[
    {
        "title": "USER FUNDS MAY GET LOCKED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_1_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When admin calls thecage function of the CollateralJoin contract, the live flag is set to zero, which means the contract is stopped. The user can repay the loan, but will not be able to exit (withdraw) assets from the CollateralJoin contract. Code Location: cage function: Listing 1: contracts/CollateralJoin.sol (Line 96) 95 function cage () external auth { 96 97 98 } live = 0; emit Cage () ; The exit function, requires contract to be live: Listing 2: contracts/CollateralJoin.sol (Line 126) 125 function exit ( address usr , uint256 wad ) external { require ( live == 1 , \" CollateralJoin / not - live \" ); 126 lmcv . pullCollateral ( collateralName , msg . sender , wad ); 127 require ( collateralContract . transfer ( usr , wad ) , \" CollateralJoin 128  / failed - transfer \" ); 129 130 } emit Exit ( usr , wad ); Test scenario: Hardhat test case: 16 Listing 3 // initial collateralJoin balance : 2 users joined with 100 expect ( await mockToken . balanceOf ( collateralJoin . address )) . to . expect ( await userLMCV . normalizedDebt ( addr1 . address )) . to . equal ( // Total value of collateral : $6000 // Total loanable amount : $3000 await userLMCV . loan ( collateralBytesList , [ fwad ( \" 50 \") , fwad ( \" expect ( await userLMCV . lockedCollateral ( addr1 . address , expect ( await userLMCV . lockedCollateral ( addr1 . address , expect ( await userLMCV . lockedCollateral ( addr1 . address , 1 it ( \" HAL -01 User collateral gets locked \" , async function () { 2 3  tokens each 4  equal ( fwad ( \" 200 \")); 5 6 7 8  100 \" ) , fwad ( \" 200 \" )] , fwad ( \" 2000 \" ) , addr1 . address ); 9 10  mockTokenBytes )). to . equal ( fwad ( \" 50 \" )); 11  mockToken2Bytes )). to . equal ( fwad ( \" 100 \" )) ; 12  mockToken3Bytes )). to . equal ( fwad ( \" 200 \" )) ; 13 14  fwad (\" 2000 \" )); 15 16  ); 17 18 19 20 21 22 23 24  100 \" ) , fwad ( \" 200 \" )] , fwad ( \" 2000 \" ) , addr1 . address ); 25 26  debt nor issued dPrime 27  mockTokenBytes )). to . equal ( fwad ( \" 0\" )) ; 28  mockToken2Bytes )). to . equal ( fwad ( \"0 \" )); 29  mockToken3Bytes )). to . equal ( fwad ( \"0 \" )); // lock join contract await collateralJoin . cage () ; expect ( await await collateralJoin . live () ). to . equal (0) ; expect ( await userLMCV . lockedCollateral ( addr1 . address , expect ( await userLMCV . lockedCollateral ( addr1 . address , expect ( await userLMCV . lockedCollateral ( addr1 . address , // repay the loan await userLMCV . repay ( collateralBytesList , [ fwad (\" 50 \" ) , fwad (\" expect ( await lmcv . totalDPrime () ). to . equal ( frad ( \" 2000 \" )) ; expect ( await lmcv . totalNormalizedDebt () ). to . equal ( fwad ( \" 2000 \" ) // validate the loan was paid - there is no locked collateral , 17 expect ( await userLMCV . normalizedDebt ( addr1 . address )) . to . equal ( expect ( await lmcv . totalDPrime () ). to . equal ( frad ( \"0 \" )) ; expect ( await lmcv . totalNormalizedDebt () ). to . equal ( fwad ( \" 0\" )) ; // try to exit from join contract let collatJoinConnect = collateralJoin . connect ( addr1 ); await expect ( collatJoinConnect . exit ( addr1 . address , fwad ( \" 100 \" ) . to . be . revertedWith ( \" CollateralJoin / not - live \" ); // balance does not change expect ( await mockToken . balanceOf ( collateralJoin . address )) . to . 30  fwad (\" 0\" )); 31 32 33 34 35 36  )) 37 38 39 40  equal ( fwad ( \" 200 \")); 41 }) ; Risk Level: Likelihood - 3 Impact - 5 Recommendation: Consider allowing users to exit when the contract is stopped (like in CollateralJoinDecimals). Remediation Plan: SOLVED: Updated the cage function to allow an admin to re-make the contract. When the administrator resumes the contract, users can withdraw their assets successfully. Reference: CollateralJoin.sol 18 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_1",
            "Severity: High"
        ]
    },
    {
        "title": "ADMINS ARE ALLOWED TO BURN USERS DPRIME TOKENS WITHOUT AUTHORIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_1_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "An administrator of the dPrime token can burn users tokens. Admin burning dPrime might break the LMCV contract as there might be less supply than recorded in the LMCV contract. Code Location: Listing 4: contracts/CollateralJoin.sol (Line 159) uint256 balance = balanceOf [ from ]; require ( balance >= value , \" dPrime / insufficient - balance \" ); 155 function burn ( address from , uint256 value ) external { 156 157 158 159 160 161 [...] if ( from != msg . sender && admins [ msg . sender ] != 1) { uint256 allowed = allowance [ from ][ msg . sender ]; Test scenario: Hardhat test scenario: Listing 5 await setupUser ( addr1 , [ \" 1000 \" , \" 1000 \" , \" 1000 \" ]) ; await userLMCV . approveMultiple ([ lmcvProxy . address , dPrimeJoin . 1 it ( \" HAL -02 admin burns user dPrime \" , async function () { 2 3  address ]) ; 4 5 6  \" ) , fwad ( \" 200 \" ) , fwad ( \" 300 \")] , fwad (\" 1000 \" )) ; // lock some collataral of each token await userLMCVProxy . createLoan ( collateralBytesList , [ fwad ( \" 100 19 expect ( await lmcv . totalNormalizedDebt () ). to . equal ( fwad ( \" 1000 \" ) expect ( await lmcv . normalizedDebt ( addr1 . address )) . to . equal ( fwad expect ( await dPrime . balanceOf ( addr1 . address )) . to . eq ( fwad (\" 990 \" expect ( await dPrime . totalSupply () ). to . eq ( fwad (\" 990 \")) ; dPrime . burn ( addr1 . address , fwad (\" 500 \")) ; expect ( await lmcv . totalNormalizedDebt () ). to . equal ( fwad ( \" 1000 \" ) expect ( await lmcv . normalizedDebt ( addr1 . address )) . to . equal ( fwad expect ( await dPrime . balanceOf ( addr1 . address )) . to . be . eq ( fwad (\" expect ( await dPrime . totalSupply () ). to . eq ( fwad (\" 490 \")) ; 7  ); 8  ( \" 1000 \")); 9 10  )); 11 12 13 14 15  ); 16  ( \" 1000 \")); 17  490 \" )); 18 19 }) ; Risk Level: Likelihood - 2 Impact - 5 Recommendation: Administrators should not have the ability to burn user tokens without approval. Remediation Plan: PENDING: The DAMfinance team stated that they are planning to implement the recommended fix with the governance module in the future. 20 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_1",
            "Severity: Medium"
        ]
    },
    {
        "title": "MULTIPLE INTEGER UNDERFLOWS IN LMCV MODULE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_1_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are multiple cases in the LMCV contract when subtracting balances without checks. Such behavior may cause the transaction to fail due to arithmetic errors (integer underflow). Code Location: The repay function does not perform boundary checks; when the user tries to repay a loan after the interest rate has changed, the transaction may fail with an arithmetic error due to underflow: Calculating the dPrime amounts and debt: Listing 6: contracts/LMCV.sol (Lines 406-409) 406 dPrime [ user ] 407 totalDPrime 408 normalizedDebt [ user ] 409 totalNormalizedDebt 410 -= normalizedDebtChange * rateMult ; -= normalizedDebtChange * rateMult ; -= normalizedDebtChange ; -= normalizedDebtChange ; Calculating new collateral amount: Listing 7: contracts/LMCV.sol (Line 416) 415 // Debit locked collateral amount and credit unlocked collateral  amount . 416 uint256 newLockedCollateralAmount = lockedCollateral [ user ][  collateralList [ i ]] -= collateralChange [ i ]; 417 uint256 newUnlockedCollateralAmount = unlockedCollateral [ user ][  collateralList [ i ]] += collateralChange [i ]; deflate function calculating protocol deficit: 21 Listing 8: contracts/LMCV.sol (Lines 522-525) address u = msg . sender ; protocolDeficit [ u] totalProtocoldeficit dPrime [ u ] totalDPrime 520 function deflate ( uint256 rad ) external { 521 522 523 524 525 526 527 528 } -= rad ; -= rad ; -= rad ; -= rad ; emit Deflate ( msg . sender , rad ); pullCollateral function updating unlocked collateral: Listing 9: contracts/LMCV.sol (Line 275) 274 function pullCollateral ( bytes32 collat , address user , uint256 wad )  external auth { 275 276 277 } unlockedCollateral [ user ][ collat ] -= wad ; emit PullCollateral ( collat , user , wad ); moveCollateral function updating unlocked collateral: Listing 10: contracts/LMCV.sol (Line 281) 279 function moveCollateral ( bytes32 collat , address src , address dst ,  uint256 wad ) external { 280 require ( approval ( src , msg . sender ) , \" LMCV / collateral move not  allowed \" ); 281 282 283 284 } unlockedCollateral [ src ][ collat ] -= wad ; unlockedCollateral [ dst ][ collat ] += wad ; emit MoveCollateral ( collat , src , dst , wad ); moveDPrime function: Listing 11: contracts/LMCV.sol (Line 292) 290 function moveDPrime ( address src , address dst , uint256 rad )  external { 22 291 require ( approval ( src , msg . sender ) , \" LMCV / dPrime move not  allowed \" ); 292 293 294 295 } dPrime [ src ] -= rad ; dPrime [ dst ] += rad ; emit MoveDPrime ( src , dst , rad ); Test scenarios: Below are the Hardhat test cases for underflow issues: Listing 12 1 Issues 2  twice (38 ms ) 3  with more than joined 4  than deposited 5 6  loan (98 ms ) HAL -03 Integer underflow in LMCV pullCollateral function - exit HAL -03 Integer underflow in LMCV pullCollateral function - exit HAL -03 Integer underflow in LMCV moveCollateral - move more HAL -03 Integer underflow in LMCV moveDPrime (62 ms ) HAL -03 Integer underflow in LMCV repay - rate updated after Source code of test cases: Listing 13 expect ( await userLMCV . unlockedCollateral ( addr1 . address , 1 it ( \" HAL -03 Integer underflow in LMCV pullCollateral function -  exit twice \" , async function () { 2 3  mockTokenBytes )). to . equal ( fwad ( \" 100 \")) ; 4 5 6 7 8 9  mockTokenBytes )). to . equal ( fwad ( \" 0\" )) ; 10 // exit from CollateralJoin let collatJoinConnect = collateralJoin . connect ( addr1 ); await collatJoinConnect . exit ( addr1 . address , fwad ( \" 100 \")) ; expect ( await userLMCV . unlockedCollateral ( addr1 . address , 23 // try to exit for the second time await expect ( collatJoinConnect . exit ( addr1 . address , fwad ( \" 100 \" ) // exit with more than joined await expect ( collatJoinConnect . exit ( addr1 . address , fwad ( \" 101 \" ) . to . be . revertedWith ( \" Arithmetic operation underflowed or . to . be . revertedWith ( \" Arithmetic operation underflowed or expect ( await userLMCV . unlockedCollateral ( addr1 . address , let collatJoinConnect = collateralJoin . connect ( addr1 ); expect ( await userLMCV . unlockedCollateral ( addr1 . address , 11 12  )) 13  overflowed outside of an unchecked block \"); 14 }) ; 15 16 it ( \" HAL -03 Integer underflow in LMCV pullCollateral function -  exit with more than joined \" , async function () { 17 18 19  mockTokenBytes )). to . equal ( fwad ( \" 100 \")) ; 20 21 22  )) 23  overflowed outside of an unchecked block \"); 24 25  mockTokenBytes )). to . equal ( fwad ( \" 100 \")) ; 26 }) ; 27 28 it ( \" HAL -03 Integer underflow in LMCV moveCollateral - move more  than deposited \" , async function () { 29 30  mockTokenBytes )). to . equal ( fwad ( \" 100 \")) ; 31  mockToken2Bytes )). to . equal ( fwad ( \" 200 \" )) ; 32  mockToken3Bytes )). to . equal ( fwad ( \" 300 \" )) ; 33 34  address , addr1 . address , fwad ( \" 200 \" )) ) 35  overflowed outside of an unchecked block \"); 36 }) ; 37 38 it ( \" HAL -03 Integer underflow in LMCV moveDPrime \" , async function  () { 39 40 await expect ( userLMCV . moveCollateral ( mockTokenBytes , addr1 . expect ( await userLMCV . unlockedCollateral ( addr1 . address , expect ( await userLMCV . unlockedCollateral ( addr1 . address , expect ( await userLMCV . unlockedCollateral ( addr1 . address , . to . be . revertedWith ( \" Arithmetic operation underflowed or await userLMCV . approve ( dPrimeJoin . address ); 24 expect ( await lmcv . totalDPrime () ). to . equal ( frad ( \" 1000 \" )) ; . to . be . revertedWith ( \" Arithmetic operation underflowed or await userLMCV . loan ([ mockTokenBytes ], [ fwad ( \" 50 \")] , fwad (\" 1000 expect ( await dPrime . balanceOf ( addr1 . address )) . to . equal ( fwad (\" 0 let dPrimeJoinConnect = dPrimeJoin . connect ( addr1 ); await expect ( dPrimeJoinConnect . exit ( addr1 . address , fwad ( \" 1001 \" // take a loan await userLMCV . loan ( collateralBytesList , [ fwad ( \" 50 \") , fwad ( \" 41  \" ) , addr1 . address ); 42 43  ))) 44  overflowed outside of an unchecked block \"); 45 46  \" )); 47 48 }) ; 49 50 it ( \" HAL -03 Integer underflow in LMCV repay - rate updated after  loan \" , async function () { 51 52 53  100 \" ) , fwad ( \" 200 \" )] , fwad ( \" 2000 \" ) , addr1 . address ); 54  ); 55  fwad (\" 2000 \" )); 56  2000 \")); 57 58 59 60 61 62  fwad (\" 100 \") , fwad ( \" 200 \" )] , fwad ( \" 2000 \") , addr1 . address )) 63  overflowed outside of an unchecked block \"); 64 }) ; // repay await expect ( userLMCV . repay ( collateralBytesList , [ fwad ( \" 50 \" ) , // update rate await lmcv . updateRate ( fray ( \" .1 \" )); expect ( await userLMCV . normalizedDebt ( addr1 . address )) . to . equal ( expect ( await lmcv . dPrime ( addr1 . address )) . to . equal ( frad ( \" 2000 \" ) expect ( await userLMCV . dPrime ( addr1 . address )). to . equal ( frad ( \" . to . be . revertedWith ( \" Arithmetic operation underflowed or Risk Level: Likelihood - 3 Impact - 3 25 Recommendation: Consider adding a validation before calculating the balances to avoid integer underflow. Remediation Plan: SOLVED: Added additional require statements to ensure that an underflow does not occur: LMCV.sol: #275, 282, 294, 409, 420, 530 26 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_1",
            "Severity: Medium"
        ]
    },
    {
        "title": "INTEGER UNDERFLOW PSM MODULE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_1_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "PSM contract may revert due to an arithmetic error caused by integer underflow when mintFee is set to a large value. Code Location: Listing 14: contracts/PSM.sol (Line 162) 158 function createDPrime ( address usr , bytes32 [] memory collateral ,  uint256 [] memory collatAmount ) external { 159 require ( collateral . length == 1 && collatAmount . length == 1 &&  collateral [0] == collateralName , \" PSM / Incorrect setup \" ); 160 uint256 collatAmount18 = collatAmount [0] *  to18ConversionFactor ; // [ wad ] 161 uint256 fee = _rmul ( collatAmount18 , mintFee ); // rmul ( wad , ray  ) = wad 162 163 164 uint256 dPrimeAmt = collatAmount18 - fee ; collateralJoin . join ( address ( this ) , collatAmount [0] , msg . sender  ); 165 [...] Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider adding a validation of maximum mintFee to avoid integer under- flow. 27 Remediation Plan: SOLVED: The require statement was added to ensure that mintFee is less than 100%. Reference: PSM.sol 28 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_1",
            "Severity: Low"
        ]
    },
    {
        "title": "CONTRACTS MIGHT LOSE ADMIN FUNCTIONALITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_1_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The deny function is not checking if there are any other active wards before setting wards[usr] = 0. If the user denies himself, when they are the only ward, the contract will lose admin functionality. Code Location: LMCV module: Listing 15: contracts/LMCVProxy.sol (Line 97) 96 function deny ( address usr ) external auth { 97 98 99 } wards [ usr ] = 0; emit Deny ( usr ); PSM module: Listing 16: contracts/PSM.sol (Line 69) 68 function deny ( address usr ) external auth { 69 70 71 } wards [ usr ] = 0; emit Deny ( usr ); dPrime module: Listing 17: contracts/dPrime.sol (Line 68) 67 function deny ( address usr ) external auth { 68 69 70 } admins [ usr ] = 0; emit Deny ( usr ); 29 CollateralJoin module: Listing 18: contracts/CollateralJoin.sol (Line 53) 52 function deny ( address usr ) external auth { 53 54 55 } wards [ usr ] = 0; emit Deny ( usr ); CollateralJoinDecimals module: Listing 19: contracts/CollateralJoinDecimals.sol (Line 36) 35 function deny ( address usr ) external auth { 36 37 38 } wards [ usr ] = 0; emit Deny ( usr ); Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider adding validation to make sure that there is at least one privileged account left. Remediation Plan: SOLVED: The ArchAdmin variable was added to the contract. The address assigned to this field cannot be removed from wards/admins mapping via administrate or deny functions, ensuring there is at least one adminis- trator on the contract. To update this address, a new ArchAdmin must be set; then the address can be removed from admins mapping. Reference: 30  LMCV.sol  LMCVProxy.sol  PSM.sol  dPrime.sol  CollateralJoin.sol  CollateralJoinDecimals.sol 31 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_1",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING PAUSE/UNPAUSE FUNCTIONALITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_1_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In case a hack occurs, or an exploit is discovered, the team should be able to pause functionality until the necessary changes are made to the system. To use a THORchain example again, the team behind THOR chain noticed an attack was going to occur well before the system transferred funds to the hacker. shut the system down fast enough (According to the incident report). However, they were unable to In case of the contracts in scope, only LMCV and LMCVProxy can be stopped/resumed. Other contracts can only be disabled by the cage func- tion (CollateralJoin and CollateralJoinDecimals) or do not have such possibility at all (PSM, dPrimeJoin). Risk Level: Likelihood - 2 Impact - 3 Recommendation: Pause functionality on the contract would have helped secure the funds quickly in an emergency. Remediation Plan: SOLVED: The cage function was modified, and the setLive function was added to the contracts. Now all contracts except dPrime and dPrimeJoin can be stopped/resumed in case of an attack.  CollateralJoin.sol 32  CollateralJoinDecimals.sol  PSM.sol 33 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_1",
            "Severity: Low"
        ]
    },
    {
        "title": "IMPROPER ROLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_1_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The smart contracts, in scope, do not implement granular access control. All the privileged functionality is assigned to one role. This could lead to serious consequences if, for example, a malicious admin decides to take over the platform. Risk Level: Likelihood - 2 Impact - 3 Recommendation: Halborn recommends that a more granular access control policy is enforced. For instance, the following user roles could be set:  protocolAdmin - responsible for setting loans, fees, debt ceiling, etc.  collateralAdmin - used for managing collateral-related functions  keepers/oracle - used for updating prices/rates  owner/admin - used for most sensitive actions like adding/removing admins Remediation Plan: RISK ACCEPTED: The DAMfinance team accepted the risk of this finding and stated that in this role-based admin structure, only smart contracts would have access to specific roles, and a person-controlled owner address would be able to set all of these roles. Since a smart contract can only call functions it has interfaces for and admin access to in this setup, and an owner-level admin hack would have the ability to set itself as any 34 other level admin, this does not seem like a useful check. 35 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_1",
            "Severity: Low"
        ]
    },
    {
        "title": "DIVISION BY ZERO IN ISWITHINCREDITLIMIT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_1_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The isWithinCreditLimit function does not handle leveraged-only collat- eral properly. When leveraged-only collateral is passed, and the credit value exceeds the collateral value, the transaction fails with a Division or modulo division by zero error. Code Location: LMCV module: Listing 20: contracts/LMCV.sol (Line 603) 575 function isWithinCreditLimit ( address user , uint256 rate ) private  view returns ( bool ) { 576 577 578 579 580 581 582 bytes32 [] storage lockedList = lockedCollateralList [ user ]; uint256 creditLimit uint256 leverTokenCreditLimit uint256 noLeverageTotal uint256 leverageTotal for ( uint256 i = 0; i < lockedList . length ; i ++) { = 0; // [ rad ] = 0; // [ rad ] = 0; // [ wad ] = 0; // [ rad ] Collateral memory collateralData = CollateralData [  lockedList [ i ]]; 583 584 if ( lockedCollateral [ user ][ lockedList [ i ]] > collateralData .  dustLevel ){ 585 uint256 collateralValue = lockedCollateral [ user ][  lockedList [ i ]] * collateralData . spotPrice ; // wad * ray -> rad 586 587 588 if (! collateralData . leveraged ){ creditLimit += _rmul ( collateralValue ,  collateralData . creditRatio ); 589 590 591 592 noLeverageTotal += collateralValue / RAY ; } else { leverageTotal += collateralValue ; leverTokenCreditLimit += _rmul ( collateralValue ,  collateralData . creditRatio ); 36 593 594 595 596 597 } } } // If only leverage tokens exist , just return their credit  limit 598 // Keep credit ratio low on levered tokens (60% or lower ) to  incentivize having non levered collateral in the vault 599 if ( noLeverageTotal == 0 && leverageTotal > 0 &&  leverTokenCreditLimit >= normalizedDebt [ user ] * rate ){ 600 601 602 603 return true ; } uint256 leverageMultiple = noLeverageTotal == 0 &&  leverageTotal == 0 ? RAY : RAY + leverageTotal / noLeverageTotal ; 604 605 if ( _rmul ( creditLimit , leverageMultiple ) >= ( normalizedDebt [  user ] * rate )) { 606 607 608 609 } return true ; } return false ; Risk Level: Likelihood - 3 Impact - 2 Recommendation: Consider updating a condition determining the amount of leveraged col- lateral. Remediation Plan: SOLVED: The condition in the isWithinLimit function of the LMCV.sol contract was modified to handle correctly limits for leveraged tokens. Reference: LMCV.sol 37 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_1",
            "Severity: Low"
        ]
    },
    {
        "title": "EDITCOLLATERALLIST BEHAVIOUR MAY BE MISLEADING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_1_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "takes function arguments: editCollateralList three The collateralName, bool accepted, uint256 position. When adding collateral, only collateraName is used, and position is ignored. When removing collateral, only position is used; the function is not validated if a given collateralName is located in a specified position. Moreover, the function does not check if the given collateral is already added to the list. bytes32 Code Location: LMCV module: Listing 21: contracts/LMCV.sol (Line 238) 575 function editCollateralList ( bytes32 collateralName , bool accepted ,  uint256 position ) external auth { 576 577 578 579 580 581 } if ( accepted ){ CollateralList . push ( collateralName ); } else { deleteElement ( CollateralList , position ); } Risk Level: Likelihood - 2 Impact - 2 38 Recommendation: Consider changing function logic to remove collateral by name, or split it into two separate functions. Remediation Plan: SOLVED: The editCollateralList function was removed. Reference: LMCV.sol 39 3.10 (HAL-10) MISSING ZERO ADDRESS CHECK - LOW ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_1",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNLIMITED MINTING BY REUSING FAILED HYPERLANE MESSAGES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_3_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It is possible to transfer dPrime tokens across chains using the If minting the tokens on the dPrimeConnectorHyperlane contract. destination chain fails, then the program stores the failed transaction in a mapping. It is possible to manually retry the failed transactions The function by calling the retry function on the destination chain. reads the failed transaction details from a mapping and mints the specified tokens for the receiver. However, the function does not update the mapping after a successfully retried transaction, so it is possible to mint as many tokens as desired by calling the retry function multiple times with the data of the failed transaction. Code Location: Listing 1: hyperlane/dPrimeConnectorHyperlane.sol (Lines 144,145) 141 function retry ( uint32 _origin , address _recipient , uint256 _nonce )  external { 142 143 144 145 146 147 uint256 amount = failedMessages [ _origin ][ _recipient ][ _nonce ]; try dPrimeLike ( dPrimeContract ). mint ( _recipient , amount ) { emit ReceivedTransferRemote ( _origin , _recipient , amount ); } catch { emit FailedTransferRemote ( _origin , _recipient , nonce ,  amount ); 148 149 } } 14 Proof of Concept: As proof of concept, a failed Hyperlane message was created in a local test environment. Then the same failed message was used multiple times to mint dPrime tokens for the receiver. It is noted that it is possible to mint as many tokens as desired using the failed message. Risk Level: Likelihood - 5 Impact - 5 Recommendation: The retry function should delete the successfully retried messages from the failedMessages mapping. 15 Remediation Plan: SOLVED: The DAMfinance team solved the issue in commit cfc13a8 by deleting the successfully retried messages from the failedMessages mapping. 16 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_3",
            "Severity: Critical"
        ]
    },
    {
        "title": "MISMATCHING DATA LOCATION DURING INHERITANCE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_3_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was identified that the dPrimeConnectorHyperlane contract was incom- patible with the latest Hyperlane protocol and might not work with new versions of Hyperlane Inbox contracts, which can lead to users losing their dPrime tokens during cross-chain transfers. The dPrimeConnectorHyperlane contract is inherited from the Hyperlane Router abstract contract. When receiving a message from another chain, the handle function is called by the corresponding Hyperlane Inbox contract. This function calls the internal _handle function that can be overridden in the derived contracts. The following code is an example from the Hyperlane Router version 0.5.0: Listing 2: 85,95) @hyperlane-xyz/app/contracts/Router.sol (0.5.0) (Lines ) external virtual override onlyInbox onlyRemoteRouter ( _origin function handle ( uint32 _origin , bytes32 _sender , bytes memory _message 82 83 84 85 86  , _sender ) { 87 88 89 90 91 92 93 94 95 96 } // TODO : callbacks on success / failure _handle ( _origin , _sender , _message ); // ============ Virtual functions ============ function _handle ( uint32 _origin , bytes32 _sender , bytes memory _message ) internal virtual ; 17 The _handle function was overridden in the dPrimeConnectorHyperlane con- tract: Listing 3: hyperlane/dPrimeConnectorHyperlane.sol (Line 123) 120 121 122 123 124 function _handle ( uint32 _origin , bytes32 , bytes memory _message ) internal override alive { However, from Hyperlane version 0.5.1, the storage location of the _message parameter was changed from memory to calldata: Listing 4: 85,95) @hyperlane-xyz/app/contracts/Router.sol (0.5.1) (Lines function handle ( uint32 _origin , bytes32 _sender , bytes calldata _message ) external virtual override onlyInbox onlyRemoteRouter ( _origin 82 83 84 85 86  , _sender ) { 87 88 89 90 91 92 93 94 95 96 } // TODO : callbacks on success / failure _handle ( _origin , _sender , _message ); // ============ Virtual functions ============ function _handle ( uint32 _origin , bytes32 _sender , bytes calldata _message ) internal virtual ; A bug concerning data location during inheritance was identified in Solidity on May 17, 2022. According to the Solidity team, the calldata pointer in these cases is interpreted as a memory pointer which results in reading invalid data from memory. It is also noted that the current protocol is not configured with a fixed version of Hyperlane dependencies. In the package.json configuration 18 file, floating versions are used, which means that the contract might be deployed with an incompatible Hyperlane messaging protocol: Listing 5: package.json (Lines 25,26) 23 24 25 26 27 28 29 30 \" dependencies \": { \" @chainlink / contracts \" : \" ^0.4.1 \" , \" @hyperlane - xyz / app \": \" ^0.5.0 \" , \" @hyperlane - xyz / sdk \": \" ^0.5.0 \" , \" @layerzerolabs / solidity - examples \": \" ^0.0.4 \" , \" @openzeppelin / contracts \" : \" ^4.5.0 \" , \" solc \": \" ^0.8.15 \" } Proof of Concept: As proof of concept, the dPrimeConnectorHyperlane contract was deployed with Hyperlane version 0.5.0. It was possible to mint tokens by calling the handle function: 19 The contract was also deployed using the Hyperlane version 0.5.1. Calling the handle function with the same parameters resulted in an error and corrupted data: Note that it is not possible to recover the tokens from corrupted data using the retry function of the dPrimeConnectorHyperlane contract. Risk Level: Likelihood - 4 Impact - 4 Recommendation: The dPrimeConnectorHyperlane contract should be updated to work with the latest version of Hyperlane contracts. Before deployment, DAMfinance team should ensure the dPrimeConnectorHyperlane contract is compatible with the Hyperlane Inbox contract deployed on the same chain. It is also recommended to fix the versions of the external contracts in the package.json configuration file to versions that have been tested thoroughly with the protocol. 20 Remediation Plan: SOLVED: The DAMfinance team solved the issue in commit c19b217 by changing the storage location of the _message parameter from memory to calldata and fixing the versions of the Hyperlane contracts in the package.json configuration file. 21 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_3",
            "Severity: High"
        ]
    },
    {
        "title": "DENIAL OF SERVICE USING MINT DELAY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_3_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The new version of the dPrime token contract was extended with an addi- tional security feature that prevents transferring funds for a certain The delay allows the number of blocks after a cross-chain transfer. DAMfinance team team to pause the contract in case the cross-chain mes- saging is compromised to limit the impact of such security incidents. However, a malicious actor can also exploit this behavior to manipu- late the market during volatile times or perform a griefing attack by The likelihood of continuously sending tokens to the targeted users. such attacks is increased because it is enough to send only one token to prevent the transfer of the targeted users funds temporarily. Code Location: Listing 6: dPrime.sol (Line 192) 191 function mintAndDelay ( address to , uint256 value ) external auth  { 192 transferBlockRelease [ to ] = block . number +  transferBlockWait ; 193 194 } _mint ( to , value ); Listing 7: dPrime.sol (Line 123) 121 function transferFrom ( address from , address to , uint256 value )  external alive returns ( bool ) { 122 require ( to != address (0) && to != address ( this ) , \" dPrime /  invalid - address \"); 123 require ( block . number > transferBlockRelease [ from ], \" dPrime  / transfer too soon after cross - chain mint \" ); 22 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Adding a configurable threshold to the mintAndDelay function is recom- mended. The function should be able to mint tokens below the set threshold directly. The threshold and the length of the delay should be configured based on the specific blockchain and actual market characteristics to make it more expensive for an attacker to perform a denial of service attack while limiting the potential damage in case the cross-chain messaging of the protocol is compromised. Remediation Plan: SOLVED: The DAMfinance team solved the issue in commit e76f394 by adding a configurable threshold to the mintAndDelay function. 23 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_3",
            "Severity: Medium"
        ]
    },
    {
        "title": "INCOMPLETE GUARDIAN IMPLEMENTATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_3_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was identified that in the dPrimeGuardian contract, it is not possible to add any values to the pipeAddresses mapping. And therefore, in case of an incident, the dPrimeGuardian contract cannot be used to take back the admin privileges of any insecure connector from the dPrime token because the removeConnectorAdmin reads the required addresses from the mapping. Code Location: Listing 8: dPrimeGuardian.sol (Line 26) 25 function removeConnectorAdmin ( bytes32 pipeName ) external auth { 26 27 28 } dPrimeLike ( dPrimeContract ). deny ( pipeAddresses [ pipeName ]) ; emit HaltedPipe ( pipeName ); Risk Level: Likelihood - 2 Impact - 4 Recommendation: Modify the contract to allow the removeConnectorAdmin function to be used. Remediation Plan: SOLVED: The DAMfinance team solved the issue in commit cfc13a8 by adding the setPipeAddress function to the dPrimeGuardian contract. 24 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_3",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING EVENTS FOR RELEVANT OPERATIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_3_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The connector and guardian contracts are inherited from the AuthAdmin contract. It was identified that in this contract, the cage function did not emit any events. As a result, blockchain monitoring systems might not be able to timely detect suspicious behaviors related to the cage function. Note that the Cage event declared in the dPrimeConnectorHyperlane contract is not used and could be removed from the contract. Risk Level: Likelihood - 2 Impact - 2 Recommendation: Adding events for all important operations is recommended to help monitor the contracts and detect suspicious behavior. A monitoring system that tracks relevant events would allow the timely detection of compromised system components. Remediation Plan: SOLVED: The DAMfinance team solved the issue in commit cfc13a8 by emitting the event in the cage function of the AuthAdmin contract and removing the redundant Cage event from the dPrimeConnectorHyperlane contract. 25 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_3",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO VALUE CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_3_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was identified that within the code, several functions were lacking zero address or zero value validation on important parameters. Set- ting invalid parameters in the examples below might result in loss of funds, waste of gas, lose of administrative controls, or reverting during important operations: Missing zero address checks: LayerZero/dPrimeConnectorLZ.sol: - Line 24 constructor is missing zero-address checks for _lzEndpoint, _dPrimeContract. Line initialize hyperlane/dPrimeConnectorHyperlane.sol: - 71 _abacusConnectionManager, . - Line 95 transferRemote is missing zero-address check for _recipient. is _interchainGasPaymaster, for dPrimeContract zero-address missing checks dPrimeGuardian.sol - Line 16: constructor is missing zero-address check for _dPrimeContract. It is also recommended to validate the following parameters and variables: hyperlane/dPrimeConnectorHyperlane.sol: - Line 95 transferRemote is missing zero value checks for _destination, _amount. - Line 142 retry is missing zero-value check for amount. Risk Level: Likelihood - 1 Impact - 3 26 Recommendation: It is recommended to review the above list of functions and add checks where applicable. Remediation Plan: SOLVED: The DAMfinance team solved the issue in commit cfc13a8 by adding checks where appropriate. 27 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_3",
            "Severity: Low"
        ]
    },
    {
        "title": "REVERT STRING SIZE OPTIMIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_3_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Shortening the revert strings to fit within 32 bytes will decrease de- ployment time gas and reduce runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one addi- tional mstore, along with additional overhead to calculate memory offset, etc. Recommendation: Shorten the revert strings to fit within 32 bytes. That will affect gas optimization. Remediation Plan: ACKNOWLEDGED: The DAMfinance team acknowledged this finding. 28 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_3",
            "Severity: Informational"
        ]
    },
    {
        "title": "STATE VARIABLES MISSING IMMUTABLE MODIFIER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_3_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The following state variables are missing the immutable modifier: dPrimeGuardian.sol - Line 16: address public dPrimeContract; dPrimeConnectorLZ.sol - Line 19: address public dPrimeContract; Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to add the immutable modifier to the state variables mentioned. Remediation Plan: SOLVED: The DAMfinance team solved the issue in commits e1a2d28 and cfc13a8 by adding the immutable modifier to the state variables. 29 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_3",
            "Severity: Informational"
        ]
    },
    {
        "title": "USER FUNDS MAY GET LOCKED IN JOIN CONTRACTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The RewardJoin and StakeJoin contracts have possibility to be stopped/dis- abled by the administrator using cage function. When the administrator calls the cage function, user funds will get locked as the users will not be able to call the exit function successfully and get the staked and rewards tokens. The contracts also do not implement a possibility to start the contract again (setting the live flag to 1), so all funds will get locked inside the contract. Code Location: cage function: Listing 1: contracts/staking/RewardJoin.sol (Line 71) 70 function cage () external auth { 71 72 73 } live = 0; emit Cage () ; staking/RewardJoin.sol Listing 2: contracts/staking/RewardJoin.sol (Line 100) 99 function exit ( address usr , uint256 wad ) external { require ( live == 1 , \" CollateralJoin / not - live \" ); stakingVault . pullRewards ( collateralName , msg . sender , wad ); require ( collateralContract . transfer ( usr , wad ) , \" RewardJoin / 100 101 102  failed - transfer \"); 103 104 } emit Exit ( usr , wad ); 16 staking/StakeJoin.sol Listing 3: contracts/staking/StakeJoin.sol (Line 98) 97 function exit ( address usr , uint256 wad ) external { require ( live == 1 , \" CollateralJoin / not - live \" ); 98 stakingVault . pullStakingToken ( msg . sender , wad ); 99 require ( collateralContract . transfer ( usr , wad ) , \" CollateralJoin 100  / failed - transfer \" ); 101 102 } emit Exit ( usr , wad ); Test scenario: Example Hardhat test cases: Listing 4 // User stakes tokens let userStakeJoin = stakeJoin . connect ( addr1 ); await userStakeJoin . join ( addr1 . address , fwad ( \" 1000 \")) ; 1 it ( \" HAL -01 User staked tokens are locked ( StakeJoin )\" , async  function () { 2 3 4 5 6 7 8 9 10 11 12 }) ; // User can 't exit , collateral is locked in the contract await expect ( userStakeJoin . exit ( addr1 . address , fwad ( \" 500 \"))) // Contract is stopped await stakeJoin . cage () ; . to . be . revertedWith ( \" CollateralJoin / not - live \" ); Listing 5 // User stakes tokens let userStakeJoin = stakeJoin . connect ( addr1 ); await userStakeJoin . join ( addr1 . address , fwad ( \" 1000 \")) ; 1 it ( \" HAL -01 User rewards are locked ( RewardsJoin ) \" , async function  () { 2 3 4 5 6 7 // User stakes tokens in the vault userSV = stakingVault . connect ( addr1 ); 17 await userSV . stake ( fwad ( \" 800 \") , addr1 . address ); // Rewards are added await fooJoin . join ( fwad ( \" 1000 \" )) ; // User stakes 0 to claim rewards await userSV . stake ( \"0 \" , addr1 . address ); 8 9 10 11 12 13 14 15 16 17 18 19 20 21  1000000000000000000000 \" )) 22 23 }) ; // Contract is stopped await fooJoin . cage () ; // User tries to exit rewards join contract let userFooJoin1 = fooJoin . connect ( addr1 ); await expect ( userFooJoin1 . exit ( addr1 . address , \" . to . be . revertedWith ( \" CollateralJoin / not - live \" ); Risk Level: Likelihood - 3 Impact - 5 Recommendation: Consider allowing users to call exit when the contract is not live, or add a possibility to make the contract live again. Remediation Plan: SOLVED: The cage function in the RewardJoin and StakeJoin contracts was updated, adding a possibility to make the contract live again. Reference: RewardJoin.sol and StakeJoin.sol 18 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_2",
            "Severity: High"
        ]
    },
    {
        "title": "USERS MAY NOT BE ABLE TO UNSTAKE OR CLAIM REWARDS WHEN stakedAmountLimit IS DECREASED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The StakingVault contract defines a maximum amount allowed to stake in the stakedAmountLimit variable. An administrator can modify this value. However, the setStakedAmountLimit function does not perform any validation on its parameter. It is possible to decrease stakedAmountLimit to a value lower than the currently staked amount. In such a situation, some users may not be able to unstake or claim their rewards because of the require statement in the stake function, enforcing that stakedAmount must be lower or equal to the limit. Example scenario:  stakedAmountLimit is set to 5000  User 1 stakes 4000 tokens  User 2 stakes 1000 tokens  Administrator decreases stakedAmountLimit to 3000  User 2 cant unstake/claim rewards as transaction gets reverted due to require statement In the above scenario, User 2 wont be able to unstake or claim the rewards until User 1 decreases his staked amount. Code Location: setStakedAmountLimit setter: 19 Listing 6: contracts/staking/StakingVault.sol (Line 158) 157 function setStakedAmountLimit ( uint256 wad ) external auth { 158 159 160 } stakedAmountLimit = wad ; emit StakedAmountLimit ( wad ); Unstaking may not be possible, because of the require statement in stake function, enforcing that current stakedAmount + new staked amount is lower than the limit: Listing 7: contracts/staking/StakingVault.sol (Line 240) 231 function stake ( int256 wad , address user ) external stakeAlive { //  [ wad ] 232 require ( approval ( user , msg . sender ) , \" StakingVault / Owner must  consent \" ); 233 require ( getOwnedDDPrime ( user ) >= lockedStakeable [ user ] *  stakedMintRatio , \" StakingVault / Need to own ddPRIME to cover locked  amount \" ); 234 235 236 237 // 1. Add locked tokens uint256 prevStakedAmount unlockedStakeable [ user ]  wad ); = lockedStakeable [ user ]; // [ wad ] = _sub ( unlockedStakeable [ user ], 238  ; 239 240 lockedStakeable [ user ] = _add ( lockedStakeable [ user ], wad ) stakedAmount require ( stakedAmount <= stakedAmountLimit , \" StakingVault / = _add ( stakedAmount , wad );  Cannot be over staked token limit \" ); 241 [...] Test scenario: Hardhat test case: Listing 8 1 it ( \" HAL -02 User may not be able to unstake / claim rewards when  stakedAmountLimit is decreased \" , async function () { 2 20 // User 1 and 2 add 10000 stakeable coin with join contract await userStakeJoin . join ( addr1 . address , fwad ( \" 10000 \" )) ; await userStakeJoin2 . join ( addr2 . address , fwad (\" 10000 \" )) ; // User1 stakes 4000 of tokens ( stakedAmount < limit ) await userSV . stake ( fwad ( \" 4000 \" ) , addr1 . address ); // assert balances expect ( await stakingVault . lockedStakeable ( addr1 . address )) . to . expect ( await stakingVault . unlockedStakeable ( addr1 . address )). to expect ( await stakingVault . ddPrime ( addr1 . address )) . to . equal ( // User2 stakes 1000 of tokens await userSV2 . stake ( fwad ( \" 1000 \" ) , addr2 . address ); ( stakedAmount == limit ) // assert balances expect ( await stakingVault . lockedStakeable ( addr2 . address )) . to . expect ( await stakingVault . unlockedStakeable ( addr2 . address )). to expect ( await stakingVault . ddPrime ( addr2 . address )) . to . equal ( // Foo Rewards get added await fooJoin . join ( fwad ( \" 50 \" )); // limit is changed to 3000 await stakingVault . setStakedAmountLimit ( fwad ( \" 3000 \")) ; // user 2 stakes 0 to claim rewards - transaction fails await expect ( userSV2 . stake ( fwad (\" 0\" ) , addr2 . address )) . to . be . revertedWith ( \" StakingVault / Cannot be over staked // user 2 tries to unstake -1000 tokens to claim rewards - await expect ( userSV2 . stake ( fwad (\" -1000 \" ) , addr2 . address )) . to . be . revertedWith ( \" StakingVault / Cannot be over staked 3 4 5 6 7 8 9 10 11  equal ( fwad ( \" 4000 \" )) ; 12  . equal ( fwad ( \" 6000 \" )); 13  frad (\" 4000 \" )); 14 15 16 17 18 19  equal ( fwad ( \" 1000 \" )) ; 20  . equal ( fwad ( \" 9000 \" )); 21  frad (\" 1000 \" )); 22 23 24 25 26 27 28 29 30 31  token limit \" ); 32 33  transaction fails 34 35  token limit \" ); 36 21 // User 1 stakes 0 to claim rewards - transaction fails , await expect ( userSV . stake ( fwad ( \"0 \") , addr1 . address )) . to . be . revertedWith ( \" StakingVault / Cannot be over staked 37  without reducing staked tokens 38 39  token limit \" ); 40 41 42 43 44 45  . to . equal ( fwad ( \" 20 \")) ; 46  . to . equal (0) ; 47  fooBytes )). to . equal ( fwad ( \" 40 \" )) ; 48  fooBytes )). to . equal (0) ; 49 50 51 52  . to . equal ( fwad ( \" 10 \")) ; 53  fooBytes )). to . equal ( fwad ( \" 10 \" )) ; 54 }) ; // User 1 reduces staked tokens to claim rewards await userSV . stake ( fwad ( \" -2000 \" ) , addr1 . address ); // assert reward balances expect ( await stakingVault . rewardDebt ( addr1 . address , fooBytes )) expect ( await stakingVault . rewardDebt ( addr2 . address , fooBytes )) expect ( await stakingVault . withdrawableRewards ( addr1 . address , expect ( await stakingVault . withdrawableRewards ( addr2 . address , // Now user 2 is able to claim rewards / unstake await userSV2 . stake ( fwad ( \"0 \" ) , addr2 . address ); expect ( await stakingVault . rewardDebt ( addr2 . address , fooBytes )) expect ( await stakingVault . withdrawableRewards ( addr2 . address , Risk Level: Likelihood - 2 Impact - 5 Recommendation: One of the solutions might be to add a check in the setStakedAmountLimit function and not allow decreasing a limit below the currently staked amount. 22 Remediation Plan: SOLVED: The require statement in the stake function was modified to always allow a negative amount (withdraw request) - in this way, the user will always be able to withdraw the amount staked at 0. When the user tries to withdraw more than staked, the transaction is reverted in the _add function. Reference: StakingVault.sol 23 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_2",
            "Severity: Medium"
        ]
    },
    {
        "title": "INTEGER UNDERFLOWS IN STAKINGVAULT MODULE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are multiple instances in the StakingVault contract when subtracting balances is done without checks. Such behavior may cause the transaction to fail due to arithmetic errors (integer underflow), for example, when the user balance is lower than the requested withdrawal. Code Location: The pullStakingToken function is not verifying balance before subtraction in staking/StakingVault.sol: Listing 9: contracts/staking/StakingVault.sol (Line 201) 200 function pullStakingToken ( address user , uint256 wad ) external auth  { 201 202 203 } unlockedStakeable [ user ] -= wad ; emit PullStakingToken ( user , wad ); The pullRewards function is not checking if user has enough tokens to move in staking/StakingVault.sol: Listing 10: staking/StakingVault.sol (Line 222) 220 function pullRewards ( bytes32 rewardToken , address usr , uint256 wad  ) external auth { 221 222 223 224 225 } RewardTokenData storage tokenData = RewardData [ rewardToken ]; withdrawableRewards [ usr ][ rewardToken ] tokenData . totalRewardAmount emit PullRewards ( rewardToken , usr , wad ); -= wad ; -= wad ; The liquidationWithdraw does not check if liquidator has enough ddPrime 24 in staking/StakingVault.sol: Listing 11: staking/StakingVault.sol (Line 263) 254 function liquidationWithdraw ( address liquidator , address  liquidated , uint256 rad ) external { 255 require ( approval ( liquidator , msg . sender ) , \" StakingVault / Owner  must consent \"); 256 257 258 // 1. Check that liquidated does not own ddPrime they claim to require ( getOwnedDDPrime ( liquidated ) <= lockedStakeable [  liquidated ] * stakedMintRatio - rad , \" StakingVault / Account must  not have ownership of tokens \" ); 259 uint256 liquidatedAmount = rad / stakedMintRatio ; //  rad / ray = wad 260 uint256 prevStakedAmount = lockedStakeable [ liquidated  ]; // [ wad ] 261 262 263 264 265 [...] // 2. Take ddPrime from liquidator 's account to repay ddPrime [ liquidator ] totalDDPrime -= rad ; -= rad ; Test scenario: Example Hardhat test cases: Listing 12 // User tries to exit from stake join contract without staking 1 it ( \" HAL -03 Integer underflow - withdraw more than staked \" , async  function () { 2  anything before 3 4 5  overflowed outside of an unchecked block \"); 6 }) ; let userStakeJoin = stakeJoin . connect ( addr1 ); await expect ( userStakeJoin . exit ( addr1 . address , fwad ( \" 500 \"))) . to . be . revertedWith ( \" Arithmetic operation underflowed or 25 Listing 13 // Rewards are added await fooJoin . join ( fwad ( \" 1000 \" )) ; // User stakes tokens in the vault userSV = stakingVault . connect ( addr1 ); await userSV . stake ( fwad ( \" 800 \") , addr1 . address ); // User joins stake let userStakeJoin = stakeJoin . connect ( addr1 ); await userStakeJoin . join ( addr1 . address , fwad ( \" 1000 \")) ; 1 it ( \" HAL -03 Integer underflow - withdraw more than withdrawable (  RewardJoin ) \" , async function () { 2 3 4 5 6 7 8 9 10 11 12 13 14 15  fooBytes )). to . equal ( fwad ( \" 1000 \" )) ; 16 17  than withdrawable 18 19 20  overflowed outside of an unchecked block \"); 21 }) ; // User stakes 0 to claim rewards await userSV . stake ( \"0 \" , addr1 . address ); expect ( await stakingVault . withdrawableRewards ( addr1 . address , let userFooJoin1 = fooJoin . connect ( addr1 ); await expect ( userFooJoin1 . exit ( addr1 . address , fwad (\" 10000 \" )) ) // User tries to exit reward join contract with more tokens . to . be . revertedWith ( \" Arithmetic operation underflowed or Listing 14 expect ( await lmcv . lockedCollateral ( addr4 . address , blorpBytes )) // Sanity checks expect ( await lmcv . lockedCollateral ( addr4 . address , ddPrimeBytes 1 it ( \" HAL -03 Integer underflow - Liquidator doesn 't hold enough  ddPrime \" , async function () { 2 3  )). to . equal ( fwad ( \" 1000 \" )) ; 4  . to . equal ( fwad ( \" 1000 \")) ; 5 6 7  equal ( frad ( \" 1000 \" )) ; 8  ( \" 100 \" )); 9 expect ( await ddPrime . balanceOf ( addr4 . address )) . to . equal (0) ; expect ( await stakingVault . ddPrime ( addr4 . address )) . to . equal (0) ; expect ( await stakingVault . getOwnedDDPrime ( addr4 . address )) . to . expect ( await lmcv . normalizedDebt ( addr4 . address )) . to . equal ( fwad 26 // Assert rewards expect ( await stakingVault . withdrawableRewards ( addr4 . address , expect ( await stakingVault . rewardDebt ( addr4 . address , fooBytes )) // User 4 stakes 1000 to claim rewards await userStakeJoin4 . join ( addr4 . address , fwad (\" 1000 \" )) ; await userSV4 . stake ( fwad ( \" 1000 \" ) , addr4 . address ); // Foo Rewards get added await fooJoin . join ( fwad ( \" 20 \" )); 10 11 12 13 14 15  fooBytes )). to . equal ( \"0 \" ); 16  . to . equal ( fwad ( \" 20 \")) ; 17 18 19 20 21 22 23 24  bypasses auction functionality ) 25  addr4 . address , addr3 . address , owner . address ); 26 27 28  address , frad ( \" 1000 \" )) ) 29  overflowed outside of an unchecked block \"); 30 }) ; // User 4 stakes 0 to claim rewards await userSV4 . stake ( fwad ( \"0 \" ) , addr4 . address ); // User 3 calls liquidationWithdraw not having enough ddPrime await expect ( userSV3 . liquidationWithdraw ( addr3 . address , addr4 . . to . be . revertedWith ( \" Arithmetic operation underflowed or // User 1 gets liquidated , ddPrime is transferred to user 3 ( await lmcv . seize ([ ddPrimeBytes ], [ fwad ( \" 1000 \" )], fwad (\" 100 \" ) , Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider adding a validation before calculating the balances to avoid integer underflow and return an appropriate error message to the user. 27 Remediation Plan: SOLVED: Additional require statements were added, to ensure underflow does not occur: StakingVault.sol: #216, 238, 280 28 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_2",
            "Severity: Medium"
        ]
    },
    {
        "title": "DATA RETURNED FROM CHAINLINK IS NOT VALIDATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The getLatestPrice function in the contract ChainlinkClient.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID nor timeStamp, which may result in stale prices. If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g., Chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the Chainlink system), consumers of this contract may continue using outdated stale data (if oracles are unable to submit no new round is started). Code Location: Listing 15: contracts/lmcv/ChainlinkClient.sol (Line 26) ( 18 function getLatestPrice () public view returns ( int256 ) { 19 20 21 22 23 24 25 26 27 } /* uint80 roundID */ , int256 price , /* uint startedAt */ , /* uint timeStamp */ , /* uint80 answeredInRound */ ) = priceFeed . latestRoundData () ; return price ; Risk Level: Likelihood - 2 Impact - 4 29 Recommendation: Consider adding checks on the return data such as price > 0, timestamp != 0 and answeredInRound >= roundID. Add a proper revert message if the price is stale or the round is incomplete. Remediation Plan: SOLVED: Validation of data returned from Chainlink was added. Reference: ChainlinkClient.sol 30 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_2",
            "Severity: Medium"
        ]
    },
    {
        "title": "ADMINISTRATORS ARE ALLOWED TO BURN USERS DDPRIME TOKENS WITHOUT AUTHORIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "An administrator of the ddPrime token can burn users tokens. Such action might break the StakingVault contract, as it keeps its copy of ddPrime balances. Code Location: ddPrime.sol Listing 16: staking/ddPrime.sol (Line 159) uint256 balance = balanceOf [ from ]; require ( balance >= value , \" ddPrime / insufficient - balance \" ); 155 function burn ( address from , uint256 value ) external { 156 157 158 159 160 161 162 uint256 allowed = allowance [ from ][ msg . sender ]; if ( allowed != type ( uint256 ). max ) { if ( from != msg . sender && admins [ msg . sender ] != 1) { require ( allowed >= value , \" ddPrime / insufficient -  allowance \"); 163 164 165 166 167 } 168 169 [...] unchecked { allowance [ from ][ msg . sender ] = allowed - value ; } } 31 Test scenario: Hardhat test scenario: Listing 17 // User 1 joins and stakes 1000 tokens await userStakeJoin . join ( addr4 . address , fwad ( \" 10000 \" )) ; await userSV4 . stake ( fwad ( \" 1000 \" ) , addr4 . address ); // Approve and exit with ddPrime await userSV4 . approve ( ddPrimeJoin . address ); userDDPrimeJoin = ddPrimeJoin . connect ( addr4 ); await userDDPrimeJoin . exit ( addr4 . address , fwad ( \" 1000 \" )) ; 1 it ( \" HAL -05 Administrator burns users ddPrime \" , async function () { 2 3 4 5 6 7 8 9 10 11 12 13 14  1000 \")); 15 16 17 18 19 20  500 \" )); 21 }) ; // Assert balance expect ( await stakingVault . ddPrime ( addr4 . address )) . to . equal (0) ; expect ( await ddPrime . balanceOf ( addr4 . address )) . to . equal ( fwad ( \" // Assert balance expect ( await ddPrime . balanceOf ( addr4 . address )) . to . equal ( fwad ( \" // Administrator burns ddPrime await ddPrime . burn ( addr4 . address , fwad ( \" 500 \" )) ; Risk Level: Likelihood - 2 Impact - 5 Recommendation: Administrator should not have an ability to burn user tokens, without approval. 32 Remediation Plan: PENDING: The DAMfinance team stated that they plan to implement the recommended fix with the governance module in the future. 33 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_2",
            "Severity: Medium"
        ]
    },
    {
        "title": "CONTRACTS MIGHT LOSE ADMINISTRATOR FUNCTIONALITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The deny function is not checking if there are any other active wards The contract will lose administrator before setting wards[usr] = 0. functionality when the only ward user calls this function. Code Location: OSM.sol, #32 RatesUpdater.sol, #30 Liquidator.sol, #68 AuctionHouse.sol, #26 staking/ddPrime.sol, #68 staking/RewardJoin.sol, #34 staking/StakeJoin.sol, #32 staking/StakingVault.sol, #102 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider adding validation to ensure at least one privileged account is left. 34 Remediation Plan: SOLVED: The ArchAdmin variable was added to the contract. The address assigned to this field cannot be removed from the wards/admins mapping via the administrate or deny functions, ensuring that there is at least one administrator on the contract. To update this address, a new ArchAdmin must be set; then, the address can be removed from the admin mapping.  OSM.sol  RatesUpdater.sol  Liquidator.sol  AuctionHouse.sol  staking/ddPrime.sol  staking/RewardJoin.sol  staking/StakeJoin.sol  staking/StakingVault.sol 35 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_2",
            "Severity: Low"
        ]
    },
    {
        "title": "IMPROPER ROLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The smart contracts in scope do not implement granular access control. All the privileged functionality is assigned to one role. This could lead to severe consequences if, for example, such an account gets compromised or a malicious administrator decides to take over the platform. Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider a more robust RBAC (Role Based Access Control) that allows for finer-grained control as to which functionalities users and contracts have permissions, rather than a blanket admin access to all. For instance, the following user roles could be set:  protocolAdmin - responsible for setting loans, fees, debt ceiling, etc.  collateralAdmin - used for managing collateral-related functions  keepers/oracle - used for updating prices/rates  owner/admin - used for most sensitive actions like adding/removing admins A secure multisig would be best utilized as an administrator, with all permissions and the ability to add or remove permissions to other ad- dresses. 36 Remediation Plan: RISK ACCEPTED: The DAM finance team accepted the risk of this finding. In this role-based admin structure, only smart contracts would have access to specific roles, and a person-controlled owner address would have the ability to set all of these roles. Since a smart contract can only call functions it has interfaces for and admin access to in this setup, and an owner-level admin hack would have the ability to set itself as any other level admin, this does not seem like a useful check. 37 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_2",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING PAUSE/UNPAUSE FUNCTIONALITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In case a hack occurs, or an exploit is discovered, the team should be able to pause functionality until the necessary changes are made to the system. To use a THORchain example again, the team behind the THORchain noticed an attack was going to occur well before the system transferred funds to the hacker. However, they were unable to shut the system down fast enough (According to the incident report). contracts: Liquidator, and Following StakeJoin implement a cage function which the administrator may use to However, there is no possibility of putting the stop the contract. contract into a live state again. AuctionHouse, RewardsJoin, The StakingVault contract has a stakeLive flag, which the stakeAlive modifier uses to allow access to the stake function. During an audit, it was discovered that the contract couldnt be paused/stopped. The stakeLive flag is set to 1 in the constructor, and there is no method to change it later. Code Location: lmcv/Liquidator.sol, #125 lmcv/AuctionHouse.sol, #92 stake/RewardsJoin.sol, #71 stake/StakeJoin.sol, #69 stake/StakingVault.sol, #93 38 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Pause functionality on the contract would have helped secure the funds quickly in an emergency. Remediation Plan: SOLVED: The cage function was modified, and the setStakeAlive function was added to the contracts. Now, contracts can be stopped/resumed in case of an attack.  lmcv/Liquidator.sol  lmcv/AuctionHouse.sol  stake/RewardJoin.sol  stake/StakeJoin.sol  stake/StakingVault.sol 39 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_2",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Contracts in-scope are missing address validation in constructors and setter functions. It is possible to configure the 0x0 address, which will cause issues during execution. Code Location: lmcv/ChainlinkClient.sol Listing 18: lmcv/ChainlinkClient.sol (Line 12) 11 constructor ( address priceFeedAddress ) { 12 13 } priceFeed = AggregatorV3Interface ( priceFeedAddress ); lmcv/OSM.sol Listing 19: lmcv/OSM.sol (Line 93) 92 function changeOracleAddress ( address _oracleAddress ) external auth  { 93 94 } oracleAddress = _oracleAddress ; lmcv/PriceUpdater.sol Listing 20: lmcv/PriceUpdater.sol (Line 66) 64 constructor ( address vat_ ) { 65 66 67 68 } wards [ msg . sender ] = 1; lmcv = LMCVLike ( vat_ ); live = 1; 40 lmcv/PriceUpdater.sol Listing 21: lmcv/PriceUpdater.sol (Line 78) 77 function updateSource ( bytes32 collateral , address _osm ) external  auth { 78 79 } osms [ collateral ] = OSMLike ( _osm ); lmcv/RatesUpdater.sol Listing 22: lmcv/RatesUpdater.sol (Line 51) 49 constructor ( address lmcvAddress ) { 50 51 52 53 54 } wards [ msg . sender ] lmcv stabilityRate lastAccrual = 1; = LMCVLike ( lmcvAddress ); = ONE ; = block . timestamp ; lmcv/Liquidator.sol Listing 23: lmcv/Liquidator.sol (Line 151) 149 function setAuctionHouse ( address addr ) external auth { 150 151 152 153 } lmcv . disapprove ( address ( auctionHouse )) ; auctionHouse = AuctionHouseLike ( addr ); lmcv . approve ( addr ); staking/RewardJoin.sol Listing 24: staking/RewardJoin.sol (Lines 82,84) 79 constructor ( address stakingVault_ , bytes32 collateralName_ ,  address collateralContract_ ) { 80 81 82 83 84 wards [ msg . sender ] = 1; live = 1; stakingVault = StakingVaultLike ( stakingVault_ ); collateralName = collateralName_ ; collateralContract = CollateralLike ( collateralContract_ ); 41 emit Rely ( msg . sender ); 85 86 } staking/StakeJoin.sol Listing 25: staking/StakeJoin.sol (Lines 80,82) 77 constructor ( address stakingVault_ , bytes32 collateralName_ ,  address collateralContract_ ) { 78 79 80 81 82 83 84 } wards [ msg . sender ] = 1; live = 1; stakingVault = StakingVaultLike ( stakingVault_ ); collateralName = collateralName_ ; collateralContract = CollateralLike ( collateralContract_ ); emit Rely ( msg . sender ); staking/StakingVault.sol Listing 26: staking/StakingVault.sol (Line 91) require ( _lmcv != address (0) , \" StakingVault / LMCV address cannot ddPRIMEBytes require ( _ddPRIMEContract != address (0) , \" StakingVault / 87 constructor ( bytes32 _ddPRIMEBytes , address _ddPRIMEContract ,  address _lmcv ) { 88  dPrimeContract address cannot be zero \"); 89  be zero \" ); 90  ddPRIME in LMCV for lookup in locked collateral list ddPRIMEContract 91  ddPRIME for balance lookup 92 93 94 95 } lmcv stakeLive admins [ msg . sender ] = _lmcv ; = 1; = 1; = _ddPRIMEContract ; = _ddPRIMEBytes ; // bytes32 of // Address of Risk Level: Likelihood - 3 Impact - 2 42 Recommendation: Halborn recommends that validation is added to the setter functions throughout all the smart contracts. At a minimum, the DAMfinance team should ensure that these values cannot be set to zero. Remediation Plan: SOLVED: Zero-address checks were added:  ChainlinkClient.sol: #12  OSM.sol: #82, 117  PriceUpdater.sol: #36, 86, 101  RatesUpdater.sol: #32, 75  Liquidator.sol: #64, 175  RewardJoin.sol: #30, 88  StakeJoin.sol: #28, 86  StakingVault.sol: #90, 91, 105, 43 3.10 (HAL-10) MISSING DATA VALIDATION - LOW ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_2",
            "Severity: Informational"
        ]
    },
    {
        "title": "MULTIPLE INTEGER UNDERFLOWS IN LMCV MODULE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_1_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are multiple cases in the LMCV contract when subtracting balances without checks. Such behavior may cause the transaction to fail due to arithmetic errors (integer underflow). Code Location: The repay function does not perform boundary checks; when the user tries to repay a loan after the interest rate has changed, the transaction may fail with an arithmetic error due to underflow: Calculating the dPrime amounts and debt: Listing 6: contracts/LMCV.sol (Lines 406-409) 406 dPrime [ user ] 407 totalDPrime 408 normalizedDebt [ user ] 409 totalNormalizedDebt 410 -= normalizedDebtChange * rateMult ; -= normalizedDebtChange * rateMult ; -= normalizedDebtChange ; -= normalizedDebtChange ; Calculating new collateral amount: Listing 7: contracts/LMCV.sol (Line 416) 415 // Debit locked collateral amount and credit unlocked collateral  amount . 416 uint256 newLockedCollateralAmount = lockedCollateral [ user ][  collateralList [ i ]] -= collateralChange [ i ]; 417 uint256 newUnlockedCollateralAmount = unlockedCollateral [ user ][  collateralList [ i ]] += collateralChange [i ]; deflate function calculating protocol deficit: 21 Listing 8: contracts/LMCV.sol (Lines 522-525) address u = msg . sender ; protocolDeficit [ u] totalProtocoldeficit dPrime [ u ] totalDPrime 520 function deflate ( uint256 rad ) external { 521 522 523 524 525 526 527 528 } -= rad ; -= rad ; -= rad ; -= rad ; emit Deflate ( msg . sender , rad ); pullCollateral function updating unlocked collateral: Listing 9: contracts/LMCV.sol (Line 275) 274 function pullCollateral ( bytes32 collat , address user , uint256 wad )  external auth { 275 276 277 } unlockedCollateral [ user ][ collat ] -= wad ; emit PullCollateral ( collat , user , wad ); moveCollateral function updating unlocked collateral: Listing 10: contracts/LMCV.sol (Line 281) 279 function moveCollateral ( bytes32 collat , address src , address dst ,  uint256 wad ) external { 280 require ( approval ( src , msg . sender ) , \" LMCV / collateral move not  allowed \" ); 281 282 283 284 } unlockedCollateral [ src ][ collat ] -= wad ; unlockedCollateral [ dst ][ collat ] += wad ; emit MoveCollateral ( collat , src , dst , wad ); moveDPrime function: Listing 11: contracts/LMCV.sol (Line 292) 290 function moveDPrime ( address src , address dst , uint256 rad )  external { 22 291 require ( approval ( src , msg . sender ) , \" LMCV / dPrime move not  allowed \" ); 292 293 294 295 } dPrime [ src ] -= rad ; dPrime [ dst ] += rad ; emit MoveDPrime ( src , dst , rad ); Test scenarios: Below are the Hardhat test cases for underflow issues: Listing 12 1 Issues 2  twice (38 ms ) 3  with more than joined 4  than deposited 5 6  loan (98 ms ) HAL -03 Integer underflow in LMCV pullCollateral function - exit HAL -03 Integer underflow in LMCV pullCollateral function - exit HAL -03 Integer underflow in LMCV moveCollateral - move more HAL -03 Integer underflow in LMCV moveDPrime (62 ms ) HAL -03 Integer underflow in LMCV repay - rate updated after Source code of test cases: Listing 13 expect ( await userLMCV . unlockedCollateral ( addr1 . address , 1 it ( \" HAL -03 Integer underflow in LMCV pullCollateral function -  exit twice \" , async function () { 2 3  mockTokenBytes )). to . equal ( fwad ( \" 100 \")) ; 4 5 6 7 8 9  mockTokenBytes )). to . equal ( fwad ( \" 0\" )) ; 10 // exit from CollateralJoin let collatJoinConnect = collateralJoin . connect ( addr1 ); await collatJoinConnect . exit ( addr1 . address , fwad ( \" 100 \")) ; expect ( await userLMCV . unlockedCollateral ( addr1 . address , 23 // try to exit for the second time await expect ( collatJoinConnect . exit ( addr1 . address , fwad ( \" 100 \" ) // exit with more than joined await expect ( collatJoinConnect . exit ( addr1 . address , fwad ( \" 101 \" ) . to . be . revertedWith ( \" Arithmetic operation underflowed or . to . be . revertedWith ( \" Arithmetic operation underflowed or expect ( await userLMCV . unlockedCollateral ( addr1 . address , let collatJoinConnect = collateralJoin . connect ( addr1 ); expect ( await userLMCV . unlockedCollateral ( addr1 . address , 11 12  )) 13  overflowed outside of an unchecked block \"); 14 }) ; 15 16 it ( \" HAL -03 Integer underflow in LMCV pullCollateral function -  exit with more than joined \" , async function () { 17 18 19  mockTokenBytes )). to . equal ( fwad ( \" 100 \")) ; 20 21 22  )) 23  overflowed outside of an unchecked block \"); 24 25  mockTokenBytes )). to . equal ( fwad ( \" 100 \")) ; 26 }) ; 27 28 it ( \" HAL -03 Integer underflow in LMCV moveCollateral - move more  than deposited \" , async function () { 29 30  mockTokenBytes )). to . equal ( fwad ( \" 100 \")) ; 31  mockToken2Bytes )). to . equal ( fwad ( \" 200 \" )) ; 32  mockToken3Bytes )). to . equal ( fwad ( \" 300 \" )) ; 33 34  address , addr1 . address , fwad ( \" 200 \" )) ) 35  overflowed outside of an unchecked block \"); 36 }) ; 37 38 it ( \" HAL -03 Integer underflow in LMCV moveDPrime \" , async function  () { 39 40 await expect ( userLMCV . moveCollateral ( mockTokenBytes , addr1 . expect ( await userLMCV . unlockedCollateral ( addr1 . address , expect ( await userLMCV . unlockedCollateral ( addr1 . address , expect ( await userLMCV . unlockedCollateral ( addr1 . address , . to . be . revertedWith ( \" Arithmetic operation underflowed or await userLMCV . approve ( dPrimeJoin . address ); 24 expect ( await lmcv . totalDPrime () ). to . equal ( frad ( \" 1000 \" )) ; . to . be . revertedWith ( \" Arithmetic operation underflowed or await userLMCV . loan ([ mockTokenBytes ], [ fwad ( \" 50 \")] , fwad (\" 1000 expect ( await dPrime . balanceOf ( addr1 . address )) . to . equal ( fwad (\" 0 let dPrimeJoinConnect = dPrimeJoin . connect ( addr1 ); await expect ( dPrimeJoinConnect . exit ( addr1 . address , fwad ( \" 1001 \" // take a loan await userLMCV . loan ( collateralBytesList , [ fwad ( \" 50 \") , fwad ( \" 41  \" ) , addr1 . address ); 42 43  ))) 44  overflowed outside of an unchecked block \"); 45 46  \" )); 47 48 }) ; 49 50 it ( \" HAL -03 Integer underflow in LMCV repay - rate updated after  loan \" , async function () { 51 52 53  100 \" ) , fwad ( \" 200 \" )] , fwad ( \" 2000 \" ) , addr1 . address ); 54  ); 55  fwad (\" 2000 \" )); 56  2000 \")); 57 58 59 60 61 62  fwad (\" 100 \") , fwad ( \" 200 \" )] , fwad ( \" 2000 \") , addr1 . address )) 63  overflowed outside of an unchecked block \"); 64 }) ; // repay await expect ( userLMCV . repay ( collateralBytesList , [ fwad ( \" 50 \" ) , // update rate await lmcv . updateRate ( fray ( \" .1 \" )); expect ( await lmcv . dPrime ( addr1 . address )) . to . equal ( frad ( \" 2000 \" ) expect ( await userLMCV . normalizedDebt ( addr1 . address )) . to . equal ( expect ( await userLMCV . dPrime ( addr1 . address )). to . equal ( frad ( \" . to . be . revertedWith ( \" Arithmetic operation underflowed or Risk Level: Likelihood - 3 Impact - 3 25 Recommendation: Consider adding a validation before calculating the balances to avoid integer underflow. Remediation Plan: SOLVED: Added additional require statements to ensure that an underflow does not occur: LMCV.sol: #275, 282, 294, 409, 420, 530 26 ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_1",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/DAMfinance Audits/DAMfinance_LMCV_part_2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Contracts in-scope are missing address validation in constructors and setter functions. It is possible to configure the 0x0 address, which will cause issues during execution. Code Location: lmcv/ChainlinkClient.sol Listing 18: lmcv/ChainlinkClient.sol (Line 12) 11 constructor ( address priceFeedAddress ) { 12 13 } priceFeed = AggregatorV3Interface ( priceFeedAddress ); lmcv/OSM.sol Listing 19: lmcv/OSM.sol (Line 93) 92 function changeOracleAddress ( address _oracleAddress ) external auth  { 93 94 } oracleAddress = _oracleAddress ; lmcv/PriceUpdater.sol Listing 20: lmcv/PriceUpdater.sol (Line 66) 64 constructor ( address vat_ ) { 65 66 67 68 } wards [ msg . sender ] = 1; lmcv = LMCVLike ( vat_ ); live = 1; 40 lmcv/PriceUpdater.sol Listing 21: lmcv/PriceUpdater.sol (Line 78) 77 function updateSource ( bytes32 collateral , address _osm ) external  auth { 78 79 } osms [ collateral ] = OSMLike ( _osm ); lmcv/RatesUpdater.sol Listing 22: lmcv/RatesUpdater.sol (Line 51) 49 constructor ( address lmcvAddress ) { 50 51 52 53 54 } wards [ msg . sender ] lmcv stabilityRate lastAccrual = 1; = LMCVLike ( lmcvAddress ); = ONE ; = block . timestamp ; lmcv/Liquidator.sol Listing 23: lmcv/Liquidator.sol (Line 151) 149 function setAuctionHouse ( address addr ) external auth { 150 151 152 153 } lmcv . disapprove ( address ( auctionHouse )) ; auctionHouse = AuctionHouseLike ( addr ); lmcv . approve ( addr ); staking/RewardJoin.sol Listing 24: staking/RewardJoin.sol (Lines 82,84) 79 constructor ( address stakingVault_ , bytes32 collateralName_ ,  address collateralContract_ ) { 80 81 82 83 84 wards [ msg . sender ] = 1; live = 1; stakingVault = StakingVaultLike ( stakingVault_ ); collateralName = collateralName_ ; collateralContract = CollateralLike ( collateralContract_ ); 41 emit Rely ( msg . sender ); 85 86 } staking/StakeJoin.sol Listing 25: staking/StakeJoin.sol (Lines 80,82) 77 constructor ( address stakingVault_ , bytes32 collateralName_ ,  address collateralContract_ ) { 78 79 80 81 82 83 84 } wards [ msg . sender ] = 1; live = 1; stakingVault = StakingVaultLike ( stakingVault_ ); collateralName = collateralName_ ; collateralContract = CollateralLike ( collateralContract_ ); emit Rely ( msg . sender ); staking/StakingVault.sol Listing 26: staking/StakingVault.sol (Line 91) require ( _lmcv != address (0) , \" StakingVault / LMCV address cannot ddPRIMEBytes require ( _ddPRIMEContract != address (0) , \" StakingVault / 87 constructor ( bytes32 _ddPRIMEBytes , address _ddPRIMEContract ,  address _lmcv ) { 88  dPrimeContract address cannot be zero \"); 89  be zero \" ); 90  ddPRIME in LMCV for lookup in locked collateral list ddPRIMEContract 91  ddPRIME for balance lookup 92 93 94 95 } lmcv stakeLive admins [ msg . sender ] = _lmcv ; = 1; = 1; = _ddPRIMEContract ; = _ddPRIMEBytes ; // Address of // bytes32 of Risk Level: Likelihood - 3 Impact - 2 42 Recommendation: Halborn recommends that validation is added to the setter functions throughout all the smart contracts. At a minimum, the DAMfinance team should ensure that these values cannot be set to zero. Remediation Plan: SOLVED: Zero-address checks were added:  ChainlinkClient.sol: #12  OSM.sol: #82, 117  PriceUpdater.sol: #36, 86, 101  RatesUpdater.sol: #32, 75  Liquidator.sol: #64, 175  RewardJoin.sol: #30, 88  StakeJoin.sol: #28, 86  StakingVault.sol: #90, 91, 105, 43 3.10 (HAL-10) MISSING DATA VALIDATION - LOW ",
        "labels": [
            "Halborn",
            "DAMfinance_LMCV_part_2",
            "Severity: Informational"
        ]
    }
]