[{"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/139", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/138", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "`VE3DRewardPool` and `VE3DLocker` adds to an unbounded array which may potentially lock all rewards in the contract", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-05-vetoken-findings", "body": "`VE3DRewardPool` and `VE3DLocker` adds to an unbounded array which may potentially lock all rewards in the contract"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/135", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/134", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/132", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/131", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/129", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/125", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/121", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Not updating `totalWeight` when operator is removed in `VeTokenMinter`", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/120", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-05-vetoken-findings", "body": "Not updating `totalWeight` when operator is removed in `VeTokenMinter`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/119", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/118", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "BaseRewardPool: The getAPY function uses the wrong constant.", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/115", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-05-vetoken-findings", "body": "BaseRewardPool: The getAPY function uses the wrong constant."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/114", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/113", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/111", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/109", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Admin Privilege in minting to arbitrary address allows operator to dilute tokens", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/108", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-05-vetoken-findings", "body": "Admin Privilege in minting to arbitrary address allows operator to dilute tokens"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/104", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/103", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Owner should be allowed to change feeManager", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/99", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/Booster.sol#L129   # Vulnerability details  ## Impact Once Fee Manager has been set initially by owner, then owner has no power to change it. Owner should be allowed to change fees manager in case if he feels current fee manager is behaving maliciously  ## Proof of Concept 1. Observe the setFeeManager function and see that only feeManager is allowed to change it once set initially  ``` function setFeeManager(address _feeM) external {         require(msg.sender == feeManager, \"!auth\");         feeManager = _feeM;         emit FeeManagerUpdated(_feeM);     } ```  ## Recommended Mitigation Steps Change the setFeeManager function like below. Same can be done with other important functionality involving setArbitrator and setVoteDelegate  ``` require(msg.sender == owner, \"!auth\"); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/91", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/90", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "No check for existing extraRewards during push", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/89", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L138 ttps://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DLocker.sol#L156   # Vulnerability details  ## Impact Similar to a reported I submitted for BaseRewardPool.sol (https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/BaseRewardPool.sol#L126)  When adding `extraRewards` to the extra reward pool in https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L138 , there's no check for already existing address. Assume a particular address takes up 2 slots out of 3, and a user withdraws staked extra rewards, the user will receive double the amount requested in https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L257-L258  ## Proof of Concept 1.  Assume `rewardManager` had mistakenly added the same address twice in `addExtraReward()` 2. A user calls `stake()` , linked rewards is staked twice to the same address (unexpected behaviour I guess but not severe issue) 3. Now, user calls `withdraw()` to withdraw linked rewards (this is already 2x in step 2) 4. User will receive double the linked rewards due to the iteration in `https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L257-L258`  ## Tools Used Manual review  ## Recommended Mitigation Steps Guess a check for an already existing extraRewards can be added before Line 138  ##Similar issue **https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DLocker.sol#L156 - not so sure of the severity for this. **https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/BaseRewardPool.sol#L126  - reported in a seperate report    "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/86", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Centralisation RIsk: `VoterProxy` owner may set the `operate` to an address they own and drain all token balances", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/82", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-05-vetoken-findings", "body": "Centralisation RIsk: `VoterProxy` owner may set the `operate` to an address they own and drain all token balances"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/76", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/75", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "compromised `owner` can drain funds from`VeTokenMinter.sol`", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-vetoken-findings", "body": "compromised `owner` can drain funds from`VeTokenMinter.sol`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/65", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/64", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/61", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/59", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/57", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "VE3DRewardPool allows the same reward address to be added multiple times to the `extraRewards` array", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/55", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-05-vetoken-findings", "body": "VE3DRewardPool allows the same reward address to be added multiple times to the `extraRewards` array"}, {"title": "VE3DRewardPool.sol is incompatible with Bal/veBal", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/53", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-vetoken-findings", "body": "VE3DRewardPool.sol is incompatible with Bal/veBal"}, {"title": "Incorrect deployment parameters", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/52", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/25_deploy_angle_pools.js#L68 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/25_deploy_angle_pools.js#L80   # Vulnerability details  ## Impact The address of G-Uni tokens in the deployment scripts are not up to date.   ## Proof of concept For example for agEUR/USDC it is 0xedecb43233549c51cc3268b5de840239787ad56c and not 0x2bD9F7974Bc0E4Cb19B8813F8Be6034F3E772add  ## Mitigation steps For safety why not fetching directly the LP token from the staking contract ?\u2028  "}, {"title": "`VoterProxy` incorrectly assumes a 1-1 mapping between the gauge and the LP tokens.", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/51", "labels": ["bug", "question", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-vetoken-findings", "body": "`VoterProxy` incorrectly assumes a 1-1 mapping between the gauge and the LP tokens."}, {"title": "Contracts should be robust to upgrades of underlying gauges and eventually changes of the underlying tokens", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VoterProxy.sol   # Vulnerability details  ## Impact  For some veAsset project (for example Angle\u2019s [gauges](https://github.com/AngleProtocol/angle-core/blob/main/contracts/staking/LiquidityGaugeV4UpgradedToken.vy), gauge contracts are upgradable, so interfaces and underlying LP tokens are subject to change, blocking and freezing the system. Note that this is not hypothetic as it happened a few weeks ago: see this [snapshot vote]( https://snapshot.org/#/anglegovernance.eth/proposal/0x1adb0a958220b3dcb54d2cb426ca19110486a598a41a75b3b37c51bfbd299513). Therefore, the system should be robust to a change in the pair gauge / token.   Note that is doable in the current setup for the veToken team to rescue the funds in such case, hence it is only a medium issue. You\u2019d have to do as follow: a painful shutdown of the `Booster` (which would lead to an horrible situation where you\u2019d have to preserve backwards compatibility for LPs to save their funds in the new Booster), an operator change in `VoterProxy` to be able to call `execute`.  ## Mitigation steps To deal with upgradeable contracts, either the `VoterProxy` needs to be upgradable to deal with any situation that may arise, either you need to add upgradeable \u201cintermediate\u201d contracts between the `staker` and the gauge that could be changed to preserve the logic.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/48", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/43", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/42", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/40", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/39", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/38", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/37", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "ExtraRewardStashV2's stashRewards can become unavailable", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/36", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L193-L203   # Vulnerability details  There is no check for the reward token amount to be transferred out in stashRewards(). As reward token list is external (controlled with `IGauge(gauge).reward_tokens`), and an arbitrary token can end up there, in the case when such token doesn't allow for zero amount transfers, the stashRewards() managed extra rewards retrieval can become unavailable.  I.e. stashRewards() can be blocked for even an extended period of time, so all other extra rewards gathering will not be possible. This cannot be controlled by the system as pool reward token list is external.  Setting the severity to medium as reward gathering is a base functionality of the system and its availability is affected.  ## Proof of Concept  stashRewards() attempts to send the `amount` to rewardArbitrator() without checking:  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L193-L203  ```solidity     if (activeCount > 1) {         //take difference of before/after(only send new tokens)         uint256 amount = IERC20(token).balanceOf(address(this));         amount = amount.sub(before);          //send to arbitrator         address arb = IDeposit(operator).rewardArbitrator();         if (arb != address(0)) {             IERC20(token).safeTransfer(arb, amount);         }     } ```  If `IStaker(staker).withdraw()` produced no new tokens for any reason, the `amount = amount.sub(before)` above can be zero:  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L188-L189  ```solidity     uint256 before = IERC20(token).balanceOf(address(this));     IStaker(staker).withdraw(token); ```  As reward `token` can be arbitrary, it can also be reverting on an attempt to transfer zero amounts:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  If this be the case then the whole stashRewards() call will be failing until `IStaker(staker).withdraw()` manage to withdraw some `tokens` or such `token` be removed from gauge's reward token list. Both events aren\u2019t directly controllable by the system.  ## Recommended Mitigation Steps  Consider running the transfer only when amount is positive:  ```solidity -   if (activeCount > 1) { +   if (amount > 0 && activeCount > 1) {         //take difference of before/after(only send new tokens)         uint256 amount = IERC20(token).balanceOf(address(this));         amount = amount.sub(before);          //send to arbitrator         address arb = IDeposit(operator).rewardArbitrator();         if (arb != address(0)) {             IERC20(token).safeTransfer(arb, amount);         }     } ```  "}, {"title": "Booster's shutdownPool can freeze user funds", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/35", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-05-vetoken-findings", "body": "Booster's shutdownPool can freeze user funds"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/33", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/30", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Highly Unsafe Pattern of Minting the Additional Reward Tokens at `VeAssetDepositor.sol`", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/29", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeAssetDepositor.sol#L117-L120   # Vulnerability details  ## Impact   In [VeAssetDepositor.sol#L117-L120](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeAssetDepositor.sol#L117-L120), the condition to mint the additional rewards tokens to the user is `if (incentiveVeAsset > 0)`. However, the `incentiveVeAsset` variable is only updated to zero after an external call to the `ITokenMinter` contract. This lacks the Checks Effects and Interactions safety pattern. In the event that the **wrong** minter contract has been initialised, an attacker could potentially drain all the additional reward tokens via a reentrancy attack.  ## Proof of Concept  - <https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html>  ## Recommended Mitigation Steps  Be sure to follow the [Checks Effects and Interactions safety pattern](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) and update the `incentiveVeAsset = 0` before minting the token for the user. Alternatively, the developers can also add the `nonReentrant()` [modifier](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard) from OpenZeppelin to prevent any sort of potential reentrancy attacks.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/27", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/17", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "User can lose extra rewards", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/15", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-05-vetoken-findings", "body": "User can lose extra rewards"}, {"title": "User can lose funds", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/13", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-05-vetoken-findings", "body": "User can lose funds"}, {"title": "Duplicate LP token could lead to incorrect deposits", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/Booster.sol#L256   # Vulnerability details  ## Impact It was observed that addPool function is not checking for duplicate lpToken which allows 2 or more pools to have exact same lpToken. This can cause issue with deposits.  In case of duplicate lpToken, the first pool calling depositAll will take away all lpToken and deposit them under there own pid. This leaves no balance for 2nd pool  ## Proof of Concept  1. PoolManager call addPool function and uses lpToken as A 2. PoolManager again call addPool function and mistakenly provides lpToken as A 3. Now 2 pools will be created with lpToken as A 4. depositAll function is called passing first pool.  5. This takes all balance of lpToken A and depsoit it under first pool pid 6. This mean no balance is left for second pool now  ## Recommended Mitigation Steps Add a global variable keeping track of all lpToken added for pool. In case of duplicate lpToken addPool function should fail.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/9", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/8", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "malicious operator can rug pull", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-vetoken-findings", "body": "malicious operator can rug pull"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/2", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/1", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/128", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/127", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/126", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/124", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/121", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/120", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/119", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/118", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/114", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/113", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/112", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/111", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/110", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/106", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/105", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/104", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/103", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/94", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/93", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/92", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/88", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/87", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/86", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/85", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/84", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "[WP-M10] Wrong formula of `getSharesForAmount()` can potentially cause fund loss when being used to calculate the `shares` to be used in `withdraw()`", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/81", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L306-L329   # Vulnerability details  In `Collateral`, the getter functions `getAmountForShares()` and `getSharesForAmount()` is using `totalAssets()` instead of `_strategyController.totalValue()`, making the results can be different than the actual shares amount needed to `withdraw()` a certain amount of `_baseToken` and the amount of shares expected to get by `deposit()` a certain amount.  Specifically, `totalAssets()` includes the extra amount of `_baseToken.balanceOf(Collateral)`.  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L306-L329  ```solidity function getAmountForShares(uint256 _shares)     external     view     override     returns (uint256) {     if (totalSupply() == 0) {         return _shares;     }     return (_shares * totalAssets()) / totalSupply(); }  function getSharesForAmount(uint256 _amount)     external     view     override     returns (uint256) {     uint256 _totalAssets = totalAssets();     return         (_totalAssets > 0)             ? ((_amount * totalSupply()) / _totalAssets)             : 0; } ```  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L339-L343  ```solidity function totalAssets() public view override returns (uint256) {     return         _baseToken.balanceOf(address(this)) +         _strategyController.totalValue(); } ```  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L137-L148  ```solidity function withdraw(uint256 _amount)     external     override     nonReentrant     returns (uint256) {     require(_withdrawalsAllowed, \"Withdrawals not allowed\");     if (_delayedWithdrawalExpiry != 0) {         _processDelayedWithdrawal(msg.sender, _amount);     }     uint256 _owed = (_strategyController.totalValue() * _amount) /         totalSupply();     ... ```  ### PoC  Given:  - `_baseToken.balanceOf(Collateral)` == 90 - `_strategyController.totalValue()` == 110 - totalSupply of shares = 100  `totalAssets()` returns: 200  `getSharesForAmount(100)` returns: 50, while `withdraw(50)` will actual only get: 55.  When `Collateral` is used by another contract that manages many users' funds, and if it's using `getSharesForAmount()` to calculate the amount of shares needed for a certain amount of underlying tokens to be withdrawn.  This issue can potentially cause fund loss to the user of that contract because it will actually send a lesser amount of `_baseToken` than expected.  ### Recommendation  Consider changing `Collateral.totalValue()` to:   ```solidity function totalAssets() public view override returns (uint256) {     return         _strategyController.totalValue(); } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/75", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/74", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/73", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/71", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/69", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/66", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/65", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/64", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "SingleStrategyController doesn't verify that new strategy uses the same base token", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72 https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/interfaces/IStrategy.sol#L52   # Vulnerability details  ## Impact When migrating from one strategy to another, the controller pulls out the funds of the old strategy and deposits them into the new one. But, it doesn't verify that both strategies use the same base token. If the new one uses a different base token, it won't \"know\" about the tokens it received on migration. It won't be able to deposit and transfer them. Effectively they would be lost.  The migration is done by the owner. So the owner must make a mistake and migrate to the wrong strategy by accident. In a basic protocol with 1 controller and a single active strategy managing that should be straightforward. There shouldn't be a real risk of that mistake happening. But, if you have multiple controllers running at the same time each with a different base token, it gets increasingly likelier.   According to the `IStrategy` interface, there is a function to retrieve the strategy's base token: `getBaseToken()`. I'd recommend adding a check in the `migrate()` function to verify that the new strategy uses the correct base token to prevent this issue from being possible.  ## Proof of Concept https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/interfaces/IStrategy.sol#L52  ## Tools Used none  ## Recommended Mitigation Steps Add  `require(_baseToken == _newStrategy.getBaseToken());` to the beginning of `migrate()`  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/59", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "`getSharesForAmount` returns wrong value when `totalAssets == 0`", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/55", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L328   # Vulnerability details  ## Impact The [`getSharesForAmount`](https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L328) function returns `0` if `totalAssets == 0`.  However, if **`totalSupply == 0`**, the actual shares that are minted in a [`deposit` are `_amount`](https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L83) even if `totalAssets == 0`.  Contracts / frontends that use this function to estimate their deposit when `totalSupply == 0` will return a wrong value.  ## Recommended Mitigation Steps  ```diff function getSharesForAmount(uint256 _amount)     external     view     override     returns (uint256) { +   // to match the code in `deposit` +   if (totalSupply() == 0) return _amount;      uint256 _totalAssets = totalAssets();     return         (_totalAssets > 0)             ? ((_amount * totalSupply()) / _totalAssets)             : 0; // @audit this should be _amount according to `deposit` } ```  "}, {"title": "Withdrawal delay can be circumvented", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/54", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L97   # Vulnerability details  ## Impact After initiating a withdrawal with `initiateWithdrawal`, it's still possible to transfer the collateral tokens. This can be used to create a second account, transfer the accounts to them and initiate withdrawals at a different time frame such that one of the accounts is always in a valid withdrawal window, no matter what time it is. If the token owner now wants to withdraw they just transfer the funds to the account that is currently in a valid withdrawal window.  Also, note that each account can withdraw the specified `amount`. Creating several accounts and circling & initiating withdrawals with all of them allows withdrawing larger amounts **even at the same block** as they are purchased in the future.  I consider this high severity because it breaks core functionality of the Collateral token.  #### POC For example, assume the `_delayedWithdrawalExpiry = 20` blocks. Account A owns 1000 collateral tokens, they create a second account B. - At `block=0`, A calls `initiateWithdrawal(1000)`. They send their balance to account B. - At `block=10`, B calls `initiateWithdrawal(1000)`. They send their balance to account A. - They repeat these steps, alternating the withdrawal initiation every 10 blocks. - One of the accounts is always in a valid withdrawal window (`initiationBlock < block && block <= initiationBlock + 20`). They can withdraw their funds at any time.  ## Recommended Mitigation Steps If there's a withdrawal request for the token owner (`_accountToWithdrawalRequest[owner].blockNumber > 0`), disable their transfers for the time.  ```solidity // pseudo-code not tested beforeTransfer(from, to, amount) {   super();   uint256 withdrawalStart =  _accountToWithdrawalRequest[from].blockNumber;   if(withdrawalStart > 0 && withdrawalStart + _delayedWithdrawalExpiry < block.number) {     revert(); // still in withdrawal window   } } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/48", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/46", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/44", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/43", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/31", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Market expiry behaviour differs in implementation and documentation", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/28", "labels": ["bug", "2 (Med Risk)"], "target": "2022-03-prepo-findings", "body": "Market expiry behaviour differs in implementation and documentation"}, {"title": "First depositor can break minting of shares", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/27", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63   # Vulnerability details  ## Impact The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large \u201cdonation\u201d.  ## Proof of Concept In `Pair.add()`, the amount of LP token minted is calculated as ```solidity function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {     uint256 lpTokenSupply = lpToken.totalSupply();     if (lpTokenSupply > 0) {         // calculate amount of lp tokens as a fraction of existing reserves         uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();         uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();         return Math.min(baseTokenShare, fractionalTokenShare);     } else {         // if there is no liquidity then init         return Math.sqrt(baseTokenAmount * fractionalTokenAmount);     } } ```  An attacker can exploit using these steps 1. Create and add `1 wei baseToken - 1 wei quoteToken` to the pair. At this moment, attacker is minted `1 wei LP token` because `sqrt(1 * 1) = 1` 2. Transfer large amount of `baseToken` and `quoteToken` directly to the pair, such as `1e9 baseToken - 1e9 quoteToken`. Since no new LP token is minted, `1 wei LP token` worths `1e9 baseToken - 1e9 quoteToken`. 3. Normal users add liquidity to pool will receive `0` LP token if they add less than `1e9` token because of rounding division. ```solidity baseTokenShare = (X * 1) / 1e9; fractionalTokenShare = (Y * 1) / 1e9; ```   ## Tools Used Manual Review  ## Recommended Mitigation Steps - [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `lpTokenSupply == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. - In `add()`, ensure the number of LP tokens to be minted is non-zero: ```solidity require(lpTokenAmount != 0, \"No LP minted\"); ```  "}, {"title": "Strategy Migration May Leave Tokens in the Old Strategy Impacting Share Calculations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/26", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72   # Vulnerability details  ## Impact  If a strategy does not have sufficient funds to `withdraw()` for the full amount then it is possible that tokens will be left in this yield contract during `migrate()`.  It is common for withdrawal from a strategy to withdraw less than a user's balance. The reason is that these yield protocols may lend the deposited funds to borrowers, if there is less funds in the pool than the withdrawal amount the withdrawal may succeed but only transfer the funds available rather than the full withdrawal amount.  The impact of tokens remaining in the old strategy is that when we call `StrategyController.totalValue()` this will only account for the tokens deposited in the new strategy and not those stuck in the previous strategy. Therefore `totalValue()` is undervalued.   Thus, when a user calls `Collateral.deposit()` the share calculations `_shares = (_amountToDeposit * totalSupply()) / (_valueBefore);` will be over stated (note: `uint256 _valueBefore = _strategyController.totalValue();`). Hence, the user will receive more shares than they should.  The old tokens may be recovered by calling `migrate()` back to the old strategy. If this is done then `totalValue()` will now include the tokens previously stuck. The recent depositer may now withdraw and will be owed `(_strategyController.totalValue() * _amount) / totalSupply()`. Since `totalValue()` is now includes the previously stuck tokens  `_owed` will be overstated and the user will receive more collateral than they should.  The remaining users who had deposited before `migrate()` will lose tokens proportional to their share of the `totalSupply()`.  ## Proof of Concept  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72 ```     function migrate(IStrategy _newStrategy)         external         override         onlyOwner         nonReentrant     {         uint256 _oldStrategyBalance;         IStrategy _oldStrategy = _strategy;         _strategy = _newStrategy;         _baseToken.approve(address(_newStrategy), type(uint256).max);         if (address(_oldStrategy) != address(0)) {             _baseToken.approve(address(_oldStrategy), 0);             _oldStrategyBalance = _oldStrategy.totalValue();             _oldStrategy.withdraw(address(this), _oldStrategyBalance);             _newStrategy.deposit(_baseToken.balanceOf(address(this)));         }         emit StrategyMigrated(             address(_oldStrategy),             address(_newStrategy),             _oldStrategyBalance         );     } ```  ## Recommended Mitigation Steps  The recommendation is to ensure that `require(_oldStrategy.totalValue() == 0)` after calling `_oldStrategy.withdraw()`. This ensures that no funds are left in the strategy. Consider the code example below.  ```     function migrate(IStrategy _newStrategy)         external         override         onlyOwner         nonReentrant     {         uint256 _oldStrategyBalance;         IStrategy _oldStrategy = _strategy;         _strategy = _newStrategy;         _baseToken.approve(address(_newStrategy), type(uint256).max);         if (address(_oldStrategy) != address(0)) {             _baseToken.approve(address(_oldStrategy), 0);             _oldStrategyBalance = _oldStrategy.totalValue();             _oldStrategy.withdraw(address(this), _oldStrategyBalance);             require(_oldStrategy.totalValue() == 0)             _newStrategy.deposit(_baseToken.balanceOf(address(this)));         }         emit StrategyMigrated(             address(_oldStrategy),             address(_newStrategy),             _oldStrategyBalance         );     } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/24", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/23", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/21", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/20", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/18", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/16", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/15", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/14", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/11", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/10", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/8", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/7", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/6", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/5", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-prepo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/4", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Duplicate  _tokenNameSuffix and _tokenSymbolSuffix will incorrectly update current Market", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/2", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/PrePOMarketFactory.sol#L42   # Vulnerability details  ## Impacted Function: createMarket  ## Description:  1. Owner calls createMarket with  _tokenNameSuffix S1 and _tokenSymbolSuffix S2 which creates a new market M1 with _deployedMarkets[_salt] pointing to M1. Here salt can be S which is computed using  _tokenNameSuffix and _tokenSymbolSuffix 2. This market is now being used 3. After some time owner again mistakenly calls createMarket with  _tokenNameSuffix S1 and _tokenSymbolSuffix S2  4. Instead of returning error mentioning that this name and symbol already exists, new market gets created. The problem here is that salt which is computed using _tokenNameSuffix and _tokenSymbolSuffix will again come as S (as in step 1) which means _deployedMarkets[_salt] will now get updated to M2. This means reference to M1 is gone  ## Recommendation: Add below check:  ``` require(_deployedMarkets[_salt]==address(0), \"Market already exists\"); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/1", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-prepo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/83", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/80", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/79", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/76", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/75", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/69", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/68", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/67", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/66", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/64", "labels": ["bug", "question", "2 (Med Risk)"], "target": "2022-03-sublime-findings", "body": "Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/63", "labels": ["bug", "question", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/62", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/61", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "[WP-M10] Lack of access control allow anyone to `withdrawInterest()` for any lender", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-03-sublime-findings", "body": "[WP-M10] Lack of access control allow anyone to `withdrawInterest()` for any lender"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/53", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/51", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/47", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/46", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/37", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/36", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/33", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/31", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/29", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/28", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Pool Credit Line May Not Able to Start When _borrowAsset is Non ERC20 Compliant Tokens", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-sublime-findings", "body": "# Lines of code  https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L327   # Vulnerability details  ## Impact ```IERC20(_borrowAsset).transfer(_to, _fee);```  If the USDT token is supported as _borrowAsset, the unsafe version of .transfer(_to, _fee) may revert as there is no return value in the USDT token contract\u2019s transfer() implementation (but the IERC20 interface expects a return value).  Function start() will break when _borrowAsset is USDT or Non ERC20 Compliant Tokens. USDT is one of the most borrowed Asset in DEFI. This may cause losing a lot of potential users.  ## Proof of Concept https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L327  ## Recommended Mitigation Steps Use .safeTransfer instead of .transfer  ```IERC20(_borrowAsset).safeTransfer(_to, _fee);```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/24", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/23", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/22", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "PooledCreditLine: termination likely fails because _principleWithdrawable is treated as shares", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/21", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-sublime-findings", "body": "# Lines of code  https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L404-L406   # Vulnerability details  ## Details & Impact  `_principalWithdrawable` is denominated in the borrowAsset, but subsequently treats it as the share amount to be withdrawn.  ```jsx // _notBorrowed = borrowAsset amount that isn't borrowed // totalSupply[_id] = ERC1155 total supply of _id // _borrowedTokens = borrower's specified borrowLimit uint256 _principalWithdrawable = _notBorrowed.mul(totalSupply[_id]).div(_borrowedTokens);  SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _principalWithdrawable.add(_totalInterestInShares), false); ```  ## Recommended Mitigation Steps  The amount of shares to withdraw can simply be `_sharesHeld`.  Note that this comes with the assumption that `terminate()` is only called when the credit line is `ACTIVE` or `EXPIRED` (consider ensuring this condition on-chain), because `_sharesHeld` **excludes principal withdrawals,** so the function will fail once a lender withdraws his principal.  ```jsx function terminate(uint256 _id, address _to) external override onlyPooledCreditLine nonReentrant {   address _strategy = pooledCLConstants[_id].borrowAssetStrategy;   address _borrowAsset = pooledCLConstants[_id].borrowAsset;   uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;    SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _sharesHeld, false);   delete pooledCLConstants[_id];   delete pooledCLVariables[_id]; } ```  "}, {"title": "LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/19", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-sublime-findings", "body": "# Lines of code  https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L594-L599 https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L399-L404   # Vulnerability details  ## Details & Impact  The `_principalWithdrawable` calculated will be more than expected if `_start()` is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting in `totalSupply[id]` not being 1:1 with the borrow limit.  ```jsx function _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {   uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;   uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));   uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);   return _principalWithdrawable; } ```  ## Proof of Concept  Assume the following conditions:  - Alice, the sole lender, provided `100_000` tokens: `totalSupply[_id] = 100_000` - `borrowLimit = 99_000` because of a 1% startFee - Borrower borrowed zero amount  When Alice attempts to withdraw her tokens, the `_principalWithdrawable` amount is calculated as   ```jsx _borrowedTokens = 99_000 _totalLiquidityWithdrawable = 99_000 - 0 = 99_000 _principalWithdrawable = 99_000 * 100_000 / 99_000 = 100_000 ```  This is more than the available principal amount of `99_000`, so the withdrawal will fail.  ## Recommended Mitigation Steps  One hack-ish way is to save the initial supply in `minBorrowAmount` (perhaps rename the variable to `minInitialSupply`) when the credit line is accepted, and replace `totalSupply[_id]` with it.   The other places where `minBorrowAmount` are used will not be affected by the change because:  - startTime has been zeroed, so `start()` cannot be invoked (revert with error S1) - credit line status would have been changed to `ACTIVE` and cannot be changed back to `REQUESTED`, meaning the check below will be false regardless of the value of `minBorrowAmount`.          ```jsx     _status == PooledCreditLineStatus.REQUESTED &&     block.timestamp > pooledCLConstants[_id].startTime &&     totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount     ```       Code amendment example:  ```jsx  function _accept(uint256 _id, uint256 _amount) internal {   ...   // replace delete pooledCLConstants[_id].minBorrowAmount; with the following:   pooledCLConstants[_id].minInitialSupply = totalSupply[_id]; }  // update comment in _withdrawLiquidity // Case 1: Pooled credit line never started because desired amount wasn't reached // state will never revert back to REQUESTED if credit line is accepted so this case is never run  function _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {   uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;   uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));   // totalSupply[id] replaced with minInitialSupply   uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(minInitialSupply);   return _principalWithdrawable; } ```  In `terminate()`, the shares withdrawable can simply be `_sharesHeld`.  ```jsx function terminate(uint256 _id, address _to) external override onlyPooledCreditLine nonReentrant {   address _strategy = pooledCLConstants[_id].borrowAssetStrategy;   address _borrowAsset = pooledCLConstants[_id].borrowAsset;   uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;    SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _sharesHeld, false);   delete pooledCLConstants[_id];   delete pooledCLVariables[_id]; } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/18", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/17", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/16", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/15", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "Interest accrued could be zero for small decimal tokens", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/10", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-03-sublime-findings", "body": "Interest accrued could be zero for small decimal tokens"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/8", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/7", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/3", "labels": ["bug", "question", "QA (Quality Assurance)"], "target": "2022-03-sublime-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/2", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-sublime-findings", "body": "Gas Optimizations"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/155", "labels": [], "target": "2022-03-joyn-findings", "body": "Agreements & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/131", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "`RoyaltyVault.sol` is Not Equipped to Handle On-Chain Royalties From Secondary Sales", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/130", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol   # Vulnerability details  ## Impact  The Joyn documentation mentions that Joyn royalty vaults should be equipped to handle revenue generated on a collection's primary and secondary sales. Currently, `CoreCollection.sol` allows the collection owner to receive a fee on each token mint, however, there is no existing implementation which allows the owner of a collection to receive fees on secondary sales.   After discussion with the Joyn team, it appears that this will be gathered from Opensea which does not have an on-chain royalty mechanism. As such, each collection will need to be added manually on Opensea, introducing further centralisation risk. It is also possible for users to avoid paying the secondary fee by using other marketplaces such as Foundation.   ## Recommended Mitigation Steps  Consider implementing the necessary functionality to allow for the collection of fees through an on-chain mechanism. `ERC2981` outlines the approiate behaviour for this.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/128", "labels": ["bug", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/125", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/124", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/121", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L139-L167 https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50-L56   # Vulnerability details  ## Impact  The `mintToken()` function is called to mint unique tokens from an `ERC721` collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a `payableToken`. However, because the `payableToken` is paid before a token is minted, it may be possible to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. Because `totalSupply()` has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply` check. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again.  ## Proof of Concept  For the sake of this example, let's say `startingIndex = 0` and `maxSupply = 100`. `tokenId` is minted according to `((startingIndex + totalSupply()) % maxSupply) + 1`. If we see that a user mints a token where `totalSupply() = maxSupply - 1 = 99` and they reenter the function, then the next token to mint will actually be of index `1` as `totalSupply() % maxSupply = 0`. Calculating the first `tokenId`, we get `((0 + 0) % maxSupply) + 1 = 1` which is a duplicate of our example.  ## Recommended Mitigation Steps  Consider adding reentrancy protections to prevent users from abusing this behaviour. It may also be useful to follow the checks-effects pattern such that all external/state changing calls are made at the end.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/120", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/119", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/113", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "Add a timelock to `setPlatformFee()`", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/112", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-joyn-findings", "body": "Add a timelock to `setPlatformFee()`"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/110", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "STORAGE COLLISION BETWEEN PROXY AND IMPLEMENTATION (LACK EIP 1967)", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/108", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L9   # Vulnerability details  ## Impact Storage collision because of lack of EIP1967 could cause conflicts and override sensible variables  ## Proof of Concept      contract CoreProxy is Ownable {            address private immutable _implement;  When you implement proxies, logic and implementation share the same storage layout.    In order to avoid storage conflicts  EIP1967 was proposed.(https://eips.ethereum.org/EIPS/eip-1967)   The idea is to set proxy variables at fixed positions (like  `impl` and `admin` ).    For example, according to the standard,  the slot for for logic address should be  `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` (obtained as `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`  ).  In this case, for example, as you inherits from `Ownable` the variable _owner is at the first slot and can be overwritten in the implementation.   There is a table at OZ site that explains this scenario more in detail  https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies  section  \"Unstructured Storaged Proxies\"  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider using EIP1967     "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/106", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/103", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/99", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/98", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/97", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/96", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/95", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/94", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/92", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/91", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/89", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/88", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/87", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/86", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "ERC20 tokens with no return value will fail to transfer", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/83", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L43-L46 https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57   # Vulnerability details   Although the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard (including high profile, like USDT) . In that case, the .transfer() call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.  Recommendation: Consider using OpenZeppelin\u2019s SafeERC20  "}, {"title": "Not handling return value of transferFrom command can create inconsistency", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/81", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L175-L176 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L54-L55   # Vulnerability details  The below transferFrom command is called at two places in the core contracts, followed by an emit event ``` payableToken.transferFrom(msg.sender,recipient,_amount) emit ...(...); ``` The return value is not checked during the payableToken.transferFrom  ## Impact In the event of failure of payableToken.transferFrom(...), the emit event is still generated causing the downstream applications to capture wrong transaction / state of the protocol.  ## Proof of Concept 1. Contract CoreCollection.sol      function withdraw()  2. Contract ERC721Payable.sol    function _handlePayment   ## Recommended Mitigation Steps Add a require statement as being used in the RoyaltyVault.sol ``` require( payableToken.transferFrom(msg.sender,recipient,_amount) == true,             \"Failed to transfer amount to recipient\" ); ```  "}, {"title": "Funds cannot be withdrawn in `CoreCollection.withdraw`", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/80", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L175   # Vulnerability details   The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the `msg.sender` ( who is the owner of the contract). The usage of `transferFrom` can result in serious issues. In fact, many ERC20 always require that in `transferFrom` `allowance[from][msg.sender] >= amount`, so in this case the call to the `withdraw` function will revert as the `allowance[CoreCollection][CoreCollection] == 0` and therefore the funds cannot ben withdrawn and will be locked forever in the contract.  Recommendation : replace `transferFrom` with `transfer`  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/77", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "`CoreCollection.setRoyaltyVault` doesn't check `royaltyVault.royaltyAsset` against `payableToken`, resulting in potential permanent lock of `payableTokens` in royaltyVault", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/73", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L185 https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50 https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L31   # Vulnerability details  ## Impact  Each CoreProxy is allowed to be associated with a RoyaltyVault, the latter which would be responsible for collecting minting fees and distributing to beneficiaries. Potential mismatch between token used in CoreProxy and RoyaltyVault might result in minting tokens being permanently stuck in RoyaltyVault.  ## Proof of Concept  Each RoyaltyVault can only handle the `royaltyVault.royaltyAsset` token assigned upon creation, if any other kind of tokens are sent to the vault, it would get stuck inside the vault forever.  ```     function sendToSplitter() external override {         ...         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             \"Failed to transfer royalty Asset to splitter\"         );         ...         require(             IERC20(royaltyAsset).transfer(                 platformFeeRecipient,                 platformShare             ) == true,             \"Failed to transfer royalty Asset to platform fee recipient\"         );         ...     } ```  Considering that pairing of CoreProxy and RoyaltyVault is not necessarily handled automatically, and can sometimes be manually assigned, and further combined with the fact that once assigned, CoreProxy does not allow modifications of the pairing RoyaltyVault. We can easily conclude that if a CoreProxy is paired with an incompatible RoyaltyVault, the `payableToken` minting fees automatically transferred to RoyaltyVault by `_handlePayment` will get permanently stuck.  ```      function setRoyaltyVault(address _royaltyVault)          external          onlyVaultUninitialized      {          ...          royaltyVault = _royaltyVault;          ...      }       function _handlePayment(uint256 _amount) internal {          address recipient = royaltyVaultInitialized()              ? royaltyVault              : address(this);          payableToken.transferFrom(msg.sender, recipient, _amount);          ...      } ```  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  While assigning vaults to CoreProxy, check if `payableToken` is the same as `royaltyVault.royaltyAsset`   ```      function setRoyaltyVault(address _royaltyVault)          external          onlyVaultUninitialized      {          require(              payableToken == _royaltyVault.royaltyAsset(),              \"CoreCollection : payableToken must be same as royaltyAsset.\"          );          ...          royaltyVault = _royaltyVault;          ...      } ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/71", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/70", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/66", "labels": ["bug", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/63", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/62", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/59", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/58", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/57", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "Differing percentage denominators causes confusion and potentially brick claims", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/53", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L14 https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L103   # Vulnerability details  ## Details & Impact  There is a `PERCENTAGE_SCALE = 10e5` defined, but the actual denominator used is `10000`. This is aggravated by the following factors:  1. Split contracts are created by collection owners, not the factory owner. Hence, there is a likelihood for someone to mistakenly use `PERCENTAGE_SCALE` instead of `10000`. 2. The merkle root for split distribution can only be set once, and a collection\u2019s split and royalty vault can\u2019t be changed once created.  Thus, if an incorrect denominator is used, the calculated claimable amount could exceed the actual available funds in the contract, causing claims to fail and funds to be permanently locked.  ## Recommended Mitigation Steps  Remove `PERCENTAGE_SCALE` because it is unused, or replace its value with `10_000` and use that instead.   P.S: there is an issue with the example scaled percentage given for platform fees `(5% = 200)`. Should be `500` instead of `200`.  "}, {"title": "ERC20 transferFrom return values not checked", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/52", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L54   # Vulnerability details  ## Details  The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.  Some tokens like [EURS](https://etherscan.io/address/0xdb25f211ab05b1c97d595516f45794528a807ad8#code) and [BAT](https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code) will **not** revert if the transfer failed but return `false` instead. Tokens that don't actually perform the transfer and return `false` are still counted as a correct transfer.  ## Impact  Users would be able to mint NFTs for free regardless of mint fee if tokens that don\u2019t revert on failed transfers were used.  ## Recommended Mitigation Steps  Check the\u00a0`success` boolean of all\u00a0`transferFrom()` calls. Alternatively, use OZ\u2019s `SafeERC20`\u2019s `safeTransferFrom()` function.  "}, {"title": "CoreCollection: Starting index is pseudo-randomly generated, allowing for gameable NFT launches", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-joyn-findings", "body": "CoreCollection: Starting index is pseudo-randomly generated, allowing for gameable NFT launches"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/47", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/45", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/44", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "Ineffective Handling of FoT or Rebasing Tokens", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50   # Vulnerability details  ## Impact  Certain ERC20 tokens may change user's balances over time (positively or negatively) or charge a fee when a transfer is called (FoT tokens). The accounting of these tokens is not handled by `RoyaltyVault.sol` or `Splitter.sol` and may result in tokens being stuck in `Splitter` or overstating the balance of a user   Thus, for FoT tokens if all users tried to claim from the Splitter there would be insufficient funds and the last user could not withdraw their tokens.  ## Proof of Concept  The function `RoyaltyVault.sendToSplitter()` will transfer `splitterShare` tokens to the `Splitter` and then call `incrementWindow(splitterShare)` which tells the contract to split `splitterShare` between each of the users.  ```         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             \"Failed to transfer royalty Asset to splitter\"         );         require(             ISplitter(splitterProxy).incrementWindow(splitterShare) == true,             \"Failed to increment splitter window\"         ); ```  Since the `Splitter` may receive less than `splitterShare` tokens if there is a fee on transfer the `Splitter` will overstate the amount split and each user can claim more than their value (except the last user who claims nothing as the contract will have insufficient funds to transfer them the full amount).  Furthermore, if the token rebase their value of the tokens down while they are sitting in the `Splitter` the same issue will occur. If the tokens rebase their value up then this will not be accounted for in the protocol.  ## Recommended Mitigation Steps  It is recommend documenting clearly that rebasing token should not be used in the protocol.  Alternatively, if it is a requirement to handle rebasing tokens balance checks should be done before and after the transfer to ensure accurate accounting. Note: this makes the contract vulnerable to reentrancy and so a [reentrancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) must be placed over the function `sendToSplitter()`.  ```         uint256 balanceBefore = IERC20(royaltyAsset).balanceOf(splitterProxy);         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             \"Failed to transfer royalty Asset to splitter\"         );         uint256 balanceAfter = IERC20(royaltyAsset).balanceOf(splitterProxy);         require(             ISplitter(splitterProxy).incrementWindow(balanceAfter - balanceBefore) == true,             \"Failed to increment splitter window\"         ); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/40", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/39", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/38", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "CoreCollection's token transfer can be disabled", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/37", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57 https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164   # Vulnerability details  ## Impact  When royaltyAsset is an ERC20 that doesn't allow zero amount transfers, the following griefing attack is possible, entirely disabling CoreCollection token transfer by precision degradation as both reward distribution and vault balance can be manipulated.  Suppose splitterProxy is set, all addresses and fees are configured correctly, system is in normal operating state.  POC:  Bob the attacker setup a bot which every time it observes positive royaltyVault balance:  1) runs `sendToSplitter()`, distributing the whole current royaltyAsset balance of the vault to splitter and platform, so vault balance becomes zero  2) sends `1 wei` of royaltyAsset to the royaltyVault balance  3) each next CoreCollection token transfer will calculate `platformShare = (balanceOfVault * platformFee) / 10000`, which will be 0 as platformFee is supposed to be less than 100%, and then there will be an attempt to transfer it to `platformFeeRecipient`  If royaltyAsset reverts on zero amount transfers, the whole operation will fail as the success of `IERC20(royaltyAsset).transfer(platformFeeRecipient, platformShare)` is required for each CoreCollection token transfer, which invokes `sendToSplitter()` in `_beforeTokenTransfer()` as vault balance is positive in (3).  Notice, that Bob needn't to front run the transfer, it is enough to empty the balance in a lazy way, so cumulative gas cost of the attack can be kept moderate.  Setting severity to medium as on one hand, the attack is easy to setup and completely blocks token transfers, making the system inoperable, and it looks like system has to be redeployed on such type of attack with some manual management of user funds, which means additional operational costs and reputational damage. On the another, it is limited to the zero amount reverting royaltyAsset case or the case when platformFee is set to 100%.  That is, as an another corner case, if platformFee is set to 100%, `platformShare` will be `1 wei` and `splitterShare` be zero in (3), so this attack be valid for any royaltyAsset as it is required in Splitter's `incrementWindow` that `splitterShare` be positive.  ## Proof of Concept  As royaltyAsset can be an arbitrary ERC20 it can be reverting on zero value transfers:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  `_beforeTokenTransfer` runs `IRoyaltyVault(royaltyVault).sendToSplitter()` whenever royaltyVault is set and have positive balance:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L307  `sendToSplitter()` leaves vault balance as exactly zero as `splitterShare = balanceOfVault - platformShare`, i.e. no dust is left behind:  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L41  This way the balance opens up for the tiny amount manipulation.  One require that can fail the whole operation is `platformShare` transfer:  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57  Another is positive `royaltyAmount` = `splitterShare` requirement:  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164  ## Recommended Mitigation Steps  The issue is that token transfer, which is core system operation, require fee splitting to be done on the spot. More failsafe design is to try to send the fees and record the amounts not yet distributed, not requiring immediate success. The logic here is that transfer itself is more important than fee distribution, which is simple enough and can be performed in a variety of ways later.  Another issue is a combination of direct balance usage and the lack of access controls of the sendToSplitter function, but it only affects fee splitting and is somewhat harder to address.  As one approach consider trying, but not requiring `IRoyaltyVault(royaltyVault).sendToSplitter()` to run successfully as it can be executed later with the same result.  Another, a simpler one (the same is in `Griefing attack is possible making Splitter's claimForAllWindows inaccessible` issue), is to introduce action threshold, `MIN_ROYALTY_AMOUNT`, to `sendToSplitter()`, for example:  Now: ``` /**  * @dev Send accumulated royalty to splitter.  */ function sendToSplitter() external override {     uint256 balanceOfVault = getVaultBalance();      require(         balanceOfVault > 0,         \"Vault does not have enough royalty Asset to send\"     );  ...      emit RoyaltySentToSplitter(...);     emit FeeSentToPlatform(...); } ```  To be: ``` /**  * @dev Send accumulated royalty to splitter if it's above MIN_ROYALTY_AMOUNT threshold.  */ function sendToSplitter() external override {     uint256 balanceOfVault = getVaultBalance();      if (balanceOfVault > MIN_ROYALTY_AMOUNT) {   ...       emit RoyaltySentToSplitter(...);      emit FeeSentToPlatform(...);     } } ```  "}, {"title": "DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/33", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L153-L155   # Vulnerability details  ## Impact  A `merkleRoot` may only be used once in `createSplit()` since it is used as `salt` to the deployment of a `SplitProxy`.   The result is an attacker may front-run any `createSplit()` transaction in the mem pool and create another `createSplit()` transaction with a higher gas price that uses the same `merkleRoot` but changes the other fields such as the `_collectionContract` or `_splitAsset()`.  The original transaction will revert and the user will not be able to send any more transaction with this `merkleRoot`.  The user would therefore have to generate a new merkle tree with different address, different allocations or a different order of leaves in the tree to create a new merkle root. However, the attack is repeateable and there is no guarantee this new merkle root will be successfully added to a split without the attacker front-running the transaction again.  ## Proof of Concept  The excerpt from `createSplitProxy()` shows the `merkleRoot()` being used as a `salt`.  ```   splitProxy = address(     new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()   ); ```  ## Recommended Mitigation Steps  As seems to be the case here if the transaction address does NOT need to be known ahead of time consider removing the `salt` parameter from the contract deployment.  Otherwise, if the transaction address does need to be known ahead of time then consider concatenating `msg.sender` to the `merkleRoot`. e.g.  ``` splitProxy = address(     new SplitProxy{salt: keccak256(abi.encode(msg.sender, merkleRoot))}()   ) ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/32", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/30", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Gas costs will likely result in any fees sent to the Splitter being economically unviable to recover.", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169   # Vulnerability details  ## Impact  Collection owners will likely lose money by claiming fees unless the fees from a single NFT sale outweighs the cost of claiming it (not guaranteed).  ## Proof of Concept  Consider a new `Collection` with a `RoyaltyVault` and `Splitter` set and a nonzero mint fee.  When calling `mintToken`, the `_handlePayment` function is called https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163  This will transfer the minting fee to the `RoyaltyVault` contract.  On each transfer of an NFT within the collection (for instance in the `_mint` call which occurs directly after calling `_handlePayment`), the `Collection` contract will call `sendToSplitter` on the `RoyaltyVault`: https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307  This function will forward the collection owners' portion of the minting on to the `Splitter` contract but another important thing to note is that we call `Splitter.incrementWindow`.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50  This results in the fees newly deposited into the `Splitter` contract being held in a separate \"window\" to the fees from previous or later mints and need to be claimed separately. Remember that this process happens on every NFT sale so the only funds which will be held in this window will be the minting fees for this particular mint.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169  From this we can see that the `claim` function will only claim the fraction of the fees which are owed to the caller from a single NFT mint.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L112-L142  Note that we can attempt to claim from multiple windows in a single transaction using `claimForAllWindow` but as the name suggests it performs an unbounded loop trying to claim all previous windows (even ones which have already been claimed!) and it is likely that with a new window for every NFT sold this function will exceed the gas limit (consider an 10k token collection resulting in trying to do 10k SSTOREs at 20k gas each.), leaving us to claim each window individually with `claim`.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L35-L62  We're then forced to claim the royalties from each NFT sold one by one, having to send huge numbers of calls to `claim` incurring the base transaction cost many times over and performing many ERC20 transfers when we could have just performed one.  Compound on this that this needs to be repeated by everyone included in the split, multiplying the costs of claiming.  Medium risk as it's gas inefficiency to the point of significant value leakage where collection owners will lose a large fraction of their royalties.  ## Recommended Mitigation Steps  It doesn't seem like the \"window\" mechanism does anything except raise gas costs to the extent that it will be very difficult to withdraw fees so it should be removed.  "}, {"title": "createProject can be frontrun", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L77   # Vulnerability details  ## Impact  This is dangerous in scam senario because the malicious user can frontrun and become the owner of the collection. As owner, one can withdraw `paymentToken`. (note that _collections.isForSale can be change by frontrunner)  ## Proof of Concept  1. Anyone can call `createProject`.  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L77  ```solidity   function createProject(     string memory _projectId,     Collection[] memory _collections   ) external onlyAvailableProject(_projectId) {     require(       _collections.length > 0,       'CoreFactory: should have more at least one collection'     ); ```  ## Recommended Mitigation Steps  Two way to mitigate.  1. Consider use white list on project creation. 2. Ask user to sign their address and check the signature against `msg.sender`.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol#L102  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/25", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/15", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/12", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "Centralisation RIsk: Owner Of `RoyaltyVault` Can Take All Funds", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/9", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L76-L83   # Vulnerability details  ## Impact  The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g. 100% = 10000) and that share of the contracts balance and future balances will be set to the `platformFeeRecipient` (which is in the owners control) rather than the splitter contract.  As a result the owner can steal the entire contract balance and any future balances avoiding the splitter.  ## Proof of Concept  ```     function setPlatformFee(uint256 _platformFee) external override onlyOwner {         platformFee = _platformFee;         emit NewRoyaltyVaultPlatformFee(_platformFee);     } ```  ## Recommended Mitigation Steps  This issue may be mitigated by add a maximum value for the `_platformFee` say 5% (or some reasonable value based on the needs of the platform).  Also consider calling `sendToSplitter()` before adjusting the `platformFee`. This will only allow the owner to change the fee for future value excluding the current contract balance.  Consider the following code. ```     function setPlatformFee(uint256 _platformFee) external override onlyOwner {         require(_platformFee < MAX_FEE);         sendToSplitter(); // @audit this will need to be public rather than external         platformFee = _platformFee;         emit NewRoyaltyVaultPlatformFee(_platformFee);     } ```  "}, {"title": "Fixed Amount of Gas Sent in Call May Be Insufficient", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248-L257   # Vulnerability details  ## Impact  The function `attemptETHTransfer()` makes a call with a fixed amount of gas, 30,000. If the receiver is a contract this may be insufficient to process the `receive()` function. As a result the user would be unable to receive funds from this function.  ## Proof of Concept  ```     function attemptETHTransfer(address to, uint256 value)         private         returns (bool)     {         // Here increase the gas limit a reasonable amount above the default, and try         // to send ETH to the recipient.         // NOTE: This might allow the recipient to attempt a limited reentrancy attack.         (bool success, ) = to.call{value: value, gas: 30000}(\"\");         return success;     } ```  ## Recommended Mitigation Steps  Consider removing the `gas` field to use the default amount and protect from reentrancy by using reentrancy guards and the [check-effects-interaction pattern](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html). Note this pattern is already applied correctly.  "}, {"title": "DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/6", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50-L59   # Vulnerability details  ## Impact  When the value of `currentWindow` is raised sufficiently high `Splitter.claimForAllWindows()` will not be able to be called due to the block gas limit.  `currentWindow` can only ever be incremented and thus will always increase. This value will naturally increase as royalties are paid into the contract.  Furthermore, an attacker can continually increment `currentWindow` by calling `incrementWindow()`. An attacker can impersonate a `IRoyaltyVault` and send 1 WEI worth of WETH to pass the required checks.  ## Proof of Concept  Excerpt from `Splitter.claimForAllWindows()` demonstrating the for loop over `currentWindow` that will grow indefinitely. ```         for (uint256 i = 0; i < currentWindow; i++) {             if (!isClaimed(msg.sender, i)) {                 setClaimed(msg.sender, i);                  amount += scaleAmountByPercentage(                     balanceForWindow[i],                     percentageAllocation                 );             }         } ```  `Splitter.incrementWindow()` may be called by an attacker increasing `currentWindow`. ```     function incrementWindow(uint256 royaltyAmount) public returns (bool) {         uint256 wethBalance;          require(             IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),             \"Royalty Vault not supported\"         );         require(             IRoyaltyVault(msg.sender).getSplitter() == address(this),             \"Unauthorised to increment window\"         );          wethBalance = IERC20(splitAsset).balanceOf(address(this));         require(wethBalance >= royaltyAmount, \"Insufficient funds\");          require(royaltyAmount > 0, \"No additional funds for window\");         balanceForWindow.push(royaltyAmount);         currentWindow += 1;         emit WindowIncremented(currentWindow, royaltyAmount);         return true;     } ```  ## Recommended Mitigation Steps  Consider modifying the function `claimForAllWindows()` to instead claim for range of windows. Pass the function a `startWindow` and `endWindow` and only iterate through windows in that range. Ensure that `endWindow < currentWindow`.  "}, {"title": "CoreCollection can be reinitialized", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/4", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L78-L97   # Vulnerability details  ## Impact  Reinitialization is possible for CoreCollection as `initialize` function sets `initialized` flag, but doesn't control for it, so the function can be rerun multiple times.  Such types of issues tend to be critical as all core variables can be reset this way, for example `payableToken`, which provides a way to retrieve all the contract funds.  However, setting priority to be medium as `initialize` is `onlyOwner`. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.  ## Proof of Concept  `initialize` doesn't control for repetitive runs:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L87  ## Recommended Mitigation Steps  Add `onlyUnInitialized` modifier to the `initialize` function:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L46-L49   "}, {"title": "Splitter: Anyone can call incrementWindow to steal the tokens in the contract", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/3", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L149-L169   # Vulnerability details  ## Impact In general, the Splitter contract's incrementWindow function is only called when tokens are transfer to the contract, ensuring that the number of tokens stored in balanceForWindow is equal to the contract balance. However, anyone can use a fake RoyaltyVault contract to call the incrementWindow function of the Splitter contract, so that the amount of tokens stored in balanceForWindow is greater than the contract balance, after which the verified user can call the claim or claimForAllWindows functions to steal the tokens in the contract. ```     function incrementWindow(uint256 royaltyAmount) public returns (bool) {         uint256 wethBalance;          require(             IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),             \"Royalty Vault not supported\"         );         require(             IRoyaltyVault(msg.sender).getSplitter() == address(this),             \"Unauthorised to increment window\"         );          wethBalance = IERC20(splitAsset).balanceOf(address(this));         require(wethBalance >= royaltyAmount, \"Insufficient funds\");          require(royaltyAmount > 0, \"No additional funds for window\");         balanceForWindow.push(royaltyAmount);         currentWindow += 1;         emit WindowIncremented(currentWindow, royaltyAmount);         return true;     } ``` ## Proof of Concept https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L149-L169 ## Tools Used None ## Recommended Mitigation Steps Add the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/125", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/121", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/119", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/118", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/117", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/115", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/112", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/105", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/104", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/102", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/101", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/97", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/96", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/93", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/90", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/89", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/88", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/86", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/85", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "NonCustodialPSM can become insolvent as CPI index rises", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/83", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-03-volt-findings", "body": "NonCustodialPSM can become insolvent as CPI index rises"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/82", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/81", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/80", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/79", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/75", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/72", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/65", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/64", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "`vcon` address change not persistent across protocol components", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/60", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-03-volt-findings", "body": "`vcon` address change not persistent across protocol components"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/59", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Div by 0", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/58", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-volt-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-volt/tree/main/contracts/utils/Deviation.sol#L23   # Vulnerability details   Division by 0 can lead to accidentally revert, (An example of a similar issue - https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/84)          https://github.com/code-423n4/2022-03-volt/tree/main/contracts/utils/Deviation.sol#L23 a might be 0  It's internal function but since it is used in another internal functions that are used in public and neither of them has this protection I thought it can be considered as medium (e.g. isWithinDeviationThreshold)  Thanks.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/56", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/51", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/48", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/47", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/44", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/42", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/40", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/39", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/38", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/35", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/34", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/32", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/31", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Setting new buffer does not reduce current buffer to cap", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/29", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-volt-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol#L142   # Vulnerability details  ## Impact The `RateLimited.setBufferCap` function first updates the buffer and then sets the new cap, but does not apply the new cap to the updated buffer. Meaning, the updated buffer value can be larger than the new buffer cap which should never be the case. Actions consuming more than the new buffer cap can be performed.  ```solidity function _setBufferCap(uint256 newBufferCap) internal {     // @audit still uses old buffer cap, should set buffer first     _updateBufferStored();      uint256 oldBufferCap = bufferCap;     bufferCap = newBufferCap;       emit BufferCapUpdate(oldBufferCap, newBufferCap); } ```  ## Recommended Mitigation Steps Update the buffer after setting the new cap:  ```diff function _setBufferCap(uint256 newBufferCap) internal { -   _updateBufferStored();     uint256 oldBufferCap = bufferCap;     bufferCap = newBufferCap;  +   _updateBufferStored();      emit BufferCapUpdate(oldBufferCap, newBufferCap); } ```   "}, {"title": "Updating rate limit for addresses restores their entire buffer amount", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-volt-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol#L280   # Vulnerability details  ## Impact When the `bufferCap` is updated for an address in `_updateAddress`, the address's allowed buffer (`bufferStored`) is replenished to the entire `bufferCap`.  The address could frontrun the `updateAddress` call and spend their entire buffer, then the buffer is replenished and they can spend their entire buffer a second time.  ## Recommended Mitigation Steps Keep the old buffer value, capped by the new `bufferCap`:  ```diff + uint256 newBuffer = individualBuffer(rateLimitedAddress);    rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();   rateLimitData.bufferCap = _bufferCap;   rateLimitData.rateLimitPerSecond = _rateLimitPerSecond; - rateLimitData.bufferStored = _bufferCap; + rateLimitData.bufferStored = min(_bufferCap, newBuffer); ```   "}, {"title": "`OracleRef` assumes backup oracle uses the same normalizer as main oracle", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-volt-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/OracleRef.sol#L104   # Vulnerability details  ## Impact The `OracleRef` assumes that the backup oracle uses the same normalizer as the main oracle. This generally isn't the case as it could be a completely different oracle, not even operated by Chainlink.  If the main oracle fails, the backup oracle could be scaled by a wrong amount and return a wrong price which could lead to users being able to mint volt cheap or redeem volt for inflated underlying amounts.  ## Recommended Mitigation Steps Should there be two scaling factors, one for each oracle?   "}, {"title": "Oracle price does not compound", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/22", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-volt-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L136 https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L113   # Vulnerability details  ## Impact The oracle does not correctly compound the monthly APRs - it resets on `fulfill`. Note that the [`oraclePrice` storage variable](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L198) is only set in `_updateCPIData` as part of the oracle `fulfill` callback. It's set to the old price (price from 1 month ago) plus the interpolation from **`startTime`** to now. However, `startTime` is **reset** in `requestCPIData` due to the `afterTimeInit` modifier, and therefore when Chainlink calls `fulfill` in response to the CPI request, the `timeDelta = block.timestamp - startTime` is close to zero again and `oraclePrice` is updated to itself again.  This breaks the core functionality of the protocol as the oracle does not track the CPI, it always resets to `1.0` after every `fulfill` instead of compounding it. In addition, there should also be a way for an attacker to profit from the sudden drop of the oracle price to `1.0` again.  #### POC As an example, assume `oraclePrice = 1.0 (1e18)`, `monthlyAPR = 10%`. The time elapsed is 14 days. Calling `getCurrentOraclePrice()` now would return `1.0 + 14/28 * 10% = 1.05`.  - it's now the 15th of the month and one can trigger `requestCPIData`. **This resets `startTime = now`**. - Calling `getCurrentOraclePrice()` now would return `1.0` again as `timeDelta` (and `priceDelta`) is zero: `oraclePriceInt + priceDelta = oraclePriceInt = 1.0`. - When `fulfill` is called it sets `oraclePrice = getCurrentOraclePrice()` which will be close to `1.0` as the `timeDelta` is tiny.  ## Recommended Mitigation Steps The `oraclePrice` should be updated in `requestCPIData()` not in `fulfill`. Cover this scenario of multi-month accumulation in tests.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/21", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/20", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/16", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/15", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/11", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/10", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/9", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/8", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-volt-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/4", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-volt-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/217", "labels": ["bug", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/215", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/212", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Should prevent users from sending more native tokens in the `startBridgeTokensViaCBridge` function", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/207", "labels": ["bug", "2 (Med Risk)"], "target": "2022-03-lifinance-findings", "body": "Should prevent users from sending more native tokens in the `startBridgeTokensViaCBridge` function"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/206", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/204", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/202", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/201", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/199", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/197", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/196", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/194", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/190", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/188", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/183", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/182", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/180", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/179", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/178", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/177", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/173", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/172", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/171", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/170", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/169", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/168", "labels": ["bug", "disagree with severity", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/167", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/166", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/165", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "[WP-H7] Infinite approval to an arbitrary address can be used to steal all the funds from the contract", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "[WP-H7] Infinite approval to an arbitrary address can be used to steal all the funds from the contract"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/157", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/149", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/148", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/147", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/146", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/139", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/127", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/121", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "`AnyswapFacet` can be exploited to approve arbitrary tokens.", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved"], "target": "2022-03-lifinance-findings", "body": "`AnyswapFacet` can be exploited to approve arbitrary tokens."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/116", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/114", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/111", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Swap functions are Reenterable", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/109", "labels": ["bug", "2 (Med Risk)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Swap functions are Reenterable"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/107", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/105", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Failed transfer with low level call won't revert", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/101", "labels": ["bug", "2 (Med Risk)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Failed transfer with low level call won't revert"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/99", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/93", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "`msg.value` is Sent Multipletimes When Performing a Swap", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/86", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "`msg.value` is Sent Multipletimes When Performing a Swap"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/83", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/82", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/81", "labels": ["bug", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/79", "labels": ["bug", "disagree with severity", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "All swapping functions lack checks for returned tokens", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/76", "labels": ["bug", "3 (High Risk)", "resolved"], "target": "2022-03-lifinance-findings", "body": "All swapping functions lack checks for returned tokens"}, {"title": "Reliance on lifiData.receivingAssetId can cause loss of funds", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/75", "labels": ["bug", "3 (High Risk)"], "target": "2022-03-lifinance-findings", "body": "Reliance on lifiData.receivingAssetId can cause loss of funds"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/72", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/71", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/68", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Anyone can get swaps for free given certain conditions in `swap`.", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/66", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Anyone can get swaps for free given certain conditions in `swap`."}, {"title": "Reputation Risks with `contractOwner`", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/65", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Reputation Risks with `contractOwner`"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/56", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "ERC20 bridging functions do not revert on non-zero msg.value", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/53", "labels": ["bug", "2 (Med Risk)"], "target": "2022-03-lifinance-findings", "body": "ERC20 bridging functions do not revert on non-zero msg.value"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/52", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/50", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "`safeApprove` in `LibAsset` is unnecessary and waste gas", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/49", "labels": ["disagree with severity", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "`safeApprove` in `LibAsset` is unnecessary and waste gas"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/46", "labels": ["bug", "resolved", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/43", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/42", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "cBridge integration fails to send native tokens", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/35", "labels": ["bug", "2 (Med Risk)", "resolved"], "target": "2022-03-lifinance-findings", "body": "cBridge integration fails to send native tokens"}, {"title": "DexManagerFacet: batchRemoveDex() removes first dex only", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/34", "labels": ["bug", "2 (Med Risk)", "resolved"], "target": "2022-03-lifinance-findings", "body": "DexManagerFacet: batchRemoveDex() removes first dex only"}, {"title": "LibSwap: Excess funds from swaps are not returned", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/33", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved"], "target": "2022-03-lifinance-findings", "body": "LibSwap: Excess funds from swaps are not returned"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/29", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "WithdrawFacet's withdraw calls native payable.transfer, which can be unusable for DiamondStorage owner contract", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/14", "labels": ["bug", "2 (Med Risk)", "resolved"], "target": "2022-03-lifinance-findings", "body": "WithdrawFacet's withdraw calls native payable.transfer, which can be unusable for DiamondStorage owner contract"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/7", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-03-lifinance-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-lifinance-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-lifinance-findings", "body": "Gas Optimizations"}, {"title": "Increasing the Lock Amount on an Expired Lock Will Cause Users to Miss Out on Rewards", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/95", "labels": ["2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code\r \r https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L284-L294\r \r https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1137-L1233\r \r # Vulnerability details\r \r ## Impact\r \r Paladin protocol allows users to increase the amount or duration of their lock while it is stil active. Increasing the amount of an active lock should only increase the total locked amount and it shouldn't make any changes to the associated bonus ratios as the duration remains unchanged. \r \r However, if a user increases the lock amount on an expired lock, a new lock will be created with the duration of the previous lock and the provided non-zero amount. Because the `action != LockAction.INCREASE_AMOUNT` check later on in the function does not hold true, `userCurrentBonusRatio` will contain the last updated value from the previous lock. As a result, the user will not receive any rewards for their active lock and they will need to increase the duration of the lock to fix lock's bonus ratio.\r \r ## Recommended Mitigation Steps\r \r Consider preventing users from increasing the amount on an expired lock. This should help to mitigate this issue.\r "}, {"title": "Users Can Bypass Emergency Restrictions on updateUserRewardState()", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/94", "labels": ["2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code\r \r https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1338-L1378\r \r https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L876-L906\r \r # Vulnerability details\r \r ## Impact\r \r The `emergencyWithdraw()` function intends to withdraw their tokens regardless if they are locked up for any duration. This emergency must be triggered by the owner of the contract by calling `triggerEmergencyWithdraw()`. A number of functions will revert when the protocol is in an emergency state, including all stake, lock, unlock and kick actions and the updating of a user's rewards. However, a user could bypass the restriction on `_updateUserRewards()` by transferring a small amount of unlocked tokens to their account. `_beforeTokenTransfer()` will call `_updateUserRewards()` on the `from` and `to` accounts. As a result, users can continue to accrue rewards while the protocol is in an emergency state and it makes sense for users to delay their emergency withdraw as they will be able to claim a higher proportion of the allocated rewards.\r \r ## Recommended Mitigation Steps\r \r Consider adding a check for the boolean `emergency` value in `_beforeTokenTransfer()` to not call `_updateUserRewards` on any account if this value is set. Alternatively, a check could be added into the `_updateUserRewards()` function to return if `emergency` is true.\r "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/93", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/92", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/91", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/90", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/85", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/82", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/81", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/80", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/79", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "System could be wrapped and made useless without contract whitelisting", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/77", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L253 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L284 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L268   # Vulnerability details  ## Impact Anyone could create a contract or a contract factory \"PAL Locker\" with a fonction to deposit PAL tokens through a contract, lock them and delegate the voting power to the contract owner. Then, the ownership of this contract could be sold. By doing so, locked hPAL would be made liquid and transferrable again. This would eventually break the overall system of hPAL, where the idea is that you have to lock them to make them non liquid to get a boosted voting power and reward rate.   Paladin should expect this behavior to happen as we've seen it happening with veToken models and model implying locking features (see https://lockers.stakedao.org/ and https://www.convexfinance.com/).   This behavior could eventually be beneficial to the original DAO (ex. https://www.convexfinance.com/ for Curve and Frax), but the original DAO needs to at least be able to blacklist / whitelist such contracts and actors to ensure their interests are aligned with the protocol.  ## Proof of Concept  To make locked hPAL liquid, Alice could create a contact C. Then, she can deposit hPAL through the contract, lock them and delegate voting power to herself. She can then sell or tokenize the ownership of the contract C.  ## Recommended Mitigation Steps  Depending of if Paladin wants to be optimistic or pessimistic, implement a whitelisting / blacklisting system for contracts.   See: https://github.com/curvefi/curve-dao-contracts/blob/4e428823c8ae9c0f8a669d796006fade11edb141/contracts/VotingEscrow.vy#L185  https://github.com/FraxFinance/frax-solidity/blob/7375949a73042c1e6dd14848fc4ea1ba62e36fb5/src/hardhat/contracts/FXS/veFXS_Solidity.sol.old#L370  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/76", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/75", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/73", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/70", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Users with large `cooldown`s can grief other users", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/69", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor disputed"], "target": "2022-03-paladin-findings", "body": "Users with large `cooldown`s can grief other users"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/68", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Emergency mode enable/disable issue", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-paladin-findings", "body": "Emergency mode enable/disable issue"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/62", "labels": ["bug", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/61", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/60", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "UserLock information can be found during emergency mode", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L446-L468   # Vulnerability details   When the contract is in blocked state (emergency mode), the protocol wants to return an empty UserLock info, on calling the function getUserLock. However, there is another way, by which the users can find the same information.  The below function is not protected when in emergency mode, and users can use this alternatively. Line#466 function getUserPastLock(address user, uint256 blockNumber)   ## Impact There is no loss of funds, however the intention to block information (return empty lock info) is defeated, because not all functions are protected. There is inconsistency in implementing the emergency mode check.  ## Proof of Concept Contract Name : HolyPaladinToken.sol Functions getUserLock and getUserPastLock  ## Recommended Mitigation Steps Add checking for emergency mode for this function getUserPastLock. ``` if(emergency) revert EmergencyBlock(); ``` Additional user access check can be added, so that the function returns correct value when the caller(msg.sender) is admin or owner.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/58", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/55", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Function cooldown() is not protected when protocol in emergency mode", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L228-L235   # Vulnerability details  Function cooldown() is not protected when protocol is in emergency mode. Its behavior is not consistent with the other major functions defined.  ## Impact While other major functions like stake, unstake, lock, unlock, etc., of this contract is protected by checking for emergency flag and reverting,  this function cooldown() is not checked. The impact of this is that during emergency mode, users can set immediately the cooldown() and plan for unstaking when the emergency mode is lifted and cooldown period expires. This may not be the desirable behaviour expected by the protocol.  ## Proof of Concept Contract Name : HolyPaladinToken.sol Function cooldown()  ## Recommended Mitigation Steps Add checking for emergency mode for this function also. ``` if(emergency) revert EmergencyBlock(); ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/52", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/51", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/50", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "`DropPerSecond` is not updated homogeneously, the rewards emission can be much higher than expected in some cases", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/44", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L715-L743   # Vulnerability details  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L715-L743  ```solidity function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates => decrease duration is over     if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; } ```  When current time is `lastDropUpdate + (2*MONTH-1)`:  `nbMonthEllapsed` will be round down to `1`, while it's actually 1.99 months passed, but because of precision loss, the smart contract will believe it's only 1 month elapsed, as a result, `DropPerSecond` will only decrease by 1 * `dropDecreasePerMonth`.  In another word, due to the precision loss in calculating the number of months elapsed, for each `_updateDropPerSecond()` there can be a short of up to `1 * dropDecreasePerMonth` for the decrease of emission rate.  At the very edge case, if all the updates happened just like the scenario above. by the end of the `dropDecreaseDuration`, it will drop only `12 * dropDecreasePerMonth` in total, while it's expected to be `24 * dropDecreasePerMonth`.  So only half of `(startDropPerSecond - endDropPerSecond)` is actually decreased. And the last time `updateDropPerSecond` is called, `DropPerSecond` will suddenly drop to `endDropPerSecond`.  ### Impact  As the `DropPerSecond` is not updated correctly, in most of the `dropDecreaseDuration`, the actual rewards emission rate is much higher than expected. As a result, the total rewards emission can be much higher than expected.  ### Recommendation  Change to:  ```solidity function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates => decrease duration is over     if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = UNIT * (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed / UNIT;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/40", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/36", "labels": ["bug", "resolved", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/32", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Add a timelock to PaladinRewardReserve functions", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/31", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-paladin-findings", "body": "Add a timelock to PaladinRewardReserve functions"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/29", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/28", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "updating the state ", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-03-paladin-findings", "body": "updating the state "}, {"title": "PaladinRewardReserve.sol may have potential bugs if it uses new tokens as rewards", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol   # Vulnerability details  ## Impact ``PaladinRewardReserve.sol`` may have potential bugs if it uses new tokens as rewards.  ## Proof of Concept Currently, ``PaladinRewardReserve.sol`` has following behaviors:  - ``mapping(address => bool) public approvedSpenders`` does not store the info regarding which token it targets - ``setNewSpender``, ``updateSpenderAllowance``, ``removeSpender`` and ``transferToken`` functions can set ``token`` arbitrarily  Hence, some corner cases may happen as follows: - Use TokenA at PaladinRewardReserve.sol and do operations. - Start TokenB as rewards at PaladinRewardReserve.sol.  - All the information stored in ``approvedSpenders`` was intended for TokenA. So it is possible that following corner cases happen:   - ``setNewSpender`` function cannot set new token   - If userA is already added in ``approvedSpenders`` for TokenA, it can call ``updateSpenderAllowance``.   ## Tools Used Statis code analysis  ## Recommended Mitigation Steps Do either of followings depending on the product specification:  (1) If PAL token is only used and other token will never be used at ``PaladinRewardReserve.sol``, stop having ``address token`` argument at ``setNewSpender``, ``updateSpenderAllowance``, ``removeSpender`` and ``transferToken`` functions. Instead, set ``token`` at the constructor or other ways, and limit the ability to flexibly set ``token`` from functions.  (2) If other tokens potentially will be used at ``PaladinRewardReserve.sol``, update data structure of ``approvedSpenders`` mapping and change the logic.  Firstly, it should also contain the info which ``token`` it targets such as ``mapping(address => address => bool)``.  Secondly, it should rewrite the ``require`` logic at each function as follows.  ``` require(!approvedSpenders[spender][token], \"Already Spender on the specified Token\"); ```  ``` require(approvedSpenders[spender][token], \"Not approved Spender on the specified Token\"); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/24", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/23", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/22", "labels": ["bug", "resolved", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Past state query results are susceptible to manipulation due to multiple states with same block number", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/20", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L466 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L492 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L644 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L663 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L917 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L961 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L993 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1148 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1164 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1184 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1199 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1225 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1250 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1260 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1287 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1293 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1324 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1352 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1357   # Vulnerability details  ## Impact  4 kinds of states (`UserLock`, `TotalLock`, `Checkpoint`, `DelegateCheckpoint`) are maintained in the protocol to keep record of history. For functions that query history states, target block number is used as an index to search for the corresponding state.  However, 3 (`DelegateCheckpoint`, `TotalLock`, `UserLocks`) out of the 4 states are allowed to have multiple entries with same `fromBlock`, resulting in a one-to-many mapping between block number and history entry. This makes queried results at best imprecise, and at worst manipulatable by malicious users to present an incorrect history.  ## Proof of Concept  Functions that query history states including `_getPastLock`, `getPastTotalLock`, `_getPastDelegate` perform a binary search through the array of history states to find entry matching queried block number. However, the searched arrays can contain multiple entries with the same `fromBlock`.  For example the `_lock` function pushes a new `UserLock` to `userLocks[user]` regardless of previous lock block number.  ```     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {         require(user != address(0)); //Never supposed to happen, but security check         require(amount != 0, \"hPAL: Null amount\");         uint256 userBalance = balanceOf(user);         require(amount <= userBalance, \"hPAL: Amount over balance\");         require(duration >= MIN_LOCK_DURATION, \"hPAL: Lock duration under min\");         require(duration <= MAX_LOCK_DURATION, \"hPAL: Lock duration over max\");          if(userLocks[user].length == 0){             ...         }         else {             // Get the current user Lock             uint256 currentUserLockIndex = userLocks[user].length - 1;             UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];             // Calculate the end of the user current lock             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;              uint256 startTimestamp = block.timestamp;              if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                 // User locked, and then unlocked                 // or user lock expired                  userLocks[user].push(UserLock(                     safe128(amount),                     safe48(startTimestamp),                     safe48(duration),                     safe32(block.number)                 ));             }             else {                 // Update of the current Lock : increase amount or increase duration                 // or renew with the same parameters, but starting at the current timestamp                 require(amount >=  currentUserLock.amount,\"hPAL: smaller amount\");                 require(duration >=  currentUserLock.duration,\"hPAL: smaller duration\");                  // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                  userLocks[user].push(UserLock(                     safe128(amount),                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                     safe48(duration),                     safe32(block.number)                 ));                 ...             }         ...     } ```  This makes the history searches imprecise at best. Additionally, if a user intends to shadow his past states from queries through public search functions, it is possible to control the number of entries precisely such that binsearch returns the entry he wants to show.   ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Adopt the same strategy as checkpoint, and modify last entry in array instead of pushing new one if it `fromBlock == block.number`   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/18", "labels": ["bug", "resolved", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/17", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/16", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/15", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/13", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/12", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/10", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/9", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "cooldown is set to 0 when the user sends all tokens to himself.", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L891-L905   # Vulnerability details  ## Impact In the _beforeTokenTransfer function, cooldowns will be set to 0 when the user transfers all tokens to himself. Consider the following scenario Day 0: The user stakes 100 tokens and calls the cooldown function Day 10: the user wanted to unstake the tokens, but accidentally transferred all the tokens to himself, which caused the cooldown to be set to 0 and the user could not unstake. ## Proof of Concept https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L891-L905 ## Tools Used None ## Recommended Mitigation Steps ```   function _beforeTokenTransfer(       address from,       address to,       uint256 amount   ) internal virtual override {       if(from != address(0)) { //check must be skipped on minting           // Only allow the balance that is unlocked to be transfered           require(amount <= _availableBalanceOf(from), \"hPAL: Available balance too low\");       }        // Update user rewards before any change on their balance (staked and locked)       _updateUserRewards(from);        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0        if(from != to) {           // Update user rewards before any change on their balance (staked and locked)           _updateUserRewards(to);           // => we don't want a self-transfer to double count new claimable rewards           // + no need to update the cooldown on a self-transfer            uint256 previousToBalance = balanceOf(to);           cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);           // If from transfer all of its balance, reset the cooldown to 0           uint256 previousFromBalance = balanceOf(from);           if(previousFromBalance == amount && fromCooldown != 0) {               cooldowns[from] = 0;           }       }   } ```  "}, {"title": "Users at UNSTAKE_PERIOD can assist other users in unstaking tokens.", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/7", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1131   # Vulnerability details  ## Impact Consider the following scenario: Day 0: User A stakes 200 tokens and calls the cooldown function. At this time, user A's cooldown is Day 0. Day 15: User B stakes 100 tokens, but then wants to unstake tokens. So user A said that he could assist user B in unstaking tokens, and this could be done by deploying a smart contract. In the smart contract deployed by user A, user B first needs to transfer 100 tokens to user A. In the _getNewReceiverCooldown function, _senderCooldown is Day 15 and receiverCooldown is Day 0, so the latest cooldown of user A is (100 * Day 15 + 200 * Day 0)/(100+200) = Day 5. ```     function _getNewReceiverCooldown(         uint256 senderCooldown,         uint256 amount,         address receiver,         uint256 receiverBalance     ) internal view returns(uint256) {         uint256 receiverCooldown = cooldowns[receiver];          // If receiver has no cooldown, no need to set a new one         if(receiverCooldown == 0) return 0;          uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);          // If last receiver cooldown is expired, set it back to 0         if(receiverCooldown < minValidCooldown) return 0;          // In case the given senderCooldown is 0 (sender has no cooldown, or minting)         uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;          // If the sender cooldown is better, we keep the receiver cooldown         if(_senderCooldown < receiverCooldown) return receiverCooldown;          // Default new cooldown, weighted average based on the amount and the previous balance         return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);      } ``` Since User A is still at UNSTAKE_PERIOD after receiving the tokens, User A unstakes 100 tokens and sends it to User B.  After calculation, we found that when user A has a balance of X and is at the edge of UNSTAKE_PERIOD, user A can assist in unstaking the X/2 amount of tokens just staked.  ## Proof of Concept https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1131  ## Tools Used None ## Recommended Mitigation Steps After calculation, we found that the number of tokens that users at the edge of UNSTAKE_PERIOD can assist in unstaking conforms to the following equation UNSTAKE_PERIOD/COOLDOWN_PERIOD = UNSTAKE_AMOUNT/USER_BALANCE, when COOLDOWN_PERIOD remains unchanged, the smaller the UNSTAKE_PERIOD, the less tokens the user can assist in unstaking, so UNSTAKE_PERIOD can be adjusted to alleviate this situation.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/5", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "Incorrect number of seconds in `ONE_YEAR` variable", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L25   # Vulnerability details  ## Impact In `HolyPaladinToken.sol` the `ONE_YEAR` variable claims that there are `31557600` seconds in a year when this is incorrect.  The `ONE_YEAR` variable is used in the `getCurrentVotes()` function as well as the `getPastVotes()` function so it is vital that the correct time in seconds be used as it can effect users negatively.   ## Proof of Concept https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L25  86,400 seconds in a day x 365 = 31_536_000  ## Tools Used Manual code review   ## Recommended Mitigation Steps The correct number of seconds in a year is 31_536_000 so the `ONE_YEAR` variable should be changed to `ONE_YEAR = 31_536_000`   "}, {"title": "`HolyPaladinToken.sol` uses `ERC20` token with a highly unsafe pattern", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/3", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/open-zeppelin/ERC20.sol#L149   # Vulnerability details  ## Impact In `HolyPaladinToken.sol` it imports `ERC20.sol` with some changes from the original Open Zeppelin standard.  One change is that the `transferFrom()` function does not follow the Checks Effect and Interactions safety pattern to safely make external calls to other contracts. All checks should be handled first, then any effects/state updates,  followed by the external call to prevent reentrancy attacks.  Currently the `transferFrom()` function in `ERC20.sol` used by `HolyPaladinToken.sol` calls `_transfer()` first and then updates the `sender` allowance which is highly unsafe.  The openZeppelin `ER20.sol` contract which is the industry standard first updates the `sender` allowance before calling `_transfer`.  The external call should always be done last to avoid any double spending bugs or reentrancy attacks.   ## Proof of Concept https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/open-zeppelin/ERC20.sol#L149  Open Zeppelins Implementation https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol  ## Tools Used Manual code review   ## Recommended Mitigation Steps Be sure to follow the Checks Effects and Interactions safety pattern as the `transferFrom` function is one of the most important functions in any protocol.  Consider importing the Open Zeppelin `ERC20.sol` contract code directly as it is battle tested and safe code.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/2", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/1", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/232", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Update initializer modifier to prevent reentrancy during initialization", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/227", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "Update initializer modifier to prevent reentrancy during initialization"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/226", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/225", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/224", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/223", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/222", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/218", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/217", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/216", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/215", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/212", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/210", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/207", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/204", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/202", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/196", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/195", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/192", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/191", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/190", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-jpegd-findings", "body": "Gas Optimizations"}]