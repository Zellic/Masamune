[{"title": "(M1) Unexpected root claims", "body": "Executing a previously scheduled scheduleRootChange can result in an unexpected root claim. Here are two exemplary plausible scenarios that can lead to this issue: Erroneous Double Scheduling: The root can mistakenly schedule a root change twice to Alice. Alice then claims root powers. If Alice transfers root permissions to Bob at any point in the future, she could still claim herself as root by executing the other scheduled root transfer to herself. Intentional Backdoor: A root can schedule a root transfer to itself without executing it. At any later time, the original root can execute this root change and revoke root privileges from the current root. The security assumption is that the root is not malicious. It does not prevent this attack unless it is assumed that the current root and all previous roots in the system\u2019s history are not and will never be malicious. Additionally, the \ufb01rst scenario above does not necessarily stem from malicious intentions but rather from mistrust between the roots or execution mistakes. For example, if the system was deployed and initialized with an EOA root address, and later the root privileges were claimed by a DAO, we may not trust the EOA anymore, as it has no time delays or transparency, and it can be compromised. \fResponse Balancer is aware of this issue. Similarly, it can be used to avoid delays if a scheduled action is already in place. However, it is di\ufb03cult to keep track of the scheduled executions for speci\ufb01c actions and update them if the corresponding execution is executed or canceled. Balancer\u2019s team has deemed the added complexity of such a process to be not worthwhile.", "html_url": "https://www.certora.com/wp-content/uploads/2023/05/Formal-Verification-of-Balancer-TimelockAuthorizer-1.pdf", "labels": ["Certora", "Medium"]}, {"title": "(L1) Non-root users could get roots permissions", "body": "Somebody could get root permissions if there was a mistake in granting arguments and then make another malicious user an executor for an action they weren\u2019t supposed to execute. Response The permission system was rewritten. Under the new system, there is no non-root global granter.", "html_url": "https://www.certora.com/wp-content/uploads/2023/05/Formal-Verification-of-Balancer-TimelockAuthorizer-1.pdf", "labels": ["Certora", "Low"]}, {"title": "(L2) Can create a canceler for a non existing scheduledExecutionId", "body": "The addCanceler() function does not prevent the root from mistakenly adding a canceler to a non-existent execution. This is because there are no checks that the scheduledExecutionId exists and because _isCanceler is a mapping, no out-of-bounds exception will occur. If a malicious user cancels future executions with that scheduledExecutionId, it can cause delays for sensitive tasks that must be rescheduled. \fResponse The scheduledExecutionId for an action cannot be predicted because it depends on others scheduling actions. Creating a canceler for an unknown id is unreasonable and, therefore, always a mistake. We updated the code to only allow creating cancelers for existing executions that have not been canceled or executed, or global cancelers.", "html_url": "https://www.certora.com/wp-content/uploads/2023/05/Formal-Verification-of-Balancer-TimelockAuthorizer-1.pdf", "labels": ["Certora", "Low"]}, {"title": "(L3) The system can be stuck with address(0) root", "body": "If the default address value, address(0), is used as both the current and pending root when deploying the contract, the root will be invalid. This error cannot be recovered because only the root can set a new pending root. Response This is not an issue because the migrator forces the root to interact when deploying the contract.", "html_url": "https://www.certora.com/wp-content/uploads/2023/05/Formal-Verification-of-Balancer-TimelockAuthorizer-1.pdf", "labels": ["Certora", "Low"]}, {"title": "(L4) Nobody with root permissions", "body": "If _pendingRoot and _root were equal, then after claiming root, there would be no one with root permissions. Response The issue was resolved after a rewrite of the permission system. \fSeverity: Informational Issue Inconsistency in adding and removing permissions Description There is an option to grant speci\ufb01c permissions to someone who already has global permissions for a given actionId and account. But there isn\u2019t the opposite option, to revoke a speci\ufb01c permission from someone if they have global permission. Response We disallowed granting speci\ufb01c permission to someone who already has global permissions.", "html_url": "https://www.certora.com/wp-content/uploads/2023/05/Formal-Verification-of-Balancer-TimelockAuthorizer-1.pdf", "labels": ["Certora", "Low"]}, {"title": "Execution delay can be smaller than MIN_DELAY", "body": "The check for the MIN_DELAY is not on the parameter that the data contains, so it was possible to set the delay below the MIN_DELAY. Response Balancer renamed the variable to _MINIMUM_CHANGE_DELAY_EXECUTION_DELAY to convey its meaning better.", "html_url": "https://www.certora.com/wp-content/uploads/2023/05/Formal-Verification-of-Balancer-TimelockAuthorizer-1.pdf", "labels": ["Certora", "Informational"]}, {"title": "Loss of assets in BentoBox", "body": "Rules Broken: allTokensAreInvested, integrityHarvest Description: When harvesting the profits, cTokens are transferred to BentoBox instead of the invested token. Fix: Transfer the invested token instead of cToken.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/SushiCompoundStrategyApr2021.pdf", "labels": ["Certora", "Critical"]}, {"title": "Loss of assets in BentoBox", "body": "Rules Broken: allTokensAreInvested, integrityExit Description: When exiting the strategy, all the tokens are passed to the owner instead of to BentoBox. Fix: Transfer to BentoBox instead of the owner. www.certora.com \f", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/SushiCompoundStrategyApr2021.pdf", "labels": ["Certora", "Critical"]}, {"title": "Creating collateral from nothing by using  transferCollateral", "body": "Description: When calling  transferCollateral()  the new balances of the sender and the recipient are calculated and stored in two steps. Since the calculation is being done first for both users, it is possible to create funds from nothing by specifying  src = dst . In this case the increment of  dst  balance overwrites the decrement of the  src balance, effectively increasing the balance by the amount given. Properties Violated: Total collateral per asset (property #1) Verify transferAsset (property #12) Compound Response: This issue was fixed in commit c0d8a11f424747204ce680f0fe17441368f4d85c.", "html_url": "https://www.certora.com/wp-content/uploads/2022/06/CometReport-1.pdf", "labels": ["Certora", "Critical"]}, {"title": "Creating base token from nothing by using  transferBase", "body": "\fIssue: Creating base token from nothing by using  transferBase Description: When calling  transferBase()  the new balances of the sender and the recipient are calculated and stored in two steps. Since the calculation is being done first for both users, it is possible to create funds from nothing by specifying  src = dst . In this case the increment of  dst  balance overwrites the decrement of the  src balance, effectively increasing the balance by the amount given. Properties Violated: Total base token (property #5) Verify transferAsset (property #12) Compound This issue was fixed in commit Response: c0d8a11f424747204ce680f0fe17441368f4d85c.", "html_url": "https://www.certora.com/wp-content/uploads/2022/06/CometReport-1.pdf", "labels": ["Certora", "Critical"]}, {"title": "Wrong calculation of  principalValue", "body": "Description: The function  principalValue()  is using the functions presentValueSupply()  and  presentValueBorrow()  to calculate the principle value. It should use  principalValueSupply()  and principalValueBorrow()  instead. Property Violated: -- Compound This issue was fixed in commit Response: ffac97079f6573cc7cdb8ebc4e024ffce55825e9.", "html_url": "https://www.certora.com/wp-content/uploads/2022/06/CometReport-1.pdf", "labels": ["Certora", "Critical"]}, {"title": "Incorrect liquidation computation", "body": "Description: When invoking  absorbInternal() ,  accrue()  is being called after the check  isLiquidatable() . In practice, it means that the check whether a user is liquidatable is being done on a non-updated state of the system, i.e. on the state of the user from the last time an update was called. For example, a borrower can be not liquidatable at time $t=0$, then after some time $(t)$ passes and debts accumulate, the borrower enters a liquidatable state at time $t$. If at no point in time $t'\u2265t$ did anybody call the  accrue()  function through a financial action-- withdraw() ,  supply() ,  transfer() --a call to absorbInternal()  will not allow users to absorb the borrower's assets even though in reality he/she should be liquidatable. \fIssue: Property Violated: -- Incorrect liquidation computation Compound This issue was fixed in commit Response: cf066c4995162d5ac7d455a33e442d8dc7cbb2bb.", "html_url": "https://www.certora.com/wp-content/uploads/2022/06/CometReport-1.pdf", "labels": ["Certora", "Medium"]}, {"title": "Incorrect gain of assets, incorrect option to  buyCollateral", "body": "Description: withdrawReserves()  and  buyCollateral()  use the  getReserves() function to check the present value of  totalSupply  and totalBorrow . If  accrue()  is not called beforehand, the present values may not be fully up-to-date. As a result the calculated reserves amount will be inaccurate. This will prevent the governor from taking out its rightful assets, or mean that  getReserves()  retrieves a larger number than the governance. In addition, one might be able to buy collateral (at a discount) when not appropriate. Property Violated: Balance change vs accrue (property #9) Compound Response: This issue was fixed in commit 59def475c9ca9570f690201b7dd07a3ce1ed1a6b.", "html_url": "https://www.certora.com/wp-content/uploads/2022/06/CometReport-1.pdf", "labels": ["Certora", "Medium"]}, {"title": "Incorrect collateral representation", "body": "Description: absorbInternal()  sets all of a user's collateral assets to 0, but never updates the user's  assetIn() . This means that even though the collateral balance of a user is 0, the bit is still 'on' such that the function  isInAsset()  will return true. This wastes gas in methods like isBorrowCollateralized() ,  getBorrowLiquidity() , isLiquidatable() ,  getLiquidationMargin() , and absorbInternal()  which count on the correct update of  assetIn when iterating over collateral assets. Property Violated: AssetIn initialized with balance (property #8) Compound This issue was fixed in commit Response: 83211fa995a1e3bb79d98cbfdd453f0ce7f7b2e7. Gas Optimization \faccrue()  can be called in  absorb()  instead of  absorbInternal()  - Currently accrue()  is being called in  absorbInternal()  and therefore being called in every loop iteration over the array of accounts. The accrual can be moved to  absorb()  to save some unnecessary operations. Update of accrual time can be saved in some cases - The update  lastAccrualTime = now_  in  accrue()  can be done inside the  if (timeElapsed > 0)  to save gas on storage. Redundant use of  Safe64()  - The use of  Safe64()  on  asset.scale  in isBorrowCollateralized  and  getBorrowLiquidity  is redundant since scale is already a  uint64 . Redundant assignment of  TotalsCollateral  to memory - In withdrawCollateral()  there is an assignment of  totalsCollateral  into a local variable which is redundant as it's accessed only once throughout the method. Redundant check in  absorbInternal()  - In  absorbInternal()  there is no need to check  if seizeAmount > 0 , because of the  isInAsset()  check beforehand. Redundant assignment of  newBalance  in  absorbInternal()  - In absorbInternal() , a more efficient way to execute the line  newBalance = newBalance < 0 ? int104(0) : newBalance  is by replacing it with  if(newBalance < 0) { newBalance = 0} . All the gas optimization suggestions were implemented in commit 10ca0422e4e983d8384a08c5d19ecb34515b66aa.", "html_url": "https://www.certora.com/wp-content/uploads/2022/06/CometReport-1.pdf", "labels": ["Certora", "Low"]}, {"title": "Token address duplicates not checked on calling  initialize", "body": "Description: Property Violated: AAVE Response: Upon calling  initialize , no check is performed for duplicates in the L1 and L2 token arrays. A mistake in the function input can lead to two tokens on one side of the bridge corresponding to the same token on the other side. Community rule #2:  shouldRevertInitializeTokens It is assumed that no duplicates are introduced by the trusted party in charge (Aave governance). In addition, validation of approval protects against that case for L1 tokens. Can be seen here. Discovered By Certora:", "html_url": "https://www.certora.com/wp-content/uploads/2022/10/Formal-Verification-Report-of-Aave-Starknet-Bridge-3.pdf", "labels": ["Certora", "Low"]}, {"title": "Front running of withdrawal", "body": "After a withdrawal request is initiated on the L2 side by a user, it is possible for anyone to call  withdraw  from the L1 side on their behalf. The withdrawal payload message (L2->L1) doesn't include the boolean  toUnderlyingAsset  which determines the type of token to be paid to the redeemer - ATokens or underlying asset. Hence, a malicious user can front-run the original redeemer and decide the type of tokens they withdraw, with no special permissions necessary. Fixed in commit 3d00e2a. Transformation from dynamic to static amounts is not precisely reversible Description: AAVE Response:", "html_url": "https://www.certora.com/wp-content/uploads/2022/10/Formal-Verification-Report-of-Aave-Starknet-Bridge-3.pdf", "labels": ["Certora", "Low"]}, {"title": "\fIssue:", "body": "Transformation from dynamic to static amounts is not precisely reversible When transforming an amount of ATokens to static Atokens and back, usually by deposit and subsequent withdrawal or cancellation, the returned amount can be larger than the original one, meaning the user Description: can gain more L1 tokens than they should recieve. This is a result of rounding errors in the ray math library. We were able to prove the inconsistency for an arbitrary asset with an arbitrary liquidity index ( index ). The difference between the values is bounded by (index/RAY+1)/2  (see rule #3). Property Violated: Rule #2:  dynamicToStaticInversible2 Rule #8:  cancelAfterDepositGivesBackExactAmount AAVE Response: To fix this issue, a deeper change on the Aave protocol will be required. We acknowledge this issue however no action will be taken on the Bridge contract.", "html_url": "https://www.certora.com/wp-content/uploads/2022/10/Formal-Verification-Report-of-Aave-Starknet-Bridge-3.pdf", "labels": ["Certora", "Low"]}, {"title": "Cancelling a deposit does not check for success of deposit on L2", "body": "Cancelling a deposit by calling  startDepositCancellation()  checks only for non-zero message count of the deposit payload hash, i.e. that the payload indeed exists. It does not, however, check for the status of the deposit payload, i.e. whether it was handled by the other side. Therefore a great deal of trust is placed on the L2 (starkNet) confirmation proofs and update mechanism. A failure to send confirmation proof for successful deposit within the predetermined 5 day delay, will enable gaining tokens on both sides by canceling a successful deposit that has not yet received a confirmation. Rule #9:  cannotCancelDepositAndGainBothTokens We assume that Starknet can write proofs for successful transactions within 5 days. All projects creating bridges between Ethereum and Starknet make this assumption. Description: Property Violated: AAVE Response:", "html_url": "https://www.certora.com/wp-content/uploads/2022/10/Formal-Verification-Report-of-Aave-Starknet-Bridge-3.pdf", "labels": ["Certora", "Informational"]}, {"title": "Malicious users can settle asstes using settlement rates of other", "body": "assets Description: When the function SettlePortfolioAssets.settlePortfolio() settles an asset in the portfolio that must be settled, it first computes its settlement rate. Due to an optimization, it only computes the settlement rate if asset.maturity < blockTime. However, it settles liquidity token assets if asset.maturity <= blockTime, meaning that if asset.maturity equals blockTime (block.timestamp), then because the assets in the portfolio are settled one by one in a loop, if this asset isn\u2019t the first one that is being settled in the loop, this asset will be settled with the settlement rate of the previous asset that was settled. block.timestamp can be manipulated by miners, and a malicious user (which is also a miner) can arrange the assets in its portfolio in such an order that allows him to earn significant funds on the expense of the system, by settleing assets with different settlement rates, at the date of their maturity. Mitigation/Fix: Compute the settlement rate for an asset if asset.maturity <= blockTime, instead of only when asset.maturity < blockTime.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "High"]}, {"title": "Description:", "body": "Assets in a portfolio aren\u2019t always unique If an asset is added to a portfolio using PortfolioHandler.addAsset() with isNewHint=true, but this asset already presents in the portfolio, then this asset will be inserted into the portfolioState.newAssets array. The effect of this is that the portfolio will end up having the same asset twice, instead of just one with its overall notional value. From now on, the second instance of that asset in the portfolio will be discarded. Mitigation/Fix: Remove the argument isNewHint from PortfolioHandler.addAsset() and act like it is always false. \fSeverity: Medium Issue: Deleting an asset from a portfolio twice causes the loss of other assets Description: If the function PortfolioHandler.deleteAsset() tries to delete an asset that was already deleted (its storageState equals to AssetStorageState.Delete), then it will swap the deleted asset\u2019s storage slot (which is currently located after any storage slot of active assets) with a storage slot of an active asset. The result is that the swapped active asset will be stored after the slot of the deleted asset and portfolioState.storedAssetLength will be decreased by 1. Meaning that these two assets (the deleted asset and the swapped active asset) will not be loaded, when loading the portfolio from storage. Mitigation/Fix: Add a require statement that prevents deletions of assets that were already deleted.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "SettlePortfolioAssets.settlePortfolio() also settles deleted assets", "body": "Description: When the function SettlePortfolioAssets.settlePortfolio() settles the assets in the portfolio, it doesn\u2019t check whether the assets in the portfolio are active or they have been deleted, meaning that it also settles the deleted assets in the portfolio, if any. In addition, since every settlement also deletes the involved asset from the portfolio, settlement of a deleted asset will also triger the previous issue (Deleting an asset from a portfolio twice causes the loss of other assets). Mitigation/Fix: Settle only the active assets in the portfolio. \fSeverity: Medium Issue: Description: Currency ids in an account context can be modified in AccountContextHandler.setActiveCurrency() The 14 least significant bits of the flags argument in the function AccountContextHandler.setActiveCurrency() must be off because of these reasons: \u25cf If isActive=false then the 14 least significant bits in flags can modify the 14-bits currencyId when it is found inside accountContext.activeCurrencies (it can set off bits in currencyId). Therefore, these 14 bits in flags must be set off. \u25cf If isActive=true then the 14 least significant bits in flags can modify the 14-bits currencyId when it is found inside or inserted into accountContext.activeCurrencies (it can set on bits in currencyId). Therefore, these 14 bits in flags must be set off. Mitigation/Fix: Add a requirement for these 14 bits to be off or set them off at the beginning of this function. \fSeverity: Medium Issue: The function SettlePortfolioAssets.settlePortfolio() can revert unexpectedly in valid transactions Description: Recalling the previous issue with this function (Malicious users can settle asstes using settlement rates of other assets), if the asset that is being settled without computing its settlement rate (happens when asset.maturity equals blockTime) is the first asset in the loop that is being settled, then the settlement rate that will be used for its settlement will remain uninitialized, with the zero value. This will cause the settlement to failed due to a division by zero, when it calls the function convertFromUnderlying() and tries to devide by the uninitialize settlement rate. Mitigation/Fix: Compute the settlement rate for an asset if asset.maturity <= blockTime, instead of only when asset.maturity < blockTime. \fSeverity: Medium Issue: Authorized addresses can cause loss of asset tokens Description: Addresses that were authorized as global transfer operators using GovernanceAction.updateGlobalTransferOperator() are able to call BatchAction.batchBalanceAction and BatchAction.batchBalanceAndTradeAction with account=Notional (Notional\u2019s address) through ERC1155Action._checkPostTransferEvent(). With these functions, in the first action of the batch they can invoke BalanceHandler.depositAssetToken() with a token that has no transfer fee, and in the second action of the batch they can invoke TokenHandler.redeem(). This is what will happen in such a scenario: \u25cf In the first action, when the function BalanceHandler.depositAssetToken() is invoked, balanceState.netAssetTransferInternalPrecision is increased according to the deposit amount. Then, in BalanceHandler.finalize(), the function TokenHandler.transfer() is invoked with the asset token and the value of balanceState.netAssetTransferInternalPrecision (converted to external precision), and transfer tokens from the account (itself) to itself, and no tokens are actually transferred. \u25cf In the second action, in BalanceHandler.finalize(), the function TokenHandler.redeem() is invoked with the asset token and the amount we want to withdraw (it can be the entire balance of that account, we have just \u201cdeposited\u201d tokens to it), redeeming the asset tokens that other users have deposited into the system, and then the function TokenHandler.transfer() is invoked with the underlying token, transferring the amount of underlying tokens that the system received from the redeem action, to itself. The system is now unaware that is holds this underlying tokens and they will be unreachable, and effectively lost. Mitigation/Fix: Add a require statement in TokenHandler.transfer() that the account cannot be the contract itself (Notional\u2019s address), to prevent self transfers. Notional Response We\u2019ve added guards the prevent invalid addresses from accessing any of the trading or deposit actions in ActionGuards.sol \fSeverity: Low Issue: Description: Missing validation of currencyId, maturity and assetType in PortfolioHandler.addAsset() The function PortfolioHandler.addAsset() is missing require statements that validates the values of currencyId, maturity and assetType when a new asset is inserted into the portfolioState.newAssets array. The only validation is done when that portfolio is stored on storage, in PortfolioHandler.storeAssets(), during the internal call to _encodeAssetToBytes(). Mitigation/Fix: Add require statements that validates these values.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "Description:", "body": "Incorrect calculation of zero\u2019s MSB The functionBitmap.getMSB() returns 0 for the input x=0, although the MSB of zero is not defined. Mitigation/Fix: Revert if the input x is zero.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Low"]}, {"title": "AccountContextHandler.setActiveCurrency() can insert an inactive", "body": "currency id into an account context Description: If the arguments for AccountContextHandler.setActiveCurrency() are isActive=true and flags=0x0000 then the currencyId can be inserted into accountContext.activeCurrencies with no flags at all, meaning that it wasn\u2019t supposed to be inserted in the first place. Mitigation/Fix: Add a require statement that prevents flags from being zero when isActive=true. \fSeverity: Low Issue: PortfolioHandler.buildPortfolioState() incorrectly implements an optimization for adding multiple new assets Description: The function PortfolioHandler.buildPortfolioState() should initialize state.newAssets to an array with length of newAssetsHint, as an optimization for a following addition of multiple new assets, but it doesn\u2019t do it if assetArrayLength=0. Mitigation/Fix: Initialize state.newAssets also when assetArrayLength=0.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Low"]}, {"title": "Description:", "body": "PortfolioHandler.addAsset() and PortfolioHandler.storeAssets() incorrectly use portfolioState.newAssets.length as the number of new assets. The functions PortfolioHandler.addAsset() and PortfolioHandler.storeAssets() use portfolioState.newAssets.length as the number of new assets in the portfolio, although the portfolioState.newAssets array isn\u2019t necessarily full. The correct number of new assets is stored at portfolioState.lastNewAssetIndex. The value of portfolioState.newAssets.length can only be used as an upper bound for the number of new assets. Mitigation/Fix: Use portfolioState.lastNewAssetIndex as the number of new assets in the portfolio, instead of portfolioState.newAssets.length.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Low"]}, {"title": "Description:", "body": "Insufficient validation of currencyId in PortfolioHandler._encodeAssetToBytes() The function PortfolioHandler._encodeAssetToBytes() only requires that currencyId will fit in uint16, but it also must not be greater than Constants.MAX_CURRENCIES. Mitigation/Fix: Change the current require statement to restrict currencyId to be less than or equal to Constants.MAX_CURRENCIES. \fSeverity: Recommendation Issue: Description: Unnecessary checks for a constant value in AccountContextHandler.setActiveCurrency() The function AccountContextHandler.setActiveCurrency() checks the value of isActive 4 times on every loop iteration, although this value never changes. Mitigation/Fix: Save gas by checking the value of isActive only once.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Low"]}, {"title": "Description:", "body": "Unnecessary array boundaries checks When loading an array element more than once, there is no reason to check again that the index doesn\u2019t exceed the array limits. Mitigation/Fix: Save gas by caching the array element in a local variable instead of loading it again.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Computation of a value that isn\u2019t necessarily used in", "body": "AccountContextHandler.isActiveInBalances() Description: The function AccountContextHandler.isActiveInBalances() computes isActive on every loop iteration, although it is not used in most iterations Mitigation/Fix: Save gas by computing isActive only when it is necessary.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Early exit optimization in AccountContextHandler.isActiveInBalances()", "body": "Description: The function AccountContextHandler.isActiveInBalances() can return false in case it finds currencyId in the active currencies \u201carray\u201d and its ACTIVE_IN_BALANCES flag is off. There is no reason to continue iterating over the rest of the active currencies. Mitigation/Fix: Save gas by returning false in this case, instead of continuing to iterate over the rest of the active currencies for no reason. \fSeverity: Recommendation Issue: Description: Complicated require statement in AccountContextHandler.setActiveCurrency() The complicated require statement after the while loop in AccountContextHandler.setActiveCurrency() that checks that the active currencies \u201carray\u201d contains less than 9 currencies, can be simplified to require(shifts < 9) because at this point, shifts equals the number of iterations that took place in the previous while loop that was iterating over this active currencies \u201carray\u201d. Mitigation/Fix: Save gas by simplifying this require statement to require(shifts < 9).", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Unnecessary castings in FloatingPoint56.unpackFrom56Bits()", "body": "Description: The function FloatingPoint56.unpackFrom56Bits() contains two unnecessary castings from uint256 to uint256. Mitigation/Fix: Remove these two unnecessary castings.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Unnecessary casting in", "body": "nTokenHandler.setNTokenCollateralParameters() Description: The function nTokenHandler.setNTokenCollateralParameters() contains an unnecessary casting from bytes32 to bytes32. Mitigation/Fix: Remove this unnecessary casting.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Unnecessary castings in", "body": "nTokenHandler.setArrayLengthAndInitializedTime() Description: The function nTokenHandler.setArrayLengthAndInitializedTime() contains two unnecessary castings from uint256 to uint256. Mitigation/Fix: Remove these two unnecessary castings. \fSeverity: Recommendation Issue: Description: Trivial require statement in nTokenHandler.setArrayLengthAndInitializedTime() The function nTokenHandler.setArrayLengthAndInitializedTime() requires lastInitializedTime to be greater than or equal to zero, even though it is a variable of type uint256. Mitigation/Fix: Remove this trivial require statement.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Trivial if statement in SettlePortfolioAssets.settlePortfolio()", "body": "Description: The function SettlePortfolioAssets.settlePortfolio() contains an if statement that checks whether an asset is a fCash, followed by an \u201celse if\u201d statement that checks if that asset is a liquidity token, while the only two options available for that asset\u2019s type are fCash and liquidity token. Mitigation/Fix: Save gas by changing the \u201celse if\u201d statement to an \u201celse\u201d statement.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Unnecessary require statement in DateTime.getTradedMarket()", "body": "Description: The function DateTime.getTradedMarket() begins with the require statement require(index != 0). This requirement is unnecessary because even without it, if index=0, there will still be a revert at the end of the function. Mitigation/Fix: Remove this unnecessary require statement. \fSeverity: Recommendation Issue: Unnecessary checked arithmetic in AssetHandler.getSettlementDate() Description: The add(Constants.QUARTER) operation in AssetHandler.getSettlementDate() perfoms an overflow check which is unnecessary because the function first subtracts marketLength, which is always greater than or equal to 2 * Constants.QUARTER in this case, and only then adds Constants.QUARTER to it. Mitigation/Fix: Save gas by replacing add(Constants.QUARTER) with + Constants.QUARTER.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Trivial require statement in BalanceHandler._setBalanceStorage()", "body": "Description: The function BalanceHandler._setBalanceStorage() requires lastClaimTime to be greater than or equal to zero, even though it is a variable of type uint256. Mitigation/Fix: Remove this trivial require statement.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/Notional1Nov2021.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Non-compliance of  maxFlashLoan  in the FlashMinter facilitator to", "body": "the EIP3156 standard Description: EIP3156 states that the function  maxFlashLoan  must return the maximum loan possible for the token, and return 0 instead of reverting if the token is not currently supported. The GhoFlashMinter  implmentation, however, may revert if bucketLevel > bucketCapacity . This can happen if the bucket's capacity gets reduced below the bucket's level. Mitigation/Fix: Fixed on commit 038442d.", "html_url": "https://www.certora.com/wp-content/uploads/2023/03/Aave_Gho_Formal_Verification_Report.pdf", "labels": ["Certora", "Low"]}, {"title": "Accumulated interest can be manipulated by the user", "body": "Description: Concrete Example: Calling  rebalanceUserDiscountPerecent  calculates the accumulated interest since the last operation made by the user. As part of this operation, the scaled discount given to the user is burned. This call decreases the total interest accumulated for this debt compared to the case of the exact same position taken without calling rebalance. Consider a user with  scaledBalance = 100 , 50% discount rate and 0 accumulated interest at time  t0 . The global index is 1, 2, and 4 at times  t0 ,  t1 , and  t2  respectively. In the first scenario the user calls  rebalanceUserDiscountPercent  at  t1  which updates the scaled balance to 75 and the accumulated interest to 50. At  t2  the \fIssue: Accumulated interest can be manipulated by the user user does the same call which updates the accumulated interest to 125. If instead, the user does only a single call to rebalanceUserDiscountPerecent  at  t2 , the accumulated interest balance would reach a total of 150. Mitigation/Fix: The use of  rebalanceUserDiscountPercent  or any other function that accumulates the user's interest, results in insignificant benefits for the end user given that the values of the expected configuration of interest and discount rates are low.", "html_url": "https://www.certora.com/wp-content/uploads/2023/03/Aave_Gho_Formal_Verification_Report.pdf", "labels": ["Certora", "Low"]}, {"title": "Using of  WadRayMath.sol  not according to guidelines", "body": "WadRayMath.sol  states that  wadMul/wadDiv  and  rayMul/rayDiv should be called with both operands should have the same format of WAD / RAY  respectively. In  ghoVariableDebtToken.sol  there are multiple occasions where  rayMul  and  rayDiv  are called with the first operand being some token balance (both scaled and not- scaled) which is formatted as  WAD , and the second operand being the index which is formatted as  RAY . The  GhoVariableDebtToken  contains code that belongs to the standard Aave  VariableDebtToken  implementation. Although it is not natural to use  WadRayMath  functions with operands that aren't in the same format, these calculations provides a result with correct format. Description: Mitigation/Fix:", "html_url": "https://www.certora.com/wp-content/uploads/2023/03/Aave_Gho_Formal_Verification_Report.pdf", "labels": ["Certora", "Informational"]}, {"title": "Precision loss during voting power transfer", "body": "When calculating delegated balance on token transfer, the new delegated balance of a delegate was calculated with a small precision loss that violated the property after a delegator to delegatee1 transfers z amount of tokens. vpTransferWhenOnlyOneIsDelegating (Property #6) and others The issue was fixed in commit a287d134 and the relevant property was modified to be  Description: Property Violated: AAVE Response: List of Issues Discovered Independently By The Community", "html_url": "https://www.certora.com/wp-content/uploads/2022/09/Formal-Verification-Report-of-AAVE-Token-V3.pdf", "labels": ["Certora", "Low"]}, {"title": "Wrong parameters order in a  _transferWithDelegation  call", "body": "This issue was present in an intermediary version of the code given to the community to verify, but not in the finalized version that Certora has verified. It was introduced for a short period of time during development, and immediately fixed by the AAVE team. multiple properties The issue was fixed in commit 190c03f4 Description: Property Violated: AAVE Response:", "html_url": "https://www.certora.com/wp-content/uploads/2022/09/Formal-Verification-Report-of-AAVE-Token-V3.pdf", "labels": ["Certora", "High"]}, {"title": "Withdrawal of all KashiPair assets", "body": "Rules Broken: No change to other\u2019s borrowed asset Description: A user can borrow all available asset tokens on behalf of a third party that is not checked for solvency. Fix: Users can only borrow for themselves and only when they are in a solvent state.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/KashiLendingMar2021.pdf", "labels": ["Certora", "Critical"]}, {"title": "Loss of system's assets during liquidation", "body": "Rules Broken: Balance change in liquidation Description: The cook function, a function for batch processing, allows a user to invoke KashiPair the collateral is transferred to the user but no assets are transferred to the system. to perform a liquidation, in which case, Fix: Disabled calls to KashiPair in the cook function", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/KashiLendingMar2021.pdf", "labels": ["Certora", "Critical"]}, {"title": "Denial of service in deposit", "body": "Rules Broken: Integrity of add collateral Description: Due to the miscalculation of total collateral, when a user skims (adds collateral to the KashiPair and then claims the excess balance) the transaction reverts. Fix: Total collateral calculation corrected www.certora.com \fSeverity: Medium Status: Fixed Issue: Malicious KashiPair may trick users to lose assets Rules Broken: N/A Description: A kashiPair initialized with only asset token and no collateral token can be reinitialized with a different asset token, thus causing loss to asset providers. Fix: Cannot initialize a KashiPair with zero collateral", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/KashiLendingMar2021.pdf", "labels": ["Certora", "High"]}, {"title": "Utilization computation", "body": "Rules Broken: Integrity of interest accrued Description: During accrue, the utilization is miscalculated, which might make the utilization more than 100%. Fix: Utilization calculation corrected in accrue", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/KashiLendingMar2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "Loss of assets and higher joining requirement for asset providers", "body": "Rules Broken: Add then remove asset Description: Due to the rounding error, depositing asset tokens can result in zero fractions. Repeating this process results in a state where asset providers wouldn\u2019t want to join KashiPair. Fix: Require some minimum assets units in KashiPair www.certora.com \f", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/KashiLendingMar2021.pdf", "labels": ["Certora", "Low"]}, {"title": "A  staticAToken  user can be owed a large sum of reward by the", "body": "staticAToken  if it's not yet registered Rules Broken: Property #44 -  getClaimableRewards_stable . see violation Description: Consider a reward token ( REW ) distributed through the INCENTIVES_CONTROLLER  to a reward-bearing token that the \fIssue: A  staticAToken  user can be owed a large sum of reward by the staticAToken  if it's not yet registered Concrete Example: StaticAToken  holds. At any time, a  staticAToken  user can invoke any claim method with an array that contains this  REW  token. If this token is not registered in the  StaticATokenLM 's reward list, the user\u02bcs  rewardsIndexOnLastInteraction  will be 0 by default. When, later,  getClaimableRewards()  is called, the rewardsIndexOnLastInteraction  sent to compute the pending rewards will depend on the value of the user's rewardsIndexOnLastInteraction . That value is the one which will be sent if it is non-zero; however, if the value is zero, _startIndex[REW]  will be sent instead. This variable represents a snapshot of the index at the time of registration. However, since the reward isn\u02bct registered, the user\u02bcs index has never been updated, and therefore it is zero. In addition, since the reward isn\u02bct registered the  startIndex[REW]  is 0. that means that the pending rewards will be calculated as:  (balance * currentRewardsIndex)/assetUint This will make the  staticAToken  owe a large amount of rewards to any user who makes a claim before the registration of the asset. In fact, the  staticAToken  may owe one or more of its users a larger amount than the incentive owes to the static Token. 1. Take an initialized  staticAToken  that just started to work with a list of 3 reward tokens that deserve to be collected thanks to the distribution of the incentive controller. 2. On initialization, the contract will register those three tokens in the  staticToken  internal list. 3. User1 is depositing for the first time at a time  t , which updates his user state, i.e. unclaimed, as well as a snapshot of the index at the time of operation. 4. At time  t' > t , a new token, REW , is added to the list of rewards that the  staticAToken  is eligible to claim. 5. Nobody refreshes the reward list in the StaticAToken . 6. User1 take any action he desires, including depositing a lot of money. 7. At time  t'' > t' , after some  REW s are starting to accumulate in the incentive controller for the staticToken 's right, user1 realises that he\u02bcs eligible for his share of REW  and tries to claim it through one of the  claim  functions of the staticAToken . 8. Since the rewards aren\u02bct registered, the user\u02bcs rewardsIndexOnLastInteraction  is never updated and stays at the default value of 0. 9. The pending rewards that  staticToken  is now owed to the user is  [user_balance * (currentIndex - 0)]/assetUnit . This value can be greater than the value actually owed by the incentive controller to the  staticAToken . If user1 is the only user in the system  staticAToken.balanceOf(user) = \fIssue: A  staticAToken  user can be owed a large sum of reward by the staticAToken  if it's not yet registered incentiveController.deservedRewards(asset, reward, staticAToken)  however, the current index of the  staticAToken  on the incentive controller must be greater than 0 because the reward- bearing token (AToken in this case) makes sure to update the code upon transfer (in  handleAction ). Mitigation/Fix: Fixed in PR #29", "html_url": "https://www.certora.com/wp-content/uploads/2023/05/Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "Medium"]}, {"title": "Losing one share worth of assets upon deposit", "body": "Rules Broken: Property #14 -  withdrawCheck . see violation Description: Concrete Example: Suppose a user calls the  deposit()  function with an asset amount anywhere in the range  [x/2, x+1)  AToken. In that case, the deposit()  function will round up the amount of Atokens that needs to be transferred from the sender but will round down the number of staticAToken  shares the receiver gets in return. For example, the user sends x+1 Atokens, but receives only x  staticAtokens . 1. A user calls  deposit()  with an asset amount of 9 underlying tokens. The  fromUnderlying  flag is  false , so the AToken.transferFrom()  function is called. 2. AToken.transferFrom()  function eventually calls the AToken._transfer()  function. This function converts the user- specified underlying asset amount to the number of ATokens by calling the  rayDiv  function with the current rate and asset amount. 3. Due to round-up,  rayDiv  returns 1 AToken, which is equivalent to 18 underlying tokens. 4. 1 AToken is transferred from the user to the staticAToken  contract. 5. The  Deposit()  function proceeds to calculate the shares to be minted to the user.  rayDivRoundDown  is called with the rate and the asset amount (9). Due to round-down, rayDivRoundDown  returns 0. 6. The user gets 0 shares in return for the 1 AToken deposited in the vault. Mitigation/Fix: Fixed in PR #25", "html_url": "https://www.certora.com/wp-content/uploads/2023/05/Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "Low"]}, {"title": "Non-compliance of  deposit()  with the EIP4626 standard", "body": "Rules Broken: Properties #11 & #12 -  depositCheck . see violation \fIssue: Non-compliance of  deposit()  with the EIP4626 standard Description: Concrete Example: As per EIP4626,  deposit()  must revert if all the assets cannot be deposited. In the contract, if the user calls  deposit()  with an amount of underlying assets that are less than the equivalent of half an AToken, the function will end up depositing no assets but will inappropriately fail to revert. 1. A user calls the deposit function with 547 of underlying asset tokens. The  fromUnderlying  flag is  false , so the AToken.transferFrom()  function is called. 2. AToken.transferFrom()  function eventually calls AToken._transfer() . This function converts the user-specified underlying asset amount to the number of  ATokens  by calling rayDiv  with the current rate and asset amount. 3.  rayDiv  function returns  0  as the asset amount is less than  rate/(2RAY) . As a result,  0 ATokens  get transferred from the user to the staticAToken  contract. 4. The function proceeds with the rest of the execution without reverting. Mitigation/Fix: Fixed in PR #25", "html_url": "https://www.certora.com/wp-content/uploads/2023/05/Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "Low"]}, {"title": "Inconsistency of  getUnclaimedRewards()  return value units", "body": "Rules Broken: Property #38 -  rewardsConsistencyWhenInsufficientRewards . see violation Description: All the reward-related methods -  _getPendingRewards() , collectAndUpdateRewards ,  _getClaimableRewards , etc., compute and return values in the reward token units. However, getUnclaimedRewards()  incorrectly assumes that the user's unclaimedReward  amount is stored in  RAY  units and converts it to WAD . This can cause external protocols relying on the getter's result to interpret and function in a false state. Mitigation/Fix: Fixed in PR #24", "html_url": "https://www.certora.com/wp-content/uploads/2023/05/Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "informational"]}, {"title": "Non-compliance of  totalAssets()  and  maxWithdraw  with the", "body": "EIP4626 standard Rules Broken: Property #21 & #26 - totalAssetsMustntRevert , maxWithdrawMustntRevert see violation \fIssue: Non-compliance of  totalAssets()  and  maxWithdraw  with the EIP4626 standard Description: Mitigation/Fix: As per EIP4626, both  maxWithdraw()  and  totalAssets()  mustn't revert by any means. The implementation, however may revert due to overflow when calling  rayMulRoundDown  in the first function and rayMul  in the second. The only way these methods can revert is when  a*b > type(uint256).max , where  a  is the  amount  and  b  is the normalizedIncome . With the following assumptions in mind: (1) type(uint256).max ~=10\u2077\u2077 , (2)  normalizedIncome  will always be around  10^27 , even with some margin on the index, the revert case will occur only when  amount > 10^45 . This is an unreasonably large amount of tokens assuming  token decimals <= 18 . All this makes the compliance violation purely theoretical with the currently used tokens.", "html_url": "https://www.certora.com/wp-content/uploads/2023/05/Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "informational"]}, {"title": "_claimRewardsOnBehalf()  stops handling rewards after it", "body": "encounters address 0 Recommendation: The function  _claimRewardsOnBehalf()  iterates over an array of rewards passed to it by the user via one of the external claim functions. Currently, the function short-circuits at the first occurrence of address 0 in the array - it exits the function by executing  return . Although it is a viable way to handle claims, replacing the  return  with  continue  and being more forgiving to protocols that make mistakes in constructing the array is possible. Mitigation/Fix: Fixed in PR #27", "html_url": "https://www.certora.com/wp-content/uploads/2023/05/Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Rules", "body": "Broken: A governance with a voting token that has 0 total supply will consider all current and future proposals to have reached quorum. quorumReachedEffect ,  proposalNotCreatedEffects , proposalInOneState \fA governance with a voting token that has 0 total supply will Issue: consider all current and future proposals to have reached quorum. Description: A voting token with 0 token supply will result in all proposals being considered as having reached quorum. This can be an issue in the case that the token has not been initialized/minted, but this case is not as interesting because there will be no tokens to vote with. A more interesting case can arise if the voting token's  totalSupply  is accidentally set to 0. This will allow all proposals to reach quorum and thus be executable as long as the vote is successful. This is an edge case that should never manifest as long as tokens withhold the invariant that total supply is equal to the sum of all Response: balances, as in this case no one will be able to vote for a proposal and the condition for a successful proposal will never be met (more for votes than against votes).", "html_url": "https://www.certora.com/wp-content/uploads/2022/10/OZ-final-report.pdf", "labels": ["Certora", "Low"]}, {"title": "Rules", "body": "Broken: Description: TimelockController  should not have additional executors beside the governor ( GovernorTimelockControl._execute() ) None An executor can execute a scheduled operation on the TimelockController  by calling  TimelockController.execute . If the operation was queued using  GovernorTimelockControl.queue , this will cause  GovernorTimelockControl.execute  to revert as the proposal has already been executed by the  TimelockController . (Same issue with calling  TimelockController.cancel ) Agreed, but probably not any significant consequence. The only Response: consequence is that if the proposal is executed directly in the timelock, the \"ProposalExecuted\" event will never be emitted.", "html_url": "https://www.certora.com/wp-content/uploads/2022/10/OZ-final-report.pdf", "labels": ["Certora", "Low"]}, {"title": "Rules", "body": "Broken: Description: Protocol hijack by single validator transacationDoesNotExistsImpliesNotConfirmed In the  removeTransaction()  function, removing a transaction does not set all its confirmations to false. This leaves the  transactionId that was removed as pre-confirmed, so a following transaction to that transactionId  will be immediately executed (as it already has \fIssue: Protocol hijack by single validator enough votes). An attacker could leverage this to call upgradeContract()  function and take control over the protocol The vulnerable removeTransaction function was removed in aa1a4. Asset value upgrade Calling  upgradeAsset()  on an asset from a low-value token to a high-value token would greatly increase the value a user already owns on that  assetId . This improper increase would cause insolvency. The vulnerable updateAsset function was removed in 62e64. Double execution of same request dcSpark Response:", "html_url": "https://www.certora.com/wp-content/uploads/2023/01/Formal-Verification-Report-of-dcSpark-Sidechain-Bridge-2.pdf", "labels": ["Certora", "Critical"]}, {"title": "Rules Broken:", "body": "Description: dcSpark Response:", "html_url": "https://www.certora.com/wp-content/uploads/2023/01/Formal-Verification-Report-of-dcSpark-Sidechain-Bridge-2.pdf", "labels": ["Certora", "Critical"]}, {"title": "Rules", "body": "Broken: A malicious validator could migrate a proposal that it wants to duplicate and not sign it on-chain. The malicious validator would call the  migrate()  when ( quorum  - 1) signatures are obtained. This would enable them to sign the proposal off-chain and send it to the Description: other side, while the migrated proposal would also likely be signed and sent. Unless the migration process on this side is tracked very tightly by all good validators and the other side's bridge, it would be impossible to distinguish between such a malicious duplication and an actual case of two proposals with the same request. The vulnerable migrateProposal function was removed in b3179. dcSpark Response:", "html_url": "https://www.certora.com/wp-content/uploads/2023/01/Formal-Verification-Report-of-dcSpark-Sidechain-Bridge-2.pdf", "labels": ["Certora", "Critical"]}, {"title": "DOS by a validator frontruns transactions", "body": "Rules Broken: nonDOS A malicious validator can  voteForTransaction  with the id of the future transaction he wants to prevent and then this transaction will not be able to be submitted. This is a DOS to any transaction that the malicious validator wants to prevent and he can even prevent his removal because he can prevent this transaction. The bridge contract is only deployed to networks where consensus is controlled by the same set of validators that controls the contract. For example, the Milkomeda C1 sidechain is run by the bridge contract validators operating under the IBFT consensus. Under honest majority assumption a corrupt validator will not be able to block their removal from the contract for instance because they can be ejected as a validator on the consensus level (bypassing any communication via EVM transactions). Description: dcSpark Response:", "html_url": "https://www.certora.com/wp-content/uploads/2023/01/Formal-Verification-Report-of-dcSpark-Sidechain-Bridge-2.pdf", "labels": ["Certora", "High"]}, {"title": "Vote on canceled Unwrapping Proposal", "body": "Rules Broken: \fIssue: Vote on canceled Unwrapping Proposal Validators can vote on a canceled Unwrapping Proposal and may lead to its execution if the quorum is reached. This can happen because there is no way to distinguish between a canceled UPT and a confirmed UPT. The vulnerable migrateProposal function was removed in b3179. Description: dcSpark Response:", "html_url": "https://www.certora.com/wp-content/uploads/2023/01/Formal-Verification-Report-of-dcSpark-Sidechain-Bridge-2.pdf", "labels": ["Certora", "High"]}, {"title": "DOS by Reset all voting on unwrappingProposals", "body": "Rules Broken: Description: dcSpark Response:", "html_url": "https://www.certora.com/wp-content/uploads/2023/01/Formal-Verification-Report-of-dcSpark-Sidechain-Bridge-2.pdf", "labels": ["Certora", "High"]}, {"title": "Rules", "body": "Broken: Description: dcSpark Response:", "html_url": "https://www.certora.com/wp-content/uploads/2023/01/Formal-Verification-Report-of-dcSpark-Sidechain-Bridge-2.pdf", "labels": ["Certora", "Medium"]}, {"title": "unwrapping proposal getting stuck after quorum change", "body": "Rules Broken: Description: If an unwrapping proposal has vote count 'x' that is less than the quorum and the quorum is changed to be less than 'x', the \fIssue: unwrapping proposal getting stuck after quorum change unwrapping proposal will never be executed and will remain stucked because it is flaged as not closed but it's voting had reached the quorum dcSpark Response: Fixed by adding  confirmUnwrappingProposalTransaction . to confirm unwrapping proposal transactions that it's votes had reached the quorum", "html_url": "https://www.certora.com/wp-content/uploads/2023/01/Formal-Verification-Report-of-dcSpark-Sidechain-Bridge-2.pdf", "labels": ["Certora", "Low"]}, {"title": "Replace to zero validator", "body": "Rules Broken: zeroNotValidator The notnull modifier was missing in the  replaceValidator function meaning a majority could add 0x0 as a validator by mistake. Fixed in 35a12. Description: dcSpark Response:", "html_url": "https://www.certora.com/wp-content/uploads/2023/01/Formal-Verification-Report-of-dcSpark-Sidechain-Bridge-2.pdf", "labels": ["Certora", "Low"]}, {"title": "Anyone can call  flashLoan  for a receiver [ERC20FlashMint]", "body": "Description: Anyone can call  flashLoan  for a  receiver . An attacker can call flashLoan  repeatedly on a receiver and drain its funds as the receiver contract has to pay back extra  fee . Response: We've implemented EIP-3156. If a receiver pays a fee, they should validate the initiator in onFlashLoan", "html_url": "https://www.certora.com/wp-content/uploads/2022/11/final-report-3.pdf", "labels": ["Certora", "Medium"]}, {"title": "Votes.sol  can only support token supply upto 2^224 - 1", "body": "[Checkpoints.sol push()] Description: Since  Votes.sol  uses  Checkpoints.push , which casts the new value to  uint224 , it is only able to support token supply up till type(uint224).max . If this is indeed the case, they should mention it in the comments as they have done it for  ERC20Votes.sol Response: Votes is an abstraction of the mechanisme that was first introduced in ERC20Votes . Both are limited, by design, to uint224. We will improve Votes  documentation to more clearly reflect that limitation.", "html_url": "https://www.certora.com/wp-content/uploads/2022/11/final-report-3.pdf", "labels": ["Certora", "Informational"]}, {"title": "Extra unnecessary require [Votes.sol getPastTotalSupply()]", "body": "Description: require(blockNumber < block.number)  is checked twice when calling getPastTotalSupply() Response: The redundant require in  getPastTotalSupply  was indeed missed. The check should should indeed be removed from  Votes.sol  to save gas \fSeverity: Informational Issue: Checkpoint Overflow [ERC20Votes.sol, draft-ERC721Votes.sol] Description: Should the number of checkpoints go past 2^32 uint32 index used will no longer function properly resulting in a loss of votes. However, since the property that only one checkpoint per block number is held, this is not believed to be an issue in a realistic time frame The \"key\" art of the Checkpoints is uint32 that is currently used to store block numbers. Having it overflow would be a real issue, but we consider it very unlikelly to ever overflow, at list considering the current Response: chain design. Even if someone was to use block.timestamp based checkpoint to circumvent the unpredictable nature of block number on some L2s (which is a feature that our code doesn't provide out of the box), that overflow would happen in the year 2106.", "html_url": "https://www.certora.com/wp-content/uploads/2022/11/final-report-3.pdf", "labels": ["Certora", "Informational"]}, {"title": "Equal addresses of contract and  msg.sender  [ERC20Wrapper.sol", "body": "depositFor()/withdrawTo()] Description: Contract's address( address(this) ) can be equal to the  msg.sender , thus, it's posssible to deposit/withdraw without limits The hability to mint  ERC20Wrapper  tokens without a counterpart, while apparently not serious, has the ability to create a serious inconsistency between the totalSupply and the amount of underlying token. This could confuse external observer. Additionnaly, extensions of the ERC20Wrapper might include functionnality that use these additionals \"unbacked\" tokens. We will add a check to prevent this. Response:", "html_url": "https://www.certora.com/wp-content/uploads/2022/11/final-report-3.pdf", "labels": ["Certora", "Low"]}, {"title": "Users can prevent their accounts from being liquidated", "body": "Description: Due to a require statement that is tested during liquidation, users can force all attempts to liquidate their accounts to fail and revert (details below). Response: This issue depends on a malicious asset being promoted out of borrow isolation. Euler has done the suggested hardening to block this speci\ufb01c attack, but governance should be aware the promotion of a malicious asset still has other serious security implications (see the Euler documentation), and assets must be thoroughly vetted before removing isolation or adding collateral factors. www.certora.com \fSeverity: High Issue: \u201cExact output\u201d swaps via Uniswap can leave Uniswap with allowance from Euler Description: The return value from IERC20.approve() is ignored in some cases, allowing to reset Uniswap\u2019s allowance from Euler, they don\u2019t check the return value, which according to the ERC-20 Token Standard, is a boolean value indicating whether the operation succeeded (details). Response: For this problem to occur, an honest token would have to have an approve() method that fails, and that failure must be indicated with a return value of false (instead of reverting). Although we aren\u2019t aware of any such tokens, the Swap module now uses safeApprove() everywhere, as suggested.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/EulerNov2021.pdf", "labels": ["Certora", "High"]}, {"title": "Parameters for multihop swaps via Uniswap aren\u2019t validated", "body": "Description: The functions Swap.swapUniExactInput() and Swap.swapUniExactOutput() don\u2019t properly check params.path, making it possible to steal tokens from Euler (details below). Response: The Swap module depends on approvals being maintained properly. This attack requires approvals to be accidentally granted somehow (potentially as described in the previous issue). As suggested, Euler now makes additional checks on the Uniswap path to validate that the tokens in the path are as expected, although the primary security enforcement remains the approvals system. www.certora.com \fSeverity: Medium Issue: \u201cExact output\u201d swaps via Uniswap don\u2019t support all ERC-20 tokens Description: Many commonly used tokens do not return a boolean from IERC20.approve(); Euler methods will revert for these tokens (details). Response: This was also addressed by changing the Swap module to use safeApprove() everywhere (see above).", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/EulerNov2021.pdf", "labels": ["Certora", "High"]}, {"title": "Parameters for swaps via 1inch aren\u2019t validated", "body": "Description: The function swap1Inch() doesn\u2019t check that params.payload matches params.underlyingIn, params.underlyingOut and params.amount. It also doesn\u2019t check that params.payload speci\ufb01es Euler\u2019s address as both the account who gives away tokens to 1inch and the account who receives the tokens from 1inch. Response: Acknowledged. 1inch has a variety of methods and is used as a black box. To allow the users to use all 1inch\u2019s functions, the code doesn\u2019t enforce any speci\ufb01c format for params.payload. It relies on the approval mechanism of ERC-20 tokens to prevent any malicious swaps. www.certora.com \fSeverity: Medium Issue: Exec.pTokenWrap() doesn\u2019t work with \u201cde\ufb02ationary\u201d ERC-20 tokens Description: Euler is intended to work with de\ufb02ationary tokens, but Exec.pTokenWrap() will fail with these tokens (details). Response: PTokens can only be created for collateral assets. One of the criteria for collateral assets is that their balances are \u201cwell behaved\u201d, which excludes de\ufb02ationary tokens.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/EulerNov2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "BaseLogic.decreaseBorrow can also increase debt and emit a", "body": "Borrow event Description: In some cases, rounding error can cause decreaseBorrow to increase the borrow instead (details). Response: Acknowledged. This is a necessary consequence of the design. In order for off-chain systems to properly track the debt owed by an account, Borrow and Repay events are issued. However, interest is accrued second-by-second, which obviously cannot be tracked in real-time with events. To solve this, when an account\u2019s borrow is re-assessed (which it must be in order to increase or decrease a borrow), the accrued interest must be logged. To reduce gas usage and simplify the implementation, what is actually logged is the change in the borrow. So a repay operation for X units will actually result in a Repay event of only X-I units, where I was the interest that accrued. If the repay amount X is in fact smaller than I, then (counter-intuitively) a Borrow event will be issued instead. www.certora.com \fSeverity: Low Issue: Missing initialization of the installer module address Description: A missing initialization results in higher gas costs in every call coming through the installer proxy (details). Response: This only has a gas impact when invoking the Installer module, which is a relatively rare operation and is paid for by governance when upgrading modules, and never by protocol users. Nevertheless, we\u2019ve added the initialisation as suggested.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/EulerNov2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "View functions in Markets have unde\ufb01ned behavior on invalid", "body": "input Description: Several view functions in Markets behave inconsistently when their input pair is an invalid underlying token pair Response: This was originally by design, however after discussion with Certora we\u2019ve decided to de\ufb01ne this behaviour for methods where applicable (in the nat spec documentation), and by reverting with error messages elsewhere.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/EulerNov2021.pdf", "labels": ["Certora", "Low"]}, {"title": "Code cleanliness and gas optimizations", "body": "Description: During our manual code review, we found several small details that could be improved (details). Response: We have implemented some of the suggested optimisations, where it had a measurable improvement and made sense to do so. www.certora.com \f", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/EulerNov2021.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Unexpected revert of queued actions", "body": "\fIssue: Unexpected revert of queued actions When invoking  _queue  with a batch of transactions, an action hash is calculated using the  keccak256  algorithm on the transaction parameters as the arguments, together with the  executionTime , defined as $$block.timestamp + _ delay $$ Given two similiar actions Description: (same function and arguments) in two different blocks, it is possible that after the first one was queued in the first block, the second one will lead to revert since there is a check of queued actions duplication. The execution time could have the same value for both actions if the delay was shortened between these two blocks such that the sum of delay and time stamp is the same. The aforementioned situation leads to an unexpected revert for this function call. Property Violated: independentQueuedActions (Property #18) The community should be aware that any update of the executor parameters could affect the regular behaviour of the queued action AAVE Response: sets of the contract. Then, governance proposals that change the parameters of the executors should be carefully reviewed taking into the account the current state of the executor contract and its queued action sets.", "html_url": "https://www.certora.com/wp-content/uploads/2022/07/Formal-Verification-Report-of-AAVE-L2-Bridge-July22.pdf", "labels": ["Certora", "Low"]}, {"title": "Impossible to queue two similar actions", "body": "Description: _queue()  includes a check whether an action was previously queued but yet to be executed. It does that in order to prevent action duplication in the same block (same actions in different block are allowed). The check is done by mapping each action by its signature, arguments and execution time to a  bytes32  hash and assigning each action hash a boolean (mapping) variable  _queuedActions[bytes32] . The revert due to the action duplicity prevents any proposal which includes two similar transactions, even if not subsequent. In the case where the proposal wants to execute duplicated actions on AAVE Response: purpose the use of payload contracts is encouraged. Payload contracts help to make all actions of a sophisticated / more complicated proposal clearer and easier to get tracked.", "html_url": "https://www.certora.com/wp-content/uploads/2022/07/Formal-Verification-Report-of-AAVE-L2-Bridge-July22.pdf", "labels": ["Certora", "Low"]}, {"title": "Unexpected action Occurrence upon low-level call", "body": "\fIssue: Unexpected action Occurrence upon low-level call Description: In the methods  executeDelegateCall  and _executeTransaction  an explicit low-level call is being made on a given target address. The default behavior of such a call in case that the target address does not exist is returning  success == true  (see in solidity docs). In this case, if the proposal was to specify a target that does not exist the following consequences will apply: 1. The methods will return a success value while the no actual action is being executed. 2. An event will be emitted by  execute  with a new  actionsSetId , the address of the  execute  caller, and the  returndata  which will be empty. While the Eth refunded to the executor can be restored by raising a proposal, the emitted event may be misleading - making observers think that the action indeed succeed. Recommendation: It might be worth to check whether the target contract exist by checking the address code size prior to executing. AAVE Response: There could be a case where an action wants to send some value to a pre-calculated address of a contract that will be deployed later on.", "html_url": "https://www.certora.com/wp-content/uploads/2022/07/Formal-Verification-Report-of-AAVE-L2-Bridge-July22.pdf", "labels": ["Certora", "Low"]}, {"title": "disableRecoveryMode() can be called while not in recovery mode", "body": "Severity: LOW Rules Broken: None \fIssue: disableRecoveryMode() can be called while not in recovery mode Description: When disableRecoveryMode() is called, it does not check whether or not the system is currently under recovery mode. Rather, it sets recovery mode to false and conducts subsequent updates. In that case the system behaves as if recovery mode was enabled and immediately disabled. It's an interesting finding, though it does Response: not changes the permissions model much, since disabling recovery mode is an extremely rare occurrence It does make for a weird footnote -------- -------- Issue: exiting in recovery mode is advantageous to users Severity: INFORMATIONAL Rules Broken: None Exiting in recovery mode is sometimes more advantageous over Description: exiting in non-recovery mode. We have investigated further to see if a join/exit sequence can be profitable or be used to manipulate prices, however we have not found a scenario for intentional manipulation Response: Aware of potentially advantageous exits in recovery mode. -------- -------- Issue: Denial of Service for increasing amplification factor Severity: INFORMATIONAL Rules Broken: amplificationUpdateCanFinish Description: The startAmplificationUpdate() function allows for value of endTime, the result is that the updating value will continue to be true stopping the system from ever allowing for more amplificationFactorUpdates Response: This issue can be ignored by using the stopAmplificationParameterUpdate() function", "html_url": "https://www.certora.com/wp-content/uploads/2022/11/Balancersept22.pdf", "labels": ["Certora", "Low"]}, {"title": "Zero minimum quorum", "body": "Description: In  Executor.sol , it is possible to set the  minimumQuorum to zero. In this case, the significance of a quorum becomes redundant. Response: A check was added in commit 0d9f679", "html_url": "https://www.certora.com/wp-content/uploads/2022/09/Security-Review-of-Aave-Governance-V2-Update.pdf", "labels": ["Certora", "Low"]}, {"title": "Zero or 100% proposition threshold", "body": "In  Executor.sol , it is possible to set the  propositionThreshold to zero. In this case, every proposal could be submitted with no Description: restriction whatsoever on the voting power of the submitter. The threshold could also be set to 100%, but smaller values could prevent almost any proposal from being submitted. Response: A check was added in commit 0d9f679", "html_url": "https://www.certora.com/wp-content/uploads/2022/09/Security-Review-of-Aave-Governance-V2-Update.pdf", "labels": ["Certora", "Low"]}, {"title": "Zero grace period", "body": "Description: In  Executor.sol , it is possible to set the  gracePeriod  in the constructor to zero. If done on purpose or by accident, executing proposals' action sets will be impossible. Response: A check was added in commit 06d71de Informational Issue: Potential use of Level 1 proposal system as a voting proxy for Level 2 proposal system. \fIssue: Potential use of Level 1 proposal system as a voting proxy for Level 2 proposal system. The process of using the  AaveEcosystemReserveV2 's voting power on a Level 2 proposal can be similarly repeated in the future. By raising a proposal on Level 1 to upgrade the reserve's implementation and bump the revision number,  initialize  will be available to be used once again to boost a new Level 2 proposal, or in a worse case, a dedicated functionality for this procedure could be added. Considering the new lower Level 2 conditions and the current AAVE Description: amount in reserve, such functionality, in effect, will allow passing a Level 2 proposal by passing a proposal on Level 1. Taking the current state of things, according to BGDLabs' proposal, the new 'YES' amount needed to pass a vote on Level 2 will be lowered to 1'040'000, while the  AaveEcosystemReserveV2  has a voting power of 1'625'351 votes. This is well above the necessary 'YES' amount needed to pass a proposal, making even the differential 'YES/NO' barrier very hard to use as a veto mechanism. Aave Response: We don't think anybody was aware of this possibility before the proposal. We want to make a clear statement that it should not be something to normalize. Yes, it is clear that it becomes easier to \"cheat\" on future Level 2 votes, but there are multiple protections to avoid that (Guardian with cancel, etc.).", "html_url": "https://www.certora.com/wp-content/uploads/2022/09/Security-Review-of-Aave-Governance-V2-Update.pdf", "labels": ["Certora", "Low"]}, {"title": "User unable to receive LP tokens", "body": "\fIssue: User unable to receive LP tokens user.hasWithdrawnPair  is set to true before the transfer of LP tokens. This results in a  pairBalance(user)  value of 0. This issue was fixed in commit 4804a0a9. Description: Trader Joe Response:", "html_url": "https://www.certora.com/wp-content/uploads/2022/03/Rocket-Joe-Report-2022-03-17.pdf", "labels": ["Certora", "High"]}, {"title": "Reentrancy attack tokens", "body": "if the event is stopped and we can call  emergencyWithdraw() , we can drain the system and take all the eth.  emergencyWithdraw()  calls _safeTransferAVAX()  which uses the low level  call  function to msg.sender  with amount  user.allocation . it sets  user.allocation  to 0 only after the transfer, but in the transfer, we can call emergencyWithdraw()  again and take the  user.allocation  before it's set to 0 until we take all the money from the system. This issue was fixed in commit 578a4d5c. Description: Trader Joe Response:", "html_url": "https://www.certora.com/wp-content/uploads/2022/03/Rocket-Joe-Report-2022-03-17.pdf", "labels": ["Certora", "High"]}, {"title": "Create bad event DOS", "body": "anyone can create an event but there can only be a single event for each token. An attacker can create bad event for all the tokens and prevent anyone from creating an event. (bad event can be one with maxAllocation==0 ). This issue was fixed in commit c750e722. Description: Trader Joe Response:", "html_url": "https://www.certora.com/wp-content/uploads/2022/03/Rocket-Joe-Report-2022-03-17.pdf", "labels": ["Certora", "High"]}, {"title": "LaunchEvent createPair DOS", "body": "\fIssue: LaunchEvent createPair DOS An attacker can call  factory.createPair(address(WAVAX), address(token))  before the LaunchEvent reaches phase three, causing  LaunchEvent.createPair()  to revert on require(factory.getPair(address(WAVAX), address(token)) == address(0)) . This will prevent anyone from creating a pair for the given token. This issue was fixed in commit 93b2fcc9. Description: Trader Joe Response:", "html_url": "https://www.certora.com/wp-content/uploads/2022/03/Rocket-Joe-Report-2022-03-17.pdf", "labels": ["Certora", "High"]}, {"title": "rJoeToken not initialized after setter", "body": "setRJoe(address _rJoe)  only sets the  rJoe  state variable to  _rJoe but doesn\u2019t call  initialize()  on it (the factory constructor also initializes the rJoe token). This issue was fixed in commit 93b2fcc9. Description: Trader Joe Response:", "html_url": "https://www.certora.com/wp-content/uploads/2022/03/Rocket-Joe-Report-2022-03-17.pdf", "labels": ["Certora", "High"]}, {"title": "lastRewardTimestamp is not set in constructor", "body": "Description: Trader Joe Response: A user can transfer joe externally to the contract to make accRJoePerShare  increase by a huge number in the first updatePool() . This issue was fixed in commit 93b2fcc9.", "html_url": "https://www.certora.com/wp-content/uploads/2022/03/Rocket-Joe-Report-2022-03-17.pdf", "labels": ["Certora", "High"]}, {"title": "Anyone can call RocketJoeToken.initialize()", "body": "the initialize() function has no modifier and thus anyone can invoke it Description: before it is called by the RocketJoeFactory. This prevents RocketJoeFactory from being initialized or changing the rJoe state variable. \fIssue: Anyone can call RocketJoeToken.initialize() Trader Joe Response: We acknowledge this issue, but handle it by making sure the contract is initialized properly post-deployment", "html_url": "https://www.certora.com/wp-content/uploads/2022/03/Rocket-Joe-Report-2022-03-17.pdf", "labels": ["Certora", "Medium"]}, {"title": "DoS - incorrect handling when depositing underlying tokens", "body": "Description: When depositing an amount of underlying token that isn't a whole multiplication of the liquidity index to the vault, the contract may reach a dirty state that keeps reverting undesirably on every method that calls  accrueYield() . This occurs due to an inaccurate increment of  lastVaultBalance  that doesn't correspond to the actual increment or decrement in the vault's assets following \fIssue: DoS - incorrect handling when depositing underlying tokens deposit()  or  mint() . In such cases,  lastVaultBalance  ends up being greater than  ATOKEN.balanceof(vault) , which causes a revert when the new yield is being calculated. The state can be corrected by increasing the existing assets relative to lastVaultBalance . This may occur naturally due to the fact that the token accrue yield from the pool, but it can also be initiated by sending a gift to the contract. initial state: Consider a valid state where  index = 10 Ray, totalSupply = 100 Ray, totalAsset = 101Ray . Action 1: A user deposits a sum of 91 underlying tokens through the contract. The first action invoked is accrual, which updates the state to lastVaultBalance = _AToken.balanceOf(vault), lastUpdated = now . Action 2: The amount of shares that the assets are worth is calculated through  previewDeposit() . The simulation returns shares = (assets * totalSupply)/totalAssets ~= 90.099 , but after rounding down, the result will be  shares = 90 . Action 3: From the amount of shares, the number of assets supplied to the pool is recalculated with  _convertToAssets  rounding up. The result of this calculation will be  assets = (shares * totalAssets)/totalSupply = 90.9 = 91 . Action 4: The contract sends the 91 assets to the pool, which will mint 9 aToken with a worth of 90 underlying tokens. However,  lastVaultBalance  will be incremented by the full 91 assets that were passed to the function. Post State: At this point, the state of the contract is  index = 10 Ray, totalSupply = 190 Ray, totalAsset = 101 + 90 = 191Ray, lastVaultBalance = 101 + 91 = 192  In this state, any call to  accrueYield()  will perform the calculation  newYield = newVaultBalance - _s.lastVaultBalance which will immediately revert due to underflow. Example: Mitigation/Fix: Fixed in PR#70, merged in commit 32edfe6.", "html_url": "https://www.certora.com/wp-content/uploads/2023/06/Aave-Vault-Formal-Verification-2.pdf", "labels": ["Certora", "Medium"]}, {"title": "Description:", "body": "Grifting - an attacker can prevent other users from withdrawing for a duration of a block An attacker can prevent other users from withdrawing part of their funds, or otherwise force revert by gifting assets to the vault. A gift can be given by directly transferring tokens to the vault at a block where  accrueYield()  is called. By doing this, the malicious player takes  lastVaultBalance  out of sync with _AToken.balanceof(vault) . At this stage, the share-to-asset ratio \fIssue: Grifting - an attacker can prevent other users from withdrawing for a duration of a block used to determine the amount of assets a user deserves for redeeming their shares is using  _AToken.balanceof(vault) . However, upon  redeem() , the withdrawn amount is deducted from lastVaultBalance . This mismatch in balance values may lead to reverting cases when the victim tries to withdraw an amount greater than the recorded  lastVaultBalance . The amount of money that the attacker needs to gift the system in order to execute the attack successfully is determined by the following formula (it does not take rounding into account):  giftAmount > totalAsset(t0) * [1]  where [(totalShares(t0)/BobSharesToRedeem) - 1] totalAssets(t0)  is the  _AToken.balanceOf(vault)  before the gift,  totalShares(t0)  is the amount of shares in the vault before the gift,  BobSharesToRedeem  is the amount of shares the victim desires to redeem, and  giftAmount  is the amount of assets needed to be gifted to the system by the attacker. Simply put, the gift is proportional to the total amount of reserves in the vault prior to the gift. A simple assignment shows that even for a victim that holds a significant share of the pool which is 50%, the amount needing to be gifted is greater than the total reserves that the pool backs up. Note: This is only valid for the same block the gift was transferred. In the next accrual,  lastVaultBalance  is synced, and the user can withdraw their funds. initial state: Consider the valid state  totalAssets = 200, totalShares = 200 , where the entire 200 shares belong to a victim. Step 1: An honest user deposits 1 asset, which grants them 1 share. This brings the state of the contract to  totalAssets = 201, totalShares = 201, lastVaultBalance = 201, lastUpdated = now Step 2: The attacker gifts 3 assets to the vault and takes lastVaultBalance  out of sync with the _AToken.balanceOf(vault) . This brings the state of the contract to totalAssets = 204, totalShares = 201, lastVaultBalance = 201 . Post State: If the victim tries to redeem all their shares, the share-to-asset ratio will evaluate their 200 shares as  200 * 204/201 = 202  assets. When the code gets to the point where it updates lastVaultBalance , the function will revert due to underflow: lastVaultBalance = 201 - 202 . Example: Mitigation/Fix: Fixed in PR#82 merged in commit 385b397. The following 3 issues are derived from the same sequence of initial states and transactions and are a result of the same vulnerability. \fSeverity: Medium Issue: Insolvency - lack of reserves to backup the vault's shares Rules Broken: property #14 -  getClaimableFees_LEQ_ATokenBalance  property #15 -  positiveSupply_imply_positiveAssets Given some initial state, an attacker can cause the protocol to deserve fees amounting to a larger value than its reserves. This means a state of insolvency. The coordinated transaction sequence described below relies on two things: 1. An optimization in the code that omits computation of the fees owed by protocol if such computation was already performed in the same block. 2. Although the vault uses the  _AToken.balanceOf[vault]  to track its reserves, it allows users to bypass the  lastVaultBalance  update (accrual) when gifting money to the protocol. The amount of money that the attacker needs to gift the system in order to execute the attack successfully is determined by the following formula (it does not take rounding into account):  (totalAssets(t0) - Description: [2]  where withdrawnAmount)/feePercentage <= giftAmount totalAssets(t0)  is the  _AToken.balanceOf(vault)  before the gift,  withdrawnAmount  is the amount of assets being withdrawn by the attacker to cause the insolvency,  feePercentage  is the is the fee percentage charges by the vault, and  giftAmount  is the amount of assets needed to be gifted to the system by the attacker. During this griefing attack, the attacker loses a sum of:  giftAmount * (1 - withdrawn_amount/totalAssets(t0)) . We can immediately see that the max loss to the attacker is the gift amount. [2] Example: The following scenario assumes that a 5% fee is deducted by the vault. initial state: Consider the valid state  _accumulatedFees = 700, _AToken.balanceOf(vault) = 1700, lastVaultBalance = 1700, totalSupply = 1000 . From the definition,  totalAssets() = 1700 - 700 = 1000 , the ratio of share-to-asset is  1:1 . Step 1: An attacker is gifting the vault  620  assets by a call to withdrawATokens()  with the vault as the recipient. This updates the state of the contract to be:  _accumulatedFees = 700, _AToken.balanceOf(vault) = 1700, lastVaultBalance = 1080, totalSupply = 380 ,  lastUpdated = now , which implies the share- to-assets ratio is now around  1:2.63 . Step 2: On the same block, the attacker, which holds an adequate amount of shares in the pool, withdraws  970  assets by redeeming  ~369  shares. Due to optimization on the update block,  totalAssets()  is using a stored, outdated amount of fees deserved by the protocol instead of computing the value using  lastVaultBalance . The recorded value \fIssue: Insolvency - lack of reserves to backup the vault's shares is  totalSupply = 1700 - 700 = 1000 . Post State: Following step 2, the state of the contract is now:  _accumulatedFees = 700, _AToken.balanceOf(vault) = 730, lastVaultBalance = 110, totalSupply = ~11 . In the next block ( time > now ), the function getClaimableFees()  returns  700 + 0.05*(730 - 110) = 731 , while  _AToken.balanceOf(vault) = 730 . A call to  withdrawFees() with the entire reserve sum (or less) will cause insolvency, meaning shareholders have no assets to backup their shares. Note: this broken state is \"eternal\". Even without withdrawing fees, once _accrueYield()  is being performed, the state variable _accumulatedFees  will be updated to the \"bad\" value, 731. Mitigation/Fix: Fixed in PR#82 merged in commit 385b397.", "html_url": "https://www.certora.com/wp-content/uploads/2023/06/Aave-Vault-Formal-Verification-2.pdf", "labels": ["Certora", "Medium"]}, {"title": "Complete DoS of the contract due to revert of  totalAssets()", "body": "Rules Broken: property #14 -  getClaimableFees_LEQ_ATokenBalance Description: Following the scenario described in the issue above, the final state constitutes  getClaimableFees() > _AToken.balanceOf(vault) , which, as we explained, will remain eternal once an accrual is being performed at one of the next blocks. This state results in a revert of any call to  totalAssets()  due to the underflow of the definition - ATOKEN.balanceOf(vault) - getClaimableFees() . This practically DoS the system completely since every function calls totalAssets()  through  convertToAssets  or  convertToShares . Mitigation/Fix: Fixed in PR#82 merged in commit 385b397.", "html_url": "https://www.certora.com/wp-content/uploads/2023/06/Aave-Vault-Formal-Verification-2.pdf", "labels": ["Certora", "Medium"]}, {"title": "Misinformation -  previewRedeem()  returns a larger amount of", "body": "assets than an immediate  redeem() Rules Broken: property #14 -  getClaimableFees_LEQ_ATokenBalance Description: Following the scenario described in the previous issue, if instead of performing Step 2, an honest user calls  previewRedeem()  at the same block, the returned value of the preview will be calculated according to the broken ratio ( 1:2.63  shown in the example). If the user calls  redeem()  at the next block, the amount of assets transferred to them will be smaller than expected, according to a lower ratio ( 1:2.55  shown in the example). This is because upon \fIssue: Misinformation -  previewRedeem()  returns a larger amount of assets than an immediate  redeem() redemption,  _accrueYield()  is called, which causes a reduction in totalAssets()  by  feePercentage * (ATOKEN.balanceOf(vault) - lastVaultBalance) . Mitigation/Fix: Fixed in PR#82 merged in commit 385b397.", "html_url": "https://www.certora.com/wp-content/uploads/2023/06/Aave-Vault-Formal-Verification-2.pdf", "labels": ["Certora", "Low"]}, {"title": "Loss of fees, overcharge of fees due to rounding", "body": "Rules Broken: property #13 -  lastVaultBalance_OK Description: The storage variable  _s.lastVaultBalance  marks the portion of reserves for which the vault has already charged fees. In every call to  accrueYield() , the vault charges fees only from the new yield accrued since the last fee charge -  ATOKEN.balanceOf(Vault) - _s.lastVaultBalance . Thus, it is expected that after every accrual, _s.lastVaultBalance  will be equal to  ATOKEN.balanceOf(Vault) . However, the system may reach a mismatch between the two values when depositing to or withdrawing from the vault due to different update mechanisms. While  _s.lastVaultBalance  is being updated with the exact  assets  amount passed to the function, aToken uses rayMath  to update the  ATOKEN.balanceOf(Vault) . While the former is exact, the latter is subject to rounding and may differ from the passed  assets  amount. At the end of a  deposit()  or withdraw() , the vault may reach a state where _s.lastVaultBalance == ATOKEN.balanceOf(Vault) \u00b1 1 . Since this scenario may repeat itself, the vault generally may reach a state where  _s.lastVaultBalance == ATOKEN.balanceOf(Vault) \u00b1 k , where  k  is the number of such occurred deposits or withdraws. For the  +  case, the next time the Vault accrues yield, it will lose its fee from that  k  unaccounted tokens. For the  -  case, the next time that the Vault accrues yield, it will gain money it does not deserve on account of the Vault's users. In some extreme cases, the system may even enter an insolvency similar to the one explained in the insolvency  bug above. Mitigation/Fix: Fixed in PR#86 merged in commit 385b397.", "html_url": "https://www.certora.com/wp-content/uploads/2023/06/Aave-Vault-Formal-Verification-2.pdf", "labels": ["Certora", "Low"]}, {"title": "Frontrun - avoiding fee charges for gifts given to the protocol", "body": "Description: The vault intends to charge fees for any yield generated in the Aave pool. This is done by tracking the vault's balance internally at each state-changing method ( lastVaultBalance ) and ensuring that only changes in aTokens' value are accounted for when calculating the fee. However, due to the \"same block\" optimization that is mentioned in the insolvency issue above, a user can front-run a withdrawFees()  call and ensure that the vault does not charge fees for any gifts given to the protocol at a block where accrual has already occurred. \fIssue: Frontrun - avoiding fee charges for gifts given to the protocol Detailed Attack: 1. A user sees that the vault owner wants to withdraw fees. 2. The user invokes an action that will trigger  accrueYield()  and update the state to  lastUpdated = now . This can be done cheaply by depositing dust in the vault. At this point, there are a few ways that the user can gift money to the protocol, which will not be counted when calculating fees: 3.a. The user can transfer aTokens directly to the vault. 3.b. The user can redeem shares and send the gains directly to the vault. 3.c. The user can gift money directly to the pool by using the  backUnbacked  functionality, for example, and increase the liquidity index. 4. When  withdrawFees()  is invoked, getClaimableFees()  returns the stored  accumulatedFees  instead of recalculating the fee and taking the new yield generated in this block into account. Mitigation/Fix: Fixed in PR#82 merged in commit 385b397.", "html_url": "https://www.certora.com/wp-content/uploads/2023/06/Aave-Vault-Formal-Verification-2.pdf", "labels": ["Certora", "informational"]}, {"title": "Rules Broken:", "body": "Description: Non-compliance of the preview methods with the EIP4626 standard properties: #2 -  previewDeposit_has_NO_threshold  #4 - previewMint_has_NO_threshold  #6 - previewWithdraw_has_NO_threshold  #8 - previewRedeem_has_NO_threshold As per EIP4626, all the preview functions must not take into account any limitation of the system, like those returned by the  max() methods. In the contract, the preview methods do take into account system limitations. For example let  m  be the value returned by maxDeposit() . Then value returned from  previewDeposit(m1)  is identical to the value returned from  previewDeposit(m)  for every m1>m . As per EIP4626, all the preview functions may revert due to other Mitigation/Fix: conditions that would also cause primary functions to revert. Relying on Aave is acceptable, given that primary functions are impacted by its limitations (e.g. users cannot withdraw if there is no available liquidity in the Aave Pool).", "html_url": "https://www.certora.com/wp-content/uploads/2023/06/Aave-Vault-Formal-Verification-2.pdf", "labels": ["Certora", "Informational"]}, {"title": "Withdraw extra assets", "body": "Rules Broken: Total assets of user Description: A user can withdraw an amount that, due to rounding, reduces their balance by shares that correspond to a lower amount and transfer the amount requested. One can repeat this step until no profit is left in the system. Mitigation: Use explicit rounding up/down depending on the context to have the system always benefit from rounding errors.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/SushiBentoboxFeb2021.pdf", "labels": ["Certora", "High"]}, {"title": "Withdraw of profit", "body": "Rules Broken: No change to others Description: In case there is profit in the BentoBox, a user can withdraw an amount that is less than one share which would be rounded down to zero share, and repeat this operation until no profit is left in the system. Mitigation: Withdraw of at least one share", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/SushiBentoboxFeb2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "Lock of assets", "body": "Rules Broken: Inverse of deposit and withdraw Description: Users can not withdraw and leave the BentoBox below some minimum threshold. Mitigation: Reduce the minimum to an insignificant amount www.certora.com \fSeverity: Medium Issue: Denial-of-service on flashloan Rules Broken: N/A Description: When the system has excess tokens, a valid flashloan returning the exact required amount fails. Mitigation: Weaken requirement to take into account the excess collateral", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/SushiBentoboxFeb2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "Inconsistent representation of total assets", "body": "Rules Broken: Solvency Description: Incorrect updating of negative profit from strategy for support of future strategies. Mitigation: New interface for strategies www.certora.com \f", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/SushiBentoboxFeb2021.pdf", "labels": ["Certora", "Low"]}, {"title": "Potential memory overwrite of the local stack", "body": "Rules Broken: Memory safety Description: In proxy.sol:_parse, if the handler returns length in [1..31], the new index will remain equal to index in _parse, thus allowing to overwrite it in the next iteration of the loop in _execs. Fix: The expectations about valid handler outputs should be checked: the return length is checked to be a multiple of 32.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "High"]}, {"title": "HAaveProtocol executeOperation can be delegatecall-ed directly", "body": "from Proxy Rules Broken: onlyValidCaller; The executeOperation should only be delegatecalled by the Proxy when the flashLoan is initiated by Furucombo. Description: The executeOperation serves as the callback for the flashloan, but in fact it can be called directly from the proxy too. This can be confusing to users and may lead to donation of funds to the lending pool. Fix: executeOperation should be called by a valid caller, in particular the Aave contract.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "Handler outputs are limited to types that are in multiples of 32 bytes,", "body": "otherwise return data length and number of return values may not match Rules Broken: Memory safety www.certora.com \fDescription: In Proxy.sol:_execs, if the handler returns a buffer of length in [1..31], and the number of arguments is 0, then data is copied into the local stack while not matching the 32-byte offset packing. The require may pass trivially if the config is set to match to the newly computed newIndex. Fix: Handler return buffers should be 32-byte aligned to be parsed correctly - fixed.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "Untrusted handler may overwrite memory", "body": "Rules Broken: Memory safety Description: In Proxy.sol:_exec - returndatasize can be arbitrary, and cause a memory overflow when computing the new value of free memory pointer in _exec. For comparison, when the Solidity compiler handles a function that returns a dynamic type parameter such as an array, it adds various checks that bound the length of the array returned, and forces the increase to be 32-byte aligned. Mitigation: Overflow of the free memory pointer due to huge returndatasize value is infeasible thanks to gas.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "Getter functions should be marked view", "body": "Rules Broken: noOverwrite Description: Calling external contracts may lead to reentrancy which in turn could have adverse effects, such as modifying the state of the contract in unexpected ways. For example: - IAToken underlyingAssetAddress - IComptroller getCompAddress Fix: External functions that are not expected to modify the state should be marked view in the relevant interface, to guarantee that the www.certora.com \fSolidity compiler uses STATICCALL opcode which is safer reentrancy-wise.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "batchExec can be called if sender is already set.", "body": "Rules Broken: Only a limited number of operations are allowed when the sender is initialized Description: batchExec unexpectedly succeeds despite the sender being initialized. This is because setSender() is idempotent and does not revert if trying to run it a second time (see related issue). This may mean reentrancy is allowed and hijacking of funds is possible. The other checks (that the cube counter is zero, and that the stack is empty) should make such a reentrancy impossible, but reasoning about it is more complicated and thus could be prone to errors in future versions. (For example, if an attacker is able to overflow the stack length field, and the cube counter, then such a reentrancy is made possible.) Fix: halt and banned agent checks are added before external functions in Proxy.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "Description:", "body": "HFunds: getBalance should have the same conditions as _getBalance The _getBalance function in handler base is using 0xeee.. and 0x0 as both indicators to using native ETH token. But HFund\u2019s getBalance function is only comparing against 0x0. This is confusing and potentially could cause errors in handlers\u2019 executions. Fix: HFunds getBalance was changed to call to the internal _getBalance function.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "HFunds: sendTokens can have unexpected eth balance modification", "body": "www.certora.com \fDescription: The token \u201c0\u201d address can be passed multiple times, and nowhere it is checked that the sum of eth amounts is equal to msg.value (or to the current working balance).", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Low"]}, {"title": "Can unregister a caller or handler via the matching register function", "body": "Rules Broken: Registration of handlers can only be modified by the relevant functions Description: Registry.sol - One can deprecate a handler via the register function, or a caller via the registerCaller function, by giving the \u201cdeprecated\u201d info directly. This is potentially confusing since a dedicated function exists for that end. Fix: Disallow deprecation via register functions.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Low"]}, {"title": "2 issues: Halting can be irreversible; banning can be irreversible", "body": "Rules Broken: haltingIsReversible, banningIsReversible Description: Registry.sol - If ownership is renounced in a state where the system is halted, it will be impossible to go back to non halted state. Same is true for the state where an agent is banned, and ownership is renounced. The agent can never be unbanned. Mitigation: No action necessary.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Low"]}, {"title": "batchExec can be called on a proxy that was banned by its registry", "body": "Rules Broken: nonExecutableByBannedAgents Description: Proxy.sol/Registry.sol - A proxy is also called an agent by the registry. Banning the proxy in the registry disallows certain callbacks www.certora.com \fto be calling into the proxy, but the top-level batchExec can still be called, and even fully execute (unless there are callbacks to it). Fix: Extend the check of banned agent + halting to batchExec.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Low"]}, {"title": "Can set a sender a second time without any update", "body": "Rules Broken: nonExecutableWithInitializedSender Description: Storage.sol - The_setSender() function can be called more than once with a non-zero address, but the second call has no effect. This could lead to unexpected results. (This issue is related to \u201cbatchExec can be called if sender is already set.\u201d which is the more concrete effect of this behavior). Fix: Revert in _setSender() if the sender is already set.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Low"]}, {"title": "Description:", "body": "In LibStack.sol:setHandlerType, _input can have type HandlerType instead of uint256 enum type are uint8 and have Solidity compiler generated checks of compliance, so it\u2019s recommended to use. This also relieves of the need to check the input against uint96. Fix: Change the type of _input to the enum type", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Low"]}, {"title": "Unused return variable", "body": "Description: In Registry.sol and Proxy.sol, the functions isValidHandler(), isValidCaller(), _isValidHandler() and _isValidCaller(), return `result` by their definition, although this variable\u2019s value is never set. Fix: Omit the return variable name from the function definition. www.certora.com \fSeverity: Recommendation Issue: Hard to read code Description: In Proxy.sol, in _execs() function, the code block handling referenced configs can be simplified by hoisting the call to _exec. In LibParam.sol, the loop counting references in getParams() function can be simplified.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Low"]}, {"title": "Use an immutable for the registry address", "body": "Description: Storage.sol/Proxy.sol - In case a vulnerable or malicious handler is executed via delegatecall, one privilege escalation method is to override the value stored at the registry slot to point to an alternative registry that allows malicious handlers and callers. Solidity\u2019s immutable feature allows to hard-code the address of the proxy\u2019s registry. www.certora.com \f", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/FurucomboMay2021.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Issue:", "body": "Loss of assets Loss of assets Description: RepayWithATokens function lacks an HF check, can be exploited to withdraw liquidity from the system for free. Mitigation/Fix: Canceled repayment with ATokens on behalf of another user Property violated:", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/AaveV3Jan2022-1.pdf", "labels": ["Certora", ""]}, {"title": "Issue:", "body": "Risk Exposure Risk Exposure Description: User can come to hold both an isolated and a non-isolated assets as collaterals upon calling AToken.transfer(), liquidation call and mintUnbacked(). Can be exploited to surpass the debt ceiling Mitigation/Fix: A check for isolation mode was added to the functions Property violated:", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/AaveV3Jan2022-1.pdf", "labels": ["Certora", ""]}, {"title": "Issue:", "body": "Loss of assets Loss of assets Description: Confusion of Asset and EMode price feed for liquidations Mitigation/Fix: Price Sources are called according to EMode Property violated: Emode source price usage \fMedium", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/AaveV3Jan2022-1.pdf", "labels": ["Certora", ""]}, {"title": "Issue:", "body": "Loss of Users' Profitability Loss of Users' Profitability Description: EMode liquidation may use wrong liquidation bonus Mitigation/Fix: Bonus rewarded correctly according to EMode Medium", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/AaveV3Jan2022-1.pdf", "labels": ["Certora", ""]}, {"title": "Issue:", "body": "Loss of revenue Loss of revenue Description: When repaying with aToken, the interest rate is updated as if we provided the equivalent liquidity in underlying instead of in AToken. In fact there\u2019s no liquidity provided to the system. It can be used to manipulate the interest rates. Mitigation/Fix: Call to rates updating function was changed to use 0 as the added liquidity Rule Coverage:", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/AaveV3Jan2022-1.pdf", "labels": ["Certora", ""]}, {"title": "Issue:", "body": "Integrity of ReserveList Integrity of ReserveList Description: _addReserveToList function will push a new reserve into all empty spots of the reserves list, instead of just the first one Mitigation/Fix: A return call was inserted to the loop Rule Coverage: The same asset should not appear twice on the reserves list Recommendation", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/AaveV3Jan2022-1.pdf", "labels": ["Certora", ""]}, {"title": "Issue:", "body": "Denial of Service Denial of Service Description: Users can be forced into isolation mode through supply(),AToken.transfer() functions, thus temporarily preventing them from borrowing other assets Property violated: Informative Rule: Check which functions can revert for one user due to another user's action Mitagation/Fix: User can withdraw asset of isolation mode", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/AaveV3Jan2022-1.pdf", "labels": ["Certora", ""]}, {"title": "Theft of yield", "body": "Description: When calling rebalance, the share price goes up as the imbalanced token is being invested. Thus anyone buying shares in deposit right before rebalance is called and withdrawing right after rebalance, will make no-risk pro\ufb01t at the expense of the investors. Mitigation/Fix: Include the imbalanced token amount in share price calculation.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/PopsicleV3OptimizerVerificationReport05Nov2021.pdf", "labels": ["Certora", "High"]}, {"title": "Loss of yield", "body": "Description: When a user withdraws his shares a long time after the last rebalance call, he won\u2019t get his part of the imbalanced token. Mitigation/Fix: At withdrawal, give the user his part also in the imbalanced token.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/PopsicleV3OptimizerVerificationReport05Nov2021.pdf", "labels": ["Certora", "Medium"]}, {"title": "Possible to deposit when tick is out of range", "body": "Description: When the tick is out of range, users can still deposit, and that\u2019s not lucrative. Mitigation/Fix: In deposit, check that tick is in range. www.certora.com \fSeverity: Low Issue: Minor loss of shares Description: When withdrawing, due to signi\ufb01cant rounding down, some shares might be lost. Mitigation/Fix: Compute back the shares to burn.", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/PopsicleV3OptimizerVerificationReport05Nov2021.pdf", "labels": ["Certora", "Low"]}, {"title": "Commingling investors assets with governance assets", "body": "Description: After collecting fees the governance would invest it together with its clients. Mitigation/Fix: Fixed", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/PopsicleV3OptimizerVerificationReport05Nov2021.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Collecting fees as a share of investors income", "body": "Description: Collecting fees as a share of investors income regardless of the incurred expenses, may raise the issue of con\ufb02ict of interest. Mitigation/Fix: Taken into consideration", "html_url": "https://www.certora.com/wp-content/uploads/2022/02/PopsicleV3OptimizerVerificationReport05Nov2021.pdf", "labels": ["Certora", "Recommendation"]}]