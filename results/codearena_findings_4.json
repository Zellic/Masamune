[{"title": "no time restriction in  setMarketTimeRestrictions()", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/49", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "no time restriction in  setMarketTimeRestrictions()"}, {"title": "Remove hardhat console import", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/48", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "Remove hardhat console import"}, {"title": "RCTreasury: Spelling Errors", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  - `seperate` \u2192 `separate` - `incase` \u2192 `in case`  "}, {"title": "RCTreasury: new hasRole() function with string role", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  It might be operationally easier (eg. reading permissions via etherscan, saves a few seconds having to search for the bytes32 constant and copy its value) to take in the role of type `string` instead of `bytes32`. It also has an added benefit of overloading the `hasRole()` function, where overriding was desired.  ### Recommended Mitigation Steps  Perhaps add it as an additional function to avoid having to change all `treasury.checkPermissions()` function calls (since the role input has to be modified too).  ```jsx // TODO: add to interface function hasRole(string memory role, address account)  external  view  override  returns (bool) {  bytes32 _role = keccak256(abi.encodePacked(role));  return AccessControl.hasRole(_role, account); } ```  "}, {"title": "RCTreasury: AccessControl diagram contains Leaderboard, but it has no role", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  ```jsx /* setup AccessControl                   UBER_OWNER     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502           \u2502          \u2502            \u2502         \u2502   OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD     \u2502           \u2502  GOVERNOR     MARKET     \u2502  WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE */ ```  From this diagram, one might expect the existence of a `LEADERBOARD` role, but there is no such role. It should be removed from the diagram.  ### Recommended Mitigation Steps  ```jsx /* setup AccessControl                   UBER_OWNER     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502           \u2502          \u2502            \u2502            OWNER      FACTORY    ORDERBOOK   TREASURY     \u2502           \u2502  GOVERNOR     MARKET     \u2502  WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE */ ```  "}, {"title": "RCLeaderboard: Erroneous comment", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The comments above the event declarations were probably copied over from RCOrderbook. They should be modified to refer to the leaderboard.  ### Recommended Mitigation Steps  ```jsx /// @dev emitted every time a user is added to the leaderboard event LogAddToLeaderboard(address _user, address _market, uint256 _card); /// @dev emitted every time a user is removed from the leaderboard event LogRemoveFromLeaderboard(     address _user,     address _market,     uint256 _card ); ```  "}, {"title": "RCFactory: Unnecessary casting in updateTokenURI()", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "RCFactory: Unnecessary casting in updateTokenURI()"}, {"title": "RCFactory: Solve stack too deep for getMarketInfo()", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `marketInfoResults` is a parameter used by `getMarketInfo()` to determine the length of results to return. As the `setMarketInfoResults()` comments state, \"(it) would be better to pass this as a parameter in getMarketInfo.. however we are limited because of stack too deep errors\".  This limitation can be overcome by defining the return array variables as the function output, as suggested below.  The need for `marketInfoResults` and its setter function is then made redundant, whilst making querying results of possibly varying lengths more convenient.  ### Recommended Mitigation Steps  ```jsx function getMarketInfo(   IRCMarket.Mode _mode,   uint256 _state,   uint256 _skipResults,   uint256 _numResults // equivalent of marketInfoResults )   external   view   returns (     address[] memory _marketAddresses,     string[] memory _ipfsHashes,     string[] memory _slugs,     uint256[] memory _potSizes  )  {    uint256 _marketIndex = marketAddresses[_mode].length;        _marketAddresses = new address[](_numResults);    _ipfsHashes = new string[](_numResults);    _slugs = new string[](_numResults);    _potSizes = new uint256[](_numResults);   ... } ```  "}, {"title": "RCFactory: Do multiplication instead of division for length checks", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/39", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  Solidity division rounds down, so doing `M / 2 <= N` checks mean that `M` can be at most `2N + 1`.  This affects the following checks:  ```jsx require(  (_tokenURIs.length / 2) <= cardLimit,  \"Too many tokens to mint\" );  require(   _cardAffiliateAddresses.length == 0 ||    _cardAffiliateAddresses.length == (_tokenURIs.length / 2),   \"Card Affiliate Length Error\" ) ```  Note that with the current implementation, if `_tokenURIs` is of odd length, its last element will be  redundant, but market creation will not revert.  The stricter checks will partially mitigate `_tokenURIs` having odd length because `_cardAffiliateAddresses` is now required to be exactly twice that of `_tokenURIs`.  ### Recommended Mitigation Steps  These checks should be modified to   ```jsx require(  _tokenURIs.length <= cardLimit * 2,  \"Too many tokens to mint\" );  require(   _cardAffiliateAddresses.length == 0 ||    _cardAffiliateAddresses.length * 2 == _tokenURIs.length,   \"Card Affiliate Length Error\" ); ```  In addition, consider adding a check for `_tokenURIs` to strictly be of even length.  `require(_tokenURIs.length % 2 == 0, \"TokenURI Length Error\");`  "}, {"title": "Access Control Constants", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/38", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "Access Control Constants"}, {"title": "transferCard should be done after treasury is updated.", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  0xImpostor   # Vulnerability details  ## Impact  When the current owner of the card is still the new owner of the card, `transferCard` is called before the treasury is updated. While this does not currently pose a risk, it is not aligned with best practices of [check-effect-interations](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) and opens your code to a potential re-entrancy attack in the future.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```jsx // line 381 treasury.updateRentalRate(     _oldOwner,     _user,     user[_oldOwner][index[_oldOwner][_market][_card]].price,     _price,     block.timestamp ); transferCard(_market, _card, _oldOwner, _user, _price); ... // line 449 treasury.updateRentalRate(     _user,     _user,     _price,     _currUser.price,     block.timestamp ); transferCard(_market, _card, _user, _user, _currUser.price); ```  "}, {"title": "Tight Variable Packing", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "Tight Variable Packing"}, {"title": "Parameter updates not propagated", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/30", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "Parameter updates not propagated"}, {"title": "uint32 conversion doesn't work as expected.", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The uint32 conversion in setWinner of the RCMarket doesn't work as expected. The first statement: \"uint32(block.timestamp)\" already first the block.timestamp in a uint32. If it is larger than type(uint32).max it wraps around and starts with 0 again The testcode below shows this.  Check for \"<= type(uint32).max\" in the second statement is useless because _blockTimestamp is always  <= type(uint32).max  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L507  function setWinner(uint256 _winningOutcome) internal { ...             uint256 _blockTimestamp = uint32(block.timestamp);             require(_blockTimestamp <= type(uint32).max, \"Overflow\");   //Testcode: pragma solidity 0.8.7; contract Convert {    uint256 public a = uint256( type(uint32).max )+1; // a==4294967296    uint32  public b = uint32(a); // b==0    uint256 public c = uint32(a); // c==0 }     ## Tools Used  ## Recommended Mitigation Steps Do the require first (without a typecast to uint32):              require( block.timestamp <= type(uint32).max, \"Overflow\");             uint256 _blockTimestamp = uint32(block.timestamp);    "}, {"title": "findNewOwner edgecase", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/27", "labels": ["bug", "sponsor confirmed", "Resolved", "disagree with severity", "3 (High Risk)"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function findNewOwner of RCOrderbook, as loop is done which included the check  _loopCounter < maxDeletions Afterwards a check is done for  \"(_loopCounter != maxDeletions)\" to determine if the processing is finished. If _loopCounter == maxDeletions then the conclusion is that it isn't finished yet.  However there is the edgecase that the processing might just be finished at the same time as _loopCounter == maxDeletions.  You can see this the best if you assume maxDeletions==1, in that case it will never draw the conclusion it is finished. Of course having maxDeletions==1 is very unlikely in practice.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L549  function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)  external  override  onlyMarkets  { ...         // delete current owner         do {             _newPrice = _removeBidFromOrderbookIgnoreOwner( _head.next, _market, _card );             _loopCounter++;             // delete next bid if foreclosed         } while (    treasury.foreclosureTimeUser( _head.next, _newPrice,  _timeOwnershipChanged ) <  minimumTimeToOwnTo &&                 _loopCounter < maxDeletions );          if (_loopCounter != maxDeletions) {   // the old owner is dead, long live the new owner             _newOwner = ....              ...         } else {             // we hit the limit, save the old owner, we'll try again next time            ...         }     }   ## Tools Used  ## Recommended Mitigation Steps Use a different way to determine that the processing is done. This could save some gas. Note: the additional check also costs gas, so you have the verify the end result.  Perhaps in setDeletionLimit doublecheck that _deletionLimit > 1.  "}, {"title": "Divide Before Multiply", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/25", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "Divide Before Multiply"}, {"title": "Return Value is Not Validated", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact The `circuitBreaker()` function in `RCMarket.sol` is utilised in the event an oracle never provides a response to a RealityCards question. The function makes an external call to the `RCOrderbook.sol` contract through the `closeMarket()` function. If for some reason the orderbook was unable to be closed, this would never be checked in the `circuitBreaker()` function.  ## Proof of Concept  https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1215-L1223  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Ensure this is intended behaviour, or otherwise validate the response of `orderbook.closeMarket()`. Another option would be to emit the result of the external call in the `LogStateChange` event, alongside the state change.  "}, {"title": "External Call Made Before State Change", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/23", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact There are a number of functions in `RCTreasury.sol` which make external calls to another contract before updating the underlying market balances. More specifically, these affected functions are `deposit()`, `sponsor()`, and `topupMarketBalance()`. As a result, these functions would be prone to reentrancy exploits. However, as `safeTransferFrom()` operates on a trusted ERC20 token (RealityCard's token), this issue is of low severity.  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L385-L391 https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L561-L563 https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L459-L461  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Modify the aforementioned functions such that all state changes are made before a call to the ERC20 token using the `safeTransferFrom()` function.  "}, {"title": "msgSender() or _msgSender()", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/22", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The code has two implementations of msgSender:  -   msgSender() => uses meta transaction signer -  _msgSender() => maps to msg.sender  _msgSender() is used in a few locations - when using _setupRole, this seems legitimate - in function withdraw  (whereas the similar function withdrawWithMetadata uses msgSender() )  It is confusing to have multiple functions with almost the same name, this could easily lead to mistakes.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/lib/NativeMetaTransaction.sol#L105  function msgSender() internal view returns (address payable sender) {         if (msg.sender == address(this)) {             assembly {   sender := shr(96, calldataload(sub(calldatasize(), 20)))   }         } else {              sender = payable(msg.sender);         }         return sender;     }  // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol   function _msgSender() internal view virtual returns (address) {         return msg.sender;     }  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L164   function withdraw(uint256 tokenId) external override {         require(  _msgSender() == ownerOf(tokenId), \"ChildMintableERC721: INVALID_TOKEN_OWNER\" ); // _msgSender()          withdrawnTokens[tokenId] = true;         _burn(tokenId);     }      function withdrawWithMetadata(uint256 tokenId) external override {         require( msgSender() == ownerOf(tokenId), \"ChildMintableERC721: INVALID_TOKEN_OWNER\" );  // msgSender()          withdrawnTokens[tokenId] = true;         // Encoding metadata associated with tokenId & emitting event         emit TransferWithMetadata( ownerOf(tokenId), address(0), tokenId, this.encodeTokenMetadata(tokenId) );         _burn(tokenId);     }  RCNftHubL1.sol:      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCNftHubL2.sol:      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCTreasury.sol:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); RCTreasury.sol:        _setupRole(UBER_OWNER,               _msgSender()); RCTreasury.sol:        _setupRole(OWNER,                         _msgSender()); RCTreasury.sol:        _setupRole(GOVERNOR,                   _msgSender()); RCTreasury.sol:        _setupRole(WHITELIST,                    _msgSender());  ## Tools Used grep  ## Recommended Mitigation Steps Doublecheck the use of  _msgSender() in withdraw and adjust if necessary.  Add comments when using  _msgSender()   Consider overriding _msgSender(), as is done in the example below: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol    "}, {"title": "rentAllCards: don't have to pay for card you already own", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/21", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function rentAllCards of RCMarket checks for _maxSumOfPrices to see you are not paying more that you want.  However the first part of the calculations (which calculate _actualSumOfPrices ), do not take in account the fact that you might  already own a card. (while the second part of the code does). If you already own the card you don't have to pay for it and you certainly don't have to pay the extra minimumPriceIncreasePercent.  The code at \"Proof of Concept\" shows a refactored version of the code (see other issue \"make code of rentAllCards easier to read\"). This immediately shows the issue.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L691 ==> simplified version  function calc(uint256 currentPrice) returns(uint256) {         if (currentPrice == 0)              return MIN_RENTAL_VALUE;         return (currentPrice *(minimumPriceIncreasePercent + 100)) / 100;     }          function rentAllCards(uint256 _maxSumOfPrices) external override {       ..         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             _actualSumOfPrices += calc(card[i].cardPrice);   // no check for  (ownerOf(i) != msgSender()) {         }         require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");          for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice=calc(card[i].cardPrice);                 newRental(_newPrice, 0, address(0), i);             }         }     }  ## Tools Used  ## Recommended Mitigation Steps Add \"if (ownerOf(i) != msgSender()) {\" also in the first part of the code of rentAllCards          uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {              if (ownerOf(i) != msgSender()) {              // extra if statement                  _actualSumOfPrices += calc(card[i].cardPrice);                 }         }         "}, {"title": "make code of rentAllCards easier to read and maintain", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function rentAllCards or RCMarket contains a similar piece of code twice (mainly the formula: (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) / 100; )  The current code is somewhat difficult to read and maintain and hides potential issue (also see other issue about rentAllCards)  ## Proof of Concept //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L691   function rentAllCards(uint256 _maxSumOfPrices) external override {         _checkState(States.OPEN);         // check that not being front run         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             if (card[i].cardPrice == 0) {                 _actualSumOfPrices += MIN_RENTAL_VALUE;             } else {                 _actualSumOfPrices += (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) / 100;             }         }         require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");          for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice;                 if (card[i].cardPrice > 0) {                     _newPrice =                         (card[i].cardPrice *                             (minimumPriceIncreasePercent + 100)) /                         100;                 } else {                     _newPrice = MIN_RENTAL_VALUE;                 }                 newRental(_newPrice, 0, address(0), i);             }         }     }   ## Tools Used  ## Recommended Mitigation Steps Suggestion to make the code easier to read and maintain:   function calc(uint256 currentPrice) returns(uint256) {         if (currentPrice == 0)              return MIN_RENTAL_VALUE;         return (currentPrice *(minimumPriceIncreasePercent + 100)) / 100;     }          function rentAllCards(uint256 _maxSumOfPrices) external override {       ..         uint256 _actualSumOfPrices = 0;         for (uint256 i = 0; i < numberOfCards; i++) {             _actualSumOfPrices += calc(card[i].cardPrice);         }         .....         for (uint256 i = 0; i < numberOfCards; i++) {             if (ownerOf(i) != msgSender()) {                 uint256 _newPrice=calc(card[i].cardPrice);                 newRental(_newPrice, 0, address(0), i);             }         }     }   "}, {"title": "optimize _beforeTokenTransfer", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "optimize _beforeTokenTransfer"}, {"title": "Uninitialized Variable `marketWhitelist` in `RCTreasury.sol`", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/18", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Resolved", "disagree with severity"], "target": "2021-08-realitycards-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact The variable, `marketWhitelist`, is never initialized in the contract `RCTreasury.sol`. As a result, the function `marketWhitelistCheck()`  does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return `true`, even if a market wishes to restrict its users to a specific role.   ## Proof of Concept  The initial state variable is defined in the link below. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L75  The state variable `marketWhitelist` is accessed in the function `RCTreasury.marketWhitelistCheck()` as per below. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L269-L281  The function `RCTreasury.marketWhitelistCheck()` is called in `RCMarket.newRental()` as seen below. The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in `RCTreasury` that allow a market creator to enable this functionality. https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L758-L761  ## Tools Used  `npx hardhat coverage` `slither` Manual code review  ## Recommended Mitigation Steps  Ensure this behaviour is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.  "}, {"title": "Overflow in `Mode` Type", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/17", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-08-realitycards-findings", "body": "Overflow in `Mode` Type"}, {"title": "Inaccurate Comment", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/16", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact This issue has no direct security implications, however, there may be some confusion when understanding what the `RCFactory.createMarket()` function actually does.  ## Proof of Concept https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L625  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Update the line (linked above) to include the `SAFE_MODE` option outline in the `enum` type in `IRCMarket.sol`. For example, the line `/// @param _mode 0 = normal, 1 = winner takes all` could be updated to `/// @param _mode 0 = normal, 1 = winner takes all, 2 = SAFE_MODE`  "}, {"title": "Test Coverage Improvements", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/15", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "Test Coverage Improvements"}, {"title": "Can't retrieve all data with getMarketInfo ", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/14", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function getMarketInfo of RCFactory only can give results back in the range 0...marketInfoResults  Supplying _skipResults doesn't help, it then just skips the first _skipResults  records.  Assume marketInfoResults == 10 and _skipResults == 20: Then no result will be given back because \"_resultNumber < marketInfoResults\" will never allow _resultNumber  to be bigger than 10  Note: this is low risk because getMarketInfo is a backup function (although you maybe want the backup to function as expected)  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L227   function getMarketInfo( IRCMarket.Mode _mode, uint256 _state, uint256 _skipResults  )  external view         returns ( address[] memory, string[] memory, string[] memory, uint256[] memory ) {            ..         uint256 _resultNumber = 0;        ..         while (_resultNumber < marketInfoResults && _marketIndex > 1) {            ...                 if (_resultNumber < _skipResults) {                     _resultNumber++;                 } else {                     _marketAddresses[_resultNumber] = _market;   // will never reach this part if _skipResults >= marketInfoResults                      ....                     _resultNumber++;                 }             }         }         return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);     }   ## Tools Used  ## Recommended Mitigation Steps Update the code to something like the following:       uint idx;  while (idx < marketInfoResults && _marketIndex > 1) {             _marketIndex--;             address _market = marketAddresses[_mode][_marketIndex];             if (IRCMarket(_market).state() == IRCMarket.States(_state)) {                 if (_resultNumber < _skipResults) {                     _resultNumber++;                 } else {                     _marketAddresses[idx] = _market;                     _ipfsHashes[idx] = ipfsHash[_market];                     _slugs[idx] = addressToSlug[_market];                     _potSizes[idx] = IRCMarket(_market).totalRentCollected();                     idx++;                 }             }         }        "}, {"title": "getMostRecentMarket can revert", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/13", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function getMostRecentMarket of RCFactory.sol will revert if no markets of the specific mode are created yet.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L171     function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address)     {         return marketAddresses[_mode][marketAddresses[_mode].length - (1)];     }   ## Tools Used  ## Recommended Mitigation Steps Change the function getMostRecentMarket to something like:  function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address) {      if ( marketAddresses[_mode].length ==0) return address(0);      return marketAddresses[_mode][marketAddresses[_mode].length - (1)]; }   "}, {"title": "updateTokenURI doesn't call setTokenURI ", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/12", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function updateTokenURI of RCFactory.sol doesn't update the uris of RCNftHubL2. E.g. it doesn't call setTokenURI to try and update the already created NFT's. This way the URIs of already minted tokens are not updated.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L453  function updateTokenURI(  // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L101 function setTokenURI(uint256 _tokenId, string calldata _tokenURI) external onlyUberOwner {         _setTokenURI(_tokenId, _tokenURI);     }  ## Tools Used  ## Recommended Mitigation Steps Also call setTokenURI of RCNftHubL2 Or restrict updateTokenURI to the phase where no NFT's are minted yet. Or at least add comments to updateTokenURI   "}, {"title": "remove addMarket from RCNftHubL2", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The contract RCNftHubL2 contains a function addMarket and an array isMarket. This was useful in the previous version of the contract, but now it is no longer used. Note: isMarket() could be used to retrieve the markets from RCNftHubL2, but there are also other ways to do that.  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L31 /// @dev so only markets can move NFTs     mapping(address => bool) public isMarket;   /// @dev so only markets can change ownership     function addMarket(address _newMarket) external override {         require(msgSender() == address(factory), \"Not factory\");         isMarket[_newMarket] = true;     }      // MARKET ONLY     function transferNft( address _currentOwner,  address _newOwner,   uint256 _tokenId ) external override {         require(marketTracker[_tokenId] == msgSender(), \"Not market\");         _transfer(_currentOwner, _newOwner, _tokenId);     }  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L636 function createMarket( ...  nfthub.addMarket(_newAddress);  ## Tools Used  ## Recommended Mitigation Steps Double check if isMarket and addMarket have any use left. If not remove them from RCNftHubL2 Also remove the call to nfthub.addMarket(_newAddress) from RCFactory.sol  "}, {"title": "remove unused modifiers", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Several modifiers are defined, but not used: - onlyTokenOwner in RCMarket.sol - onlyFactory in RCOrderbook.sol and RCLeaderboard.sol  This clutters the code base  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L328     modifier onlyTokenOwner(uint256 _token) {     ...  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L104   modifier onlyFactory() {     ...  //https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCLeaderboard.sol#L61   modifier onlyFactory() {   ...  ## Tools Used  ## Recommended Mitigation Steps Remove the unused modifiers   "}, {"title": "tokenExists ==> cardExists", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/9", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "tokenExists ==> cardExists"}, {"title": "safer implementation of tokenExists", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/8", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function tokenExists does only limited checks on the existence of cards. It doesn't doublecheck that tokenIds[_card] != 0   This is relevant because 0 is the default value of empty array elements. Although this isn't a problem in the current code,  future changes might accidentally introduce vulnerabilities.  Also cards are only valid if they are below numberOfCards. This has led to vulnerabilities in previous versions of the contract (e.g. previous contest)  ## Proof of Concept // https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1139 function tokenExists(uint256 _card) internal view returns (bool) {         return tokenIds[_card] != type(uint256).max; }  ## Tools Used  ## Recommended Mitigation Steps Change the function to something like the following:  function tokenExists(uint256 _card) internal view returns (bool) {        if (_cardId >= numberOfCards) return false;        if (tokenIds[_card] == 0) return false;        return tokenIds[_card] != type(uint256).max; }   "}, {"title": "Allowance checks are not required", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "Allowance checks are not required"}, {"title": "RCMarket.sol - Gas optimization in _payoutWinnings", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "Resolved"], "target": "2021-08-realitycards-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact  We can avoid 3 sload by storing `card[winningOutcome]` in a private variable.  We can also avoid 4 sload by storing `msgSender()` in a private variable.  We can also simplify the `_winningsToTransfer` calculation.  ## Proof of Concept  `card[winningOutcome]`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L574 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L589  `msgSender()`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L578 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L591 - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L592  `_winningsToTransfer`:  - https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L587-L589  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  `card[winningOutcome]`:  ``` Card storage _cardWinningOutcome = card[winningOutcome]; ```  [L574](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L574): `_cardWinningOutcome.rentCollectedPerCard) *`  `msgSender()`:  ``` address _msgSender = msgSender(); ```  [L578](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L578): `(rentCollectedPerUserPerCard[_msgSender][winningOutcome] *`  [L591 to L592](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L591-L592):  ``` _payout(_msgSender, _winningsToTransfer); emit LogWinningsPaid(_msgSender, _winningsToTransfer); ```  `card[winningOutcome]` and `msgSender()`:  [L564](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L564): `if (_cardWinningOutcome.longestOwner == _msgSender && winnerCut > 0) {`  [L585](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L585): `uint256 _winnersTimeHeld = _cardWinningOutcome.timeHeld[_msgSender];`  `card[winningOutcome]` and `_winningsToTransfer`:  [L587 to L589](https://github.com/code-423n4/2021-08-realitycards/blob/514a6157fb7bd0df1d27a4affece131ba5056818/contracts/RCMarket.sol#L587-L589): `_winningsToTransfer += (_numerator / _cardWinningOutcome.totalTimeHeld);`   "}, {"title": "RCMarket.sol - Gas optimization in claimCard", "html_url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-08-realitycards-findings", "body": "RCMarket.sol - Gas optimization in claimCard"}, {"title": "Cannot actually submit evidence", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/64", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  jmak   # Vulnerability details  ## Impact Detailed description of the impact of this finding.\u2028The SubmitBadSignatureEvidence is not actually registered in the handler and hence no one can actually submit this message, rendering the message useless. This harms the security model of Gravity since validators have no disincentive to attempt to collude and take over the bridge.   ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. The SubmitBadSignatureEvidence handler is omitted from module/x/gravity/handler.go  ## Tools Used Visual inspection  ## Recommended Mitigation Steps Handle the MsgSubmitBadSignatureEvidence in module/x/gravity/handler.go.   "}, {"title": "Incorrect accounting on transfer-on-fee/deflationary tokens in `Gravity`", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `sendToCosmos` function of `Gravity` transfers `_amount` of `_tokenContract` from the sender using the function `transferFrom`. If the transferred token is a transfer-on-fee/deflationary token, the actually received amount could be less than `_amount`. However, since `_amount` is passed as a parameter of the `SendToCosmosEvent` event, the Cosmos side will think more tokens are locked on the Ethereum side.  ## Proof of Concept  Referenced code: [Gravity.sol#L535](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L535) [Gravity.sol#L541](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L541)  ## Recommended Mitigation Steps  Consider getting the received amount by calculating the difference of token balance (using `balanceOf`) before and after the `transferFrom`.  "}, {"title": "Direct usage of `ecrecover` allows signature malleability", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "Direct usage of `ecrecover` allows signature malleability"}, {"title": "SafeMath library is not always used in `Gravity`", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/60", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  SafeMath library functions are not always used in the `Gravity` contract's arithmetic operations, which could cause integer underflow/overflows. Using SafeMath is considered a best practice that could completely prevent underflow/overflows and increase code consistency.  ## Proof of Concept  Referenced code: [Gravity.sol#L202](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L202) [Gravity.sol#L586](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L586)  ## Recommended Mitigation Steps  Consider using the SafeMath library functions in the referenced lines of code.  "}, {"title": "Filter Logic calls to gravity cosmos at client level to avoid reverts", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/58", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-08-gravitybridge-findings", "body": "Filter Logic calls to gravity cosmos at client level to avoid reverts"}, {"title": "Unhandled reverts from Cosmos to Eth batches can cause *Denial Of Service*", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/56", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-08-gravitybridge-findings", "body": "Unhandled reverts from Cosmos to Eth batches can cause *Denial Of Service*"}, {"title": "Lack of Validation Check", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/55", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that on the cosmos side Coin amount has not been checked on the token definition. That can use misfunctionality on the bridge.  Although zero amount definition fee will be calculated. That can cause lose of user funds.   ## Proof of Concept  1. Navigate to \"https://github.com/althea-net/cosmos-gravity-bridge/blob/main/module/x/gravity/types/ethereum.go\" Line #69. 2. On the following code, ValidateBasic function does not validate amount.  ``` // ValidateBasic permforms stateless validation func (e *ERC20Token) ValidateBasic() error {  if err := ValidateEthAddress(e.Contract); err != nil {   return sdkerrors.Wrap(err, \"ethereum address\")  }  // TODO: Validate all the things  return nil } ```  ## Tools Used  ## Recommended Mitigation Steps  Add the following validation steps on the ValidationBasic function.  ```  if !m.Amount.IsValid() {   return cosmos.ErrInvalidCoins(\"coins must be valid\")  }   if !m.Amount.IsAllPositive() {   return cosmos.ErrInvalidCoins(\"coins must be positive\")  } ```    "}, {"title": "Consider adding a token whitelist in `sendToCosmos` function", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-gravitybridge-findings", "body": "Consider adding a token whitelist in `sendToCosmos` function"}, {"title": "Anyone can deploy ERC20 tokens", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/53", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-gravitybridge-findings", "body": "Anyone can deploy ERC20 tokens"}, {"title": "The function `updateValset` does not have enough sanity checks", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/51", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ##  `updateValset` does not have enough sanity checks  In [updateValset](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L224) function, the current set of validators adds a new set.  It is missing the check that the combined power of all new validators is above the `state_powerThreshold`. If this is false, then the contract is effectively stuck. Consider adding an on-chain check for this.  It is also worth adding a that the size of the new validator check is less than a certain number.  Here is a rough calculation explaining how 10000 validators (an extreme example) is too much:  1.  Let us say that the new set of validators have the property that at     least, say, `N` validators are needed to get the total threshold     above `state_powerThreshold`. 2.  Since each validating signature requires a call to `ecrecover`,     costing at least `3000` gas, the minimum gas needed for getting a     proposal over `state_powerThreshold` would be `N * 3000` 3.  `N * 3000` cannot be more than the `block.gaslimit` Currently, this     puts `N` to be less than `10000`  Another approach to solve the above potential problems is to do the updating as a two step process:  1.  The current set of validators proposes a pending set of validators. 2.  And the pending set of validators need to do the transition to     become the new set of validators. Going through the same threshold     checks.  This guarantees that the new set of validators has enough power to pass threshold and doesn't have gas limit issues in doing so.   "}, {"title": "Avoid long revert strings.", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "Avoid long revert strings."}, {"title": "State Variables that can be changed to `immutable`", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## State Variables that can be changed to `immutable`  [Solidity 0.6.5](https://blog.soliditylang.org/2020/04/06/solidity-0.6.5-release-announcement/) introduced `immutable` as a major feature. It allows setting contract-level variables at construction time which gets stored in code rather than storage.  Consider the following generic example:  ``` solidity contract C {     /// The owner is set during contruction time, and never changed afterwards.     address public owner = msg.sender; } ```  In the above example, each call to the function `owner()` reads from storage, using a `sload`. After [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929), this costs 2100 gas cold or 100 gas warm. However, the following snippet is more gas efficient:  ``` solidity contract C {     /// The owner is set during contruction time, and never changed afterwards.     address public immutable owner = msg.sender; } ```  In the above example, each storage read of the `owner` state variable is replaced by the instruction `push32 value`, where `value` is set during contract construction time. Unlike the last example, this costs only 3 gas.  ### Examples  1.  <https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L59> 2.  <https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L60>    "}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) { uint length = arr.length; for (uint i = 0; i < arr.length; i++) { sum += arr[i]; } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) { uint length = arr.length; for (uint i = 0; i < arr.length; i++) { sum += arr[i]; } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause \"unimplemented feature error\". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  ``` https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L176  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L186  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  "}, {"title": "Caching the length in for loops", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching the length in for loops  Consider a generic example of an array `arr` and the following loop:  ``` solidity for (uint i = 0; i < arr.length; i++) {     // do something that doesn't change arr.length } ```  In the above case, the solidity compiler will always read the length of the array during each iteration. That is,  1.  if it is a `storage` array, this is an extra `sload` operation (100     additional extra gas     ([EIP-2929](https://eips.ethereum.org/EIPS/eip-2929)) for each     iteration except for the first), 2.  if it is a `memory` array, this is an extra `mload` operation (3     additional gas for each iteration except for the first), 3.  if it is a `calldata` array, this is an extra `calldataload`     operation (3 additional gas for each iteration except for the first)  This extra costs can be avoided by caching the array length (in stack):  ``` solidity uint length = arr.length; for (uint i = 0; i < length; i++) {     // do something that doesn't change arr.length } ```  In the above example, the `sload` or `mload` or `calldataload` operation is only called once and subsequently replaced by a cheap `dupN` instruction. Even though `mload`, `calldataload` and `dupN` have the same gas cost, `mload` and `calldataload` needs an additional `pushX value` to put the offset in the stack, i.e., an extra 3 gas.  This optimization is especially important if it is a storage array or if it is a lengthy for loop. Note: this especially relevant for the IndexPool contract.  Note that the Yul based optimizer (not enabled by default; only relevant if you are using `--experimental-via-ir` or the equivalent in standard JSON) can sometimes do this caching automatically. However, this is likely not the case in your project. [Reference](https://forum.soliditylang.org/t/solidity-team-ama-2-on-wed-10th-of-march-2021/152/15?u=hrkrshnn).  ### Examples  ``` text ./contracts/flat/BentoBoxV1Flat.sol:626:        for (uint256 i = 0; i < calls.length; i++) { ./contracts/pool/PoolDeployer.sol:34:            for (uint256 i; i < tokens.length - 1; i++) { ./contracts/pool/PoolDeployer.sol:36:                for (uint256 j = i + 1; j < tokens.length; j++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:73:        for (uint256 i = 0; i < _tokens.length; i++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:104:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/franchised/FranchisedIndexPool.sol:132:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/franchised/WhiteListManager.sol:105:        for (uint256 i = 0; i < merkleProof.length; i++) { ./contracts/pool/IndexPool.sol:71:        for (uint256 i = 0; i < _tokens.length; i++) { ./contracts/pool/IndexPool.sol:102:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/pool/IndexPool.sol:129:        for (uint256 i = 0; i < tokens.length; i++) { ./contracts/utils/TridentHelper.sol:27:        for (uint256 i = 0; i < data.length; i++) { ./contracts/TridentRouter.sol:65:        for (uint256 i; i < params.path.length; i++) { ./contracts/TridentRouter.sol:83:        for (uint256 i; i < path.length; i++) { ./contracts/TridentRouter.sol:123:        for (uint256 i; i < params.path.length; i++) { ./contracts/TridentRouter.sol:139:        for (uint256 i; i < params.initialPath.length; i++) { ./contracts/TridentRouter.sol:149:        for (uint256 i; i < params.percentagePath.length; i++) { ./contracts/TridentRouter.sol:157:        for (uint256 i; i < params.output.length; i++) { ./contracts/TridentRouter.sol:181:        for (uint256 i; i < tokenInput.length; i++) { ./contracts/TridentRouter.sol:223:        for (uint256 i; i < minWithdrawals.length; i++) { ./contracts/TridentRouter.sol:225:            for (; j < withdrawnLiquidity.length; j++) { ./contracts/TridentRouter.sol:274:        for (uint256 i; i < tokenInput.length; i++) { ```   "}, {"title": "Upgrade to at least Solidity 0.8.4", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "Upgrade to at least Solidity 0.8.4"}, {"title": "use of floating pragma ", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/42", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  https://swcregistry.io/docs/SWC-103  ## Proof of Concept https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L1  ## Tools Used manual review  ## Recommended Mitigation Steps use fixed solidity version  "}, {"title": "Gravity: Consider enforcing validation expiry on-chain", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/40", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-gravitybridge-findings", "body": "Gravity: Consider enforcing validation expiry on-chain"}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/39", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "Style issues"}, {"title": "Pack structs tightly", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Gas efficiency can be achieved by tightly packing the struct. Struct variables are stored in 32 bytes each so you can group smaller types to occupy less storage. For example, startedAt or boughtAt in Auction struct hold block.number so realistically this does not need uint256 and you can consider storing it in lower type. You can read more here: https://fravoll.github.io/solidity-patterns/tight_variable_packing.html or in the official documentation: https://docs.soliditylang.org/en/v0.4.21/miscellaneous.html  ## Recommended Mitigation Steps Search for an optimal size and order of structs to reduce gas usage.  "}, {"title": "Cache values", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "Cache values"}, {"title": "Actions can be frontrunned", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-gravitybridge-findings", "body": "Actions can be frontrunned"}, {"title": "Why nonces are not incrementing by 1 ?", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/32", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I am concerned why invalidationId, invalidationNonce or valsetNonce are only required to be greater than the previous value. Why did you choose this approach instead of just simply asking for an incremented value? While this may not be a problem if the validators are honest, but otherwise, they may submit a nonce of MAX UINT and thus block the whole system as it would be no longer possible to submit a greater value. Again, just wanted you to be aware of this issue, not sure how likely this to happen is in practice, it depends on the honesty of validators so you better know.  ## Recommended Mitigation Steps I didn't receive an answer on Discord so decided to submit this FYI to decide if that's a hazard or no.  "}, {"title": "Validations of parameters", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/31", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are a few validations that could be added to the system: the constructor could check that _gravityId is not empty. state_powerThreshold should always be greater than 0, otherwise, anyone will be available to execute actions.  ## Recommended Mitigation Steps Consider implementing suggested validations.  "}, {"title": "Skip functionCall when the payload is empty", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/29", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "Skip functionCall when the payload is empty"}, {"title": "powers in a decreasing order", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/27", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-gravitybridge-findings", "body": "powers in a decreasing order"}, {"title": "cumulativePower check should be inclusive", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "cumulativePower check should be inclusive"}, {"title": "logic calls can steal tokens", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/25", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2021-08-gravitybridge-findings", "body": "logic calls can steal tokens"}, {"title": "validator set can be updated with same set", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/23", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-08-gravitybridge-findings", "body": "validator set can be updated with same set"}, {"title": "Panics as error-handling", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/20", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2021-08-gravitybridge-findings", "body": "Panics as error-handling"}, {"title": "Downcasting Can Freeze The Chain", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/19", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "Downcasting Can Freeze The Chain"}, {"title": "Anti-pattern `is_err()`, `return`, then `.unwrap()`", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/18", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "Anti-pattern `is_err()`, `return`, then `.unwrap()`"}, {"title": "`Vec::new()` instead of `Iterator::collect()`", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/17", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "`Vec::new()` instead of `Iterator::collect()`"}, {"title": "Passing by ownership instead of borrowing", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/16", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "Passing by ownership instead of borrowing"}, {"title": "The gravity.sol router should have pause/unpause functionality.", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/15", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "The gravity.sol router should have pause/unpause functionality."}, {"title": "Does the cosmos-sdk listen to only 1 gravity.sol contract address?", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/14", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-08-gravitybridge-findings", "body": "Does the cosmos-sdk listen to only 1 gravity.sol contract address?"}, {"title": "Possible miner incentive for chain reorgs if ETHBlockDelay is too small", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "Possible miner incentive for chain reorgs if ETHBlockDelay is too small"}, {"title": "Crash Eth Oracle On Any LogicCallEvent", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  nascent   # Vulnerability details  **Severity: Medium** **Likelihood: High**  In `eth_oracle_main_loop`, `get_last_checked_block` is called. Followed by: ```rust= let logic_call_executed_events = web3             .check_for_events(                 end_search.clone(),                 Some(current_block.clone()),                 vec![gravity_contract_address],                 vec![LOGIC_CALL_EVENT_SIG],             )             .await; ``` and may hit the code path: ```rust=         for event in logic_call_executed_events {             match LogicCallExecutedEvent::from_log(&event) {                 Ok(call) => {                     trace!(                         \"{} LogicCall event nonce {} last event nonce\",                         call.event_nonce,                         last_event_nonce                     );                     if upcast(call.event_nonce) == last_event_nonce && event.block_number.is_some()                     {                         return event.block_number.unwrap();                     }                 }                 Err(e) => error!(\"Got ERC20Deployed event that we can't parse {}\", e),             }         } ```  But will panic at `from_log` here: ```rust= impl LogicCallExecutedEvent {     pub fn from_log(_input: &Log) -> Result<LogicCallExecutedEvent, GravityError> {         unimplemented!()     }     // snip... } ``` It can/will also be triggered here in `check_for_events`:  ```rust= let logic_calls = LogicCallExecutedEvent::from_logs(&logic_calls)?; ```  Attestations will be frozen until patched.  ## Recommendation Implement the method.  ## Recommended Mitigation Steps  "}, {"title": "Large ValSets potentially freezes `Gravity.sol`", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/9", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "Large ValSets potentially freezes `Gravity.sol`"}, {"title": "ERC20s that block transfer to particular addresses enable DoS/Censorship", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-08-gravitybridge-findings", "body": "ERC20s that block transfer to particular addresses enable DoS/Censorship"}, {"title": "Win all relayer rewards", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/7", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  nascent   # Vulnerability details  \"Large Validator Sets/Rapid Validator Set Updates May Freeze the Bridge or Relayer\" can affect just the relayers & not affect the oracle in certain circumstances. This could result in valid attestations, but prevent any of the other relayers from being able to participate in the execution. While the other relayers are down from the other attack, the attacker can win all batch, logic, and valset rewards as their node is the only relayer running. This is possible because `find_latest_valset` is run in the main relayer loop and everytime tries for 5000 blocks of logs.  "}, {"title": "Large Validator Sets/Rapid Validator Set Updates May Freeze the Bridge or Relayers", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/6", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  nascent   # Vulnerability details  In a similar vein to \"Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms\", a sufficiently large validator set or sufficiently rapid validator update could cause both the `eth_oracle_main_loop` and `relayer_main_loop` to fall into a state of perpetual errors. In `find_latest_valset`, [we call](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/relayer/src/find_latest_valset.rs#L33-L40): ```rust= let mut all_valset_events = web3             .check_for_events(                 end_search.clone(),                 Some(current_block.clone()),                 vec![gravity_contract_address],                 vec![VALSET_UPDATED_EVENT_SIG],             )             .await?; ```  Which if the validator set is sufficiently large, or sufficiently rapidly updated, which continuous return an error if the logs in a 5000 (see: `const BLOCKS_TO_SEARCH: u128 = 5_000u128;`) block range are in excess of 10mb. Cosmos hub says they will be pushing the number of validators up to 300 (currently 125). At 300, each log would produce 19328 bytes of data (4\\*32+64\\*300). Given this, there must be below 517 updates per 5000 block range otherwise the node will fall out of sync.   This will freeze the bridge by disallowing attestations to take place.  This requires a patch to reenable the bridge.  ## Recommendation Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.  "}, {"title": "Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/5", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  nascent   # Vulnerability details  Ethereum Oracles watch for events on the `Gravity.sol` contract on the Ethereum blockchain. This is performed in the [`check_for_events`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L23) function, ran in the [`eth_oracle_main_loop`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/main_loop.rs#L94).   In this function, there is [the following code snippet](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L66-L73): ```rust=     let erc20_deployed = web3         .check_for_events(             starting_block.clone(),             Some(latest_block.clone()),             vec![gravity_contract_address],             vec![ERC20_DEPLOYED_EVENT_SIG],         )         .await; ``` This snippet leverages the `web30` library to check for events from the `starting_block` to the `latest_block`. Inside the `web30` library this nets out to calling: ```rust=     pub async fn eth_get_logs(&self, new_filter: NewFilter) -> Result<Vec<Log>, Web3Error> {         self.jsonrpc_client             .request_method(                 \"eth_getLogs\",                 vec![new_filter],                 self.timeout,                 Some(10_000_000),             )             .await     } ```  The `10_000_000` specifies the maximum size of the return in bytes and returns an error if the return is larger: ```rust=         let res: Response<R> = match res.json().limit(limit).await {             Ok(val) => val,             Err(e) => return Err(Web3Error::BadResponse(format!(\"Web3 Error {}\", e))),         }; ```  This can be triggered at will and keep the loop in a perpetual state of returning the `GravityError::EthereumRestError(Web3Error::BadResponse(             \"Failed to get logs!\".to_string()))` error. To force the node into this state, you just have to deploy ERC20s generated by the [public function in `Gravity.sol`](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L546-L565): ```solidity=  function deployERC20(   string memory _cosmosDenom,   string memory _name,   string memory _symbol,   uint8 _decimals  ) public {   // Deploy an ERC20 with entire supply granted to Gravity.sol   CosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);    // Fire an event to let the Cosmos module know   state_lastEventNonce = state_lastEventNonce.add(1);   emit ERC20DeployedEvent(    _cosmosDenom,    address(erc20),    _name,    _symbol,    _decimals,    state_lastEventNonce   );  } ```  And specify a large string as the denom, name, or symbol. If an attacker uses the denom as the attack vector, they save significant gas costing just 256 per additional 32 bytes. For other cases, to avoid gas overhead, you can have the string be mostly 0s resulting in just 584 gas per additional 32 bytes. This leaves it feasible to surpass the 10mb response data in the 6 block buffer. This would throw every ethereum oracle into a state of perpetual errors and all would fall out of sync with the ethereum blockchain. This would result in the batches, logic calls, deposits, ERC20 creations, and valset updates to never receive attestations from other validators because their ethereum oracles would be down; the bridge would be frozen and remain frozen until the bug is fixed due to `get_last_checked_block`.  This will freeze the bridge by disallowing attestations to take place.  This requires a patch to reenable the bridge.  ## Recommendation Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.  Additionally, you could require that validators sign ERC20 creation requests.  "}, {"title": "Freeze Bridge via Non-UTF8 Token Name/Symbol/Denom", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/4", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  nascent   # Vulnerability details  Manual insertion of non-utf8 characters in a token name will break parsing of logs and will always result in the oracle getting in a loop of failing and early returning an error. The fix is non-trivial and likely requires significant redesign.  # Proof of Concept Note the `c0` in the last argument of the call data (invalid UTF8).  It can be triggered with: ```solidity= data memory bytes = hex\"f7955637000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000461746f6d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046e616d6500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000673796d626fc00000000000000000000000000000000000000000000000000000\"; gravity.call(data); ``` The log output is as follows: ``` ERC20DeployedEvent(\"atom\", \"name\", \u276eutf8 decode failed\u276f: 0x73796d626fc0, 18, 2) ```  Which hits [this code path](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/gravity_utils/src/types/ethereum_events.rs#L431-L438): ```rust=             let symbol = String::from_utf8(input.data[index_start..index_end].to_vec());             trace!(\"Symbol {:?}\", symbol);             if symbol.is_err() {                 return Err(GravityError::InvalidEventLogError(format!(                     \"{:?} is not valid utf8, probably incorrect parsing\",                     symbol                 )));             } ```  And would cause an early return [here](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/orchestrator/orchestrator/src/ethereum_event_watcher.rs#L99): ```rust= let erc20_deploys = Erc20DeployedEvent::from_logs(&deploys)?; ```  Never updating last checked block and therefore, this will freeze the bridge by disallowing any attestations to take place. This is an extremely low cost way to bring down the network.  ## Recommendation This is a hard one. Resyncing is permanently borked because on the Go side, there is seemingly no way to ever process the event nonce because protobufs do not handle non-utf8 strings. The validator would report they need event nonce `N` from the orchestrator, but they can never parse the event `N`. Seemingly, validators & orchestrators would have to know to ignore that specific event nonce. But it is a permissionless function, so it can be used to effectively permanently stop attestations & the bridge until a new `Gravity.sol` is deployed.  One potential fix is to check in the solidity contract if the name contains valid utf8 strings for denom, symbol and name. This likely will be expensive though. Alternatively, you could require that validators sign ERC20 creation requests and perform checks before the transaction is sent.   "}, {"title": "Smart Contract Gas Optimization", "html_url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-08-gravitybridge-findings", "body": "# Handle  ElliotFriedman   # Vulnerability details  ## Impact Currently, submitBatch, updateValset, deployERC20 and submitLogicCall all have arguments that are in memory. This causes calls to these functions to be more expensive than they need to be. By moving to external functions and upgrading the compiler version, there will be gas savings. The larger the amount of data being submitted to the contracts, the greater the savings as the cost of memory in the EVM goes up quadratically with the amount of data stored.  ## Tools Used Hardhat  ## Recommended Mitigation Steps Make all functions that you can external instead of public, especially the ones mentioned above that will see large transaction volumes, and change the data types from memory to external. This may involve changing compiler versions to 0.8.0 or greater to support using structs as external types.  "}, {"title": "Inconsistent Template Deletion", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/151", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Inconsistent Template Deletion"}, {"title": "Inaccurate Function Name `enableList()`", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/149", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Inaccurate Function Name `enableList()`"}, {"title": "Missing `uint256` Cast", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/148", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Missing `uint256` Cast"}, {"title": "Improper Boolean Comparison", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/144", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Improper Boolean Comparison"}, {"title": "Use a struct for raw data.", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/143", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Use a struct for raw data."}, {"title": "Certain view functions should be used only by UI and not by the code", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/142", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "Certain view functions should be used only by UI and not by the code"}, {"title": "Add input validation on some methods", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/141", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Add input validation on some methods"}, {"title": "Consider using a solidity version >= 0.8.0", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/138", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Consider using a solidity version >= 0.8.0"}, {"title": "An adversarial attacker can initialize ListFactory", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/137", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "An adversarial attacker can initialize ListFactory"}, {"title": "Requiring a decimals method for ERC-20 tokens is non-standard", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/136", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "Requiring a decimals method for ERC-20 tokens is non-standard"}, {"title": "Caching `totalPoints` during `setPoints` method", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching `totalPoints` during `setPoints` method  Instead of constantly writing to the same slot in a for loop, write it once at the end. This would save `100` gas for each iteration of the for loop. (Since [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929), the cost of writing to a dirty storage slot is 100 gas)  ``` diff modified   contracts/Access/PointList.sol @@ -65,6 +65,7 @@ contract PointList is IPointList, MISOAccessControls {     function setPoints(address[] memory _accounts, uint256[] memory _amounts) external override {          require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PointList.setPoints: Sender must be operator\");          require(_accounts.length != 0, \"PointList.setPoints: empty array\");          require(_accounts.length == _amounts.length, \"PointList.setPoints: incorrect array length\"); +        uint totalPointsCache = totalPoints;          for (uint i = 0; i < _accounts.length; i++) {              address account = _accounts[i];              uint256 amount = _amounts[i]; @@ -72,9 +73,10 @@ contract PointList is IPointList, MISOAccessControls {               if (amount != previousPoints) {                  points[account] = amount; -                totalPoints = totalPoints.sub(previousPoints).add(amount); +                totalPointsCache = totalPointsCache.sub(previousPoints).add(amount);                  emit PointsUpdated(account, previousPoints, amount);              }          } +        totalPoints = totalPointsCache;      }  } ```   "}, {"title": "Consider having short revert strings", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/134", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Consider having short revert strings"}, {"title": " Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) {   uint length = arr.length;   for (uint i = 0; i < arr.length; i++) {       sum += arr[i];   } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) {   uint length = arr.length;   for (uint i = 0; i < arr.length; i++) {       sum += arr[i];   } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause \"unimplemented feature error\". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L297`  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  "}, {"title": "## Caching the length in for loops", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/132", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "## Caching the length in for loops"}, {"title": "Upgrade to at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Upgrade to at least 0.8.4"}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/130", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "Style issues"}, {"title": "_addCommitment should check that address is not empty", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/128", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "_addCommitment should check that address is not empty"}, {"title": "_startTime is always < 10000000000 when _endTime < 10000000000 (_endTime > _startTime)", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact No need to check that _startTime < 10000000000 as it is later checked against _endTime which is also < 10000000000 :         require(_startTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");         require(_endTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");         ...         require(_endTime > _startTime, \"Crowdsale: end time must be older than start price\");  ## Recommended Mitigation Steps Remove this line:     require(_startTime < 10000000000, \"Crowdsale: enter an unix timestamp in seconds, not miliseconds\");  "}, {"title": "Pack structs tightly", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Pack structs tightly"}, {"title": "allDepositIds is pretty much useless", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "allDepositIds is pretty much useless"}, {"title": "Dead code", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact BLOCK_DECREMENT state variable in Auction is not used anywhere.  ## Recommended Mitigation Steps Consider removing unused variables.  "}, {"title": "Useless initialization to default value", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact No need for this line in function initMISOMarket as it gets this value by default:   auctionTemplateId = 0;  ## Recommended Mitigation Steps Consider removing useless initialization.  "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/120", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).           ConvexModule.sol, line 3, import \"@yield-protocol/vault-interfaces/DataTypes.sol\";         ConvexStakingWrapper.sol, line 9, import \"./interfaces/IConvexDeposits.sol\";         ConvexStakingWrapper.sol, line 10, import \"./interfaces/ICvx.sol\";  "}, {"title": "Separate minter roles are not really necessary", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/118", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Separate minter roles are not really necessary"}, {"title": "SushiToken transfers are broken due to wrong delegates accounting on transfers", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/117", "labels": ["bug", "3 (High Risk)", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "SushiToken transfers are broken due to wrong delegates accounting on transfers"}, {"title": "MISORecipe01 uses outdated interfaces", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/116", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "MISORecipe01 uses outdated interfaces"}, {"title": "Commitments can happen after already finalized", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/115", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Commitments can happen after already finalized"}, {"title": "`TokenVault` incorrectly tracks `userIndex`", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/114", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "`TokenVault` incorrectly tracks `userIndex`"}, {"title": "Inclusive checks", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/113", "labels": ["bug", "0 (Non-critical)"], "target": "2021-09-sushimiso-findings", "body": "Inclusive checks"}, {"title": "`MISOMasterChef.setDevPercentage` should be capped", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/111", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "`MISOMasterChef.setDevPercentage` should be capped"}, {"title": "The first escrow index underflows", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/110", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed", "resolved"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function createEscrow first assigns an index for the new isChildEscrow and only then pushes the struct to the array. When first escrow is being created, the array contains 0 elements so escrows.length-1 will underflow and return a max uint value:    isChildEscrow[address(newEscrow)] = Fermenter(true,_templateId,escrows.length-1);    escrows.push(newEscrow);  ## Recommended Mitigation Steps    isChildEscrow[address(newEscrow)] = Fermenter(true,_templateId,escrows.length);    escrows.push(newEscrow);  "}, {"title": "`HyperbolicAuction.initAuction` 's `_factor` argument is never used", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/109", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "`HyperbolicAuction.initAuction` 's `_factor` argument is never used"}, {"title": "Loss of price precision", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  cmichel   # Vulnerability details  The `DutchAuction._currentPrice()` is computed by multiplying with `priceDrop()`. However, `priceDrop()` already performs a division and the final current price, therefore, loses precision.  Note that `priceDrop()` could even return `0` for ultra-low prices or very long auctions.  Imagine the actual payment per auction token price is `10^-12` => `startPrice` and `endPrice` are set with 18 decimals as ~`10^6`, but for auctions over a year (31,536,000 seconds > `10^6`) it'll then return 0.  ## Impact Precision can be lost leading to less accurate token auction results or even completely breaking the auction if the price is very low and the auctions are very long.  ## Recommended Mitigation Steps Perform all multiplications before divisions:  ```solidity uint256 priceDiff = block.timestamp.sub(uint256(marketInfo.startTime)).mul(     uint256(_marketPrice.startPrice.sub(_marketPrice.minimumPrice))   ) / uint256(_marketInfo.endTime.sub(_marketInfo.startTime)); ```   "}, {"title": "Gas:  Remove nonce from parameter list", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Gas:  Remove nonce from parameter list"}, {"title": "TokenInitialized token parameter is always empty", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/106", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed", "resolved"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function createToken emits TokenInitialized event, however, it does it before actually deploying the token so address(token) will always be empty (0x0):    emit TokenInitialized(address(token), _templateId, _data);    token = deployToken(_templateId, _integratorFeeAccount); This may confuse external consumers of this event.  ## Recommended Mitigation Steps Usually, a good practice is to emit events in the end after all the actions are done.  "}, {"title": "Gas: Cache auction prices", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/105", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  cmichel   # Vulnerability details  The `DutchAuction.clearingPrice` function can save gas by caching the computed prices instead of recomputing it.  ## Recommended Mitigation Steps Cache the values:  ```solidity function clearingPrice() public view returns (uint256) {     /// @dev If auction successful, return tokenPrice     uint256 _tokenPrice = tokenPrice();     uint256 _currentPrice = priceFunction();     return _tokenPrice > _currentPrice ? _tokenPrice : _currentPrice; } ```   "}, {"title": "Use constant named variable for auction decimals", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/103", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed", "resolved"], "target": "2021-09-sushimiso-findings", "body": "# Handle  cmichel   # Vulnerability details  The `CrowdSale.initCrowdsale` function checks that the auction token has 18 decimals through `IERC20(_token).decimals() == 18`. This seems to be related to `AUCTION_TOKEN_DECIMALS` and these values should not get ouf of sync.  ## Impact These values can easily get out of sync.  ## Recommended Mitigation Steps Create another named constant and set it to `18` decimals:  ```solidity uint256 private constant AUCTION_TOKEN_DECIMAL_PLACES = 18; uint256 private constant AUCTION_TOKEN_DECIMALS = 10 ** AUCTION_TOKEN_DECIMAL_PLACES; ```   "}, {"title": "Should `TokenList` implement `IPointList`?", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/101", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "Should `TokenList` implement `IPointList`?"}, {"title": "`AccessControlTemplateRemoved` event not used", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/100", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "`AccessControlTemplateRemoved` event not used"}, {"title": "No ERC20 `safeApprove` versions called", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/99", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  cmichel   # Vulnerability details  Some tokens don't correctly implement the EIP20 standard and their `approve` function returns `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  Calls to `.approve` with user-defined tokens are made in: - `MISOLauncher.createLauncher` - `MISOMarket.createMarket`  ## Impact Tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the mentioned contracts as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin\u2019s `SafeERC20` versions with the `safeApprove` function that handle the return value check as well as non-standard-compliant tokens.  "}, {"title": "getTokenTemplate should check boundaries", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/98", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "getTokenTemplate should check boundaries"}, {"title": "No ERC20 safe* versions called in MisoRecipe", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/97", "labels": ["bug", "1 (Low Risk)"], "target": "2021-09-sushimiso-findings", "body": "No ERC20 safe* versions called in MisoRecipe"}, {"title": "Usage of address.transfer", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/96", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Usage of address.transfer"}, {"title": "`MISOMasterChef` may not be used with fee-on-transfer tokens", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/94", "labels": ["bug", "sponsor disputed", "1 (Low Risk)"], "target": "2021-09-sushimiso-findings", "body": "`MISOMasterChef` may not be used with fee-on-transfer tokens"}, {"title": "Unused event `StrategyCvxHelper.HarvestState`", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/93", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `HarvestState` event in `StrategyCvxHelper` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.   "}, {"title": "lockTokens should validate withdrawer", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/92", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function lockTokens in contract TokenVault should check that _withdrawer is not empty (0x0) to prevent accidentally locked forever (burned) tokens.  ## Recommended Mitigation Steps require(_withdrawer != address(0));  "}, {"title": "use of floating pragma", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/91", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "use of floating pragma"}, {"title": "unused local variable", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "unused local variable"}, {"title": "use of transfer() instead of call()  to send eth", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "use of transfer() instead of call()  to send eth"}, {"title": "excessive eth is not transfered back to the deployer if msg.value is greater than minimum fees ", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/86", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "excessive eth is not transfered back to the deployer if msg.value is greater than minimum fees "}, {"title": "Consolidation of Storage Slots", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Consolidation of Storage Slots"}, {"title": "Lack of `Immutable` Keyword", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Lack of `Immutable` Keyword"}, {"title": "Old Solidity compiler version", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Old Solidity compiler version"}, {"title": "Unconventional use of basis points for integratorFeePct could cause undefined behavior", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/78", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Unconventional use of basis points for integratorFeePct could cause undefined behavior"}, {"title": "Same LP token can be added more than once to affect reward calculations", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Same LP token can be added more than once to affect reward calculations"}, {"title": "Unchecked `fundsCommitted` in Token Withdrawal", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/74", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Unchecked `fundsCommitted` in Token Withdrawal"}, {"title": "Event parameters interchanged for emit of access control template addition", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed", "resolved"], "target": "2021-09-sushimiso-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Emission of the event AccessControlTemplateAdded(address oldAccessControl, address newAccessControl) has the old and new addresses interchanged which could confuse/trigger offchain monitoring tools or interfaces.   This is of medium severity (instead of low) because it is related to access control template updation and critical to security of all contracts that rely on MISOAccessFactory.  The actual emit is emit AccessControlTemplateAdded(_template, accessControlTemplate); which has the parameter used in the oldAccessControl place instead of being used for the second argument, and vice-versa.  ## Proof of Concept https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/MISOAccessFactory.sol#L36-L37  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Access/MISOAccessFactory.sol#L100   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Interchange the arguments in the emit.  "}, {"title": "Unused event may be unused code or indicative of missed emit/logic", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/72", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Events that are declared but not used may be indicative of unused declarations where it makes sense to remove them for better readability/maintainability/auditability, or worse indicative of a missing emit which is bad for monitoring or missing logic that would have emitted that event.  Event InsuranceClaimed is missing an emit.  Event ControllerSet is missing an emit.  Event VaultManagerSet is missing an emit.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L56  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Harvester.sol#L44  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Harvester.sol#L72  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add emit or remove event declaration.  "}, {"title": "Lack of indexed event parameters will affect offchain monitoring", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "Lack of indexed event parameters will affect offchain monitoring"}, {"title": "Relying on setters for initialisation of critical parameters is risky", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/70", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Relying on setters for initialisation of critical parameters is risky"}, {"title": "Unnecessary zero check on variable which is never initialized earlier", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Unnecessary zero check on variable which is never initialized earlier"}, {"title": "Avoiding unnecessary external call will save > 2600 gas", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Market is guaranteed to be finalized by checking and calling finalize if not finalized. So the subsequent require()  by again checking market.finalized() is redundant and can save 2600+ gas by removing the external call. External calls cost 2600 gas after Berlin upgrade.  ## Proof of Concept  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L226-L229  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove the require().  "}, {"title": "Using function parameters in emits saves gas", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Using function parameters in emits saves gas"}, {"title": "Init functions are susceptible to front-running", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/64", "labels": ["bug", "sponsor disputed", "1 (Low Risk)"], "target": "2021-09-sushimiso-findings", "body": "Init functions are susceptible to front-running"}, {"title": "Missing contract existence check may cause silent failures of token transfers", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Missing contract existence check may cause silent failures of token transfers"}, {"title": "Check for zero msg.value can save gas", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Check for zero msg.value can save gas"}, {"title": "deployMarket may revert due to integer underflow from missing threshold check", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/61", "labels": ["bug", "sponsor disputed", "1 (Low Risk)"], "target": "2021-09-sushimiso-findings", "body": "deployMarket may revert due to integer underflow from missing threshold check"}, {"title": "Avoiding initialization of loop index can save a little gas", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L57  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L211   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove explicit 0 initialization of for loop index variable.  "}, {"title": "Missing useful isOpen() function could save gas", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/59", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Missing useful isOpen() function could save gas"}, {"title": "Payable external init is redundant and may allow unaccounted token claims or DoS", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/53", "labels": ["bug", "sponsor disputed", "1 (Low Risk)"], "target": "2021-09-sushimiso-findings", "body": "Payable external init is redundant and may allow unaccounted token claims or DoS"}, {"title": "Single-step wallet address change is risky", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/52", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Single-step wallet address change is risky"}, {"title": "Missing zero-address checks", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Missing zero-address checks"}, {"title": "Critical withdrawTokens function is missing an event\u2028", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/44", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Critical withdrawTokens function is missing an event\u2028"}, {"title": "Front-running cancelAuction can prevent auction cancellation", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/43", "labels": ["bug", "sponsor disputed", "1 (Low Risk)"], "target": "2021-09-sushimiso-findings", "body": "Front-running cancelAuction can prevent auction cancellation"}, {"title": "Caching state variables in local/memory variables avoids SLOADs to save gas", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  There are few places across contracts where the same state variables are read multiple times or the same external calls are made multiple times within a function. Caching state variables or results from external calls in local/memory variables avoids SLOADs and CALLs to save gas. Warm SLOADs cost 100 gas and CALLs cost 2600 gas after Berlin upgrade. MLOADs cost only 3 gas units.  ## Proof of Concept  Cache swivel: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L61-L64  Cache markets[u][m]: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L76-L86  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L99-L100  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L111-L112  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L181-L182  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L195-L196   Cache matured and maturityRate: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L156-L179\\  Cache vaults: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L244   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Cache state variables or results from external calls in local/memory variables to save gas.  "}, {"title": "Missing zero-address check on beneficiary may lead to loss of funds", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/41", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "Missing zero-address check on beneficiary may lead to loss of funds"}, {"title": "Tokens without 18 decimals are unhandled", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/38", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Tokens without 18 decimals are unhandled"}, {"title": "Slot packing saves slots but increases runtime gas consumption due to masking", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Slot packing saves slots but increases runtime gas consumption due to masking"}, {"title": "Lack of Factory Contract for `TokenList.sol`", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Lack of Factory Contract for `TokenList.sol`"}, {"title": "`_safeApprove()` is Not Used Instead of `approve()`", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "`_safeApprove()` is Not Used Instead of `approve()`"}, {"title": "`currentTemplateId` is Not Actively Removed by `MISOLauncher.removeLiquidityLauncherTemplate()`", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/32", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  If the current template ID is removed from `MISOLauncher.sol`, the function `removeLiquidityLauncherTemplate()` does not accurately reflect this by deleting `currentTemplateId[_templateId]`. This may lead to users actively using a removed template, expecting the `deployLauncher()` function to succeed when it will revert instead.  ## Proof of Concept  https://github.com/sushiswap/miso/blob/master/contracts/MISOLauncher.sol#L323-L334  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider removing `currentTemplateId[_templateId]` if the template to be removed by `removeLiquidityLauncherTemplate()` is the same template.  "}, {"title": "Missing Events on State Changing Functions", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/31", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "Missing Events on State Changing Functions"}, {"title": "Divide Before Multiply", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Divide Before Multiply"}, {"title": "Lack of Input Validation", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/29", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Lack of Input Validation"}, {"title": "Missing SPDX Identifier", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/26", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "Missing SPDX Identifier"}, {"title": "Require statement in PostAuctionLauncher finalize() function will never be reached.", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Require statement in PostAuctionLauncher finalize() function will never be reached."}, {"title": "Outdated and Vulnerable `TimelockController.sol` Contract", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/24", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `TimelockController.sol` acts as an auxiliary contract to the MISO platform's core contracts. Therefore, this issue is not of high risk as not all users wanting to auction tokens will use this contract for governance behaviour. The `TimelockController.sol` enables a governance framework to enforce a timelock on any proposals, giving users time to exit before a potentially dangerous maintenance operation is applied. However, the `executeBatch()` is vulnerable to reentrancy, enabling privilege escalation for any account with the `EXECUTOR` role to `ADMIN`.  ## Proof of Concept  Bug outlined [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/access/TimelockController.sol#L244-L269). Fix is outlined in this [commit](https://github.com/OpenZeppelin/openzeppelin-contracts/commit/cec4f2ef57495d8b1742d62846da212515d99dd5#diff-8229f9027848871a1706845a5a84fa3e6591445cfac6e16cfb7d652e91e8d395R307).  ## Tools Used  Sourced from publicly disclosed post by [Immnuefi](https://medium.com/immunefi/openzeppelin-bug-fix-postmortem-66d8c89ed166).  ## Recommended Mitigation Steps  Update `Openzeppelin` library to a version containing the commit fixing the bug (mentioned above). Tag `v3.4.2-solc-0.7` in `Openzeppelin`'s Github repository is an example of a compatible library that contains the aforementioned bug fix.  "}, {"title": "funds will get lost in deployAccessControl if devaddr isn't set", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/23", "labels": ["bug", "sponsor disputed", "1 (Low Risk)"], "target": "2021-09-sushimiso-findings", "body": "funds will get lost in deployAccessControl if devaddr isn't set"}, {"title": "comment copy paste error", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/21", "labels": ["bug", "0 (Non-critical)"], "target": "2021-09-sushimiso-findings", "body": "comment copy paste error"}, {"title": "Frontrunning Initialization of Contracts", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/19", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "Frontrunning Initialization of Contracts"}, {"title": "gas improvement in isInList ", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "gas improvement in isInList "}, {"title": "finalize() can be succesfully called before initMarket()", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/16", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushimiso-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function finalize() of all the auction contracts can be called by everyone before initMarket() is called. This will set status.finalized = true, which will probably not be detected until the auction is over (because it is only used in a few locations).  If this would happen then the auction cannot be finalized again. Also cancelAuction cannot be called.  Luckily the deployment of the auction contracts is done from createMarket in MISOMarket.sol, which directly calls initMarket(). So in practice this won't pose a problem, however future developers or forks might not be aware of this and deploy the contract differently.  ## Proof of Concept https://github.com/sushiswap/miso/blob/master/contracts/Auctions/Crowdsale.sol#L374  function finalize() public nonReentrant {         require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender)              || finalizeTimeExpired(),                         // initially  true             \"Crowdsale: sender must be an admin\"         );         MarketStatus storage status = marketStatus;         require(!status.finalized, \"Crowdsale: already finalized\");  // initially status.finalized==false         MarketInfo storage info = marketInfo;         require(auctionEnded(), \"Crowdsale: Has not finished yet\");   // initially  true          if (auctionSuccessful()) {  // initially  true             /// @dev Successful auction             /// @dev Transfer contributed tokens to wallet.             _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));             /// @dev Transfer unsold tokens to wallet.             uint256 soldTokens = _getTokenAmount(uint256(status.commitmentsTotal));             uint256 unsoldTokens = uint256(info.totalTokens).sub(soldTokens);             if(unsoldTokens > 0) {                 _safeTokenPayment(auctionToken, wallet, unsoldTokens);             }         } else {             /// @dev Failed auction             /// @dev Return auction tokens back to wallet.             _safeTokenPayment(auctionToken, wallet, uint256(info.totalTokens));         }          status.finalized = true;    // will end up here          emit AuctionFinalized();     }  function finalizeTimeExpired() public view returns (bool) {            return uint256(marketInfo.endTime) + 7 days < block.timestamp;  // initially  true (0 + 7 days <  block.timestamp)     }       function auctionSuccessful() public view returns (bool) {         return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal); // initially  true  (0>=0)     }   function auctionEnded() public view returns (bool) {         return block.timestamp > uint256(marketInfo.endTime) ||                              // // initially  true  (block.timestamp>0)         _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens);     }  // https://github.com/sushiswap/miso/blob/master/contracts/MISOMarket.sol#L273 function createMarket(...)     {         newMarket = deployMarket(_templateId, _integratorFeeAccount);         ...         IMisoMarket(newMarket).initMarket(_data);  ## Tools Used  ## Recommended Mitigation Steps In function finalize() add something like:     require(isInitialized(),\"Not initialized\");   "}, {"title": "Last person to withdraw his tokens might not be able to do this, in Crowdsale (edge case)", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/15", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-09-sushimiso-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose a Crowdsale is successful and enough commitments are made before the marketInfo.endTime. Suppose marketStatus.commitmentsTotal  == marketInfo.totalTokens -1      // note this is an edge case, but can be constructed by an attacker Then the function auctionEnded() returns true Assume auctionSuccessful() is also true (might depend on the config of marketPrice.goal and marketInfo.totalTokens) Then an admin can call finalize() to finalize the Crowdsale. The function finalize distributes the funds and the unsold tokens and sets status.finalized = true so that finalized cannot be called again. Now we have \"marketInfo.totalTokens -1\" tokens left in the contract  However commitEth() or commitTokens() can still be called (they give no error message that the auction has ended) Then functions call calculateCommitment, which luckily prevent from buying too much, however 1 token can still be bought These functions also call _addCommitment(), which only checks for marketInfo.endTime, which hasn't passed yet.  Now an extra token is sold and the contract has 1 token short. So the last person to withdraw his tokens cannot withdraw them (because you cannot specify how much you want to withdraw)  Also the revenues for the last token cannot be retrieved as finalize() cannot be called again.  ## Proof of Concept https://github.com/sushiswap/miso/blob/master/contracts/Auctions/Crowdsale.sol#L374 ```JS  function finalize() public nonReentrant {         require(hasAdminRole(msg.sender) || wallet == msg.sender || hasSmartContractRole(msg.sender) || finalizeTimeExpired(),\"Crowdsale: sender must be an admin\"); // can be called by admin         MarketStatus storage status = marketStatus;         require(!status.finalized, \"Crowdsale: already finalized\");         MarketInfo storage info = marketInfo;         require(auctionEnded(), \"Crowdsale: Has not finished yet\");    // is true if enough sold, even if this is before marketInfo.endTime          if (auctionSuccessful()) {                       /// @dev Transfer contributed tokens to wallet.             /// @dev Transfer unsold tokens to wallet.         } else {             /// @dev Return auction tokens back to wallet.         }         status.finalized = true;  function auctionEnded() public view returns (bool) {         return block.timestamp > uint256(marketInfo.endTime) ||          _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens); // is true if enough sold, even if this is before marketInfo.endTime     }  function auctionSuccessful() public view returns (bool) {         return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal); }  function commitEth(address payable _beneficiary, bool readAndAgreedToMarketParticipationAgreement ) public payable nonReentrant  {        ...         uint256 ethToTransfer = calculateCommitment(msg.value);        ...        _addCommitment(_beneficiary, ethToTransfer);      function calculateCommitment(uint256 _commitment) public view returns (uint256 committed) { // this prevents buying too much         uint256 tokens = _getTokenAmount(_commitment);         uint256 tokensCommited =_getTokenAmount(uint256(marketStatus.commitmentsTotal));         if ( tokensCommited.add(tokens) > uint256(marketInfo.totalTokens)) {             return _getTokenPrice(uint256(marketInfo.totalTokens).sub(tokensCommited));         }         return _commitment;     }  function _addCommitment(address _addr, uint256 _commitment) internal {         require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), \"Crowdsale: outside auction hours\"); // doesn't check auctionEnded() nor status.finalized         ...         uint256 newCommitment = commitments[_addr].add(_commitment);         ...         commitments[_addr] = newCommitment;  function withdrawTokens(address payable beneficiary) public   nonReentrant  {             if (auctionSuccessful()) {             ...             uint256 tokensToClaim = tokensClaimable(beneficiary);             ...             claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);             _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);    // will fail is last token is missing         } else {    ## Tools Used  ## Recommended Mitigation Steps In the function _addCommitment, add a check on auctionEnded() or status.finalized  "}, {"title": "`PostAuctionLauncher.sol#finalize()` Adding liquidity to an existing pool may allows the attacker to steal most of the tokens", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/14", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-09-sushimiso-findings", "body": "# Handle  WatchPug   # Vulnerability details  `PostAuctionLauncher.finalize()` can be called by anyone, and it sends tokens directly to the pair pool to mint liquidity, even when the pair pool exists.  An attacker may control the LP price by creating the pool and then call `finalize()` to mint LP token with unfair price (pay huge amounts of tokens and get few amounts of LP token), and then remove the initial liquidity they acquired when creating the pool and takeout huge amounts of tokens.  https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L257  ```solidity=216 /**  * @notice Finalizes Token sale and launches LP.  * @return liquidity Number of LPs.  */ function finalize() external nonReentrant returns (uint256 liquidity) {     // GP: Can we remove admin, let anyone can finalise and launch?     // require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PostAuction: Sender must be operator\");     require(marketConnected(), \"PostAuction: Auction must have this launcher address set as the destination wallet\");     require(!launcherInfo.launched);      if (!market.finalized()) {         market.finalize();     }     require(market.finalized());      launcherInfo.launched = true;     if (!market.auctionSuccessful() ) {         return 0;     }      /// @dev if the auction is settled in weth, wrap any contract balance      uint256 launcherBalance = address(this).balance;     if (launcherBalance > 0 ) {         IWETH(weth).deposit{value : launcherBalance}();     }          (uint256 token1Amount, uint256 token2Amount) =  getTokenAmounts();      /// @dev cannot start a liquidity pool with no tokens on either side     if (token1Amount == 0 || token2Amount == 0 ) {         return 0;     }      address pair = factory.getPair(address(token1), address(token2));     if(pair == address(0)) {         createPool();     }      /// @dev add liquidity to pool via the pair directly     _safeTransfer(address(token1), tokenPair, token1Amount);     _safeTransfer(address(token2), tokenPair, token2Amount);     liquidity = IUniswapV2Pair(tokenPair).mint(address(this));     launcherInfo.liquidityAdded = BoringMath.to128(uint256(launcherInfo.liquidityAdded).add(liquidity));      /// @dev if unlock time not yet set, add it.     if (launcherInfo.unlock == 0 ) {         launcherInfo.unlock = BoringMath.to64(block.timestamp + uint256(launcherInfo.locktime));     }     emit LiquidityAdded(liquidity); } ```   In line 257, `PostAuctionLauncher` will mint LP with token1Amount and token2Amount. The amounts (token1Amount and token2Amount) are computed according to the auction result, without considering the current price (reserves) of the existing `tokenPair`.  See [PostAuctionLauncher.getTokenAmounts()](https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L268)  `PostAuctionLauncher` will receive an unfairly low amount of lp token because the amounts sent to `tokenPair` didn't match the current price of the pair.  See [UniswapV2Pair.mint(...)](https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/UniswapV2/UniswapV2Pair.sol#L135) ```solidity=135 liquidity = MathUniswap.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); ```  ## Impact  Lose a majority share of the tokens.  ## Proof of Concept  1. The attacker creates LP with 0.0000001 token1 and 1000 token2, receives 0.01 LP token; 2. Call `PostAuctionLauncher.finalize()`. PostAuctionLauncher will mint liquidity with 2000 token1 and 1000 token2 for example, receives only  0.01 LP token; 3. The attacker removes all his LP, receives 1000 token1 (most of which come from PostAuctionLauncher).  ## Recommended Mitigation Steps  To only support tokenPair created by PostAuctionLauncher or check for the token price before mint liquidity.  "}, {"title": "PostAuctionLauncher _deposit require condition contradicts error message", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/13", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushimiso-findings", "body": "PostAuctionLauncher _deposit require condition contradicts error message"}, {"title": "Teams should be warned not to accept rebasing tokens as payment currencies", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "Teams should be warned not to accept rebasing tokens as payment currencies"}, {"title": "Typo in comment in PointList.sol", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/10", "labels": ["bug", "0 (Non-critical)"], "target": "2021-09-sushimiso-findings", "body": "Typo in comment in PointList.sol"}, {"title": "Redundant liquidityAdded check", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Redundant liquidityAdded check"}, {"title": "Unnecessary addition in finalize() function", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Unnecessary addition in finalize() function"}, {"title": "Redundant _newAddress parameter for deprecateFactory", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushimiso-findings", "body": "Redundant _newAddress parameter for deprecateFactory"}, {"title": "cancelAuction function is public, but not called internally", "html_url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-09-sushimiso-findings", "body": "cancelAuction function is public, but not called internally"}, {"title": "Incorrect comparison in the `_updateReserves` function of `HybridPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/190", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushitrident-findings", "body": "Incorrect comparison in the `_updateReserves` function of `HybridPool`"}, {"title": "Unnecessary condition on `_processSwap` of `HybridPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/189", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "Unnecessary condition on `_processSwap` of `HybridPool`"}, {"title": "Division by zero in `_computeLiquidityFromAdjustedBalances` of `HybridPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/185", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeLiquidityFromAdjustedBalances` function of `HybridPool` should return in the `if (s == 0)` statement, or it will cause a divison-by-zero error otherwise.  ## Proof of Concept  Referenced code: [HybridPool.sol#L350-L352](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L350-L352)  ## Recommended Mitigation Steps  Add `return computed;` after `computed = 0;`.  "}, {"title": "Docs disagrees with index pool code", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/184", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushitrident-findings", "body": "Docs disagrees with index pool code"}, {"title": "No bar fees for IndexPools?", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/181", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact IndexPool doesn't collect fees for `barFeeTo`. Since this Pool contains also a method `updateBarFee()`, probably this is an unintended behavior. Also without a fee, liquidity providers would probably ditch ConstantProductPool in favor of IndexPool (using the same two tokens with equal weights), since they get all the rewards. This would constitute an issue for the ecosystem.  ## Recommended Mitigation Steps Add a way to send barFees to barFeeTo, same as the other pools.  "}, {"title": "Wrong initialization of `blockTimestampLast` in `ConstantProductPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/180", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Wrong initialization of `blockTimestampLast` in `ConstantProductPool`"}, {"title": "Users are susceptible to back-running when depositing ETH to `TridenRouter`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/179", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  The `_depositToBentoBox` and `_depositFromUserToBentoBox` allow users to provide ETH to the router, which is later deposited to the `bento` contract for swapping other assets or providing liquidity. However, in these two functions, the input parameter does not represent the actual amount of ETH to deposit, and users have to calculate the actual amount and send it to the router, causing a back-run vulnerability if there are ETH left after the operation.  ## Proof of Concept  1. A user wants to swap ETH to DAI. He calls `exactInputSingleWithNativeToken` on the router with the corresponding parameters and `params.amountIn` being 10. Before calling the function, he calculates `bento.toAmount(wETH, 10, true) = 15` and thus send 15 ETH to the router. 2. However, at the time when his transaction is executed, `bento.toAmount(wETH, amount, true)` becomes to `14`, which could happen if someone calls `harvest` on `bento` to update the `elastic` value of the `wETH` token. 3. As a result, only 14 ETH is transferred to the pool, and 1 ETH is left in the router. Anyone could back-run the user's transaction to retrieve the remaining 1 ETH from the router by calling the `refundETH` function.  Referenced code: [TridentRouter.sol#L318-L351](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L318-L351)  ## Recommended Mitigation Steps  Directly push the remaining ETH to the sender to prevent any ETH left in the router.  "}, {"title": "Inconsistent tokens sent to `barFeeTo`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/177", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "Inconsistent tokens sent to `barFeeTo`"}, {"title": "View functions in Hybrid Pool Contract Pool need better documentation", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/175", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "View functions in Hybrid Pool Contract Pool need better documentation"}, {"title": "`_getY` and `_getYD` math operations can be reordered", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/174", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "`_getY` and `_getYD` math operations can be reordered"}, {"title": "`_computeLiquidityFromAdjustedBalances` order of operations can be improved", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/173", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "`_computeLiquidityFromAdjustedBalances` order of operations can be improved"}, {"title": "Funds in the pool could be stolen by exploiting `flashSwap` in `HybridPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/167", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  An attacker can call the `bento.harvest` function during the callback function of a flash swap of the `HybridPool` to reduce the number of input tokens that he has to pay to the pool, as long as there is any unrealized profit in the strategy contract of the underlying asset.  ## Proof of Concept  1. The `HybridPool` accounts for the reserve and balance of the pool using the `bento.toAmount` function, which represents the actual amount of assets that the pool owns instead of the relative share. The value of `toAmount` could increase or decrease if the `bento.harvest` function is called (by anyone), depending on whether the strategy contract earns or loses money. 2. Supposing that the DAI strategy contract of `Bento` has a profit not accounted for yet. To account for the profit, anyone could call `harvest` on `Bento` with the corresponding parameters, which, as a result, increases the `elastic` of the DAI token. 3. Now, an attacker wants to utilize the unrealized profit to steal funds from a DAI-WETH hybrid pool. He calls `flashSwap` to initiate a flash swap from WETH to DAI. First, the pool transfers the corresponding amount of DAI to him, calls the `tridentSwapCallback` function on the attacker's contract, and expects that enough DAI is received at the end. 4. During the `tridentSwapCallback` function, the attacker calls `bento.harvest` to realize the profit of DAI. As a result, the pool's `bento.toAmount` increases, and the amount of DAI that the attacker has to pay to the pool is decreased. The attacker could get the same amount of ETH but paying less DAI by exploiting this bug.  Referenced code: [HybridPool.sol#L218-L220](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L218-L220) [HybridPool.sol#L249-L250](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L249-L250) [HybridPool.sol#L272-L285](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L272-L285) [BentoBoxV1Flat.sol#L1105](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L1105) [BentoBoxV1Flat.sol#L786-L792](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L786-L792) [BentoBoxV1Flat.sol#L264-L277](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/flat/BentoBoxV1Flat.sol#L264-L277)  ## Recommended Mitigation Steps  Consider not using `bento.toAmount` to track the reservers and balances, but use `balanceOf` instead (as done in the other two pools).   "}, {"title": "Incorrect multiplication in `_computeSingleOutGivenPoolIn` of `IndexPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/166", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeSingleOutGivenPoolIn` function of `IndexPool` uses the raw multiplication (i.e., `*`) to calculate the `zaz` variable. However, since both `(BASE - normalizedWeight)` and `_swapFee` are in `WAD`, the `_mul` function should be used instead to calculate the correct value of `zaz`. Otherwise, `zaz` would be `10 ** 18` times larger than the expected value and causes an integer underflow when calculating `amountOut`. The incorrect usage of multiplication prevents anyone from calling the function successfully.  ## Proof of Concept  Referenced code: [IndexPool.sol#L282](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L282)   ## Recommended Mitigation Steps  Change `(BASE - normalizedWeight) * _swapFee` to `_mul((BASE - normalizedWeight), _swapFee)`.  "}, {"title": "Incorrect usage of `_pow` in `_computeSingleOutGivenPoolIn` of `IndexPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/165", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  The `_computeSingleOutGivenPoolIn` function of `IndexPool` uses the `_pow` function to calculate `tokenOutRatio` with the exponent in `WAD` (i.e., in 18 decimals of precision). However, the `_pow` function assumes that the given exponent `n` is not in `WAD`. (for example, `_pow(5, BASE)` returns `5 ** (10 ** 18)` instead of `5 ** 1`). The misuse of the `_pow` function could causes an integer overflow in the `_computeSingleOutGivenPoolIn` function and thus prevent any function from calling it.  ## Proof of Concept  Referenced code: [IndexPool.sol#L279](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L279)   ## Recommended Mitigation Steps  Change the `_pow` function to the `_compute` function, which supports exponents in `WAD`.  "}, {"title": "HybridPool's wrong amount to balance conversion", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/164", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "HybridPool's wrong amount to balance conversion"}, {"title": "Overflow in the `mint` function of `IndexPool` causes LPs' funds to be stolen", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/163", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Overflow in the `mint` function of `IndexPool` causes LPs' funds to be stolen"}, {"title": "`_powApprox`: unbounded loop and meaning", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/162", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-findings", "body": "`_powApprox`: unbounded loop and meaning"}, {"title": "Follow Curve's convention: `_getYD` and `_getY`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/156", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In HybridPool.sol, functions `_getY` and `_getYD` are identical (only differences are variables' names), and only `_getY` is used in the contract.  Since these functions are supposed to mimic those of Curve, it would make more sense to follow their naming conventions. In particular, `_getYD` correctly mimics Curve's `_get_y_D` ([ref](https://github.com/curvefi/curve-contract/blob/master/contracts/pool-templates/base/SwapTemplateBase.vy#L614)), while `_getY` does not mimic Curve's `_get_y` ([ref](https://github.com/curvefi/curve-contract/blob/master/contracts/pool-templates/base/SwapTemplateBase.vy#L379)).  ## Recommended Mitigation Steps Consider eliminating `_getY` and using `_getYD` instead in the contract.  "}, {"title": "Approximations may finish with inaccurate values", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/155", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-09-sushitrident-findings", "body": "Approximations may finish with inaccurate values"}, {"title": "lack of input validation in Transfer() and TransferFrom()", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/153", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "lack of input validation in Transfer() and TransferFrom()"}, {"title": "Rounding errors will occur for tokens without decimals", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/152", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Rounding errors will occur for tokens without decimals"}, {"title": "Using interfaces instead of selectors is best practice", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/150", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "# Handle  tensors   # Vulnerability details  Throughout the code function selectors are often used instead of interfaces.  It is considered best practice to use interfaces instead of selectors for code readability.  "}, {"title": "Using 10**X for constants isn't gas efficient", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact In Solidity, a `constant` expression in a variable will compute the expression everytime the variable is called. It's not the result of the expression that is stored, but the expression itself.  As Solidity supports the scientific notation, constants of form `10**X` can be rewritten as `1eX` to save the gas cost from the calculation with the exponentiation operator `**`.  ## Proof of Concept ``` NFTXInventoryStaking.sol:   28:     uint256 public constant BASE = 10**18;  NFTXMarketplaceZap.sol:   158:   uint256 constant BASE = 10**18;  NFTXStakingZap.sol:   163:   uint256 constant BASE = 10**18;  NFTXVaultUpgradeable.sol:   33:     uint256 constant base = 10**18; ```  ## Tools Used Vs Code  ## Recommended Mitigation Steps Replace `10**18` with `1e18`  "}, {"title": "Consider using solidity 0.8.8", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/141", "labels": ["bug", "1 (Low Risk)"], "target": "2021-09-sushitrident-findings", "body": "Consider using solidity 0.8.8"}, {"title": "Lack of address validation in `MasterDeployer.setMigrator`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/140", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Lack of address validation in `MasterDeployer.setMigrator`"}, {"title": "absolute difference is not calculated properly when a > b in MathUtils", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/139", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  hack3r-0m   # Vulnerability details  https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/libraries/MathUtils.sol#L22 the difference is computed incorrectly when a > b.  As it only used in within1 function, scope narrows down to where `difference(a, b) <= 1;` is exploitable.  cases where `difference(a, b) <= 1` should be true but is reported false: - where b = a-1 (returned value is type(uint256).max)  cases where `difference(a, b) <= 1` should be false but is reported true: - where a = type(uint256).max and b = 0, it returns 1 but it should ideally return type(uint256).max  within1 is used at the following locations: - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L359 - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L383 - https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L413  It is possible to decrease the denominator and increase the value of the numerator (when calculating y) using constants and input to make within1 fail  Mitigation:  Add `else` condition to mitigate it.  ``` unchecked {           if (a > b) {               diff = a - b;           }           else {               diff = b - a;              }       } ```  (re-submitting this issue after withdrawing past one since I forgot to add more  details and POC)  "}, {"title": "Lack of address validation in `MasterDeployer.addToWhitelist`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/138", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "Lack of address validation in `MasterDeployer.addToWhitelist`"}, {"title": "Lack of checks for address and amount in `TridentERC20._burn`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/135", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Lack of checks for address and amount in `TridentERC20._burn`"}, {"title": "Lack of checks for address and amount in `TridentERC20._mint`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/131", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Lack of checks for address and amount in `TridentERC20._mint`"}, {"title": "Cache storage variable in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  WatchPug   # Vulnerability details  Cache storage variable in the stack can save gas.  For instance:  https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L140-L155  `outRecord.reserve` is accessed 2 times.   https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L158-L179 https://github.com/sushiswap/trident/blob/master/contracts/pool/IndexPool.sol#L182-L205  `inRecord.reserve` is accessed 3 times.  "}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `TimeswapPair.sol#pay()`      https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359-L359   - `PayMath.sol#givenMaxAssetsIn()`      https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L21-L21   "}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/127", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "Style issues"}, {"title": "The functions `refundETH` and `unwrapWETH` is generalized-front-runnable", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/124", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-findings", "body": "The functions `refundETH` and `unwrapWETH` is generalized-front-runnable"}, {"title": "Functions that can be made external", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/122", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "Functions that can be made external"}, {"title": "Consider avoiding low level calls to MasterDeployer", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/121", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Consider avoiding low level calls to MasterDeployer  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/ConstantProductPool.sol#L64)  The constructor uses low-level calls to the master deployer. It is more idiomatic to rely on high level solidity to deal with the calls. The difference would be additional checks on whether there is code at the specified address (additional `100` gas) and automatically performing the ABI decoding (may actually be more efficient than the manual implementation.) (Note that this call will still be `staticcall`, since `barFee` is a view function in the interface.)  Example:  ``` diff modified   contracts/pool/ConstantProductPool.sol @@ -61,7 +61,7 @@ contract ConstantProductPool is IPool, TridentERC20 {          require(_token1 != address(this), \"INVALID_TOKEN\");          require(_swapFee <= MAX_FEE, \"INVALID_SWAP_FEE\");  -        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector)); +        barFee = IMasterDeployer(_masterDeployer).barFee();          (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));          (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));  @@ -72,7 +72,6 @@ contract ConstantProductPool is IPool, TridentERC20 {          unchecked {              MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;          } -        barFee = abi.decode(_barFee, (uint256));          barFeeTo = abi.decode(_barFeeTo, (address));          bento = abi.decode(_bento, (address));          masterDeployer = _masterDeployer; ```   "}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "Use `calldata` instead of `memory` for function parameters"}, {"title": " Consider putting some parts of `_div` in unchecked", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/118", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Consider putting some parts of `_div` in unchecked  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L335)  ``` diff modified   contracts/pool/IndexPool.sol @@ -332,7 +332,8 @@ contract IndexPool is IPool, TridentERC20 {       function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {          uint256 c0 = a * BASE; -        uint256 c1 = c0 + (b / 2); +        unchecked { uint256 tmp =  b / 2; } +        uint256 c1 = c0 + tmp;          c2 = c1 / b;      } ```  Looking at the optimized assembly generated, the unchecked version doesn't seem to have the additional check for division by zero. I'm not entirely sure why, but my guess is because of inlining. Also consider replacing the division by inline assembly.  ``` solidity uint tmp; assembly {     tmp := div(b, 2) } uint256 c1 = c0 + tmp; ```  The change avoids an `if` condition which checks if the divisor is zero, which the optimizer is currently unable to optimize out. The gas savings would be around 16 (reduces a `jumpi`, `push 0` and `dupN`). Since the `_div` function is called from throughout the code (also present in other contracts), this may be worth considering, although I admit this might be too much of a micro-optimization.   "}, {"title": "Unused state variable `barFee` and `_barFeeTo` in IndexPool", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Unused state variable `barFee` and `_barFeeTo` in IndexPool"}, {"title": "Caching a storage load in TridentERC20", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching a storage load in TridentERC20  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/TridentERC20.sol#L76)  This avoids an unnecessary `sload`.  ``` diff modified   contracts/pool/TridentERC20.sol @@ -73,8 +73,9 @@ abstract contract TridentERC20 {          address recipient,          uint256 amount      ) external returns (bool) { -        if (allowance[sender][msg.sender] != type(uint256).max) { -            allowance[sender][msg.sender] -= amount; +        uint _allowance = allowance[sender][msg.sender]; +        if (_allowance != type(uint256).max) { +            allowance[sender][msg.sender] = _allowance - amount;          }          balanceOf[sender] -= amount;          // @dev This is safe from overflow - the sum of all user ```   "}, {"title": "Caching the storage read to `tokens.length`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Caching the storage read to `tokens.length`  Ignoring the caching for the for-loop condition (see my other issue \"Caching the length in for loops\"), this would save an additional `sload`, around `100` gas.  [Context](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L129).  ``` diff modified   contracts/pool/IndexPool.sol @@ -121,12 +121,12 @@ contract IndexPool is IPool, TridentERC20 {          (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));           uint256 ratio = _div(toBurn, totalSupply); -        withdrawnAmounts = new TokenAmount[](tokens.length); +        uint length = tokens.length; +        withdrawnAmounts = new TokenAmount[](length);           _burn(address(this), toBurn);  -        for (uint256 i = 0; i < tokens.length; i++) { +        for (uint256 i = 0; i < length; i++) {              address tokenOut = tokens[i];              uint256 balance = records[tokenOut].reserve;              uint120 amountOut = uint120(_mul(ratio, balance)); ```   "}, {"title": "Consider changing the `_deployData` architecture", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/114", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Consider changing the `_deployData` architecture"}, {"title": "Consider using custom errors instead of revert strings", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/113", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Consider using custom errors instead of revert strings"}, {"title": "Caching the length in for loops", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "Caching the length in for loops"}, {"title": "Inclusive check of type(uint128).max", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/107", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "Inclusive check of type(uint128).max"}, {"title": "Emit events when setting the values in constructor", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/105", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "Emit events when setting the values in constructor"}, {"title": "MAX_FEE_SQUARE dependency on MAX_FEE", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/104", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "MAX_FEE_SQUARE dependency on MAX_FEE"}, {"title": "Gas: `HybridPool._computeLiquidityFromAdjustedBalances` should return early", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `HybridPool._computeLiquidityFromAdjustedBalances` function should return early if `s == 0` as it will always return zero. Currently, it still performs an expensive loop iteration.  ```solidity if (s == 0) {   // gas: should do an early return here   computed = 0;   // return 0; } ```  ## Recommended Mitigation Steps Return early with a value of `0` if `s == 0`.   "}, {"title": "Gas: `HybridPool` unnecessary `balance` computations", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `HybridPool.burn` function subtracts some computation from `balance0`/`balance1`, but the result is never used.  ```solidity balance0 -= _toShare(token0, amount0); balance1 -= _toShare(token1, amount1); ```  ## Recommended Mitigation Steps Unless it is used as an underflow check, the computation should be removed the result is not used.   "}, {"title": "`HybridPool`'s reserve is converted to \"amount\" twice", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/101", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `HybridPool`'s reserves are stored as Bento \"amounts\" (not Bento shares) in `_updateReserves` because `_balance()` converts the current share balance to amount balances. However, when retrieving the `reserve0/1` storage fields in `_getReserves`, they are converted to amounts a second time.  ## Impact The `HybridPool` returns wrong reserves which affects all minting/burning and swap functions. They all return wrong results making the pool eventually economically exploitable or leading to users receiving less tokens than they should.  ## POC Imagine the current Bento amount / share price being `1.5`. The pool's Bento _share_ balance being `1000`. `_updateReserves` will store a reserve of `1.5 * 1000 = 1500`. When anyone trades using the `swap` function, `_getReserves()` is called and multiplies it by `1.5` again, leading to using a reserve of 2250 instead of 1500. A higher reserve for the output token leads to receiving more tokens as the swap output. Thus the pool lost tokens and the LPs suffer this loss.  ## Recommended Mitigation Steps Make sure that the reserves are in the correct amounts.   "}, {"title": "`HybridPool`'s `flashSwap` does not always call callback", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/100", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `HybridPool.flashSwap` function skips the `tridentSwapCallback` callback call if `data.length == 0`.  ## Impact It should never skip the callback, otherwise the `flashSwap` function is useless. Note that this behavior of the `HybridPool` is not in alignment with the `flashSwap` behavior of all other pools that indeed always call the callback.  ## Recommended Mitigation Steps Always make the call to `ITridentCallee(msg.sender).tridentSwapCallback(data);`, regardless of the `data` variable.  "}, {"title": "`HybridPool`'s `flashSwap` sends entire fee to `barFeeTo`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/99", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `HybridPool.flashSwap` function sends the entire trade fees `fee` to the `barFeeTo`. It should only send `barFee * fee` to the `barFeeTo` address.  ## Impact LPs are not getting paid at all when this function is used. There is no incentive to provide liquidity.  ## Recommended Mitigation Steps The `flashSwap` function should use the same fee mechanism as `swap` and only send `barFee * fee / MAX_FEE` to the `barFeeTo`. See `_handleFee` function.   "}, {"title": "`HybridPool` missing positive token amount checks for initial mint", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/97", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "`HybridPool` missing positive token amount checks for initial mint"}, {"title": "`ConstantProductPool.burnSingle` swap amount computations should use balance", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/96", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConstantProductPool.burnSingle` function is basically a `burn` followed by a `swap` and must therefore act the same way as calling these two functions sequentially.  The token amounts to redeem (`amount0`, `amount1`) are computed on the **balance** (not the reserve). However, the swap amount is then computed on the **reserves** and not the balance. The `burn` function would have updated the `reserve` to the balances and therefore `balance` should be used here:  ```solidity amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1); ```  > \u26a0\ufe0f The same issue occurs in the `HybridPool.burnSingle`.  ## Impact For a burn, usually the `reserve` should equal the `balance`, however if any new tokens are sent to the contract and `balance > reserve`, this function will return slightly less swap amounts.  ## Recommended Mitigation Steps Call `_getAmountOut` with the balances instead of the reserves: `_getAmountOut(amount0, balance0 - amount0, balance1 - amount1)`   "}, {"title": "`ConstantProductPool` mint liquidity computation should include fees", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/95", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConstantProductPool` computes optimal balanced LP using `_nonOptimalMintFee`, which performs something like a swap. The returned swap fees should be included in the \"`k`\" computation as `_handleFees` uses the growth in `k` to estimate the swap fees.  ```solidity // should not reduce fee0 and fee1 uint256 computed = TridentMath.sqrt((balance0 - fee0) * (balance1 - fee1)); ```  > \u26a0\ufe0f The same issue occurs in the `HybridPool.mint`.  ## Impact The non-optimal mint swap fees are not taken into account.  ## Recommended Mitigation Steps Compute `sqrt(k)` on the `balance0 * balance1` without deducting the swap fees.   "}, {"title": "`ConstantProductPool` bar fee computation seems wrong", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/94", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "`ConstantProductPool` bar fee computation seems wrong"}, {"title": "`ConstantProductPool.getAmountOut` does not verify token", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/93", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConstantProductPool.getAmountOut` function does not verify that `tokenIn == token1` in the `else` branch. This is done everywhere else though (see `swap` and `flashSwap`) and should be done here as well.  ## Impact The function can be called with a token that is not any of the pool tokens.  ## Recommended Mitigation Steps Add the missing check.  "}, {"title": "Several low-level calls don't check the success return value", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/91", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Several low-level calls don't check the success return value"}, {"title": "`withdrawFromWETH` always reverts ", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/90", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `TridentHelper.withdrawFromWETH` (used in `TridentRouter.unwrapWETH`) function performs a low-level call to `WETH.withdraw(amount)`.  It then checks if the return `data` length is more or equal to `32` bytes, however `WETH.withdraw` returns `void` and has a return value of `0`. Thus, the function always reverts even if `success == true`.  ```solidity function withdrawFromWETH(uint256 amount) internal {     // @audit WETH.withdraw returns nothing, data.length always zero. this always reverts     require(success && data.length >= 32, \"WITHDRAW_FROM_WETH_FAILED\"); } ```  ## Impact The `unwrapWETH` function is broken and makes all transactions revert. Batch calls to the router cannot perform any unwrapping of WETH.  ## Recommended Mitigation Steps Remove the `data.length >= 32` from the require and only check if `success` is true.  "}, {"title": "`_depositToBentoBox` sometimes uses both ETH and WETH", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/89", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "`_depositToBentoBox` sometimes uses both ETH and WETH"}, {"title": "Router's `complexPath` percentagePaths don't work as expected", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-findings", "body": "Router's `complexPath` percentagePaths don't work as expected"}, {"title": "TridentERC20 does not emit Approval event in `transferFrom`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/86", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "TridentERC20 does not emit Approval event in `transferFrom`"}, {"title": "`IndexPool` should check that tokens are supported", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "`IndexPool` should check that tokens are supported"}, {"title": "IndexPool initial LP supply computation is wrong", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/78", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  cmichel   # Vulnerability details  The `IndexPool.constructor` function already mints `INIT_POOL_SUPPLY = 100 * 1e18 = 1e20` LP tokens to the zero address.  When trying to use the pool, someone has to provide the actual initial reserve tokens in `mint`. On the first `mint`, the pool reserves are zero and the token amount required to mint is just this `ratio` itself: `uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;`  Note that the `amountIn` is **independent of the token** which does not make much sense. This implies that all tokens must be provided in equal \"raw amounts\", regardless of their decimals and value.  ## POC #### Issue 1 Imagine I want to create a DAI/WBTC pool. If I want to initialize the pool with 100$ of DAI, `amountIn = ratio` needs to be `100*1e18=1e20` as DAI has 18 decimals. However, I now also need to supply `1e20` of WBTC (which has 8 decimals) and I'd need to pay `1e20/1e8 * priceOfBTC`, over a quadrillion dollars to match it with the 100$ of DAI.  #### Issue 2 Even in a pool where all tokens have the same decimals and the same value, like `USDC <> USDT`, it leads to issues: - Initial minter calls `mint` with `toMint = 1e20` which sets `ratio = 1e20 * 1e18 / 1e20 = 1e18` and thus `amountIn = 1e18` as well. The total supply increases to `2e20`. - Second minter needs to pay **less** tokens to receive the same amount of `1e18` LP tokens as the first minter. This should never be the case. `toMint = 1e20` => `ratio = 1e20 * 1e18 / 2e20 = 0.5e18`. Then `amountIn = ratio * reserve / 1e18 = 0.5*reserve = 0.5e18`. They only pay half of what the first LP provider had to pay.  ## Impact It's unclear why it's assumed that the pool's tokens are all in equal value - this is _not_ a StableSwap-like pool.  Any pool that uses tokens that don't have the same value and share the same decimals cannot be used because initial liquidity cannot be provided in an economically justifiable way.  It also leads to issues where the second LP supplier has to pay **less tokens** to receive the exact same amount of LP tokens that the initial minter receives. They can steal from the initial LP provider by burning these tokens again.  ## Recommended Mitigation Steps Do not mint the initial token supply to the zero address in the constructor.  Do it like Uniswap/Balancer and let the first liquidity provider provide arbitrary token amounts, then mint the initial pool supply. If `reserve == 0`, `amountIn` should just take the pool balances that were transferred to this account.  In case the initial mint to the zero address in the constructor was done to prevent the \"Uniswap-attack\" where the price of a single wei of LP token can be very high and price out LPs, send a small fraction of this initial LP supply (~1000) to the zero address **after** it was minted to the first supplier in `mint`.   "}, {"title": "Unsafe cast in IndexPool mint leads to attack", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/77", "labels": ["bug", "3 (High Risk)"], "target": "2021-09-sushitrident-findings", "body": "Unsafe cast in IndexPool mint leads to attack"}, {"title": "TridentRouter.isWhiteListed() Misleading name", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/76", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "TridentRouter.isWhiteListed() Misleading name"}, {"title": "`IndexPool.mint` The first liquidity provider is forced to supply assets in the same amount, which may cause a significant amount of fund loss", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/72", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-09-sushitrident-findings", "body": "`IndexPool.mint` The first liquidity provider is forced to supply assets in the same amount, which may cause a significant amount of fund loss"}, {"title": "Router would fail when adding liquidity to index Pool", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/68", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  TridentRouter is easy to fail when trying to provide liquidity to an index pool.  Users would not get extra lp if they are not providing lp at the pool's spot price. It's the same design as uniswap v2. However, uniswap's v2 handle's the dirty part.   [UniswapV2Router02.sol#L61-L76](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76) Users would not lose tokens if they use the router.  However, the router wouldn't stop users from transferring extra tokens. [TridentRouter.sol#L168-L190](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L168-L190)  Second, the price would possibly change when the transaction is confirmed. This would be reverted in the index pool.   Users would either transfer extra tokens or fail. I consider this is a medium-risk issue.   ## Proof of Concept  [TridentRouter.sol#L168-L190](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/TridentRouter.sol#L168-L190)  A possible scenario:  There's a BTC/USD pool. BTC = 50000 USD. 1. A user sends a transaction to transfer 1 BTC and 50000 USD. 2. After the user send a transaction, a random bot buying BTC with USD. 3. The transaction at step 1 is mined. Since the BTC price is not 50000 USD, the transaction fails.   ## Tools Used  None  ## Recommended Mitigation Steps  Please refer to the uniswap v2 router. [UniswapV2Router02.sol#L61-L76](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L61-L76)  The router should calculate the optimal parameters for users.    "}, {"title": "Caching in local variables can save gas ", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Caching in local variables can save gas "}, {"title": "Avoiding initialization of loop index can save a little gas", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Avoiding initialization of loop index can save a little gas"}, {"title": "Use of unchecked can save gas where computation is known to be overflow/underflow safe", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Use of unchecked can save gas where computation is known to be overflow/underflow safe"}, {"title": "Unused code can be removed to save gas", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Unused code can be removed to save gas"}, {"title": "Replace multiple calls with a single new function call", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Replace multiple calls with a single new function call"}, {"title": "Missing contract existence check may cause silent failures of token transfers", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/59", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-findings", "body": "Missing contract existence check may cause silent failures of token transfers"}, {"title": "Allowing direct single-step ownership transfer even as an option is risky", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/58", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Allowing direct single-step ownership transfer even as an option is risky"}, {"title": "Timelock between new owner transfer+claim will reduce risk", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/57", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Timelock between new owner transfer+claim will reduce risk"}, {"title": "Unconditional setting of boolean/address values is risky", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/56", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Unconditional setting of boolean/address values is risky"}, {"title": "Missing timelock for critical contract setters of privileged roles", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Missing timelock for critical contract setters of privileged roles"}, {"title": "Missing zero-address checks", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/52", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Missing zero-address checks"}, {"title": "Use of ecrecover is susceptible to signature malleability", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-09-sushitrident-findings", "body": "Use of ecrecover is susceptible to signature malleability"}, {"title": "Unlocked Solidity compiler pragma is risky", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/49", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-findings", "body": "Unlocked Solidity compiler pragma is risky"}, {"title": "Similarly initialized weight thresholds may cause unexpected deployment failures", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/48", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "Similarly initialized weight thresholds may cause unexpected deployment failures"}, {"title": "Strict bound in reserve check of Hybrid Pool", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/47", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-09-sushitrident-findings", "body": "Strict bound in reserve check of Hybrid Pool"}, {"title": "barFee handled incorrectly in flashSwap (or swap)", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/46", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "barFee handled incorrectly in flashSwap (or swap)"}, {"title": "Missing invalid token check against pool address", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/45", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Missing invalid token check against pool address"}, {"title": "Unused constants could indicate missing logic or redundant code", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/43", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Constants MAX_FEE_SQUARE and E18 are declared but never used. Unused constants could indicate missing logic or redundant code. In this case, they are likely to be redundant code that can be removed.  ## Proof of Concept  https://github.com/sushiswap/trident/blob/504e2e2f3929175eb7adc73844c381d5174e1c03/contracts/pool/ConstantProductPool.sol#L25  https://github.com/sushiswap/trident/blob/504e2e2f3929175eb7adc73844c381d5174e1c03/contracts/pool/ConstantProductPool.sol#L26  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Evaluate the use of the declared constants or remove them.  "}, {"title": "TridentOwnable: pendingOwner should be set to address(1) if direct owner transfer is used", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "TridentOwnable: pendingOwner should be set to address(1) if direct owner transfer is used"}, {"title": "IndexPool: Redundant MAX_WEIGHT", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "IndexPool: Redundant MAX_WEIGHT"}, {"title": "IndexPool:  Poor conversion from Balancer V1's corresponding functions", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/40", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "IndexPool:  Poor conversion from Balancer V1's corresponding functions"}, {"title": "HybridPool: SwapCallback should be done regardless of data.length", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/39", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "HybridPool: SwapCallback should be done regardless of data.length"}, {"title": "ConstantProductPool: Unnecessary mod before casting to uint32", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  Gas optimisation. Casting something of uint256 to uint32 has the same effect as mod since it will wrap around when it overflows. You need to ensure that unchecked math is used otherwise it will revert.  ## Recommended Mitigation Steps  [Line 294 of ConstantProductPool.sol](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/ConstantProductPool.sol#L294)  ```jsx function _update(         uint256 balance0,         uint256 balance1,         uint112 _reserve0,         uint112 _reserve1,         uint32 _blockTimestampLast     ) internal {         require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, \"OVERFLOW\");         if (blockTimestampLast == 0) {             // @dev TWAP support is disabled for gas efficiency.             reserve0 = uint112(balance0);             reserve1 = uint112(balance1);         } else {       unchecked { // changes starts here        uint32 blockTimestamp = uint32(block.timestamp);       } // changes end here             ...         }         emit Sync(balance0, balance1);     } ```  "}, {"title": "ConstantProductPool: Move minting of MIN_LIQUIDITY after checks", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/35", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "# Handle  GreyArt   # Vulnerability details  ### Impact  L102: `_mint(address(0), MINIMUM_LIQUIDITY);` should be shifted after the if / else block to L110 because of further checks done in L106, and L108-L109.  This would help save gas should the checks mentioned fail.  ### Recommended Mitigation Steps  ```jsx if (msg.sender == migrator) {   liquidity = IMigrator(migrator).desiredLiquidity();   require(liquidity != 0 && liquidity != type(uint256).max, \"BAD_DESIRED_LIQUIDITY\"); } else {   require(migrator == address(0), \"ONLY_MIGRATOR\");   liquidity = computed - MINIMUM_LIQUIDITY; } _mint(address(0), MINIMUM_LIQUIDITY); ```  "}, {"title": "ConstantProductPool & HybridPool: Adding and removing unbalanced liquidity yields slightly more tokens than swap", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/34", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  GreyArt   # Vulnerability details  ### Impact  A mint fee is applied whenever unbalanced liquidity is added, because it is akin to swapping the excess token amount for the other token.  However, the current implementation distributes the minted fee to the minter as well (when he should be excluded). It therefore acts as a rebate of sorts.  As a result, it makes adding and removing liquidity as opposed to swapping directly (negligibly) more desirable. An example is given below using the Constant Product Pool to illustrate this point. The Hybrid pool exhibits similar behaviour.  ### Proof of Concept  1. Initialize the pool with ETH-USDC sushi pool amounts. As of the time of writing, there is roughly 53586.556 ETH and 165143020.5295 USDC. 2. Mint unbalanced LP with 5 ETH (& 0 USDC). This gives the user `138573488720892 / 1e18` LP tokens. 3. Burn the minted LP tokens, giving the user 2.4963 ETH and 7692.40 USDC. This is therefore equivalent to swapping 5 - 2.4963 = 2.5037 ETH for 7692.4044 USDC. 4. If the user were to swap the 2.5037 ETH directly, he would receive 7692.369221 (0.03 USDC lesser).  ### Recommended Mitigation Steps  The mint fee should be distributed to existing LPs first, by incrementing `_reserve0` and `_reserve1` with the fee amounts. The rest of the calculations follow after.  ConstantProductPool  ```jsx (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1); // increment reserve amounts with fees _reserve0 += uint112(fee0); _reserve1 += uint112(fee1); unchecked {     _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply); } uint256 computed = TridentMath.sqrt(balance0 * balance1); ... kLast = computed; ```  HybridPool  ```jsx (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1); // increment reserve amounts with fees _reserve0 += uint112(fee0); _reserve1 += uint112(fee1); uint256 newLiq = _computeLiquidity(balance0, balance1); ... ```  "}, {"title": "Consider unlocking pool only upon initial mint", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Consider unlocking pool only upon initial mint"}, {"title": "# Hybrid Pool underflow when a < 100", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/32", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushitrident-findings", "body": "# Hybrid Pool underflow when a < 100"}, {"title": "hybrid pool uses wrong `non_optimal_mint_fee`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/31", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  When an lp provider deposits an imbalance amount of token, a swap fee is applied. HybridPool uses the same `_nonOptimalMintFee` as `constantProductPool`; however, since two pools use different AMM curve, the ideal balance is not the same.  ref: [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337)  Stable swap Pools are designed for 1B+ TVL. Any issue related to pricing/fee is serious. I consider this is a high-risk issue  ## Proof of Concept  [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337)  [HybridPool.sol#L425-L441](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/HybridPool.sol#L425-L441)  ## Tools Used  None  ## Recommended Mitigation Steps Calculate the swapping fee based on the stable swap curve. Please refer to [StableSwap3Pool.vy#L322-L337](https://github.com/curvefi/curve-contract/blob/master/contracts/pools/3pool/StableSwap3Pool.vy#L322-L337).  "}, {"title": "IndexPool's INIT_POOL_SUPPLY is not fair.", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/29", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-09-sushitrident-findings", "body": "IndexPool's INIT_POOL_SUPPLY is not fair."}, {"title": "IndexPool pow overflows when `weightRatio` > 10.", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/28", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  In the IndexPool contract, pow is used in calculating price. [IndexPool.sol#L255-L266](https://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/IndexPool.sol#L255-L266) However, Pow is easy to cause overflow. If the `weightRatio` is large (e.g. 10), there's always overflow.  Lp providers can still provide liquidity to the pool where no one can swap. All pools need to redeploy. I consider this a high-risk issue.   ## Proof of concept  It's easy to trigger this bug by deploying a 1:10 IndexPool.  ```python     deployed_code = encode_abi([\"address[]\",\"uint136[]\",\"uint256\"], [         (link.address, dai.address),         (10**18, 10 * 10**18),         10**13     ])     tx_hash = master_deployer.functions.deployPool(index_pool_factory.address, deployed_code).transact() ```  Transactions would be reverted when buying `link` with `dai`. ## Tools Used  None  ## Recommended Mitigation Steps  The `weightRatio` is an 18 decimals number. It should be divided by `(BASE)^exp`. The scale in the contract is not consistent. Recommend the dev to check all the scales/ decimals.   "}, {"title": "Index Pool always swap to Zero", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/27", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-09-sushitrident-findings", "body": "Index Pool always swap to Zero"}, {"title": "Flash swap call back prior to transferring tokens in indexPool", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/26", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-09-sushitrident-findings", "body": "Flash swap call back prior to transferring tokens in indexPool"}, {"title": "Missing validation of recipient argument could indefinitely lock owner role", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/23", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-findings", "body": "Missing validation of recipient argument could indefinitely lock owner role"}, {"title": "[TridentERC20.sol] Possible replay attacks on `permit` function in case of a future chain split", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/18", "labels": ["bug", "duplicate", "1 (Low Risk)", "disagree with severity"], "target": "2021-09-sushitrident-findings", "body": "[TridentERC20.sol] Possible replay attacks on `permit` function in case of a future chain split"}, {"title": "Use parameter _blockTimestampLast in _update() ", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _update() of ConstantProductPool.sol verifies if blockTimestampLast == 0. The value of blockTimestampLast is also passed in the parameter _blockTimestampLast  (note: with extra _ ) So _blockTimestampLast could also be used, which saves a bit of gas.  ## Proof of Concept https://github.com/sushiswap/trident/blob/master/contracts/pool/ConstantProductPool.sol#L264  function _update(...        uint32 _blockTimestampLast) internal {         ...         if (blockTimestampLast == 0) {    // could also use _blockTimestampLast  ## Tools Used  ## Recommended Mitigation Steps replace    if (blockTimestampLast == 0) {    with    if (_blockTimestampLast == 0) {      "}, {"title": "Reset cachedPool ?", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/15", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-findings", "body": "Reset cachedPool ?"}, {"title": "Safe gas on _powApprox", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-findings", "body": "Safe gas on _powApprox"}, {"title": "HybridPool.sol lacks zero check for maserDeployer", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/10", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-findings", "body": "HybridPool.sol lacks zero check for maserDeployer"}, {"title": "ConstantProductPool lacks zero check for maserDeployer", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/9", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-findings", "body": "ConstantProductPool lacks zero check for maserDeployer"}, {"title": "unchecked use of optional function \"decimals\" of erc20 standards", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/4", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-findings", "body": "unchecked use of optional function \"decimals\" of erc20 standards"}, {"title": "Events not emitted while changing state variables in constructor", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/2", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-sushitrident-findings", "body": "Events not emitted while changing state variables in constructor"}, {"title": "Adding assymetric liquidity in _addLiquidity results in fewer LP tokens minted than what should be wanted", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/158", "labels": ["bug", "2 (Med Risk)"], "target": "2021-09-yaxis-findings", "body": "Adding assymetric liquidity in _addLiquidity results in fewer LP tokens minted than what should be wanted"}, {"title": "getMostPremium() does not necessarily return the best asset to trade for.", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/156", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-09-yaxis-findings", "body": "getMostPremium() does not necessarily return the best asset to trade for."}, {"title": "Be aware that transactions can be frontrun to exactly the estimated amount.", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/153", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-09-yaxis-findings", "body": "Be aware that transactions can be frontrun to exactly the estimated amount."}, {"title": "`harvestNextStrategy` can be optimized", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/146", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "`harvestNextStrategy` can be optimized"}, {"title": "`maxStrategies` can be lower than existing strategies", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/145", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-yaxis-findings", "body": "`maxStrategies` can be lower than existing strategies"}, {"title": "Missing check in `reorderStrategies`", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/144", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Missing check in `reorderStrategies`"}, {"title": "`tokens[i]` can be memorized", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/143", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In `StablesConverter.convert` there are multiple storage reads of `tokens[i]` that add up gas. Consider saving the variable in memory.   ## Tools Used editor  ## Recommended Mitigation Steps Rewrite  ```js IERC20 _token;    // add this for (uint8 i = 0; i < 3; i++) {  _token = tokens[i];  // add this     //if (_output == address(tokens[i])) {     if (_output == address(_token)) {         //uint256 _before = tokens[i].balanceOf(address(this));         uint256 _before = _token.balanceOf(address(this));         stableSwap3Pool.remove_liquidity_one_coin(             _inputAmount,             i,             _estimatedOutput         );         //uint256 _after = tokens[i].balanceOf(address(this));         uint256 _after = _token.balanceOf(address(this));         _outputAmount = _after.sub(_before);         //tokens[i].safeTransfer(msg.sender, _outputAmount);         _token.safeTransfer(msg.sender, _outputAmount);         return _outputAmount;     } } ```  "}, {"title": "Unnecessary `balanceOfWant() > 0`", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact During the `_harvest` function in NativeStrategyCurve3Crv.sol, there's a call to `_deposit()` only `if (balanceOfWant() > 0)`. This if-statement can be removed since `_deposit` calculates again `balanceOfWant()` and makes the same check. This way the function saves a `.balanceOf` call.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L123  ## Tools Used editor  "}, {"title": "Harvest can be frontrun", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/140", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Harvest can be frontrun"}, {"title": "`getMostPremium()` can be wrong", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/139", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed", "disagree with severity"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact `NativeStrategyCurve3Crv._harvest` calls `getMostPremium` to get the best stablecoin to convert to. This function however is wrong in the case of `balancesUSDC = balancesUSDT < balancesDAI`, because it returns DAI, when it should be USDC or USDT. This is naturally a rare occasion, but a bad actor can set the balances (by depositing/withdrawing the Curve pool) like this just before the harvest function is called. Since this would imbalance even more the pool, the bad actor could also gain a profit by making the right swaps after the harvest.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L83  ## Tools Used editor  ## Recommended Mitigation Steps Convert all `<` into `<=` inside `getMostPremium()`.  "}, {"title": "Earn process emits two events that can be arranged into one", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/138", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The harvester can initiate the earn process by calling the `Vault.earn`. At the end of this function an `Earn(_token, _balance)` event is emitted. Before this, the execution is passed to the `Controller.earn` function, which emits another event `Earn(_token, _strategy)`. Since these two events are emitted _always_ together (`Controller.earn` can be called only inside `Vault.earn`), it's more efficient to emit a single event `Earn(_token, _strategy, _amount)` at the end of `Controller.earn`. This should gain a little gas (one less indexed data) and it's less confusing.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L437 https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L157  ## Tools Used editor  "}, {"title": "Unclear `totalDepositCap`", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/135", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Unclear `totalDepositCap`"}, {"title": "`cap` isn't enforced", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/134", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "`cap` isn't enforced"}, {"title": "No slippage checks can lead to sandwich attacks", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/133", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-yaxis-findings", "body": "No slippage checks can lead to sandwich attacks"}, {"title": "`Vault.balance()` mixes normalized and standard amounts", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/132", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "`Vault.balance()` mixes normalized and standard amounts"}, {"title": "`Vault.withdraw` mixes normalized and standard amounts", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/131", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-09-yaxis-findings", "body": "`Vault.withdraw` mixes normalized and standard amounts"}, {"title": "`Controller.inCaseStrategyGetStuck` does not update balance", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/130", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "`Controller.inCaseStrategyGetStuck` does not update balance"}, {"title": "`Controller.setCap` sets wrong vault balance", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/128", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-09-yaxis-findings", "body": "`Controller.setCap` sets wrong vault balance"}, {"title": "VaultHelper deposits don't work with fee-on transfer tokens", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/127", "labels": ["bug", "2 (Med Risk)"], "target": "2021-09-yaxis-findings", "body": "VaultHelper deposits don't work with fee-on transfer tokens"}, {"title": "token -> vault mapping can be overwritten", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/126", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-09-yaxis-findings", "body": "token -> vault mapping can be overwritten"}, {"title": "Gas: Timestamp in router swap can be hardcoded", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  cmichel   # Vulnerability details  When doing swaps with a Uniswap router from within a contract, there's no need to compute any offset from the current block for the `deadline` parameter. The router just checks if `deadline >= block.timestamp`.  See `BaseStrategy._swapTokens` which does an unnecessary `block.timestamp` read and another unnecessary addition of `1800`.  ## Recommended Mitigation Steps The most efficient way to provide deadlines for a router swap is to use a hardcoded value that is far in the future, for example, `1e10`.   "}, {"title": "Gas: Loop in `StablesConverter.expected` can be avoided", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Gas: Loop in `StablesConverter.expected` can be avoided"}, {"title": "Gas: Loop in `StablesConverter.convert` can be avoided", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Gas: Loop in `StablesConverter.convert` can be avoided"}, {"title": "Withdraw event uses wrong parameter", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/122", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Withdraw` event in `LegacyController.withdraw` emits the `_amount` variable which is the _initial, desired_ amount to withdraw. It should emit the actual withdrawn amount instead, which is transferred in the last `token.balanceOf(address(this))` call.  ## Impact The actual withdrawn amount, which can be lower than `_amount`, is part of the event. This is usually not what you want (and it can already be decoded from the function argument).  ## Recommended Mitigation Steps Use it or remove it.   "}, {"title": "`Vault.withdraw` sometimes burns too many shares", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/121", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-09-yaxis-findings", "body": "`Vault.withdraw` sometimes burns too many shares"}, {"title": "Gas: Unnecessary addition in `Vault.deposit`", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/118", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-09-yaxis-findings", "body": "Gas: Unnecessary addition in `Vault.deposit`"}, {"title": "Gas: `removeStrategy` iteration over all strategies can be avoided", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/117", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-09-yaxis-findings", "body": "Gas: `removeStrategy` iteration over all strategies can be avoided"}, {"title": "Gas: `removeToken` iteration over all tokens can be avoided", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/116", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-09-yaxis-findings", "body": "Gas: `removeToken` iteration over all tokens can be avoided"}, {"title": "ERC20 return values not checked", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/114", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-09-yaxis-findings", "body": "ERC20 return values not checked"}, {"title": "`YAxisVotePower.balanceOf` can be manipulated", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/113", "labels": ["bug", "documentation", "2 (Med Risk)"], "target": "2021-09-yaxis-findings", "body": "`YAxisVotePower.balanceOf` can be manipulated"}, {"title": "wrong YAXIS estimates", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/112", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "wrong YAXIS estimates"}, {"title": "Unbounded iterations over strategies or tokens", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/111", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-09-yaxis-findings", "body": "Unbounded iterations over strategies or tokens"}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/107", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "Missing parameter validation"}, {"title": "The `sqrt` function can overflow execute invalid operation", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/104", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "The `sqrt` function can overflow execute invalid operation"}, {"title": "The function `removeToken` can get prohibitively expensive", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-09-yaxis-findings", "body": "The function `removeToken` can get prohibitively expensive"}, {"title": "VaultHelper contract should never have tokens at the end of a transaction", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/100", "labels": ["bug", "documentation", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "VaultHelper contract should never have tokens at the end of a transaction"}, {"title": "Safety of the Vyper compiler", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/99", "labels": ["bug", "sponsor acknowledged", "disagree with severity", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "Safety of the Vyper compiler"}, {"title": "Upgrade to at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/98", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2021-09-yaxis-findings", "body": "Upgrade to at least 0.8.4"}, {"title": "Caching the length in for loops", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Caching the length in for loops"}, {"title": "Consider making some constants as non-public to save gas", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Each function part of contract's external interface is part of the function dispatch, i.e., every time a contract is called, it goes through a switch statement (a set of eq ... JUMPI blocks in EVM) matching the selector of each externally available functions with the chosen function selector (the first 4 bytes of calldata). This means that any unnecessary function that is part of contract's external interface will lead to more gas for (almost) every single function calls to the contract. There are several cases where constants were made public. This is unnecessary; the constants can simply be readfrom the verified contract, i.e., it is unnecessary to expose it with a public function.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L53-L55  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManager.sol#L35-L39   Example: ``` uint256 public constant BOOTSTRAP_PERIOD = 14 days; ``` ## Tools Used Remix ## Recommended Mitigation Steps  "}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/93", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "Style issues"}, {"title": "Join _checkToken function and modifier together", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _checkToken can be moved to modifier checkToken as it is a private function that is only used by this modifier. This will reduce the number of extra calls and thus reduce the gas.  ## Recommended Mitigation Steps Consider moving this function inside the modifier to reduce gas usage.  "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/89", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "Unused imports"}, {"title": "Dead code", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-09-yaxis-findings", "body": "Dead code"}, {"title": "uint8 is less efficient than uint256 in loop iterations", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/86", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "uint8 is less efficient than uint256 in loop iterations"}, {"title": "VaultHelper could validate that amount is greater than 0", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact functions depositVault, depositMultipleVault and withdrawVault in VaultHelper could require _amount > 0 to prevent useless transfers.  ## Recommended Mitigation Steps Add require _amount > 0 statements to mentioned functions.  "}, {"title": "Decimals of upgradeable tokens may change", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact A theoretical issue is that the decimals of USDC may change as they use an upgradeable contract so you cannot assume that it stays 6 decimals forever:   balances[1] = stableSwap3Pool.balances(1).mul(10**12); // USDC  ## Recommended Mitigation Steps A simple solution would be to call .decimals() on token contract to query it on the go. Then you will not need to hardcode it but gas usage will increase.  "}, {"title": "setMinter should check that _minter is not empty", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/81", "labels": ["bug", "sponsor acknowledged", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function setMinter should validate that _minter is not an empty (0x0) address.  ## Recommended Mitigation Steps require(_minter != address(0), \"!_minter\");  "}, {"title": "Inclusive check in setSlippage", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/78", "labels": ["bug", "invalid"], "target": "2021-09-yaxis-findings", "body": "Inclusive check in setSlippage"}, {"title": "An attacker can steal funds from multi-token vaults", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/77", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "An attacker can steal funds from multi-token vaults"}, {"title": "Vault: Zero Withdrawal Fee If Protocol Halts", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/75", "labels": ["bug", "1 (Low Risk)"], "target": "2021-09-yaxis-findings", "body": "Vault: Zero Withdrawal Fee If Protocol Halts"}, {"title": "Vault: Withdrawals can be frontrun to cause users to burn tokens without receiving funds in return", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/74", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Vault: Withdrawals can be frontrun to cause users to burn tokens without receiving funds in return"}, {"title": "Vault: Swaps at parity with swap fee = withdrawal fee", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/71", "labels": ["bug", "2 (Med Risk)"], "target": "2021-09-yaxis-findings", "body": "Vault: Swaps at parity with swap fee = withdrawal fee"}, {"title": "Vault: Redundant notHalted modifier in depositMultiple()", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `notHalted` modifier in `depositMultiple()` is redundant because it is checked (multiple times) by the underlying function call to `deposit()`.  Further optimizations may be done to implement an internal `_deposit()` function that will be called by both `deposit()` and `depositMultiple()` so that `notHalted` is only checked once.  ### Recommended Mitigation Steps  Remove the `notHalted` modifier in `depositMultiple()`.  "}, {"title": "Removed tokens can't be withdrawn from vault", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/69", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Removed tokens can't be withdrawn from vault"}, {"title": "Harvester: Simpler implementation for canHarvest()", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Recommended Mitigation Steps  The negation of the disjunction form of the `canHarvest()` function will help save gas. In other words, instead of `!(A || B)`, return `(!A && !B)`.  ```jsx function canHarvest(  address _vault )   public   view   returns (bool) {   Strategy storage strategy = strategies[_vault];   // only can harvest if there are strategies, and when sufficient time has elapsed   // solhint-disable-next-line not-rely-on-time  return (strategy.addresses.length > 0 && strategy.lastCalled <= block.timestamp.sub(strategy.timeout)); } ```  "}, {"title": "Controller: Extra sload of _vaultDetails[_vault].balance", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `_vaultDetails[_vault].balance` in L367 can be changed to the already fetched value `_balance`.  ### Recommended Mitigation Steps  `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_amount);`  "}, {"title": "Max approvals are risky if contract is malicious/compromised", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/64", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Max approvals are risky if contract is malicious/compromised"}, {"title": "safeApprove may revert for non-zero to non-zero approvals", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/63", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact\u2028 OpenZeppelin\u2019s safeApprove reverts for non-0 to non-0 approvals. This is considered in a few places where safeApprove is performed twice with the first one for 0 and then for the desired allowance. However, there are uses of safeApprove where it is called only once for the desired allowance but it is not clear that the current allowance is guaranteed to be zero. In such cases, safeApprove may revert.  ## Proof of Concept  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6241995ad323952e38f8d405103ed994a2dcde8e/contracts/token/ERC20/utils/SafeERC20.sol#L49-L55  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/converters/StablesConverter.sol#L78  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/strategies/BaseStrategy.sol#L88  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Approve to 0 first while using safeApprove or use increaseAllowance instead.  "}, {"title": "Missing support/documentation for use of deflationary tokens in protocol", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/62", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-yaxis-findings", "body": "Missing support/documentation for use of deflationary tokens in protocol"}, {"title": "onlyEnabledConverter modifier is not used in all functions", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/60", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "onlyEnabledConverter modifier is not used in all functions"}, {"title": "Removing unused parameter and modifier can save gas", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Removing unused parameter and modifier can save gas"}, {"title": "No use of notHalted in LegacyController functions", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/57", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "No use of notHalted in LegacyController functions"}, {"title": "Change public visibility to external", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/55", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "Change public visibility to external"}, {"title": "manager.allowedVaults check missing for add/remove strategy", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact The manager.allowedVaults check is missing for add/remove strategy like how it is used in reorderStrategies(). This will allow a strategist to accidentally/maliciously add/remove strategies on unauthorized vaults.  Given the critical access control that is missing on vaults here, this is classified as medium severity.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L101-L130  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L172-L207  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L224  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L210-L221   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add manager.allowedVaults check in addStrategy() and removeStrategy()  "}, {"title": "Unused event may be unused code or indicative of missed emit/logic", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/49", "labels": ["bug", "sponsor acknowledged", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "Unused event may be unused code or indicative of missed emit/logic"}, {"title": "Halting the protocol should be onlyGovernance and not onlyStrategist", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Halting the protocol should be onlyGovernance and not onlyStrategist"}, {"title": "Removal of last token in the array can be optimized", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Removal of last token in the array can be optimized"}, {"title": "Single-step change of governance address is extremely risky", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/44", "labels": ["bug", "duplicate", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "Single-step change of governance address is extremely risky"}, {"title": "Rearranging declaration of state variables will save storage slots because of packing", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Storage slots are allocated based on the declaration order of state variables in contract definitions. For types less than 256 bits, they can be packed by the compiler if more than one fit into the same 32B storage slot. This reduces the number of storage slots but may increase runtime gas consumption because of masking the other shared variables in slot. However, if variables used together in function logic are packed in the same slot, it allows the compiler to optimize SLOADs/SSTOREs.  Example: An example of this is the declaration of the halted boolean state variable. Given the current declaration order, this occupies a full slot because booleans are internally represented by uint8 and the neighbouring declarations are uint256 which need a full slot for themselves.  Moving the halted bool next to governance address variable declaration will allow those two to share a slot. This reduces one slot and also should not incur extra masking gas overhead at runtime because governor and halted are used in onlyGovernance and notHalted modifiers respectively which are typically used together.  ## Proof of Concept  https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L33-L49   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move halted declaration to immediately after governance declaration. Also, consider the declaration order of all state variables across contracts for such packing possibilities.  "}, {"title": "Tokens with > 18 decimals will break logic", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/42", "labels": ["bug", "duplicate", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "Tokens with > 18 decimals will break logic"}, {"title": "Missing sanity/threshold check on totalDepositCap may cause DoS", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/38", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Missing sanity/threshold check on totalDepositCap may cause DoS"}, {"title": "Missing zero-address checks", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Missing zero-address checks"}, {"title": "Checking for zero amounts can save gas by preventing expensive external calls", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Checking for zero amounts can save gas by preventing expensive external calls"}, {"title": "Controller does not raise an error when there's insufficient liquidity", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/28", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Controller does not raise an error when there's insufficient liquidity"}, {"title": "hijack the vault by pumping vault price.", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/26", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "hijack the vault by pumping vault price."}, {"title": "vault cap's at totalSupply would behave unexpectedly", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/25", "labels": ["bug", "1 (Low Risk)"], "target": "2021-09-yaxis-findings", "body": "vault cap's at totalSupply would behave unexpectedly"}, {"title": "missing safety check in addStrategy", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/23", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact There's no safety check in controller's `addStrategy`. When the same strategy is added to a vault twice, the protocol breakdowns in several ways.   1. Removing that strategy would always raise errors. 2. `_vaultDetails[_vault].balances[_strategy]` would not track strategy's balance correctly; `getBestStrategyWithdraw` would have a wrong answer and makes withdrawing from the strategy to raise error in certain scenarios.  I consider this a low-risk issue.  ## Proof of Concept This is the web3.py script: ```python controller.functions.addStrategy(vault.address, strategy.address, cap, 0).transact() controller.functions.addStrategy(vault.address, strategy.address, cap, 0).transact()  # would not be able to removestrategy controller.functions.removeStrategy(vault.address, strategy.address, 0).transact() ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps  The controller should raise an error if the strategy has been added to the protocol(any vault). As adding the same strategy to two different vaults would have worse results, the controller can maintain a map to record each strategy's status.  "}, {"title": "extra array length check in depositMultipleVault ", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function depositMultipleVault of VaultHelper doesn't check the array size of _tokens and _amounts are the same length. In previous version of solidity there were bugs with giving an enormous large array to a function which accepted memory arrays.  Although depositMultipleVault uses calldata arrays, it is probably better to add a check on the length.  On the other hand the function depositMultiple of Vault.sol does check it.  ## Proof of Concept https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/VaultHelper.sol#L57 ```JS  function depositMultipleVault(         address _vault,         address[] calldata _tokens,         uint256[] calldata _amounts     )  external {         for (uint8 i = 0; i < _amounts.length; i++) {         ... ```  https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L188 ```JS  function depositMultiple(         address[] calldata _tokens,         uint256[] calldata _amounts     )  external override notHalted returns (uint256 _shares) {         require(_tokens.length == _amounts.length, \"!length\");          for (uint8 i; i < _amounts.length; i++) {            ...  ```   ## Tools Used  ## Recommended Mitigation Steps Add something like the following in depositMultipleVault:    require(_tokens.length == _amounts.length, \"!length\");  "}, {"title": "Save a step in withdraw of Vault.sol", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Save a step in withdraw of Vault.sol"}, {"title": "shadowing of strategies", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/17", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-09-yaxis-findings", "body": "shadowing of strategies"}, {"title": "Harvesting and Funding Is Not Checked When the Contract Is Halted", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/10", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that harvesting and fundings progress is not checked when the contract is halted. This can cause misfunctionality and locking user funds during the halt progress.  ## Proof of Concept  1-) Navigate to \"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol\" contract. 2-) Observe the following code on the Controller.sol.  Functions earn and HarvestStrategy ```     function harvestStrategy(address _strategy,uint256 _estimatedWETH,uint256 _estimatedYAXIS)         external         override         onlyHarvester         onlyStrategy(_strategy)              function earn(         address _strategy,         address _token,         uint256 _amount     )         external         override         onlyStrategy(_strategy)         onlyVault(_token)  ```  ## Tools Used  None   ## Recommended Mitigation Steps  Implement the notHalt modifier into the functions. Only withdraw functions should be allowed on the contract.   "}, {"title": "earn results in decreasing share price", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/9", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "earn results in decreasing share price"}, {"title": " # Controller is vulnerable to sandwich attack", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/7", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": " # Controller is vulnerable to sandwich attack"}, {"title": "removeToken would break the vault/protocol.", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/4", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## removeToken would break the vault.   ## Impact There's no safety check in Manager.sol's removeToken. [Manager.sol#L454-L487](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Manager.sol#L454-L487) 1. The token would be locked in the original vault. Given the current design, the vault would keep a ratio of total amount to save the gas. Once the token is removed at manager contract, these token would lost. 2. Controller's balanceOf would no longer reflects the real value. [Controller.sol#L488-L495](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L488-L495) While `_vaultDetails[msg.sender].balance;` remains the same, user can nolonger withdraw those amount. 3. Share price in the vault would decrease drastically. The share price is calculated as `totalValue / totalSupply` [Vault.sol#L217](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L217). While the `totalSupply` of the share remains the same, the total balance has drastically decreased.  Calling removeToken way would almost break the whole protocol if the vault has already started. I consider this is a high-risk issue.   ## Proof of Concept  We can see how the vault would be affected with below web3.py script. ```python print(vault.functions.balanceOfThis().call()) print(vault.functions.totalSupply().call()) manager.functions.removeToken(vault.address, dai.address).transact() print(vault.functions.balanceOfThis().call()) print(vault.functions.totalSupply().call()) ```  output ``` 100000000000000000000000 100000000000000000000000 0 100000000000000000000000 ``` ## Tools Used Hardhat  ## Recommended Mitigation Steps Remove tokens from a vault would be a really critical job. I recommend the team cover all possible cases and check all components' states (all vault/ strategy/ controller's state) in the test.   Some steps that I try to come up with that is required to remove TokenA from a vault.  1. Withdraw all tokenA from all strategies (and handle it correctly in the controller).  2. Withdraw all tokenA from the vault.  3. Convert all tokenA that's collected in the previous step into tokenB.  4. Transfer tokenB to the vault and compensate the transaction fee/slippage cost to the vault.    "}, {"title": "No safety check in addToken", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/3", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact There's no safety check in `Manager.sol` `addToken`. There are two possible cases that might happen. 1. One token being added twice in a Vault. Token would be counted doubly in the vault. Ref: [Vault.sol#L293-L303](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L293-L303). There would be two item in the array when querying `manager.getTokens(address(this));`.  2. A token first being added to two vaults. The value calculation of the first vault would be broken. As `vaults[_token] = _vault;` would point to the other vault.  Permission keys should always be treated cautiously. However, calling the same initialize function twice should not be able to destroy the vault. Also, as the protocol develops, there's likely that one token is supported in two vaults. The DAO may mistakenly add the same token twice. I consider this a high-risk issue.   ## Proof of Concept Adding same token twice would not raise any error here. ``` manager.functions.addToken(vault.address, dai.address).transact() manager.functions.addToken(vault.address, dai.address).transact() ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps I recommend to add two checks ```solidity require(vaults[_token] == address(0)); bool notFound = True; for(uint256 i; i < tokens[_vault].length; i++) {     if (tokens[_vault] == _token) {         notFound = False;     } } require(notFound, \"duplicate token\"); ```  "}, {"title": "Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities.", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/2", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-09-yaxis-findings", "body": "Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities."}, {"title": " set cap breaks vault's Balance", "html_url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/1", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-yaxis-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact In controller.sol's function `setCap`, the contract wrongly handles `_vaultDetails[_vault].balance`. While the balance should be decreased by the difference of strategies balance, it subtracts the remaining balance of the strategy. [Controller.sol#L262-L278](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278)  `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);`  This would result in `vaultDetails[_vault].balance` being far smaller than the strategy's value. A user would trigger the assertion at [Contreller.sol#475](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L475) and the fund would be locked in the strategy.  Though `setCap` is a permission function that only the operator can call, it's likely to be called and the fund would be locked in the contract. I consider this a high severity issue.  ## Proof of Concept We can trigger the issue by setting the cap 1 wei smaller than the strategy's balance.   ```python strategy_balance = strategy.functions.balanceOf().call() controller.functions.setCap(vault.address, strategy.address, strategy_balance - 1, dai.address).transact()  ## this would be reverted vault.functions.withdrawAll(dai.address).transact() ```   [Controller.sol#L262-L278](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278)  ## Tools Used Hardhat  ## Recommended Mitigation Steps  I believe the dev would spot the issue in the test if `_vaultDetails[_vault].balance` is a public variable.  One possile fix is to subtract the difference of the balance. ```solidity uint previousBalance = IStrategy(_strategy).balanceOf(); _vaultDetails[_vault].balance.sub(previousBalance.sub(_amount)); ```   "}, {"title": "add zero address validation in constructor and initializer", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "add zero address validation in constructor and initializer"}, {"title": "lack of emission of events while setting fees ", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact setWithdrawalFee(), setPerformanceFeeStrategist()  has no event, so it is difficult to track off-chain changes in the fee   ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/deps/BaseStrategy.sol#L126  ## Tools Used manual review  ## Recommended Mitigation Steps add event to above function  "}, {"title": "state variable that are not changed throughout the contract should be declared as constant", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "state variable that are not changed throughout the contract should be declared as constant"}, {"title": "use of floating pragma", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/58", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-bvecvx-findings", "body": "use of floating pragma"}, {"title": "Missing slippage/min-return check in `veCVXStrategy`", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/57", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Missing slippage/min-return check in `veCVXStrategy`"}, {"title": "Missing slippage/min-return check in `StrategyCvxHelper`", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/56", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Missing slippage/min-return check in `StrategyCvxHelper`"}, {"title": "Missing slippage/min-return check in `BaseStrategy`", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Missing slippage/min-return check in `BaseStrategy`"}, {"title": "Unbounded iteration in `CvxLocker.updateReward`", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Unbounded iteration in `CvxLocker.updateReward`"}, {"title": "`CvxLocker.findEpochId` stops after 128 iterations", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/53", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "`CvxLocker.findEpochId` stops after 128 iterations"}, {"title": "`CvxLocker.setApprovals` can be called by anyone", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/52", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "`CvxLocker.setApprovals` can be called by anyone"}, {"title": "`CvxLocker.setBoost` wrong validation", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CvxLocker.setBoost` function does not validate the `_max, _rate` parameters, instead it validates the already set **storage** variables.  ```solidity // @audit this is checking the already-set storage variables, not the parameters require(maximumBoostPayment < 1500, \"over max payment\"); //max 15% require(boostRate < 30000, \"over max rate\"); //max 3x ```  ## Impact Once wrong boost values are set (which are not validated when they are set), they cannot be set to new values anymore, breaking core contract functionality.  ## Recommended Mitigation Steps Implement these two checks instead:  ```solidity require(_max < 1500, \"over max payment\"); //max 15% require(_rate < 30000, \"over max rate\"); //max 3x ```   "}, {"title": "`CvxLocker.setStakeLimits` missing validation", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `CvxLocker.setStakeLimits` function does not check `_minimum <= _maximum`.  ## Recommended Mitigation Steps Implement these two checks instead:  ```solidity require(_minimum <= _maximum, \"min range\"); require(_maximum <= denominator, \"max range\"); ```  "}, {"title": "`SettV3.transferFrom` block lock can be circumvented", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/49", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "`SettV3.transferFrom` block lock can be circumvented"}, {"title": "`veCVXStrategy.manualRebalance` has wrong logic", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/47", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `veCVXStrategy.manualRebalance` function computes two ratios `currentLockRatio` and `newLockRatio` and compares them.  However, these ratios compute different things and are not comparable: - `currentLockRatio = balanceInLock.mul(10**18).div(totalCVXBalance)` is a **percentage value** with 18 decimals (i.e. `1e18 = 100%`). Its max value can at most be `1e18`. - `newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS)` is a **CVX token amount**. It's unbounded and just depends on the `totalCVXBalance` amount.  The comparison that follows does not make sense:  ```solidity if (newLockRatio <= currentLockRatio) {   // ... } ```  ## Impact The rebalancing is broken and does not correctly rebalance. It usually leads to locking nearly everything if `totalCVXBalance` is high.  ## Recommended Mitigation Steps Judging from the `cvxToLock = newLockRatio.sub(currentLockRatio)` it seems the desired computation is that the \"ratios\" should actually be in CVX amounts and not in percentages. Therefore, `currentLockRatio` should just be `balanceInLock`. (The variables should be renamed as they aren't really ratios but absolute CVX balance amounts.)   "}, {"title": "Gas: `_onlyNotProtectedTokens` should use maps", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Gas: `_onlyNotProtectedTokens` should use maps"}, {"title": "Unused event `veCVXStrategy.TreeDistribution`", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/44", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Unused event `veCVXStrategy.TreeDistribution`"}, {"title": "Unused event `veCVXStrategy.Debug`", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/43", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `Debug` event in `veCVXStrategy` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  "}, {"title": "Unused event `StrategyCvxHelper.TendState`", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TendState` event in `StrategyCvxHelper` is not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.   "}, {"title": "Unused event `StrategyCvxHelper.HarvestState`", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/41", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "Unused event `StrategyCvxHelper.HarvestState`"}, {"title": "veCVXStrategy: Unused return outputs from _processRewardsFees()", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "veCVXStrategy: Unused return outputs from _processRewardsFees()"}, {"title": "veCVXStrategy: Sub-optimal trading path", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/38", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  `_swapcvxCRVToWant()` swaps `cvxCRV -> ETH -> CVX` via sushiswap.  Looking at sushiswap analytics, this may also not be the most optimal trading path. The cvxCRV-CRV pool seems to have substantially better liquidity than the cvxCRV-ETH pool as r[eported here](https://www.notion.so/6a2dc64a1969e19c23e4f579f9810aa7) (Note that cvxCRV-CRV's liquidity is overstated, [clicking into the pool](https://www.notion.so/a2a8a54062e021873bcaee006cdf4007) gives a more reasonable amount). It is therefore better to do `cvxCRV -> CRV -> ETH -> CVX`, though this comes at the cost of higher gas usage.  ### Recommended Mitigation Steps  Switch the trading path to `cvxCRV -> CRV -> ETH -> CVX`, as it means more CVX tokens received, translating to higher APY, while the higher gas cost is borne by the caller.  Additionally, given how liquidity can shift between pools over time, the most optimal trade path may change accordingly. Hence, it may be beneficial to make the pool path configurable.  "}, {"title": "veCVXStrategy: Redundancies", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "veCVXStrategy: Redundancies"}, {"title": "veCVXStrategy: Extra functions can be external instead of public", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The `setWithdrawalSafetyCheck()`, `setHarvestOnRebalance()`, `setProcessLocksOnReinvest()` and `setProcessLocksOnRebalance()` functions are unused internally but have `public` visibility. Their visibility can be changed to `external`.  "}, {"title": "veCVXStrategy: Erroneous Comments", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  - L211: `// We receive bCVX -> Convert to bCVX` \u2192 `We receive bCVX -> Convert to CVX` - L443: `/// @notice toLock = 100, lock everything (CVX) you have` \u2192 `/// @notice toLock = MAX_BPS, lock everything (CVX) you have` since MAX_BPS (10_000) is the base used  "}, {"title": "Swap conversion is susceptible to MEV flashbots", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/34", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Swap conversion is susceptible to MEV flashbots"}, {"title": "StrategyCvxHelper: safeApprove instead of approve", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  This was probably an oversight since  - the veCVXStrategy contract used `safeApprove()` for token approvals - `using SafeERC20Upgradeable for IERC20Upgradeable;` was declared  ### Recommended Mitigation Steps  Change  `cvxToken.approve(address(cvxRewardsPool), MAX_UINT_256);`  to  `cvxToken.safeApprove(address(cvxRewardsPool), MAX_UINT_256);`  "}, {"title": "StrategyCvxHelper: Redundant re-initialisation of path array", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "StrategyCvxHelper: Redundant re-initialisation of path array"}, {"title": "Delete function setKeepReward", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact even the comment says it, delete to save some gas:     /// @notice Delete if you don't need!     function setKeepReward(uint256 _setKeepReward) external {         _onlyGovernance();     }   "}, {"title": "Calculation of valueInLocker", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Calculation of valueInLocker"}, {"title": "public functions that can be external", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact functions setWithdrawalSafetyCheck, setHarvestOnRebalance, setProcessLocksOnReinvest, and setProcessLocksOnRebalance are public but can be external as they are only supposed to be invoked from the outside.   "}, {"title": "lpComponent is useless", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "lpComponent is useless"}, {"title": "tend() can be simplified", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact because function tend() always reverts, you can remove authorization checks and modifiers to save some gas.   "}, {"title": "Immutable variables", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are variables that do not change so they can be marked as immutable to greatly improve the gast costs. Examples of such variables are: Limbo.sol ```solidity   FlanLike Flan; ``` TokenProxyLike.sol ```solidity   address internal baseToken; ``` ProposalFactory.sol ```solidity   string public description;   LimboDAOLike DAO; ``` Please review all the state variables and apply immutable where possible.  "}, {"title": "Use cached _ethBalance", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Use cached _ethBalance"}, {"title": "_processPerformanceFees is useless now", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _processPerformanceFees is not used. functions _processPerformanceFees and _processRewardsFees are way too similar. _processPerformanceFees can be eliminated and _processRewardsFees used by passing want as a _token parameter.  "}, {"title": "Frontrunning distribute functions", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/22", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Frontrunning distribute functions"}, {"title": "events in BaseStrategy are never emitted", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/21", "labels": ["bug", "0 (Non-critical)"], "target": "2021-09-bvecvx-findings", "body": "events in BaseStrategy are never emitted"}, {"title": "Order of parameters in KickReward event", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/20", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Order of parameters in KickReward event"}, {"title": "Validations", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/19", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Validations"}, {"title": "Functions not returning declared values", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function withdrawAll in BaseStrategy declares 'returns (uint256 balance)', however, no actual value is returned. function reinvest in MyStrategy declares to return 'uint256 reinvested', however, it also actually does not return anything so they always get assigned a default value of 0.  ## Recommended Mitigation Steps Either remove the return declarations or return the intended values. Otherwise, it may confuse other protocols that later may want to integrate with you.  "}, {"title": "The comments incorrectly indicate the range in which `toLock` input should be given.", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/15", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  The input `toLock` in the `manualRebalance` function should in terms of BPS else `toLock` should be changed accordingly in the function. The comments incorrectly indicate the range in which the input `toLock` should be given. https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L443  ## Recommended Mitigation Steps In the comments `toLock` should be = 10_000 as we are comparing with `MAX_BPS` https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L446  "}, {"title": "Declare CvxLocker erc20 contract variables as immutable", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  patitonar   # Vulnerability details  ## Impact Gas optimization to store variables as immutable instead of storage similar to `_decimals`  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/locker/CvxLocker.sol#L112-L114  ## Tools Used Manual review  ## Recommended Mitigation Steps Declare as following: string private immutable _name; string private immutable _symbol;   "}, {"title": "Make variable veCVXStrategy::MAX_BPS constant", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `MAX_BPS` in the veCVXStrategy is never reset after initialization. Declaring it as a constant saves gas.  ## Tools Used slither  "}, {"title": "Faulty return value in veCVXStrategy::reinvest()", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/12", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact The function `reinvest` in the veCVXStrategy always returns 0 as the return variable `reinvested` is never updated.  The function is `onlyGovernance` and the return value probably does not matter if the caller is a multi-sig. However, if a protocol is set as `onlyGovernance` the faulty return value would have to be ignored by the caller to not transition into an incorrect state.  ## Proof of Concept The variable `reinvested` is declared as return variable (line 400) but not updated to reflect the actual amount reinvested which is saved in variable `toDeposit`.  Therefore always the default value is returned (0).  Link: https://github.com/code-423n4/2021-09-bvecvx/blob/32ecfd005d421f29c3846f4609fec33eaad388b9/veCVX/contracts/veCVXStrategy.sol#L400  ## Recommended Mitigation Steps  Add `reinvested = toDeposit;` after line 412.  "}, {"title": "Reentrancy on distributeOther()", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/9", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Reentrancy on distributeOther()"}, {"title": "Refactor code to use calculations at current epoch", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Refactor code to use calculations at current epoch"}, {"title": "Gas optimization: no need for extra variable declaration", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-bvecvx-findings", "body": "Gas optimization: no need for extra variable declaration"}, {"title": "toLock in the comments is a % while in the code it is measured in bips.", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/6", "labels": ["bug", "0 (Non-critical)"], "target": "2021-09-bvecvx-findings", "body": "toLock in the comments is a % while in the code it is measured in bips."}, {"title": "ManualRebalance will be frontrun for most of the tokens.", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/5", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact We have previously seen that the harvest function can be exploited for almost all the tokens at stake. Since ManualRebalance calls harvest, it is also unsafe and funds swapped using it will likely be lost.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L444-L453  ## Recommended Mitigation Steps Adding an amount out minimum here will work that should be passed on to the harvest method.  "}, {"title": "Don't include unused functions", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/4", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact The code includes unused functions, like tend(), L319. It's best practice to remove these. It will also save gas.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L319  ## Recommended Mitigation Steps Remove the unused function.  "}, {"title": "setKeepReward function is unfinished", "html_url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/1", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-bvecvx-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact The setKeepReward function is unfinished.  ## Proof of Concept https://github.com/code-423n4/2021-09-bvecvx/blob/1d64bd58c7a4224cc330cef283561e90ae6a3cf5/veCVX/contracts/veCVXStrategy.sol#L203  ## Recommended Mitigation Steps Either complete the function or follow the comment above the code and remove it.  "}, {"title": "Race condition on ERC20 approval", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/120", "labels": ["bug", "1 (Low Risk)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L112-L116  ```solidity=112   function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool) {     _approve(msg.sender, spender, value);      return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);   } ```  ```solidity=208 function _transfer(address sender, address recipient, uint256 amount) internal virtual {     require(sender != address(0), \"ERC20: transfer from the zero address\");     require(recipient != address(0), \"ERC20: transfer to the zero address\");      _beforeTokenTransfer(sender, recipient, amount);      _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");     _balances[recipient] = _balances[recipient].add(amount);     emit Transfer(sender, recipient, amount); } ```  Using approve() to manage allowances opens yourself and users of the token up to frontrunning. Best practice, but doesn't usually matter.  [Explanation](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit) of this possible attack vector  See also: [0xProject/0x-monorepo#850](https://github.com/0xProject/0x-monorepo/issues/850)  Using increase/decreaseAllowance instead is recommended.  "}, {"title": "Add nonReentrant modifiers to uniswap position methods + Check effects pattern", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/118", "labels": ["bug", "0 (Non-critical)", "disagree-with-severity", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Add nonReentrant modifiers to uniswap position methods + Check effects pattern"}, {"title": "Oracle should call latestRoundData instead.", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/116", "labels": ["bug", "1 (Low Risk)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Oracle should call latestRoundData instead."}, {"title": "Improper File Imports", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/115", "labels": ["bug", "0 (Non-critical)", "sponsor-disputed"], "target": "2021-09-wildcredit-findings", "body": "Improper File Imports"}, {"title": "Lack of check for address(0) in `LendingPair.depositUniPosition`", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/112", "labels": ["bug", "0 (Non-critical)", "disagree-with-severity", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Lack of check for address(0) in `LendingPair.depositUniPosition`"}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/108", "labels": ["bug", "0 (Non-critical)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Style issues"}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Unused imports"}, {"title": "Ensure targetUtilization > 0", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/105", "labels": ["bug", "0 (Non-critical)", "disagree-with-severity", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Ensure targetUtilization > 0"}, {"title": "Only accept ETH from WETH contract", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/103", "labels": ["bug", "0 (Non-critical)", "disagree-with-severity", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Only accept ETH from WETH contract"}, {"title": "Oracle response assumes 8 decimals", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/101", "labels": ["bug", "1 (Low Risk)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Oracle response assumes 8 decimals"}, {"title": "Emit events when setting the initial values in the constructor", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/100", "labels": ["bug", "0 (Non-critical)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Emit events when setting the initial values in the constructor"}, {"title": "Reordering state variable declarations to prevent incorrect packing can save slots/gas", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Reordering state variable declarations to prevent incorrect packing can save slots/gas"}, {"title": "Avoiding unnecessary SSTORE can save gas", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Avoiding unnecessary SSTORE can save gas"}, {"title": "Using msg.sender or cached locals in emits instead of state variables saves gas", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Using msg.sender or cached locals in emits instead of state variables saves gas"}, {"title": "Unused parameter removal can save gas", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Unused parameter removal can save gas"}, {"title": "`setTargetUtilization()` Misleading error message", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/86", "labels": ["bug", "0 (Non-critical)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "`setTargetUtilization()` Misleading error message"}, {"title": "Moving checks before other logic can save gas", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Moving checks before other logic can save gas"}, {"title": "Use unchecked{} primitive to save gas where possible", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Use unchecked{} primitive to save gas where possible"}, {"title": "Input validation on amount > 0 will save gas", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Input validation on amount > 0 will save gas"}, {"title": " Input validation on positionID not being 0 will save gas", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": " Input validation on positionID not being 0 will save gas"}, {"title": "Redundant zero-address checks", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Redundant zero-address checks"}, {"title": "Caching state variables in local/memory variables avoids SLOADs to save gas", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Caching state variables in local/memory variables avoids SLOADs to save gas"}, {"title": "Clone-and-own approach used for OZ libraries is susceptible to errors and missing upstream bug fixes", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/77", "labels": ["bug", "0 (Non-critical)", "sponsor-disputed"], "target": "2021-09-wildcredit-findings", "body": "Clone-and-own approach used for OZ libraries is susceptible to errors and missing upstream bug fixes"}, {"title": "Lack of guarded launch approach may be risky", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "sponsor-disputed"], "target": "2021-09-wildcredit-findings", "body": "Lack of guarded launch approach may be risky"}, {"title": "Missing event for this critical onlyOperator function where the operator can arbitrarily change name+symbol", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/74", "labels": ["bug", "0 (Non-critical)", "disagree-with-severity", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Missing event for this critical onlyOperator function where the operator can arbitrarily change name+symbol"}, {"title": "Cache and check decimals before write storage can save gas", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Cache and check decimals before write storage can save gas"}, {"title": "Renouncing ownership is not allowed", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "disagree-with-severity", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Renouncing ownership is not allowed"}, {"title": "Use of tokenB\u2019s price instead of tokenA in determining account health will lead to protocol mis-accounting and insolvency", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/70", "labels": ["bug", "3 (High Risk)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Use of tokenB\u2019s price instead of tokenA in determining account health will lead to protocol mis-accounting and insolvency"}, {"title": "Using a zero-address check as a proxy for enforcing one-time initialization is risky", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "sponsor-disputed"], "target": "2021-09-wildcredit-findings", "body": "Using a zero-address check as a proxy for enforcing one-time initialization is risky"}, {"title": "UniV3Helper: Function visibilities can be restricted to pure", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "UniV3Helper: Function visibilities can be restricted to pure"}, {"title": "Remove pair-specific parameters until they are actually used/enforced", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/65", "labels": ["bug", "0 (Non-critical)", "sponsor-disputed", "disagree-with-severity"], "target": "2021-09-wildcredit-findings", "body": "Remove pair-specific parameters until they are actually used/enforced"}, {"title": "UniswapV3Helper: Redundant pool initialization", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "UniswapV3Helper: Redundant pool initialization"}, {"title": "Missing threshold check for highRate", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/63", "labels": ["bug", "1 (Low Risk)", "disagree-with-severity", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Missing threshold check for highRate"}, {"title": "UniswapV3Helper: Misleading param names for getSqrtPriceX96()", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor-disputed", "disagree-with-severity"], "target": "2021-09-wildcredit-findings", "body": "UniswapV3Helper: Misleading param names for getSqrtPriceX96()"}, {"title": "Constraint of minRate < lowRate can be broken", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "disagree-with-severity", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Constraint of minRate < lowRate can be broken"}, {"title": "Incorrect error message strings with require()s", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/59", "labels": ["bug", "0 (Non-critical)", "disagree-with-severity", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Incorrect error message strings with require()s"}, {"title": "UniswapV3Helper: Avoid recomputation of sqrtRatio from pool tick", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "UniswapV3Helper: Avoid recomputation of sqrtRatio from pool tick"}, {"title": "Strict inequality should be relaxed to be closed ranges instead of open", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "disagree-with-severity", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Strict inequality should be relaxed to be closed ranges instead of open"}, {"title": "Use of deprecated Chainlink API", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/55", "labels": ["bug", "2 (Med Risk)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Use of deprecated Chainlink API"}, {"title": "Missing zero-address checks", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "disagree-with-severity", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Missing zero-address checks"}, {"title": "Missing SafeMath", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/53", "labels": ["bug", "1 (Low Risk)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Missing SafeMath"}, {"title": "Consider adding `account` parameter to event WithdrawUniPosition", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/51", "labels": ["bug", "0 (Non-critical)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Consider adding `account` parameter to event WithdrawUniPosition"}, {"title": "Supply part of the accrued debt can be stolen", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "disagree-with-severity", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Supply part of the accrued debt can be stolen"}, {"title": "Gas: Unnecessary `_maxAmount` parameter in `repayAllETH`", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Gas: Unnecessary `_maxAmount` parameter in `repayAllETH`"}, {"title": "`LendingPair.withdrawUniPosition` should accrue debt first", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/48", "labels": ["bug", "2 (Med Risk)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "`LendingPair.withdrawUniPosition` should accrue debt first"}, {"title": "`UniswapV3Helper.getUserTokenAmount` could be simplified", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "disagree-with-severity", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "`UniswapV3Helper.getUserTokenAmount` could be simplified"}, {"title": "Truncated math in `interestRatePerBlock`", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/46", "labels": ["bug", "0 (Non-critical)", "disagree-with-severity", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Truncated math in `interestRatePerBlock`"}, {"title": "Simple interest formula is used", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Simple interest formula is used"}, {"title": "Uniswap oracle assumes PairToken <> WETH liquidity", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Uniswap oracle assumes PairToken <> WETH liquidity"}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/41", "labels": ["bug", "0 (Non-critical)", "disagree-with-severity", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Missing parameter validation"}, {"title": "The check if _checkBorrowEnabled and _checkBorrowLimits can be done earlier", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/40", "labels": ["bug", "0 (Non-critical)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "The check if _checkBorrowEnabled and _checkBorrowLimits can be done earlier"}, {"title": "Improve readability of constants", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/37", "labels": ["bug", "0 (Non-critical)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Improve readability of constants"}, {"title": "Reduce risk of rounding error in _timeRateToBlockRate", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/36", "labels": ["bug", "1 (Low Risk)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Reduce risk of rounding error in _timeRateToBlockRate"}, {"title": "transferLp() Misleading error message", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "transferLp() Misleading error message"}, {"title": "Change unnecessary _supplyBalanceConverted to _supplyOf can save gas", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Change unnecessary _supplyBalanceConverted to _supplyOf can save gas"}, {"title": "Change unnecessary _borrowBalanceConverted to _debtOf can save gas", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Change unnecessary _borrowBalanceConverted to _debtOf can save gas"}, {"title": "Liquidation can be escaped by depositing a Uni v3 position with 0 liquidity", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/30", "labels": ["bug", "3 (High Risk)", "disagree-with-severity", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Liquidation can be escaped by depositing a Uni v3 position with 0 liquidity"}, {"title": "Incorrect import ", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "sponsor-disputed"], "target": "2021-09-wildcredit-findings", "body": "Incorrect import "}, {"title": "PairFactory.sol is Ownable but not owner capabilites are used", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "PairFactory.sol is Ownable but not owner capabilites are used"}, {"title": "Declare the value when the variable is created ", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Declare the value when the variable is created "}, {"title": "Prefer abi.encode over abi.encodePacked", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/4", "labels": ["bug", "0 (Non-critical)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Prefer abi.encode over abi.encodePacked"}, {"title": "Use unchecked{} in ERC20 to save gas without risk", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor-acknowledged"], "target": "2021-09-wildcredit-findings", "body": "Use unchecked{} in ERC20 to save gas without risk"}, {"title": "Making PairFactory state vars immutable would save gas", "html_url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "sponsor-confirmed"], "target": "2021-09-wildcredit-findings", "body": "Making PairFactory state vars immutable would save gas"}, {"title": "Inaccurate Revert Message", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/63", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `_decreaseUserTwab()` function is used to decrease an account's TWAB balance when Ticket tokens are transferred between users or delegated to other users. If the amount to decrease exceeds the account's TWAB balance, the function will revert. However, this message does not fully reflect the function's behaviour.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol#L364  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the aforementioned revert message to correctly the function behaviour instead of a generic message.  "}, {"title": "`PrizePool.awardExternalERC721()` Erroneously Emits Events", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `awardExternalERC721()` function uses solidity's try and catch statement to ensure a single tokenId cannot deny function execution. If the try statement fails, an `ErrorAwardingExternalERC721` event is emitted with the relevant error, however, the failed tokenId is not removed from the list of tokenIds emitted at the end of function execution. As a result, the `AwardedExternalERC721` is emitted with the entire list of tokenIds, regardless of failure.  An off-chain script or user could therefore be tricked into thinking an ERC721 tokenId was successfully awarded.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L250-L270  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider emitting only successfully transferred tokenIds in the `AwardedExternalERC721` event.  "}, {"title": "Lack of Pause Mechanism", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/61", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-10-pooltogether-findings", "body": "Lack of Pause Mechanism"}, {"title": "Comment Typos", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/59", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  There are a couple of typos found within the `Reserve.sol` contract.  ## Proof of Concept  https://github.com/pooltogether/v4-core/blob/master/contracts/Reserve.sol#L20 https://github.com/pooltogether/v4-core/blob/master/contracts/Reserve.sol#L21  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the typo in `Reserve.sol:L20` from `speicific` to `specific` and the typo in `Reserve.sol:L21` from `determininstially` to `deterministically`.  "}, {"title": "`YieldSourcePrizePool._canAwardExternal()` Does Not Prevent the Deposit Token From Being Withdrawn", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/58", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `_canAwardExternal()` function is used to prevent the `onlyPrizeStrategy` role from moving a yield source's deposit tokens. However, the `YieldSourcePrizePool.sol` contract only restricts the movement of tokens from the `yieldSource` address instead of the actual deposit token. As a result, the `onlyOwner` role could escalate its role by calling `PrizePool.setPrizeStrategy()` and setting the prize strategy to its own address. Once it has taken over this role, they could effectively transfer out the yield source's deposit tokens, thereby draining the contract.   This is in direct contrast to PoolTogether's ethos, whereby their docs state that the multisig account used to represent the `onlyOwner` role has no custody over deposited assets.  ## Proof of Concept  https://v4.docs.pooltogether.com/protocol/reference/launch-architecture#progressive-decentralization https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/YieldSourcePrizePool.sol#L55-L57 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L329-L343 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L228-L236 https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L300-L302  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider updating the `YieldSourcePrizePool._canAwardExternal()` function to restrict the prize strategy from withdrawing `yieldSource.depositToken()` instead.  "}, {"title": "Unnecessary decrement (DrawCalculator.sol)", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/57", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-pooltogether-findings", "body": "Unnecessary decrement (DrawCalculator.sol)"}, {"title": "Miners Can Re-Roll the VRF Output to Game the Protocol", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/56", "labels": ["bug", "sponsor acknowledged", "3 (High Risk)"], "target": "2021-10-pooltogether-findings", "body": "Miners Can Re-Roll the VRF Output to Game the Protocol"}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/52", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-pooltogether-findings", "body": "Style issues"}, {"title": "unchecked arithmetics", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact You can save some gas by using the 'unchecked' keyword to avoid redundant arithmetic checks when an underflow/overflow cannot happen. For example, here:   while (_prizeSplits.length > newPrizeSplitsLength) {     uint256 _index = _prizeSplits.length - 1; or here:         require(_accountDetails.balance >= _amount, _revertMessage);         ...         accountDetails.balance = _accountDetails.balance - _amount;  ## Recommended Mitigation Steps Consider applying 'unchecked' keyword where overflows/underflows are not possible.  "}]