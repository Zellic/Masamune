[{"title": "making public", "html_url": "https://github.com/code-423n4/2021-03-elasticdao-findings/issues/1", "labels": [], "target": "2021-03-elasticdao-findings", "body": "making public"}, {"title": "Magic Numbers used in Admin._stake() When Constant Defined Above Can Be Used Instead", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/71", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "Magic Numbers used in Admin._stake() When Constant Defined Above Can Be Used Instead"}, {"title": "Add a timelock to functions that set key variables", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/70", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-marginswap-findings", "body": "Add a timelock to functions that set key variables"}, {"title": "Duplicated Code In Admin.viewCurrentMaintenanceStaker()", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/69", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "Duplicated Code In Admin.viewCurrentMaintenanceStaker()"}, {"title": "Users Can Drain Funds From MarginSwap By Making Undercollateralized Borrows If The Price Of A Token Has Moved More Than 10% Since The Last MarginSwap Borrow/Liquidation Involving Accounts Holding That Token.", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/67", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-marginswap-findings", "body": "Users Can Drain Funds From MarginSwap By Making Undercollateralized Borrows If The Price Of A Token Has Moved More Than 10% Since The Last MarginSwap Borrow/Liquidation Involving Accounts Holding That Token."}, {"title": "The First User To Borrow a Particular Token Can Drain Funds In MarginSwap by Making An Undercollateralized Borrow Using Flash Loans", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/66", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-marginswap-findings", "body": "The First User To Borrow a Particular Token Can Drain Funds In MarginSwap by Making An Undercollateralized Borrow Using Flash Loans"}, {"title": "Impossible to call withdrawReward fails due to run out of gas", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/65", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-marginswap-findings", "body": "Impossible to call withdrawReward fails due to run out of gas"}, {"title": "Inconsistent usage of applyInterest", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/64", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-marginswap-findings", "body": "Inconsistent usage of applyInterest"}, {"title": "[Gas] Useless addition of 0", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/62", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[Gas] Useless addition of 0"}, {"title": "Not emitting event for important state changes", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/61", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "Not emitting event for important state changes"}, {"title": "[Gas] Do not send value if holdingsValue is 0", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/60", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[Gas] Do not send value if holdingsValue is 0"}, {"title": "[Gas] Extract storage variable to a memory variable", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/59", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[Gas] Extract storage variable to a memory variable"}, {"title": "[Gas] Not used imports", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/58", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[Gas] Not used imports"}, {"title": "[Gas] only process value if amount is greater than 0", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/57", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[Gas] only process value if amount is greater than 0"}, {"title": "[Gas] unused variables", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/56", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[Gas] unused variables"}, {"title": "[Gas] same calculations are done twice", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/55", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[Gas] same calculations are done twice"}, {"title": "[Gas] Error codes", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/54", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[Gas] Error codes"}, {"title": "[INFO] liquidators may be a subject of front-running attacks", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/53", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[INFO] liquidators may be a subject of front-running attacks"}, {"title": "[INFO] allTranches array is unbounded", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/52", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[INFO] allTranches array is unbounded"}, {"title": "[INFO] Inaccurate revert message in function deactivateIssuer", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/51", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[INFO] Inaccurate revert message in function deactivateIssuer"}, {"title": "[INFO] Optimize the inheritance tree", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/50", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[INFO] Optimize the inheritance tree"}, {"title": "[INFO] setUpdateMaxPegAmount and setUpdateMinPegAmount do not check boundaries", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/49", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[INFO] setUpdateMaxPegAmount and setUpdateMinPegAmount do not check boundaries"}, {"title": "[INFO] Misleading revert messages", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/48", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[INFO] Misleading revert messages"}, {"title": "[INFO] Code duplication in viewCurrentMaintenanceStaker", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/47", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[INFO] Code duplication in viewCurrentMaintenanceStaker"}, {"title": "[INFO] Variable is declared and initialized with different values", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/46", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[INFO] Variable is declared and initialized with different values"}, {"title": "[INFO] Useless overflow comments", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/45", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[INFO] Useless overflow comments"}, {"title": "[INFO] Consistent function names", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/44", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[INFO] Consistent function names"}, {"title": "[INFO] TODOs", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/43", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[INFO] TODOs"}, {"title": "[INFO] All caps indicates that the value should be constant", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/42", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "[INFO] All caps indicates that the value should be constant"}, {"title": "setLeveragePercent should check that new _leveragePercent >= 100", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/41", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "setLeveragePercent should check that new _leveragePercent >= 100"}, {"title": "Isolated margin contracts declare but do not set the value of liquidationThresholdPercent", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/40", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-marginswap-findings", "body": "Isolated margin contracts declare but do not set the value of liquidationThresholdPercent"}, {"title": "PriceAware uses prices from getAmountsOut", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/39", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-marginswap-findings", "body": "PriceAware uses prices from getAmountsOut"}, {"title": "function buyBond charges msg.sender twice", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/38", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-marginswap-findings", "body": "function buyBond charges msg.sender twice"}, {"title": "diffMaxMinRuntime gets default value of 0", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/37", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-marginswap-findings", "body": "diffMaxMinRuntime gets default value of 0"}, {"title": "runtime > 1 hours error message discrepancy", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/36", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "runtime > 1 hours error message discrepancy"}, {"title": "function initTranche should check that the share parameter is > 0", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/35", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "function initTranche should check that the share parameter is > 0"}, {"title": "function crossWithdrawETH does not emit withdraw event", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/34", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-marginswap-findings", "body": "function crossWithdrawETH does not emit withdraw event"}, {"title": "An erroneous constructor's argument could block the withdrawReward", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/33", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "An erroneous constructor's argument could block the withdrawReward"}, {"title": "Unlocked Pragma", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/31", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-marginswap-findings", "body": "Unlocked Pragma"}, {"title": "`getReserves` does not check if tokens match", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/30", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "`getReserves` does not check if tokens match"}, {"title": "Missing checks if pairs equal tokens", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/29", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-marginswap-findings", "body": "Missing checks if pairs equal tokens"}, {"title": " No default `liquidationThresholdPercent`", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/28", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-marginswap-findings", "body": " No default `liquidationThresholdPercent`"}, {"title": "Events not indexed", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/27", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "Events not indexed"}, {"title": "Rewards cannot be withdrawn", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/26", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-marginswap-findings", "body": "Rewards cannot be withdrawn"}, {"title": "`account.holdsToken` is never set", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/25", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-marginswap-findings", "body": "`account.holdsToken` is never set"}, {"title": "Users are credited more tokens when paying back debt with `registerTradeAndBorrow`", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/24", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-marginswap-findings", "body": "Users are credited more tokens when paying back debt with `registerTradeAndBorrow`"}, {"title": "Wrong liquidation logic", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/23", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-marginswap-findings", "body": "Wrong liquidation logic"}, {"title": "Liquidations can be sandwich attacked", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/22", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-marginswap-findings", "body": "Liquidations can be sandwich attacked"}, {"title": "Price feed can be manipulated", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/21", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-marginswap-findings", "body": "Price feed can be manipulated"}, {"title": "Missing `fromToken != toToken` check in `MarginRouter.crossSwapExactTokensForTokens`/`MarginRouter.crossSwapTokensForExactTokens`", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/20", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-marginswap-findings", "body": "Missing `fromToken != toToken` check in `MarginRouter.crossSwapExactTokensForTokens`/`MarginRouter.crossSwapTokensForExactTokens`"}, {"title": "Re-entrancy bug in `MarginRouter.crossSwapTokensForExactTokens` allows inflating balance", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/19", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-marginswap-findings", "body": "Re-entrancy bug in `MarginRouter.crossSwapTokensForExactTokens` allows inflating balance"}, {"title": "Naming convention for internal functions not used consistently", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/17", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-marginswap-findings", "body": "Naming convention for internal functions not used consistently"}, {"title": "Function parameter named timestamp", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/16", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-marginswap-findings", "body": "Function parameter named timestamp"}, {"title": "Natspec comments not used in a consistent way", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/15", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-marginswap-findings", "body": "Natspec comments not used in a consistent way"}, {"title": "lastUpdatedDay not initialized", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/14", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-marginswap-findings", "body": "lastUpdatedDay not initialized"}, {"title": "Multisig wallets can't be used for liquidate", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/13", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "Multisig wallets can't be used for liquidate"}, {"title": "isStakePenalizer differtent than other functions in RoleAware.sol", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/12", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-marginswap-findings", "body": "isStakePenalizer differtent than other functions in RoleAware.sol"}, {"title": "No function for TOKEN_ADMIN in RoleAware.sol", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/11", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-marginswap-findings", "body": "No function for TOKEN_ADMIN in RoleAware.sol"}, {"title": "Role 9  in Roles.sol", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/10", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "Role 9  in Roles.sol"}, {"title": "Several function have no entry check", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/9", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-marginswap-findings", "body": "Several function have no entry check"}, {"title": "Todo's left in code", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/8", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "Todo's left in code"}, {"title": "sortTokens can be simplified", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/7", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "sortTokens can be simplified"}, {"title": "Different solidity version in UniswapStyleLib.sol", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/6", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-marginswap-findings", "body": "Different solidity version in UniswapStyleLib.sol"}, {"title": "maintainer can be pushed out", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/5", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-marginswap-findings", "body": "maintainer can be pushed out"}, {"title": "No entry checks in crossSwap[Exact]TokensFor[Exact]Tokens", "html_url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/4", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-marginswap-findings", "body": "No entry checks in crossSwap[Exact]TokensFor[Exact]Tokens"}, {"title": "Bypass or reduction on the lockup period of Pool FDTs.", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  shw   # Vulnerability details  ** Editing on a previous submission to clarify more details **  ## Impact  In `Pool.sol`, the lockup restriction of withdrawal (`Pool.sol#396`) can be bypassed or reduced if new liquidity providers cooperate with existing ones.  ## Proof of Concept  1. A liquidity provider, Alice, deposits liquidity assets into the pool and minted some FDTs. She then waits for `lockupPeriod` days and calls `intendToWithdraw` to pass her withdrawal window. Now she is available to receive FDTs from others. 2. A new liquidity provider, Bob, deposits liquidity assets into the pool and minted some FDTs. Currently, he is not allowed to withdraw his funds by protocol design. 3. Bob and Alice agree to cooperate with each other to reduce Bob's waiting time for withdrawal. Bob transfers his FDT to Alice via the `_transfer` function. 4. Alice calls `intendToWithdraw` and waits for the `withdrawCooldown` period. Notice that Alice's `depositDate` is updated after the transfer; however, since it is calculated using a weighted timestamp, the increased amount of lockup time should be less than `lockupPeriod`. In situations where the deposit from Alice is much larger than that from Bob, Alice could only even need to wait for the `withdrawCooldown` period before she could withdraw any funds. 5. Alice then withdraws the amount of FDT that Bob transferred to her and transfers the funds (liquidity assets) to Bob. Bob successfully reduces (or bypasses) the lockup period of withdrawal.  ## Tools Used  None  ## Recommended Mitigation Steps  Force users to wait for the lockup period when transferring FDT to others. Or let the `depositDate` variable record the timestamp of the last operation instead of a weighted timestamp.  "}, {"title": "Potential reentrancy when the borrower drawdowns the loan.", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/115", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor disputed"], "target": "2021-04-maple-findings", "body": "Potential reentrancy when the borrower drawdowns the loan."}, {"title": "Functions calculating the value of `BPT` is vulnerable to flash-loan attacks.", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/113", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In `library/PoolLib.sol`, the return value of functions `BPTVal` and `getPoolSharesRequired` are vulnerable by flash-loan attacks. The attacker can inflate the results of these two functions by swapping a large amount of `liquidityAsset` into the pool and swaps back after the functions are called to deceive the pool contract that BPT has a relatively high price.  Although currently `BPTVal` is not used and `getPoolSharesRequired` only affects the required staking amounts of token for a pool delegate, the code is vulnerable and could be misused by anyone in the future.  ## Proof of Concept  In the function `BPTVal`, the value of BPT in units of liquidityAsset is calculated directly from the balance of `liquidityAsset` in the Balancer pool (`PoolLib.sol#331`). For function `getPoolSharesRequired`, the required BPT to be burned also depends on the current balance of `liquidityAsset` in the pool.  ## Tools Used  None  ## Recommended Mitigation Steps  Use the balance of `liquidityAsset` in the previous block to eliminate the possibility of suffering from a flash-loan attack. A time-weight average price can also mitigate the problem.  "}, {"title": "Full payment does not consider late fees of the payment", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/112", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "resolved"], "target": "2021-04-maple-findings", "body": "Full payment does not consider late fees of the payment"}, {"title": "Oracle not checked if set for an asset", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/110", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Oracle not checked if set for an asset"}, {"title": "Not ERC20 Compliant", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "0 (Non-critical)", "sponsor acknowledged", "disagree with severity"], "target": "2021-04-maple-findings", "body": "Not ERC20 Compliant"}, {"title": "Default slippage value too high", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/106", "labels": ["bug", "2 (Med Risk)", "0 (Non-critical)", "sponsor acknowledged", "disagree with severity"], "target": "2021-04-maple-findings", "body": "Default slippage value too high"}, {"title": "Uniswap DOS", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/105", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Uniswap DOS"}, {"title": "getRewardForDuration will start returning misleading results if rewardsDuration is updated", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/103", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "getRewardForDuration will start returning misleading results if rewardsDuration is updated"}, {"title": "LoanLib.unwind uses globals.fundingPeriod()", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/100", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  Every loan has its own fundingPeriod which is set once in the constructor: fundingPeriod          = globals.fundingPeriod(); fundingPeriod in globals can change. It does not effect already deployed Loans. However, in Loan contract function unwind() calls LoanLib.unwind which checks against globals.fundingPeriod():         IGlobals globals = _globals(superFactory);         // Only callable if time has passed drawdown grace period, set in MapleGlobals         require(block.timestamp > createdAt.add(globals.fundingPeriod()), \"Loan:FUNDING_PERIOD_NOT_FINISHED\"); at this time, globals.fundingPeriod() could be different than this specific Loan's fundingPeriod.  ## Recommended Mitigation Steps  Check expiration against local fundingPeriod.   "}, {"title": "Function triggerDefault should call _emitBalanceUpdateEventForCollateralLocker", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/99", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  function triggerDefault should call _emitBalanceUpdateEventForCollateralLocker to emit event as the balance of CollateralLocker changes after calling LoanLib.liquidateCollateral.   "}, {"title": "Interface and implementation function declaration differs", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/98", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  ILoan.sol: function getNextPayment() external view returns (uint256, uint256, uint256, uint256) Loan.sol: function getNextPayment() public view returns(uint256, uint256, uint256, uint256, bool) Such discrepencies appear because implementation contracts do not inherit the interface explicitly (Loan is ILoan), so it does not give compilation errors if the declaration changes.  ## Recommended Mitigation Steps  Unify the declarations or even better, make the contract inherit from the interface so you can always be sure that these functions are present.  "}, {"title": "Unused code", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/97", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract LifeGuard3Pool has unused events: LogHealhCheckUpdate, LogNewEmergencyWithdrawal. Interfaces IHarvest and IStake are not used. contract Buoy3Pool has unused variable TIME_LIMIT and a variable that is only initialized but never used: lpToken.  Style issue: BASIS_POINTS all caps indicate it should be a constant, however, an owner can change it by calling function setBasisPointsLmit.  ## Recommended Mitigation Steps Make use of this code or remove it.   "}, {"title": "Comment indicates that FundsWithdrawn event should be emitted only when _withdrawableDividend > 0", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/96", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Vulnerability details  A comment says: \"It emits a `FundsWithdrawn` event if the amount of withdrawn ether is greater than 0.\" However, actually, this event is always emitted (no check against 0).   ## Recommended Mitigation Steps Either emit this event if _withdrawableDividend > 0 or remove the comment.    "}, {"title": "Griefing attack on pool creation in PoolFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/94", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Griefing attack on pool creation in PoolFactory.sol"}, {"title": "Griefing attack on loan creation in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/93", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Griefing attack on loan creation in LoanFactory.sol"}, {"title": "Potential huge arbitrage opportunities / MPL price decrease", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/92", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Potential huge arbitrage opportunities / MPL price decrease"}, {"title": "MPL USDC distributions can be withdrawn by anyone", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/91", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-04-maple-findings", "body": "MPL USDC distributions can be withdrawn by anyone"}, {"title": "MPL reward claims of balancer pools can be exploited", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/90", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-04-maple-findings", "body": "MPL reward claims of balancer pools can be exploited"}, {"title": "Allowance Double-Spend Exploit", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/89", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Allowance Double-Spend Exploit"}, {"title": "Possible sandwich-attack when treasury converts tokens", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/88", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor disputed"], "target": "2021-04-maple-findings", "body": "Possible sandwich-attack when treasury converts tokens"}, {"title": "Missing non-zero check", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/87", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-04-maple-findings", "body": "Missing non-zero check"}, {"title": "Missing index on events", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/86", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  Some events have no index: - `BasicFDT.PointsCorrectionUpdated` - `BasicFDT.PointsCorrectionUpdated` - `BasicFDT.LossesCorrectionUpdated` - `ExtendedFDT.LossesCorrectionUpdated` - `StakeLocker.StakeDateUpdated` - `MapleTreasury.FundsTokenModified` is never used   ## Impact  Off-chain scripts that rely on these events are unable to filter them efficiently.  ## Recommended Mitigation Steps  Add the missing indexes on the events or remove the events if they are not needed on the backend.   "}, {"title": "Missing check on `setManualPrice(int256 _price)`", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/85", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `ChainlinkOracle.setManualPrice` function specifies that it can only be called \"if manualOverride == true\".  This is not the case.   ## Impact  Assume an oracle failure happened, and the oracle needs to be manually set to prevent losses. The `setManualPrice` function succeeds and the owner might think that the oracle price is overwritten as the function would fail when `manualOverride` is not `true` according to specification. The protocol would still use the broken chainlink price feed and suffer losses.  ## Recommended Mitigation Steps  Add the missing `require(manualOverride == true, \"manual override not set\")` check.   "}, {"title": "Wrong docs on UsdOracle", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/84", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `UsdOracle.sol` contract states:  > UsdOracle is a constant price oracle feed that always returns 1 USD in USDC precision.  The USDC precision is 6, but the oracle returns a precision of 8, so the comment does not match the code.   ## Impact  A wrong precision on the oracle contract could lead to inflated/deflated prices.  ## Recommended Mitigation Steps  It seems that the current contract code assumes a precision of 8 instead of 6 and works correctly. Clarify if the documentation is wrong or the code needs to be updated. If further development is done and the comment is assumed to be correct, one might use 100 times the actual USDC token balance.   "}, {"title": "Chainlink Price oracle always assumes 8 decimals", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/83", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Chainlink Price oracle always assumes 8 decimals"}, {"title": "Chainlink Price data could be stale", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  There is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:   * [\"if answeredInRound < roundId could indicate stale data.\"](https://docs.chain.link/docs/developer-communications#current-notifications)   * [\"A timestamp with zero value means the round is not complete and should not be used.\"](https://docs.chain.link/docs/historical-price-data#solidity)   ## Impact  The price oracle might return unreliable price data which can lead to a variety of different issues in the protocol, for example, for liquidating more staker & lender tokens than required at fair market price.  ## Recommended Mitigation Steps  Add missing checks for stale data. See example [here](https://github.com/cryptexfinance/contracts/blob/master/contracts/oracles/ChainlinkOracle.sol#L58-L65).   "}, {"title": "Unnecessary check for `uint256 >= 0`", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "resolved"], "target": "2021-04-maple-findings", "body": "Unnecessary check for `uint256 >= 0`"}, {"title": "Unused variable in `PoolLib.handleDefault`", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/78", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  Low  ## Proof of Concept  Here you have a gist: https://gist.github.com/alexon1234/7b51e901ac50e524369549af70ca9eeb   "}, {"title": "Outdated Compiler", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/77", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Outdated Compiler"}, {"title": "Use of mapping in place of array in `PoolFactory` and `LoanFactory`", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Use of mapping in place of array in `PoolFactory` and `LoanFactory`"}, {"title": "Using precalculated value in the Pool & Loan contracts", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/75", "labels": ["bug", "sponsor confirmed", "resolved", "G (Gas Optimization)"], "target": "2021-04-maple-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  Low, just gas optimizations  ## Proof of Concept  Here you have a gist: https://gist.github.com/alexon1234/60973d61b49ff1f5ec83b121b33b30b1  ## Tools Used  Remix  ## Recommended Mitigation Steps  Use constant for unchanging values  "}, {"title": "Optimising Factory contracts by using structs  ", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/73", "labels": ["bug", "sponsor acknowledged", "G (Gas Optimization)"], "target": "2021-04-maple-findings", "body": "Optimising Factory contracts by using structs  "}, {"title": "Event emission inconsistent with NatSpec comment in ERC2222.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/72", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Event emission inconsistent with NatSpec comment in ERC2222.sol"}, {"title": "Inconsistent NatSpec comment in Pool.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers/requires/checks is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the setAdmin() function which is accessible only by Pool Delegate.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L329-L337  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add \u201cCan only called by the pool delegate.\u201d to @dev on L330.   "}, {"title": "Inconsistent NatSpec comment in Pool.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/70", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "Inconsistent NatSpec comment in Pool.sol"}, {"title": "Missing event for critical operation of setAdmin change in Pool.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/69", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  An admin of a Pool can call claim() and setLiquidytCap() along with the Pool Delegate. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L329-L337  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   "}, {"title": "Missing check for Pool state on several functions in Pool.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Missing check for Pool state on several functions in Pool.sol"}, {"title": "Missing check for stakingFee+delegateFee in Pool.sol constructor", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/66", "labels": ["1 (Low Risk)", "invalid"], "target": "2021-04-maple-findings", "body": "Missing check for stakingFee+delegateFee in Pool.sol constructor"}, {"title": "Incorrect require error message string in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/65", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The error message string for the require statement on L153 of LoanFactory.sol incorrectly uses PoolFactory as the source contract for this message instead of LoanFactory, which could be confusing when this error is hit.  require(msg.sender == globals.governor(), \"PoolFactory:INVALID_GOVERNOR\");  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L153  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change error message to: require(msg.sender == globals.governor(), \u201cLoanFactory:INVALID_GOVERNOR\");   "}, {"title": "Inconsistent NatSpec comment in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function pause() in LoanFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers paused state. Halts functionality for certain functions. Only Governor can call this function.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L133-L139  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   "}, {"title": "Incorrect require error message string in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "Incorrect require error message string in LoanFactory.sol"}, {"title": "Incorrect require error message string in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "Incorrect require error message string in LoanFactory.sol"}, {"title": "Inconsistent NatSpec comment in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/61", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "Inconsistent NatSpec comment in LoanFactory.sol"}, {"title": "Inconsistent NatSpec comment in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "Inconsistent NatSpec comment in LoanFactory.sol"}, {"title": "Inconsistent NatSpec comment in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/59", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "Inconsistent NatSpec comment in LoanFactory.sol"}, {"title": "Inconsistent NatSpec comment in PoolFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/58", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function pause() in PoolFactory.sol can be called by both Governor and Admin but the @dev Natspec comment incorrectly says that this is only callable by Governor.   Therefore, the Natspec comment for this function is incorrect: @dev Triggers paused state. Halts functionality for certain functions. Only Governor can call this function.   ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L122-L128  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change @dev Natspec comment to correctly indicate this function can be called by both Governor and Admin   "}, {"title": "Inconsistent NatSpec comment in PoolFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "Inconsistent NatSpec comment in PoolFactory.sol"}, {"title": "Inconsistent NatSpec comment in PoolFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "Inconsistent NatSpec comment in PoolFactory.sol"}, {"title": "Inconsistent NatSpec comment in PoolFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/55", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "Inconsistent NatSpec comment in PoolFactory.sol"}, {"title": "Inconsistent NatSpec comment in PoolFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "Inconsistent NatSpec comment in PoolFactory.sol"}, {"title": "Specification/Implementation mismatch on Security Multisig capability", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/53", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor disputed"], "target": "2021-04-maple-findings", "body": "Specification/Implementation mismatch on Security Multisig capability"}, {"title": "Specification/Implementation mismatch on Security Multisig capability", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/52", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-04-maple-findings", "body": "Specification/Implementation mismatch on Security Multisig capability"}, {"title": "Missing input validation on critical globals variable for zero address in MplRewardsFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/51", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor disputed"], "target": "2021-04-maple-findings", "body": "Missing input validation on critical globals variable for zero address in MplRewardsFactory.sol"}, {"title": "Missing input validation on critical globals variable for zero address in LoanFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/50", "labels": ["bug", "duplicate", "0 (Non-critical)"], "target": "2021-04-maple-findings", "body": "Missing input validation on critical globals variable for zero address in LoanFactory.sol"}, {"title": "Missing input validation on critical globals variable for zero address in PoolFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/49", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor disputed"], "target": "2021-04-maple-findings", "body": "Missing input validation on critical globals variable for zero address in PoolFactory.sol"}, {"title": "Missing input validation on critical globals variable for zero address in MapleTreasury.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/48", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor disputed"], "target": "2021-04-maple-findings", "body": "Missing input validation on critical globals variable for zero address in MapleTreasury.sol"}, {"title": "Inconsistent NatSpec comment in StakeLocker.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers or require statements is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the pull() function of StakeLocker.sol which is accessible only by isPool.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/StakeLocker.sol#L125-L132  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add \u201cOnly Pool can call this function.\u201d to @dev on L126.   "}, {"title": "Inconsistent NatSpec comment in StakeLocker.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/46", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "Inconsistent NatSpec comment in StakeLocker.sol"}, {"title": "Missing input validation on function parameter for zero address in FundingLocker.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Missing input validation on function parameter for zero address in FundingLocker.sol"}, {"title": "Missing input validation on function parameter for zero address in CollateralLocker.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/44", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Missing input validation on function parameter for zero address in CollateralLocker.sol"}, {"title": "Missing input validation on function parameter for zero address in StakeLocker.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/43", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Missing input validation on function parameter for zero address in StakeLocker.sol"}, {"title": "Inconsistent NatSpec comment in StakeLocker.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "Inconsistent NatSpec comment in StakeLocker.sol"}, {"title": "Missing event for critical operation of Pool Delegate validity change in MapleGlobals.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/39", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Pool delegates are trusted actors (see https://github.com/maple-labs/maple-core/wiki/Security#trust-assumptions) and so any change (additions/removals) in their validity should be recorded for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L232-L239  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log pool delegate validity change in setPoolDelegateAllowlist function.   "}, {"title": "Missing event for critical operation of setAdmin change for Protocol admin in MapleGlobals.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/38", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The protocol admin defined in MapleGlobals can pause/unpause all important functionalities of the protocol. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L148-L156  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   "}, {"title": "Mirrored admin variables in global context, Pool, PoolFactory, Loan and LoanFactory may make it confusing for deployment and maintenance", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/36", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The access control model for the different contracts and how they interact is confusing and may cause issues during deployment and maintenance. Multiple contracts have the notion of admin(s), all of which use setAdmin function to update admin status. This mirroring and reuse of the admin variable is susceptible to accidents.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/MapleGlobals.sol#L20 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Pool.sol#L55 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/PoolFactory.sol#L19 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Loan.sol#L58 https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LoanFactory.sol#L27  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Rename the different admin variables e.g. adminGlobal, adminPool, adminLoan. Document the access control roles, hierarchy and interactions explicitly.   "}, {"title": "Missing input validation on critical globals for zero addresses in MapleGlobals.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-04-maple-findings", "body": "Missing input validation on critical globals for zero addresses in MapleGlobals.sol"}, {"title": "Inconsistent NatSpec comment in DebtLocker.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/34", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Access control of external/public functions via modifiers or require statements is typically specified in the @dev part of the NatSpec comment. This highlight is missing for the claim() function which is accessible only by isPool.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/DebtLocker.sol#L44-L54  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add \u201cOnly called by the pool contract.\u201d to @dev on L45.   "}, {"title": "Missing event for critical operation of setAdmin change in Loan.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  An admin of a Loan can pause/unpause the fundLoan operation along with the borrower. This critical operation of admin status change in setAdmin function should be logged as an event for off-chain monitoring. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/Loan.sol#L409-L413  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log admin status change in setAdmin function.   "}, {"title": "Vulnerable to potential reentrancy attacks in Loan.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/32", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Vulnerable to potential reentrancy attacks in Loan.sol"}, {"title": "Missing event for critical operation of new Liquidity locker creation in LiquidityLockerFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/31", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/LiquidityLockerFactory.sol#L19-L24  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   "}, {"title": "Missing event for critical operation of new Funding locker creation in FundingLockerFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/FundingLockerFactory.sol#L21-L26  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   "}, {"title": "Missing event for critical operation of new Debt locker creation in DebtLockerFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/29", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Lockers are critical contracts that hold custody of different Maple assets. While there are five lockers created initially (as described in https://github.com/maple-labs/maple-core/wiki/Lockers), such new lockers created by the factory should be logged as events for off-chain monitoring, similar to whats done in StakeLocker. However, such an event emission is missing here.  ## Proof of Concept  https://github.com/maple-labs/maple-core/blob/355141befa89c7623150a83b7d56a5f5820819e9/contracts/DebtLockerFactory.sol#L19-L23  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Create and emit a suitable event to log locker creation.   "}, {"title": "Missing event for critical operation of new Collateral locker creation in CollateralLockerFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/28", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-04-maple-findings", "body": "Missing event for critical operation of new Collateral locker creation in CollateralLockerFactory.sol"}, {"title": "Missing event for critical operation of new Collateral locker creation in CollateralLockerFactory.sol", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/27", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "resolved"], "target": "2021-04-maple-findings", "body": "Missing event for critical operation of new Collateral locker creation in CollateralLockerFactory.sol"}, {"title": "Year is not exactly 365 days", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/26", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Year is not exactly 365 days"}, {"title": "Typo NULL_TRASNFER_DST", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/25", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact  A require statement in the function transfer in LiquidityLocker.sol contains a typo. TRASNFER should be TRANSFER  ## Proof of Concept  LiquidityLocker.sol: function transfer(address dst, uint256 amt) external isPool { LiquidityLocker.sol:    require(dst != address(0), \"LiquidityLocker:NULL_TRASNFER_DST\");  ## Tools Used  Editor  ## Recommended Mitigation Steps  Fix typo   "}, {"title": "Same constants defined in different files", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/23", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Same constants defined in different files"}, {"title": "Unused definition of enum", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/17", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact  LoanLib.sol has a definition of enum State and Loan.sol has the same definition. The LoanLib.sol does not seem to be used This means dead code and could be confusing.  ## Proof of Concept  Loan.sol:       enum State { Ready, Active, Matured, Expired, Liquidated } LoanLib.sol:    enum State { Ready, Active, Matured, Expired, Liquidated }  ## Tools Used  grep \"enum\" *.sol -S  ## Recommended Mitigation Steps  Remove the unused definition from LoanLib.sol (or make sure there is just one definition for the enum and include that elsewhere)  "}, {"title": "Declare functions `external` to save gas", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/11", "labels": ["bug", "sponsor confirmed", "resolved", "G (Gas Optimization)"], "target": "2021-04-maple-findings", "body": "# Handle  JMukesh   # Vulnerability details  // All these function described should be declared  external, as functions that are never called by the contract should be declared external to save gas.                 In fundingLockerFactory.sol --> newLocker(){} In LatefeeCalc.sol          --> getlateFee(){] In Loan.sol                 --> MakeFullPayment(){} In library/Loanlib.sol      --> getNextPayment(){} In library/Util.sol         --> calcMinAmount(){} In token/BasicFDT.sol       --> withdrawnFundsOf(){} In MapleTreasury.sol        --> reclaimERC20(){}                                distributeToHolder(){}                                convertERC20(){}  In Pool.sol                 --> claimablefunds(){}                             --> BPTval(){} In Poollib,sol              --> validateDeactivation(){}                                isWithdrawAllowed(){}                                getInitialStakeRequirements(){}                                ecognizedLossesOf(){} In Premiumcal.sol            --> getPremium(){} In Repayment.sol            -->  getNextPayment(){}     "}, {"title": "Missing zero address validation", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Missing zero address validation"}, {"title": "Constructor arguments to MapleTreasury not validated", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/9", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Constructor arguments to MapleTreasury not validated"}, {"title": "MapleTreasury does not emit an event when MapleGlobals address is updated", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-04-maple-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Its impact will be limited since we will not able tract the change of address off-chain but on-chain we can which will consume gas  ## Proof of Concept In file MapleTreasury.sol has no event, so it is difficult to track off-chain changes of  Address of new MapleGlobals contract     ## Tools Used  slither  ## Recommended Mitigation Steps  add event for setting global address  "}, {"title": "Loans of tokens with >18 decimals can result in incorrect collateral calculation", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "resolved"], "target": "2021-04-maple-findings", "body": "Loans of tokens with >18 decimals can result in incorrect collateral calculation"}, {"title": "Cross-Chain Replay Attack", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-maple-findings", "body": "Cross-Chain Replay Attack"}, {"title": "Test of Maple Finance contest form", "html_url": "https://github.com/code-423n4/2021-04-maple-findings/issues/1", "labels": ["0 (Non-critical)"], "target": "2021-04-maple-findings", "body": "Test of Maple Finance contest form"}, {"title": "Requires a non-zero address check when deploying `CErc20` tokens and `CEther`.", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/39", "labels": ["bug", "disagree with severity", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "Requires a non-zero address check when deploying `CErc20` tokens and `CEther`."}, {"title": "`UniswapAnchoredView`'s `PriceUpdated` event is never fired", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/38", "labels": ["bug", "duplicate", "disagree with severity", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  `UniswapAnchoredView`'s `PriceUpdated` event is never fired.  ## Impact  Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps  Use it or remove it.   "}, {"title": "UniswapConfig getters return wrong token config if token config does not exist", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/37", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `UniswapConfig.getTokenConfigBySymbolHash` function does not work as `getSymbolHashIndex` returns `0` if there is no config token for that symbol (uninitialized map value), but the outer function implements the non-existence check with `-1`.  The same issue occurs also for:  - `getTokenConfigByCToken` - `getTokenConfigByUnderlying`  ## Impact  When encountering a non-existent token config, it will always return the token config of the **first index** (index 0) which is a valid token config for a completely different token. This leads to wrong oracle prices for the actual token which could in the worst case be used to borrow more tokens at a lower price or borrow more tokens by having a higher collateral value, essentially allowing undercollateralized loans that cannot be liquidated.  ## Recommended Mitigation Steps  Fix the non-existence check.   "}, {"title": "Privileged roles", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/35", "labels": ["bug", "disagree with severity", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "Privileged roles"}, {"title": "Reward rates can be changed through flash borrows", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/33", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "Reward rates can be changed through flash borrows"}, {"title": " Unbounded iteration on `refreshCompSpeedsInternal`", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/32", "labels": ["bug", "disagree with severity", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": " Unbounded iteration on `refreshCompSpeedsInternal`"}, {"title": "Usage of `address.transfer`", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/31", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `transfer` function is used in `Maximillion.sol` to send ETH to an account.  ## Impact  It is performed with a fixed amount of GAS and might fail if GAS costs change in the future or if a smart contract's fallback function handler is complex.  ## Recommended Mitigation Steps  Consider using the lower-level `.call{value: value}` instead and checking its success return value.  "}, {"title": "[Info] functions 'getUnderlyingPriceView' and 'price' are too similar", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/29", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "[Info] functions 'getUnderlyingPriceView' and 'price' are too similar"}, {"title": "Allow borrowCap to be filled fully", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "Allow borrowCap to be filled fully"}, {"title": "Use 'interface' keyword for interfaces", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/27", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "Use 'interface' keyword for interfaces"}, {"title": "function getUnderlyingPrice compares against \"cETH\"", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/26", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact contract CompoundLens functions cTokenMetadata and cTokenBalances compare against \"bETH\" while contract SimplePriceOracle function getUnderlyingPrice compares against \"cETH\". It is not clear if this SimplePriceOracle will be used in production, probably only for testing, but still would be nice to unify it across all the contracts.  ## Recommended Mitigation Steps Replace \"cETH\" with \"bETH\" in SimplePriceOracle function getUnderlyingPrice.  "}, {"title": "Use 'receive' when expecting eth and empty call data", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact contract CEther fallback function was refactored to be compatible with the Solidity 0.6 version:    /**    * @notice Send Ether to CEther to mint    */   fallback () external payable {       (uint err,) = mintInternal(msg.value);       requireNoError(err, \"mint failed\");   }  From Solidity 0.6 documentation:  \"The unnamed function commonly referred to as \u201cfallback function\u201d was split up into a new fallback function that is defined using the fallback keyword and a receive ether function defined using the receive keyword. If present, the receive ether function is called whenever the call data is empty (whether or not ether is received). This function is implicitly payable. The new fallback function is called when no other function matches (if the receive ether function does not exist then this includes calls with empty call data). You can make this function payable or not. If it is not payable then transactions not matching any other function which send value will revert. You should only need to implement the new fallback function if you are following an upgrade or proxy pattern.\"  I think in this case \"receive\" is more suitable as the function is expecting to receive ether and empty call data.  ## Recommended Mitigation Steps Replace \"fallback\" with \"receive\".  "}, {"title": "uint(-1) index for not found", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/24", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact functions getTokenConfigBySymbolHash, getTokenConfigByCToken and getTokenConfigByUnderlying check returned index against max uint:   index != uint(-1) -1 should indicate that the index is not found, however, a default value for an uninitialized uint is 0, so it is impossible to get -1. What is even weirder is that 0 will be returned for non-existing configs but 0 is a valid index for the 1st config.  ## Recommended Mitigation Steps One of the solutions would be to reserve 0 for a not found index and use it when searching in mappings. Then normal indexes should start from 1. Another solution would be to introduce a new mapping with a boolean value that indicates if this index is initialized or not but this may be a more gas costly way.  "}, {"title": "Missed NatSpec @param for newly introduced parameter distributeAll", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The distributeSupplierComp() function has been modified to take in a third parameter which is a boolean distributeAll. But the corresponding NatSpec comments for the function have not been updated to add this new parameter. This could lead to minor confusion where NatSpec is consulted.  ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L1238-L1243   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add @param for distributeAll parameter.  "}, {"title": "Missing zero/threshold check for maxAssets", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/21", "labels": ["bug", "disagree with severity", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "Missing zero/threshold check for maxAssets"}, {"title": "Missing input validation may set COMP token to zero-address in Comptroller.sol", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/20", "labels": ["bug", "duplicate", "disagree with severity", "0 (Non-critical)", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "Missing input validation may set COMP token to zero-address in Comptroller.sol"}, {"title": "Floating pragma used in Uniswap*.sol\u2028", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/19", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Contracts should be deployed using the same compiler version/flags with which they have been tested. Locking the floating pragma, i.e. by not using ^ in pragma solidity ^0.6.10, ensures that contracts do not accidentally get deployed using an older compiler version with unfixed bugs.  For reference, see https://swcregistry.io/docs/SWC-103   ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapAnchoredView.sol#L3  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapConfig.sol#L3  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/UniswapOracle/UniswapLib.sol#L3   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove ^ in \u201cpragma solidity ^0.6.10\u201d and change it to \u201cpragma solidity 0.6.12\u201d to be consistent with the rest of the contracts.  "}, {"title": "All except one Comptroller verify functions do not verify anything in Comptroller.sol/CToken.sol\u2028", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Six of the seven Comptroller verify functions do nothing. Not sure why their calls in CToken.sol have been uncommented from the original Compound version.  Except redeemVerify(), six other verify functions transferVerify(), mintVerify(), borrowVerify(), repayBorrowVerify(), liquidateBorrowVerify() and seizeVerify() have no logic except accessing state variables to not be marked pure. Calls to these functions were commented out in the original Compound code\u2019s CToken.sol but have been uncommented here.  Given that they do not implement any logic, the protocol should not be making any assumptions about any defence provided from their unimplemented verification logic.  ## Proof of Concept  Dummy functions whose comments say \u201c// Shh - currently unused\u201d:  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L263-L281  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L402-L418  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L450-L474  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L519-L546  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L584-L609  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/Comptroller.sol#L638-L656    Uncommented calls from modified code:  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L126  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L560  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L798  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L915  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L1019  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CToken.sol#L1090    Commented calls from original Compound code:  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L123-L124  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L558-L559  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L797-L798  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L915-L916  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L1020-L1021  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CToken.sol#L1092-L1093    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add logic to implement verification if that is indeed assumed to be implemented but is actually not. Otherwise, comment call sites.  "}, {"title": "sweepToken() function removed in CErc20.sol from original Compound code", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/17", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The sweepToken() function in the original Compound code whose specified purpose was to recover accidentally sent ERC20 tokens to contract has been removed.   The original code comment says: \u201cA public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock).\u201d This safety measure is helpful given the number/value of accidentally stuck tokens that are sent to contracts by mistake.  Tokens accidentally sent to this contract will be stuck leading to fund loss for sender.  ## Proof of Concept  https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CErc20.sol#L112-L120  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CErc20.sol#L109-L121  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Retain this function unless there is a specific reason to remove it here.  "}, {"title": "No account existence check for low-level call in CEther.sol", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/16", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Low-level calls call/delegatecall/staticcall\u00a0return\u00a0true\u00a0even if the account called is non-existent (per EVM design). Account existence must be checked prior to calling.  The doTransferOut() function was changed from using a transfer() function (which reverts) to a call() function (which returns a boolean), however there is no account existence check for the destination address to. If it doesn\u2019t exist, for some reason, call will still return true (not throw an exception) and successfully pass the return value check on the next line.  The checked call paths don\u2019t seem vulnerable because they use msg.sender/admin and not a user-controlled address, but this may be a risk if used later in other contexts. Hence rating as low-risk.  For reference, see this related high-risk severity finding from Trail of Bit\u2019s audit of Hermez Network: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  ## Proof of Concept  https://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CEther.sol#L145-L148  https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls  https://docs.soliditylang.org/en/v0.8.4/control-structures.html#error-handling-assert-require-revert-and-exceptions   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check for account-existence before the call() to make this safely extendable to user-controlled address contexts in future.  "}, {"title": "Outdated Compiler", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/15", "labels": ["bug", "disagree with severity", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "Outdated Compiler"}, {"title": "Missing validation for _setCompAddress", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/14", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "Missing validation for _setCompAddress"}, {"title": "Missing event visbility in _setCompAddress() function", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/13", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The _setCompAddress() function in the Comptroller contract does not emit an event when changing the comp address. While this does not impose any security risk, it does hinder a users ability to view any changes made to the comp address through the contract's lifetime.   ## Affected line https://github.com/code-423n4/2021-04-basedloans/blob/main/code/contracts/Comptroller.sol#L1354  ## Recommended Mitigation Steps It is recommended to emit an event indicating the old comp address, and the new comp address to be used when calling the _setCompAddress() function. An example of such an event is `event NewCompAddress(address oldCompAddress, address newCompAddress)`.  "}, {"title": "uint[] memory parameter is tricky", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/12", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "uint[] memory parameter is tricky"}, {"title": "now is still used", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "now is still used"}, {"title": "More readable constants", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-04-basedloans-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Some constant values are difficult to read in one time because they have at lot of 0's. Solidity allows _ to separate series of zero's  ## Proof of Concept .\\Governance\\Blo.sol:    uint public constant totalSupply = 100000000e18; // 100 million BLO .\\Governance\\GovernorAlpha.sol:    function quorumVotes() public pure returns (uint) { return 4000000e18; } // 4,000,000 = 4% of BLO .\\Governance\\GovernorAlpha.sol:    function proposalThreshold() public pure returns (uint) { return 1000000e18; } // 1,000,000 = 1% of BLO  ## Tools Used grep  ## Recommended Mitigation Steps Replace   1000000e18 with    1_000_000e18  Replace   4000000e18 with    4_000_000e18  Replace 100000000e18 with  100_000_000e18   "}, {"title": "uint(-1)", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/7", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "uint(-1)"}, {"title": "CarefulMath / safe math not allways used", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/6", "labels": ["bug", "disagree with severity", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "CarefulMath / safe math not allways used"}, {"title": "requireNoError not used in a consistent way", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/5", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "requireNoError not used in a consistent way"}, {"title": "requireNoError can be optimized", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/4", "labels": ["bug", "sponsor acknowledged", "G (Gas Optimization)"], "target": "2021-04-basedloans-findings", "body": "requireNoError can be optimized"}, {"title": "Alphabetical order not complied with (contrary to the comments)", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/3", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "Alphabetical order not complied with (contrary to the comments)"}, {"title": "Reliance on the fact that NO_ERROR = 0", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/2", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "Reliance on the fact that NO_ERROR = 0"}, {"title": "Multiple error enums with overlapping values", "html_url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/1", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-04-basedloans-findings", "body": "Multiple error enums with overlapping values"}, {"title": "Unnecessary function calls in `addLiquidity`", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/320", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Unnecessary function calls in `addLiquidity`"}, {"title": "Unnecessary `else if` statement in `swapWithSynthsWithLimit`", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/319", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In `Router.sol`, the second `else if` statement in the function `swapWithSynthsWithLimit` is unnecessary.  ## Proof of Concept  Referenced code: [Router.sol#L162](https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L162)  ## Tools Used  None  ## Recommended Mitigation Steps  Consider using `else {...}`, which has the identical behavior to save gas.  "}, {"title": "Unrestricted `addLiquidity` could cause unintended results on front-end apps that listen to events.", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/317", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor acknowledged", "filed"], "target": "2021-04-vader-findings", "body": "Unrestricted `addLiquidity` could cause unintended results on front-end apps that listen to events."}, {"title": "Users may unintendedly remove liquidity under a phishing attack.", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/316", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-04-vader-findings", "body": "Users may unintendedly remove liquidity under a phishing attack."}, {"title": "Allowing duplicated anchors could cause bias on anchor price.", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/314", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-04-vader-findings", "body": "Allowing duplicated anchors could cause bias on anchor price."}, {"title": "Out-of-bound index access in function `getAnchorPrice`", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/313", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "Out-of-bound index access in function `getAnchorPrice`"}, {"title": "Unused and Unnecessary code", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/312", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Unused and Unnecessary code"}, {"title": "flashProof is not effective at the start", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/307", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "flashProof is not effective at the start"}, {"title": "Unused ID field in structs", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/304", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact Both structs CollateralDetails and DebtDetails have unused ID field which is never set nor queried:    uint ID;  "}, {"title": "token == arrayAnchors[i]", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/303", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact In function updateAnchorPrice here 'arrayAnchors[i]' can be replaced with 'token' to eliminate one expensive storage access:    arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);  "}, {"title": "You don't need to recalculate exclusion fee every time", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/302", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "You don't need to recalculate exclusion fee every time"}, {"title": "Function can be simplified", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/301", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Function can be simplified"}, {"title": "excludedCount", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/300", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "excludedCount"}, {"title": "totalSupply + amount > maxSupply", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/299", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact Condition could be '>', not '>=' as there is no point in recalculating amount to the same value (waste of gas):  if((totalSupply + amount) >= maxSupply){   amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply  }  "}, {"title": "Fee on transfer conditions", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/293", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Fee on transfer conditions"}, {"title": "Some storage optimizations", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/292", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  a_delamo   # Vulnerability details  Here you have more information: https://gist.github.com/alexon1234/5eb3fff3bded4e4c50d6e13abae6f474  "}, {"title": "Cache duplicate calls or storage access", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/291", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Cache duplicate calls or storage access"}, {"title": "Extract mappings to a common struct", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/289", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Extract mappings to a common struct"}, {"title": "variable == false -> !variable", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/288", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact a bit cheapier when you replace:   require(inited == false); with:   require(!inited); same with variable == true.  "}, {"title": "Extra useless steps to calculate pooledVADER and pooledUSDV ", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/287", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact Here are some useless calculations:   if(_token == VADER && _pool != VADER){  // Want to know added VADER      addedAmount = _balance - pooledVADER;      pooledVADER = pooledVADER + addedAmount;  } else if(_token == USDV) {             // Want to know added USDV      addedAmount = _balance - pooledUSDV;      pooledUSDV = pooledUSDV + addedAmount; if you do the simple maths, it is always in the first case, pooledVADER = _balance, in the second case pooledUSDV = _balance.   "}, {"title": "Use immutable for constant variables", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/286", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact There are variables that are only assigned once (e.g. in a constructor). You should mark such variables with the keyword \"immutable\", this greatly reduces the gas costs. A concrete example of such a variable is \"VADER\" which is only initialized once and cannot be changed later:    VADER = _vader; There are plenty of such variables across the contracts.   "}, {"title": "[INFO] Code style suggestions", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/285", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-vader-findings", "body": "[INFO] Code style suggestions"}, {"title": "ERC20 specification declares decimals as uint8 type", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/283", "labels": ["bug", "0 (Non-critical)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact iERC20 decimals field is declared as uint, but to be exact, ERC20 specification declares decimals as uint8. Anyway, this has no security impact as 18 decimals is set which fits in uint8.  ## Recommended Mitigation Steps You can refactor to uint8 or just be informed about such compatibility guidelines.  "}, {"title": "calculations of upgradedAmount is not overflow protected", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/277", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "calculations of upgradedAmount is not overflow protected"}, {"title": "curatePool emits Curated event no matter what", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/274", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "curatePool emits Curated event no matter what"}, {"title": "You can vote for proposal still not existent", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/273", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "You can vote for proposal still not existent"}, {"title": "Swap fee not applied", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/272", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "Swap fee not applied"}, {"title": "listAnchor sets _isCurated to true but forgets other parts of curation", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/271", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "listAnchor sets _isCurated to true but forgets other parts of curation"}, {"title": "_recordBurn does not handle 0 _eth appropriately", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/269", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _recordBurn should validate that _eth > 0. Now it is possible to spam this function with 0 eth burns and fictitiously increase member statistics.  I have previously reported this issue in a Vader's contest. You can read find details here: https://github.com/code-423n4/2021-04-vader-findings/issues/269  ## Recommended Mitigation Steps Handle case when _eth = 0 in function _recordBurn.  "}, {"title": "Function can be simplified", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/263", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Function can be simplified"}, {"title": "Token can be burn through transfer", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/262", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "Token can be burn through transfer"}, {"title": "Use Keccak256 over Sha256 for string comparation", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/258", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Use Keccak256 over Sha256 for string comparation"}, {"title": "Not needed check for uint > 0", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/256", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  s1m0   # Vulnerability details  ## Impact The following functions check that an uint > 0 but it's always true.  ## Proof of Concept https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L278 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L197 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L127  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Remove the checks.  "}, {"title": "Divide before multiply", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/255", "labels": ["bug", "question", "2 (Med Risk)"], "target": "2021-04-vader-findings", "body": "Divide before multiply"}, {"title": "Gas improvement", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/253", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Gas improvement"}, {"title": "Store using Struct over multiple mappings", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/252", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Store using Struct over multiple mappings"}, {"title": "Difference from whitepaper", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/251", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-vader-findings", "body": "Difference from whitepaper"}, {"title": "Events not emitted", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/250", "labels": ["bug", "disagree with severity", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  s1m0   # Vulnerability details  ## Impact Events not emitted for important state changes. https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L93 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L98 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L196 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L201 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L61 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L163 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L171 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L179 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L184 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L188 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L193 https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L198  ## Proof of Concept -  ## Tools Used Manual analysis.  ## Recommended Mitigation Steps Emit events with meaningful names for the changes made.  "}, {"title": "Tokens can get locked and funds lost when minting is disabled in Vader.sol and USDV.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/238", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The flipMinting() function can disable/stop conversion/redeeming of VADER<>USDV tokens upon DAO approval (when that functionality is added). When minting is disabled (i.e. false), the convert functions in USDV.sol accept VADER tokens from sender (L170) but do not burn them to mint the sender the equivalent USDV tokens. When minting is disabled (i.e. false), the redeem functions in USDV.sol accept USDV tokens from sender (L188) but do not burn them to mint the sender the equivalent VADER tokens. Both paths silently return 0 without reverting the transaction thus trapping the sent tokens and leaving the users with lost funds. Protocol will break and funds will be lost.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L171-L177  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L174-L181  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L165-L172  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L183-L191  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L238-L243   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Revert in the paths (instead of silently returning) when minting is disabled so that tokens are not accepted for conversion or redemption.  "}, {"title": "Add anchor map", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/236", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  `Router.updateAnchorPrice` iterates over all anchor tokens on each update which is very inefficient and does a lot of expensive storage loads. add a mapping `address => index` to easily retrieve the index of the token in the `arrayAnchors` mapping.  "}, {"title": "`DAO.mapPID_finalised` is never read in the contract, only written", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  `DAO.mapPID_finalised` is never read in the contract, only written. Remove it and show the `finalized` state in the frontend based on whether the `FinalisedProposal` event was emitted  "}, {"title": "cache `proposalCount` instead of accessing it three times in `newGrantProposal`/`newAddressProposal`", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/232", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "cache `proposalCount` instead of accessing it three times in `newGrantProposal`/`newAddressProposal`"}, {"title": "ERC20 return values not checked", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/231", "labels": ["bug", "2 (Med Risk)", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter should checked for success.  See `Unlock.recordKeyPurchase` which performs ERC20 transfers without checking for the return value.  ## Impact As the trusted `udt` token is used which supposedly reverts on failed transfers, not checking the return value does not lead to any security issues. We still recommend checking it to abide by the EIP20 standard.  ## Recommended Mitigation Steps Consider using `require(IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward), \"transfer failed\")` instead.  "}, {"title": " `Protection` event not used", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/230", "labels": ["bug", "0 (Non-critical)", "filed"], "target": "2021-04-vader-findings", "body": " `Protection` event not used"}, {"title": "Completed proposals can be voted on and executed again", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/229", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "filed"], "target": "2021-04-vader-findings", "body": "Completed proposals can be voted on and executed again"}, {"title": "Canceled proposals can still be executed", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/228", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  Proposals that passed the threshold (\"finalized\") can be cancelled by a minority again using the `cancelProposal` functions. It only sets `mapPID_votes` to zero but `mapPID_timeStart` and `mapPID_finalising` stay the same and pass the checks in `finaliseProposal` which queues them for execution.  ## Impact  Proposals cannot be cancelled.  ## Recommended Mitigation Steps  Set a cancel flag and check for it in `finaliseProposal` and in execution.   "}, {"title": "Proposals can be cancelled", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/227", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  Anyone can cancel any proposals by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`. This always passes the minority check as the proposal was approved.  ## Impact  An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.  ## Recommended Mitigation Steps  Check `oldProposalID == newProposalID`   "}, {"title": "Vault Weight accounting is wrong for withdrawals", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/224", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  When depositing two different synths, their weight is added to the same `mapMember_weight[_member]` storage variable. When withdrawing the full amount of one synth with `_processWithdraw(synth, member, basisPoints=10000` the full weight is decreased.  The second deposited synth is now essentially weightless.  ## Impact  Users that deposited more than one synth can not claim their fair share of rewards after a withdrawal.  ## Recommended Mitigation Steps  The weight should be indexed by the synth as well.   "}, {"title": "Vault rewards last claim time not always initialized", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/223", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `harvest` calls `calcCurrentReward` which computes `_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];`. As one can claim different synths than the synths that they deposited, `mapMemberSynth_lastTime[member][synth]` might still be uninitialized and the `_secondsSinceClaim` becomes the current block timestamp.  ## Impact  The larger the `_secondsSinceClaim` the larger the rewards. This bug allows claiming a huge chunk of the rewards.  ## Recommended Mitigation Steps  Let users only harvest synths that they deposited.   "}, {"title": " Vault rewards can be gamed", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/222", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `_deposit` function increases the member's _weight_ by `_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);` which is the swap output amount when trading the deposited underlying synth amount.  Notice that anyone can create synths of custom tokens by calling `Pools.deploySynth(customToken)`.  Therefore an attacker can deposit valueless custom tokens and inflate their member weight as follows:  1. Create a custom token and issue lots of tokens to the attacker 2. Create synth of this token 3. Add liquidity for the `TOKEN <> BASE` pair by providing a single wei of `TOKEN` and `10^18` BASE tokens. This makes the `TOKEN` price very expensive. 4. Mint some synths by paying BASE to the pool 5. Deposit the fake synth, `_weight` will be very high because the token pool price is so high.  Call `harvest(realSynth)` with a synth with actual value. This will increase the synth balance and it can be withdrawn later.  ## Impact  Anyone can inflate their member weight through depositing a custom synth and earn almost all vault rewards by calling `harvest(realSynth)` with a valuable \"real\" synth. The rewards are distributed pro rata to the member weight which is independent of the actual synth deposited.  ## Recommended Mitigation Steps  The `calcReward` function completely disregards the `synth` parameter which seems odd. Think about making the rewards based on the actual synths deposited instead of a \"global\" weight tracker. Alternatively, whitelist certain synths that count toward the weight, or don't let anyone create synths.   "}, {"title": "Fee can be at most 1% and dead code", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/221", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "Fee can be at most 1% and dead code"}, {"title": "Transfer fee is burned on wrong accounts", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/220", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Vader._transfer` function burns the transfer fee on `msg.sender` but this address might not be involved in the transfer at all due to `transferFrom`.  ## Impact  Smart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality.  ## Recommended Mitigation Steps  It should first increase the balance of `recipient` by the full amount and then burn the fee on the `recipient`.  "}, {"title": "Interest debt is capped after a year", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/219", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Utils.getInterestOwed` function computes the `_interestPayment` as:  ```solidity uint256 _interestPayment =   calcShare(       timeElapsed,       _year,       getInterestPayment(collateralAsset, debtAsset)   ); // Share of the payment over 1 year ```  However, `calcShare` caps `timeElpased` to `_year` and therefore the owed interest does not grow after a year has elapsed.  ## Impact  The impact is probably small because the only call so far computes the elapsed time as `block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];` which most likely will never go beyond a year.  It's still recommended to fix the logic bug in case more functions will be added that use the broken function.  ## Recommended Mitigation Steps  Use a different function than `calcShare` that does not cap.   "}, {"title": "`flashProof` is not flash-proof", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/218", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `flashProof` modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block.  However, it performs this check on `tx.origin` and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.  But flash loan attacks are theoretically not limited to the same transaction but to the same block as miners have full control of the block and include several vulnerable transactions back to back. (Think transaction _bundles_ similar to flashbot bundles that most mining pools currently offer.)  A miner can deploy a proxy smart contract relaying all contract calls and call it from a different EOA each time bypassing the `tx.origin` restriction.  ## Impact  The `flashProof` modifier does not serve its purpose.  ## Recommended Mitigation Steps  Try to apply the modifier to individual addresses that interact with the protocol instead of `tx.origin`.  Furthermore, attacks possible with flash loans are usually also possible for whales, making it debatable if adding flash-loan prevention logic is a good practice.   "}, {"title": "Tokens can be stolen through `transferTo`", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/217", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor acknowledged", "filed"], "target": "2021-04-vader-findings", "body": "Tokens can be stolen through `transferTo`"}, {"title": "Wrong `calcAsymmetricShare` calculation", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/214", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The inline-comment defines the number of asymmetric shares as `(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3` but the `Utils.calcAsymmetricShare` function computes `(uA * 2U^2 - 2uU + u^2) / U^3` which is not equivalent as can be seen from the `A^2` term in the first term which does not occur in the second one. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.  ## Impact  The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share which is used to determine the collateral value in base tokens could be wrong. For example, it might be possible to borrow more than the collateral put up.  ## Recommended Mitigation Steps  Clarify if the comment is correct or the code and fix them.   "}, {"title": "getAnchorPrice potentially returns the wrong median", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/213", "labels": ["bug", "disagree with severity", "1 (Low Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The `Router.getAnchorPrice` sorts the `arrayPrices` array and always returns the third element `_sortedAnchorFeed[2]`. This only returns the median if `_sortedAnchorFeed` is of length 5, but it can be anything from `0` to `anchorLimit`.  ## Impact  If not enough anchors are listed initially, it might become out-of-bounds and break all contract functionality due to revert, or return a wrong median. If `anchorLimit` is set to a different value than 5, it's also wrong.  ## Recommended Mitigation Steps  Check the length of `_sortedAnchorFeed` and return `_sortedAnchorFeed[_sortedAnchorFeed.length / 2]` if it's odd, or the average of the two in the middle if it's even.   "}, {"title": "Replacing an anchor does not reset `Pool.isAnchor`", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/212", "labels": ["bug", "disagree with severity", "sponsor acknowledged", "0 (Non-critical)", "filed"], "target": "2021-04-vader-findings", "body": "Replacing an anchor does not reset `Pool.isAnchor`"}, {"title": "Anyone can list anchors / curate tokens", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/211", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2021-04-vader-findings", "body": "Anyone can list anchors / curate tokens"}, {"title": "Anyone can curate pools and steal rewards", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/210", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2021-04-vader-findings", "body": "Anyone can curate pools and steal rewards"}, {"title": "Wrong slippage protection on Token -> Token trades", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/209", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Router.swapWithSynthsWithLimit` allows trading token to token and specifying slippage protection. A token to token trade consists of two trades:  1. token to base 2. base to token  The slippage protection of the second trade (base to token) is computed wrong:  ```solidity require(iUTILS(UTILS()).calcSwapSlip(         inputAmount, // should use outToken here from prev trade         iPOOLS(POOLS).getBaseAmount(outputToken)   ) <= slipLimit ); ```  It compares the **token** input amount (of the first trade) to the **base** reserve of the second pair.  ## Impact  Slippage protection fails and either the trade is cancelled when it shouldn't be or it is accepted even though the user suffered more losses than expected.  ## Recommended Mitigation Steps  It should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.   "}, {"title": "Missing access restriction on `lockUnits/unlockUnits`", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/208", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pool.lockUnits` allows anyone to steal pool tokens from a `member` and assign them to `msg.sender`.  ## Impact  Anyone can steal pool tokens from any other user.  ## Recommended Mitigation Steps  Add access control and require that `msg.sender` is the router or another authorized party.   "}, {"title": "4 Synths can be minted with fake base token", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/207", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pools.mintSynth` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `mintSynth(token, token, member)`.  The `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.  ## Impact  It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased.  The amount that is minted could also be inflated (cheaper than sending the actual base tokens), especially if `token` is a high-precision token or worth less than base.  ## Recommended Mitigation Steps  Check that `base` is either `USDV` or `VADER` in `mintSynth`.   "}, {"title": "`getAddedAmount` can return wrong results", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/206", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `getAddedAmount` function only works correctly when called with `(VADER/USDV, pool)` or `(pool, pool)`. However, when called with (`token, pool)` where `token` is neither `VADER/USDV/pool`, it returns wrong results:  1. It gets the `token` balance 2. And subtracts it from the stored `mapToken_tokenAmount[_pool]` amount which can be that of a completely different token  ## Impact  Anyone can break individual pairs by calling `sync(token1, token2)` where the `token1` balance is less than `mapToken_tokenAmount[token2]`. This will add the difference to `mapToken_tokenAmount[token2]` and break the accounting and result in a wrong swap logic.  Furthermore, this can also be used to swap tokens without having to pay anthing with `swap(token1, token2, member, toBase=false)`.  ## Recommended Mitigation Steps  Add a require statement in the `else` branch that checks that `_token == _pool`.   "}, {"title": "Swap token can be traded as fake base token", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/205", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details  ## Vulnerability Details  The `Pools.swap` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `swap(token, token, member, toBase=false)`.  The `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.  ## Impact  It breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased (and `token` decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.  Another example scenario is that the token pool amount can be stolen. Send `tokenIn=baseAmount` of tokens to the pool and call `swap(base=token, token, member, toBase=false)`. Depending on the price of `token` relative to `base` this could be cheaper than trading with the base tokens.  ## Recommended Mitigation Steps  Check that `base` is either `USDV` or `VADER`  "}, {"title": "Wrong liquidity units calculation", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/204", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed", "filed"], "target": "2021-04-vader-findings", "body": "# Handle  @cmichelio   # Vulnerability details   ## Vulnerability Details  The spec defines the number of LP units to be minted as `units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments` but the `Utils.calcLiquidityUnits` function computes `((P * part1) + part2) / part3 * slipAdjustments`. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.  ## Impact  The math from the spec is not correclty implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.  ## Recommended Mitigation Steps  Fix the equation.   "}, {"title": "Uninitialized variable leads to zero-fees for first transfer in Vader.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/203", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "Uninitialized variable leads to zero-fees for first transfer in Vader.sol"}, {"title": "Incorrect burn address in Vader.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/202", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The internal _transfer() function is called from external facing transfer(), transferFrom() and transferTo() functions all of which have different sender addresses. It is msg.sender for transfer(), sender parameter for transferFrom() and tx.origin for transferTo(). These different senders are reflected in the sender parameter of _transfer() function. While this sender parameter is correctly used for transfer of tokens within _transfer, the call to _burn() on L129 incorrectly uses msg.sender as the burn address which is correct only in the case of the transfer() caller's context. This is incorrect for transferFrom() and transferTo() caller contexts.  This will incorrectly burn the fees from a different (intermediate contract) account for all users of the protocol interacting with the transferTo() and transferFrom() functions and lead to incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L129  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L122-L134  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L91-L94  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L108-L112  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L116-L119    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change L129 to: _burn(sender, _fee);   "}, {"title": "Gas Optimization: DAO.sol Unnecessary Multiple Return Statements", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/200", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  jvaqa   # Vulnerability details  ## Impact Gas Optimization: DAO.sol Unnecessary Multiple Return Statements  ## Recommended Mitigation Steps  In DAO.sol, replace this:  if(votes > consensus){     return true; } else {     return false; }  With this:  return (votes > consensus)  "}, {"title": "Gas Optimization: Utils.sol Make An Unnecessary Multiplication And Division By An Identical Value", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/199", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  jvaqa   # Vulnerability details  ## Impact  Gas Optimization: Utils.sol Make An Unnecessary Multiplication And Division By An Identical Value  The value \"(T1 * B1) / T1\" is identical to the value \"B1\", so you can simplify the expression \"B1 + (T1 * B1) / T1\" to \"B1 + B1\".  ## Recommended Mitigation Steps  In Utils.sol, replace this:  uint _redemptionValue = B1 + (T1 * B1) / T1;   With this:  uint _redemptionValue = B1 + B1;  "}, {"title": "Gas Optimization: Vader.sol Unnecessary Conditional", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/197", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  jvaqa   # Vulnerability details  ## Impact  Gas Optimization: Vader.sol Unnecessary Conditional  You can remove this conditional entirely.  ## Recommended Mitigation Steps  In Vader.sol, change this:  if(emitting){         emitting = false;     } else {         emitting = true;     }  To this:  emitting = !emitting;  "}, {"title": "The Calculation For nextEraTime Drifts, Causing Eras To Occur Further And Further Into The Future", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/193", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "The Calculation For nextEraTime Drifts, Causing Eras To Occur Further And Further Into The Future"}, {"title": "Gas Optimization: Avoid Unnecessary Expensive SSTORE Calls In Vether.sol By Checking If _fee Is Non-Zero", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/191", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  jvaqa   # Vulnerability details  ## Impact  Avoid Unnecessary Expensive SSTORE Calls In Vether.sol By Checking If _fee Is Non-Zero  SSTORE calls (writes to storage) are very expensive, especially for cold-storage slots (those that have not yet been accessed this transaction). We know that the SSTORE call to totalFees will be a cold storage call, since this is the only place in the whole contract that totalFees is used. Vether.sol makes two SSTORE calls in _transfer that are unnecessary when _fee is zero. It will be common for _fee to be zero, since Vether.sol implements an \"excluded addresses\" list (mapAddress_Excluded), where _fee is zero when either the sender or the recipient is on the excludedAddresses list. Currently, anyone can add themselves to the excludedAddresses list, but that is probably a mistake.  Nevertheless, since it will probably at least include Uniswap, we should add a check for whether _fee is zero.  ## Proof of Concept When _fee is zero, Vether._transfer() nevertheless makes these two unnecessary SSTORE calls:  _balances[address(this)] += _fee; totalFees += _fee;  ## Recommended Mitigation Steps  Change this:  _balances[address(this)] += _fee; totalFees += _fee;  To this:  if(_fee > 0){   _balances[address(this)] += _fee;   totalFees += _fee; }    "}, {"title": "Gas Optimization: Remove Overflow Check in Vether.sol Since Solidity 0.8.x Disallows Implicit Overflows", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/190", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Gas Optimization: Remove Overflow Check in Vether.sol Since Solidity 0.8.x Disallows Implicit Overflows"}, {"title": "Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List.", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/189", "labels": ["bug", "disagree with severity", "3 (High Risk)"], "target": "2021-04-vader-findings", "body": "Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List."}, {"title": "Flash loans can affect governance voting in DAO.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/187", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor disputed"], "target": "2021-04-vader-findings", "body": "Flash loans can affect governance voting in DAO.sol"}, {"title": "Unnecessary logic that will never get triggered in DAO.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/186", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The conditional checking if proposal has quorum in finaliseProposal() is unnecessary and will never be triggered because finalising proposals will always have quorum. Proposal without quorum are not finalised in the voteProposal() function.  Removing this code will reduce contract size and save some gas.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L114-L116  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L82-L90  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L94-L99   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove code from L114 to L116.  "}, {"title": "Undefined behavior for DAO and GRANT vote proposals in DAO.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/183", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-04-vader-findings", "body": "Undefined behavior for DAO and GRANT vote proposals in DAO.sol"}, {"title": "Perform early input validation of zero-address for efficiency in DAO.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/182", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Instead of performing a zero-address check in moveRewardAddress on L146 or L152, it is more efficient to do so in newAddressProposal() as soon as the new address is proposed, instead of allowing a proposal for zero-address which goes through the whole voting process. If there is a requirement for zero-address proposals, it should be specified explicitly.  Depending on the participation in the voting process, this will save significant amount of gas for all the participants.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L69-L74  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L144-L154  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Perform input validation of zero-address in newAddressProposal() for proposedAddress parameter.   "}, {"title": "Gas savings by replacing public visibility with internal/private for isEqual() function of DAO.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/181", "labels": ["bug", "G (Gas Optimization)", "filed"], "target": "2021-04-vader-findings", "body": "Gas savings by replacing public visibility with internal/private for isEqual() function of DAO.sol"}, {"title": "changeDAO should be a two-step process in Vader.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/162", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  changeDAO() updates\u00a0DAO address in one-step. If an incorrect address is mistakenly used (and voted upon) then future administrative access or recovering from this mistake is prevented because onlyDAO modifier is used for changeDAO(), which requires\u00a0msg.sender\u00a0to be the incorrectly used\u00a0DAO\u00a0address (for which private keys may not be available to sign transactions).  Reference: See finding #6 from Trail of Bits audit of Hermez Network: https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L192-L196   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Use a two-step process where the old DAO address first proposes new ownership in one transaction and a second transaction from the newly proposed DAO address accepts ownership. A mistake in the first step can be recovered by granting with a new correct address again before the new DAO address accepts ownership. Ideally, there should also be a timelock enforced before the new DAO takes effect.   "}, {"title": "Missing DAO functionality to call changeDAO() function in Vader.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/161", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-04-vader-findings", "body": "Missing DAO functionality to call changeDAO() function in Vader.sol"}, {"title": "Missing input validation may set rewardAddress to zero-address in Vader.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/160", "labels": ["bug", "disagree with severity", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Function setRewardAddress is used by DAO to change rewardAddress from USDV to something else. However, there is no zero-address validation on the address. This may accidentally mint rewards to zero-address.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L80  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L209  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L183-L186   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add zero-address check to setRewardAddress.  "}, {"title": "Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/155", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-04-vader-findings", "body": "Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol"}, {"title": "Gas savings by removing state variable baseline in Vader.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/153", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Gas savings by removing state variable baseline in Vader.sol"}, {"title": "Gas savings by converting storage variable to immutable in Vader.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/149", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  From Solidity\u2019s documentation (https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables), \u201cState variables can be declared as\u00a0constant\u00a0or\u00a0immutable. In both cases, the variables cannot be modified after the contract has been constructed. For\u00a0constant variables, the value has to be fixed at compile-time, while for\u00a0immutable, it can still be assigned at construction time. The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value. Compared to regular state variables, the gas costs of constant and immutable variables are much lower.\u201d  The burnAddress variable  can be made immutable. This will avoid the use of one storage slot and lead to gas savings.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L36   https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L71  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Make burnAddress immutable.   "}, {"title": "Missing DAO functionality to call setParams() function in USDV.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/140", "labels": ["bug", "disagree with severity", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "Missing DAO functionality to call setParams() function in USDV.sol"}, {"title": "Flash attack mitigation does not work as intended in USDV.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/138", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  One of the stated protocol (review) goals is to detect susceptibility to \u201cAny attack vectors using flash loans on Anchor price, synths or lending.\u201d As such, USDV contract aims to protect against flash attacks using flashProof() modifier which uses the following check in isMature() to determine if currently executing contract context is at least blockDelay duration ahead of the previous context: lastBlock[tx.origin] + blockDelay <= block.number  However, blockDelay state variable is not initialized which means it has a default uint value of 0. So unless it is set to >= 1 by setParams() which can be called only by the DAO (which currently does not have the capability to call setParams() function), blockDelay will be 0 which allows current executing context (block.number) to be the same as the previous one (lastBlock[tx.origin]). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks as opposed to what is expected as commented on L41: \"// Stops an EOA doing a flash attack in same block\"  Even if the DAO can call setParams() to change blockDelay to >= 1, there is a big window of opportunity for flash attacks until the DAO votes, finalises and approves such a proposal. Moreover, such proposals can be cancelled by a DAO minority or replaced by a malicious DAO minority to launch flash attacks.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L22  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L140-L142  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L35-L44  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L174    ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Initialize blockDelay to >= 1 at declaration or in constructor.   "}, {"title": "Gas savings by declaring state variables constant in USDV.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  From Solidity\u2019s documentation (https://docs.soliditylang.org/en/v0.8.4/contracts.html#constant-and-immutable-state-variables), \u201cState variables can be declared as\u00a0constant\u00a0or\u00a0immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for\u00a0immutable, it can still be assigned at construction time. The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value. Compared to regular state variables, the gas costs of constant and immutable variables are much lower.\u201d  State variables name, symbol and decimals can be declared as constants and assigned at declaration (instead of constructor) because they are never modified later. This avoid 3 storage slots and associated expensive SSTOREs/SLOADs to save gas.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L12-L13   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Declare state variables name, symbol and decimals as constant.   "}, {"title": "Unhandled return value of transfer in transferOut() of Pools.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/128", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor disputed"], "target": "2021-04-vader-findings", "body": "Unhandled return value of transfer in transferOut() of Pools.sol"}, {"title": "Incorrect operator used in deploySynth() of Pools.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/124", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The deploySynth() function in Pools.sol is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory\u2019s deploySynth() function.   However, the require() incorrectly uses \u2018||\u2019 operator instead of \u2018&&\u2019 which allows both VADER and USDV to be supplied as the token parameters. This will allow an attacker to deploy either VADER or USDV as a Synth which will break assumptions throughout the entire protocol. Protocol will break and funds may be lost.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L138   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change \u2018||\u2019 operator to \u2018&&\u2019 in the require statement: require(token != VADER && token != USDV);   "}, {"title": "User may not get IL protection if certain functions are called directly in Pools.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/120", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-04-vader-findings", "body": "User may not get IL protection if certain functions are called directly in Pools.sol"}, {"title": "Gas savings by removing unused state variable _isMember and related getter function isMember() in Pools.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/118", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  _isMember mapping state variable is declared and used only in the getter function isMember(), but is net assigned to anywhere in the contract. This will consume an unnecessary storage slot and along with its getter function will also increase the contract size.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L22  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L215-L217   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove _isMember state variable declaration on L22 and related getter function isMember().   "}, {"title": "Pool functions can be called before initialization in init() of Pools.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/114", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "sponsor disputed"], "target": "2021-04-vader-findings", "body": "Pool functions can be called before initialization in init() of Pools.sol"}, {"title": "Gas savings by moving inited bool state variable next to an address state variable declaration in Pools.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  A bool in Solidity is internally represented as a unit8 and so required only 8 bits of the 256-bits storage slot. An address variable is 160-bits. So declaring a bool next to an address variable lets Solidity pack them in the same storage slot thereby using one slot instead of two.  Moving the inited bool state variable next to one of the address state variables VADER, USDV, ROUTER or FACTORY lets the compiler pack them together in one storage slot instead of two, thereby saving one slot. It costs 20k gas to SSTORE each slot of data.  The current order where inited bool is declared before uint does not allow packing because uint itself requires the entire 256-bits of a slot, which forces the compiler to use one full slot for the inited bool variable.  For reference, see https://mudit.blog/solidity-gas-optimization-tips/  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L13-L20   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Move inited bool state variable declaration next to an address state variable declaration.   "}, {"title": "Public functions getSynth() and isSynth() are commented out in Factory.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/110", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-vader-findings", "body": "Public functions getSynth() and isSynth() are commented out in Factory.sol"}, {"title": "Missing event for critical init() function in Factory.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/108", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "Missing event for critical init() function in Factory.sol"}, {"title": "Gas savings by removing unnecessary conditional in isCurated() function of Router.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/100", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Gas savings by removing unnecessary conditional in isCurated() function of Router.sol"}, {"title": "Gas savings by breaking from loop after match+replace in replaceAnchor() of Router.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  If the requirement is that listed anchors are unique token addresses, then the loop in replaceAnchor() can break upon match+replace to save gas from executing more loop iterations.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L261-L265   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Add a break statement after L263.   "}, {"title": "Gas savings by saving state variable in a memory for loop access in replaceAnchor() of Router.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/90", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Gas savings by saving state variable in a memory for loop access in replaceAnchor() of Router.sol"}, {"title": "Lack of input validation in replacePool() allows curated pool limit bypass in Router.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  There is no input validation in replacePool() function to check if oldToken exists and is curated. Using a non-existing oldToken (even 0 address) passes the check on L236 (because Pools.getBaseAmount() will return 0 for the non-existing token) and newToken will be made curated. This can be used to bypass the curatedPoolLimit enforced only in curatePool() function.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L234-L241  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L227-L229  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L227  ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Check if oldToken exists and is curated as part of input validation in replacePool() function.   "}, {"title": "Default value of curatedPoolLimit allows only one curated pool in Router.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/86", "labels": ["bug", "disagree with severity", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-vader-findings", "body": "Default value of curatedPoolLimit allows only one curated pool in Router.sol"}, {"title": "Gas savings by changing getILProtection() function\u2019s public visibility to internal/private in Router.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/85", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Gas savings by changing getILProtection() function\u2019s public visibility to internal/private in Router.sol"}, {"title": "Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/84", "labels": ["bug", "disagree with severity", "3 (High Risk)", "sponsor disputed"], "target": "2021-04-vader-findings", "body": "Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol"}, {"title": "Gas savings by removing unused state variable repayDelay in Router.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  repayDelay uint state variable is declared but never used elsewhere. This will consume an unnecessary storage slot and also increase the contract size.  ## Proof of Concept https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Router.sol#L35   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Remove repayDelay state variable declaration on L35.   "}, {"title": "Copy-paste bug leading to incorrect harvest rewards in Vault.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/51", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The conditional in calcReward() function uses the same code in both if/else parts with repeated use of reserveUSDV, reserveVADER and getUSDVAmount leading to incorrect computed value of _adjustedReserve in the else part.  This will affect harvest rewards for all users of the protocol and lead to incorrect accounting. Protocol will break and lead to fund loss.  ## Proof of Concept  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L141  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L144  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L125  https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L105   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Change variables and function calls from using USDV to VADER in the else part of the conditional which has to return the adjusted reserves when synth is not an asset i.e. an anchor and therefore base is VADER.  L144 should be changed to: uint _adjustedReserve = iROUTER(ROUTER).getVADERAmount(reserveUSDV()) + reserveVADER();   "}, {"title": "Named return variable in harvest() and other functions of Vault.sol and contracts", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/50", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-vader-findings", "body": "Named return variable in harvest() and other functions of Vault.sol and contracts"}, {"title": "Misleading comment for deposit() function of Vault.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/48", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-vader-findings", "body": "Misleading comment for deposit() function of Vault.sol"}, {"title": "Gas savings by avoiding re-initialization of POOLS variable in init() function of Vault.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/43", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "Gas savings by avoiding re-initialization of POOLS variable in init() function of Vault.sol"}, {"title": "Vader.redeemToMember() vulnerable to front running", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/36", "labels": ["bug", "disagree with severity", "2 (Med Risk)", "sponsor disputed"], "target": "2021-04-vader-findings", "body": "Vader.redeemToMember() vulnerable to front running"}, {"title": "ERC20 race condition for allowances", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-vader-findings", "body": "ERC20 race condition for allowances"}, {"title": "Transfer fee avoidance ", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/33", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor disputed"], "target": "2021-04-vader-findings", "body": "Transfer fee avoidance "}, {"title": "totalBurnt might be wrong", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/32", "labels": ["bug", "disagree with severity", "1 (Low Risk)", "sponsor disputed"], "target": "2021-04-vader-findings", "body": "totalBurnt might be wrong"}, {"title": "Pay double fees in addExcluded of Vether.sol", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-04-vader-findings", "body": "Pay double fees in addExcluded of Vether.sol"}, {"title": "Optimization possible at _transfer", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-04-vader-findings", "body": "Optimization possible at _transfer"}, {"title": "Different pragma solidity", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/25", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-04-vader-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Vault.sol has a different pragma statement than the rest, it contains an additional \"^\".  For the record the Vether.sol contract (as deployed here https://etherscan.io/address/0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279#code),  has a different solidity version.  It's cleaner to use the same versions.  ## Proof of Concept  DAO.sol:pragma solidity 0.8.3; Factory.sol:pragma solidity 0.8.3; Pools.sol:pragma solidity 0.8.3; Router.sol:pragma solidity 0.8.3; Synth.sol:pragma solidity 0.8.3; USDV.sol:pragma solidity 0.8.3; Utils.sol:pragma solidity 0.8.3; Vader.sol:pragma solidity 0.8.3; Vault.sol:pragma solidity ^0.8.3; Vether.sol:pragma solidity 0.6.4;  ## Tools Used Editor  ## Recommended Mitigation Steps Use the same solidity versions   "}, {"title": "Functions with implicit return values", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/24", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-04-vader-findings", "body": "Functions with implicit return values"}, {"title": "Result of ERC20 transfer not checked", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function transferOut of Pools.sol contains a iERC20(_token).transfer where the result of the function isn't checked. This could result in transfers that don't succeed are undetected.  ## Proof of Concept Pools.sol:   function transferOut(address _token, uint _amount, address _recipient) internal {         if(_token == VADER){             pooledVADER = pooledVADER - _amount; // Accounting         } else if(_token == USDV) {             pooledUSDV = pooledUSDV - _amount;  // Accounting         }         if(_recipient != address(this)){             iERC20(_token).transfer(_recipient, _amount);         }     }  ## Tools Used Editor  ## Recommended Mitigation Steps Add a require statement to check the result: require(...transfer(...) )   "}, {"title": "Not always reason at require", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/20", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-04-vader-findings", "body": "Not always reason at require"}, {"title": "sortArray optimizable", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/19", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-vader-findings", "body": "sortArray optimizable"}, {"title": "Init function can be called by everyone", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/18", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-04-vader-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.  ## Proof of Concept  DAO.sol:    function init(address _vader, address _usdv, address _vault) public { Factory.sol:    function init(address _pool) public { Pools.sol:    function init(address _vader, address _usdv, address _router, address _factory) public { Router.sol:    function init(address _vader, address _usdv, address _pool) public { USDV.sol:    function init(address _vader, address _vault, address _router) external { Utils.sol:    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public { Vader.sol:    function init(address _vether, address _USDV, address _utils) external { Vault.sol:    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {    ## Tools Used Editor  ## Recommended Mitigation Steps Add a check to the init function, for example that only the deployer can call the function.  "}, {"title": "Some  unused code", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact There is some unused / redundant code present.  Router.sol defines repayDelay but it is never used Vault.sol initializes POOLS twice, with the same value.  ## Proof of Concept Router.sol: uint public repayDelay = 3600;  Vault.sol:  function init(address _vader, address _usdv, address _router, ... ..         POOLS = _pool; ..           POOLS = _pool;     ## Tools Used Editor  ## Recommended Mitigation Steps Remove redundant code  "}, {"title": "Public function that could be declared external", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "addressed"], "target": "2021-04-vader-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact public functions that are never called by the contract should be declared external to save gas.  ## Proof of Concept  1. In Vault.sol  -- > init() and grant()                     https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L45  https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vault.sol#L68  2. Vader.sol -- > burn()    https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Vader.sol#L146  3. Utils.sol -- > init(),  getProtection()   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Utils.sol#L30  4. Router.sol -- >  init(address,address,address)  getVADERAmount(uint256)  getUSDVAmount(uint256)  borrow(uint256,address,address)  repay(uint256,address,address)  checkLiquidate() getSystemCollateral(address,address)  getSystemDebt(address,address) getSystemInterestPaid()   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L77  5. Pools.sol  init(address,address,address,address)  isMember(address)  isSynth(address)   https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol  6. Dao.sol  init(address,address,address)  newGrantProposal(address,uint256)  newAddressProposal(address,string)  voteProposal(uint256)  cancelProposal(uint256,uint256)  finaliseProposal(uint256)  https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/DAO.sol#L46    ## Tools Used  slither  ## Recommended Mitigation Steps  use external instead of public visibility to save gas  "}, {"title": "Lack of zero address validation in init() function", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/12", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-04-vader-findings", "body": "Lack of zero address validation in init() function"}, {"title": "events can be emitted  even after failed transaction", "html_url": "https://github.com/code-423n4/2021-04-vader-findings/issues/6", "labels": ["bug", "disagree with severity", "1 (Low Risk)", "sponsor disputed"], "target": "2021-04-vader-findings", "body": "events can be emitted  even after failed transaction"}, {"title": "Using calldata when not appropiate", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/100", "labels": ["bug", "0 (Non-critical)", "Disputed"], "target": "2021-05-nftx-findings", "body": "Using calldata when not appropiate"}, {"title": "Revert inside a loop", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "Acknowledged"], "target": "2021-05-nftx-findings", "body": "Revert inside a loop"}, {"title": "Two Duplicate \"rescueTokens\" Functions In NFTXFeeDistributor ", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/91", "labels": ["bug", "duplicate", "0 (Non-critical)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Two Duplicate \"rescueTokens\" Functions In NFTXFeeDistributor "}, {"title": "Incorrect Type Specified For Argument _address In NFTXFeeDistributor.rescueTokens()", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/89", "labels": ["bug", "0 (Non-critical)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Incorrect Type Specified For Argument _address In NFTXFeeDistributor.rescueTokens()"}, {"title": "NFTXLPStaking Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/88", "labels": ["bug", "3 (High Risk)", "Disputed"], "target": "2021-05-nftx-findings", "body": "NFTXLPStaking Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault"}, {"title": "Upgradeable contracts not Upgradeable", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/87", "labels": ["bug", "1 (Low Risk)", "Disputed"], "target": "2021-05-nftx-findings", "body": "Upgradeable contracts not Upgradeable"}, {"title": "__Ownable_init will be called twice in multiple Eligibility contracts", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/84", "labels": ["bug", "1 (Low Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "__Ownable_init will be called twice in multiple Eligibility contracts"}, {"title": "lack of zero address validation", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "lack of zero address validation"}, {"title": "Missing pool existence check in balanceOf", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/80", "labels": ["bug", "1 (Low Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Missing pool existence check in balanceOf"}, {"title": "Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/79", "labels": ["bug", "2 (Med Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  It is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelin\u2019s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L457  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L463  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L489  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L513  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L537  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Consider using safeTransfer/safeTransferFrom or require() consistently.   "}, {"title": "Randomization of NFTs returned in redeem/swap operations can be brute-forced", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/78", "labels": ["bug", "2 (Med Risk)", "Acknowledged"], "target": "2021-05-nftx-findings", "body": "Randomization of NFTs returned in redeem/swap operations can be brute-forced"}, {"title": "Front-running setFees() could avoid fees", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/72", "labels": ["bug", "1 (Low Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Front-running setFees() could avoid fees"}, {"title": "The direct redeem fee can be circumvented", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "Acknowledged"], "target": "2021-05-nftx-findings", "body": "The direct redeem fee can be circumvented"}, {"title": "A malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when receiveRewards is called on their receiver contract.", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "A malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when receiveRewards is called on their receiver contract."}, {"title": "Change function visibility from public to external", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Change function visibility from public to external"}, {"title": "Unused events", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/63", "labels": ["bug", "duplicate", "G (Gas Optimization)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  Unused events increase contract size and gas usage at deployment.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/eligibility/NFTXMintRequestEligibility.sol#L62-L62  ```solidity event Reject(uint256[] nftIds); ```  `Reject` is unused.  "}, {"title": "Unused storage variables", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "Acknowledged", "Confirmed"], "target": "2021-05-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  Unused storage variables in contracts use up storage slots and increase contract size and gas usage at deployment and initialization.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L57-L57 ```solidity=57 address public uniswapV2Factory; ```  "}, {"title": "Semantic Overloading in NFTXUpgradable.sol", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/61", "labels": ["bug", "duplicate", "0 (Non-critical)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Semantic Overloading in NFTXUpgradable.sol"}, {"title": "Tokens can get stuck in `NFTXMintRequestEligibility`", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Tokens can get stuck in `NFTXMintRequestEligibility`"}, {"title": "Potential bug with `reverseEligOnRedeem` / misleading name", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/57", "labels": ["bug", "1 (Low Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Potential bug with `reverseEligOnRedeem` / misleading name"}, {"title": "`getRandomTokenIdFromFund` yields wrong probabilities for ERC1155", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/56", "labels": ["bug", "duplicate", "3 (High Risk)", "Acknowledged"], "target": "2021-05-nftx-findings", "body": "`getRandomTokenIdFromFund` yields wrong probabilities for ERC1155"}, {"title": "Vault's flash loan not implemented according to EIP-3156", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Vault's flash loan not implemented according to EIP-3156"}, {"title": "Vault's `swapTo` can return the input tokens", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/53", "labels": ["bug", "1 (Low Risk)", "Acknowledged"], "target": "2021-05-nftx-findings", "body": "Vault's `swapTo` can return the input tokens"}, {"title": "LockIds not according to spec", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/52", "labels": ["documentation", "0 (Non-critical)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "LockIds not according to spec"}, {"title": "Manager can grief with fees", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/51", "labels": ["bug", "2 (Med Risk)"], "target": "2021-05-nftx-findings", "body": "Manager can grief with fees"}, {"title": "Gas optimization for `StakingTokenProvider.nameForStakingToken`", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Gas optimization for `StakingTokenProvider.nameForStakingToken`"}, {"title": "Unchecked external calls in `NFTXLPStaking`", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/48", "labels": ["bug", "1 (Low Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Unchecked external calls in `NFTXLPStaking`"}, {"title": "Unbounded iteration in `NFTXEligiblityManager.distribute` over `_feeReceivers`", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "Acknowledged"], "target": "2021-05-nftx-findings", "body": "Unbounded iteration in `NFTXEligiblityManager.distribute` over `_feeReceivers`"}, {"title": "`distribute` DoS on missing `receiveRewards` implementation", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/46", "labels": ["bug", "3 (High Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "`distribute` DoS on missing `receiveRewards` implementation"}, {"title": "Missing usage of SafeMath", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/45", "labels": ["bug", "1 (Low Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Missing usage of SafeMath"}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `TreasuryManager.setPriceOracle: oracleAddress`: could break things - `TreasuryManager.setSlippageLimit: slippageLimit`: should be `<= SLIPPAGE_LIMIT_PRECISION`  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  "}, {"title": "Missing overflow check in `flashLoan`", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/43", "labels": ["bug", "duplicate", "3 (High Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Missing overflow check in `flashLoan`"}, {"title": "Unused variables", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/39", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-05-nftx-findings", "body": "Unused variables"}, {"title": "[INFO] function publicMint is for testing only", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/26", "labels": ["bug", "0 (Non-critical)"], "target": "2021-05-nftx-findings", "body": "[INFO] function publicMint is for testing only"}, {"title": "eligibilityManager is always 0x0", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "eligibilityManager is always 0x0"}, {"title": "no check _rangeStart<=_rangeEnd", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/17", "labels": ["bug", "0 (Non-critical)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "no check _rangeStart<=_rangeEnd"}, {"title": "Missing documentation for flashloan paused number", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/14", "labels": ["documentation", "0 (Non-critical)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Missing documentation for flashloan paused number"}, {"title": "Not checked if within array bounds", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/13", "labels": ["bug", "0 (Non-critical)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Not checked if within array bounds"}, {"title": "simpler way to suppress compiler warning", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/12", "labels": ["bug", "0 (Non-critical)", "Acknowledged"], "target": "2021-05-nftx-findings", "body": "simpler way to suppress compiler warning"}, {"title": "Fee Distribution Re-Entrancy", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "Fee Distribution Re-Entrancy"}, {"title": "EIP-721 / EIP-1155 Re-Entrancy Vulnerability", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/8", "labels": ["bug", "3 (High Risk)", "Confirmed"], "target": "2021-05-nftx-findings", "body": "EIP-721 / EIP-1155 Re-Entrancy Vulnerability"}, {"title": "Inconsistent solidity pragma", "html_url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/3", "labels": ["bug", "1 (Low Risk)"], "target": "2021-05-nftx-findings", "body": "Inconsistent solidity pragma"}, {"title": "Beebots.randomIndex() Can Be Manipulated To Not Be Random Without Costing Alice Anything", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/85", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-meebits-findings", "body": "Beebots.randomIndex() Can Be Manipulated To Not Be Random Without Costing Alice Anything"}, {"title": "External over public ", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/84", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-meebits-findings", "body": "External over public "}, {"title": "Optimizations storage", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/83", "labels": ["bug", "G (Gas Optimization)", "style"], "target": "2021-04-meebits-findings", "body": "Optimizations storage"}, {"title": "Constructor lack of zero address validation", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/82", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "Constructor lack of zero address validation"}, {"title": "Randomnesss can be manipulated", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/81", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-meebits-findings", "body": "Randomnesss can be manipulated"}, {"title": "Nonce not modified", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/80", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "Nonce not modified"}, {"title": "Beebots.contentHash() Is Currently Set As \"todo\"", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/79", "labels": ["duplicate", "invalid", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Beebots.contentHash() Is Currently Set As \"todo\""}, {"title": "Beebots.tokenURI() References A Non-Existent Domain at \"TODO\"", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/78", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "Beebots.tokenURI() References A Non-Existent Domain at \"TODO\""}, {"title": "Beebots.TradeValid() Will Erroneously Return True When Maker Is Set To Address(0) and makerIds Are Set To The TokenIds of Unminted Beebot NFTs", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/77", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-meebits-findings", "body": "Beebots.TradeValid() Will Erroneously Return True When Maker Is Set To Address(0) and makerIds Are Set To The TokenIds of Unminted Beebot NFTs"}, {"title": "Can cancel the same offer several times", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/76", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Can cancel the same offer several times"}, {"title": "NFT can be minted for free after sale ended", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/75", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-meebits-findings", "body": "NFT can be minted for free after sale ended"}, {"title": "The randomIndex() can be determined", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/74", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-meebits-findings", "body": "The randomIndex() can be determined"}, {"title": "function tokenByIndex treats last index as invalid", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/73", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-meebits-findings", "body": "function tokenByIndex treats last index as invalid"}, {"title": "function ownerOf does not check if it is a valid _tokenId", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/72", "labels": ["invalid", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "function ownerOf does not check if it is a valid _tokenId"}, {"title": "Use always uint256", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/71", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Use always uint256"}, {"title": "contentHash is not used", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/70", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "contentHash is not used"}, {"title": "PauseMarket() can be optimized", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/69", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-meebits-findings", "body": "PauseMarket() can be optimized"}, {"title": "creatorNftMints is assigned only 0 or 1", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/68", "labels": ["0 (Non-critical)", "G (Gas Optimization)", "style"], "target": "2021-04-meebits-findings", "body": "creatorNftMints is assigned only 0 or 1"}, {"title": "Require() not needed", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/67", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-meebits-findings", "body": "Require() not needed"}, {"title": "Lack of chain information in the signed data leads to potential replay attacks.", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/66", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-meebits-findings", "body": "Lack of chain information in the signed data leads to potential replay attacks."}, {"title": "Should use `SafeMath.add` in the `acceptTrade` function.", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "style"], "target": "2021-04-meebits-findings", "body": "Should use `SafeMath.add` in the `acceptTrade` function."}, {"title": "Nonce does not increase during the entire sale.", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/64", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "Nonce does not increase during the entire sale."}, {"title": "No zero check on constructor inputs.", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/63", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "No zero check on constructor inputs."}, {"title": "The `ownerOf` function requires checking if the owner is non-zero.", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/62", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "The `ownerOf` function requires checking if the owner is non-zero."}, {"title": "Several functions in the ERC721 interface are not declared `payable`.", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/61", "labels": ["invalid"], "target": "2021-04-meebits-findings", "body": "Several functions in the ERC721 interface are not declared `payable`."}, {"title": "cancelOffer() is susceptible to front-running", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/60", "labels": ["invalid", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "cancelOffer() is susceptible to front-running"}, {"title": "Market pause does not pause cancelOffer()", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/59", "labels": ["0 (Non-critical)", "style"], "target": "2021-04-meebits-findings", "body": "Market pause does not pause cancelOffer()"}, {"title": "event Deposit when value is 0", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/58", "labels": ["bug", "0 (Non-critical)", "style"], "target": "2021-04-meebits-findings", "body": "event Deposit when value is 0"}, {"title": "Market pause does not pause tradeValid()", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/57", "labels": ["1 (Low Risk)", "style"], "target": "2021-04-meebits-findings", "body": "Market pause does not pause tradeValid()"}, {"title": "event Mint parameter minter", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "style"], "target": "2021-04-meebits-findings", "body": "event Mint parameter minter"}, {"title": "Design susceptible to taker griefing on acceptTrade()", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/55", "labels": ["enhancement", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "Design susceptible to taker griefing on acceptTrade()"}, {"title": "Signature malleability of EVM's ecrecover in verify()", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/54", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "Signature malleability of EVM's ecrecover in verify()"}, {"title": "mint for 0 cost when the sale is over", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/53", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-04-meebits-findings", "body": "mint for 0 cost when the sale is over"}, {"title": "nonce always remains 0", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/52", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-04-meebits-findings", "body": "nonce always remains 0"}, {"title": "Incorrect use of test parameterization for baseURI value in tokenURI()", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/51", "labels": ["invalid", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Incorrect use of test parameterization for baseURI value in tokenURI()"}, {"title": ".transfer is not safe to use with custom smart contracts", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/50", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-04-meebits-findings", "body": ".transfer is not safe to use with custom smart contracts"}, {"title": "ERC721Metadata Spec mismatch from lack of input validation in tokenURI()", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/49", "labels": ["invalid", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "ERC721Metadata Spec mismatch from lack of input validation in tokenURI()"}, {"title": "ERC-721 Enumerable Spec mismatch for return value of tokenByIndex() function", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/48", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-04-meebits-findings", "body": "ERC-721 Enumerable Spec mismatch for return value of tokenByIndex() function"}, {"title": "ERC-721 Enumerable Spec mismatch for index of tokenByIndex() function", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/47", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-meebits-findings", "body": "ERC-721 Enumerable Spec mismatch for index of tokenByIndex() function"}, {"title": "Potential reentrancy in safeTransferFrom functions", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/46", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-04-meebits-findings", "body": "Potential reentrancy in safeTransferFrom functions"}, {"title": "Use of transfer() may lead to failures", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/45", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-meebits-findings", "body": "Use of transfer() may lead to failures"}, {"title": "Incorrect createVia argument used in mintWithAlphaOrBeta function", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/44", "labels": ["0 (Non-critical)", "style"], "target": "2021-04-meebits-findings", "body": "Incorrect createVia argument used in mintWithAlphaOrBeta function"}, {"title": "Deployer minting to arbitrary addresses could trick/confuse users", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/43", "labels": ["invalid", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Deployer minting to arbitrary addresses could trick/confuse users"}, {"title": "Missing event in critical devMint() function", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/42", "labels": ["1 (Low Risk)", "style"], "target": "2021-04-meebits-findings", "body": "Missing event in critical devMint() function"}, {"title": "ERC-721 Spec mismatch for ownerOf() function", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/41", "labels": ["0 (Non-critical)", "style"], "target": "2021-04-meebits-findings", "body": "ERC-721 Spec mismatch for ownerOf() function"}, {"title": "Missing error messages in require statements of various function", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/40", "labels": ["1 (Low Risk)", "style"], "target": "2021-04-meebits-findings", "body": "Missing error messages in require statements of various function"}, {"title": "Missing event in critical sealContract() function", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/39", "labels": ["duplicate", "enhancement", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "Missing event in critical sealContract() function"}, {"title": "Missing event in critical pauseMarket() function", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/38", "labels": ["duplicate", "enhancement", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "Missing event in critical pauseMarket() function"}, {"title": "Missing parameters in SalesBegin event of critical startSale() function", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/37", "labels": ["enhancement", "1 (Low Risk)", "style"], "target": "2021-04-meebits-findings", "body": "Missing parameters in SalesBegin event of critical startSale() function"}, {"title": "No guarded launch circuit breaker for public sale", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/36", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "No guarded launch circuit breaker for public sale"}, {"title": "Missing zero/threshold check for NFT sale duration", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/35", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-meebits-findings", "body": "Missing zero/threshold check for NFT sale duration"}, {"title": "Missing zero/threshold check for NFT sale price", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/34", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-meebits-findings", "body": "Missing zero/threshold check for NFT sale price"}, {"title": "Missing zero-address check for the beneficiary address", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/33", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-meebits-findings", "body": "Missing zero-address check for the beneficiary address"}, {"title": "Privileged deployer role and capabilities", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/32", "labels": ["invalid", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Privileged deployer role and capabilities"}, {"title": "Gas savings by replacing modifier onlyDeployer with internal function", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/31", "labels": ["0 (Non-critical)", "style"], "target": "2021-04-meebits-findings", "body": "Gas savings by replacing modifier onlyDeployer with internal function"}, {"title": "randomIndex is not truly random - possibility of predictably minting a specific token Id", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/30", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-meebits-findings", "body": "randomIndex is not truly random - possibility of predictably minting a specific token Id"}, {"title": "Explicit initialization with zero not required for nonce", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/29", "labels": ["duplicate"], "target": "2021-04-meebits-findings", "body": "Explicit initialization with zero not required for nonce"}, {"title": "Explicit initialization with false not required for publicSale", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/28", "labels": ["duplicate"], "target": "2021-04-meebits-findings", "body": "Explicit initialization with false not required for publicSale"}, {"title": "Explicit initialization with zero not required for numSales", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/27", "labels": ["duplicate"], "target": "2021-04-meebits-findings", "body": "Explicit initialization with zero not required for numSales"}, {"title": "Explicit initialization with zero not required for numTokens", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/26", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-meebits-findings", "body": "Explicit initialization with zero not required for numTokens"}, {"title": "Incorrect initialization uses test parameterization for sale limit", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/25", "labels": ["invalid", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Incorrect initialization uses test parameterization for sale limit"}, {"title": "Incorrect initialization uses test parameterization for token limit", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/24", "labels": ["invalid", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Incorrect initialization uses test parameterization for token limit"}, {"title": "Atypical contract structure affects maintainability and readability", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/23", "labels": ["0 (Non-critical)", "style"], "target": "2021-04-meebits-findings", "body": "Atypical contract structure affects maintainability and readability"}, {"title": "Clone-and-own approach used for OZ SafeMath library and other code susceptible to errors and missing upstream bug fixes", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/22", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Clone-and-own approach used for OZ SafeMath library and other code susceptible to errors and missing upstream bug fixes"}, {"title": "Unclear `randomIndex` function", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/21", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Unclear `randomIndex` function"}, {"title": "Mint can be front-run", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/20", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "Mint can be front-run"}, {"title": "Usage of `address.transfer`", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/19", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "Usage of `address.transfer`"}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/18", "labels": ["invalid", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Missing parameter validation"}, {"title": "SafeMath library asserts instead of reverts", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/17", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "SafeMath library asserts instead of reverts"}, {"title": "Incorrect Implementation", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/16", "labels": ["bug", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Incorrect Implementation"}, {"title": "Numerous Gas Optimizations", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/15", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-meebits-findings", "body": "Numerous Gas Optimizations"}, {"title": "Legacy Function Usage", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/14", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "Legacy Function Usage"}, {"title": "transfer used", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/13", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "transfer used"}, {"title": "transfer of 0 ETH", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/12", "labels": ["invalid", "0 (Non-critical)", "style"], "target": "2021-04-meebits-findings", "body": "transfer of 0 ETH"}, {"title": "nonce isn't increased", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/11", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "nonce isn't increased"}, {"title": "Not really random", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/10", "labels": ["bug", "1 (Low Risk)"], "target": "2021-04-meebits-findings", "body": "Not really random"}, {"title": "Safemath missing in several places", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/9", "labels": ["invalid", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "Safemath missing in several places"}, {"title": "Check for marketPaused in sealContract", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "style"], "target": "2021-04-meebits-findings", "body": "Check for marketPaused in sealContract"}, {"title": "lack of input validation in ownerOf(uint )", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/7", "labels": ["invalid", "0 (Non-critical)"], "target": "2021-04-meebits-findings", "body": "lack of input validation in ownerOf(uint )"}, {"title": "No zero address checking in contractor", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/6", "labels": ["invalid", "0 (Non-critical)", "style"], "target": "2021-04-meebits-findings", "body": "No zero address checking in contractor"}, {"title": "public function that could be declared external", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/5", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-meebits-findings", "body": "public function that could be declared external"}, {"title": "Arbitrary Transfer of Unowned NFTs", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/4", "labels": ["bug", "3 (High Risk)"], "target": "2021-04-meebits-findings", "body": "Arbitrary Transfer of Unowned NFTs"}, {"title": "state variables that could be declared constant", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/3", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-04-meebits-findings", "body": "state variables that could be declared constant"}, {"title": "instead of call() , transfer() is used to withdraw the ether", "html_url": "https://github.com/code-423n4/2021-04-meebits-findings/issues/2", "labels": ["bug", "2 (Med Risk)"], "target": "2021-04-meebits-findings", "body": "instead of call() , transfer() is used to withdraw the ether"}, {"title": "Unchecking the ownership of `mph` in function `distributeFundingRewards` could cause several critical functions to revert", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/23", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-88mph-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  In contract `MPHMinter`, the function `distributeFundingRewards` does not check whether the contract itself is the owner of `mph`. If the contract is not the owner of `mph`, `mph.ownerMint` could revert, causing functions such as `withdraw`, `rolloverDeposit`, `payInterestToFunders` in the contract `DInterest` to revert as well.  ## Proof of Concept  Referenced code: [MPHMinter.sol#L121](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/rewards/MPHMinter.sol#L121) [DInterest.sol#L1253](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/DInterest.sol#L1253) [DInterest.sol#L1420](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/DInterest.sol#L1420)  ## Tools Used  None  ## Recommended Mitigation Steps  Add a `mph.owner() != address(this)` check as in the other functions (e.g., `mintVested`).  "}, {"title": "Use openzeppelin ECDA for erecover", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/20", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-88mph-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  In `Sponsorable.sol` is using erecover directly to verify the signature. Being such a critical piece of the protocol, I would recommend using the ECDSA from openzeppelin as it does more validations when verifying the signature.   ```  // Currently   address recoveredAddress =       ecrecover(digest, sponsorship.v, sponsorship.r, sponsorship.s);     require(       recoveredAddress != address(0) && recoveredAddress == sponsorship.sender,       \"Sponsorable: invalid sig\"     );     //ECDSA     function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines         // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most         // signatures from current libraries generate a unique signature with an s-value in the lower half order.         //         // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value         // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or         // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept         // these malleable signatures as well.         require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");         require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");          // If the signature is valid (and not malleable), return the signer address         address signer = ecrecover(hash, v, r, s);         require(signer != address(0), \"ECDSA: invalid signature\");          return signer;     }    ``` ## Tools Used  None   "}, {"title": "Gas optimizations - storage over memory", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "resolved"], "target": "2021-05-88mph-findings", "body": "Gas optimizations - storage over memory"}, {"title": "Gas optimizations by using external over public ", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "resolved"], "target": "2021-05-88mph-findings", "body": "Gas optimizations by using external over public "}, {"title": "Incompatability with deflationary / fee-on-transfer tokens", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/16", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-05-88mph-findings", "body": "Incompatability with deflationary / fee-on-transfer tokens"}, {"title": "Anyone can withdraw vested amount on behalf of someone", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/15", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-05-88mph-findings", "body": "Anyone can withdraw vested amount on behalf of someone"}, {"title": "lack of zero address validation in constructor", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/13", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-05-88mph-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact since the parameter of the constructor are used to initialize the sate variable and these state variable are used throughout the contract error in these parameter can lead to redeployment of the contract  ## Proof of Concept  constructor of ctokenAggregator.sol,  NotionalV1ToNotionalV2.sol, nTokenERC20Proxy.sol, Reservoir.sol, PauseRouter.sol lack zero address validation  ## Tools Used manual review  ## Recommended Mitigation Steps add address(0) validation in constructor  "}, {"title": "zero amount  of token value can be entered for creating vest object in  vesting.sol", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/12", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-05-88mph-findings", "body": "zero amount  of token value can be entered for creating vest object in  vesting.sol"}, {"title": "Extra precautions in updateAndQuery", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/10", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-88mph-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function updateAndQuery of EMAOracle.sol subtracts the incomeIndex with the previous incomeIndex. These incomeIndex values are retrieved via the moneyMarket contract from an external contract.  If by accident the previous incomeIndex is larger than the current incomeIndex then the subtraction would be negative and the code halts (reverts), without an error message. Also the updateAndQuery function would not be able to execute (until the current incomeIndex is larger than the previous incomeIndex).  This situation could occur when an error occurs in one of the current or future money markets.  ## Proof of Concept EMAOracle.sol:   function updateAndQuery() {         ...         uint256 _lastIncomeIndex = lastIncomeIndex;         ...         uint256 newIncomeIndex = moneyMarket.incomeIndex();         uint256 incomingValue =             (newIncomeIndex - _lastIncomeIndex).decdiv(_lastIncomeIndex) /                 timeElapsed;  ## Tools Used Editor  ## Recommended Mitigation Steps Give an error message when the previous incomeIndex is larger than the current incomeIndex. And/or create a way to recover from this erroneous situation.  "}, {"title": "Multiple definitions of PRECISION", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-05-88mph-findings", "body": "Multiple definitions of PRECISION"}, {"title": "Add extra error message in_depositRecordData", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/7", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-05-88mph-findings", "body": "Add extra error message in_depositRecordData"}, {"title": "function payInterestToFunders does not have a re-entrancy modifier", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/6", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-88mph-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact function payInterestToFunders does not have a re-entrancy modifier. I expect to see this modifier because similar functions (including sponsored version) have it.  ## Recommended Mitigation Steps Add 'nonReentrant' to function payInterestToFunders.  "}, {"title": "Missmatch between the comment and the actual code", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/5", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-05-88mph-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact Here the comment says that it should transfer from msg.sender but it actually transfers from the sender which is not always the msg.sender (e.g. sponsored txs):   // Transfer `fundAmount` stablecoins from msg.sender   stablecoin.safeTransferFrom(sender, address(this), fundAmount);  ## Recommended Mitigation Steps Update the comment to match the code.  "}, {"title": "contract AaveMarket function setRewards has a misleading revert message", "html_url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/4", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-05-88mph-findings", "body": "# Handle  paulius.eth   # Vulnerability details  ## Impact contract AaveMarket function setRewards has a misleading revert message:    require(newValue.isContract(), \"HarvestMarket: not contract\");  ## Recommended Mitigation Steps Should be 'AaveMarket', not 'HarvestMarket'.  "}, {"title": "Unbounded loop in `_removeNft` could lead to a griefing/DOS attack", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/80", "labels": ["bug", "3 (High Risk)"], "target": "2021-05-visorfinance-findings", "body": "Unbounded loop in `_removeNft` could lead to a griefing/DOS attack"}, {"title": "Deflationary tokens are not considered in time-locked ERC20 functions", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/78", "labels": ["bug", "1 (Low Risk)"], "target": "2021-05-visorfinance-findings", "body": "Deflationary tokens are not considered in time-locked ERC20 functions"}, {"title": "Unused imported interface `IVisorService`", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/71", "labels": ["bug", "0 (Non-critical)"], "target": "2021-05-visorfinance-findings", "body": "Unused imported interface `IVisorService`"}, {"title": "Events are not indexed", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/70", "labels": ["bug", "0 (Non-critical)"], "target": "2021-05-visorfinance-findings", "body": "Events are not indexed"}, {"title": "The function onERC721Received () allows writing duplicates in the array \"nfts\". Another functions dealing with this array do not expect duplicates met.", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/67", "labels": ["bug", "1 (Low Risk)"], "target": "2021-05-visorfinance-findings", "body": "The function onERC721Received () allows writing duplicates in the array \"nfts\". Another functions dealing with this array do not expect duplicates met."}, {"title": "timelockERC721Keys could exceed the block size limit", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/65", "labels": ["bug", "2 (Med Risk)"], "target": "2021-05-visorfinance-findings", "body": "timelockERC721Keys could exceed the block size limit"}, {"title": "Internal GetBalanceLocked call can exceed block size limit", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/63", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-05-visorfinance-findings", "body": "Internal GetBalanceLocked call can exceed block size limit"}, {"title": "Locking the same funds twice in lock() on line 269 of Visor.sol", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/61", "labels": ["bug", "1 (Low Risk)"], "target": "2021-05-visorfinance-findings", "body": "Locking the same funds twice in lock() on line 269 of Visor.sol"}, {"title": "Gas optimizations - calculation getBalanceLocked", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/55", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-05-visorfinance-findings", "body": "Gas optimizations - calculation getBalanceLocked"}, {"title": "Gas optimizations - storage over memory", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/53", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-05-visorfinance-findings", "body": "Gas optimizations - storage over memory"}, {"title": "Gas optimization storage NFTs", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/52", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-05-visorfinance-findings", "body": "Gas optimization storage NFTs"}, {"title": "Gas optimizations by using external over public ", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/51", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-05-visorfinance-findings", "body": "Gas optimizations by using external over public "}, {"title": "Approval for NFT transfers is not removed after transfer", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/48", "labels": ["bug", "3 (High Risk)"], "target": "2021-05-visorfinance-findings", "body": "Approval for NFT transfers is not removed after transfer"}, {"title": "Wrong TimeLockERC20 event emitted", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/45", "labels": ["bug", "1 (Low Risk)"], "target": "2021-05-visorfinance-findings", "body": "Wrong TimeLockERC20 event emitted"}, {"title": "Missing events", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/44", "labels": ["bug", "0 (Non-critical)"], "target": "2021-05-visorfinance-findings", "body": "Missing events"}, {"title": "Unhandled return value of transferFrom in timeLockERC20() could lead to fund loss for recipients", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/39", "labels": ["bug", "2 (Med Risk)"], "target": "2021-05-visorfinance-findings", "body": "Unhandled return value of transferFrom in timeLockERC20() could lead to fund loss for recipients"}, {"title": "Timelock keys are never removed after unlocks", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/37", "labels": ["bug", "1 (Low Risk)"], "target": "2021-05-visorfinance-findings", "body": "Timelock keys are never removed after unlocks"}, {"title": "A previously timelocked NFT token becomes permanently stuck in vault if it\u2019s ever moved back into the vault", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/35", "labels": ["bug", "3 (High Risk)"], "target": "2021-05-visorfinance-findings", "body": "A previously timelocked NFT token becomes permanently stuck in vault if it\u2019s ever moved back into the vault"}, {"title": "NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/34", "labels": ["bug", "3 (High Risk)"], "target": "2021-05-visorfinance-findings", "body": "NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens"}, {"title": "Breaking out of loop can save gas", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/32", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-05-visorfinance-findings", "body": "Breaking out of loop can save gas"}, {"title": "Use a temporary variable to cache repetitive storage reads", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/31", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-05-visorfinance-findings", "body": "Use a temporary variable to cache repetitive storage reads"}, {"title": "Use a temporary variable to cache repetitive complex calculation", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/30", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-05-visorfinance-findings", "body": "Use a temporary variable to cache repetitive complex calculation"}, {"title": "Unused state variable and associated setter function", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/28", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-05-visorfinance-findings", "body": "Unused state variable and associated setter function"}, {"title": "Change function visibility from public to external", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/27", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-05-visorfinance-findings", "body": "Change function visibility from public to external"}, {"title": "missing condition in addTemplate(bytes32 name, address template), visorFactory.sol", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/24", "labels": ["bug", "1 (Low Risk)"], "target": "2021-05-visorfinance-findings", "body": "missing condition in addTemplate(bytes32 name, address template), visorFactory.sol"}, {"title": "delegatedTransferERC20 can revert when called by owner", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/21", "labels": ["bug", "1 (Low Risk)"], "target": "2021-05-visorfinance-findings", "body": "delegatedTransferERC20 can revert when called by owner"}, {"title": "transferERC721 doesn't clean timelockERC721s", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/19", "labels": ["bug", "2 (Med Risk)"], "target": "2021-05-visorfinance-findings", "body": "transferERC721 doesn't clean timelockERC721s"}, {"title": "introduce a max lock time limit", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/14", "labels": ["bug", "0 (Non-critical)"], "target": "2021-05-visorfinance-findings", "body": "introduce a max lock time limit"}, {"title": "sandwich approveTransferERC20", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/10", "labels": ["bug", "1 (Low Risk)"], "target": "2021-05-visorfinance-findings", "body": "sandwich approveTransferERC20"}, {"title": "getNftById is querying against the index not id", "html_url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/8", "labels": ["bug", "0 (Non-critical)"], "target": "2021-05-visorfinance-findings", "body": "getNftById is querying against the index not id"}, {"title": "Incorrect type conversion in the contract `ABC` makes users unable to burn FSD tokens", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/77", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The function `_calculateDeltaOfFSD` of contract `ABC` incorrectly converts an `int256` type parameter, `_reserveDelta`, to `uint256` by explicit conversion, which in general results in an extremely large number when the provided parameter is negative. The extremely large number could cause a SafeMath operation `sub` at line 43 to revert, and thus the FSD tokens cannot be burned. (`_reserveDelta` is negative when burning FSD tokens)  ## Proof of Concept  Simply calling `fsd.burn` after a successful `fsd.mint` will trigger this bug.  Referenced code: [ABC.sol#L43](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L43) [ABC.sol#L49](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L49) [ABC.sol#L54](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L54)  ## Recommended Mitigation Steps  Use the solidity function `abs` to get the `_reserveDelta` absolute value.  "}, {"title": "Flash minting and burning can reduce the paid fees when purchasing a membership or opening a cost share request", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/76", "labels": ["bug", "question", "2 (Med Risk)", "disagree with severity"], "target": "2021-05-fairside-findings", "body": "Flash minting and burning can reduce the paid fees when purchasing a membership or opening a cost share request"}, {"title": "The variable `fShareRatio` is vulnerable to manipulation by flash minting and burning", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/75", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The variable `fShareRatio` in the function `purchaseMembership` of contract `FSDNetwork` is vulnerable to manipulation by flash minting and burning, which could affect several critical logics, such as the check of enough capital in the pool (line 139-142) and the staking rewards (line 179-182).  ## Proof of Concept  The `fShareRatio` is calculated (line 136) by:  ```solidity (fsd.getReserveBalance() - totalOpenRequests).mul(1 ether) / fShare; ```  where `fsd.getReserveBalance()` can be significantly increased by a user minting a large amount of FSD tokens with flash loans. In that case, the increased `fShareRatio` could affect the function `purchaseMembership` results. For example, the user could purchase the membership even if the `fShareRatio` is < 100% previously, or the user could earn more staking rewards than before to reduce the membership fees. Although performing flash minting and burning might not be profitable overall since a 3.5% tribute fee is required when burning FSD tokens, it is still important to be aware of the possible manipulation of `fShareRatio`.  Referenced code: [FSDNetwork.sol#L134-L142](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L134-L142) [FSDNetwork.sol#L178-L182](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L178-L182)  ## Recommended Mitigation Steps  Force users to wait for (at least) a block to prevent flash minting and burning.  "}, {"title": "Incorrect implementation of arctan in the contract `FairSideFormula`", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/73", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The current implementation of the arctan formula in the contract `FairSideFormula` is inconsistent with the referenced paper and could cause incorrect results when the input parameter is negative. The erroneous formula affects the function `calculateDeltaOfFSD` and the number of FSD tokens minted or burned.  ## Proof of Concept  The function `_arctan` misses two `abs` on the variable `a`. The correct implementation should be:  ```solidity function _arctan(bytes16 a) private pure returns (bytes16) {     return         a.mul(PI_4).sub(             a.mul(a.abs().sub(ONE)).mul(APPROX_A.add(APPROX_B.mul(a.abs())))         ); } ```  Notice that `_arctan` is called by `arctan`, and `arctan` is called by `arcs` with `ONE.sub(arcInner)` provided as the input parameter. Since `arcInner = MULTIPLIER_INNER_ARCTAN.mul(x).div(fS3_4)` can be a large number (recall that `x` is the capital pool), it is possible that the parameter `a` is negative.  Referenced code:  [FairSideFormula.sol#L45-L61](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L45-L61) [FairSideFormula.sol#L77-L85](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L77-L85) [FairSideFormula.sol#L127](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L127) [ABC.sol#L38](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/ABC.sol#L38)  ## Recommended Mitigation Steps  Modify the `_arctan` function as above.  "}, {"title": "`pendingWithdrawals` not decreased after a `withdraw`", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/72", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The variable `pendingWithdrawals` in the contract `Withdrawable` is not decreased after the function `withdraw` is called, which causes the return value of function `getReserveBalance` less than it should be. This bug could cause incorrect results in several critical functions related to FSD token pricing, including `getFSDPrice`, `purchaseMembership`, `getMaximumBenefitPerUser`, `mint`, and `burn` in the `FSDNetwork` and `FSD` contracts.  ## Proof of Concept  Referenced code: [Withdrawable.sol#L14-L19](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L14-L19) [Withdrawable.sol#L26-L28](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L26-L28)  Affected functions: [FSD.sol#L85](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L85) [FSD.sol#L100](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L100) [FSDNetwork.sol#L136](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L136) [FSDNetwork.sol#L361](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L361) [FSDNetwork.sol#L369](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L369)  ## Recommended Mitigation Steps  Add `pendingWithdrawals = pendingWithdrawals.sub(reserveAmount);` after line 17 in the contract `Withdrawable`.  "}, {"title": "Gas optimization for the `rootPows` function in `FairSideFormula`", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/71", "labels": ["bug", "question", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  Gas optimization is possible for the current `rootPows` implementation.  ## Proof of Concept  The original implementation of `rootPows` requires 4 `mul` and 2 `sqrt`:  ```solidity function rootPows(bytes16 x) private pure returns (bytes16, bytes16) {     // fourth root     x = x.sqrt().sqrt();     // to the power of 3     x = _pow3(x);     // we offset the root on the second arg     return (x, x.mul(x)); } ```  However, the calculation process can be simplified to be more gas-efficient than the original with only 1 `mul` and 2 `sqrt` requried:  ```solidity function rootPows(bytes16 x) private pure returns (bytes16, bytes16) {     bytes16 x1_2 = x.sqrt();     bytes16 x3_2 = x.mul(x1_2);     bytes16 x3_4 = x3_2.sqrt();     return (x3_4, x3_2); } ```  Referenced code: [FairSideFormula.sol#L67-L75](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/FairSideFormula.sol#L67-L75)  ## Recommended Mitigation Steps  To save gas, change the implementation of `rootPows` as mentioned above.  "}, {"title": "Should check return data from Chainlink aggregators", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/70", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The `getEtherPrice` function in the contract `FSDNetwork` fetches the ETH price from a Chainlink aggregator using the `latestRoundData` function. However, there are no checks on `roundID` nor `timeStamp`, resulting in stale prices.  ## Proof of Concept  Referenced code: [FSDNetwork.sol#L376-L381](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/network/FSDNetwork.sol#L376-L381)  ## Recommended Mitigation Steps  Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete, for example:  ```solidity (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(answeredInRound >= roundID, \"...\"); require(timeStamp != 0, \"...\"); ```  "}, {"title": "Events in `FairSideDAO` are not indexed", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/69", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-05-fairside-findings", "body": "Events in `FairSideDAO` are not indexed"}, {"title": "Solidity keyword `transfer` is used in the contract `Withdrawable`", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/67", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The function `withdraw` in the contract `Withdrawable` uses the Solidity keyword, `transfer`, which is unrecommended since it forwards a fixed amount of 2300 gas to the recipient. The gas cost of opcodes may change during hard forks in the future and thus break the functionalities of existing deployed contracts.  ## Proof of Concept  Referenced code: [Withdrawable.sol#L18](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/dependencies/Withdrawable.sol#L18)  Please refer to the following references for more details:  [Solidity issue - Remove .send and .transfer](https://github.com/ethereum/solidity/issues/7455) [Stop Using Solidity's transfer() Now](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/)   ## Recommended Mitigation Steps  Use `.call{value: 1 ether}(\"\")` instead of `transfer` or `send`. Besides, since the `call` function forwards all gas to the recipient, the contract should add protections (e.g., reentrancy guards) to prevent the recipient from reentering critical functions.  "}, {"title": "Revert messages are wrong", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  s1m0   # Vulnerability details  ## Impact The following revert messages refer to a different function instead of the one where they actually are, making harder to understand the flow of the program in case of error. [l. 166](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L166) [l. 185](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L185) [l. 254](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L254)  ## Recommended Mitigation Steps Set the messages with the correct function name.  "}, {"title": "convictionless mapping is not used", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/61", "labels": ["bug", "question", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact convictionless can be set via function setConvictionless, however, it is not used anywhere across the system, thus making it useless. Based on the comment above this variable, I expect to see it used in functions like _updateConvictionScore.  ## Recommended Mitigation Steps Either remove this mapping or use it where intended.  "}, {"title": "lack of input validation of id in getConvictionScore(){}", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/60", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-05-fairside-findings", "body": "lack of input validation of id in getConvictionScore(){}"}, {"title": "Check if variables are initialized", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/59", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-05-fairside-findings", "body": "Check if variables are initialized"}, {"title": "Gas optimizations - Use external instead of public", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-05-fairside-findings", "body": "Gas optimizations - Use external instead of public"}, {"title": "Gas optimizations - Reduce reads in purchaseMembership method", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  a_delamo   # Vulnerability details  ## Impact  The method `purchaseMembership` in `FSDNetwork` contract contains the code below. Inside this method, we are constantly reading from the mapping `membership`, so why not use just one read `Membership userMembership = membership[msg.sender]` and use this instance for everything related to memberships.  Each read we are currently doing has an impact on the gas cost.  ``` function purchaseMembership(uint256 costShareBenefit) external {         require(             costShareBenefit % 10 ether == 0 && costShareBenefit > 0,             \"FSDNetwork::purchaseMembership: Invalid cost share benefit specified\"         );          if (             membership[msg.sender].creation + MEMBERSHIP_DURATION <             block.timestamp         ) {             membership[msg.sender].creation = 0;             membership[msg.sender].availableCostShareBenefits = 0;         }          uint256 totalCostShareBenefit =             membership[msg.sender].availableCostShareBenefits.add(                 costShareBenefit             );         require(             totalCostShareBenefit <= getMaximumBenefitPerUser(),             \"FSDNetwork::purchaseMembership: Exceeds cost share benefit limit per account\"         );          totalCostShareBenefits = totalCostShareBenefits.add(costShareBenefit);          // FSHARE = Total Available Cost Share Benefits / Gearing Factor         uint256 fShare = totalCostShareBenefits / GEARING_FACTOR;         // Floor of 7500 ETH         if (fShare < 7500 ether) fShare = 7500 ether;          // FSHARERatio = Capital Pool / FSHARE (scaled by 1e18)         uint256 fShareRatio =             (fsd.getReserveBalance() - totalOpenRequests).mul(1 ether) / fShare;          // 1 ether = 100%         require(             fShareRatio >= 1 ether,             \"FSDNetwork::purchaseMembership: Insufficient Capital to Cover Membership\"         );          uint256 membershipFee = costShareBenefit.wmul(MEMBERSHIP_FEE);         uint256 fsdSpotPrice = getFSDPrice();         uint256 fsdFee = membershipFee.wdiv(fsdSpotPrice);          // Automatically locks 65% to the Network by disallowing its retrieval         fsd.safeTransferFrom(msg.sender, address(this), fsdFee);          if (membership[msg.sender].creation == 0) {             membership[msg.sender]                 .availableCostShareBenefits = totalCostShareBenefit;             membership[msg.sender].creation = block.timestamp;             membership[msg.sender].gracePeriod =                 membership[msg.sender].creation +                 MEMBERSHIP_DURATION +                 60 days;         } else {             membership[msg.sender]                 .availableCostShareBenefits = totalCostShareBenefit;              uint256 elapsedDurationPercentage =                 ((block.timestamp - membership[msg.sender].creation) *                     1 ether) / MEMBERSHIP_DURATION;             if (elapsedDurationPercentage < 1 ether) {                 uint256 durationIncrease =                     (costShareBenefit.mul(1 ether) /                         (totalCostShareBenefit - costShareBenefit))                         .mul(MEMBERSHIP_DURATION) / 1 ether;                 membership[msg.sender].creation += durationIncrease;             }         }          uint256 governancePoolRewards =             fsdFee.wmul(GOVERNANCE_FUNDING_POOL_REWARDS);          // Staking Rewards = 20% + [FSHARERatio - 125%] (if FSHARERatio > 125%)         uint256 stakingMultiplier =             fShareRatio >= 1.25 ether                 ? STAKING_REWARDS + fShareRatio - 1.25 ether                 : STAKING_REWARDS;          // Maximum of 75% as we have 15% distributed to governance + funding pool         if (stakingMultiplier > 0.75 ether) stakingMultiplier = 0.75 ether;          uint256 stakingRewards = fsdFee.wmul(stakingMultiplier);          // 20% as staking rewards         fsd.safeTransfer(address(fsd), stakingRewards);         fsd.addRegistrationTribute(stakingRewards);          // 7.5% towards governance         fsd.safeTransfer(address(fsd), governancePoolRewards);         fsd.addRegistrationTributeGovernance(governancePoolRewards);          // 7.5% towards funding pool         fsd.safeTransfer(FUNDING_POOL, governancePoolRewards);     } ```  "}, {"title": "Gas optimizations - checkpoints from ERC20ConvictionScore", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/54", "labels": ["bug", "question", "G (Gas Optimization)"], "target": "2021-05-fairside-findings", "body": "Gas optimizations - checkpoints from ERC20ConvictionScore"}, {"title": "`ERC20ConvictionScore.acquireConviction` implements wrong governance checks", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/45", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details  There are two issues with the governance checks when acquiring them from an NFT:  #### Missing balance check The governance checks in `_updateConvictionScore` are:  ```solidity !isGovernance[user] && userConvictionScore >= governanceThreshold  && balanceOf(user) >= governanceMinimumBalance; ```  Whereas in `acquireConviction`, only `userConvictionScore >= governanceThreshold` is checked but not `&& balanceOf(user) >= governanceMinimumBalance`.  ```solidity else if (     !isGovernance[msg.sender] && userNew >= governanceThreshold ) {     isGovernance[msg.sender] = true; } ```  #### the `wasGovernance` might be outdated  The second issue is that at the time of NFT creation, the `governanceThreshold` or `governanceMinimumBalance` was different and would not qualify for a governor now. The NFT's governance state is blindly appplied to the new user:  ```solidity if (wasGovernance && !isGovernance[msg.sender]) {     isGovernance[msg.sender] = true; } ```  This allows a user to circumvent any governance parameter changes by front-running the change with an NFT creation.  ## Impact It's easy to circumvent the balance check to become a governor by minting and redeeming your own NFT. One can also circumvent any governance parameter increases by front-running these actions with an NFT creation and backrunning with a redemption.  ## Recommended Mitigation Steps Add the missing balance check in `acquireConviction`. Remove the `wasGovernance` governance transfer from the NFT and solely recompute it based on the current `governanceThreshold` / `governanceMinimumBalance` settings.   "}, {"title": "`ERC20ConvictionScore` allows transfers to special TOTAL_GOVERNANCE_SCORE address", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The credit score of the special `address(type(uint160).max)` is supposed to represent the sum of the credit scores of all users that are governors. But any user can directly transfer to this address increasing its balance and accumulating a credit score in `_updateConvictionScore(to=address(uint160.max), amount)`. It'll first write a snapshot of this address' balance which should be very low:  ```solidity // in _updateConvictionScore _writeCheckpoint(user, userNum, userNew) = _writeCheckpoint(TOTAL_GOVERNANCE_SCORE, userNum, checkpoints[user][userNum - 1].convictionScore + convictionDelta); ```  This address then accumulates a score based on its balance which can be updated using `updateConvictionScore(uint160.max)` and breaks the invariant.  ## Impact Increasing it might be useful for non-governors that don't pass the voting threshold and want to grief the proposal voting system by increasing the `quorumVotes` threshold required for proposals to pass. (by manipulating `FairSideDAO.totalVotes`). `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Disallow transfers from/to this address. Or better, track the total governance credit score in a separate variable, not in an address.   "}, {"title": "`ERC20ConvictionScore._updateConvictionScore` uses stale credit score for `governanceDelta`", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/41", "labels": ["bug", "question", "3 (High Risk)", "sponsor confirmed", "disagree with severity", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details In `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore, the `governanceDelta` is the old conviction score of the previous block.  ```solidity isGovernance[user] = false; governanceDelta = getPriorConvictionScore(     user,     block.number - 1 ); ```  The user could increase their conviction / governance score first in the same block and then lose their status in a second transaction, and the total governance conviction score would only be reduced by the previous score.  Example: Block n - 10000: User is a governor and has a credit score of 1000 which was also contributed to the `TOTAL_GOVERNANCE_SCORE` Block n: - User updates their own conviction score using public `updateConvictionScore` function which increases the credit score by 5000 based on the accumulated time. The total governance credit score increased by 5000, making the user contribute 6000 credit score to governance in total. - User transfers their whole balance away, the balance drops below `governanceMinimumBalance` and user is not a governor anymore. The `governanceDelta` update of the transfer should be 6000 (user's whole credit score) but it's only `1000` because it takes the snapshot of block n - 1.  ## Impact The `TOTAL_GOVERNANCE_SCORE` score can be inflated this way and break the voting mechanism in the worst case as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Use the current conviction store which should be `governanceDelta = checkpoints[user][userCheckpointsLength - 1].convictionScore`   "}, {"title": "`ERC20ConvictionScore`'s `governanceDelta` should be subtracted when user is not a governor anymore", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/40", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "resolved"], "target": "2021-05-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  ## Vulnerability Details The `TOTAL_GOVERNANCE_SCORE` is supposed to track the sum of the credit scores of all governors.  In `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore and is therefore removed, the `governanceDelta` should be negative but it's positive.  ```solidity isGovernance[user] = false; governanceDelta = getPriorConvictionScore(     user,     block.number - 1 ); ```  It then gets added to the new total:  ```solidity uint224 totalGCSNew =     add224(         totalGCSOld,         governanceDelta,         \"ERC20ConvictionScore::_updateConvictionTotals: conviction score amount overflows\"     ); ```  ## Impact The `TOTAL_GOVERNANCE_SCORE` tracks wrong data leading to issues throughout all contracts like wrong `FairSideDAO.totalVotes` data which can then be used for anyone to pass proposals in the worst case. Or `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.  ## Recommended Mitigation Steps Return a negative, signed integer for this case and add it to the new total.   "}, {"title": "`validateVoteHash` does not confirm the vote result", "html_url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/37", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-05-fairside-findings", "body": "`validateVoteHash` does not confirm the vote result"}]