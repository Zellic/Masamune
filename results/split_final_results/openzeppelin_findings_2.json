[{"title": "Drift between test and production contracts", "body": "commitVote,  revealVote, and  commitAndEmitEncryptedVote functions. While these functions were removed from the version of the  added to the  Consider removing the functions added to the VotingV2Test contract that are no longer present in the VotingV2 contract, and update tests accordingly.  Update: Acknowledged, and will not fix. UMAs statement:  We have decided not to incorporate these changes. Updates to the tests could take a long time compared to the outcome.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#drift-between-test-and-production-contracts", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider addressing the following typographical errors:  In EmergencyProposer.sol (PR #4128):  line 82: action.. should be action.  In Staker.sol (PR #4110):  line 113: users wallet should be users wallet line 241: msg.sender(voter or delegate) should be msg.sender (voter or delegate) (add 1 space)  In VotingV2.sol (PR #4117):  line 962: be either a should be be either line 1119: removed from should be removed from (delete 1 space)  In VotingV2.sol (PR #4118):  line 249: Must be set to 0x0 for production environments that use live time. refers to the deleted _timerAddress parameter and should be deleted  In VotingV2.sol (PR #4139):  line 499: participates should be participant  In VotingV2.js (PR #4139):  line 3123: not posable should be not possible  Update: Fixed as of commit c311e0a53c8b3a0ddb00fcea79341baca42d142a in PR #4165.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary non-empty return value on success", "body": "_getPriceOrError in the  returns three values: *  comment on  return a non-empty string even when the price was successfully retrieved. Because the string message  is only used in the error case, users will never see the Returned from previous contract string.  Consider returning an empty string when _getPriceOrError returns true.  Update: Fixed as of commit 0aef75d2fe05488c31b462484c57277ee30e9cb0 in PR #4163.  Unnecessary public visibility in executeEmergencyProposal  In the EmergencyProposer contract, the executeEmergencyProposal function has public visibility. This is not required as the function is not called within the contract.  Consider changing the visibility of the executeEmergencyProposal function to external.  Update: Fixed as of commit fd4813895c1f113f71b03ac9cf79c5ab22710514 in PR #4166.  Unused imports  In the EmergencyProposer contract, the following files are imported but not used:  Constants.sol  OracleAncillaryInterface.sol  AdminIdentifierLib.sol  To improve readability and avoid confusion, consider removing the unused imports.  Update: Fixed as of commit a16bed5abe1de184c689ece8bb5e56e3c183f3e8 in PR #4164.  Unused variables  Within the EmergencyProposer contract, several variables are defined but not used:  The finder state variable is initialized in the constructor, but otherwise is not used  The currentId state variable is never used  To improve readability and avoid confusion, consider removing the unused variables.  Update: Fixed as of commit 5f7567e7c9686ae68565a09fe4db49a2cd29a2f4 in PR #4167.  Conclusions  A single medium severity issue was found. Some recommendations were also made to improve the quality of the codebase.  There were multiple changes regarding VotingV2 that were done to reduce the contract bytecode size as it was reaching the limit. However, some of these changes included removing errors from require statements or grouping multiple conditions into a single statement. These changes make it more difficult for a user to debug failures when interacting with a contract and make the codebase less readable.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#unnecessary-non-empty-return-value-on-success", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary public visibility in executeEmergencyProposal", "body": "Unnecessary public visibility in executeEmergencyProposal", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#unnecessary-public-visibility-in-executeemergencyproposal", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "In the EmergencyProposer contract, the following files are imported but not used:  Constants.sol  OracleAncillaryInterface.sol  AdminIdentifierLib.sol  To improve readability and avoid confusion, consider removing the unused imports.  Update: Fixed as of commit a16bed5abe1de184c689ece8bb5e56e3c183f3e8 in PR #4164.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused variables", "body": "Within the EmergencyProposer contract, several variables are defined but not used:  The finder state variable is initialized in the constructor, but otherwise is not used  The currentId state variable is never used  To improve readability and avoid confusion, consider removing the unused variables.  Update: Fixed as of commit 5f7567e7c9686ae68565a09fe4db49a2cd29a2f4 in PR #4167.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#unused-variables", "labels": ["OpenZeppelin"]}, {"title": "Medium: Parasitic staking term issue", "body": "This issue allows for a parasitic staker to accumulate rewards without having to participate on a vote and without ever being slashed. The root cause of this is that the slashing mechanism only takes into account the activeStake of a staker while deciding to slash a user, while the rewards mechanism takes both activeStake and pendingStake into account.  Update: Fixed as of commit fd8cecc6719a7a69d44287b2096866686313593c of pull request #4168.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#medium:-parasitic-staking-term-issue", "labels": ["OpenZeppelin"]}, {"title": "Low: Unresolvable price request issue", "body": "This issue causes that a price request becomes unresolvable under very specific conditions: If a price request is made, then the price request rolls over, the only participant who voted on the request was not staked before the request and they had staked during the reveal phase post roll over.  Then the price request can only be resolved if another voter who staked before the request participates once the request rolls over again.  Update: Fixed as of commit 2d4fad7cb3525a7faeb88f07953907d3c4515796 of pull request #4139.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#low:-unresolvable-price-request-issue", "labels": ["OpenZeppelin"]}, {"title": "Findings", "body": "Here we present our findings.  Critical Severity", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#findings", "labels": ["OpenZeppelin"]}, {"title": "Slashing mechanism grants exponentially more rewards than expected", "body": "In the VotingV2 contract the function updateTrackers calls the internal function _updateAccountSlashingTrackers with parameter indexTo set to the priceRequestIds.length to process the slashing rewards and penalties associated with all resolved requests.  ensured that any  Additionally, the contract contains a function updateTrackersRange that is callable without authorization, with freely chosen parameters voterAddress and indexTo which are passed to _updateAccountSlashingTrackers. The use of this function is necessary whenever the potentially unbounded amount of requests to be processed within the for-loop exceeds the gas limit.  Consider modifying the respective update functions to ensure that slash values can only be applied round-wise. Additionally, consider implementing a monitoring solution that continuously checks whether the sum of all staked balances is equal to the amount of UMA contained within the contract and whether this value lies within an expected range. Finally, consider implementing an emergency mechanism to temporarily suspend the reward system without affecting the contracts functionality as a governance and voting system.  Update: Fixed as of commit 18aef110f2bc882a9bfe115bc4ca86f3681f2d4b in pull request #4067.  High Severity", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#slashing-mechanism-grants-exponentially-more-rewards-than-expected", "labels": ["OpenZeppelin"]}, {"title": "Duplicate Request Rewards", "body": "_updateAccountSlashingTrackers function contains an optimization that marks unresolved requests in a prior round (rolled votes) as deleted via an entry in the  line 860 enables future callers to skip an  However, the request processing logic within _updateAccountSlashingTrackers is not able to correctly handle multiple rolled votes that appear sequentually in the request array. Consider the following scenario:  The deletedRequests map is initially empty and the previous voting round contained three votes (limiting to 3 just for simplicity). In this example we will number these request indexes as 1, 2, 3. Assume the the first two votes (index 1 and 2) have not been resolved and are considered rolled, while index 3 is considered resolved. The first voter to call the _updateAccountSlashingTrackers function will go through the array of requests to process and cause a modification of the deletedRequests mapping to  and re-append each requests identifier to the priceRequestIds array. This creates index 4 and 5 in our example.  The next voter that calls this same function will not process request 1 due to the logic in line 845. Instead, the requestIndex will be updated to 2. However, there is no additional check ensuring that index 2 has not been deleted as well; the code assumes this is not the case and index 2 will be processed again instead of being skipped as intended.  line 858 the if-statement condition will fail thereby allowing the code to reach the break statement on  line 867. Consequently, the entire loop is terminated without increasing the voters  lines 865-866 indicates that if the  line 920.  Now, assuming both rolled requests are resolved in the following round, our previous voter calls (indirectly) this function again. Because lastRequestIndexConsidered was not updated, once again the processing starts at index 1, which is again skipped on line 845 when it is looked up in the deletedRequests map, and requestIndex is advanced to 2. Execution continues to line 854, which will evaluate to true because the corresponding request has been resolved, so slashing will be applied for index 2. On the next cycles of the for-loop, indices 3, 4, and 5 will be processed. Recall however that index 4 and 5 are re-queued elements that reference the same identifiers as index 1 and 2. Therefore, the slashing penalties for index 2 will be processed twice in this example. In this example all the requests were resolved, but if that had not been the case, additional duplications would have occurred each time a vote was rolled to the next round.  The underlying bug is the incorrect assumption on line 845 that assumes deletedRequests wont contain consecutive unresolved votes. There are several ways the fix can be approached depending on the tradeoff between simplicity vs efficiency. Consider some possible options:  A straightforward fix that sets requestIndex = deletedRequests[requestIndex] on line 845 (remove the + 1) and then inserts a continue statement. This would return execution back to line 843 where requestIndex would be incremented as before, but ensures that the deletedRequests[requestIndex] != 0 test on line 845 is applied to this new index.  A more complex but efficient fix would be to additionally store the inverse mapping to deletedRequest to enable jumping over adjacent skipped indices in one step by modifying the target of the first index.  Update: Fixed as of commit 8356375e8893d3b0375345b0464ef0fe10d15c26 in pull request #4064 by adopting the first recommendation.  Medium Severity", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#duplicate-request-rewards", "labels": ["OpenZeppelin"]}, {"title": "Incorrect refund of spamDeletionProposalBond", "body": "VotingV2.sol contract the  spamDeletionProposalBond determines the amount of  signalRequestsAsSpamForDeletion. An amount of  If the owner mistakenly calls setSpamDeletionProposalBond between a spam deletion request and its execution, the value of the refunded bond will differ from the originally submitted bond, thereby leading to a loss for either the original requester or the VotingV2 contract.  Consider adding a new uint256 bond parameter to the SpamDeletionRequest struct to record the bond amount at the time a specific request was submitted, and using this value during the call to executeSpamDeletion.  Update: Partially fixed in commit 52b32d4e1f6f7262228b7c3d7f1fa00b95c4d4b2 of pull request #4065. Our recommendation has been adopted in the case of a successful spamDeletionProposal. However, in the case of unsuccesful proposal, the amount sent to the store contract remains affected.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#incorrect-refund-of-spamdeletionproposalbond", "labels": ["OpenZeppelin"]}, {"title": "Incorrect math in slashing library comments", "body": "In the SlashingLibrary contract the functions calcWrongVoteSlashPerToken and calcNoVoteSlashPerToken are meant to return constants representing a slashing percentage per wrong vote or no vote that would counteract the 20% staking APY under the assumption of 120 yearly votes. Both functions contain commentary with an incorrect mathematical formula to counteract a 20% APY.  More specifically, the formula outlined in the inline comments  uses basic interest instead of compound interest and assumes that a 20% increase will be negated with a subsequent 20% loss. However, the correct formula to counteract a 20% APY over 120 votes would be  While the current deviation between both values is negligible, applying the correct formula becomes crucially important for a higher APY and more yearly votes.  Consider updating the documentation to include both the correct mathematical formula and an advisory to check the inequality  to prevent setting any incentives for staking without participating in votes.  Update: Fixed as of commit fed9d90bff9ec5052ced798e52ff36502f3cac1e of pull request #4066.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#incorrect-math-in-slashing-library-comments", "labels": ["OpenZeppelin"]}, {"title": "Stake can be withheld indefinitely", "body": "Staker contract the function  setUnstakeCoolDown allows the contract owner to set the  Giving the contract owner full control over setting unstakeCoolDown violates the trust assumptions typically present in a staking system. Namely, stakers expect to be able to retrieve their stake regardless of operator error or operator malice. Setting unstakeCoolDown to a very large value would render each users stake practically unretrievable.  The intended use of this contract is to be owned by the GovernorV2 contract thereby allowing the affected stakers to control the unstakeCoolDown through governance proposals, which reduce the likelihood of malice. However, voters who disagree with a legitimate majority vote to extend unstakeCoolDown will most likely not be able to leave the staking system before the changes take effect.  Consider validating the input of the setUnstakeCoolDown function against an acceptable maximum cooldown time. Also consider allowing the retroactive application of a new unstakeCoolDown value only in cases when it acts to decrease the cooldown time of users who are actively unstaking.  Update: Acknowledged. UMA indicated that the economic incentives between stakeholders make this scenario unlikely. The increased complexity and gas cost of the suggested recommendation does not appear justified.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#stake-can-be-withheld-indefinitely", "labels": ["OpenZeppelin"]}, {"title": "Limitations of contract migration", "body": "The VotingV2 contract includes a setMigrated administrative function that sets an associated migratedAddress which stores the address of a future version of the voting system (e.g. V3).  onlyIfNotMigrated and  onlyRegisteredContract modifiers which restrict its functionality in the event of a migration. The  However, there are several concerns with the existing migration design:  The onlyRegisteredContract modifier allows forwarding price requests from the contract deployed at migratedAddress to VotingV2 after migratedAddress has been set, but the onlyIfNotMigrated modifier prevents anyone from voting on those requests.  Voter tokens are staked on the VotingV2 contract and there is a GAT threshold for voting. If users are directed to migrate their staked tokens from VotingV2 to the new Voting contract, there may be a transition period where not enough users are staked on either contract to reach the GAT threshold for voting.  Ideally, contract migration would occur during a time window when there are no active requests. Attempting to upgrade the contract while price requests are active would result in it not being able to complete the voting process on those requests due to the disabled state of the commit and reveal functions. However a price request can occur at any time, and if demand for the voting system increases in the future, it will become more difficult to chance upon a time window where there is no activity in the voting system, and there is no guarantee that such a window will exist.  To avoid a situation where the voting system cannot be upgraded, consider introducing an upgrade mechanism that allows for migration in several distinct steps while ensuring that the voting system remains functional at each stage.  Update: Partially fixed in commit 852b60531bb1888d581046a3ccda3a68d4856f33 of pull request #4105. Forwarding price requests to the old contract have been fixed, while UMA indicated that additional measures to facilitate migration will be addressed in a future version.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#limitations-of-contract-migration", "labels": ["OpenZeppelin"]}, {"title": "Lack of emergency administration", "body": "The VotingV2 contract has several functions that are protected by the onlyOwner modifier:  requestGovernanceAction  setMigrated  setGat  setRewardsExpirationTimeout  setSlashingLibrary  setSpamDeletionProposalBond  setEmissionRate (inherited from Staker)  setUnstakeCoolDown (inherited from Staker)  propose function in the  calling the Ownable base contract function transferOwnership(), as demonstrated in the  This change of ownership means that the GovernorV2 contract also becomes the only valid caller for the setter functions in the list above. In order to call any of these functions, a governance action must be proposed with Transaction data that will invoke the target function, and subsequently executed via the executeProposal function.  The concern with this approach is that the voting system is potentially a single point of failure for administrative governance actions. Taking the setGat function as an example, if voter participation becomes insufficient to meet the GAT threshold and the GAT value needs to be lowered, a governance proposal to call setGat may be prevented from execution if the existing GAT value prevents that vote from succeeding. Furthermore, future versions of the DVM with new administrative functions may encounter the same problem where the current state of the Voting contract prevents a new corrective state from being applied.  To address this issue, consider developing an out-of-band system that allows UMA governance to execute emergency corrective actions for the voting system that do not rely on the voting system itself in order to succeed. For this approach, it is recommended to use a multisig wallet to control access to the onlyOwner-protected functions. Also consider implementing minimum and maximum values for each setter function that restrict governance changes to a safe range.  Update: Acknowledged. UMA acknowledges that emergency administration is a concern. However, due to the complexity and severity of changes it cannot be addressed as part of this audit.  Low Severity", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#lack-of-emergency-administration", "labels": ["OpenZeppelin"]}, {"title": "Staker contract should be declared abstract", "body": "The Staker contract contains the following internal virtual functions:  inActiveReveal which always returns false and is meant to return a boolean value that indicates whether or not the voting system is currently in a reveal phase  getStartingIndexForStaker which always returns 0 and is meant to return a uint64 value indicating the index of the first request from which slashing rewards and penalties apply to a new staker  Neither function is supposed to modify the contract state despite lacking a view identifier.  Further, the documentation of the inActiveReveal function states This function should be overridden by the child contract. This suggests the Staker contract is designed to always be inherited by a child contract which overrides both virtual functions, and never deployed as a standalone contract.  To enforce the intended design, prevent accidental deployments, and enhance the clarity of your code base, consider declaring the Staker contract with the abstract keyword and removing the function body of inActiveReveal and getStartingIndexForStaker in order to force their implementation by a derived contract. Additionally, consider adding the view modifier to both function declarations.  Update: Fixed as of commit 8b3084adcd51fba381e733d05b75345fa3db5e4d in pull request #4068.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#staker-contract-should-be-declared-abstract", "labels": ["OpenZeppelin"]}, {"title": "Duplicate function execution", "body": "VotingV2 contract the overloaded function  commitAndEmitEncryptedVote that is provided for backwards compatibility mistakenly calls  line 614, and an additional call is performed indirectly by the call to  line 616.  The duplicate call is an unnecessary gas expense and leads to an unintentional duplication of VoteCommitted event emission.  Consider removing the direct call to commitVote from the function body.  Update: Fixed as of commit 4cd15fceb99ab03ad978f1dd01a3d0d146b6253d in pull request #4069.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#duplicate-function-execution", "labels": ["OpenZeppelin"]}, {"title": "Imprecise function name", "body": "In the DesignatedVotingV2 contract, the retrieveRewards function name suggests that the caller will gain possession of the rewards; this assumption is further reinforced by the docstrings description of the return value as amount of rewards that the user should receive. However, instead of transferring rewards to the user, the retrieveRewards function restakes users rewards.  To avoid confusion, consider renaming the retrieveRewards function to withdrawAndRestakeRewards or some other name that more accurately describes its behavior.  Update: Fixed as of commit 284c6842ed05b13cfdc82cb3b5dd897507696e8f in pull request #4071.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#imprecise-function-name", "labels": ["OpenZeppelin"]}, {"title": "Incorrect documentation for voting commit hash", "body": "lines 559-563 of the  The structure of the commit hash is described in the docstrings of several functions within the DesignatedVotingV2 and VotingV2 contracts. However, none of these docstrings appears to describe the format of the hash correctly:  In DesignatedVotingV2.sol:  line 56: The commitVote docstring describes the input hash as the keccak256 hash of the price you want to vote for and a random integer salt value. This description omits the required voterAddress, time, ancillaryData, currentRoundId, and identifier. line 74: The commitAndEmitEncryptedVote docstring describes the input hash as keccak256 hash of the price you want to vote for and a int256 salt. This description omits the required voterAddress, time, ancillaryData, currentRoundId, and identifier. line 91: The revealVote docstring describes the input price as used along with the salt to produce the hash during the commit phase. This description is technically correct but implies these are the only two values required, omitting voterAddress, time, ancillaryData, currentRoundId, and identifier. line 92: The revealVote docstring describes the input salt as used along with the price to produce the hash during the commit phase. This description is technically correct but implies these are the only two values required, omitting voterAddress, time, ancillaryData, currentRoundId, and identifier.  In VotingV2.sol:  line 488 : The commitVote docstring describes the input hash as keccak256 hash of the price, salt, voter address, time, current roundId, and identifier. This description omits the required ancillaryData variable. line 526: The revealVote docstring states that The revealed price, salt, address, time, roundId, and identifier, must hash to the latest hash. This comment omits the requires ancillaryData variable.  Furthermore, while the type of all the encoded values can be deduced by examining the input parameters and body of the revealVote function, this type information is not explicitly provided to voters in the documentation of the commit functions where the hash is inputted.  An incorrectly formatted commit hash can lead to a voter being slashed when the revealVote function attempts to re-create the submitted hash and fails.  To avoid any misunderstanding about the hash encoding and the potential for unintentional wrong votes, consider carefully documenting the exact format of the commit hash in all docstrings where it is referenced.  Update: Fixed as of commit 4f8798aeb90b1b3419f6e6da3ae1531ef07c058b in pull request #4072.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#incorrect-documentation-for-voting-commit-hash", "labels": ["OpenZeppelin"]}, {"title": "Lack of input verification in library functions", "body": "In the SpamGuardIdentifierLib contract, the function _constructIdentifier does not document or enforce the range of allowed input values for its function parameter uint256 id.  Supplying a value of 10^11 or greater as parameter id will lead to silent unexpected behavior and potentially cause the generation of duplicate identifiers, because the concatenation of the decimal string AdminIdentifierLib._uintToUtf8(id) and the identifier SpamDeletionProposal  is limited to 32 bytes. While the current usage of SpamGuardIdentifierLib within VotingV2 appears safe, this might change due to future modifications of the code base.  Consider both explicitly documenting the valid range of the input parameter and including a require statement that enforces this range.  Update: Fixed as of commit 97ca84895e094a825c55c4b905e262c771a6c80a in pull request #4073 by reducing the input to uint32.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#lack-of-input-verification-in-library-functions", "labels": ["OpenZeppelin"]}, {"title": "Missing documentation", "body": "Many of the functions, events, and variables within the codebase lack documentation.  Contracts that do not have a docstring:  SlashingLibrary  SpamGuardIdentifierLib  Functions that do not have a docstring:  _getVotingContract in DesignatedVotingV2.sol  _executeCall, _getOracle, getIdentifierWhitelist in GovernorV2.sol  updateTrackers, getStartingIndexForStaker in Staker.sol  computeRoundToVoteOnPriceRequest in VoteTimingV2.sol  getNumberOfPriceRequests, _getPriceRequest, _encodePriceRequest, _freezeRoundVariables, _priceRequestResolved, _computeGat, _getRequestStatus, unsafe_inc, unsafe_inc_64, _getIdentifierWhitelist, _requireNotMigrated, _requireRegisteredContract in VotingV2.sol  Docstrings that are incomplete:  commitVote in DesignatedVotingV2.sol is missing the @param for ancillaryData  _constructIdentifier in SpamGuardIdentifierLib.sol is missing the @param for id  init in VoteTimingV2.sol is missing the @param documentation for all input parameters  getVoterFromDelegate in VotingV2.sol is missing the @param for caller  constructor in VotingV2.sol is missing the @param for _spamDeletionProposalBond and _startingRequestIndex  Many events and storage variables throughout the codebase also lack explanatory comments.  Finally, some useful documentation was recently removed:  Documentation for the NewProposal and ProposalExexcuted events in GovernorV2.sol  Documentation explaining the propose functions public visibility in GovernorV2.sol   hinder reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions that implement sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec). Also consider providing explanatory comments for all events, structs, and storage variables that indicate their intended purpose.  Update: Partially fixed as of commit 3d68ad7fa471d4d763ab3ae9e6e5052bad1dce8e in pull request #4077. The following functions still lack docstrings:  getIdentifierWhitelist in GovernorV2.sol  updateTrackers, getStartingIndexForStaker in Staker.sol  _requireRegisteredContract in VotingV2.sol", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#missing-documentation", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require statements", "body": "Within the codebase, there are multiple require statements that lack error messages.  In VotingV2.sol:  The require statement on line 552 The require statement on line 771 The require statement on line 810 The require statement on line 961 The require statement on line 993 The require statement on line 999 The require statement on line 1188 The require statement on line 1192  In VoteTimingV2.sol:  The require statement on line 24 The require statement on line 25  Consider including specific, informative error messages in require statements to improve overall code clarity and to facilitate troubleshooting whenever a requirement is not satisfied.  Update: Fixed as of commit f29085860f7a32a480825e06b8f69c3456ea19dc in pull request #4074.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Testcode in production", "body": "The ProposerV2 and GovernorV2 contracts inherit the Testable contract, which is meant to allow setting and providing the time via an additional external contract. During deployment to a production environment the inheritance of Testable is meant to be kept while disabling the external time setter by passing the zero address to the testable constructor.  This testing methodology increases both the code size and the risk of deployment mistakes. Further, it allows multiple time sources for different contracts within the projects test cases, thereby increasing the likelihood of erroneous tests.  Consider replacing the Testable contract with equivalent functionality provided by the projects test framework. For example, consider using evm_setNextBlockTimestamp in Hardhat or vm.warp in Foundry.  Update: Fixed as of commit 90b6634f6daebf02100f4a1b8aa6bca22bc64cc8 in pull request #4095.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#testcode-in-production", "labels": ["OpenZeppelin"]}, {"title": "Unlocked Solidity version pragma", "body": "Throughout the codebase, the Solidity version used is ^0.8.0, which allows compilation with any version of Solidity from 0.8.0 up to the latest release. This may lead to unexpected behavior if the code is deployed with a different Solidity version than was used during testing. Further, allowing old versions of Solidity leaves the code potentially vulnerable to known security bugs which have already been patched. The official guidance is to always use the latest Solidity release when deploying contracts. When a bug is discovered that affects a range of Solidity versions, the general policy of the Solidity team is to only apply the fix to the latest release (i.e. no backporting of security updates).  Consider locking the version pragma to the same Solidity version used during development and testing. Also consider setting this version to be the latest release.  Update: Partially fixed in commit 4f6cc15e0dd573095b8485e57ca91330bfc5bbdc within pull request #4075. The pragma has been updated to 0.8.15 in most contracts, however Staker, SlashingLibrary and SpamGuardIdentifierLib retain an unlocked pragma.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#unlocked-solidity-version-pragma", "labels": ["OpenZeppelin"]}, {"title": "Withdraw role is not configured", "body": "The DesignatedVotingV2Factory contract inherits from the Withdrawable contract, a base contract which provides the ability to create a Withdraw role and assign it to one or more addresses to grant them the ability to withdraw ETH or ERC20 tokens from the contract by using the corresponding withdraw and withdrawErc20 functions.  _createWithdrawRole and  setWithdrawRole, and the documentation for these functions indicates that one or the other must be called by the derived contract (  Given the intended purpose of the DesignatedVotingV2Factory contract, it does not appear that it requires the Withdrawable feature. Consider removing the inheritance from Withdrawable and the corresponding import of Withdrawable.sol.  Update: Fixed as of commit 88c79f4403d6f61715fab044c8933e8d90ca4366 in pull request #4078.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#withdraw-role-is-not-configured", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent usage of reentrancy protection", "body": "In the GovernorV2 contract, the function executeProposal is protected against reentrancy by the checks-effects-interactions pattern. In contrast, the ProposerV2 contract provides an additional layer of safety against re-entrancy attacks by importing the Lockable contract and using its modifiers.  Consider inheriting from Lockable and using the nonReentrant modifier as an additional precaution.  Update: Fixed as of commit 32e27d1ca004a33a8f0ac256ccfc4f526666eeb0 in pull request #4080. The nonReentrant modifier was applied to the executeProposal function as recommended. Additionally, the nonReentrant modifier was also applied to the following functions:  The propose function in GovernorV2.sol  The stake, requestUnstake, executeUnstake, withdrawRewards, and withdrawAndRestake in functions in Staker.sol  The requestPrice, commitVote, revealVote, setDelegate, setDelegator, signalRequestAsSpamForDeletion, and executeSpamDeletion functions in VotingV2", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#inconsistent-usage-of-reentrancy-protection", "labels": ["OpenZeppelin"]}, {"title": "Duplicate code", "body": "VotingV2 contract,  lines 1136-1140 in the  pendingPriceRequests array. The  lines 1010-1016, with the only difference being that  Consider moving this duplicated code into a new shared function.  Update: Fixed as of commit ce97e9124402996f77f2c8cf22c236f599de9456 in pull request #4081 by moving the duplicated code into a new shared function named _removeRequestFromPendingPriceRequests.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#duplicate-code", "labels": ["OpenZeppelin"]}, {"title": "Duplicate computations", "body": "In the ProposerV2 contract, the function resolveProposal performs two subsequent calls to AdminIdentifierLib._constructIdentifier(id) in line 91 and line 99 without storing the return value.  Consider performing only one call and capturing the return value to enhance the gas efficiency of your code.  Update: Fixed as of commit 4c116c98224c78ef866c9a8f960c4ac4a6c08ad2 in pull request #4082.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#duplicate-computations", "labels": ["OpenZeppelin"]}, {"title": "Erroneous imports", "body": "The ProposalV2 contract erroneously imports Voting.sol instead of VotingV2.sol.  Currently, all function signatures used within ProposalV2 are available in both Voting.sol and VotingV2.sol, thereby preventing any direct consequences.  Consider upgrading the import to VotingV2.sol for consistency.  Update: Fixed as of commit 0267ae4d344df061c9e392dc1cf862de82ff43d6 in pull request #4083 by replacing the Voting.sol import with OracleAncillaryInterface.sol, which provides an interface for the hasPrice and getPrice voting functions used by ProposerV2.sol.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#erroneous-imports", "labels": ["OpenZeppelin"]}, {"title": "WithdrawnRewards is emitted for zero rewards", "body": "withdrawRewards function in the  emits a  the if block that checks for a non-zero value of  Consider only emitting the WithdrawnRewards event if tokensToMint is not zero.  Update: Fixed as of commit 703662231d4399a869e4ce990868cb2061f9e402 in pull request #4084.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#withdrawnrewards-is-emitted-for-zero-rewards", "labels": ["OpenZeppelin"]}, {"title": "Lack of immutable identifier", "body": "In the ProposerV2 contract, the mutable state variables token, governor, and finder are only set once within the constructor.  In the Staker contract, the mutable state variable votingToken is only set once within the constructor. Consider declaring these state variables as immutableto increase gas efficiency and enhance the clarity of your code base.  Update: Fixed as of commit 8be5f9c16f27e283f5cd5654e168a28d17b9d655 in pull request #4085.  Inconsistent declarations for finder variable  Finder contract to lookup the addresses of other deployed UMA contracts. While most contracts in the DVM implementation store a  FinderInterface type in their  Proposer and  ProposerV2 contracts store a  Additionally, some contracts declare their finder variable with private visibility, while others declare finder as a public variable.  Consider making these declarations consistent within the codebase by uniformly applying the same contract type and visibility to all instances of the finder storage variable.  Update: Partially fixed as of commit 2f5f667994c96612e95417de24f526b94a37b6c0 in pull request #4086. In the VotingV2 contract, the finder variables visibility was changed from private to public, but there is still an inconsistent application of private and public visibility applied to this variable across ProposerV2 (public), GovernorV2 (private), DesignatedVotingV2 (private), and VotingV2 (public). Additionally, Proposer and ProposerV2 still use the Finder type.  Inconsistent function naming  Throughout the codebase, a leading underscore is used to denote private and internal functions. However, several functions that are marked internal do not follow this pattern. To avoid confusion, consider the following renaming suggestions:  In Staking.sol:  inActiveReveal should be _inActiveReveal getStartingIndexForStaker should be _getStartingIndexForStaker  In VotingV2.sol:  applySlashToVoter should be _applySlashToVoter  Update: Fixed as of commit 59c103a5a378505203a1fc78146e494ed26905bb in pull request #4087.  Inconsistent event indexing  VotingV2 contract, the  PriceRequestAdded event applies the  time variable but not the  requester variable. All other events within this contract that emit a  To use indexing consistently, in the PriceRequestAdded event consider removing the indexed keyword from time and adding it to requester.  Update: Fixed as of commit c6a8f7e088aefb5d5b5f77407e3ef400fe743d77 in pull request #4088.  Misleading variable name  In the updateTrackersRange function, the indexTo parameter is the last price request index to update the trackers for. On line 810 there is a check that indexTo <= priceRequestIds.length; at first glance this appears to be an off-by-one error because array indexing starts at index 0 and the index is considered out of bounds if it is greater than or equal to the length of the array.  However, in the _updateAccountSlashingTrackers function, the for-loop test condition ensures that the maximum index value used to access the priceRequestIds array is indexTo - 1, thereby preventing any out-of-bounds access. Thus the logic appears correct, but the name indexTo is misleading because it specifies the maximum element number to include in the update, not the maximum index number.  To avoid confusion, consider renaming the indexTo variable, or update the documentation to clarify that this is not an array index value.  Update: Acknowledged. UMAs statement for this issue:  We chose to not implement any change for this note.  Use of magic values  In the VotingV2 contract, the function executeSpamDeletion contains the magic value 1e18 which represents a successful vote in favor of a spam deletion request.  Using inline magic values hinders code legibility and increases the chance of introducing erroneous values.  Consider assigning all magic values to descriptive constants and replacing all semantically matching occurrences of the value with its respective constant.  Update: Fixed as of commit baf99022bb69c0744a5b13b26610245c49c74b93 in pull request #4089 by eliminating the magic value 1e18 and interpreting any non-zero price value as a yes vote. This behavior is consistent with the existing price validation that is performed in the executeProposal function.  Misleading documentation  The code base contains multiple occurrences of misleading or incorrect documentation:  In the contract DesignatedVotingV2, the comment on line 21 Is also permanently permissioned as the minter role appears to be a copy & paste error as a minting function is not part of the contract. Consider removing the comment.  In the contract SlashingLibrary, the docstring for calcSlashing on line 55 contains the erroneous expression cross-chain calls. Consider altering it to cross-contract calls.  In the contract VotingV2, the comment on line 161 describes the spamDeletionProposals variable as Maps round numbers to the spam deletion request. However, mapping indices to values is a property every array possesses. Consider revising the comment to give a more contextual description of the identifier and its usage.  In the contract VotingV2, the docstring for getRoundEndTime on lines 716-719 appears to be a copy & paste error that duplicates the docstring of the getCurrentRoundId function. Consider rewriting the docstring.  In the contract VotingV2, the comment on line 767 This method is public because calldata structs are not currently supported by solidity. appears to be a copy & paste error, because no such struct is present in the functions arguments. Consider removing the comment.  Update: Fixed as of commit 6a4bd53200b18d25379ce9082922ba0eea286619 in pull request #4090.  Missing license identifier  The following files do not contain an SPDX License identifier:  SpamGuardIdentifierLib.sol  AdminIdentifierLib.sol  Missing license agreements can lead to legal disputes and undesired forms of code usage.  Consider adding a license identifier to all mentioned files.  Update: Fixed as of commit 2da561bcee2c72ae36eb4257f04c68537c6e2cd5 in pull request #4091.  Missing Solidity version pragma  The SpamGuardIdentifierLibs.sol and AdminIdentifierLib.sol files do not define a Solidity version pragma.  It is considered good practice to always specify the desired compiler version by using the Solidity version pragma. If the contract contains non-trivial operations the resulting bytecode might differ between Solidity versions including security relevant breaking changes and non-trivial bug fixes.  Consider defining Solidity version pragmas for all Solidity source files in this project.  Update: Fixed as of commit 2da561bcee2c72ae36eb4257f04c68537c6e2cd5 in pull request #4091.  Function with return type does not return value  In the DesignatedVotingV2 contract, both the signature of the retrieveRewards function and its docstring indicate that it returns a value, but the function has no return statement.  Consider adding the missing rewardsMinted return value in order to make the retrieveRewards function behavior match its public interface.  Update: Not fixed. The retreiveRewards function was renamed in pull request #4071 to withdrawAndRestakeRewards as suggested in issue L03, but the function still does not return a value.  Inconsistent use of named return variables  There is an inconsistent usage of named return variables across the codebase.  Occurrences of named return values are:  The getResolvedPrice function in the ResultComputationV2 contract  The calcSlashing function in the SlashingLibrary library  The _getIdentifierWhitelist function in the GovernorV2 contract  The _getIdentifierWhitelist function in the VotingV2 contract  The propose function in the ProposerV2 contract  Consider adopting a consistent approach to return values by removing all named return variables.  Update: Fixed as of commit b62a8c90355b6e6c8643e65d354a9a253962073b in pull request #4092. For clarity, the UMA team has retained the use of named return values only for functions that return multiple values. As a result, the getResolvedPrice and calcSlashing functions were left unchanged.  Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  In the VotingV2 contract, consider renaming the constant ancillaryBytesLimit to ANCILLARY_BYTES_LIMIT.  In the VotingV2 contract, the deletedRequests mapping is used to optimize the processing of the priceRequestIds array by skipping certain elements. The reason to skip an element could be deletion via the executeSpamDeletion function or the detection of a rolled vote within the _updateAccountSlashingTrackers function. The name deletedRequests is misleading as it only describes one of two origins for skips during request processing. Consider renaming the mapping to indicate the purpose of efficient request processing, e.g. skippedRequestIndexes.  In the VotingV2Interface interface, consider renaming the constant NUM_PHASES_PLACEHOLDER to NUM_PHASES.  Update: Fixed as of commit bf04d1dce70eadbdeeff4760fca1cae2ecc3651c in pull request #4094. All naming suggestions were implemented on the contracts in scope for this audit.  Public functions can be marked as external  The following functions are currently marked with public visibility, but can be declared external because they are never called internally by their own contracts or by child contracts:  In DesignatedVotingV2.sol:  retrieveRewards  In GovernorV2.sol:  propose  In Staker.sol:  requestUnstake executeUnstake withdrawAndRestake setEmissionRate setUnstakeCooldown  In VotingV2.sol:  commitVote (backwards compatible version only) commitAndEmitEncryptedVote (backwards compatible version only) executeSpamDeletion getCurrentRoundId getNumberOfPriceRequests getPendingRequests getPrice (backwards compatible version only) getPriceRequestStatuses (backwards compatible version only) getRoundEndTime getSpamDeletionRequest requestGovernanceAction requestPrice (backwards compatible version only) revealVote (backwards compatible version only) setDelegate setDelegator setGat setRewardsExpirationTimeout setSlashingLibrary signalRequestsAsSpamForDeletion updateTrackers updateTrackersRange  In SlashingLibrary.sol:  calcSlashing  Consider changing the visibility of these functions to external in order to reduce gas costs and clarify that these functions will only ever be called by external contracts.  Update: Fixed as of commit 940ccda23259963687988c3cf7ae954d599980e0 in pull request #4102. Note that the retrieveRewards function has been renamed to withdrawAndRestakeRewards.  Redundant code  Consider making the following changes to eliminate unnecessary code:  In Staker.sol:  line 26: The override keyword can be removed line 115: The override keyword can be removed line 151: The override keyword can be removed line 178: The override keyword can be removed line 199: The override keyword can be removed line 209: (tokensToMint) can be changed to tokensToMint  In VotingV2.sol:  lines 1005-1006: The uint256(i) casts can be changed to i  Update: Partially fixed as of commit 764d555eab7d58315561cd98904a06c24c980999 in pull request #4096. The changes in Staker.sol have been fully addressed, while the change to VotingV2.sol remains unaddressed. Also note that pull request #4096 inadvertently removes the immutable keyword that was added by pull request #4085 to the votingToken variable declaration in Staker.sol.  Amount to stake or unstake can be zero  Within the Staking contract, there are two functions that allow users to stake and unstake a specific amount of UMA tokens: stake and requestUnstake. Both functions have an amount parameter that specifies how many tokens to stake or unstake, but neither function checks whether this amount is zero. If the caller specifies an amount value of 0 for either function, all of the logic is still executed, wasting the users gas.  In both stake and requestUnstake, consider adding a check that amount is a non-zero value before proceeding.  Update: Acknowledged. UMAs statement for this issue:  We dont have any issue with a user unstaking 0, which is a no op.  Too many digits in numeric literals  Within the SlashingLibrary contract, the functions calcWrongVoteSlashPerToken and calcNoVoteSlashPerToken both return a hard-coded value of 1600000000000000. Numeric literals with a large number of digits are more difficult to interpret, requiring the reader or reviewer to count the number of digits to ensure correctness.  Solidity supports scientific notation representation for large values. Consider replacing these integer values with their more compact equivalent representation 1.6e15.  Update: Fixed as of commit 1d11705161a9d2d49943eace26ab6239886c21e8 in pull request #4097.  Typographical errors  Consider addressing the following typographical errors:  In DesignatedVotingV2.sol:  line 54: EG should be E.g. line 71: Eg: should be E.g. line 72: of for the price request should be of the price request line 75: voters should be voters line 89: EG should be E.g.  In GovernorV2.sol:  line 98: an an array should be an array  In ProposerV2.sol:  line 115: system, itself should be system itself  In SlashingLibrary.sol:  line 59: Remove space before wrongVoteSlashPerToken  In Staker.sol:  line 13: prorate should be pro rata line 53: voterPendingUnStake should be voterPendingUnstake line 91: prorate should be pro rata line 93: Remove erroneous comment line line 111: a active reveal should be an active reveal line 175-176: Remove the incomplete sentence that begins with Note that this\u2026 line 230: prorate should be pro rata line 231: prorate should be pro rata  In VoteTimingV2.sol:  line 31: roundID should be round ID line 44: round Id should be round ID (or roundId)  In VotingV2.sol:  line 26: UMAs DVM mechanism should be UMAs DVM (mechanism is redundant) line 52: UINT_MAX should be UINT64_MAX line 59: uint56 should be uint64 line 295: eg should be E.g. line 311: eg should be E.g. line 327: eg should be E.g. line 391: eg should be E.g. line 413: eg should be E.g. line 485: EG should be E.g. line 528: EG should be E.g. line 585: commits should be Commits line 588: Eg: should be E.g. line 589: of for the price request should be of the price request line 592: voters should be voters line 621: actors should be actions line 630: for delegator should be for the delegator line 631: two way should be two-way line 632: of the delegate should be of the delegator line 656: of type PendingRequest should be of type PendingRequestAncillary line 866: cant should be cant line 943: its should be its line 907: Remove blank line line 946: diregarded should be disregarded line 959: sequently should be sequential line 1134: pending request should be pending requests  Additionally, some errors were found in out-of-scope files:  In packages/core/README.md:  line 92: optimsim-up should be optimism-up  In packages/core/contracts/common/implementation/MultiCaller.sol:  line 1: Uniswapss should be Uniswaps  In packages/core/test/oracle/VotingV2.js:  line 2300: i.e should be i.e. line 2481: cant should be cant line 2482: cant should be cant line 2630: Dont should be Dont line 2708: cant should be cant line 2815: dont should be dont line 2857: i.e should be i.e.  Update: Fixed as of commit 69e9574f3ffb3b9085e58b731862c92728134710 in pull request #4098. All typos were corrected except for those identified in the VotingV2.js file, which was out of scope.  Unnecessary use of SafeMath library  imports the OpenZeppelin  SafeMath library and uses the librarys  line 144. Solidity version  introduced default underflow/overflow checks on all arithmetic operations. Since the  Consider removing the SafeMath.sol import from GovernorV2 and replacing the sub function with the - operator.  Update: Fixed as of commit 9714b2df60965edd99bec6cb674f01f6d5fb141b in pull request #4099.  Unused function parameters  SlashingLibrary contract defines a standard interface for the  Although the unused parameters are harmless in this case, the goal should be to have zero compiler warnings, in order to prevent other warnings mixed in with these from going unnoticed during compilation. Consider adding the following block of no-op code to the body of each of the aforementioned functions in order to suppress the compiler warnings:  This code would then be removed at a later date when these variables are used to perform slashing calculations.  Update: Acknowledged. UMAs statement for this issue:  We are ok with the compiler warnings for this and are not too worried about this.  Unused imports  The following files are imported but not used:  In the Staker contract, the Testable.sol contract  In the VotingV2 contract, the AncillaryData.sol library  In the VotingV2Interface contract, the FixedPoint.sol library  To improve readability and avoid confusion, consider removing the unused imports.  Update: Fixed as of commit 160c985d9560b78d41b2998d2ca40f4c1ef297b4 in pull request #4100 and commit 0f9bdee0d0584254a93c48fddf3987e2d8559a6e in pull request #4095.  State variable visibility not explicitly declared  Within VotingV2.sol the state variable spamDeletionProposalBond lacks an explicitly declared visibility.  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Fixed as of commit e3ae35386ddaa674145816c80a11b2117fff44ad in pull request #4101.  Conclusions  One critical and one high severity issue were found and subsequently resolved. Some changes were proposed to follow best practices and reduce potential attack surface. The supporting usage of a monitoring system and the addition of emergency administration functionality was recommended.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#lack-of-immutable-identifier", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent declarations for finder variable", "body": "Inconsistent declarations for finder variable", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#inconsistent-declarations-for-finder-variable", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent function naming", "body": "Throughout the codebase, a leading underscore is used to denote private and internal functions. However, several functions that are marked internal do not follow this pattern. To avoid confusion, consider the following renaming suggestions:  In Staking.sol:  inActiveReveal should be _inActiveReveal getStartingIndexForStaker should be _getStartingIndexForStaker  In VotingV2.sol:  applySlashToVoter should be _applySlashToVoter  Update: Fixed as of commit 59c103a5a378505203a1fc78146e494ed26905bb in pull request #4087.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#inconsistent-function-naming", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent event indexing", "body": "VotingV2 contract, the  PriceRequestAdded event applies the  time variable but not the  requester variable. All other events within this contract that emit a  To use indexing consistently, in the PriceRequestAdded event consider removing the indexed keyword from time and adding it to requester.  Update: Fixed as of commit c6a8f7e088aefb5d5b5f77407e3ef400fe743d77 in pull request #4088.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#inconsistent-event-indexing", "labels": ["OpenZeppelin"]}, {"title": "Misleading variable name", "body": "In the updateTrackersRange function, the indexTo parameter is the last price request index to update the trackers for. On line 810 there is a check that indexTo <= priceRequestIds.length; at first glance this appears to be an off-by-one error because array indexing starts at index 0 and the index is considered out of bounds if it is greater than or equal to the length of the array.  However, in the _updateAccountSlashingTrackers function, the for-loop test condition ensures that the maximum index value used to access the priceRequestIds array is indexTo - 1, thereby preventing any out-of-bounds access. Thus the logic appears correct, but the name indexTo is misleading because it specifies the maximum element number to include in the update, not the maximum index number.  To avoid confusion, consider renaming the indexTo variable, or update the documentation to clarify that this is not an array index value.  Update: Acknowledged. UMAs statement for this issue:  We chose to not implement any change for this note.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#misleading-variable-name", "labels": ["OpenZeppelin"]}, {"title": "Use of magic values", "body": "In the VotingV2 contract, the function executeSpamDeletion contains the magic value 1e18 which represents a successful vote in favor of a spam deletion request.  Using inline magic values hinders code legibility and increases the chance of introducing erroneous values.  Consider assigning all magic values to descriptive constants and replacing all semantically matching occurrences of the value with its respective constant.  Update: Fixed as of commit baf99022bb69c0744a5b13b26610245c49c74b93 in pull request #4089 by eliminating the magic value 1e18 and interpreting any non-zero price value as a yes vote. This behavior is consistent with the existing price validation that is performed in the executeProposal function.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#use-of-magic-values", "labels": ["OpenZeppelin"]}, {"title": "Misleading documentation", "body": "The code base contains multiple occurrences of misleading or incorrect documentation:  In the contract DesignatedVotingV2, the comment on line 21 Is also permanently permissioned as the minter role appears to be a copy & paste error as a minting function is not part of the contract. Consider removing the comment.  In the contract SlashingLibrary, the docstring for calcSlashing on line 55 contains the erroneous expression cross-chain calls. Consider altering it to cross-contract calls.  In the contract VotingV2, the comment on line 161 describes the spamDeletionProposals variable as Maps round numbers to the spam deletion request. However, mapping indices to values is a property every array possesses. Consider revising the comment to give a more contextual description of the identifier and its usage.  In the contract VotingV2, the docstring for getRoundEndTime on lines 716-719 appears to be a copy & paste error that duplicates the docstring of the getCurrentRoundId function. Consider rewriting the docstring.  In the contract VotingV2, the comment on line 767 This method is public because calldata structs are not currently supported by solidity. appears to be a copy & paste error, because no such struct is present in the functions arguments. Consider removing the comment.  Update: Fixed as of commit 6a4bd53200b18d25379ce9082922ba0eea286619 in pull request #4090.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Missing license identifier", "body": "The following files do not contain an SPDX License identifier:  SpamGuardIdentifierLib.sol  AdminIdentifierLib.sol  Missing license agreements can lead to legal disputes and undesired forms of code usage.  Consider adding a license identifier to all mentioned files.  Update: Fixed as of commit 2da561bcee2c72ae36eb4257f04c68537c6e2cd5 in pull request #4091.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#missing-license-identifier", "labels": ["OpenZeppelin"]}, {"title": "Missing Solidity version pragma", "body": "The SpamGuardIdentifierLibs.sol and AdminIdentifierLib.sol files do not define a Solidity version pragma.  It is considered good practice to always specify the desired compiler version by using the Solidity version pragma. If the contract contains non-trivial operations the resulting bytecode might differ between Solidity versions including security relevant breaking changes and non-trivial bug fixes.  Consider defining Solidity version pragmas for all Solidity source files in this project.  Update: Fixed as of commit 2da561bcee2c72ae36eb4257f04c68537c6e2cd5 in pull request #4091.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#missing-solidity-version-pragma", "labels": ["OpenZeppelin"]}, {"title": "Function with return type does not return value", "body": "In the DesignatedVotingV2 contract, both the signature of the retrieveRewards function and its docstring indicate that it returns a value, but the function has no return statement.  Consider adding the missing rewardsMinted return value in order to make the retrieveRewards function behavior match its public interface.  Update: Not fixed. The retreiveRewards function was renamed in pull request #4071 to withdrawAndRestakeRewards as suggested in issue L03, but the function still does not return a value.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#function-with-return-type-does-not-return-value", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent use of named return variables", "body": "There is an inconsistent usage of named return variables across the codebase.  Occurrences of named return values are:  The getResolvedPrice function in the ResultComputationV2 contract  The calcSlashing function in the SlashingLibrary library  The _getIdentifierWhitelist function in the GovernorV2 contract  The _getIdentifierWhitelist function in the VotingV2 contract  The propose function in the ProposerV2 contract  Consider adopting a consistent approach to return values by removing all named return variables.  Update: Fixed as of commit b62a8c90355b6e6c8643e65d354a9a253962073b in pull request #4092. For clarity, the UMA team has retained the use of named return values only for functions that return multiple values. As a result, the getResolvedPrice and calcSlashing functions were left unchanged.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#inconsistent-use-of-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Naming issues", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  In the VotingV2 contract, consider renaming the constant ancillaryBytesLimit to ANCILLARY_BYTES_LIMIT.  In the VotingV2 contract, the deletedRequests mapping is used to optimize the processing of the priceRequestIds array by skipping certain elements. The reason to skip an element could be deletion via the executeSpamDeletion function or the detection of a rolled vote within the _updateAccountSlashingTrackers function. The name deletedRequests is misleading as it only describes one of two origins for skips during request processing. Consider renaming the mapping to indicate the purpose of efficient request processing, e.g. skippedRequestIndexes.  In the VotingV2Interface interface, consider renaming the constant NUM_PHASES_PLACEHOLDER to NUM_PHASES.  Update: Fixed as of commit bf04d1dce70eadbdeeff4760fca1cae2ecc3651c in pull request #4094. All naming suggestions were implemented on the contracts in scope for this audit.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#naming-issues", "labels": ["OpenZeppelin"]}, {"title": "Public functions can be marked as external", "body": "The following functions are currently marked with public visibility, but can be declared external because they are never called internally by their own contracts or by child contracts:  In DesignatedVotingV2.sol:  retrieveRewards  In GovernorV2.sol:  propose  In Staker.sol:  requestUnstake executeUnstake withdrawAndRestake setEmissionRate setUnstakeCooldown  In VotingV2.sol:  commitVote (backwards compatible version only) commitAndEmitEncryptedVote (backwards compatible version only) executeSpamDeletion getCurrentRoundId getNumberOfPriceRequests getPendingRequests getPrice (backwards compatible version only) getPriceRequestStatuses (backwards compatible version only) getRoundEndTime getSpamDeletionRequest requestGovernanceAction requestPrice (backwards compatible version only) revealVote (backwards compatible version only) setDelegate setDelegator setGat setRewardsExpirationTimeout setSlashingLibrary signalRequestsAsSpamForDeletion updateTrackers updateTrackersRange  In SlashingLibrary.sol:  calcSlashing  Consider changing the visibility of these functions to external in order to reduce gas costs and clarify that these functions will only ever be called by external contracts.  Update: Fixed as of commit 940ccda23259963687988c3cf7ae954d599980e0 in pull request #4102. Note that the retrieveRewards function has been renamed to withdrawAndRestakeRewards.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#public-functions-can-be-marked-as-external", "labels": ["OpenZeppelin"]}, {"title": "Redundant code", "body": "Consider making the following changes to eliminate unnecessary code:  In Staker.sol:  line 26: The override keyword can be removed line 115: The override keyword can be removed line 151: The override keyword can be removed line 178: The override keyword can be removed line 199: The override keyword can be removed line 209: (tokensToMint) can be changed to tokensToMint  In VotingV2.sol:  lines 1005-1006: The uint256(i) casts can be changed to i  Update: Partially fixed as of commit 764d555eab7d58315561cd98904a06c24c980999 in pull request #4096. The changes in Staker.sol have been fully addressed, while the change to VotingV2.sol remains unaddressed. Also note that pull request #4096 inadvertently removes the immutable keyword that was added by pull request #4085 to the votingToken variable declaration in Staker.sol.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Amount to stake or unstake can be zero", "body": "Within the Staking contract, there are two functions that allow users to stake and unstake a specific amount of UMA tokens: stake and requestUnstake. Both functions have an amount parameter that specifies how many tokens to stake or unstake, but neither function checks whether this amount is zero. If the caller specifies an amount value of 0 for either function, all of the logic is still executed, wasting the users gas.  In both stake and requestUnstake, consider adding a check that amount is a non-zero value before proceeding.  Update: Acknowledged. UMAs statement for this issue:  We dont have any issue with a user unstaking 0, which is a no op.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#amount-to-stake-or-unstake-can-be-zero", "labels": ["OpenZeppelin"]}, {"title": "Too many digits in numeric literals", "body": "Within the SlashingLibrary contract, the functions calcWrongVoteSlashPerToken and calcNoVoteSlashPerToken both return a hard-coded value of 1600000000000000. Numeric literals with a large number of digits are more difficult to interpret, requiring the reader or reviewer to count the number of digits to ensure correctness.  Solidity supports scientific notation representation for large values. Consider replacing these integer values with their more compact equivalent representation 1.6e15.  Update: Fixed as of commit 1d11705161a9d2d49943eace26ab6239886c21e8 in pull request #4097.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#too-many-digits-in-numeric-literals", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider addressing the following typographical errors:  In DesignatedVotingV2.sol:  line 54: EG should be E.g. line 71: Eg: should be E.g. line 72: of for the price request should be of the price request line 75: voters should be voters line 89: EG should be E.g.  In GovernorV2.sol:  line 98: an an array should be an array  In ProposerV2.sol:  line 115: system, itself should be system itself  In SlashingLibrary.sol:  line 59: Remove space before wrongVoteSlashPerToken  In Staker.sol:  line 13: prorate should be pro rata line 53: voterPendingUnStake should be voterPendingUnstake line 91: prorate should be pro rata line 93: Remove erroneous comment line line 111: a active reveal should be an active reveal line 175-176: Remove the incomplete sentence that begins with Note that this\u2026 line 230: prorate should be pro rata line 231: prorate should be pro rata  In VoteTimingV2.sol:  line 31: roundID should be round ID line 44: round Id should be round ID (or roundId)  In VotingV2.sol:  line 26: UMAs DVM mechanism should be UMAs DVM (mechanism is redundant) line 52: UINT_MAX should be UINT64_MAX line 59: uint56 should be uint64 line 295: eg should be E.g. line 311: eg should be E.g. line 327: eg should be E.g. line 391: eg should be E.g. line 413: eg should be E.g. line 485: EG should be E.g. line 528: EG should be E.g. line 585: commits should be Commits line 588: Eg: should be E.g. line 589: of for the price request should be of the price request line 592: voters should be voters line 621: actors should be actions line 630: for delegator should be for the delegator line 631: two way should be two-way line 632: of the delegate should be of the delegator line 656: of type PendingRequest should be of type PendingRequestAncillary line 866: cant should be cant line 943: its should be its line 907: Remove blank line line 946: diregarded should be disregarded line 959: sequently should be sequential line 1134: pending request should be pending requests  Additionally, some errors were found in out-of-scope files:  In packages/core/README.md:  line 92: optimsim-up should be optimism-up  In packages/core/contracts/common/implementation/MultiCaller.sol:  line 1: Uniswapss should be Uniswaps  In packages/core/test/oracle/VotingV2.js:  line 2300: i.e should be i.e. line 2481: cant should be cant line 2482: cant should be cant line 2630: Dont should be Dont line 2708: cant should be cant line 2815: dont should be dont line 2857: i.e should be i.e.  Update: Fixed as of commit 69e9574f3ffb3b9085e58b731862c92728134710 in pull request #4098. All typos were corrected except for those identified in the VotingV2.js file, which was out of scope.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary use of SafeMath library", "body": "imports the OpenZeppelin  SafeMath library and uses the librarys  line 144. Solidity version  introduced default underflow/overflow checks on all arithmetic operations. Since the  Consider removing the SafeMath.sol import from GovernorV2 and replacing the sub function with the - operator.  Update: Fixed as of commit 9714b2df60965edd99bec6cb674f01f6d5fb141b in pull request #4099.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#unnecessary-use-of-safemath-library", "labels": ["OpenZeppelin"]}, {"title": "Unused function parameters", "body": "SlashingLibrary contract defines a standard interface for the  Although the unused parameters are harmless in this case, the goal should be to have zero compiler warnings, in order to prevent other warnings mixed in with these from going unnoticed during compilation. Consider adding the following block of no-op code to the body of each of the aforementioned functions in order to suppress the compiler warnings:  This code would then be removed at a later date when these variables are used to perform slashing calculations.  Update: Acknowledged. UMAs statement for this issue:  We are ok with the compiler warnings for this and are not too worried about this.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#unused-function-parameters", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "The following files are imported but not used:  In the Staker contract, the Testable.sol contract  In the VotingV2 contract, the AncillaryData.sol library  In the VotingV2Interface contract, the FixedPoint.sol library  To improve readability and avoid confusion, consider removing the unused imports.  Update: Fixed as of commit 160c985d9560b78d41b2998d2ca40f4c1ef297b4 in pull request #4100 and commit 0f9bdee0d0584254a93c48fddf3987e2d8559a6e in pull request #4095.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "State variable visibility not explicitly declared", "body": "Within VotingV2.sol the state variable spamDeletionProposalBond lacks an explicitly declared visibility.  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Fixed as of commit e3ae35386ddaa674145816c80a11b2117fff44ad in pull request #4101.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#state-variable-visibility-not-explicitly-declared", "labels": ["OpenZeppelin"]}, {"title": " Issues", "body": "0 (0 resolved)  High Severity", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#-issues", "labels": ["OpenZeppelin"]}, {"title": "0 (0 resolved)", "body": "Medium Severity Issues  4 (4 resolved)  Low Severity Issues  16 (14 resolved)  Notes & Additional Information  15 (7 resolved, 1 partially resolved)  Scope  We audited the matter-labs/zksync-2-dev repository at the c05b49d7e303996f60a0e35f18ef224e45ee19f5 commit.  In scope were the following contracts:  System Overview  zkSync is a layer 2 scaling solution for Ethereum based on zero-knowledge rollup technology. The protocol aims to provide low transaction fees and high throughput while maintaining full EVM compatibility.  In zkSync users sign and send transactions to validators who process them, include them into blocks, and create a cryptographic commitment of the updated state. This commitment (root hash) is then transferred to a smart contract on layer 1 along with a cryptographic proof (SNARK) proving that this new state was correctly calculated based on applying transactions to a previous state. A compressed state update is also sent to layer 1, allowing anyone to reconstruct the state at any moment. The layer 1 contract validates both the state update and the cryptographic proof, assuring the validity of the transactions included in the block and the data availability.  zkSync protocol implements the Diamond Proxy EIP-2535 as an upgrade mechanism, thereby splitting its functionality into four different facets:  Executor: Processing rollups of layer 2 blocks  Mailbox: Bidirectional communication between layer 1 and layer 2  DiamondCut: Contract administration  Governance: Role management  Note that while the aforementioned EIP does not contain any known issues, it is not yet considered finalized.  Executor  The Executor component allows validators to commit, prove, and execute blocks. All blocks are tentative before execution and can be removed by any validator. This component is central in extending the security guarantees of layer 1 to transactions on layer 2 through rollups.  Mailbox  The Mailbox component handles bi-directional communications between layer 1 (L1) and layer 2 (L2). To request an L2 transaction from L1, the transaction data is appended to a queue and removed from it upon final inclusion of the L2-rollup into the L1 contract.  In contrast, communication from L2 to L1 is divided in two parts: Sending a transaction on L2 and reading it from L1. To send information from L2, a special opcode sendToL1 is implemented. Using this opcode, users can send logs or messages. Logs provide a key-value tuple of 32 bytes each to encode data while messages can be of arbitrary length. The transfer of messages is possible via a special system contract converting it into a log containing a hash-commitment. All logs are individually hashed to form the leaf nodes of a blocks fixed-size Merkle tree. The proof of inclusion is made available on L1 by checking against the Merkle tree root. Upon committing a block, verifications are performed to ensure data availability, enabling anyone to prove message inclusion without additional help from the operator.  DiamondCut  Note: For a comprehensive explanation of the diamond update mechanism please refer to EIP-2535.  This component manages upgrade-related operations and freezing/unfreezing of facets. The upgrade mechanism is comprised of three stages:  Upgrade proposal  In this stage, the governor commits both a sequence of changes (add/replace/remove) to the supported facet functions and the fixed address of an initializer contract.  Upgrade notice period  zkSync users are given a constant timeframe to withdraw their funds if they are against the proposed upgrade, unless the Security Council approves an immediate emergency upgrade, thereby skipping the execution delay.  Upgrade execution  The governor can execute the upgrade and provide additional calldata to the initializer contract.  Freezing Mechanism  Matter Labs team has implemented a freezing feature. When defining the facet through diamond cuts, each facet can be set as freezable or not. The governor can freeze the diamond as a whole which affects all freezable facets. Therefore, it is possible to designate parts that shall remain operational in an emergency situation. It is crucial for the DiamondCut facet to remain operational in order to enable the governor to unfreeze the Diamond Proxy after resolving the emergency situation.  Governance  The Governance component allows the governor to assign and remove the valdiator role from addresses. It further enables the transition of contract administration to a new governor by designating a pending governor who needs to accept his role in an additional step thereby removing the old governor.  Operation Modes  Regular Operation  This operation mode allows only registered validators to commit and execute blocks with rolled-up layer 2 transaction information. Thus, users are dependent on the validators to not censor their transactions. To protect against malfunction and malice a second operation mode exists.  Priority Mode  Under specific conditions the system can enter a special operation mode called Priority Mode. This mechanism is intended as an escape hatch to allow users to withdraw their funds from zkSync protocol in the case an operator becomes malicious or unavailable. During the course of this audit this feature was out of scope due to the fact that it was not yet implemented.  Privileged Roles and Security Assumptions  The governor is a single address that can perform critical administrative actions such as proposing, canceling, and executing upgrades of the Diamond Proxy, as well as freezing and unfreezing the proxy. The governor is restricted by a time-delay between proposal and execution of any upgrade. However, no other entity can veto, postpone, or restrict the governors actions. Further, the governor can set and unset addresses as validators. The governor is considered a trusted entity.  The security council is a set of addresses that can skip the time-delay within the approval process of upgrades proposed by the governor to allow immediate incidence response actions. The security council has no power to propose, delay, or veto actions. The exact size of the security council, its members, or the threshold of security council votes to allow immediate execution of a proposal has not been determined at the time of the audit.  The Verifier is a smart contract on layer 1 in charge of verifying zk-proofs. It exposes a function that returns a Boolean value indicating whether a given proof is valid. During the course of this audit this feature was out of scope due to the fact that it was not yet implemented.  The validators are a set of layer 1 addresses in charge of bundling transactions into blocks, executing them on layer 2, committing their compressed information to layer 1, requesting their zk-proof, and finalizing them on layer 1. Additionally, they are in charge of forwarding messages between layer 1 and layer 2. The validators are partially trusted  at the time of the audit no escape hatch was implemented, hence it is necessary to trust the validators not to censor transactions and refuse/abandon operation. However, the verification of transactions via zk-proofs mathematically prevents validators from spoofing transactions or relaying false information. At the time of the audit, the validators are a centralized entity, while future decentralization is planned.  A set of four system contracts on layer 2 has privileged roles and performs special operations:  The Contract Deployer is in charge of deploying contracts on layer 2 via a hash-commitment to the contracts bytecode.  The IL1Messenger is a contract that allows the transfer of arbitrary-length messages from layer 2 to layer 1 by using a hash commitment within the fixed-size data exchange struct L2Log.  The INonceHolder stores transaction and deployment nonces for accounts and exposes them via view functions.  The Bootloader acknowledges received requests which have been passed from layer 1 to layer 2 via the priority queue mechanism.  Medium Severity", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#0-(0-resolved)", "labels": ["OpenZeppelin"]}, {"title": "Corruption of facets array on selector replacement", "body": "The Diamond library allows replacing a selectors facet with itself which is non-compliant with EIP-2535.  Moreover, an edge-case in which a facet only has one selector and this selectors facet is replaced with itself leads to corruption of the DiamondStorage.facets array. Consider the following scenario:  A facet has an array of selectors containing only one element [s1]. Through the function diamondCut a call to _replaceFunctions is initiated.  Inside of _replaceFunctions, the call to _saveFacetIfNew does not add any facet, because the facet is already registered.  Inside of the loop iterating through the selector array [s1], the call to _removeOneFunction triggers a call to _removeFacet due to the last selector being removed. This in turn removes the facet from the ds.facets array.  The subsequent call to _addOneFunction adds selector s1 back to the facet, while the facet remains deleted from the ds.facets array, thereby corrupting it.  To be fully compliant with the EIP-2535 spec and mitigate the edge-case leading to a corruption of the facets array, consider adding the requirement that _facet and oldFacet.facetAddress are distinct from each other.  Update: Fixed in commit f6cde78. The team mitigated this edge-case by rearranging the code. However, with the missing distinction check, the implementation is not fully EIP-2535 compliant.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#corruption-of-facets-array-on-selector-replacement", "labels": ["OpenZeppelin"]}, {"title": "Freezable property applies to individual selectors instead of facets", "body": "In the DiamondProxy contract, a selector is mapped to a facet via the mapping diamondStorage.selectorToFacet upon executing the fallback function. The received datastructure of type Diamond.SelectorToFacet contains the information  address  facetAddress  uint16  selectorPosition  bool  isFreezable  The flag isFreezable is used to determine whether the delegatecall of the given selector to the respective facet should be executed.  At the same time, it is the stated intent of the system to allow freezability on the granularity level of facets: While the Diamond shall have a global flag to determine whether it is frozen or not. Each facet shall be marked as either freezable or not.  An issue arises, because the selectorToFacet mapping allows different values for the flag isFreezable for different selectors of the same facet. Which would allow for freezability on the granularity of selectors instead of facets. Consider the following example of two different selectors, one freezable, one not, belonging to the same facet:  [selector1  = SelectorToFacet  (facet1  true  ) selectorToFacet  [selector2  = SelectorToFacet  (facet1  false  Moreover, the initialization of the selectorToFacet mapping within the Diamond library in function diamondCut actually allows the assignment of different values for isFreezable. Consider the following example for the facetCuts array:  (facet1  , Add  true  [selector1  ]),  (facet1  , Add  false  [selector2  ])  which will lead to an initialization of the selectorToFacet mapping given in the example above.  To prevent selector-level granularity of the freezabilitiy property, consider removing the isFreezable property from the Diamond.SelectorToFacet datatype and add it to a datatype describing only the facet thereby establishing a 1:1 mapping between facet and freezability.  Update: Fixed in commit e39eb07.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#freezable-property-applies-to-individual-selectors-instead-of-facets", "labels": ["OpenZeppelin"]}, {"title": "Merkle library verifies intermediate inputs", "body": "The Merkle library enables verification of a Merkle proof by performing an inclusion check of an input against a binary tree. This works by consecutively hashing concatenated sibling nodes until a root hash is generated. The input is one of the leaf hash values, while the proof is a path through the tree containing the missing hash information to regenerate the root.  An issue arises in this library, due to the arbitrary length of the proof. This allows shorter paths to resolve to the same root. Hence, the known hash of an intermediate node is a valid input as well. To visualize, considering the leaf nodes h0 and h1, the hashed concatenation hash(h0 || h1) of those hashes would be a valid input along a shorter path. An attacker could utilize the known pre-image to prove its inclusion in the tree. For the standalone library this is a critical problem.  In this particular codebase the Merkle library is solely used in the MailboxFacet contact to prove the inclusion of a transaction within a set of layer 2 logs. Thus, only inputs of type L2Log with a length of 88 bytes are legitimate, while the pre-images of size 64 bytes contained within the Merkle tree are not. However, any future usage on 64 bytes input would lead to a critical vulnerability.  It was also stated that the incomplete tree of fixed size is filled with the default hash hash(\"\"). This allows an attacker to prove the inclusion of empty bytes by default. Although, no threat was identified for the contracts in scope.  Consider strictly checking the path length of the proof against the desired Merkle tree depth to mitigate the first issue. Further, consider using a default leaf hash with unknown pre-image as countermeasure to the second attack. With respect to documentation, consider sticking to the leaf wording for variable naming.  Update: Fixed in commit 7eb51d9. Additional checks have been applied outside of the Merkle library to filter malicious inputs. The library itself remains vulnerable to the attack if used in a different context. A note about this problem was added to the function documentation with commit 5f02309.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#merkle-library-verifies-intermediate-inputs", "labels": ["OpenZeppelin"]}, {"title": "Proof replayability", "body": "In the proveBlocks function of the ExecutorFacet contract, there is no linkage between the committed blocks and the proof. The respective check is commented out in line 213. However, as it is commented out, the following is applicable.  The provided proof data is self-contained. Hence, the validator verifies that the given proof is valid in itself. Seeing the validator as a black box, it is assumed that there is no back checking against the committed blocks provided during the call. Therefore, the independence between the committed blocks and proof suggests a replay attack. By providing any formerly valid proof the previously committed blocks would be validated. Thus, all users could verify committed blocks, whether valid or not.  As documented in the code, the necessary check is there but commented out, which is based on the argument that the Verifier contract is not yet implemented. However, the commitment check between the blocks and proof has nothing to do with the Verifier. Therefore, consider incorporating this crucial check as part of the finalized codebase.  Update: Fixed in commit 64d6aec.  Low Severity  _proveBlock while loop could run out of gas  In the ExecutorFacet contract within the proveBlocks function, there is a while loop to skip already verified blocks. The loop condition is defined as:  while  (_hashStoredBlockInfo  (_committedBlocks  [i  ])  != firstUnverifiedBlockHash  Therefore, if the committed blocks do no contain the first unverified block, this loop will eventually run out of gas and revert.  Consider limiting the number of loop iterations to the length of the _committedBlocks array and reverting with an expressive error message in case the block was not found.  Update: Fixed in commit df107f0.  DiamondInit can be initialized itself  The DiamondInit contract is designed to initialize the DiamondProxy or any new facet via a delegatecall from the proxy contract. Therefore, the DiamondInit contract is deployed on its own with an unprotected initialize function.  Hence, anyone could initialize the deployed instance of the DiamondInit contract itself. While this isnt identified as a threat, it is good practice to prevent arbitrary callers from initializing contracts.  Consider initializing the DiamondInit contract via the constructor or adding a security mechanism to the initialize function.  Update: Fixed in commit c9089a5.  lastDiamondFreezeTimestamp is unused  In the DiamondCutFacet contract, the diamond can be frozen to allow inspection of the protocols security. Currently, as part of the emergencyFreezeDiamond function, s.diamondCutStorage.lastDiamondFreezeTimestamp is set but not used elsewhere in the code.  Consider either implementing a use-case for this variable or removing it.  Update: Acknowledged, not fixed. The Matter Labs team states:  While this feature was not included into this release we prefer to keep the variable to facilitate the rollout of the feature once it is ready.  Freezability differences between logical components  The usage of the Diamond Proxy pattern allows very modular changes to the system. The standard foresees moving individual selectors from facet to facet. Hence, one logical component (e.g. the ExecutorFacet) could be split into two facets, due to patching a single function and migrating the selector to the new facet, while the rest of the logic is kept in the old facet. As the first selector to the new facet defines the freezability, this could result in two different freeze capabilities for one high-level logical component (ExecutorFacet).  Implementing checks to cover the joint freezability for the logical facet would introduce additional overhead. Instead, consider extensively documenting this behavior in the DiamondCutFacet contract.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.  Gas optimizations  Throughout the codebase there are multiple instances where gas costs can be optimized:  In line 162 of the Diamond library the uint16 cast is unnecessary and can be removed.  Using the delete keyword instead of overwriting with the default value saves gas in these instances:  line 33 of Governance facet. line 119-121 of DiamondCutFacet contract.  In the approveEmergencyDiamondCutAsSecurityCouncilMember function, the s.diamondCutStorage.currentProposalId variable can be written to stack and reused.  In the ExecutorFacet contract on line 113 and 155 two bytes32 values are encoded and hashed. Consider using the abi.encode function for the encoding to be more gas efficient.  In the ExecutorFacet contract, consider writing the _maxU256 return value to stack to save on the following s.totalBlocksCommitted storage reads.  Consider applying the above changes to be more gas efficient.  Update: Fixed in commit 5a4e81a. However, the fix introduced a redundant check of conditions within the function approveEmergencyDiamondCutAsSecurityCouncilMember.  Interface and contract function parameter mismatch  The revertBlocks function has a different parameter name in IExecutor compared to ExecutorFacet. While in the interface the _blocksToRevert parameter suggests reverting a relative amount of blocks, the logic sets an absolute _newLastBlock which is confusing.  Further, in the requestL2Transaction function two parameters have a mismatch between the MailboxFacet and the IMailbox interface.  Consider correcting the above mismatches in favor of consistency and clarity.  Update: Fixed in commit c0600e0.  Getter returns misleading value  In the GettersFacet contract, the function isFunctionFreezable returns a Boolean value indicating whether a given selector is freezable or not. This value is taken from storage without any prior validation. At the same time, any uninitialized storage in Solidity contains the default value zero/false.  Querying the function isFunctionFreezable for an unknown selector will return false, thereby misleading the user to believe that the selector is used within the Diamond and is not freezable.  Consider validating the existence of the selector by requiring that the facet address of the selector is registered.  Update: Fixed in commit cfe6f54.  Lack of Documentation  Docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted. In the case of structs, docstrings should explain the overall purpose of the struct, each field contained in it, and clarify whether the struct is supposed to be persisted in storage or limited to memory and calldata. If the codebase does not have proper docstrings, it hinders reviewers understanding of the codes intention and increases the maintenance effort for contributors.  Throughout the zksync-2-dev codebase there are several parts that do not have docstrings. For instance:  In the Storage.sol contract the following identifiers lack sufficient documentation:  The DiamondCutStorage struct including all fields  The L2Log struct including all fields  The storage information of the L2Message struct as well as its txNumberInBlock field  In the IMailbox.sol interface the following constructs lack sufficient documentation:  The L2CanonicalTransaction struct including all fields  The NewPriorityRequest event including all fields  In the Mailbox.sol contract the following functions lack sufficient documentation:  The proveL2MessageInclusion function  The proveL2LogInclusion function  The l2TransactionBaseCost function  The requestL2Transaction function  The serializeL2Transaction function  In the IExecutor.sol interface the following structs lack sufficient documentation:  The StoredBlockInfo struct, especially fields blockHash, indexRepeatedStorageChanges, stateRoot  The CommitBlockInfo struct, especially field indexRepeatedStorageChanges  The ProofInput struct including all fields  In the DiamondCut.sol contract the following functions lack sufficient documentation:  The emergencyFreezeDiamond function  The unfreezeDiamond function  The approveEmergencyDiamondCutAsSecurityCouncilMember function  In the IGetters.sol interface the following structs lack sufficient documentation:  The Facet struct including all fields  SelectorExtended struct including all fields  FacetExtended struct including all fields  In the Diamond.sol library the following identifiers lack sufficient documentation:  The DiamondStorage struct and all of its fields  The FacetCut struct and all of its fields  The DiamondCutData struct and all of its fields  The diamondCut function  The getDiamondStorage function  In the PriorityQueue.sol library the following identifiers lack sufficient documentation:  The Queue struct and all its fields  The getLastProcessedPriorityTx function  The getTotalPriorityTxs function  The getSize function  The isEmpty function  The pushBack function  The front function  The popFront function  Consider thoroughly documenting all structs and functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec). While applying the NatSpec tags, make sure to be consistent with the usage of the respective tag. For instance, use @notice for a general description and @dev for technical aspects.  Update: Fixed in commit 8abb05c.  Lack of event information  Throughout the codebase we found the following occurrences of state changes without event emission and event emissions with insufficient or incorrect information:  In the ExecutorFacet contract  the proveBlocks function does not emit an event after altering the storage variable s.totalBlocksVerified. Consider creating a new event that can emit both the old and new value of this variable. the BlocksRevert event is used as BlocksRevert(s.totalBlocksExecuted, s.totalBlocksCommitted) which differs from its definition BlocksRevert(uint256 totalBlocksVerified, uint256 totalBlocksCommitted) within the IExecutor interface. Consider replacing s.totalBlocksExecuted with s.totalBlocksVerified.  In the IExecutor interface  the BlockCommit event only contains the blockNumber, which might not be unique due to block reversion. Consider adding indexed fields for blockHash and commitment. the BlockExecution event only contains the blockNumber. Consider adding indexed fields for blockHash and commitment.  In the IGovernance interface the NewGovernor event emits the new governor. To ease tracking the responsibility of this important role, consider emitting both  the old and new governor  as indexed addresses.  In the IDiamondCut interface  the EmergencyDiamondCutApproved event only emits the address of the approver, but no information about the diamondcut proposal. Consider indexing the address field and adding the fields currentProposalId, securityCouncilEmergencyApprovals and the indexed field proposedDiamondCutHash. the Unfreeze event does not emit additional information. Consider adding the lastDiamondFreezeTimestamp as an event field. the DiamondCutProposalCancelation event does not emit additional information. Consider adding a currentProposalId field and the indexed field proposedDiamondCutHash.  Consider emitting events for all state changes and include all relevant state transition information in them to allow precise monitoring via off-chain systems. Consider indexing event fields to facilitate their usage as a search key.  Update: Fixed in commit 79fd845.  Lack of l2Logs validation  ExecutorFacet contract within the  _processL2Logs. While any L2 user can be the sender of  While the system implicitly assumes that exactly one L2Log of sender L2_SYSTEM_CONTEXT_ADDRESS is present in each block, this assumption is not enforced during block commitment.  Consider enforcing that only one L2Log with sender L2_SYSTEM_CONTEXT_ADDRESS is present in each block.  Update: Fixed in commit dfc6fe1.  Preimage hash collision protection for storage pointers  The Diamond Proxy makes use of the diamond storage pattern to track the facets and selectors in use. This is achieved through a DiamondStorage struct that contains the relevant facet and selector information. Because of the proxy setup, this struct is placed in an unstructured-storage-manner at a pseudo random storage slot calculated by hashing a hardcoded string.  In the event of introducing a dynamic slot calculation using hashing, the DiamondStorage storage slot could be specifically addressed to force a collision using the known input bytes from above.  To prevent this pre-image hash collision, consider applying a -1 offset to the hash.  Update: Fixed in commit 60b74e0.  Require statements with multiple conditions  Throughout the codebase there are require statements that require multiple conditions to be satisfied. For instance:  The require statement on line 37 of Executor.sol  The require statement on line 251 of Diamond.sol  The require statement on line 17 of Merkle.sol  To simplify the codebase and to raise the most helpful error messages for failing require statements, consider having a single require statement per condition.  Update: Fixed in commit b87267c.  Confusing event emission when executing diamond cut proposals  In the DiamondCutFacet contract, the executeDiamondCutProposal function is used to execute a previously proposed upgrade.  This function resets the scheduled diamond cut proposal, thereby re-purposing the _resetProposal function. When this function is successfully executed it triggers a DiamondCutProposalCancelation event. Afterwards, DiamondCutProposalExecution event is triggered by executeDiamondCutProposal function.  This dual event emission of cancellation followed by execution could lead to confusion in off-chain systems.  To prevent emitting a cancellation event during the execution of a diamond cut proposal, consider moving the emission of the DiamondCutProposalCancelation event from the _resetProposal function to the cancelDiamondCutProposal function.  Update: Fixed in commit fad57c5.  Unused input to commit blocks  In the ExecutorFacet contract, the _commitOneBlock function does not make use of the input _newBlock.priorityOperationsHash. Instead, a local variable priorityOperationsHash is calculated from the _newBlock.l2Logs and included in the block commitment.  Consider validating both values against each other.  Update: Fixed in commit 615b6a5.  Unused L2Messages can be committed to L1  ExecutorFacet contract the validator provides multiple blocks of type  CommitBlockInfo to the  commitBlocks function, which are validated in several steps including  _processL2Logs. In this function, the preimages contained in the  currentMessage is incremented only based on the  Consider the addition of a final check of currentMessage against the length of the _newBlock.l2ArbitraryLengthMessages array at the end of the _processL2Logs function to ensure that only relevant preimages have been included in the calldata.  Update: Fixed in commit 25913e7.  Unverified inputs during block commitment  In the ExecutorFacet contract the _commitOneBlock function takes the _newBlock parameter to validate, extract, and transform block information into a StoredBlockInfo struct, which is hashed and stored on chain as a commitment. With a valid zero-knowledge proof this data can later be verified and executed.  However, several fields of the _newBlock input parameter are not validated. This could lead to successful commitments of blocks that eventually will not be executable.  Consider preventing the commitment of unexecutable blocks by:  Validating the field numberOfLayer1Txs against the number of L2Logs with sender L2_BOOTLOADER_ADDRESS.  Validating the field l2LogsTreeRoot against a reconstruction of the Merkle tree from the l2Logs array.  Validating the field timestamp against the local variable blockTimestamp.  Update: Fixed in commit 230f400. The Matter Labs team states:  We have applied the recommendations #1 and #3. The recommendation #2 is redundant as it is already covered by zero knowledge proofs. Verifying this on Layer 1 would be too expensive so by design this is entrusted to zero knowledge cryptography.  Notes & Additional Information  AppStorage partially lacks getter functions  The GettersFacet contract does not expose the entire AppStorage via view functions. The following storage parts remain inconvenient to read for an outside actor:  Every aspect of diamondCutStorage  The pendingGovernor address  The storedBlockHashes mapping  The functions getSize and front of priorityQueue as well as a function to determine the position of elements within the queue  Additionally, there is an input size mismatch between the l2LogsRootHashes mapping, which takes an uint256 key, and the l2LogsRootHash getter function, which takes a uint32 parameter.  Consider exposing all relevant information via getter functions and ensure that function parameters and mapping keys are type-identical.  Update: Fixed in commit 6b99055.  Block info structs have redundant parameters  The structs StoredBlockInfo and CommitBlockInfo of the IExecutor interface have the following parameters in common:  blockNumber  indexRepeatedStorageChanges  numberOfLayer1Txs  priorityOperationsHash  l2LogsTreeRoot  timestamp  Consider moving these parameters to a separate BaseBlockInfo struct which is then included into StoredBlockInfo and CommitBlockInfo respectively. Note, this will affect the way the variables are accessed.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.  Confusing identifier names  Throughout the codebase we found multiple occurrences of identifier names creating confusion:  In the IExecutor interface the parameter name used in the signature of the revertBlocks function is _blocksToRevert. However, the implementation of said function within ExecutorFacet calls the same parameter _newLastBlock which is consistent with its usage.  In the PriorityQueue library the variables head and tail account for where to add and remove items from the list. Unintuitively, the head points to the end of the queue and tail points to the front of the queue.  Consider renaming confusing identifiers to prevent misunderstandings and incorrect usage.  Update: Fixed in commit 03e04cb and c0600e0.  Direct usage of library struct fields  In the MailboxFacet contract, the function _requestL2Transaction reads the head of the priority queue via direct access to the respective field.  However, it is best practice to decouple the internal structure of a library from the functionality it exposes to other contracts through its functions.  Consider replacing the direct access of struct field head with a call to the getter function getTotalPriorityTxs that exposes the same information.  Update: Fixed in commit 8b97af.  Lack of ERC-165 support  External contracts and third-party integrations have no means to discover interfaces supported by the codebase.  Consider implementing the supportsInterface function of the ERC-165 standard to expose information about implemented interfaces.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk and comes with additional maintenance overhead if the system is expected to change in the future. We have added it to our development backlog to be addressed once we are out of alpha version.  File and contract name mismatch  There is a general mismatch between the facet contract names and their file names. While the contrac", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#proof-replayability", "labels": ["OpenZeppelin"]}, {"title": "_proveBlock while loop could run out of gas", "body": "_proveBlock while loop could run out of gas", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#_proveblock-while-loop-could-run-out-of-gas", "labels": ["OpenZeppelin"]}, {"title": "DiamondInit can be initialized itself", "body": "DiamondInit can be initialized itself", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#diamondinit-can-be-initialized-itself", "labels": ["OpenZeppelin"]}, {"title": "lastDiamondFreezeTimestamp is unused", "body": "lastDiamondFreezeTimestamp is unused", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#lastdiamondfreezetimestamp-is-unused", "labels": ["OpenZeppelin"]}, {"title": "Freezability differences between logical components", "body": "The usage of the Diamond Proxy pattern allows very modular changes to the system. The standard foresees moving individual selectors from facet to facet. Hence, one logical component (e.g. the ExecutorFacet) could be split into two facets, due to patching a single function and migrating the selector to the new facet, while the rest of the logic is kept in the old facet. As the first selector to the new facet defines the freezability, this could result in two different freeze capabilities for one high-level logical component (ExecutorFacet).  Implementing checks to cover the joint freezability for the logical facet would introduce additional overhead. Instead, consider extensively documenting this behavior in the DiamondCutFacet contract.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#freezability-differences-between-logical-components", "labels": ["OpenZeppelin"]}, {"title": "Gas optimizations", "body": "Throughout the codebase there are multiple instances where gas costs can be optimized:  In line 162 of the Diamond library the uint16 cast is unnecessary and can be removed.  Using the delete keyword instead of overwriting with the default value saves gas in these instances:  line 33 of Governance facet. line 119-121 of DiamondCutFacet contract.  In the approveEmergencyDiamondCutAsSecurityCouncilMember function, the s.diamondCutStorage.currentProposalId variable can be written to stack and reused.  In the ExecutorFacet contract on line 113 and 155 two bytes32 values are encoded and hashed. Consider using the abi.encode function for the encoding to be more gas efficient.  In the ExecutorFacet contract, consider writing the _maxU256 return value to stack to save on the following s.totalBlocksCommitted storage reads.  Consider applying the above changes to be more gas efficient.  Update: Fixed in commit 5a4e81a. However, the fix introduced a redundant check of conditions within the function approveEmergencyDiamondCutAsSecurityCouncilMember.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Interface and contract function parameter mismatch", "body": "The revertBlocks function has a different parameter name in IExecutor compared to ExecutorFacet. While in the interface the _blocksToRevert parameter suggests reverting a relative amount of blocks, the logic sets an absolute _newLastBlock which is confusing.  Further, in the requestL2Transaction function two parameters have a mismatch between the MailboxFacet and the IMailbox interface.  Consider correcting the above mismatches in favor of consistency and clarity.  Update: Fixed in commit c0600e0.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#interface-and-contract-function-parameter-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Getter returns misleading value", "body": "In the GettersFacet contract, the function isFunctionFreezable returns a Boolean value indicating whether a given selector is freezable or not. This value is taken from storage without any prior validation. At the same time, any uninitialized storage in Solidity contains the default value zero/false.  Querying the function isFunctionFreezable for an unknown selector will return false, thereby misleading the user to believe that the selector is used within the Diamond and is not freezable.  Consider validating the existence of the selector by requiring that the facet address of the selector is registered.  Update: Fixed in commit cfe6f54.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#getter-returns-misleading-value", "labels": ["OpenZeppelin"]}, {"title": "Lack of Documentation", "body": "Docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted. In the case of structs, docstrings should explain the overall purpose of the struct, each field contained in it, and clarify whether the struct is supposed to be persisted in storage or limited to memory and calldata. If the codebase does not have proper docstrings, it hinders reviewers understanding of the codes intention and increases the maintenance effort for contributors.  Throughout the zksync-2-dev codebase there are several parts that do not have docstrings. For instance:  In the Storage.sol contract the following identifiers lack sufficient documentation:  The DiamondCutStorage struct including all fields  The L2Log struct including all fields  The storage information of the L2Message struct as well as its txNumberInBlock field  In the IMailbox.sol interface the following constructs lack sufficient documentation:  The L2CanonicalTransaction struct including all fields  The NewPriorityRequest event including all fields  In the Mailbox.sol contract the following functions lack sufficient documentation:  The proveL2MessageInclusion function  The proveL2LogInclusion function  The l2TransactionBaseCost function  The requestL2Transaction function  The serializeL2Transaction function  In the IExecutor.sol interface the following structs lack sufficient documentation:  The StoredBlockInfo struct, especially fields blockHash, indexRepeatedStorageChanges, stateRoot  The CommitBlockInfo struct, especially field indexRepeatedStorageChanges  The ProofInput struct including all fields  In the DiamondCut.sol contract the following functions lack sufficient documentation:  The emergencyFreezeDiamond function  The unfreezeDiamond function  The approveEmergencyDiamondCutAsSecurityCouncilMember function  In the IGetters.sol interface the following structs lack sufficient documentation:  The Facet struct including all fields  SelectorExtended struct including all fields  FacetExtended struct including all fields  In the Diamond.sol library the following identifiers lack sufficient documentation:  The DiamondStorage struct and all of its fields  The FacetCut struct and all of its fields  The DiamondCutData struct and all of its fields  The diamondCut function  The getDiamondStorage function  In the PriorityQueue.sol library the following identifiers lack sufficient documentation:  The Queue struct and all its fields  The getLastProcessedPriorityTx function  The getTotalPriorityTxs function  The getSize function  The isEmpty function  The pushBack function  The front function  The popFront function  Consider thoroughly documenting all structs and functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec). While applying the NatSpec tags, make sure to be consistent with the usage of the respective tag. For instance, use @notice for a general description and @dev for technical aspects.  Update: Fixed in commit 8abb05c.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#lack-of-documentation", "labels": ["OpenZeppelin"]}, {"title": "Lack of event information", "body": "Throughout the codebase we found the following occurrences of state changes without event emission and event emissions with insufficient or incorrect information:  In the ExecutorFacet contract  the proveBlocks function does not emit an event after altering the storage variable s.totalBlocksVerified. Consider creating a new event that can emit both the old and new value of this variable. the BlocksRevert event is used as BlocksRevert(s.totalBlocksExecuted, s.totalBlocksCommitted) which differs from its definition BlocksRevert(uint256 totalBlocksVerified, uint256 totalBlocksCommitted) within the IExecutor interface. Consider replacing s.totalBlocksExecuted with s.totalBlocksVerified.  In the IExecutor interface  the BlockCommit event only contains the blockNumber, which might not be unique due to block reversion. Consider adding indexed fields for blockHash and commitment. the BlockExecution event only contains the blockNumber. Consider adding indexed fields for blockHash and commitment.  In the IGovernance interface the NewGovernor event emits the new governor. To ease tracking the responsibility of this important role, consider emitting both  the old and new governor  as indexed addresses.  In the IDiamondCut interface  the EmergencyDiamondCutApproved event only emits the address of the approver, but no information about the diamondcut proposal. Consider indexing the address field and adding the fields currentProposalId, securityCouncilEmergencyApprovals and the indexed field proposedDiamondCutHash. the Unfreeze event does not emit additional information. Consider adding the lastDiamondFreezeTimestamp as an event field. the DiamondCutProposalCancelation event does not emit additional information. Consider adding a currentProposalId field and the indexed field proposedDiamondCutHash.  Consider emitting events for all state changes and include all relevant state transition information in them to allow precise monitoring via off-chain systems. Consider indexing event fields to facilitate their usage as a search key.  Update: Fixed in commit 79fd845.  Lack of l2Logs validation  ExecutorFacet contract within the  _processL2Logs. While any L2 user can be the sender of  While the system implicitly assumes that exactly one L2Log of sender L2_SYSTEM_CONTEXT_ADDRESS is present in each block, this assumption is not enforced during block commitment.  Consider enforcing that only one L2Log with sender L2_SYSTEM_CONTEXT_ADDRESS is present in each block.  Update: Fixed in commit dfc6fe1.  Preimage hash collision protection for storage pointers  The Diamond Proxy makes use of the diamond storage pattern to track the facets and selectors in use. This is achieved through a DiamondStorage struct that contains the relevant facet and selector information. Because of the proxy setup, this struct is placed in an unstructured-storage-manner at a pseudo random storage slot calculated by hashing a hardcoded string.  In the event of introducing a dynamic slot calculation using hashing, the DiamondStorage storage slot could be specifically addressed to force a collision using the known input bytes from above.  To prevent this pre-image hash collision, consider applying a -1 offset to the hash.  Update: Fixed in commit 60b74e0.  Require statements with multiple conditions  Throughout the codebase there are require statements that require multiple conditions to be satisfied. For instance:  The require statement on line 37 of Executor.sol  The require statement on line 251 of Diamond.sol  The require statement on line 17 of Merkle.sol  To simplify the codebase and to raise the most helpful error messages for failing require statements, consider having a single require statement per condition.  Update: Fixed in commit b87267c.  Confusing event emission when executing diamond cut proposals  In the DiamondCutFacet contract, the executeDiamondCutProposal function is used to execute a previously proposed upgrade.  This function resets the scheduled diamond cut proposal, thereby re-purposing the _resetProposal function. When this function is successfully executed it triggers a DiamondCutProposalCancelation event. Afterwards, DiamondCutProposalExecution event is triggered by executeDiamondCutProposal function.  This dual event emission of cancellation followed by execution could lead to confusion in off-chain systems.  To prevent emitting a cancellation event during the execution of a diamond cut proposal, consider moving the emission of the DiamondCutProposalCancelation event from the _resetProposal function to the cancelDiamondCutProposal function.  Update: Fixed in commit fad57c5.  Unused input to commit blocks  In the ExecutorFacet contract, the _commitOneBlock function does not make use of the input _newBlock.priorityOperationsHash. Instead, a local variable priorityOperationsHash is calculated from the _newBlock.l2Logs and included in the block commitment.  Consider validating both values against each other.  Update: Fixed in commit 615b6a5.  Unused L2Messages can be committed to L1  ExecutorFacet contract the validator provides multiple blocks of type  CommitBlockInfo to the  commitBlocks function, which are validated in several steps including  _processL2Logs. In this function, the preimages contained in the  currentMessage is incremented only based on the  Consider the addition of a final check of currentMessage against the length of the _newBlock.l2ArbitraryLengthMessages array at the end of the _processL2Logs function to ensure that only relevant preimages have been included in the calldata.  Update: Fixed in commit 25913e7.  Unverified inputs during block commitment  In the ExecutorFacet contract the _commitOneBlock function takes the _newBlock parameter to validate, extract, and transform block information into a StoredBlockInfo struct, which is hashed and stored on chain as a commitment. With a valid zero-knowledge proof this data can later be verified and executed.  However, several fields of the _newBlock input parameter are not validated. This could lead to successful commitments of blocks that eventually will not be executable.  Consider preventing the commitment of unexecutable blocks by:  Validating the field numberOfLayer1Txs against the number of L2Logs with sender L2_BOOTLOADER_ADDRESS.  Validating the field l2LogsTreeRoot against a reconstruction of the Merkle tree from the l2Logs array.  Validating the field timestamp against the local variable blockTimestamp.  Update: Fixed in commit 230f400. The Matter Labs team states:  We have applied the recommendations #1 and #3. The recommendation #2 is redundant as it is already covered by zero knowledge proofs. Verifying this on Layer 1 would be too expensive so by design this is entrusted to zero knowledge cryptography.  Notes & Additional Information  AppStorage partially lacks getter functions  The GettersFacet contract does not expose the entire AppStorage via view functions. The following storage parts remain inconvenient to read for an outside actor:  Every aspect of diamondCutStorage  The pendingGovernor address  The storedBlockHashes mapping  The functions getSize and front of priorityQueue as well as a function to determine the position of elements within the queue  Additionally, there is an input size mismatch between the l2LogsRootHashes mapping, which takes an uint256 key, and the l2LogsRootHash getter function, which takes a uint32 parameter.  Consider exposing all relevant information via getter functions and ensure that function parameters and mapping keys are type-identical.  Update: Fixed in commit 6b99055.  Block info structs have redundant parameters  The structs StoredBlockInfo and CommitBlockInfo of the IExecutor interface have the following parameters in common:  blockNumber  indexRepeatedStorageChanges  numberOfLayer1Txs  priorityOperationsHash  l2LogsTreeRoot  timestamp  Consider moving these parameters to a separate BaseBlockInfo struct which is then included into StoredBlockInfo and CommitBlockInfo respectively. Note, this will affect the way the variables are accessed.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.  Confusing identifier names  Throughout the codebase we found multiple occurrences of identifier names creating confusion:  In the IExecutor interface the parameter name used in the signature of the revertBlocks function is _blocksToRevert. However, the implementation of said function within ExecutorFacet calls the same parameter _newLastBlock which is consistent with its usage.  In the PriorityQueue library the variables head and tail account for where to add and remove items from the list. Unintuitively, the head points to the end of the queue and tail points to the front of the queue.  Consider renaming confusing identifiers to prevent misunderstandings and incorrect usage.  Update: Fixed in commit 03e04cb and c0600e0.  Direct usage of library struct fields  In the MailboxFacet contract, the function _requestL2Transaction reads the head of the priority queue via direct access to the respective field.  However, it is best practice to decouple the internal structure of a library from the functionality it exposes to other contracts through its functions.  Consider replacing the direct access of struct field head with a call to the getter function getTotalPriorityTxs that exposes the same information.  Update: Fixed in commit 8b97af.  Lack of ERC-165 support  External contracts and third-party integrations have no means to discover interfaces supported by the codebase.  Consider implementing the supportsInterface function of the ERC-165 standard to expose information about implemented interfaces.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk and comes with additional maintenance overhead if the system is expected to change in the future. We have added it to our development backlog to be addressed once we are out of alpha version.  File and contract name mismatch  There is a general mismatch between the facet contract names and their file names. While the contracts have a Facet suffix, the files have not. The following contracts are affected:  DiamondCutFacet  ExecutorFacet  GettersFacet  GovernanceFacet  MailboxFacet  Regarding the interfaces, the individual interface names are based on the filename, e.g. IDiamondCut, but instead should align with the contract name.  Consider following the best practice of having identical file and contract names as well as adjusting the interface naming.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.  Inconsistent NatSpec tags  Throughout the codebase the NatSpec docstring tags @notice and @dev are used interchangeably. The Solidity NatSpec documentation describes the tags as the following:  @notice  Explain to an end user what this does  @dev  Explain to a developer any extra details  Consider applying the respective descriptions across the documentation to be consistent.  Update: Acknoledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concerns and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.  Misleading documentation  The docstring documentation of the _executeOneBlock function is misleading by stating the following:  Processes all pending operations (Send Exits, Complete priority requests)  However, sending exits is not part of the implementation. Consider revising the comments to accurately reflect the logic.  Update: Fixed in commit ce78828.  Uninformative reason strings  The codebase uses short alphanumeric codes instead of understandable reason strings in require statements.  Additionally, within ReentrancyGuard.sol there is a require statement on line 72 that lacks an error message completely.  Consider including specific, informative error messages in require statements to improve overall code clarity and to facilitate troubleshooting whenever a requirement is not satisfied.  Update: Partially fixed in commit 79f6a36 by adding the missing error message. In addition, the Matter Labs team states:  Improving the error messaging is a large effort that we have added to the backlog for now.  Solidity compiler version is not pinned  Throughout the codebase there are pragma statements that allow multiple versions of the Solidity compiler, including outdated versions.  Consider taking advantage of the latest Solidity version to improve the overall readability and security of the codebase. Regardless of which version of Solidity is used, consider pinning the version consistently throughout the codebase to prevent bugs due to incompatible future releases and take into account the list of known compiler bugs.  Update: Acknowledged, not fixed. The Matter Labs team states:  The version is pinned, but not directly in the source files to speed up the development: https://github.com/matter-labs/zksync-2-dev/blob/openzeppelin-audit/contracts/ethereum/hardhat.config.ts#L82. It is in the backlog to pin it in the source files after the release.  TODO comments in the code base  We found the following instances of TODO comments in the codebase that should be tracked in the projects issues backlog and resolved before the system is deployed:  Line 17 of Config.sol  Line 50 of Storage.sol  Line 212 of Executor.sol  Lines 70, 94 and 136 of Mailbox.sol  Line 20 of IDiamondCut.sol  During development, having well described TODO comments will make the process of tracking and solving them easier. Without that information these comments might age and important information for the security of the system might be forgotten by the time it is released to production.  Consider tracking all instances of TODO comments in the issues backlog and linking each inline TODO to the corresponding backlog entry. Resolve all TODOs before deploying to a production environment.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.  Typographical errors  Throughout the codebase there were a few typographical errors. For instance:  line 105 of the Diamond library: Add facet to the list of facets if the facet address is a new one  line 192 of the Diamond library: It is expected but NOT enforced that _facet is a NON-ZERO address  line 295 of the ExecutorFacet contract: _blockAuxilaryOutput should be _blockAuxiliaryOutput  Consider correcting the above and any other typos in favor of correctness and readability.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concerns and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.  Unorganized file layout  The Diamond library has an unorganized layout of code contents, which mixes functions, structs, enums, and events in no particular order. More specifically, we found the following code order in the file:  constants -> structs -> function -> enum -> structs -> function -> event -> functions  For readability, consider bundling these categories of content into separate code areas in the file.  Update: Fixed in commit 89953d2.  Unused named return variable  The requestL2Transaction function declares a named return variable bytes32 canonicalTxHash in its signature, but uses an explicit return statement in its body.  Consider either using or removing the named return as well as applying a consistent style of returning variables.  Update: Fixed in commit 923b3c3.  Write array length to stack to save gas  In the EVM it is more gas-efficient to read values from stack than from memory or storage. As values are read repeatedly within for loops, it makes sense to write the length of an array to the stack and reuse the stack-variable.  Throughout the codebase we found multiple instances to which this optimization could be applied:  On line 100 of file Executor.sol  On line 69 of file Diamond.sol  On line 108 of file Diamond.sol  On line 131 of file Diamond.sol  On line 148 of file Diamond.sol  Consider writing the array length to stack by assigning it to a local variable and then using the variable to reduce gas consumption.  Update: Fixed in commit 2987c69.  Conclusions  Over the course of four weeks we audited this layer 1 building block of the zkSync 2.0 project. Were excited to see Matter Labs making this step and developing the first EVM-equivalent zero-knowledge-based rollup. It goes without saying that this protocol is highly complex, but Matter Labs was really responsive and helpful clarifying any doubts we had and provided dedicated documentation. The design is sound and the code is in a good spot overall, just lacking some documentation. Hence, no high or critical severity issues were identified.  Appendix  Monitoring Recommendations  While audits help in identifying code-level issues in the current implementation and potentially the code deployed in production; we encourage Matter Labs team to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps in identifying potential threats and issues affecting production environment. Hence, with the goal of providing a complete security assessment we want to raise several actions addressing trust assumptions and out-of-scope components that can benefit from on-chain monitoring.  Upgrades  The Diamond pattern that defines the code structure allows upgrading the logic of this protocol. Any upgrade must be initiated by the governor via a diamond cut proposal and a subsequent execution. This process must undergo a time delay or requires the security councils approval for a quicker upgrade. In this context, consider monitoring these events:  DiamondCutProposal  DiamondCutProposalCancelation  DiamondCutProposalExecution  EmergencyDiamondCutApproved  This would allow the detection of the following suspicious activities:  The introduction of malicious code either as part of a facet or as part of the initializer contract.  Any diamond cut proposal including an initializer address at which no contract has been deployed so far.  The init calldata on proposal execution is malicious.  An unrealistically short time delay between council members approvals.  Freezability  Further, a governor controlled mechanism was implemented to freeze all freezable facets. In that case the EmergencyFreeze and Unfreeze events are emitted. An unplanned emergency freeze outside of incident response measures could indicate that the governor role is compromised and performing a DoS attack, therefore consider monitoring the respective events.  Governance  The governor and validator roles allow for the execution of crucial operations. The system implements a mechanism to upgrade these addresses. When a new address is proposed for the governor role a NewPendingGovernor event will be emitted. Once the proposed address accepts the administrative rights, a NewGovernor event will be emitted. Finally, whether a new address is set as a validator or an existing validator changes its state, a ValidatorStatusUpdate event will be emitted. Consider monitoring these events to detect unexpected changes to the governor or validators, both of which could signal a compromised governor role.  Executor  Blocks submitted to the layer 1 contract typically undergo a three stage process: commit, prove, and execute. Consider monitoring any deviation from this process as it might indicate the following malicious activiti", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#lack-of-event-information", "labels": ["OpenZeppelin"]}, {"title": "Lack of l2Logs validation", "body": "Lack of l2Logs validation", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#lack-of-l2logs-validation", "labels": ["OpenZeppelin"]}, {"title": "Preimage hash collision protection for storage pointers", "body": "The Diamond Proxy makes use of the diamond storage pattern to track the facets and selectors in use. This is achieved through a DiamondStorage struct that contains the relevant facet and selector information. Because of the proxy setup, this struct is placed in an unstructured-storage-manner at a pseudo random storage slot calculated by hashing a hardcoded string.  In the event of introducing a dynamic slot calculation using hashing, the DiamondStorage storage slot could be specifically addressed to force a collision using the known input bytes from above.  To prevent this pre-image hash collision, consider applying a -1 offset to the hash.  Update: Fixed in commit 60b74e0.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#preimage-hash-collision-protection-for-storage-pointers", "labels": ["OpenZeppelin"]}, {"title": "Require statements with multiple conditions", "body": "Throughout the codebase there are require statements that require multiple conditions to be satisfied. For instance:  The require statement on line 37 of Executor.sol  The require statement on line 251 of Diamond.sol  The require statement on line 17 of Merkle.sol  To simplify the codebase and to raise the most helpful error messages for failing require statements, consider having a single require statement per condition.  Update: Fixed in commit b87267c.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#require-statements-with-multiple-conditions", "labels": ["OpenZeppelin"]}, {"title": "Confusing event emission when executing diamond cut proposals", "body": "In the DiamondCutFacet contract, the executeDiamondCutProposal function is used to execute a previously proposed upgrade.  This function resets the scheduled diamond cut proposal, thereby re-purposing the _resetProposal function. When this function is successfully executed it triggers a DiamondCutProposalCancelation event. Afterwards, DiamondCutProposalExecution event is triggered by executeDiamondCutProposal function.  This dual event emission of cancellation followed by execution could lead to confusion in off-chain systems.  To prevent emitting a cancellation event during the execution of a diamond cut proposal, consider moving the emission of the DiamondCutProposalCancelation event from the _resetProposal function to the cancelDiamondCutProposal function.  Update: Fixed in commit fad57c5.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#confusing-event-emission-when-executing-diamond-cut-proposals", "labels": ["OpenZeppelin"]}, {"title": "Unused input to commit blocks", "body": "In the ExecutorFacet contract, the _commitOneBlock function does not make use of the input _newBlock.priorityOperationsHash. Instead, a local variable priorityOperationsHash is calculated from the _newBlock.l2Logs and included in the block commitment.  Consider validating both values against each other.  Update: Fixed in commit 615b6a5.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#unused-input-to-commit-blocks", "labels": ["OpenZeppelin"]}, {"title": "Unused L2Messages can be committed to L1", "body": "ExecutorFacet contract the validator provides multiple blocks of type  CommitBlockInfo to the  commitBlocks function, which are validated in several steps including  _processL2Logs. In this function, the preimages contained in the  currentMessage is incremented only based on the  Consider the addition of a final check of currentMessage against the length of the _newBlock.l2ArbitraryLengthMessages array at the end of the _processL2Logs function to ensure that only relevant preimages have been included in the calldata.  Update: Fixed in commit 25913e7.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#unused-l2messages-can-be-committed-to-l1", "labels": ["OpenZeppelin"]}, {"title": "Unverified inputs during block commitment", "body": "In the ExecutorFacet contract the _commitOneBlock function takes the _newBlock parameter to validate, extract, and transform block information into a StoredBlockInfo struct, which is hashed and stored on chain as a commitment. With a valid zero-knowledge proof this data can later be verified and executed.  However, several fields of the _newBlock input parameter are not validated. This could lead to successful commitments of blocks that eventually will not be executable.  Consider preventing the commitment of unexecutable blocks by:  Validating the field numberOfLayer1Txs against the number of L2Logs with sender L2_BOOTLOADER_ADDRESS.  Validating the field l2LogsTreeRoot against a reconstruction of the Merkle tree from the l2Logs array.  Validating the field timestamp against the local variable blockTimestamp.  Update: Fixed in commit 230f400. The Matter Labs team states:  We have applied the recommendations #1 and #3. The recommendation #2 is redundant as it is already covered by zero knowledge proofs. Verifying this on Layer 1 would be too expensive so by design this is entrusted to zero knowledge cryptography.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#unverified-inputs-during-block-commitment", "labels": ["OpenZeppelin"]}, {"title": "AppStorage partially lacks getter functions", "body": "The GettersFacet contract does not expose the entire AppStorage via view functions. The following storage parts remain inconvenient to read for an outside actor:  Every aspect of diamondCutStorage  The pendingGovernor address  The storedBlockHashes mapping  The functions getSize and front of priorityQueue as well as a function to determine the position of elements within the queue  Additionally, there is an input size mismatch between the l2LogsRootHashes mapping, which takes an uint256 key, and the l2LogsRootHash getter function, which takes a uint32 parameter.  Consider exposing all relevant information via getter functions and ensure that function parameters and mapping keys are type-identical.  Update: Fixed in commit 6b99055.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#appstorage-partially-lacks-getter-functions", "labels": ["OpenZeppelin"]}, {"title": "Block info structs have redundant parameters", "body": "The structs StoredBlockInfo and CommitBlockInfo of the IExecutor interface have the following parameters in common:  blockNumber  indexRepeatedStorageChanges  numberOfLayer1Txs  priorityOperationsHash  l2LogsTreeRoot  timestamp  Consider moving these parameters to a separate BaseBlockInfo struct which is then included into StoredBlockInfo and CommitBlockInfo respectively. Note, this will affect the way the variables are accessed.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#block-info-structs-have-redundant-parameters", "labels": ["OpenZeppelin"]}, {"title": "Confusing identifier names", "body": "Throughout the codebase we found multiple occurrences of identifier names creating confusion:  In the IExecutor interface the parameter name used in the signature of the revertBlocks function is _blocksToRevert. However, the implementation of said function within ExecutorFacet calls the same parameter _newLastBlock which is consistent with its usage.  In the PriorityQueue library the variables head and tail account for where to add and remove items from the list. Unintuitively, the head points to the end of the queue and tail points to the front of the queue.  Consider renaming confusing identifiers to prevent misunderstandings and incorrect usage.  Update: Fixed in commit 03e04cb and c0600e0.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#confusing-identifier-names", "labels": ["OpenZeppelin"]}, {"title": "Direct usage of library struct fields", "body": "In the MailboxFacet contract, the function _requestL2Transaction reads the head of the priority queue via direct access to the respective field.  However, it is best practice to decouple the internal structure of a library from the functionality it exposes to other contracts through its functions.  Consider replacing the direct access of struct field head with a call to the getter function getTotalPriorityTxs that exposes the same information.  Update: Fixed in commit 8b97af.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#direct-usage-of-library-struct-fields", "labels": ["OpenZeppelin"]}, {"title": "Lack of ERC-165 support", "body": "External contracts and third-party integrations have no means to discover interfaces supported by the codebase.  Consider implementing the supportsInterface function of the ERC-165 standard to expose information about implemented interfaces.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk and comes with additional maintenance overhead if the system is expected to change in the future. We have added it to our development backlog to be addressed once we are out of alpha version.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#lack-of-erc-165-support", "labels": ["OpenZeppelin"]}, {"title": "File and contract name mismatch", "body": "There is a general mismatch between the facet contract names and their file names. While the contracts have a Facet suffix, the files have not. The following contracts are affected:  DiamondCutFacet  ExecutorFacet  GettersFacet  GovernanceFacet  MailboxFacet  Regarding the interfaces, the individual interface names are based on the filename, e.g. IDiamondCut, but instead should align with the contract name.  Consider following the best practice of having identical file and contract names as well as adjusting the interface naming.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#file-and-contract-name-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent NatSpec tags", "body": "Throughout the codebase the NatSpec docstring tags @notice and @dev are used interchangeably. The Solidity NatSpec documentation describes the tags as the following:  @notice  Explain to an end user what this does  @dev  Explain to a developer any extra details  Consider applying the respective descriptions across the documentation to be consistent.  Update: Acknoledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concerns and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#inconsistent-natspec-tags", "labels": ["OpenZeppelin"]}, {"title": "Misleading documentation", "body": "The docstring documentation of the _executeOneBlock function is misleading by stating the following:  Processes all pending operations (Send Exits, Complete priority requests)  However, sending exits is not part of the implementation. Consider revising the comments to accurately reflect the logic.  Update: Fixed in commit ce78828.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Uninformative reason strings", "body": "The codebase uses short alphanumeric codes instead of understandable reason strings in require statements.  Additionally, within ReentrancyGuard.sol there is a require statement on line 72 that lacks an error message completely.  Consider including specific, informative error messages in require statements to improve overall code clarity and to facilitate troubleshooting whenever a requirement is not satisfied.  Update: Partially fixed in commit 79f6a36 by adding the missing error message. In addition, the Matter Labs team states:  Improving the error messaging is a large effort that we have added to the backlog for now.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#uninformative-reason-strings", "labels": ["OpenZeppelin"]}, {"title": "Solidity compiler version is not pinned", "body": "Throughout the codebase there are pragma statements that allow multiple versions of the Solidity compiler, including outdated versions.  Consider taking advantage of the latest Solidity version to improve the overall readability and security of the codebase. Regardless of which version of Solidity is used, consider pinning the version consistently throughout the codebase to prevent bugs due to incompatible future releases and take into account the list of known compiler bugs.  Update: Acknowledged, not fixed. The Matter Labs team states:  The version is pinned, but not directly in the source files to speed up the development: https://github.com/matter-labs/zksync-2-dev/blob/openzeppelin-audit/contracts/ethereum/hardhat.config.ts#L82. It is in the backlog to pin it in the source files after the release.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#solidity-compiler-version-is-not-pinned", "labels": ["OpenZeppelin"]}, {"title": "TODO comments in the code base", "body": "We found the following instances of TODO comments in the codebase that should be tracked in the projects issues backlog and resolved before the system is deployed:  Line 17 of Config.sol  Line 50 of Storage.sol  Line 212 of Executor.sol  Lines 70, 94 and 136 of Mailbox.sol  Line 20 of IDiamondCut.sol  During development, having well described TODO comments will make the process of tracking and solving them easier. Without that information these comments might age and important information for the security of the system might be forgotten by the time it is released to production.  Consider tracking all instances of TODO comments in the issues backlog and linking each inline TODO to the corresponding backlog entry. Resolve all TODOs before deploying to a production environment.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#todo-comments-in-the-code-base", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Throughout the codebase there were a few typographical errors. For instance:  line 105 of the Diamond library: Add facet to the list of facets if the facet address is a new one  line 192 of the Diamond library: It is expected but NOT enforced that _facet is a NON-ZERO address  line 295 of the ExecutorFacet contract: _blockAuxilaryOutput should be _blockAuxiliaryOutput  Consider correcting the above and any other typos in favor of correctness and readability.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concerns and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unorganized file layout", "body": "The Diamond library has an unorganized layout of code contents, which mixes functions, structs, enums, and events in no particular order. More specifically, we found the following code order in the file:  constants -> structs -> function -> enum -> structs -> function -> event -> functions  For readability, consider bundling these categories of content into separate code areas in the file.  Update: Fixed in commit 89953d2.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#unorganized-file-layout", "labels": ["OpenZeppelin"]}, {"title": "Unused named return variable", "body": "The requestL2Transaction function declares a named return variable bytes32 canonicalTxHash in its signature, but uses an explicit return statement in its body.  Consider either using or removing the named return as well as applying a consistent style of returning variables.  Update: Fixed in commit 923b3c3.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#unused-named-return-variable", "labels": ["OpenZeppelin"]}, {"title": "Write array length to stack to save gas", "body": "Write array length to stack to save gas", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#write-array-length-to-stack-to-save-gas", "labels": ["OpenZeppelin"]}, {"title": "s", "body": "firt ecurity aement for zkSync 2.0 wa prepared by OpenZeppelin, a part of an ongoing ecurity partnerhip with Matter Lab.  Table of Content  Table of Content  Summary  Scope  Sytem Overview  Executor Mailbox DiamondCut Governance Operation Mode Privileged Role and Security Aumption  Medium Severity  Corruption of facet array on elector replacement Freezable property applie to individual elector intead of facet Merkle library verifie intermediate input Proof replayability  Low Severity  _proveBlock while loop could run out of ga DiamondInit can be initialized itelf latDiamondFreezeTimetamp i unued Freezability difference between logical component Ga optimization Interface and contract function parameter mimatch Getter return mileading value Lack of Documentation Lack of event information Lack of l2Log validation Preimage hah colliion protection for torage pointer Require tatement with multiple condition Confuing event emiion when executing diamond cut propoal Unued input to commit block Unued L2Meage can be committed to L1 Unverified input during block commitment  Note & Additional Information  AppStorage partially lack getter function Block info truct have redundant parameter Confuing identifier name Direct uage of library truct field Lack of ERC-165 upport File and contract name mimatch Inconitent NatSpec tag Mileading documentation Uninformative reaon tring Solidity compiler verion i not pinned TODO comment in the code bae Typographical error Unorganized file layout Unued named return variable Write array length to tack to ave ga  Concluion  Appendix  Monitoring Recommendation  Summary  Type  Rollup  Timeline  From 2022-09-05  To 2022-09-30  Language  Solidity  Total Iue  35 (25 reolved, 1 partially reolved)  Critical Severity Iue  0 (0 reolved)  High Severity Iue  0 (0 reolved)  Medium Severity Iue  4 (4 reolved)  Low Severity Iue  16 (14 reolved)  Note & Additional Information  15 (7 reolved, 1 partially reolved)  Scope  We audited the matter-lab/zkync-2-dev repoitory at the c05b49d7e303996f60a0e35f18ef224e45ee19f5 commit.  In cope were the following contract:  Sytem Overview  zkSync i a layer 2 caling olution for Ethereum baed on zero-knowledge rollup technology. The protocol aim to provide low tranaction fee and high throughput while maintaining full EVM compatibility.  In zkSync uer ign and end tranaction to validator who proce them, include them into block, and create a cryptographic commitment of the updated tate. Thi commitment (root hah) i then tranferred to a mart contract on layer 1 along with a cryptographic proof (SNARK) proving that thi new tate wa correctly calculated baed on applying tranaction to a previou tate. A compreed tate update i alo ent to layer 1, allowing anyone to recontruct the tate at any moment. The layer 1 contract validate both the tate update and the cryptographic proof, auring the validity of the tranaction included in the block and the data availability.  zkSync protocol implement the Diamond Proxy EIP-2535 a an upgrade mechanim, thereby plitting it functionality into four different facet:  Executor: Proceing rollup of layer 2 block  Mailbox: Bidirectional communication between layer 1 and layer 2  DiamondCut: Contract adminitration  Governance: Role management  Note that while the aforementioned EIP doe not contain any known iue, it i not yet conidered finalized.  Executor  The Executor component allow validator to commit, prove, and execute block. All block are tentative before execution and can be removed by any validator. Thi component i central in extending the ecurity guarantee of layer 1 to tranaction on layer 2 through rollup.  Mailbox  The Mailbox component handle bi-directional communication between layer 1 (L1) and layer 2 (L2). To requet an L2 tranaction from L1, the tranaction data i appended to a queue and removed from it upon final incluion of the L2-rollup into the L1 contract.  In contrat, communication from L2 to L1 i divided in two part: Sending a tranaction on L2 and reading it from L1. To end information from L2, a pecial opcode endToL1 i implemented. Uing thi opcode, uer can end log or meage. Log provide a key-value tuple of 32 byte each to encode data while meage can be of arbitrary length. The tranfer of meage i poible via a pecial ytem contract converting it into a log containing a hah-commitment. All log are individually hahed to form the leaf node of a block fixed-ize Merkle tree. The proof of incluion i made available on L1 by checking againt the Merkle tree root. Upon committing a block, verification are performed to enure data availability, enabling anyone to prove meage incluion without additional help from the operator.  DiamondCut  Note: For a comprehenive explanation of the diamond update mechanim pleae refer to EIP-2535.  Thi component manage upgrade-related operation and freezing/unfreezing of facet. The upgrade mechanim i compried of three tage:  Upgrade propoal  In thi tage, the governor commit both a equence of change (add/replace/remove) to the upported facet function and the fixed addre of an initializer contract.  Upgrade notice period  zkSync uer are given a contant timeframe to withdraw their fund if they are againt the propoed upgrade, unle the Security Council approve an immediate emergency upgrade, thereby kipping the execution delay.  Upgrade execution  The governor can execute the upgrade and provide additional calldata to the initializer contract.  Freezing Mechanim  Matter Lab team ha implemented a freezing feature. When defining the facet through diamond cut, each facet can be et a freezable or not. The governor can freeze the diamond a a whole which affect all freezable facet. Therefore, it i poible to deignate part that hall remain operational in an emergency ituation. It i crucial for the DiamondCut facet to remain operational in order to enable the governor to unfreeze the Diamond Proxy after reolving the emergency ituation.  Governance  The Governance component allow the governor to aign and remove the valdiator role from addree. It further enable the tranition of contract adminitration to a new governor by deignating a pending governor who need to accept hi role in an additional tep thereby removing the old governor.  Operation Mode  Regular Operation  Thi operation mode allow only regitered validator to commit and execute block with rolled-up layer 2 tranaction information. Thu, uer are dependent on the validator to not cenor their tranaction. To protect againt malfunction and malice a econd operation mode exit.  Priority Mode  Under pecific condition the ytem can enter a pecial operation mode called Priority Mode. Thi mechanim i intended a an ecape hatch to allow uer to withdraw their fund from zkSync protocol in the cae an operator become maliciou or unavailable. During the coure of thi audit thi feature wa out of cope due to the fact that it wa not yet implemented.  Privileged Role and Security Aumption  The governor i a ingle addre that can perform critical adminitrative action uch a propoing, canceling, and executing upgrade of the Diamond Proxy, a well a freezing and unfreezing the proxy. The governor i retricted by a time-delay between propoal and execution of any upgrade. However, no other entity can veto, potpone, or retrict the governor action. Further, the governor can et and unet addree a validator. The governor i conidered a truted entity.  The ecurity council i a et of addree that can kip the time-delay within the approval proce of upgrade propoed by the governor to allow immediate incidence repone action. The ecurity council ha no power to propoe, delay, or veto action. The exact ize of the ecurity council, it member, or the threhold of ecurity council vote to allow immediate execution of a propoal ha not been determined at the time of the audit.  The Verifier i a mart contract on layer 1 in charge of verifying zk-proof. It expoe a function that return a Boolean value indicating whether a given proof i valid. During the coure of thi audit thi feature wa out of cope due to the fact that it wa not yet implemented.  The validator are a et of layer 1 addree in charge of bundling tranaction into block, executing them on layer 2, committing their compreed information to layer 1, requeting their zk-proof, and finalizing them on layer 1. Additionally, they are in charge of forwarding meage between layer 1 and layer 2. The validator are partially truted  at the time of the audit no ecape hatch wa implemented, hence it i neceary to trut the validator not to cenor tranaction and refue/abandon operation. However, the verification of tranaction via zk-proof mathematically prevent validator from poofing tranaction or relaying fale information. At the time of the audit, the validator are a centralized entity, while future decentralization i planned.  A et of four ytem contract on layer 2 ha privileged role and perform pecial operation:  The Contract Deployer i in charge of deploying contract on layer 2 via a hah-commitment to the contract bytecode.  The IL1Meenger i a contract that allow the tranfer of arbitrary-length meage from layer 2 to layer 1 by uing a hah commitment within the fixed-ize data exchange truct L2Log.  The INonceHolder tore tranaction and deployment nonce for account and expoe them via view function.  The Bootloader acknowledge received requet which have been paed from layer 1 to layer 2 via the priority queue mechanim.  Medium Severity  Corruption of facet array on elector replacement  The Diamond library allow replacing a elector facet with itelf which i non-compliant with EIP-2535.  Moreover, an edge-cae in which a facet only ha one elector and thi elector facet i replaced with itelf lead to corruption of the DiamondStorage.facet array. Conider the following cenario:  A facet ha an array of elector containing only one element [1]. Through the function diamondCut a call to _replaceFunction i initiated.  Inide of _replaceFunction, the call to _aveFacetIfNew doe not add any facet, becaue the facet i already regitered.  Inide of the loop iterating through the elector array [1], the call to _removeOneFunction trigger a call to _removeFacet due to the lat elector being removed. Thi in turn remove the facet from the d.facet array.  The ubequent call to _addOneFunction add elector 1 back to the facet, while the facet remain deleted from the d.facet array, thereby corrupting it.  To be fully compliant with the EIP-2535 pec and mitigate the edge-cae leading to a corruption of the facet array, conider adding the requirement that _facet and oldFacet.facetAddre are ditinct from each other.  Update: Fixed in commit f6cde78. The team mitigated thi edge-cae by rearranging the code. However, with the miing ditinction check, the implementation i not fully EIP-2535 compliant.  Freezable property applie to individual elector intead of facet  In the DiamondProxy contract, a elector i mapped to a facet via the mapping diamondStorage.electorToFacet upon executing the fallback function. The received datatructure of type Diamond.SelectorToFacet contain the information  addre  facetAddre  uint16  electorPoition  bool  iFreezable  The flag iFreezable i ued to determine whether the delegatecall of the given elector to the repective facet hould be executed.  At the ame time, it i the tated intent of the ytem to allow freezability on the granularity level of facet: While the Diamond hall have a global flag to determine whether it i frozen or not. Each facet hall be marked a either freezable or not.  An iue arie, becaue the electorToFacet mapping allow different value for the flag iFreezable for different elector of the ame facet. Which would allow for freezability on the granularity of elector intead of facet. Conider the following example of two different elector, one freezable, one not, belonging to the ame facet:  [elector1  = SelectorToFacet  (facet1  true  ) electorToFacet  [elector2  = SelectorToFacet  (facet1  fale  Moreover, the initialization of the electorToFacet mapping within the Diamond library in function diamondCut actually allow the aignment of different value for iFreezable. Conider the following example for the facetCut array:  (facet1  , Add  true  [elector1  ]),  (facet1  , Add  fale  [elector2  ])  which will lead to an initialization of the electorToFacet mapping given in the example above.  To prevent elector-level granularity of the freezabilitiy property, conider removing the iFreezable property from the Diamond.SelectorToFacet datatype and add it to a datatype decribing only the facet thereby etablihing a 1:1 mapping between facet and freezability.  Update: Fixed in commit e39eb07.  Merkle library verifie intermediate input  The Merkle library enable verification of a Merkle proof by performing an incluion check of an input againt a binary tree. Thi work by conecutively hahing concatenated ibling node until a root hah i generated. The input i one of the leaf hah value, while the proof i a path through the tree containing the miing hah information to regenerate the root.  An iue arie in thi library, due to the arbitrary length of the proof. Thi allow horter path to reolve to the ame root. Hence, the known hah of an intermediate node i a valid input a well. To viualize, conidering the leaf node h0 and h1, the hahed concatenation hah(h0 || h1) of thoe hahe would be a valid input along a horter path. An attacker could utilize the known pre-image to prove it incluion in the tree. For the tandalone library thi i a critical problem.  In thi particular codebae the Merkle library i olely ued in the MailboxFacet contact to prove the incluion of a tranaction within a et of layer 2 log. Thu, only input of type L2Log with a length of 88 byte are legitimate, while the pre-image of ize 64 byte contained within the Merkle tree are not. However, any future uage on 64 byte input would lead to a critical vulnerability.  It wa alo tated that the incomplete tree of fixed ize i filled with the default hah hah(\"\"). Thi allow an attacker to prove the incluion of empty byte by default. Although, no threat wa identified for the contract in cope.  Conider trictly checking the path length of the proof againt the deired Merkle tree depth to mitigate the firt iue. Further, conider uing a default leaf hah with unknown pre-image a countermeaure to the econd attack. With repect to documentation, conider ticking to the leaf wording for variable naming.  Update: Fixed in commit 7eb51d9. Additional check have been applied outide of the Merkle library to filter maliciou input. The library itelf remain vulnerable to the attack if ued in a different context. A note about thi problem wa added to the function documentation with commit 5f02309.  Proof replayability  In the proveBlock function of the ExecutorFacet contract, there i no linkage between the committed block and the proof. The repective check i commented out in line 213. However, a it i commented out, the following i applicable.  The provided proof data i elf-contained. Hence, the validator verifie that the given proof i valid in itelf. Seeing the validator a a black box, it i aumed that there i no back checking againt the committed block provided during the call. Therefore, the independence between the committed block and proof ugget a replay attack. By providing any formerly valid proof the previouly committed block would be validated. Thu, all uer could verify committed block, whether valid or not.  A documented in the code, the neceary check i there but commented out, which i baed on the argument that the Verifier contract i not yet implemented. However, the commitment check between the block and proof ha nothing to do with the Verifier. Therefore, conider incorporating thi crucial check a part of the finalized codebae.  Update: Fixed in commit 64d6aec.  Low Severity  _proveBlock while loop could run out of ga  In the ExecutorFacet contract within the proveBlock function, there i a while loop to kip already verified block. The loop condition i defined a:  while  (_hahStoredBlockInfo  (_committedBlock  [i  ])  != firtUnverifiedBlockHah  Therefore, if the committed block do no contain the firt unverified block, thi loop will eventually run out of ga and revert.  Conider limiting the number of loop iteration to the length of the _committedBlock array and reverting with an expreive error meage in cae the block wa not found.  Update: Fixed in commit df107f0.  DiamondInit can be initialized itelf  The DiamondInit contract i deigned to initialize the DiamondProxy or any new facet via a delegatecall from the proxy contract. Therefore, the DiamondInit contract i deployed on it own with an unprotected initialize function.  Hence, anyone could initialize the deployed intance of the DiamondInit contract itelf. While thi int identified a a threat, it i good practice to prevent arbitrary caller from initializing contract.  Conider initializing the DiamondInit contract via the contructor or adding a ecurity mechanim to the initialize function.  Update: Fixed in commit c9089a5.  latDiamondFreezeTimetamp i unued  In the DiamondCutFacet contract, the diamond can be frozen to allow inpection of the protocol ecurity. Currently, a part of the emergencyFreezeDiamond function, .diamondCutStorage.latDiamondFreezeTimetamp i et but not ued elewhere in the code.  Conider either implementing a ue-cae for thi variable or removing it.  Update: Acknowledged, not fixed. The Matter Lab team tate:  While thi feature wa not included into thi releae we prefer to keep the variable to facilitate the rollout of the feature once it i ready.  Freezability difference between logical component  The uage of the Diamond Proxy pattern allow very modular change to the ytem. The tandard foreee moving individual elector from facet to facet. Hence, one logical component (e.g. the ExecutorFacet) could be plit into two facet, due to patching a ingle function and migrating the elector to the new facet, while the ret of the logic i kept in the old facet. A the firt elector to the new facet define the freezability, thi could reult in two different freeze capabilitie for one high-level logical component (ExecutorFacet).  Implementing check to cover the joint freezability for the logical facet would introduce additional overhead. Intead, conider extenively documenting thi behavior in the DiamondCutFacet contract.  Update: Acknowledged, not fixed. The Matter Lab team tate:  We acknowledge that thi iue raie a valid concern and we are aware that overall documentation improvement i due. Thi ha been in our backlog already and we have now adjuted the priority accordingly.  Ga optimization  Throughout the codebae there are multiple intance where ga cot can be optimized:  In line 162 of the Diamond library the uint16 cat i unneceary and can be removed.  Uing the delete keyword intead of overwriting with the default value ave ga in thee intance:  line 33 of Governance facet. line 119-121 of DiamondCutFacet contract.  In the approveEmergencyDiamondCutASecurityCouncilMember function, the .diamondCutStorage.currentPropoalId variable can be written to tack and reued.  In the ExecutorFacet contract on line 113 and 155 two byte32 value are encoded and hahed. Conider uing the abi.encode function for the encoding to be more ga efficient.  In the ExecutorFacet contract, conider writing the _maxU256 return value to tack to ave on the following .totalBlockCommitted torage read.  Conider applying the above change to be more ga efficient.  Update: Fixed in commit 5a4e81a. However, the fix introduced a redundant check of condition within the function approveEmergencyDiamondCutASecurityCouncilMember.  Interface and contract function parameter mimatch  The revertBlock function ha a different parameter name in IExecutor compared to ExecutorFacet. While in the interface the _blockToRevert parameter ugget reverting a relative amount of block, the logic et an abolute _newLatBlock which i confuing.  Further, in the requetL2Tranaction function two parameter have a", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#s", "labels": ["OpenZeppelin"]}, {"title": "Appendix", "body": "Appendix", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#appendix", "labels": ["OpenZeppelin"]}, {"title": "Monitoring Recommendations", "body": "Monitoring Recommendations", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#monitoring-recommendations", "labels": ["OpenZeppelin"]}, {"title": "Summary", "body": "Type  Rollup  Timeline  From 2022-09-05  To 2022-09-30  Languages  Solidity  Total Issues  35 (25 resolved, 1 partially resolved)  Critical Severity Issues  0 (0 resolved)  High Severity Issues  0 (0 resolved)  Medium Severity Issues  4 (4 resolved)  Low Severity Issues  16 (14 resolved)  Notes & Additional Information  15 (7 resolved, 1 partially resolved)  Scope  We audited the matter-labs/zksync-2-dev repository at the c05b49d7e303996f60a0e35f18ef224e45ee19f5 commit.  In scope were the following contracts:  System Overview  zkSync is a layer 2 scaling solution for Ethereum based on zero-knowledge rollup technology. The protocol aims to provide low transaction fees and high throughput while maintaining full EVM compatibility.  In zkSync users sign and send transactions to validators who process them, include them into blocks, and create a cryptographic commitment of the updated state. This commitment (root hash) is then transferred to a smart contract on layer 1 along with a cryptographic proof (SNARK) proving that this new state was correctly calculated based on applying transactions to a previous state. A compressed state update is also sent to layer 1, allowing anyone to reconstruct the state at any moment. The layer 1 contract validates both the state update and the cryptographic proof, assuring the validity of the transactions included in the block and the data availability.  zkSync protocol implements the Diamond Proxy EIP-2535 as an upgrade mechanism, thereby splitting its functionality into four different facets:  Executor: Processing rollups of layer 2 blocks  Mailbox: Bidirectional communication between layer 1 and layer 2  DiamondCut: Contract administration  Governance: Role management  Note that while the aforementioned EIP does not contain any known issues, it is not yet considered finalized.  Executor  The Executor component allows validators to commit, prove, and execute blocks. All blocks are tentative before execution and can be removed by any validator. This component is central in extending the security guarantees of layer 1 to transactions on layer 2 through rollups.  Mailbox  The Mailbox component handles bi-directional communications between layer 1 (L1) and layer 2 (L2). To request an L2 transaction from L1, the transaction data is appended to a queue and removed from it upon final inclusion of the L2-rollup into the L1 contract.  In contrast, communication from L2 to L1 is divided in two parts: Sending a transaction on L2 and reading it from L1. To send information from L2, a special opcode sendToL1 is implemented. Using this opcode, users can send logs or messages. Logs provide a key-value tuple of 32 bytes each to encode data while messages can be of arbitrary length. The transfer of messages is possible via a special system contract converting it into a log containing a hash-commitment. All logs are individually hashed to form the leaf nodes of a blocks fixed-size Merkle tree. The proof of inclusion is made available on L1 by checking against the Merkle tree root. Upon committing a block, verifications are performed to ensure data availability, enabling anyone to prove message inclusion without additional help from the operator.  DiamondCut  Note: For a comprehensive explanation of the diamond update mechanism please refer to EIP-2535.  This component manages upgrade-related operations and freezing/unfreezing of facets. The upgrade mechanism is comprised of three stages:  Upgrade proposal  In this stage, the governor commits both a sequence of changes (add/replace/remove) to the supported facet functions and the fixed address of an initializer contract.  Upgrade notice period  zkSync users are given a constant timeframe to withdraw their funds if they are against the proposed upgrade, unless the Security Council approves an immediate emergency upgrade, thereby skipping the execution delay.  Upgrade execution  The governor can execute the upgrade and provide additional calldata to the initializer contract.  Freezing Mechanism  Matter Labs team has implemented a freezing feature. When defining the facet through diamond cuts, each facet can be set as freezable or not. The governor can freeze the diamond as a whole which affects all freezable facets. Therefore, it is possible to designate parts that shall remain operational in an emergency situation. It is crucial for the DiamondCut facet to remain operational in order to enable the governor to unfreeze the Diamond Proxy after resolving the emergency situation.  Governance  The Governance component allows the governor to assign and remove the valdiator role from addresses. It further enables the transition of contract administration to a new governor by designating a pending governor who needs to accept his role in an additional step thereby removing the old governor.  Operation Modes  Regular Operation  This operation mode allows only registered validators to commit and execute blocks with rolled-up layer 2 transaction information. Thus, users are dependent on the validators to not censor their transactions. To protect against malfunction and malice a second operation mode exists.  Priority Mode  Under specific conditions the system can enter a special operation mode called Priority Mode. This mechanism is intended as an escape hatch to allow users to withdraw their funds from zkSync protocol in the case an operator becomes malicious or unavailable. During the course of this audit this feature was out of scope due to the fact that it was not yet implemented.  Privileged Roles and Security Assumptions  The governor is a single address that can perform critical administrative actions such as proposing, canceling, and executing upgrades of the Diamond Proxy, as well as freezing and unfreezing the proxy. The governor is restricted by a time-delay between proposal and execution of any upgrade. However, no other entity can veto, postpone, or restrict the governors actions. Further, the governor can set and unset addresses as validators. The governor is considered a trusted entity.  The security council is a set of addresses that can skip the time-delay within the approval process of upgrades proposed by the governor to allow immediate incidence response actions. The security council has no power to propose, delay, or veto actions. The exact size of the security council, its members, or the threshold of security council votes to allow immediate execution of a proposal has not been determined at the time of the audit.  The Verifier is a smart contract on layer 1 in charge of verifying zk-proofs. It exposes a function that returns a Boolean value indicating whether a given proof is valid. During the course of this audit this feature was out of scope due to the fact that it was not yet implemented.  The validators are a set of layer 1 addresses in charge of bundling transactions into blocks, executing them on layer 2, committing their compressed information to layer 1, requesting their zk-proof, and finalizing them on layer 1. Additionally, they are in charge of forwarding messages between layer 1 and layer 2. The validators are partially trusted  at the time of the audit no escape hatch was implemented, hence it is necessary to trust the validators not to censor transactions and refuse/abandon operation. However, the verification of transactions via zk-proofs mathematically prevents validators from spoofing transactions or relaying false information. At the time of the audit, the validators are a centralized entity, while future decentralization is planned.  A set of four system contracts on layer 2 has privileged roles and performs special operations:  The Contract Deployer is in charge of deploying contracts on layer 2 via a hash-commitment to the contracts bytecode.  The IL1Messenger is a contract that allows the transfer of arbitrary-length messages from layer 2 to layer 1 by using a hash commitment within the fixed-size data exchange struct L2Log.  The INonceHolder stores transaction and deployment nonces for accounts and exposes them via view functions.  The Bootloader acknowledges received requests which have been passed from layer 1 to layer 2 via the priority queue mechanism.  Medium Severity  Corruption of facets array on selector replacement  The Diamond library allows replacing a selectors facet with itself which is non-compliant with EIP-2535.  Moreover, an edge-case in which a facet only has one selector and this selectors facet is replaced with itself leads to corruption of the DiamondStorage.facets array. Consider the following scenario:  A facet has an array of selectors containing only one element [s1]. Through the function diamondCut a call to _replaceFunctions is initiated.  Inside of _replaceFunctions, the call to _saveFacetIfNew does not add any facet, because the facet is already registered.  Inside of the loop iterating through the selector array [s1], the call to _removeOneFunction triggers a call to _removeFacet due to the last selector being removed. This in turn removes the facet from the ds.facets array.  The subsequent call to _addOneFunction adds selector s1 back to the facet, while the facet remains deleted from the ds.facets array, thereby corrupting it.  To be fully compliant with the EIP-2535 spec and mitigate the edge-case leading to a corruption of the facets array, consider adding the requirement that _facet and oldFacet.facetAddress are distinct from each other.  Update: Fixed in commit f6cde78. The team mitigated this edge-case by rearranging the code. However, with the missing distinction check, the implementation is not fully EIP-2535 compliant.  Freezable property applies to individual selectors instead of facets  In the DiamondProxy contract, a selector is mapped to a facet via the mapping diamondStorage.selectorToFacet upon executing the fallback function. The received datastructure of type Diamond.SelectorToFacet contains the information  address  facetAddress  uint16  selectorPosition  bool  isFreezable  The flag isFreezable is used to determine whether the delegatecall of the given selector to the respective facet should be executed.  At the same time, it is the stated intent of the system to allow freezability on the granularity level of facets: While the Diamond shall have a global flag to determine whether it is frozen or not. Each facet shall be marked as either freezable or not.  An issue arises, because the selectorToFacet mapping allows different values for the flag isFreezable for different selectors of the same facet. Which would allow for freezability on the granularity of selectors instead of facets. Consider the following example of two different selectors, one freezable, one not, belonging to the same facet:  [selector1  = SelectorToFacet  (facet1  true  ) selectorToFacet  [selector2  = SelectorToFacet  (facet1  false  Moreover, the initialization of the selectorToFacet mapping within the Diamond library in function diamondCut actually allows the assignment of different values for isFreezable. Consider the following example for the facetCuts array:  (facet1  , Add  true  [selector1  ]),  (facet1  , Add  false  [selector2  ])  which will lead to an initialization of the selectorToFacet mapping given in the example above.  To prevent selector-level granularity of the freezabilitiy property, consider removing the isFreezable property from the Diamond.SelectorToFacet datatype and add it to a datatype describing only the facet thereby establishing a 1:1 mapping between facet and freezability.  Update: Fixed in commit e39eb07.  Merkle library verifies intermediate inputs  The Merkle library enables verification of a Merkle proof by performing an inclusion check of an input against a binary tree. This works by consecutively hashing concatenated sibling nodes until a root hash is generated. The input is one of the leaf hash values, while the proof is a path through the tree containing the missing hash information to regenerate the root.  An issue arises in this library, due to the arbitrary length of the proof. This allows shorter paths to resolve to the same root. Hence, the known hash of an intermediate node is a valid input as well. To visualize, considering the leaf nodes h0 and h1, the hashed concatenation hash(h0 || h1) of those hashes would be a valid input along a shorter path. An attacker could utilize the known pre-image to prove its inclusion in the tree. For the standalone library this is a critical problem.  In this particular codebase the Merkle library is solely used in the MailboxFacet contact to prove the inclusion of a transaction within a set of layer 2 logs. Thus, only inputs of type L2Log with a length of 88 bytes are legitimate, while the pre-images of size 64 bytes contained within the Merkle tree are not. However, any future usage on 64 bytes input would lead to a critical vulnerability.  It was also stated that the incomplete tree of fixed size is filled with the default hash hash(\"\"). This allows an attacker to prove the inclusion of empty bytes by default. Although, no threat was identified for the contracts in scope.  Consider strictly checking the path length of the proof against the desired Merkle tree depth to mitigate the first issue. Further, consider using a default leaf hash with unknown pre-image as countermeasure to the second attack. With respect to documentation, consider sticking to the leaf wording for variable naming.  Update: Fixed in commit 7eb51d9. Additional checks have been applied outside of the Merkle library to filter malicious inputs. The library itself remains vulnerable to the attack if used in a different context. A note about this problem was added to the function documentation with commit 5f02309.  Proof replayability  In the proveBlocks function of the ExecutorFacet contract, there is no linkage between the committed blocks and the proof. The respective check is commented out in line 213. However, as it is commented out, the following is applicable.  The provided proof data is self-contained. Hence, the validator verifies that the given proof is valid in itself. Seeing the validator as a black box, it is assumed that there is no back checking against the committed blocks provided during the call. Therefore, the independence between the committed blocks and proof suggests a replay attack. By providing any formerly valid proof the previously committed blocks would be validated. Thus, all users could verify committed blocks, whether valid or not.  As documented in the code, the necessary check is there but commented out, which is based on the argument that the Verifier contract is not yet implemented. However, the commitment check between the blocks and proof has nothing to do with the Verifier. Therefore, consider incorporating this crucial check as part of the finalized codebase.  Update: Fixed in commit 64d6aec.  Low Severity  _proveBlock while loop could run out of gas  In the ExecutorFacet contract within the proveBlocks function, there is a while loop to skip already verified blocks. The loop condition is defined as:  while  (_hashStoredBlockInfo  (_committedBlocks  [i  ])  != firstUnverifiedBlockHash  Therefore, if the committed blocks do no contain the first unverified block, this loop will eventually run out of gas and revert.  Consider limiting the number of loop iterations to the length of the _committedBlocks array and reverting with an expressive error message in case the block was not found.  Update: Fixed in commit df107f0.  DiamondInit can be initialized itself  The DiamondInit contract is designed to initialize the DiamondProxy or any new facet via a delegatecall from the proxy contract. Therefore, the DiamondInit contract is deployed on its own with an unprotected initialize function.  Hence, anyone could initialize the deployed instance of the DiamondInit contract itself. While this isnt identified as a threat, it is good practice to prevent arbitrary callers from initializing contracts.  Consider initializing the DiamondInit contract via the constructor or adding a security mechanism to the initialize function.  Update: Fixed in commit c9089a5.  lastDiamondFreezeTimestamp is unused  In the DiamondCutFacet contract, the diamond can be frozen to allow inspection of the protocols security. Currently, as part of the emergencyFreezeDiamond function, s.diamondCutStorage.lastDiamondFreezeTimestamp is set but not used elsewhere in the code.  Consider either implementing a use-case for this variable or removing it.  Update: Acknowledged, not fixed. The Matter Labs team states:  While this feature was not included into this release we prefer to keep the variable to facilitate the rollout of the feature once it is ready.  Freezability differences between logical components  The usage of the Diamond Proxy pattern allows very modular changes to the system. The standard foresees moving individual selectors from facet to facet. Hence, one logical component (e.g. the ExecutorFacet) could be split into two facets, due to patching a single function and migrating the selector to the new facet, while the rest of the logic is kept in the old facet. As the first selector to the new facet defines the freezability, this could result in two different freeze capabilities for one high-level logical component (ExecutorFacet).  Implementing checks to cover the joint freezability for the logical facet would introduce additional overhead. Instead, consider extensively documenting this behavior in the DiamondCutFacet contract.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.  Gas optimizations  Throughout the codebase there are multiple instances where gas costs can be optimized:  In line 162 of the Diamond library the uint16 cast is unnecessary and can be removed.  Using the delete keyword instead of overwriting with the default value saves gas in these instances:  line 33 of Governance facet. line 119-121 of DiamondCutFacet contract.  In the approveEmergencyDiamondCutAsSecurityCouncilMember function, the s.diamondCutStorage.currentProposalId variable can be written to stack and reused.  In the ExecutorFacet contract on line 113 and 155 two bytes32 values are encoded and hashed. Consider using the abi.encode function for the encoding to be more gas efficient.  In the ExecutorFacet contract, consider writing the _maxU256 return value to stack to save on the following s.totalBlocksCommitted storage reads.  Consider applying the above changes to be more gas efficient.  Update: Fixed in commit 5a4e81a. However, the fix introduced a redundant check of conditions within the function approveEmergencyDiamondCutAsSecurityCouncilMember.  Interface and contract function parameter mismatch  The revertBlocks function has a different parameter name in IExecutor compared to ExecutorFacet. While in the interface the _blocksToRevert parameter suggests reverting a relative amount of blocks, the logic sets an absolute _newLastBlock which is confusing.  Further, in the requestL2Transaction function two parameters have a mismatch between the MailboxFacet and the IMailbox interface.  Consider correcting the above mismatches in favor of consistency and clarity.  Update: Fixed in commit c0600e0.  Getter returns misleading value  In the GettersFacet contract, the function isFunctionFreezable returns a Boolean value indicating whether a given selector is freezable or not. This value is taken from storage without any prior validation. At the same time, any uninitialized storage in Solidity contains the default value zero/false.  Querying the function isFunctionFreezable for an unknown selector will return false, thereby misleading the user to believe that the selector is used within the Diamond and is not freezable.  Consider validating the existence of the sel", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#summary", "labels": ["OpenZeppelin"]}, {"title": "Type", "body": "Type", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#type", "labels": ["OpenZeppelin"]}, {"title": "Rollup", "body": "Rollup", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#rollup", "labels": ["OpenZeppelin"]}, {"title": "Timeline", "body": "Timeline", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#timeline", "labels": ["OpenZeppelin"]}, {"title": "From 2022-09-05", "body": "From 2022-09-05", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#from-2022-09-05", "labels": ["OpenZeppelin"]}, {"title": "To 2022-09-30", "body": "To 2022-09-30", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#to-2022-09-30", "labels": ["OpenZeppelin"]}, {"title": "Languages", "body": "Languages", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#languages", "labels": ["OpenZeppelin"]}, {"title": "Solidity", "body": "Total Issues  35 (25 resolved, 1 partially resolved)  Critical Severity Issues  0 (0 resolved)  High Severity Issues  0 (0 resolved)  Medium Severity Issues  4 (4 resolved)  Low Severity Issues  16 (14 resolved)  Notes & Additional Information  15 (7 resolved, 1 partially resolved)  Scope  We audited the matter-labs/zksync-2-dev repository at the c05b49d7e303996f60a0e35f18ef224e45ee19f5 commit.  In scope were the following contracts:  System Overview  zkSync is a layer 2 scaling solution for Ethereum based on zero-knowledge rollup technology. The protocol aims to provide low transaction fees and high throughput while maintaining full EVM compatibility.  In zkSync users sign and send transactions to validators who process them, include them into blocks, and create a cryptographic commitment of the updated state. This commitment (root hash) is then transferred to a smart contract on layer 1 along with a cryptographic proof (SNARK) proving that this new state was correctly calculated based on applying transactions to a previous state. A compressed state update is also sent to layer 1, allowing anyone to reconstruct the state at any moment. The layer 1 contract validates both the state update and the cryptographic proof, assuring the validity of the transactions included in the block and the data availability.  zkSync protocol implements the Diamond Proxy EIP-2535 as an upgrade mechanism, thereby splitting its functionality into four different facets:  Executor: Processing rollups of layer 2 blocks  Mailbox: Bidirectional communication between layer 1 and layer 2  DiamondCut: Contract administration  Governance: Role management  Note that while the aforementioned EIP does not contain any known issues, it is not yet considered finalized.  Executor  The Executor component allows validators to commit, prove, and execute blocks. All blocks are tentative before execution and can be removed by any validator. This component is central in extending the security guarantees of layer 1 to transactions on layer 2 through rollups.  Mailbox  The Mailbox component handles bi-directional communications between layer 1 (L1) and layer 2 (L2). To request an L2 transaction from L1, the transaction data is appended to a queue and removed from it upon final inclusion of the L2-rollup into the L1 contract.  In contrast, communication from L2 to L1 is divided in two parts: Sending a transaction on L2 and reading it from L1. To send information from L2, a special opcode sendToL1 is implemented. Using this opcode, users can send logs or messages. Logs provide a key-value tuple of 32 bytes each to encode data while messages can be of arbitrary length. The transfer of messages is possible via a special system contract converting it into a log containing a hash-commitment. All logs are individually hashed to form the leaf nodes of a blocks fixed-size Merkle tree. The proof of inclusion is made available on L1 by checking against the Merkle tree root. Upon committing a block, verifications are performed to ensure data availability, enabling anyone to prove message inclusion without additional help from the operator.  DiamondCut  Note: For a comprehensive explanation of the diamond update mechanism please refer to EIP-2535.  This component manages upgrade-related operations and freezing/unfreezing of facets. The upgrade mechanism is comprised of three stages:  Upgrade proposal  In this stage, the governor commits both a sequence of changes (add/replace/remove) to the supported facet functions and the fixed address of an initializer contract.  Upgrade notice period  zkSync users are given a constant timeframe to withdraw their funds if they are against the proposed upgrade, unless the Security Council approves an immediate emergency upgrade, thereby skipping the execution delay.  Upgrade execution  The governor can execute the upgrade and provide additional calldata to the initializer contract.  Freezing Mechanism  Matter Labs team has implemented a freezing feature. When defining the facet through diamond cuts, each facet can be set as freezable or not. The governor can freeze the diamond as a whole which affects all freezable facets. Therefore, it is possible to designate parts that shall remain operational in an emergency situation. It is crucial for the DiamondCut facet to remain operational in order to enable the governor to unfreeze the Diamond Proxy after resolving the emergency situation.  Governance  The Governance component allows the governor to assign and remove the valdiator role from addresses. It further enables the transition of contract administration to a new governor by designating a pending governor who needs to accept his role in an additional step thereby removing the old governor.  Operation Modes  Regular Operation  This operation mode allows only registered validators to commit and execute blocks with rolled-up layer 2 transaction information. Thus, users are dependent on the validators to not censor their transactions. To protect against malfunction and malice a second operation mode exists.  Priority Mode  Under specific conditions the system can enter a special operation mode called Priority Mode. This mechanism is intended as an escape hatch to allow users to withdraw their funds from zkSync protocol in the case an operator becomes malicious or unavailable. During the course of this audit this feature was out of scope due to the fact that it was not yet implemented.  Privileged Roles and Security Assumptions  The governor is a single address that can perform critical administrative actions such as proposing, canceling, and executing upgrades of the Diamond Proxy, as well as freezing and unfreezing the proxy. The governor is restricted by a time-delay between proposal and execution of any upgrade. However, no other entity can veto, postpone, or restrict the governors actions. Further, the governor can set and unset addresses as validators. The governor is considered a trusted entity.  The security council is a set of addresses that can skip the time-delay within the approval process of upgrades proposed by the governor to allow immediate incidence response actions. The security council has no power to propose, delay, or veto actions. The exact size of the security council, its members, or the threshold of security council votes to allow immediate execution of a proposal has not been determined at the time of the audit.  The Verifier is a smart contract on layer 1 in charge of verifying zk-proofs. It exposes a function that returns a Boolean value indicating whether a given proof is valid. During the course of this audit this feature was out of scope due to the fact that it was not yet implemented.  The validators are a set of layer 1 addresses in charge of bundling transactions into blocks, executing them on layer 2, committing their compressed information to layer 1, requesting their zk-proof, and finalizing them on layer 1. Additionally, they are in charge of forwarding messages between layer 1 and layer 2. The validators are partially trusted  at the time of the audit no escape hatch was implemented, hence it is necessary to trust the validators not to censor transactions and refuse/abandon operation. However, the verification of transactions via zk-proofs mathematically prevents validators from spoofing transactions or relaying false information. At the time of the audit, the validators are a centralized entity, while future decentralization is planned.  A set of four system contracts on layer 2 has privileged roles and performs special operations:  The Contract Deployer is in charge of deploying contracts on layer 2 via a hash-commitment to the contracts bytecode.  The IL1Messenger is a contract that allows the transfer of arbitrary-length messages from layer 2 to layer 1 by using a hash commitment within the fixed-size data exchange struct L2Log.  The INonceHolder stores transaction and deployment nonces for accounts and exposes them via view functions.  The Bootloader acknowledges received requests which have been passed from layer 1 to layer 2 via the priority queue mechanism.  Medium Severity  Corruption of facets array on selector replacement  The Diamond library allows replacing a selectors facet with itself which is non-compliant with EIP-2535.  Moreover, an edge-case in which a facet only has one selector and this selectors facet is replaced with itself leads to corruption of the DiamondStorage.facets array. Consider the following scenario:  A facet has an array of selectors containing only one element [s1]. Through the function diamondCut a call to _replaceFunctions is initiated.  Inside of _replaceFunctions, the call to _saveFacetIfNew does not add any facet, because the facet is already registered.  Inside of the loop iterating through the selector array [s1], the call to _removeOneFunction triggers a call to _removeFacet due to the last selector being removed. This in turn removes the facet from the ds.facets array.  The subsequent call to _addOneFunction adds selector s1 back to the facet, while the facet remains deleted from the ds.facets array, thereby corrupting it.  To be fully compliant with the EIP-2535 spec and mitigate the edge-case leading to a corruption of the facets array, consider adding the requirement that _facet and oldFacet.facetAddress are distinct from each other.  Update: Fixed in commit f6cde78. The team mitigated this edge-case by rearranging the code. However, with the missing distinction check, the implementation is not fully EIP-2535 compliant.  Freezable property applies to individual selectors instead of facets  In the DiamondProxy contract, a selector is mapped to a facet via the mapping diamondStorage.selectorToFacet upon executing the fallback function. The received datastructure of type Diamond.SelectorToFacet contains the information  address  facetAddress  uint16  selectorPosition  bool  isFreezable  The flag isFreezable is used to determine whether the delegatecall of the given selector to the respective facet should be executed.  At the same time, it is the stated intent of the system to allow freezability on the granularity level of facets: While the Diamond shall have a global flag to determine whether it is frozen or not. Each facet shall be marked as either freezable or not.  An issue arises, because the selectorToFacet mapping allows different values for the flag isFreezable for different selectors of the same facet. Which would allow for freezability on the granularity of selectors instead of facets. Consider the following example of two different selectors, one freezable, one not, belonging to the same facet:  [selector1  = SelectorToFacet  (facet1  true  ) selectorToFacet  [selector2  = SelectorToFacet  (facet1  false  Moreover, the initialization of the selectorToFacet mapping within the Diamond library in function diamondCut actually allows the assignment of different values for isFreezable. Consider the following example for the facetCuts array:  (facet1  , Add  true  [selector1  ]),  (facet1  , Add  false  [selector2  ])  which will lead to an initialization of the selectorToFacet mapping given in the example above.  To prevent selector-level granularity of the freezabilitiy property, consider removing the isFreezable property from the Diamond.SelectorToFacet datatype and add it to a datatype describing only the facet thereby establishing a 1:1 mapping between facet and freezability.  Update: Fixed in commit e39eb07.  Merkle library verifies intermediate inputs  The Merkle library enables verification of a Merkle proof by performing an inclusion check of an input against a binary tree. This works by consecutively hashing concatenated sibling nodes until a root hash is generated. The input is one of the leaf hash values, while the proof is a path through the tree containing the missing hash information to regenerate the root.  An issue arises in this library, due to the arbitrary length of the proof. This allows shorter paths to resolve to the same root. Hence, the known hash of an intermediate node is a valid input as well. To visualize, considering the leaf nodes h0 and h1, the hashed concatenation hash(h0 || h1) of those hashes would be a valid input along a shorter path. An attacker could utilize the known pre-image to prove its inclusion in the tree. For the standalone library this is a critical problem.  In this particular codebase the Merkle library is solely used in the MailboxFacet contact to prove the inclusion of a transaction within a set of layer 2 logs. Thus, only inputs of type L2Log with a length of 88 bytes are legitimate, while the pre-images of size 64 bytes contained within the Merkle tree are not. However, any future usage on 64 bytes input would lead to a critical vulnerability.  It was also stated that the incomplete tree of fixed size is filled with the default hash hash(\"\"). This allows an attacker to prove the inclusion of empty bytes by default. Although, no threat was identified for the contracts in scope.  Consider strictly checking the path length of the proof against the desired Merkle tree depth to mitigate the first issue. Further, consider using a default leaf hash with unknown pre-image as countermeasure to the second attack. With respect to documentation, consider sticking to the leaf wording for variable naming.  Update: Fixed in commit 7eb51d9. Additional checks have been applied outside of the Merkle library to filter malicious inputs. The library itself remains vulnerable to the attack if used in a different context. A note about this problem was added to the function documentation with commit 5f02309.  Proof replayability  In the proveBlocks function of the ExecutorFacet contract, there is no linkage between the committed blocks and the proof. The respective check is commented out in line 213. However, as it is commented out, the following is applicable.  The provided proof data is self-contained. Hence, the validator verifies that the given proof is valid in itself. Seeing the validator as a black box, it is assumed that there is no back checking against the committed blocks provided during the call. Therefore, the independence between the committed blocks and proof suggests a replay attack. By providing any formerly valid proof the previously committed blocks would be validated. Thus, all users could verify committed blocks, whether valid or not.  As documented in the code, the necessary check is there but commented out, which is based on the argument that the Verifier contract is not yet implemented. However, the commitment check between the blocks and proof has nothing to do with the Verifier. Therefore, consider incorporating this crucial check as part of the finalized codebase.  Update: Fixed in commit 64d6aec.  Low Severity  _proveBlock while loop could run out of gas  In the ExecutorFacet contract within the proveBlocks function, there is a while loop to skip already verified blocks. The loop condition is defined as:  while  (_hashStoredBlockInfo  (_committedBlocks  [i  ])  != firstUnverifiedBlockHash  Therefore, if the committed blocks do no contain the first unverified block, this loop will eventually run out of gas and revert.  Consider limiting the number of loop iterations to the length of the _committedBlocks array and reverting with an expressive error message in case the block was not found.  Update: Fixed in commit df107f0.  DiamondInit can be initialized itself  The DiamondInit contract is designed to initialize the DiamondProxy or any new facet via a delegatecall from the proxy contract. Therefore, the DiamondInit contract is deployed on its own with an unprotected initialize function.  Hence, anyone could initialize the deployed instance of the DiamondInit contract itself. While this isnt identified as a threat, it is good practice to prevent arbitrary callers from initializing contracts.  Consider initializing the DiamondInit contract via the constructor or adding a security mechanism to the initialize function.  Update: Fixed in commit c9089a5.  lastDiamondFreezeTimestamp is unused  In the DiamondCutFacet contract, the diamond can be frozen to allow inspection of the protocols security. Currently, as part of the emergencyFreezeDiamond function, s.diamondCutStorage.lastDiamondFreezeTimestamp is set but not used elsewhere in the code.  Consider either implementing a use-case for this variable or removing it.  Update: Acknowledged, not fixed. The Matter Labs team states:  While this feature was not included into this release we prefer to keep the variable to facilitate the rollout of the feature once it is ready.  Freezability differences between logical components  The usage of the Diamond Proxy pattern allows very modular changes to the system. The standard foresees moving individual selectors from facet to facet. Hence, one logical component (e.g. the ExecutorFacet) could be split into two facets, due to patching a single function and migrating the selector to the new facet, while the rest of the logic is kept in the old facet. As the first selector to the new facet defines the freezability, this could result in two different freeze capabilities for one high-level logical component (ExecutorFacet).  Implementing checks to cover the joint freezability for the logical facet would introduce additional overhead. Instead, consider extensively documenting this behavior in the DiamondCutFacet contract.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.  Gas optimizations  Throughout the codebase there are multiple instances where gas costs can be optimized:  In line 162 of the Diamond library the uint16 cast is unnecessary and can be removed.  Using the delete keyword instead of overwriting with the default value saves gas in these instances:  line 33 of Governance facet. line 119-121 of DiamondCutFacet contract.  In the approveEmergencyDiamondCutAsSecurityCouncilMember function, the s.diamondCutStorage.currentProposalId variable can be written to stack and reused.  In the ExecutorFacet contract on line 113 and 155 two bytes32 values are encoded and hashed. Consider using the abi.encode function for the encoding to be more gas efficient.  In the ExecutorFacet contract, consider writing the _maxU256 return value to stack to save on the following s.totalBlocksCommitted storage reads.  Consider applying the above changes to be more gas efficient.  Update: Fixed in commit 5a4e81a. However, the fix introduced a redundant check of conditions within the function approveEmergencyDiamondCutAsSecurityCouncilMember.  Interface and contract function parameter mismatch  The revertBlocks function has a different parameter name in IExecutor compared to ExecutorFacet. While in the interface the _blocksToRevert parameter suggests reverting a relative amount of blocks, the logic sets an absolute _newLastBlock which is confusing.  Further, in the requestL2Transaction function two parameters have a mismatch between the MailboxFacet and the IMailbox interface.  Consider correcting the above mismatches in favor of consistency and clarity.  Update: Fixed in commit c0600e0.  Getter returns misleading value  In the GettersFacet contract, the function isFunctionFreezable returns a Boolean value indicating whether a given selector is freezable or not. This value is taken from storage without any prior validation. At the same time, any uninitialized storage in  contains the default value zero/false.  Querying the function isFunctionFreezable for an unknown selector will return false, thereby misleading the user to believe that the selector is used within the Diamond and is not freezable.  Consider validating the existence of the selector by requiring that the facet address of the selector is registered.  Update: Fix", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#solidity", "labels": ["OpenZeppelin"]}, {"title": "Total Issues", "body": "Total Issues", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#total-issues", "labels": ["OpenZeppelin"]}, {"title": "35 (25 resolved, 1 partially resolved)", "body": "35 (25 resolved, 1 partially resolved)", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#35-(25-resolved,-1-partially-resolved)", "labels": ["OpenZeppelin"]}, {"title": "Implicit balances", "body": "There are several instances throughout the code base where the strategies use their token balance without validating it matches the expected value. This has two implications:  It does not account for tokens that could be sent to the contract directly.  It assumes the contract has received the expected number of tokens.  The most important example is both instances when the ConvexOUSDMetaStrategy attempts to burn all its OUSD tokens. This would fail if its balance exceeds the acceptable range, which could occur if someone sends OUSD directly to the strategy.  Additionally, in the interest of predictability:  When the amount of tokens to deposit is already known, that value can be used instead of the contracts balance. Alternatively, only the difference needs to be minted in the first place.  When the amount of tokens to receive is already known, it can be used as the minimum withdrawal amount.  Lastly, in the interest of local reasoning and robustness, consider explicitly confirming that the Curve protocol returns the expected number of tokens, rather than assuming it respects the stated minimum thresholds.  Update: Fixed in commit 290c68fd25a1f2967324948398227684ec834597. The Curve system is still assumed to return the expected number of tokens.  Low Severity", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#implicit-balances", "labels": ["OpenZeppelin"]}, {"title": "Complicated accounting", "body": "slightly overestimate the desired value,  determining the corresponding amount of stablecoin, and then  scaling down the LP amount linearly to match the required stablecoin value. Instead, consider directly querying the amount of LP tokens to burn with the  calc_token_amount function, and then adjusting for fees. If desired, the amount could be validated with the  calc_withdraw_one_coin function.  Update: Acknowledged, not resolved. The Origin team stated:  calc_token_amount does not account for curve fees. Correctly accounting for way curve fees are calculated ends up being more code than the current method.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#complicated-accounting", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent reference to pToken", "body": "The BaseCurveStrategy has two mechanisms to refer to the 3CRV token: the generic mapping it inherits from InitializableAbstractStrategy and its own local variable. We believe the local variable was introduced as a simplification, because all three assets correspond to the same platform token, but it is used inconsistently. In particular:  The withdraw function equivocates between the mapping and the local variable in the event emission and balance check.  The checkBalance function uses the mapping to retrieve the platform token balance but then assumes the asset is worth one third of the value. This only makes sense if there are three assets mapping to the same platform token.  There are code comments that explicitly account for the possibility that not all assets are mapped correctly.  Consider using the local variable throughout the contract and disabling the ability to set the mapping individually.  Update: Partially fixed in commit 49ee19e1d6bbc623bb88027c997658d21fe32390. Some functions (like safeApproveAllTokens) still use the mapping.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#inconsistent-reference-to-ptoken", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent rebase bound", "body": "When minting OUSD tokens, there will be a rebase if the amount equals the threshold. However, when redeeming or burning tokens, the amount needs to be strictly greater than the threshold. Consider using an exclusive (or inclusive) bound throughout the code base.  Update: Fixed in commit e574b38ba22ae95302b9386d06aed980337c07bc.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#inconsistent-rebase-bound", "labels": ["OpenZeppelin"]}, {"title": "Incorrect event parameter", "body": "Both  emissions of the  pTokenAddress variable instead.  Update: Fixed in commit 381fdfaed1ed247167f4f2182a52c27ed9b8dd05.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#incorrect-event-parameter", "labels": ["OpenZeppelin"]}, {"title": "Misleading comments", "body": "The code base contains several misleading comments:  The collectRewardTokens function of the BaseConvexMetaStrategy contract claims to send rewards to the vault, but it sends them to the harvester address.  The depositAll function of the BaseCurveStrategy contract does not accurately describe how all descendant contracts retrieve the 3CRV token address.  The comment explaining how much OUSD to add in the ConvexOUSDMetaStrategy states that it could mint less OUSD if the metapool has too much, but it always adds at least as much OUSD as 3CRV. Moreover, it claims the metapool will end up balanced. However it wont add more than twice as much OUSD (by value) than 3CRV, even if thats necessary to balance the metapool.  The mintForStrategy function of the VaultCore contract claims that it cannot use the nonReentrant modifier because it clashes with the BaseCurveStrategy contracts modifier. However, the two modifiers do not interact with each other. Instead, it is the nonReentrant modifier on the allocate function that would cause the conflict.  The @param comment describing the _lpWithdraw function of the ConvexOUSDMetaStrategy contract claims it is the number of Convex LP tokens to redeem, but it is the number of 3CRV tokens to retrieve.  Consider correcting these comments.  Update: Fixed in commit 4b7f103658656a16d160231f96f36ac1d4336dfd and commit d7ddbb3a2c261ed600d99bc73377de53b4859ad5.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#misleading-comments", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "The setMaxWithdrawalSlippage function of the BaseConvexMetaStrategy contract is missing its @param statement. Consider including it.  Update: Fixed in commit 689d527252ec78932d4bf422be3ac6b8245a777d.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Misusing safeApprove", "body": "The BaseCurveStrategy contract and the BaseConvexMetaStrategy contract provides functionality to grant addresses an infinite allowance. However, they bypass the safety mechanism in safeApprove that prevents changing the allowance between two non-zero values, which is intended to prevent front-running attacks that spend both allowances. In this case, since the intended allowance is unlimited, the possibility of front-running is irrelevant.  Nevertheless, we consider it bad practice to use a safety mechanism while bypassing its additional requirements. Consider using the standard approve function and validating that it succeeds.  Update: Acknowledged, not resolved. The Origin team stated:  We need to handle USDTs non-standard return value (no boolean), and safeApprove provides a clean way of doing this.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#misusing-safeapprove", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent storage gaps", "body": "When using the proxy pattern for upgrades, it is common practice to include storage gaps on parent contracts to reserve space for potential future variables. The size is typically chosen so that all contracts have the same number of variables (usually 50). However, the code base uses inconsistent sizes and does not always include a gap at all. In particular:  The InitializableAbstractStrategy contract reserves 98 slots, bringing the total storage usage up to 106.  The BaseCurveStrategy has no storage gaps.  The BaseConvexMetaStrategy contract reserves 30 slots, bringing the total storage usage up to 39.  Consider using consistently sized storage gaps in all contracts that have not yet been deployed. For contracts that cannot be changed, because they are ancestors of live contracts in the code base, consider documenting the unusual storage size to facilitate safe upgrades.  Update: Fixed in commit e30022cd9fb7e815cb16ffd09a21c276f3980250.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#inconsistent-storage-gaps", "labels": ["OpenZeppelin"]}, {"title": "Uninitialized implementations", "body": "The proxy contracts that represent the strategies should be initialized before they are used. However, it is good practice to initialize the implementation contracts as well to reduce the attack surface by preventing them from being initialized in the future. Consider adding a constructor that calls the initializer to the ConvexOUSDMetaStrategy and ConvexGeneralizedMetaStrategy contracts.  Update: Acknowledged, not resolved. The Origin team stated:  Our implementation contracts have the owner set in the constructor at creation and outsiders cannot initialize them. We will transfer ownership of implementation contracts to the governance system.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#uninitialized-implementations", "labels": ["OpenZeppelin"]}, {"title": "Constants not declared explicitly", "body": "There are some occurrences of literal values with unexplained meaning in Origins contracts. For example, line 135 in BaseConvexMetaStrategyand line 212 in BaseCurveStrategy.sol. Literal values in the code base without an explained meaning make the code harder to read, understand, and maintain. This makes the code harder to understand for developers, auditors, and external contributors alike.  Developers should define a constant variable for every magic value used (including booleans), giving it a clear and self-explanatory name. Additionally, for complex values, inline comments explaining how they were calculated or why they were chosen are highly recommended. Following Soliditys style guide, constants should be named in UPPER_CASE_WITH_UNDERSCORES format.  Update: Fixed in commit 46cfa3a8e0c9511b987234978178d80248215664.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#constants-not-declared-explicitly", "labels": ["OpenZeppelin"]}, {"title": "Implicit visibility", "body": "The state variables crvCoinIndex and mainCoinIndex in the BaseConvexMetaStrategy contract do not have an explicit visibility modifier. In the interest of clarity, consider including it.  Update: Fixed in commit 9d794d1e682dad35d61dd84b906b6168179a46ec.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#implicit-visibility", "labels": ["OpenZeppelin"]}, {"title": "Unindexed events", "body": "Consider indexing the VaultCore events to assist the task of off-chain services searching and filtering for specific events.  Update: Acknowledged, not resolved The Origin team stated:  Were going to keep our existing event signatures for backwards compatibility. For the new event (OusdMetaStrategyUpdated), well keep it consistent with the existing events.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#unindexed-events", "labels": ["OpenZeppelin"]}, {"title": "Unused import", "body": "The BaseCurveStrategy has an unnecessary import statement. Consider removing it.  Update: Fixed in commit ea5154feaa97b64a36bd49d83d38be6b9d526524.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#unused-import", "labels": ["OpenZeppelin"]}, {"title": "Conflated staking pool reward balances", "body": "Each staking pool specifies its own reward token and corresponding balance in the same aggregate contract. When retrieving this value, the token balance of the aggregate contract is returned. Since there could be multiple staking pools with the same reward token, this could include balances from other pools. It could also include any reward token balances that were directly sent to the contract.  Moreover, current user rewards could also be overstated, which would prevent users from claiming the last rewards. Since rewards are claimed when withdrawing stake, anyone could prevent users from unstaking by directly sending reward tokens to the staking pool contract. Any non-zero amount would be sufficient to trigger this scenario. If this occurs, a recovery agent could still retrieve the funds from the aggregate pool contract and distribute them as desired, although it is not clear how they should distribute the remaining rewards.  Consider reading the pool balance from the saved record.  Update: Fixed as of commit 8b660b13cf9fbcde0bfedb3819dbb670ba74b09a in pull request #156.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#conflated-staking-pool-reward-balances", "labels": ["OpenZeppelin"]}, {"title": "Risk of insufficient liquidity", "body": "When purchasing a cover, the protocol ensures it has enough funds to pay out all potential claimants. The computation of the existing commitments includes all covers expiring in the next 3 months, since this is the maximum policy duration. However, some covers may expire in the fourth month and these would be excluded from the calculation. Therefore, the protocol could sell more insurance than it can support, and some valid claimants may be unable to retrieve their payment.  Consider including the extra month in the commitment computation.  Update: Fixed as of commit 63fce22c67f72cf090ffa124784a3d92935e2d66 in pull request #136.  Medium Severity", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#risk-of-insufficient-liquidity", "labels": ["OpenZeppelin"]}, {"title": "Unenforced staking requirement", "body": "Adding liquidity requires a liquidity provider to have at least a minimum amount of NPM tokens staked in the vault.  However, the purpose and usefulness of this requirement is unclear, since it can be bypassed. In particular:  there is no relationship between the amount of PODs created and the size of the stake  PODs are transferable to unstaked users, so users can provide liquidity without staking  staked users can exit their entire staked amount without redeeming any PODs by calling removeLiquidity with parameters podsToRedeem = 0, npmStakeToRemove = amount, and exit = 1; the exit = 1 is crucial as it allows execution of line 234 of VaultLibV1.sol  Consider documenting and enforcing the intended relationship between NPM staking and liquidity provision.  Update: Acknowledged, not fixed. The Neptune team stated:  Although we plan to redo the staking requirement logic from scratch, we wish to consider this risk as acceptable for the time being.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#unenforced-staking-requirement", "labels": ["OpenZeppelin"]}, {"title": "Potential token transfer from unrelated account", "body": "The CoverReassurance contract contains a mechanism to retrieve funds from an arbitrary account, as long as the account has provided a non-zero allowance. This would occur whenever a cover owner can front-run another cover owners reassurance transaction, allowing them to redirect the funds to their own cover.  Even without front-running, there are multiple reasons an account may have a non-zero allowance, including:  Their addReassurance transaction failed and they didnt revoke the allowance.  They made an unlimited approval.  They approved a higher allowance than the amount they eventually transferred.  In all cases, an attacker can retrieve those funds and direct them towards a cover.  A recovery agent could still retrieve the funds from the CoverReassurance contract and distribute them as desired, although it is unclear how they would distinguish a front-running attack from one where a cover owner legitimately transfers funds from a different account.  Consider retrieving the tokens from the message sender rather than an arbitrary account parameter.  Update: Fixed as of commit ca55b69c5cdd80bcccdc83dd5d569933f450fa6a in pull request #139.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#potential-token-transfer-from-unrelated-account", "labels": ["OpenZeppelin"]}, {"title": "Incorrect policy fee", "body": "There are two discrepancies when calculating a policy fee rate:  It is always strictly higher than the configured floor.  The amount of days charged does not account for a non-standard coverage lag period.  Consider updating the calculation accordingly.  Update: Fixed as of commit 84a6fc3167adfb61b6f16666f0ba422b60bc0b2c in pull request #159 and commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196. The Neptune team have chosen not to address the first bullet.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#incorrect-policy-fee", "labels": ["OpenZeppelin"]}, {"title": "Parallel access control", "body": "The Protocol contract inherits the OpenZeppelin AccessControl contract, and uses it to define the role hierarchy. It also provides a mechanism for the administrator to grant an existing role to a new address. However, this mechanism functions in parallel to the inherited mechanism for granting roles. This leads to two inconsistencies:  A role administrator can bypass the whenNotPaused restriction by using the inherited mechanism.  The NS_ROLES_ADMIN can use the new mechanism to grant the NS_ROLES_GOVERNANCE_AGENT, even though they do not directly administer that role.  Consider ensuring consistency between the two mechanisms. Depending on the desired outcome, this could involve relying on the original mechanism, changing the role relationships, or overriding the inherited grantRole function.  Update: Fixed as of commit 1d54d66493e3109c12d610f0231529cbd65b5ba9 in pull request #157 and commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#parallel-access-control", "labels": ["OpenZeppelin"]}, {"title": "Unable to unstake after finalization", "body": "Reporters on the winning camp can unstake their tokens even after the incident has been finalized, albeit with no reward. However, the resolution deadline is not specific to a particular incident and is reset to 0 during finalization. Since the deadline is checked during unstaking, the operation will fail. This means that some successful NPM stakers will be unable to retrieve their funds.  In this scenario, a recovery agent could still retrieve the funds from the Resolution contract and distribute them as desired.  Consider recording the resolution deadline with the incident date so it does not need to be cleared during finalization.  Update: Fixed as of commit 6cb6b6064eca18cccee8114cbcefd2455c286ce9 in pull request #132 and commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#unable-to-unstake-after-finalization", "labels": ["OpenZeppelin"]}, {"title": "Unexpected deployer privileges", "body": "recorded as a protocol member, which allows it to update the storage arbitrarily. The same address  is set as the contracts  pause and unpause storage updates. We believe these are intended to be the same role, but they are not programmatically connected. In particular, if the owner address is  renounced or transferred, the deployer will still be able to update storage.  Moreover, it is unclear why the Store owner or deployer requires the ability to modify storage arbitrarily.  Consider documenting the role in the Security overview if the role is required. Otherwise, consider renouncing protocol member privileges from the deployer address after the deployment is finished.  Update: Fixed as of commit 0b278019c01dbce22923d0bb6968ddb48bcc3e2d in pull request #123. The deployer address is removed as a protocol member, assuming the deployer is the address that calls the initialize function.  Low Severity", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#unexpected-deployer-privileges", "labels": ["OpenZeppelin"]}, {"title": "Able to close non-empty staking pool", "body": "A staking pool can be closed without checking if there is any remaining liquidity of either the staking token or the reward token. Once the pool is closed, neither deposit nor withdraw functions are allowed. Hence, users wont be able to access their funds. However a recovery agent is still able to retrieve both staking and reward tokens and distribute them as desired.  Consider checking for remaining liquidity before closing a pool.  Update: Fixed as of commit 86b0caa0995ffcdbb1deecf8547c9a3db8c23821 in pull request #160.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#able-to-close-non-empty-staking-pool", "labels": ["OpenZeppelin"]}, {"title": "Collision between constants", "body": "The NS_POOL_MAX_STAKE and NS_POOL_REWARD_TOKEN constants are defined to be the same string, which introduces the possibility of unexpected storage collisions. In the current code base they are used with non-overlapping data types, which are saved in different mappings. Nevertheless, in the interest of predictability, consider redefining the NS_POOL_MAX_STAKE constant to a unique string.  Update: Fixed as of commit 90f03dce0d24af3affc50d19ac81bbc12b524a4f in pull request #161.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#collision-between-constants", "labels": ["OpenZeppelin"]}, {"title": "Implicit timing assumptions", "body": "To account for the coverage delay, some valid cxTokens may be excluded from making claims. Any coverage that will become active within 14 days but before the incident resolution will be disregarded. This implicitly assumes that no valid cover starts after either of these deadlines (otherwise it should also be excluded). Since the coverage delay and resolution window are configurable parameters, the assumptions may not hold. Consider calculating exclusions based on the specific parameters that are relevant to the incident being processed.  Update: Fixed as of commit e00b4248768c196a2b5047dcc21d91a2503452ab in pull request #162 and commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#implicit-timing-assumptions", "labels": ["OpenZeppelin"]}, {"title": "Imprecise bounds", "body": "There are several examples where the time windows or value ranges are defined inconsistently. In particular:  The getWithdrawalInfoInternal function of the RoutineInvokerLibV1 library considers the end timestamp to be part of the withdrawal period but the mustBeDuringWithdrawalPeriod validation function does not.  The StakingPoolLibV1 library prevents withdrawals on the block height where withdrawals can start.  Neither the mustBeBeforeResolutionDeadline function nor the mustBeAfterResolutionDeadline function will succeed on the resolution deadline.  The flash loan fee calculation requires the loan to be strictly less than the available balance, even though the contract claims to loan out the whole balance.  Update: Fixed as of commit 3412b68b9d729d0bc5c3b5860ace7a38a06b9835 in pull request #167.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#imprecise-bounds", "labels": ["OpenZeppelin"]}, {"title": "Incorrect NPM threshold", "body": "Some operations require an NPM stake that must not exceed a threshold, currently set to 10 billion. However, the total NPM supply cannot exceed 1 billion, making the threshold non-functional. The Neptune team indicated the threshold should only be 10 million. Consider updating the constant accordingly.  Update: Fixed as of commit 78fafa7314793a3b6b5fe40e1c9129c8f8c4f813 in pull request #164.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#incorrect-npm-threshold", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation", "body": "The mustNotExceedNpmThreshold function should validate npmStakeToAdd instead of amount.  The setPolicyRatesByKey function in the PolicyAdmin contract does not check that ceiling is greater than floor, while a similar function setPolicyRates does.  The initialize function in the Protocol contract does not check the length of the input values array.  When computing unstaking rewards after an incident resolution, the sum of the toBurn and toReporter rates are not validated to be bounded above by ProtoUtilV1.MULTIPLIER.  Consider including the corresponding validations.  Update: Fixed as of commit 5ce4b8d3ff0b0a7eb4f0265b4201c93c43af4f30 in pull request #172 and commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Missing event parameter", "body": "The PoolUpdated event does not include the stakingTarget parameter. Consider including it.  Update: Fixed as of commit 89d30f63d6c43dd3787cd291e31c03a2b712a0a2 in pull request #163.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#missing-event-parameter", "labels": ["OpenZeppelin"]}, {"title": "No unstaking window", "body": "After an incident is resolved, successful stakers can retrieve their rewards provided the incident has not been finalized. When the incident occurred, they will have at least the claim period. However, if the incident was successfully disputed, there is no claim period and the incident can be finalized immediately before stakers have been provided sufficient time to claim their rewards. Consider including an unstaking window for this scenario.  Update: Acknowledged, not fixed. The Neptune team stated:  For incidents resolved as false reporting, we intend to restore the cover status to operational as soon as possible. This flexibility allows us to accomplish a speedier finalization while still allowing the tokenholder community sufficient time to unstake their claim (with reward) on a case-by-case basis.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#no-unstaking-window", "labels": ["OpenZeppelin"]}, {"title": "Protocol administrator needs to handle external tokens", "body": "The protocol administrator is one of the most critical roles with immense privilege in the operation of the entire protocol. For example, only the administrator can re-initialize the protocol, grant key access control roles, as well as set up all staking and bonding pools.  However, when setting up a staking pool, a non-zero amount of reward tokens are required to be pre-transferred to the administrator account and pulled to the contract. This implies that the administrator needs to receive and approve the transaction a priori. This increases the attack surface and may not fit the intended security assumptions for a critical role.  Consider either using a less critical role to perform staking pool initialization or allowing pool initialization without any token transfer.  Update: Fixed as of commit 71fd05996061b9c438c557c92cd888f4f4c9c542 in pull request #173. The Liquidity Manager must now initialise and manage the staking pools. They must also set up the Bond pools.  The info parameter might lose information about an IPFS hash  The info parameter of the report, dispute, and other functions assume that the length of the IPFS hash is 32 bytes or shorter. However, that is not the case for CIDv1 where the hash can be longer than 32 bytes and also contain prefixes.  This leads to a data availability issue when NPM holders might be unable to retrieve the incident information from the smart contracts. Consequently, they are unable to decide whether to attest or refute the incident.  Consider using a different data structure for storing an IPFS hash.  Update: Fixed as of commit 5ebb130fe274f0237e368ceaac25751936c1b321 in pull request #165.  Incorrect individual liquidity share  The calculation of an individuals share of liquidity for a particular cover incorrectly uses values[5] instead of values[4] as the number of PODs. Since this is always zero, the returned share of liquidity will always be zero.  This has no implications within the current code base but would mislead external users that rely on it. Consider using the correct number of PODs in the calculation.  Update: Fixed as of commit 2192646ab5efa95a90521b986c81c05ed04fcd37 in pull request #166.  Variable outside store  In contrast to most of the code base, the last policy identifier is saved directly in the Policy contract. However, to maintain continuity and prevent conflicts, any new version will need to import the old value.  Consider saving it in the Store contract.  Update: Fixed as of commit 1826fa97f1b325d40b0b3446b384dac35074540f in pull request #168.  Notes & Additional Information  transfer and send calls are no longer considered best practice  When transfer or send calls are used to transfer Ether to an address, they forward only a limited amount of gas. This precludes destination addresses with complex fallback functions. Additionally, given that gas prices for EVM operations are sometimes repriced, code execution on the receiving end of these calls cannot be guaranteed in perpetuity.  There are multiple occurrences throughout the code base where transfer or send is used to transfer Ether. For instance:  On line 41 of StoreBase.sol Ether is transferred via transfer.  On line 19 of WithRecovery.sol Ether is transferred via transfer.  On line 23 of BaseLibV1.sol Ether is transferred via transfer.  Rather than using transfer or send, consider using address.call{value: amount}(\"\") or the sendValue function of the OpenZeppelin Address library to transfer Ether.  Update: Fixed as of commit adf8883628f94a27ae61376e98d112f998029e16 in pull request #187.  Anyone can temporarily DoS a fresh vault  Vaults are deployed by whitelisted cover creators with the addCover function. To prevent someone from unbalancing the POD-to-stablecoin ratio immediately after deployment, the Vault detects unmatched stablecoins and reverts on any attempt to add liquidity which effectively disables the vault.  A recovery agent could retrieve the excess funds to re-enable the contract. Nevertheless, to avoid this scenario, consider adding some liquidity in the same transaction as the deployment. Alternatively, consider tracking the stablecoin balance in a variable to mitigate issues caused by direct transfers.  Commit-Reveal voting  The Governance mechanism allows NPM token holders to vote on whether they believe a reported incident is valid. Typically, the rationale for using voting as an oracle is that token holders, who are incentivized to vote with the majority, will treat the truth as a natural Schelling Point. However, since token holders can review the running total, they may instead simply vote with the majority.  This is commonly mitigated with a commit-reveal voting scheme. However, it is also mitigated by the possibility of a governance administrator overruling the vote. We are just noting the practice for your consideration. If the commit-reveal scheme is adopted, votes that are not revealed should be considered incorrect so that users cannot selectively abstain based on the running total.  Copied in dependencies  Dependencies in the lib directory, including openzeppelin-solidity, are copied in without any reference in .gitmodules. This makes it hard to keep track of the latest versions and easy to accidentally change the code inside.  Consider using forge install OpenZeppelin/openzeppelin-contracts for the latest version of the OpenZeppelin contracts.  Update: Fixed as of commit 80f024fb21389e5d29eff9e79a6d0248c6f61183 in pull request #188.  Docstrings not following NatSpec  Across the code base there are several examples of contracts not consistently following the Ethereum Natural Specification Format (NatSpec). Consider following this specification on everything that is part of the contracts public API.  Some examples include:  Missing NatSpec for productKey at line 151 of PolicyHelperV1.  Discrepancy between addCovers NatSpec in the Cover contract and the ICover interface the interfaces misses NatSpec for 8th and 9th parameters. Consider using @inheritdoc NatSpec tag.  Return variables are documented using @param instead of @return in Vault.getInfo.  Duplicate modifier  The unpause function of the ProtoBase contract has two whenPaused modifiers. Consider removing the first one.  Update: Fixed as of commit 290c68fd25a1f2967324948398227684ec834597 in pull request #183.  Duplicate token supply tracking  The NPM token tracks the number of tokens that have been issued. This should be identical to the total supply if the tokens are never burned. Its worth noting that the code base transfers funds to a burner address instead of reducing the supply.  Consider disabling the burn functionality so that the total issued amount does not need to be tracked and updated separately.  Update: Not an issue. The Neptune team stated:  Given that the NPM token and protocol will be deployed on different blockchains, this is the proper approach. Ethereum is the only chain where token burn occurs. The burned tokens are transferred to a specified address on each chain and then bridged back to Ethereum on a regular basis.  Excessive indirection and coupling  We found this audit to be significantly complicated by data storage reference patterns that hinder the ability to reason locally about each functions behavior in isolation. Although we typically focus on explicit vulnerabilities or specific recommendations, we believe it may be helpful to highlight some general patterns and possible alternatives for your consideration. Naturally, any significant refactor should be thoroughly evaluated and tested.  Key construction  The StoreKeyUtil contract has a different function for several supported combinations of data type, operation, number of keys and type of keys. This adds a large amount of boilerplate code. Moreover, not all valid combinations are included, leading to situations where storage keys are sometimes calculated directly and sometimes implicitly specified.  We believe the extra layer of indirection is both complicated and unnecessary, and would be cleaner if storage lookups accepted a generic bytes value (that could be hashed to a bytes32). This could also remove the need for use-case specific multi-dimensional mapping types.  Meaningful names  Some keys are reused for different variables and are distinguished only by the type. For example, NS_COVER_PRODUCT represents whether the product is supported, the product reference, an entry in the covers product array and the active status of the product. It would be clearer to use different constants for different variables or include a human-readable identifier to distinguish them.  global,  cover-specific,  product-specific,  incident-specific and  account-specific variables. These could each be represented by a  variables with the same context.  Constant-specific functions  There are several examples of duplicated functions that differ only by the relevant constant. It would be simpler and cleaner to pass the constant to a generic function. For example, the access control functions could be replaced by a single function that accepts a role constant. Similarly, generic getter functions can be combined so meaningful helper functions can be distinguished.  Incomplete deletion  When finalizing an incident, an unused record is deleted. Additionally, the first disputer is not deleted. Consider updating the deletions accordingly.  Update: Fixed as of commit 113a6b7ff7fff5730cefedd4d35c7c6cd9f65bbf in pull request #186.  Incorrect array size  The getCoverPoolSummaryInternal function creates an array of size 8 but only uses 7 positions. Similarly, the getInfoInternal function creates an array of size 11 but only uses 8 positions.  Consider resizing them accordingly.  Update: Fixed as of commit 1826fa97f1b325d40b0b3446b384dac35074540f in pull request #168 and commit c6b1bb74a299f7c4d6d03484da91e5780fab3faa in pull request #190. The arrays have been replaced with structs.  Misleading comments  Some comments are misleading, and the implementation does not follow the stated intention. For example,  In line 76, it was stated not to reset the first reporter by incident date. However, the first reporter is not saved by incident date, and it is deleted in line 90 of Finalization.sol. Similarly, the commented out lines do not contain the productKey and dont correspond to any saved value.  In line 128 of Protocol.sol, it is said that the protocol needs to be paused when the addMember function is invoked but in line 136, it ensures the protocol must not be paused.  The comments describing the callerMustBeX functions reference the sender rather than the caller parameter.  When initializing the protocol, the burner address must be non-zero but the comment says it isnt necessarily zero.  Consider updating the comments to be aligned with the code implementation.  Update: Fixed as of commit 7d1315614a799ff200f77001aaaaaf91e8ad499a in pull request #189 and 9a3cf2ad7fba096dd5c3cada68b83bf693080baf in pull request #196.  Naming issues hinder code understanding and readability  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  Rename disablePolicy to updateDisablePolicyStatus.  Use timestamp instead of date where relevant throughout the code base.  Rename resolution timestamp to reporting deadline, to distinguish it from the resolution deadline.  Rename incidentHappened to isClaimable.  Rename delgate to delegate.  Product status needs not be incident specific  adding liquidity,  lending out flashloan,  reporting an incident , or  purchasing a cover proceeds.  hashkey depends on an  active incidentDate, and then computes the right key to read the internal status. In particular, in the case of a  normal status, the active  Consider refactoring variables such as ProductStatus that do not need to depend on the incidentDate for its hashkey for clarity and simplicity.  Repeated pause validation  Several functions in the Protocol contract have a whenNotPaused modifier and mustNotBePaused requirement. However, both of these check the pause status of the Protocol contract, so one of them is redundant. Consider removing one of them.  Update: Fixed as of commit 7a84b7a6a750224c9f29b2bdbbea84a65c9fdde3 in pull request #170.  Risks associated with the price oracle  An on-chain Time Weighted Average Price (TWAP) oracle is used to derive the NPM and LP token market prices from a UniswapV2 NPM-stablecoin pool. These prices are then used to calculate the amount of NPM tokens returned when users deposit their LP tokens to the bonding pool.  In general, a TWAP price is known to be rather resistant to single block manipulation. However, it is still subject to the risk of multi-block MEV, of which the switch to Proof of Stake may change its feasibility profile drastically.  As the NPM tokens are locked after bond purchase, there is time for the recovery agent to sweep the fund in case of an oracle price manipulation. We recommend close monitoring of the liquidity depth of the NPM-stablecoin pool to mitigate any oracle risk.  Typos  Throughout the code base, there are some incidences of typographical errors in the comments. For example,  highy should be highly  responsbility should be responsibility  Retuns should be Returns  indicent should be incident  extra as  Update: Fixed as of commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.  Unexplained dead code  The CoverUtilV1 contract contains a function that has been commented out without explanation. Consider removing it from the code base or explaining why it is there.  Unnecessary complex code  The s.getStablecoin() == address(token) == false expression on line 245 of StrategyLibV1.sol can be replaced with s.getStablecoin() != address(token).  Line 272 of CoverLibV1.sol casts the variable of type address to type address. The casting can be avoided.  isProtocolMember is defined both in line 257 of ProtoUtilV1.sol and line 85 of StoreBase.sol.  Unnecessary coupling  recorded against the who address, but the reporter is  set to the message sender. In  both  invocations, the  first disputer.  Similarly, when calculating the future commitment, the number of months to check should depend on the global limit.  Update: Fixed as of commit 63fce22c67f72cf090ffa124784a3d92935e2d66 in pull request #136 and commit f47e959a2f89e29390164257e7dce298442cff11 in pull request #184.  Unused imports  Throughout the code base many imports are unused and could be removed. Some examples are:  Line 5 of ProtoBase.sol  Line 4 of cxTokenFactory.sol  Line 7 of Resolvable.sol  Line 5 of Unstakable.sol  Consider removing unused imports to avoid confusion that could reduce the overall clarity and readability of the code base.  Update: Fixed as of commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#protocol-administrator-needs-to-handle-external-tokens", "labels": ["OpenZeppelin"]}, {"title": "The info parameter might lose information about an IPFS hash", "body": "The info parameter might lose information about an IPFS hash", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#the-info-parameter-might-lose-information-about-an-ipfs-hash", "labels": ["OpenZeppelin"]}, {"title": "Incorrect individual liquidity share", "body": "The calculation of an individuals share of liquidity for a particular cover incorrectly uses values[5] instead of values[4] as the number of PODs. Since this is always zero, the returned share of liquidity will always be zero.  This has no implications within the current code base but would mislead external users that rely on it. Consider using the correct number of PODs in the calculation.  Update: Fixed as of commit 2192646ab5efa95a90521b986c81c05ed04fcd37 in pull request #166.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#incorrect-individual-liquidity-share", "labels": ["OpenZeppelin"]}, {"title": "Variable outside store", "body": "In contrast to most of the code base, the last policy identifier is saved directly in the Policy contract. However, to maintain continuity and prevent conflicts, any new version will need to import the old value.  Consider saving it in the Store contract.  Update: Fixed as of commit 1826fa97f1b325d40b0b3446b384dac35074540f in pull request #168.  Notes & Additional Information  transfer and send calls are no longer considered best practice  When transfer or send calls are used to transfer Ether to an address, they forward only a limited amount of gas. This precludes destination addresses with complex fallback functions. Additionally, given that gas prices for EVM operations are sometimes repriced, code execution on the receiving end of these calls cannot be guaranteed in perpetuity.  There are multiple occurrences throughout the code base where transfer or send is used to transfer Ether. For instance:  On line 41 of StoreBase.sol Ether is transferred via transfer.  On line 19 of WithRecovery.sol Ether is transferred via transfer.  On line 23 of BaseLibV1.sol Ether is transferred via transfer.  Rather than using transfer or send, consider using address.call{value: amount}(\"\") or the sendValue function of the OpenZeppelin Address library to transfer Ether.  Update: Fixed as of commit adf8883628f94a27ae61376e98d112f998029e16 in pull request #187.  Anyone can temporarily DoS a fresh vault  Vaults are deployed by whitelisted cover creators with the addCover function. To prevent someone from unbalancing the POD-to-stablecoin ratio immediately after deployment, the Vault detects unmatched stablecoins and reverts on any attempt to add liquidity which effectively disables the vault.  A recovery agent could retrieve the excess funds to re-enable the contract. Nevertheless, to avoid this scenario, consider adding some liquidity in the same transaction as the deployment. Alternatively, consider tracking the stablecoin balance in a variable to mitigate issues caused by direct transfers.  Commit-Reveal voting  The Governance mechanism allows NPM token holders to vote on whether they believe a reported incident is valid. Typically, the rationale for using voting as an oracle is that token holders, who are incentivized to vote with the majority, will treat the truth as a natural Schelling Point. However, since token holders can review the running total, they may instead simply vote with the majority.  This is commonly mitigated with a commit-reveal voting scheme. However, it is also mitigated by the possibility of a governance administrator overruling the vote. We are just noting the practice for your consideration. If the commit-reveal scheme is adopted, votes that are not revealed should be considered incorrect so that users cannot selectively abstain based on the running total.  Copied in dependencies  Dependencies in the lib directory, including openzeppelin-solidity, are copied in without any reference in .gitmodules. This makes it hard to keep track of the latest versions and easy to accidentally change the code inside.  Consider using forge install OpenZeppelin/openzeppelin-contracts for the latest version of the OpenZeppelin contracts.  Update: Fixed as of commit 80f024fb21389e5d29eff9e79a6d0248c6f61183 in pull request #188.  Docstrings not following NatSpec  Across the code base there are several examples of contracts not consistently following the Ethereum Natural Specification Format (NatSpec). Consider following this specification on everything that is part of the contracts public API.  Some examples include:  Missing NatSpec for productKey at line 151 of PolicyHelperV1.  Discrepancy between addCovers NatSpec in the Cover contract and the ICover interface the interfaces misses NatSpec for 8th and 9th parameters. Consider using @inheritdoc NatSpec tag.  Return variables are documented using @param instead of @return in Vault.getInfo.  Duplicate modifier  The unpause function of the ProtoBase contract has two whenPaused modifiers. Consider removing the first one.  Update: Fixed as of commit 290c68fd25a1f2967324948398227684ec834597 in pull request #183.  Duplicate token supply tracking  The NPM token tracks the number of tokens that have been issued. This should be identical to the total supply if the tokens are never burned. Its worth noting that the code base transfers funds to a burner address instead of reducing the supply.  Consider disabling the burn functionality so that the total issued amount does not need to be tracked and updated separately.  Update: Not an issue. The Neptune team stated:  Given that the NPM token and protocol will be deployed on different blockchains, this is the proper approach. Ethereum is the only chain where token burn occurs. The burned tokens are transferred to a specified address on each chain and then bridged back to Ethereum on a regular basis.  Excessive indirection and coupling  We found this audit to be significantly complicated by data storage reference patterns that hinder the ability to reason locally about each functions behavior in isolation. Although we typically focus on explicit vulnerabilities or specific recommendations, we believe it may be helpful to highlight some general patterns and possible alternatives for your consideration. Naturally, any significant refactor should be thoroughly evaluated and tested.  Key construction  The StoreKeyUtil contract has a different function for several supported combinations of data type, operation, number of keys and type of keys. This adds a large amount of boilerplate code. Moreover, not all valid combinations are included, leading to situations where storage keys are sometimes calculated directly and sometimes implicitly specified.  We believe the extra layer of indirection is both complicated and unnecessary, and would be cleaner if storage lookups accepted a generic bytes value (that could be hashed to a bytes32). This could also remove the need for use-case specific multi-dimensional mapping types.  Meaningful names  Some keys are reused for different variables and are distinguished only by the type. For example, NS_COVER_PRODUCT represents whether the product is supported, the product reference, an entry in the covers product array and the active status of the product. It would be clearer to use different constants for different variables or include a human-readable identifier to distinguish them.  global,  cover-specific,  product-specific,  incident-specific and  account-specific variables. These could each be represented by a  variables with the same context.  Constant-specific functions  There are several examples of duplicated functions that differ only by the relevant constant. It would be simpler and cleaner to pass the constant to a generic function. For example, the access control functions could be replaced by a single function that accepts a role constant. Similarly, generic getter functions can be combined so meaningful helper functions can be distinguished.  Incomplete deletion  When finalizing an incident, an unused record is deleted. Additionally, the first disputer is not deleted. Consider updating the deletions accordingly.  Update: Fixed as of commit 113a6b7ff7fff5730cefedd4d35c7c6cd9f65bbf in pull request #186.  Incorrect array size  The getCoverPoolSummaryInternal function creates an array of size 8 but only uses 7 positions. Similarly, the getInfoInternal function creates an array of size 11 but only uses 8 positions.  Consider resizing them accordingly.  Update: Fixed as of commit 1826fa97f1b325d40b0b3446b384dac35074540f in pull request #168 and commit c6b1bb74a299f7c4d6d03484da91e5780fab3faa in pull request #190. The arrays have been replaced with structs.  Misleading comments  Some comments are misleading, and the implementation does not follow the stated intention. For example,  In line 76, it was stated not to reset the first reporter by incident date. However, the first reporter is not saved by incident date, and it is deleted in line 90 of Finalization.sol. Similarly, the commented out lines do not contain the productKey and dont correspond to any saved value.  In line 128 of Protocol.sol, it is said that the protocol needs to be paused when the addMember function is invoked but in line 136, it ensures the protocol must not be paused.  The comments describing the callerMustBeX functions reference the sender rather than the caller parameter.  When initializing the protocol, the burner address must be non-zero but the comment says it isnt necessarily zero.  Consider updating the comments to be aligned with the code implementation.  Update: Fixed as of commit 7d1315614a799ff200f77001aaaaaf91e8ad499a in pull request #189 and 9a3cf2ad7fba096dd5c3cada68b83bf693080baf in pull request #196.  Naming issues hinder code understanding and readability  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  Rename disablePolicy to updateDisablePolicyStatus.  Use timestamp instead of date where relevant throughout the code base.  Rename resolution timestamp to reporting deadline, to distinguish it from the resolution deadline.  Rename incidentHappened to isClaimable.  Rename delgate to delegate.  Product status needs not be incident specific  adding liquidity,  lending out flashloan,  reporting an incident , or  purchasing a cover proceeds.  hashkey depends on an  active incidentDate, and then computes the right key to read the internal status. In particular, in the case of a  normal status, the active  Consider refactoring variables such as ProductStatus that do not need to depend on the incidentDate for its hashkey for clarity and simplicity.  Repeated pause validation  Several functions in the Protocol contract have a whenNotPaused modifier and mustNotBePaused requirement. However, both of these check the pause status of the Protocol contract, so one of them is redundant. Consider removing one of them.  Update: Fixed as of commit 7a84b7a6a750224c9f29b2bdbbea84a65c9fdde3 in pull request #170.  Risks associated with the price oracle  An on-chain Time Weighted Average Price (TWAP) oracle is used to derive the NPM and LP token market prices from a UniswapV2 NPM-stablecoin pool. These prices are then used to calculate the amount of NPM tokens returned when users deposit their LP tokens to the bonding pool.  In general, a TWAP price is known to be rather resistant to single block manipulation. However, it is still subject to the risk of multi-block MEV, of which the switch to Proof of Stake may change its feasibility profile drastically.  As the NPM tokens are locked after bond purchase, there is time for the recovery agent to sweep the fund in case of an oracle price manipulation. We recommend close monitoring of the liquidity depth of the NPM-stablecoin pool to mitigate any oracle risk.  Typos  Throughout the code base, there are some incidences of typographical errors in the comments. For example,  highy should be highly  responsbility should be responsibility  Retuns should be Returns  indicent should be incident  extra as  Update: Fixed as of commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.  Unexplained dead code  The CoverUtilV1 contract contains a function that has been commented out without explanation. Consider removing it from the code base or explaining why it is there.  Unnecessary complex code  The s.getStablecoin() == address(token) == false expression on line 245 of StrategyLibV1.sol can be replaced with s.getStablecoin() != address(token).  Line 272 of CoverLibV1.sol casts the variable of type address to type address. The casting can be avoided.  isProtocolMember is defined both in line 257 of ProtoUtilV1.sol and line 85 of StoreBase.sol.  Unnecessary coupling  recorded against the who address, but the reporter is  set to the message sender. In  both  invocations, the  first disputer.  Similarly, when calculating the future commitment, the number of months to check should depend on the global limit.  Update: Fixed as of commit 63fce22c67f72cf090ffa124784a3d92935e2d66 in pull request #136 and commit f47e959a2f89e29390164257e7dce298442cff11 in pull request #184.  Unused imports  Throughout the code base many imports are unused and could be removed. Some examples are:  Line 5 of ProtoBase.sol  Line 4 of cxTokenFactory.sol  Line 7 of Resolvable.sol  Line 5 of Unstakable.sol  Consider removing unused imports to avoid confusion that could reduce the overall clarity and readability of the code base.  Update: Fixed as of commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#variable-outside-store", "labels": ["OpenZeppelin"]}, {"title": "reducedFraction does not reduce in the mathematical sense", "body": "reducedFraction does not reduce in the mathematical sense", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#reducedfraction-does-not-reduce-in-the-mathematical-sense", "labels": ["OpenZeppelin"]}, {"title": "weightedAverage calculation might overflow", "body": "weightedAverage calculation might overflow", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#weightedaverage-calculation-might-overflow", "labels": ["OpenZeppelin"]}, {"title": "calcExpDecayRewards is at risk of overflow reversions", "body": "calcExpDecayRewards is at risk of overflow reversions", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#calcexpdecayrewards-is-at-risk-of-overflow-reversions", "labels": ["OpenZeppelin"]}, {"title": "Lack of validation", "body": "Throughout the codebase, there are places where a proper input/output validation is lacking. In particular:  The inverse and fromFraction112 functions in FractionLibrary do not check if they were provided an invalid fraction.  The _mulMod, mulDivC, mulDivF functions in the MathEx library do not check that z in non-zero. In such cases they revert with a Panic, rather than a more helpful error message.  The isInRange and weightedAverage functions in the MathEx library do not check that the input fractions are valid. The latter also does not ensure it is returning a valid fraction.  A lack of validation on user-controlled parameters may result in erroneous or failing transactions that are difficult to debug. This is especially true in the case of libraries that are capable of being reused across different codebases. To avoid this, consider adding input and output validation to address the concerns raised above.  Update: Acknowledged without code changes. The client expressed that the lack of reversion on invalid inputs is intentional. In some cases it is desirable behavior to turn divide by zero inputs into zero outputs. In other cases, error messages will be raised somewhere else along the call chain in practice.  Low Severity", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#lack-of-validation", "labels": ["OpenZeppelin"]}, {"title": "Unbounded number of programs could result in errors", "body": "The programs function loops over a potentially unbounded list of programs/pools.  Relatedly, the pools function requires that all stored values associated with stored pools are first loaded into memory for the call to complete.  In either case, if too many programs are added to the protocol, these functions will run out of gas.  Although neither of these functions are used internally, should the number of programs grow too large, they could be problematic for external contracts that might rely on them.  Consider either adding a pagination mechanism to limit the number of stored values that must be loaded or adding some warning to the documentation about the need to keep the number of programs bounded to some safe level to avoid issues with these functions.  Update: Acknowledged. The client conveyed that simplicity of the external interface was an intentional design choice. If future on-chain usage becomes relevant the respective contract will be upgraded.", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#unbounded-number-of-programs-could-result-in-errors", "labels": ["OpenZeppelin"]}, {"title": "Duplicated code", "body": "The internal logic of the poolTokenAmountToBurn functions in the BNTPool and PoolCollection contracts are essentially duplicates.  Duplicating code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors. Such errors can inadvertently be introduced when functionality changes are not replicated across all instances of code that should be identical.  Rather than duplicating code, consider having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Acknowledged. The flexibility of independent upgrades is prioritized over re-use in this case. Clients response:  If the contracts are used for a while and the shared logic is kept in place without frequent changes, a shared logic component will be created, but for now flexibility is more important than code reusability, especially since these two contracts are very different conceptually.  uint32 times can overflow in the future  Throughout the AutoCompoundingRewards contract, all program start, end, and elapsed times are encoded as uint32 values. In the year 2106, this will be problematic in two ways.  Near the time when unix timestamps will begin to overflow the uint32 type, it will become difficult to create flat programs ending after the unix timestamp overflow event. Specifically, it will not be possible to call createFlatProgram with an endTime that overflows the uint32 type because it will appear to be less than the startTime. This will be a temporary inconvenience, because once the current time overflows the uint32 type it will be possible to create new flat programs as normal again.  The createExpDecayProgram does not expect an endTime input. Instead, a halfLife input parameter is specified. This will make it possible to call createExpDecayProgram even around the time that unix time will overflow the uint32 type. However, if a program is created before the overflow time, then after the overflow time, even if it should be a valid program, it would be treated as inactive and no rewards from the program could be processed. This, in turn, would prevent both processRewards and autoProcessRewards from processing rewards for that program. This would be more problematic and tight packing of the stored programs could make an update to remedy the situation more difficult.  Consider either increasing the bits available to store and evaluating timestamps to something larger than uint32 or adding a warning to the protocol documentation to upgrade the contract well before the overflow time will be reached.  Update: Acknowledged. Clients response:  The contracts are expected to change and evolve and new versions implemented way before the timestamps can overflow (at 2106).  Lack of event emissions after updating state  The following functions do not emit relevant events despite executing state-altering actions:  No event is emitted when the _autoProcessRewardsCount variable is first set during contract initialization. This is inconsistent with the fact that an event is emitted when the same value is updated via the setAutoProcessRewardsCount function.  There is no event emitted when _autoProcessRewardsIndex is updated despite the fact that this value influences the behavior of the external autoProcessRewards function.  In order to facilitate tracking and to notify off-chain clients following the contracts activity, consider emitting events whenever state-changing operations take place.  Update: Partially addressed in commit 5f223b2ff0f1f9fcdd92d89bc2e420c9d984cb5c. An event including the new value of _autoProcessRewardCount is now emitted during contract construction. However, the client considers _autoProcessRewardsIndex an non-public implementation detail which should not emit events upon alteration, despite its role in facilitating monitoring.  enableProgram is overloaded  In the AutoCompoundingRewards contract, the enableProgram function is used to enable or disable a program for a specific pool, depending on the bool status parameter. The function also emits a ProgramEnabled event, even in the instance where the program is being disabled (although the event details contain the correct updated status).  In order to avoid unnecessary confusion and to increase the overall readability of the codebase, consider renaming the function and event to something such as updateProgramStatus to better reflect the actual function operation.  Update: Acknowledged. Clients response:  This was a design decision in order to prioritize ease of consumption (single event) and binary size over readability.  Notes & Additional Information  Confusing use of assert statement  assert statement in the  calcFlatRewards function of the  RewardsMath library checks a condition that is impossible only because of how it is used within the  _tokenAmountToDistribute function. However, given the  To enforce input validation within the calcFlatRewards function, consider changing the assert statement to a require, and providing an error message explaining the validation. Alternatively, consider moving the assert statement into the _tokenAmountToDistribute function to check that the invariant holds in that context.  Update: Remains unaddressed in commit b2224595afab14827ee065cb65a1444d61689fb3. While the documentation of the function improved in commit ce5d2e73b348fcc368157edd70a5e59d043d939d, the function still uses assert to check a condition that is not an invariant.  Unused import  In the AutoCompoundingRewards contract the AccessDenied import is unused.  Consider removing unused import statements to simplify the codebase and increase overall readability.  Update: Fixed as of commit 107b3aa85bc306a0d94705a0bd816e57267bd9f7 in pull request #430.  Missing docstrings  Throughout the codebase there are numerous functions missing or lacking documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Acknowledged. The comments will be added in future versions of the codebase.  Conclusions  1 high and 3 medium severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#duplicated-code", "labels": ["OpenZeppelin"]}, {"title": "uint32 times can overflow in the future", "body": "uint32 times can overflow in the future", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#uint32-times-can-overflow-in-the-future", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emissions after updating state", "body": "The following functions do not emit relevant events despite executing state-altering actions:  No event is emitted when the _autoProcessRewardsCount variable is first set during contract initialization. This is inconsistent with the fact that an event is emitted when the same value is updated via the setAutoProcessRewardsCount function.  There is no event emitted when _autoProcessRewardsIndex is updated despite the fact that this value influences the behavior of the external autoProcessRewards function.  In order to facilitate tracking and to notify off-chain clients following the contracts activity, consider emitting events whenever state-changing operations take place.  Update: Partially addressed in commit 5f223b2ff0f1f9fcdd92d89bc2e420c9d984cb5c. An event including the new value of _autoProcessRewardCount is now emitted during contract construction. However, the client considers _autoProcessRewardsIndex an non-public implementation detail which should not emit events upon alteration, despite its role in facilitating monitoring.  enableProgram is overloaded  In the AutoCompoundingRewards contract, the enableProgram function is used to enable or disable a program for a specific pool, depending on the bool status parameter. The function also emits a ProgramEnabled event, even in the instance where the program is being disabled (although the event details contain the correct updated status).  In order to avoid unnecessary confusion and to increase the overall readability of the codebase, consider renaming the function and event to something such as updateProgramStatus to better reflect the actual function operation.  Update: Acknowledged. Clients response:  This was a design decision in order to prioritize ease of consumption (single event) and binary size over readability.  Notes & Additional Information  Confusing use of assert statement  assert statement in the  calcFlatRewards function of the  RewardsMath library checks a condition that is impossible only because of how it is used within the  _tokenAmountToDistribute function. However, given the  To enforce input validation within the calcFlatRewards function, consider changing the assert statement to a require, and providing an error message explaining the validation. Alternatively, consider moving the assert statement into the _tokenAmountToDistribute function to check that the invariant holds in that context.  Update: Remains unaddressed in commit b2224595afab14827ee065cb65a1444d61689fb3. While the documentation of the function improved in commit ce5d2e73b348fcc368157edd70a5e59d043d939d, the function still uses assert to check a condition that is not an invariant.  Unused import  In the AutoCompoundingRewards contract the AccessDenied import is unused.  Consider removing unused import statements to simplify the codebase and increase overall readability.  Update: Fixed as of commit 107b3aa85bc306a0d94705a0bd816e57267bd9f7 in pull request #430.  Missing docstrings  Throughout the codebase there are numerous functions missing or lacking documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Acknowledged. The comments will be added in future versions of the codebase.  Conclusions  1 high and 3 medium severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#lack-of-event-emissions-after-updating-state", "labels": ["OpenZeppelin"]}, {"title": "enableProgram is overloaded", "body": "enableProgram is overloaded", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#enableprogram-is-overloaded", "labels": ["OpenZeppelin"]}, {"title": "Confusing use of assert statement", "body": "Confusing use of assert statement", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#confusing-use-of-assert-statement", "labels": ["OpenZeppelin"]}, {"title": "Unused import", "body": "In the AutoCompoundingRewards contract the AccessDenied import is unused.  Consider removing unused import statements to simplify the codebase and increase overall readability.  Update: Fixed as of commit 107b3aa85bc306a0d94705a0bd816e57267bd9f7 in pull request #430.", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#unused-import", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Throughout the codebase there are numerous functions missing or lacking documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Acknowledged. The comments will be added in future versions of the codebase.", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "[N01] Multiple Solidity versions in use", "body": "[N01] Multiple Solidity versions in use", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#[n01]-multiple-solidity-versions-in-use", "labels": ["OpenZeppelin"]}, {"title": "Throughout the code base there are different versions of Solidity being used. For example, the\u00a0StakedTokenV1\u00a0contract is specifically using\u00a0version 0.6.12\u00a0while other contracts allow compiling with\u00a0version 0.8.6.", "body": "Throughout the code base there are different versions of Solidity being used. For example, the\u00a0StakedTokenV1\u00a0contract is specifically using\u00a0version 0.6.12\u00a0while other contracts allow compiling with\u00a0version 0.8.6.", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#throughout-the-code-base-there-are-different-versions-of-solidity-being-used.-for-example,-the\u00a0stakedtokenv1\u00a0contract-is-specifically-using\u00a0version-0.6.12\u00a0while-other-contracts-allow-compiling-with\u00a0version-0.8.6.", "labels": ["OpenZeppelin"]}, {"title": "To avoid unexpected behaviors, all contracts in the code base should allow being compiled with the same Solidity version.", "body": "To avoid unexpected behaviors, all contracts in the code base should allow being compiled with the same Solidity version.", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#to-avoid-unexpected-behaviors,-all-contracts-in-the-code-base-should-allow-being-compiled-with-the-same-solidity-version.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Acknowledged.", "body": "Coinbase acknowledges that truncation can occur though has not fixed it as the maximum impact of the truncation would be a failed on-chain transaction and needing to reconfigure the caller.  Notes & Additional Information  [N01] Multiple Solidity versions in use  Throughout the code base there are different versions of Solidity being used. For example, the StakedTokenV1 contract is specifically using version 0.6.12 while other contracts allow compiling with version 0.8.6.  To avoid unexpected behaviors, all contracts in the code base should allow being compiled with the same Solidity version.    Coinbase acknowledges that multiple Solidity versions are being used. This was an intentional decision made to allow battle tested Solidity 0.6.12 USDC code reuse for both the FiatTokenProxy and StakedTokenV1 smart contracts. Weve used Solidity 0.8.6 for our new contracts.  [N02] Naming issue  In order to improve the readability, consider changing the name of the allowanceCurrent function on line 123 of RateLimit contract to currentAllowance to make the name coherent with the estimatedAllowance function on line 111 of RateLimit contract.  Update: Fixed as of commit e676460 in PR #1.  Conclusions  No critical or high severity issues were found in the codebase. Several minor vulnerabilities have been found and recommendations and fixes have been suggested.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#update:\u00a0acknowledged.", "labels": ["OpenZeppelin"]}, {"title": "Coinbase acknowledges that multiple Solidity versions are being used. This was an intentional decision made to allow battle tested Solidity 0.6.12 USDC code reuse for both the\u00a0FiatTokenProxy\u00a0and\u00a0StakedTokenV1\u00a0smart contracts. We\u2019ve used Solidity 0.8.6 for our new contracts.", "body": "Coinbase acknowledges that multiple Solidity versions are being used. This was an intentional decision made to allow battle tested Solidity 0.6.12 USDC code reuse for both the\u00a0FiatTokenProxy\u00a0and\u00a0StakedTokenV1\u00a0smart contracts. We\u2019ve used Solidity 0.8.6 for our new contracts.", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#coinbase-acknowledges-that-multiple-solidity-versions-are-being-used.-this-was-an-intentional-decision-made-to-allow-battle-tested-solidity-0.6.12-usdc-code-reuse-for-both-the\u00a0fiattokenproxy\u00a0and\u00a0stakedtokenv1\u00a0smart-contracts.-we\u2019ve-used-solidity-0.8.6-for-our-new-contracts.", "labels": ["OpenZeppelin"]}, {"title": "[N02] Naming issue", "body": "[N02] Naming issue", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#[n02]-naming-issue", "labels": ["OpenZeppelin"]}, {"title": "In order to improve the readability, consider changing the name of the\u00a0allowanceCurrent\u00a0function on line 123 of\u00a0RateLimit\u00a0contract to\u00a0currentAllowance\u00a0to make the name coherent with the\u00a0estimatedAllowance\u00a0function on line 111 of\u00a0RateLimit\u00a0contract.", "body": "In order to improve the readability, consider changing the name of the\u00a0allowanceCurrent\u00a0function on line 123 of\u00a0RateLimit\u00a0contract to\u00a0currentAllowance\u00a0to make the name coherent with the\u00a0estimatedAllowance\u00a0function on line 111 of\u00a0RateLimit\u00a0contract.", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#in-order-to-improve-the-readability,-consider-changing-the-name-of-the\u00a0allowancecurrent\u00a0function-on-line-123-of\u00a0ratelimit\u00a0contract-to\u00a0currentallowance\u00a0to-make-the-name-coherent-with-the\u00a0estimatedallowance\u00a0function-on-line-111-of\u00a0ratelimit\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0e676460\u00a0in PR #1.", "body": "Update:\u00a0Fixed as of commit\u00a0e676460\u00a0in PR #1.", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#update:\u00a0fixed-as-of-commit\u00a0e676460\u00a0in-pr-#1.", "labels": ["OpenZeppelin"]}, {"title": "Misconfiguration could lead to blocking bids", "body": "In the _processBid function of the AuctionBase contract the time details of the auction are checked. These times are:  extendableUntil  The time until an auction may be extended through late bids.  expirationTime  The time until an asset must be transferred. Otherwise, the payment can be refunded by the user afterwards.  The requirement of line 118 checks the following:  Here, the _SAFETY_TRANSFER_WINDOW is a constant value of two hours. Therefore, the auction must expire after the longest possible duration, including enough time to transfer the asset. Further, substituting the values of extendableUntil and expirationTime and simplifying the inequation we receive:  Both values, universeExtendableBy() and _paymentWindow, are configurable by the contract owner. In the case that the system accidentally is configured to never satisfy the above condition, the requirement would always fail and so would calls to bid. No bids on new auctions would be processed, shutting down all upcoming auctions.  Consider moving this requirement and adding additional checks when setting these configurations.  Update: Fixed with commit ef597b1 of PR#16.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#misconfiguration-could-lead-to-blocking-bids", "labels": ["OpenZeppelin"]}, {"title": "Previous operator power is not revoked", "body": "_processBuyNow and bid action within  _processBid, the payment details are saved on-chain using the  In the case of an operator change, after the payment details have been written on-chain, there is no way to revoke the power of an operator. This means, if an operators key was compromised and that operator is saved as the operator in charge of a listing in the _payments mapping, they could still finalize a payment or auction with an untruthful transferResult.wasSuccessful outcome even after changing the current operator for the universe.  For instance, after the first bid on an auction and a consecutive operator change, the previous operator can bid and win the auction to then get the asset transferred. But during finalization they are able to sign that the asset transfer was not successful to also get the refund. Similarly, if the operator knows they are exchanged in the future, they can buy an asset or win an auction to then maliciously finalize the payment the same way.  Consider revoking the power of any previous operator, e.g., by fetching the current operator through the universeOperator function inside the _finalize function. The returned address can then be checked against the provided signature to assure that only the current operator can finalize a payment. In addition, remove the operator from the Payments struct.  Update: Fixed with commit ff4ff3b of PR#15.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#previous-operator-power-is-not-revoked", "labels": ["OpenZeppelin"]}, {"title": "Seller\u2019s signature not required", "body": "In this protocol, listing an asset is simply having the operator sign either a BidInput or a BuyNowInput struct. From there, once a buyer either places a bid or completes a buy-it-now listing, the struct will be saved on-chain. When processing either type of struct, the only requirements around signing is a valid signature from the operator.  Nowhere in the process is it required for the seller to signal that they intend to sell their asset. Requiring the sellers signature over the listing would ensure that the origin of the listing was the seller itself. If a signature was not required, users could create phony listings that will never complete.  Since the seller is required to actually transfer an asset at the end of a listing, the worst situation that should arise would be a large number of listings that do not complete after they end, resulting in users funds being locked for small periods of time.  Consider requiring the sellers signature along with the operators when listing assets.  Update: Partially fixed with commit 097fa4c of PR#18. Seller validation is done with a signature over the paymentId, which does not remove the need for trust between operator and seller. However, the upgradability allowed via the EIP712 implementation contract allows for future updates which remedy this.  The Freeverse team states:  Following your suggestion, we decided to start, at least, with what we already have, and require the already-existing L2 sellerSignature to be provided to the payments contract. The data that makes paymentId is available off chain.  However, we also agreed with your point and decided that itll be nicer to move to a pattern where the seller signature is much closer to the others, so that the payments contract can verify the sellers intention pre-digest.  Thats why the PR intentionally provides an interface for verifySellerSignature where future upgrades of the verification contract (via the setEIP712 method) can include implementations where the verification of the sellerSig makes use of the entire BuyNow/Auction input struct, as suggested. (note that verifySellerSignature already takes as inputs the entire bidInput/buynowInput struct).  Since changing the L2 current signature will take time (we first need to fill in details such as the not 1-to-1 mapping, and upgrades require coordination with nodes, etc.), we plan to do it carefully, and incorporate the suggestion using the setEIP712 method in due time.  Low Severity", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#seller\u2019s-signature-not-required", "labels": ["OpenZeppelin"]}, {"title": "Events lack previous values", "body": "There are a couple instances of events which are emitted when the state of the contract is changed. Among these events, some only record the new value and omit recording the previous value.  Here are instances of this issue:  event EIP712  event PaymentWindow  event OnlyUserCanWithdraw  event DefaultFeesCollector  event UniverseFeesCollector  event DefaultOperator  event UniverseOperator  event DefaultAuctionConfig  event UniverseAuctionConfig  When using events to record state changes, it is recommended to record the previous value as well to document the entirety of the change. Consider including the previous state to any event that changes the state of the contract.  Update: Fixed with commit 6e02cc3 of PR#14.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#events-lack-previous-values", "labels": ["OpenZeppelin"]}, {"title": "Loose restriction on fees", "body": "Currently, fees on buys and won auctions are not restricted and can be arbitrarily set for up to 100% via the assertBidInputsOK function in the BuyNowBase and AuctionBase contracts. Such feeBPS value is given through the input data that is signed by the operator.  Despite the trust assumption towards the operator, consider limiting the fee to a lower percentage or setting it on a contract level similar to the _paymentWindow. By doing so it is less likely that the seller gets less funds than intended due to an unexpectedly high fee.  Update: Fixed with commit bfa52af of PR#13.  Withdraw with finalBalance adds unnecessary complexity  BuyNowBase contract, the  _withdrawAmount function takes three arguments: The  Consider updating the balance by subtracting the withdrawn amount like _balanceOf[recipient] -= amount; in order to simplify the function.  Update: Fixed with commit d9bd95a of PR#12.  _acceptedCurrency could be misleading  Due to the support of ERC20s and blockchain native currencies, payments are settled through the currency indicated by the _acceptedCurrency variable that is set during deployment in the BuyNowBase constructor.  Since this variable is passed in rather than obtained via calling the name or symbol functions of the ERC20s, it is possible to have a different underlying currency than the one claimed to be supported, possibly resulting in an uncareful user accidentally paying an unexpected price.  Consider implementing the _acceptedCurrency through the symbol or name view function of the underlying ERC20 contract with a fallback to the native currency, as well as maintaining a manual method for cases of ERC20s that do not support those functions.  Update: Fixed with commit bd26283 of PR#17.  Gas optimization  _processBid function of the  AuctionBase contract, the  assertBidInputsOk function, where the inputs are sent via  IAuctionBase interface.  Consider changing both locations from memory to calldata to save gas.  In the assertBidInputsOk function of the AuctionBase contract, the bidInput requirements are checked. These checks include, whether the bidInput.deadline is met and if the bidInput.seller should be registered. Further checks are based on the state of a payment that is fetched from the state of the blockchain.  Consider moving line 229, to line 240 to save some gas getting the payment state if one of the two mentioned checks fail.  Update: Fixed with commit 00705cc of PR#11.  Inaccurate revert string  The withdrawTo function will revert with the message tx sender not authorized to withdraw on recipients behalf in the case that the given recipient is set to false in the onlyUserCanWithdraw mapping.  This function should not revert if the passed in recipient address is the same as the address calling the function.  Consider updating the logic to never revert when a user attempts to withdraw their own funds with the withdrawTo function.  Update: Fixed with commit b5db284 of PR#10.  Redundant check of unused and signed data  assertBidInputsOk function of the  AuctionBase contract, incoming bid data is checked and verified based on the state of the auction. In the case of  Both checks are redundant for two reasons:  The provided call values bidInput.feeBPS and bidInput.endsAt are not being used.  The operator signed these values so they are expected to match. This is contradictory and undermines the given strong trust assumption.  The checks are for user experience only, mainly to guarantee on a contract level that the user does not provide different values than the initial data. This could lead to a user paying a different fee than expected.  Consider moving these checks off-chain to save some gas and simplify the code.  Update: Fixed with commit 715f28a of PR#9.  Notes & Additional Information  Inconsistent buyer terminology  Throughout the codebase, there are two terms for the user who wants to acquire an asset: buyer and payer.  Consider sticking to the more frequent term buyer to be more explicit and precise about the involved roles.  Update: Fixed with commit 345c3c9 of PR#7.  Mismatch between documentation and implementation  In the AuctionBase contract, the _processBid function is documented to take parameter bidInput first and operator second, while the parameters are ordered the other way around in the actual function.  Consider swapping the order of the parameters in the documentation to match the implementation.  Update: Fixed with commit f6a2da5 of PR#5.  Revert strings lack explicitness  Throughout the codebase, the revert strings could be more explicit by following the pattern of \"<Contract-name>::<function-name>: <message>.  Consider updating the revert strings to know exactly where a transaction fails and ease debugging.  Update: Fixed with commit 9e604c1 of PR#4.  Typographical errors  During the audit of the codebase, some typographical errors were identified. For instance:  msg.sender must the the recipient should be msg.sender must be the recipient in lines 209 and 234 of IBuyNowBase.  curretEndsAt should be currentEndsAt in line 173 of AuctionBase.  exisiting should be existing in line 40 and 57 of IAuctionERC20.  While the funds provided can by less than the bid amount should be While the funds provided can be less than the bid amount in line 46 of AuctionNative.  Consider correcting above errors and any other typographical errors throughout the codebase to guarantee explicitness and correctness in the documentation.  Update: Fixed with commit dab036d of PR#3 and commit 0543d30 of PR#19.  Unintuitive naming of withdrawTo  The withdrawTo function of the BuyNowBase contract enables users to withdraw funds of another user on their behalf. For example, user A calls the contract so the funds of user B get withdrawn to user B.  Unfortunately, the naming of withdrawTo is rather unintuitive as it suggests that the funds are withdrawn from user A to user B, which could lead to confusion and unexpected reverts.  Consider renaming the function to relayedWithdraw or withdrawOnBehalfOf to better match the naming with the implementation.  Update: Fixed with commit 56b6bb0 of PR#2.  Conclusion  The code of the Freeverse team is clean, thus no major issues were found. The use of simple and self contained functions and contracts really contributed to this outcome. We found some lower severity issues and suggested some best practices that could further contribute to the overall health of the codebase. We also communicated some architectural concerns, which were acknowledged, but unchanged. We enjoyed working with Freeverse as they provided thorough explanations for any questions that we had.  Appendix  Architectural Recommendation  The current design of the payments contracts plans on having one AuctionERC20 (including BuyNowERC20) contract per supported currency. These contracts allow the contract owner to set universe specific operators and auction configurations. This managing capability is fully coupled to that contract, so as soon as a new currency is supported, the whole setup of a universe would have to be reapplied to the new contract. While the design is simple in favor of readability and security, it does not scale very well.  It was suggested to decouple the managing functionality from the contract or to introduce some logic that supports multiple currencies from one contract. The concern was acknowledged by the Freeverse team.  Monitoring Recommendation  Due to the strong trust assumption towards the contract owner and operator role, we recommend implementing monitoring for all sensitive actions. For instance, to look out for suspicious inputs of the following functions:  BuyNowERC20.buyNow  BuyNowERC20.relayedBuyNow  BuyNowNative.buyNow  AuctionERC20.bid  AuctionERC20.relayedBid  AuctionNative.bid  Suspicious activity could include an unusually high amount or feeBPS or repetitively selling to the same seller. The following functions are also dependent on operator signatures:  BuyNowBase.finalize  BuyNowBase.finalizeAndWithdraw  Their transferResult input could be manipulated by the operator to maliciously claim that an asset was successfully traded when it wasnt. Thus, the input could be checked against off-chain data to verify the correctness of the provided data. Any suspicious activity could be an indication that the operator might be compromised. Further, all functions that are maintainable by the contract owner should be monitored, to also keep track of operator and configuration changes. The affected functions are listed under Trust Assumptions.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#loose-restriction-on-fees", "labels": ["OpenZeppelin"]}, {"title": "Withdraw with finalBalance adds unnecessary complexity", "body": "Withdraw with finalBalance adds unnecessary complexity", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#withdraw-with-finalbalance-adds-unnecessary-complexity", "labels": ["OpenZeppelin"]}, {"title": "_acceptedCurrency could be misleading", "body": "_acceptedCurrency could be misleading", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#_acceptedcurrency-could-be-misleading", "labels": ["OpenZeppelin"]}, {"title": "Gas optimization", "body": "_processBid function of the  AuctionBase contract, the  assertBidInputsOk function, where the inputs are sent via  IAuctionBase interface.  Consider changing both locations from memory to calldata to save gas.  In the assertBidInputsOk function of the AuctionBase contract, the bidInput requirements are checked. These checks include, whether the bidInput.deadline is met and if the bidInput.seller should be registered. Further checks are based on the state of a payment that is fetched from the state of the blockchain.  Consider moving line 229, to line 240 to save some gas getting the payment state if one of the two mentioned checks fail.  Update: Fixed with commit 00705cc of PR#11.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#gas-optimization", "labels": ["OpenZeppelin"]}, {"title": "Inaccurate revert string", "body": "The withdrawTo function will revert with the message tx sender not authorized to withdraw on recipients behalf in the case that the given recipient is set to false in the onlyUserCanWithdraw mapping.  This function should not revert if the passed in recipient address is the same as the address calling the function.  Consider updating the logic to never revert when a user attempts to withdraw their own funds with the withdrawTo function.  Update: Fixed with commit b5db284 of PR#10.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#inaccurate-revert-string", "labels": ["OpenZeppelin"]}, {"title": "Redundant check of unused and signed data", "body": "assertBidInputsOk function of the  AuctionBase contract, incoming bid data is checked and verified based on the state of the auction. In the case of  Both checks are redundant for two reasons:  The provided call values bidInput.feeBPS and bidInput.endsAt are not being used.  The operator signed these values so they are expected to match. This is contradictory and undermines the given strong trust assumption.  The checks are for user experience only, mainly to guarantee on a contract level that the user does not provide different values than the initial data. This could lead to a user paying a different fee than expected.  Consider moving these checks off-chain to save some gas and simplify the code.  Update: Fixed with commit 715f28a of PR#9.  Notes & Additional Information  Inconsistent buyer terminology  Throughout the codebase, there are two terms for the user who wants to acquire an asset: buyer and payer.  Consider sticking to the more frequent term buyer to be more explicit and precise about the involved roles.  Update: Fixed with commit 345c3c9 of PR#7.  Mismatch between documentation and implementation  In the AuctionBase contract, the _processBid function is documented to take parameter bidInput first and operator second, while the parameters are ordered the other way around in the actual function.  Consider swapping the order of the parameters in the documentation to match the implementation.  Update: Fixed with commit f6a2da5 of PR#5.  Revert strings lack explicitness  Throughout the codebase, the revert strings could be more explicit by following the pattern of \"<Contract-name>::<function-name>: <message>.  Consider updating the revert strings to know exactly where a transaction fails and ease debugging.  Update: Fixed with commit 9e604c1 of PR#4.  Typographical errors  During the audit of the codebase, some typographical errors were identified. For instance:  msg.sender must the the recipient should be msg.sender must be the recipient in lines 209 and 234 of IBuyNowBase.  curretEndsAt should be currentEndsAt in line 173 of AuctionBase.  exisiting should be existing in line 40 and 57 of IAuctionERC20.  While the funds provided can by less than the bid amount should be While the funds provided can be less than the bid amount in line 46 of AuctionNative.  Consider correcting above errors and any other typographical errors throughout the codebase to guarantee explicitness and correctness in the documentation.  Update: Fixed with commit dab036d of PR#3 and commit 0543d30 of PR#19.  Unintuitive naming of withdrawTo  The withdrawTo function of the BuyNowBase contract enables users to withdraw funds of another user on their behalf. For example, user A calls the contract so the funds of user B get withdrawn to user B.  Unfortunately, the naming of withdrawTo is rather unintuitive as it suggests that the funds are withdrawn from user A to user B, which could lead to confusion and unexpected reverts.  Consider renaming the function to relayedWithdraw or withdrawOnBehalfOf to better match the naming with the implementation.  Update: Fixed with commit 56b6bb0 of PR#2.  Conclusion  The code of the Freeverse team is clean, thus no major issues were found. The use of simple and self contained functions and contracts really contributed to this outcome. We found some lower severity issues and suggested some best practices that could further contribute to the overall health of the codebase. We also communicated some architectural concerns, which were acknowledged, but unchanged. We enjoyed working with Freeverse as they provided thorough explanations for any questions that we had.  Appendix  Architectural Recommendation  The current design of the payments contracts plans on having one AuctionERC20 (including BuyNowERC20) contract per supported currency. These contracts allow the contract owner to set universe specific operators and auction configurations. This managing capability is fully coupled to that contract, so as soon as a new currency is supported, the whole setup of a universe would have to be reapplied to the new contract. While the design is simple in favor of readability and security, it does not scale very well.  It was suggested to decouple the managing functionality from the contract or to introduce some logic that supports multiple currencies from one contract. The concern was acknowledged by the Freeverse team.  Monitoring Recommendation  Due to the strong trust assumption towards the contract owner and operator role, we recommend implementing monitoring for all sensitive actions. For instance, to look out for suspicious inputs of the following functions:  BuyNowERC20.buyNow  BuyNowERC20.relayedBuyNow  BuyNowNative.buyNow  AuctionERC20.bid  AuctionERC20.relayedBid  AuctionNative.bid  Suspicious activity could include an unusually high amount or feeBPS or repetitively selling to the same seller. The following functions are also dependent on operator signatures:  BuyNowBase.finalize  BuyNowBase.finalizeAndWithdraw  Their transferResult input could be manipulated by the operator to maliciously claim that an asset was successfully traded when it wasnt. Thus, the input could be checked against off-chain data to verify the correctness of the provided data. Any suspicious activity could be an indication that the operator might be compromised. Further, all functions that are maintainable by the contract owner should be monitored, to also keep track of operator and configuration changes. The affected functions are listed under Trust Assumptions.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#redundant-check-of-unused-and-signed-data", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent buyer terminology", "body": "Inconsistent buyer terminology", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#inconsistent-buyer-terminology", "labels": ["OpenZeppelin"]}, {"title": "Mismatch between documentation and implementation", "body": "In the AuctionBase contract, the _processBid function is documented to take parameter bidInput first and operator second, while the parameters are ordered the other way around in the actual function.  Consider swapping the order of the parameters in the documentation to match the implementation.  Update: Fixed with commit f6a2da5 of PR#5.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#mismatch-between-documentation-and-implementation", "labels": ["OpenZeppelin"]}, {"title": "Revert strings lack explicitness", "body": "Throughout the codebase, the revert strings could be more explicit by following the pattern of \"<Contract-name>::<function-name>: <message>.  Consider updating the revert strings to know exactly where a transaction fails and ease debugging.  Update: Fixed with commit 9e604c1 of PR#4.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#revert-strings-lack-explicitness", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "During the audit of the codebase, some typographical errors were identified. For instance:  msg.sender must the the recipient should be msg.sender must be the recipient in lines 209 and 234 of IBuyNowBase.  curretEndsAt should be currentEndsAt in line 173 of AuctionBase.  exisiting should be existing in line 40 and 57 of IAuctionERC20.  While the funds provided can by less than the bid amount should be While the funds provided can be less than the bid amount in line 46 of AuctionNative.  Consider correcting above errors and any other typographical errors throughout the codebase to guarantee explicitness and correctness in the documentation.  Update: Fixed with commit dab036d of PR#3 and commit 0543d30 of PR#19.  Unintuitive naming of withdrawTo  The withdrawTo function of the BuyNowBase contract enables users to withdraw funds of another user on their behalf. For example, user A calls the contract so the funds of user B get withdrawn to user B.  Unfortunately, the naming of withdrawTo is rather unintuitive as it suggests that the funds are withdrawn from user A to user B, which could lead to confusion and unexpected reverts.  Consider renaming the function to relayedWithdraw or withdrawOnBehalfOf to better match the naming with the implementation.  Update: Fixed with commit 56b6bb0 of PR#2.  Conclusion  The code of the Freeverse team is clean, thus no major issues were found. The use of simple and self contained functions and contracts really contributed to this outcome. We found some lower severity issues and suggested some best practices that could further contribute to the overall health of the codebase. We also communicated some architectural concerns, which were acknowledged, but unchanged. We enjoyed working with Freeverse as they provided thorough explanations for any questions that we had.  Appendix  Architectural Recommendation  The current design of the payments contracts plans on having one AuctionERC20 (including BuyNowERC20) contract per supported currency. These contracts allow the contract owner to set universe specific operators and auction configurations. This managing capability is fully coupled to that contract, so as soon as a new currency is supported, the whole setup of a universe would have to be reapplied to the new contract. While the design is simple in favor of readability and security, it does not scale very well.  It was suggested to decouple the managing functionality from the contract or to introduce some logic that supports multiple currencies from one contract. The concern was acknowledged by the Freeverse team.  Monitoring Recommendation  Due to the strong trust assumption towards the contract owner and operator role, we recommend implementing monitoring for all sensitive actions. For instance, to look out for suspicious inputs of the following functions:  BuyNowERC20.buyNow  BuyNowERC20.relayedBuyNow  BuyNowNative.buyNow  AuctionERC20.bid  AuctionERC20.relayedBid  AuctionNative.bid  Suspicious activity could include an unusually high amount or feeBPS or repetitively selling to the same seller. The following functions are also dependent on operator signatures:  BuyNowBase.finalize  BuyNowBase.finalizeAndWithdraw  Their transferResult input could be manipulated by the operator to maliciously claim that an asset was successfully traded when it wasnt. Thus, the input could be checked against off-chain data to verify the correctness of the provided data. Any suspicious activity could be an indication that the operator might be compromised. Further, all functions that are maintainable by the contract owner should be monitored, to also keep track of operator and configuration changes. The affected functions are listed under Trust Assumptions.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unintuitive naming of withdrawTo", "body": "Unintuitive naming of withdrawTo", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#unintuitive-naming-of-withdrawto", "labels": ["OpenZeppelin"]}, {"title": "Anyone can prevent stakers from getting their rewards", "body": "The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any stakedToken at all were actively being staked. Any stakedToken already in the contract would be locked.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input.  Update: Fixed as of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull request #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Low Severity  Incomplete and unindexed events  Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#anyone-can-prevent-stakers-from-getting-their-rewards", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0recoverErc20\u00a0function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the\u00a0AcceleratingDistributor\u00a0contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the\u00a0AcceleratingDistributor\u00a0contract to the owner of\u00a0AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are\u00a0stakedTokens that have already been initialized in the system.", "body": "The\u00a0recoverErc20\u00a0function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the\u00a0AcceleratingDistributor\u00a0contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the\u00a0AcceleratingDistributor\u00a0contract to the owner of\u00a0AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are\u00a0stakedTokens that have already been initialized in the system.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0recovererc20\u00a0function-is-meant-to-facilitate-the-recovery-of-any-erc20-tokens-that-may-be-mistakenly-sent-to-the\u00a0acceleratingdistributor\u00a0contract.-as-this-is-a-public-function-with-no-modifiers,-anyone-can-call-this-function-to-transfer-an-erc20-token-from-the\u00a0acceleratingdistributor\u00a0contract-to-the-owner-of\u00a0acceleratingdistributor.-the-only-erc20-tokens-that-are-explicitly-disallowed-from-being-recovered-are\u00a0stakedtokens-that-have-already-been-initialized-in-the-system.", "labels": ["OpenZeppelin"]}, {"title": "However, it is currently possible to recover the ERC20\u00a0rewardToken\u00a0using the\u00a0recoverErc20\u00a0function. Doing so would\u00a0transfer some specified\u00a0amount\u00a0of\u00a0rewardToken\u00a0from the\u00a0AcceleratingDistributor\u00a0contract to the contract\u2019s owner. This would, subsequently, prevent stakers from being able to access their rewards because\u00a0AcceleratingDistributor\u00a0could be left with an insufficient balance of\u00a0rewardTokens.", "body": "However, it is currently possible to recover the ERC20\u00a0rewardToken\u00a0using the\u00a0recoverErc20\u00a0function. Doing so would\u00a0transfer some specified\u00a0amount\u00a0of\u00a0rewardToken\u00a0from the\u00a0AcceleratingDistributor\u00a0contract to the contract\u2019s owner. This would, subsequently, prevent stakers from being able to access their rewards because\u00a0AcceleratingDistributor\u00a0could be left with an insufficient balance of\u00a0rewardTokens.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#however,-it-is-currently-possible-to-recover-the-erc20\u00a0rewardtoken\u00a0using-the\u00a0recovererc20\u00a0function.-doing-so-would\u00a0transfer-some-specified\u00a0amount\u00a0of\u00a0rewardtoken\u00a0from-the\u00a0acceleratingdistributor\u00a0contract-to-the-contract\u2019s-owner.-this-would,-subsequently,-prevent-stakers-from-being-able-to-access-their-rewards-because\u00a0acceleratingdistributor\u00a0could-be-left-with-an-insufficient-balance-of\u00a0rewardtokens.", "labels": ["OpenZeppelin"]}, {"title": "Even if the owner were to send\u00a0rewardTokens back to the\u00a0AcceleratingDistributor\u00a0contract, a malicious actor could immediately transfer all of the\u00a0rewardTokens\u00a0back to the owner. Redeployment would be necessary to fix the issue.", "body": "Even if the owner were to send\u00a0rewardTokens back to the\u00a0AcceleratingDistributor\u00a0contract, a malicious actor could immediately transfer all of the\u00a0rewardTokens\u00a0back to the owner. Redeployment would be necessary to fix the issue.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#even-if-the-owner-were-to-send\u00a0rewardtokens-back-to-the\u00a0acceleratingdistributor\u00a0contract,-a-malicious-actor-could-immediately-transfer-all-of-the\u00a0rewardtokens\u00a0back-to-the-owner.-redeployment-would-be-necessary-to-fix-the-issue.", "labels": ["OpenZeppelin"]}, {"title": "Consider disallowing recovery of the\u00a0rewardToken\u00a0within the\u00a0recoverErc20\u00a0function.", "body": "Consider disallowing recovery of the\u00a0rewardToken\u00a0within the\u00a0recoverErc20\u00a0function.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#consider-disallowing-recovery-of-the\u00a0rewardtoken\u00a0within-the\u00a0recovererc20\u00a0function.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0bcdabc06ca6d789b95c5b26d23f48dab8bfad277\u00a0in\u00a0pull request #5.", "body": "Update:\u00a0Fixed as of commit\u00a0bcdabc06ca6d789b95c5b26d23f48dab8bfad277\u00a0in\u00a0pull request #5.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a0bcdabc06ca6d789b95c5b26d23f48dab8bfad277\u00a0in\u00a0pull-request-#5.", "labels": ["OpenZeppelin"]}, {"title": "Medium Severity", "body": "Medium Severity", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#medium-severity", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation", "body": "The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any stakedToken at all were actively being staked. Any stakedToken already in the contract would be locked.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input.  Update: Fixed as of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull request #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Low Severity  Incomplete and unindexed events  Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "The codebase generally lacks sufficient input validation.", "body": "The codebase generally lacks sufficient input validation.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-codebase-generally-lacks-sufficient-input-validation.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0AcceleratingDistributor\u00a0contract, the\u00a0enableStaking\u00a0function allows the contract owner to configure several parameters associated with a\u00a0stakedToken. Several of these parameters have no input checking. Specifically:", "body": "In the\u00a0AcceleratingDistributor\u00a0contract, the\u00a0enableStaking\u00a0function allows the contract owner to configure several parameters associated with a\u00a0stakedToken. Several of these parameters have no input checking. Specifically:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#in-the\u00a0acceleratingdistributor\u00a0contract,-the\u00a0enablestaking\u00a0function-allows-the-contract-owner-to-configure-several-parameters-associated-with-a\u00a0stakedtoken.-several-of-these-parameters-have-no-input-checking.-specifically:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0maxMultiplier\u00a0parameter has no upper or lower bound.", "body": "The\u00a0maxMultiplier\u00a0parameter has no upper or lower bound.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0maxmultiplier\u00a0parameter-has-no-upper-or-lower-bound.", "labels": ["OpenZeppelin"]}, {"title": "It should be restricted to being larger than the \u201cbase multiplier\u201d of\u00a01e18, or else it can lead to users\u2019 staking rewards decreasing over time rather than increasing.", "body": "It should be restricted to being larger than the \u201cbase multiplier\u201d of\u00a01e18, or else it can lead to users\u2019 staking rewards decreasing over time rather than increasing.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#it-should-be-restricted-to-being-larger-than-the-\u201cbase-multiplier\u201d-of\u00a01e18,-or-else-it-can-lead-to-users\u2019-staking-rewards-decreasing-over-time-rather-than-increasing.", "labels": ["OpenZeppelin"]}, {"title": "It should also have an upper bound, because if it were to be set to some very large value it could cause the\u00a0getUserRewardMultiplier\u00a0function to\u00a0revert on overflow. This could, in turn, cause calls to the\u00a0getOutstandingRewards\u00a0and\u00a0_updateReward\u00a0functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the\u00a0enableStaking\u00a0function to update to a more reasonable\u00a0maxMultiplier.", "body": "It should also have an upper bound, because if it were to be set to some very large value it could cause the\u00a0getUserRewardMultiplier\u00a0function to\u00a0revert on overflow. This could, in turn, cause calls to the\u00a0getOutstandingRewards\u00a0and\u00a0_updateReward\u00a0functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the\u00a0enableStaking\u00a0function to update to a more reasonable\u00a0maxMultiplier.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#it-should-also-have-an-upper-bound,-because-if-it-were-to-be-set-to-some-very-large-value-it-could-cause-the\u00a0getuserrewardmultiplier\u00a0function-to\u00a0revert-on-overflow.-this-could,-in-turn,-cause-calls-to-the\u00a0getoutstandingrewards\u00a0and\u00a0_updatereward\u00a0functions-to-revert.-this-would-interfere-with-the-normal-operation-of-the-system.-however,-it-could-be-fixed-by-the-contract-owner-using-the\u00a0enablestaking\u00a0function-to-update-to-a-more-reasonable\u00a0maxmultiplier.", "labels": ["OpenZeppelin"]}, {"title": "Similarly, the\u00a0secondsToMaxMultiplier\u00a0parameter has no lower bound. If allowed to be zero then\u00a0getUserRewardMultiplier\u00a0could revert due to\u00a0division by zero. This could cause the\u00a0getOutstandingRewards\u00a0and\u00a0_updateReward\u00a0functions to revert as outlined above. The contract owner could put the system back into a stable state by making\u00a0secondsToMaxMultiplier\u00a0non-zero.", "body": "Similarly, the\u00a0secondsToMaxMultiplier\u00a0parameter has no lower bound. If allowed to be zero then\u00a0getUserRewardMultiplier\u00a0could revert due to\u00a0division by zero. This could cause the\u00a0getOutstandingRewards\u00a0and\u00a0_updateReward\u00a0functions to revert as outlined above. The contract owner could put the system back into a stable state by making\u00a0secondsToMaxMultiplier\u00a0non-zero.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#similarly,-the\u00a0secondstomaxmultiplier\u00a0parameter-has-no-lower-bound.-if-allowed-to-be-zero-then\u00a0getuserrewardmultiplier\u00a0could-revert-due-to\u00a0division-by-zero.-this-could-cause-the\u00a0getoutstandingrewards\u00a0and\u00a0_updatereward\u00a0functions-to-revert-as-outlined-above.-the-contract-owner-could-put-the-system-back-into-a-stable-state-by-making\u00a0secondstomaxmultiplier\u00a0non-zero.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0baseEmissionRate\u00a0parameter has no upper bound. If set too high then, as soon as\u00a0stakingToken.cumulativeStaked\u00a0were some non-zero value, the\u00a0baseRewardPerToken\u00a0function would always revert\u00a0due to an overflow. Importantly, this value could be set to a system destabilizing value even when\u00a0stakingToken.cumulativeStaked\u00a0was already non-zero. This would cause\u00a0_updateReward\u00a0to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any\u00a0stakedToken\u00a0at all were actively being staked. Any\u00a0stakedToken\u00a0already in the contract would be locked.", "body": "The\u00a0baseEmissionRate\u00a0parameter has no upper bound. If set too high then, as soon as\u00a0stakingToken.cumulativeStaked\u00a0were some non-zero value, the\u00a0baseRewardPerToken\u00a0function would always revert\u00a0due to an overflow. Importantly, this value could be set to a system destabilizing value even when\u00a0stakingToken.cumulativeStaked\u00a0was already non-zero. This would cause\u00a0_updateReward\u00a0to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any\u00a0stakedToken\u00a0at all were actively being staked. Any\u00a0stakedToken\u00a0already in the contract would be locked.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0baseemissionrate\u00a0parameter-has-no-upper-bound.-if-set-too-high-then,-as-soon-as\u00a0stakingtoken.cumulativestaked\u00a0were-some-non-zero-value,-the\u00a0baserewardpertoken\u00a0function-would-always-revert\u00a0due-to-an-overflow.-importantly,-this-value-could-be-set-to-a-system-destabilizing-value-even-when\u00a0stakingtoken.cumulativestaked\u00a0was-already-non-zero.-this-would-cause\u00a0_updatereward\u00a0to-revert-even-in-the-case-that-the-provided-account-was-the-zero-address.-this-detail-would-prevent-the-contract-owner-from-fixing-the-situation-without-a-complete-redeployment-of-the-system-if-any\u00a0stakedtoken\u00a0at-all-were-actively-being-staked.-any\u00a0stakedtoken\u00a0already-in-the-contract-would-be-locked.", "labels": ["OpenZeppelin"]}, {"title": "To avoid errors and unexpected system behavior, consider implementing\u00a0require\u00a0statements to validate\u00a0all\u00a0user-controlled input.", "body": "To avoid errors and unexpected system behavior, consider implementing\u00a0require\u00a0statements to validate\u00a0all\u00a0user-controlled input.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#to-avoid-errors-and-unexpected-system-behavior,-consider-implementing\u00a0require\u00a0statements-to-validate\u00a0all\u00a0user-controlled-input.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a09652a990a14d00e4d47f9e4f3df2c422a6881d4a\u00a0in\u00a0pull request #6\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "body": "Update:\u00a0Fixed as of commit\u00a09652a990a14d00e4d47f9e4f3df2c422a6881d4a\u00a0in\u00a0pull request #6\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a09652a990a14d00e4d47f9e4f3df2c422a6881d4a\u00a0in\u00a0pull-request-#6\u00a0and-commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull-request-#20.", "labels": ["OpenZeppelin"]}, {"title": "Low Severity", "body": "Low Severity", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#low-severity", "labels": ["OpenZeppelin"]}, {"title": "Incomplete and unindexed events", "body": "Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#incomplete-and-unindexed-events", "labels": ["OpenZeppelin"]}, {"title": "Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.", "body": "Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#throughout-the-codebase,-events-are-used-to-signify-when-changes-are-made-to-the-state-of-the-system.-however,-all-of-the-existing-events-lack-indexed-parameters.-some-events-are-missing-parameters-necessary-to-fully-indicate-how-the-state-was-modified-during-a-call.", "labels": ["OpenZeppelin"]}, {"title": "Events lacking indexed parameters include:", "body": "Events lacking indexed parameters include:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#events-lacking-indexed-parameters-include:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0TokenEnabledForStaking,\u00a0RecoverErc20,\u00a0Stake,\u00a0Unstake,\u00a0GetReward, and\u00a0Exit\u00a0events in the\u00a0AcceleratingDistributor\u00a0contract.", "body": "The\u00a0TokenEnabledForStaking,\u00a0RecoverErc20,\u00a0Stake,\u00a0Unstake,\u00a0GetReward, and\u00a0Exit\u00a0events in the\u00a0AcceleratingDistributor\u00a0contract.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0tokenenabledforstaking,\u00a0recovererc20,\u00a0stake,\u00a0unstake,\u00a0getreward,-and\u00a0exit\u00a0events-in-the\u00a0acceleratingdistributor\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "Event emissions which do not fully track state changes include:", "body": "Event emissions which do not fully track state changes include:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#event-emissions-which-do-not-fully-track-state-changes-include:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0RecoverErc20\u00a0event does not emit the caller, which may be of interest to those interested in calls to the\u00a0recoverErc20\u00a0function where the event is emitted.", "body": "The\u00a0RecoverErc20\u00a0event does not emit the caller, which may be of interest to those interested in calls to the\u00a0recoverErc20\u00a0function where the event is emitted.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0recovererc20\u00a0event-does-not-emit-the-caller,-which-may-be-of-interest-to-those-interested-in-calls-to-the\u00a0recovererc20\u00a0function-where-the-event-is-emitted.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0Stake,\u00a0Unstake, and\u00a0Exit\u00a0events are emitted when a user calls the\u00a0stake,\u00a0unstake, or\u00a0exit\u00a0functions, respectively. These functions update the\u00a0stakedToken\u2018s\u00a0cumulativeStaked\u00a0value, but this is not emitted in the events. Similarly, these functions \u2013 as well as the\u00a0getReward\u00a0function \u2013 update a\u00a0stakedToken\u2018s\u00a0lastUpdateTime\u00a0and\u00a0rewardPerTokenStored\u00a0as well as a\u00a0userDeposit\u2018s\u00a0rewardsOutstanding\u00a0and\u00a0rewardsPaidPerToken\u00a0values, but these state changes are not captured by any associated event emissions.", "body": "The\u00a0Stake,\u00a0Unstake, and\u00a0Exit\u00a0events are emitted when a user calls the\u00a0stake,\u00a0unstake, or\u00a0exit\u00a0functions, respectively. These functions update the\u00a0stakedToken\u2018s\u00a0cumulativeStaked\u00a0value, but this is not emitted in the events. Similarly, these functions \u2013 as well as the\u00a0getReward\u00a0function \u2013 update a\u00a0stakedToken\u2018s\u00a0lastUpdateTime\u00a0and\u00a0rewardPerTokenStored\u00a0as well as a\u00a0userDeposit\u2018s\u00a0rewardsOutstanding\u00a0and\u00a0rewardsPaidPerToken\u00a0values, but these state changes are not captured by any associated event emissions.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0stake,\u00a0unstake,-and\u00a0exit\u00a0events-are-emitted-when-a-user-calls-the\u00a0stake,\u00a0unstake,-or\u00a0exit\u00a0functions,-respectively.-these-functions-update-the\u00a0stakedtoken\u2018s\u00a0cumulativestaked\u00a0value,-but-this-is-not-emitted-in-the-events.-similarly,-these-functions-\u2013-as-well-as-the\u00a0getreward\u00a0function-\u2013-update-a\u00a0stakedtoken\u2018s\u00a0lastupdatetime\u00a0and\u00a0rewardpertokenstored\u00a0as-well-as-a\u00a0userdeposit\u2018s\u00a0rewardsoutstanding\u00a0and\u00a0rewardspaidpertoken\u00a0values,-but-these-state-changes-are-not-captured-by-any-associated-event-emissions.", "labels": ["OpenZeppelin"]}, {"title": "Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.", "body": "Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#consider-completely-indexing-existing-events,-adding-new-indexed-parameters-where-they-are-lacking,-and/or-adding-new-events-to-facilitate-off-chain-services-searching-and-filtering-for-events.-consider-emitting-all-events-in-such-a-complete-manner-that-they-could-be-used-to-rebuild-the-state-of-the-contract.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a071178ca0ce24633eb4644f64094f455862edf5e9\u00a0in\u00a0pull request #7\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "body": "Update:\u00a0Fixed as of commit\u00a071178ca0ce24633eb4644f64094f455862edf5e9\u00a0in\u00a0pull request #7\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a071178ca0ce24633eb4644f64094f455862edf5e9\u00a0in\u00a0pull-request-#7\u00a0and-commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull-request-#20.", "labels": ["OpenZeppelin"]}, {"title": "Recovery function is not robust", "body": "Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#recovery-function-is-not-robust", "labels": ["OpenZeppelin"]}, {"title": "Within the\u00a0AcceleratingDistributor\u00a0contract, the\u00a0recoverErc20\u00a0function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.", "body": "Within the\u00a0AcceleratingDistributor\u00a0contract, the\u00a0recoverErc20\u00a0function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#within-the\u00a0acceleratingdistributor\u00a0contract,-the\u00a0recovererc20\u00a0function-is-intended-to-facilitate-the-recovery-of-tokens-which-may-have-been-sent-to-the-contract-in-error.-without-such-a-function,-tokens-sent-to-the-contract-in-error-would-generally-become-completely-inaccessible.", "labels": ["OpenZeppelin"]}, {"title": "However, the current implementation of the recovery function is less robust than may be desirable.", "body": "However, the current implementation of the recovery function is less robust than may be desirable.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#however,-the-current-implementation-of-the-recovery-function-is-less-robust-than-may-be-desirable.", "labels": ["OpenZeppelin"]}, {"title": "For instance, all recovered tokens are hard-coded to be sent to the contract\u2019s owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.", "body": "For instance, all recovered tokens are hard-coded to be sent to the contract\u2019s owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#for-instance,-all-recovered-tokens-are-hard-coded-to-be-sent-to-the-contract\u2019s-owner.-but-the-contract-also-has-the-ability-to-relinquish-ownership,-whereby-the-owner-is-set-to-the-zero-address.-after-ownership-is-relinquished-then,-the-recovery-function-can-no-longer-perform-its-intended-purpose.", "labels": ["OpenZeppelin"]}, {"title": "Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that\u00a0are or were\u00a0eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.", "body": "Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that\u00a0are or were\u00a0eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#additionally,-any-tokens-that-have-ever-been-enabled-for-staking-are-not-recoverable.-unfortunately,-it-is-precisely-tokens-that\u00a0are-or-were\u00a0eligible-to-be-staked-that-are-most-likely-to-be-sent-to-the-contract-in-error,-especially-by-users-trying-to-stake-with-the-protocol-in-an-incorrect-manner.", "labels": ["OpenZeppelin"]}, {"title": "To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the\u00a0cumulativeStaked\u00a0amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.", "body": "To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the\u00a0cumulativeStaked\u00a0amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#to-better-separate-concerns,-consider-having-tokens-recovered-to-a-recovery-address-that-is-independent-of-the-owner.-alternatively,-consider-explicitly-documenting-the-fact-that-token-recoverability-is-dependent-on-an-owner-address-that-can-be-controlled.-also,-since-the\u00a0cumulativestaked\u00a0amount-for-every-staking-token-is-already-accounted-for,-consider-using-it-to-allow-for-the-recovery-of-staking-tokens-which-were-sent-in-error-and-are,-as-a-result,-unaccounted-for.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a00cc740ecc30694077d44674d80b48c4e6d75ce31\u00a0in\u00a0pull request #8.", "body": "Update:\u00a0Fixed as of commit\u00a00cc740ecc30694077d44674d80b48c4e6d75ce31\u00a0in\u00a0pull request #8.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a00cc740ecc30694077d44674d80b48c4e6d75ce31\u00a0in\u00a0pull-request-#8.", "labels": ["OpenZeppelin"]}, {"title": "Unhandled failures in token interactions", "body": "There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#unhandled-failures-in-token-interactions", "labels": ["OpenZeppelin"]}, {"title": "There are ERC20\u00a0transfer\u00a0operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.", "body": "There are ERC20\u00a0transfer\u00a0operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#there-are-erc20\u00a0transfer\u00a0operations,-executed-over-potentially-untrusted-erc20-tokens,-which-are-not-correctly-wrapped-to-ensure-that-they-are-always-safe-and-behave-as-expected.", "labels": ["OpenZeppelin"]}, {"title": "Specifically, for the\u00a0transfer\u00a0on\u00a0line 177\u00a0of the\u00a0AcceleratingDistributor\u00a0contract, the current implementation does not handle a case where the call to\u00a0transfer\u00a0fails by returning a\u00a0false\u00a0boolean value (rather than reverting the transaction).", "body": "Specifically, for the\u00a0transfer\u00a0on\u00a0line 177\u00a0of the\u00a0AcceleratingDistributor\u00a0contract, the current implementation does not handle a case where the call to\u00a0transfer\u00a0fails by returning a\u00a0false\u00a0boolean value (rather than reverting the transaction).", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#specifically,-for-the\u00a0transfer\u00a0on\u00a0line-177\u00a0of-the\u00a0acceleratingdistributor\u00a0contract,-the-current-implementation-does-not-handle-a-case-where-the-call-to\u00a0transfer\u00a0fails-by-returning-a\u00a0false\u00a0boolean-value-(rather-than-reverting-the-transaction).", "labels": ["OpenZeppelin"]}, {"title": "For more predictable and consistent behavior, consider using the OpenZeppelin\u00a0SafeERC20\u00a0library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return\u00a0false\u00a0on failure.", "body": "For more predictable and consistent behavior, consider using the OpenZeppelin\u00a0SafeERC20\u00a0library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return\u00a0false\u00a0on failure.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#for-more-predictable-and-consistent-behavior,-consider-using-the-openzeppelin\u00a0safeerc20\u00a0library-which-is-used-for-other-transfers-throughout-the-codebase,-as-it-implements-wrappers-around-erc20-operations-that-return\u00a0false\u00a0on-failure.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a03722baff5cf0ee936b43ecf07ae47b44b3f5688d\u00a0in\u00a0pull request #9.", "body": "Update:\u00a0Fixed as of commit\u00a03722baff5cf0ee936b43ecf07ae47b44b3f5688d\u00a0in\u00a0pull request #9.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a03722baff5cf0ee936b43ecf07ae47b44b3f5688d\u00a0in\u00a0pull-request-#9.", "labels": ["OpenZeppelin"]}, {"title": "Unused inherited contracts", "body": "The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#unused-inherited-contracts", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0AcceleratingDistributor\u00a0contract\u00a0imports\u00a0and\u00a0inherits from\u00a0the\u00a0Pausable\u00a0contract but does not use any of the inherited functionality.", "body": "The\u00a0AcceleratingDistributor\u00a0contract\u00a0imports\u00a0and\u00a0inherits from\u00a0the\u00a0Pausable\u00a0contract but does not use any of the inherited functionality.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0acceleratingdistributor\u00a0contract\u00a0imports\u00a0and\u00a0inherits-from\u00a0the\u00a0pausable\u00a0contract-but-does-not-use-any-of-the-inherited-functionality.", "labels": ["OpenZeppelin"]}, {"title": "Consider either using the inherited\u00a0Pausable\u00a0functionality or else not inheriting from the\u00a0Pausable\u00a0contract.", "body": "Consider either using the inherited\u00a0Pausable\u00a0functionality or else not inheriting from the\u00a0Pausable\u00a0contract.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#consider-either-using-the-inherited\u00a0pausable\u00a0functionality-or-else-not-inheriting-from-the\u00a0pausable\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0b511e0d96a18d1087da60e2e02ee18120eb0a291\u00a0in\u00a0pull request #10.", "body": "Update:\u00a0Fixed as of commit\u00a0b511e0d96a18d1087da60e2e02ee18120eb0a291\u00a0in\u00a0pull request #10.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a0b511e0d96a18d1087da60e2e02ee18120eb0a291\u00a0in\u00a0pull-request-#10.", "labels": ["OpenZeppelin"]}, {"title": "Notes & Additional Information", "body": "Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#notes-&-additional-information", "labels": ["OpenZeppelin"]}, {"title": "Visibility unnecessarily permissive", "body": "mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#visibility-unnecessarily-permissive", "labels": ["OpenZeppelin"]}, {"title": "mint\u00a0and", "body": "mint\u00a0and", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#mint\u00a0and", "labels": ["OpenZeppelin"]}, {"title": "burn\u00a0functions of the", "body": "burn\u00a0functions of the", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#burn\u00a0functions-of-the", "labels": ["OpenZeppelin"]}, {"title": "enableStaking,", "body": "enableStaking,", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#enablestaking,", "labels": ["OpenZeppelin"]}, {"title": "stake,", "body": "and Exit events are emitted when a user calls the  un or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,    getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#stake,", "labels": ["OpenZeppelin"]}, {"title": "getCumulativeStaked, and", "body": "getCumulativeStaked, and", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#getcumulativestaked,-and", "labels": ["OpenZeppelin"]}, {"title": "getUserStake\u00a0of the", "body": "getUserStake\u00a0of the", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#getuserstake\u00a0of-the", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a00f027e6cb8ae146a755de3041172efc76bb87d5f\u00a0in\u00a0pull request #11\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "body": "Update:\u00a0Fixed as of commit\u00a00f027e6cb8ae146a755de3041172efc76bb87d5f\u00a0in\u00a0pull request #11\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a00f027e6cb8ae146a755de3041172efc76bb87d5f\u00a0in\u00a0pull-request-#11\u00a0and-commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull-request-#20.", "labels": ["OpenZeppelin"]}, {"title": "System is incompatible with non-standard ERC20 tokens", "body": "Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#system-is-incompatible-with-non-standard-erc20-tokens", "labels": ["OpenZeppelin"]}, {"title": "Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:", "body": "Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#currently,-the-system-is-incompatible-with-non-standard-erc20-tokens-and-enabling-such-tokens-for-staking-could-lead-to-loss-of-funds-in-the-following-ways:", "labels": ["OpenZeppelin"]}, {"title": "The system\u2019s internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as\u00a0Tether (USDT)\u00a0(the most widely known asset with this feature). This means that such tokens\u2019\u00a0transfer\u00a0and\u00a0transferFrom\u00a0functions could potentially fail to increase the recipient\u2019s balance by the amount that is actually transferred.If\u00a0AcceleratingDistributor\u00a0allows staking of tokens charging such transfer fees,\u00a0then stakers would receive more rewards than intended.", "body": "The system\u2019s internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as\u00a0Tether (USDT)\u00a0(the most widely known asset with this feature). This means that such tokens\u2019\u00a0transfer\u00a0and\u00a0transferFrom\u00a0functions could potentially fail to increase the recipient\u2019s balance by the amount that is actually transferred.If\u00a0AcceleratingDistributor\u00a0allows staking of tokens charging such transfer fees,\u00a0then stakers would receive more rewards than intended.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-system\u2019s-internal-accounting-mechanism-does-not-currently-support-tokens-that-can-charge-fees-on-transfers,-such-as\u00a0tether-(usdt)\u00a0(the-most-widely-known-asset-with-this-feature).-this-means-that-such-tokens\u2019\u00a0transfer\u00a0and\u00a0transferfrom\u00a0functions-could-potentially-fail-to-increase-the-recipient\u2019s-balance-by-the-amount-that-is-actually-transferred.if\u00a0acceleratingdistributor\u00a0allows-staking-of-tokens-charging-such-transfer-fees,\u00a0then-stakers-would-receive-more-rewards-than-intended.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0recoverErc20\u00a0function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case\u00a0the current restrictions\u00a0may not be sufficient to restrict such tokens\u2019 recovery via the\u00a0recoverErc20\u00a0function (e.g.\u00a0Compound-TUSD Integration Issue Retrospective).", "body": "The\u00a0recoverErc20\u00a0function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case\u00a0the current restrictions\u00a0may not be sufficient to restrict such tokens\u2019 recovery via the\u00a0recoverErc20\u00a0function (e.g.\u00a0Compound-TUSD Integration Issue Retrospective).", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0recovererc20\u00a0function-is-currently-callable-by-any-address.-this-could-be-problematic-if-the-system-were-to-allow-staking-of-non-standard-erc20-tokens,-particularly-if-those-tokens-were-to-have-a-double-entry-point.-in-such-a-case\u00a0the-current-restrictions\u00a0may-not-be-sufficient-to-restrict-such-tokens\u2019-recovery-via-the\u00a0recovererc20\u00a0function-(e.g.\u00a0compound-tusd-integration-issue-retrospective).", "labels": ["OpenZeppelin"]}, {"title": "If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the\u00a0recoverErc20\u00a0function so that is can only be called from trusted accounts.", "body": "If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the\u00a0recoverErc20\u00a0function so that is can only be called from trusted accounts.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#if-the-protocol-is-expected-to-be-compatible-with-these-types-of-non-standard-erc20-tokens,-then-consider-modifying-the-internal-accounting-mechanisms-so-that-they-properly-track-the-actual-amount-of-assets-deposited.-additionally,-consider-limiting-the\u00a0recovererc20\u00a0function-so-that-is-can-only-be-called-from-trusted-accounts.", "labels": ["OpenZeppelin"]}, {"title": "Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the\u00a0recoverErc20\u00a0function is left unrestricted, then consider moving it out of the\u00a0ADMIN\u00a0section of the codebase.", "body": "Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the\u00a0recoverErc20\u00a0function is left unrestricted, then consider moving it out of the\u00a0ADMIN\u00a0section of the codebase.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#alternatively,-consider-documenting-that-the-system-is-incompatible-with-non-standard-erc20-tokens-and-ensuring-the-contract-owner-thoroughly-vets-any-erc20-tokens-that-are-enabled-for-staking.-if-the\u00a0recovererc20\u00a0function-is-left-unrestricted,-then-consider-moving-it-out-of-the\u00a0admin\u00a0section-of-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a05ea4099a44e5edfa5e84cc65e744cf546d7f5957\u00a0in\u00a0pull request #12\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "body": "Update:\u00a0Fixed as of commit\u00a05ea4099a44e5edfa5e84cc65e744cf546d7f5957\u00a0in\u00a0pull request #12\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a05ea4099a44e5edfa5e84cc65e744cf546d7f5957\u00a0in\u00a0pull-request-#12\u00a0and-commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull-request-#20.", "labels": ["OpenZeppelin"]}, {"title": "Misleading function names", "body": "In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#misleading-function-names", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0AcceleratingDistributor\u00a0contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:", "body": "In the\u00a0AcceleratingDistributor\u00a0contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#in-the\u00a0acceleratingdistributor\u00a0contract-there-are-multiple-functions,-storage-variables,-and-events-that-have-misleading-names.-these-could-potentially-confuse-users-and-lead-to-unintentional-or-unexpected-consequences-when-interacting-with-the-contract.-for-instance:", "labels": ["OpenZeppelin"]}, {"title": "The function name\u00a0enableStaking\u00a0implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties\u00a0baseEmissionRate,\u00a0maxMultiplier\u00a0or\u00a0secondsToMaxMultiplier. Consider renaming the function to\u00a0configureStakingToken.", "body": "The function name\u00a0enableStaking\u00a0implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties\u00a0baseEmissionRate,\u00a0maxMultiplier\u00a0or\u00a0secondsToMaxMultiplier. Consider renaming the function to\u00a0configureStakingToken.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-function-name\u00a0enablestaking\u00a0implies-that-it-can-only-be-used-to-enable-a-staking-token.-however,-the-function-can-be-used-to-enable-or-disable-a-staking-token,-and/or-modify-the-properties\u00a0baseemissionrate,\u00a0maxmultiplier\u00a0or\u00a0secondstomaxmultiplier.-consider-renaming-the-function-to\u00a0configurestakingtoken.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0enableStaking\u00a0function emits the event\u00a0TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.", "body": "The\u00a0enableStaking\u00a0function emits the event\u00a0TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0enablestaking\u00a0function-emits-the-event\u00a0tokenenabledforstaking.-consider-renaming-the-event-to-better-reflect-the-actual-use-case-of-the-emitting-function-as-outlined-in-the-above-bullet-point.", "labels": ["OpenZeppelin"]}, {"title": "The function prefix\u00a0get\u00a0typically indicates a view function, however the function\u00a0getReward\u00a0transfers outstanding rewards to the caller. Consider renaming it to\u00a0withdrawReward.", "body": "The function prefix\u00a0get\u00a0typically indicates a view function, however the function\u00a0getReward\u00a0transfers outstanding rewards to the caller. Consider renaming it to\u00a0withdrawReward.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-function-prefix\u00a0get\u00a0typically-indicates-a-view-function,-however-the-function\u00a0getreward\u00a0transfers-outstanding-rewards-to-the-caller.-consider-renaming-it-to\u00a0withdrawreward.", "labels": ["OpenZeppelin"]}, {"title": "The function name\u00a0getTimeFromLastDeposit\u00a0implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to\u00a0getTimeSinceAverageDeposit.", "body": "The function name\u00a0getTimeFromLastDeposit\u00a0implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to\u00a0getTimeSinceAverageDeposit.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-function-name\u00a0gettimefromlastdeposit\u00a0implies-that-a-difference-between-the-current-time-and-the-last-time-of-deposit-is-returned.-however,-the-difference-is-calculated-using-the-weighted-average-deposit-time.-consider-renaming-it-to\u00a0gettimesinceaveragedeposit.", "labels": ["OpenZeppelin"]}, {"title": "The variable name\u00a0rewardsPaidPerToken\u00a0appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the\u00a0rewardsOustanding\u00a0variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming\u00a0rewardsPaidPerToken\u00a0to\u00a0rewardsAccumulatedPerToken.", "body": "The variable name\u00a0rewardsPaidPerToken\u00a0appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the\u00a0rewardsOustanding\u00a0variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming\u00a0rewardsPaidPerToken\u00a0to\u00a0rewardsAccumulatedPerToken.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-variable-name\u00a0rewardspaidpertoken\u00a0appears-to-imply-that-the-rewards-contained-can-be-distributed-or-have-already-been-distributed-to-the-individual-user.-however,-this-variable-is-used-as-a-helper-variable-to-allow-accurate-bookkeeping-of-the\u00a0rewardsoustanding\u00a0variable,-which-contains-the-funds-that-are-actually-withdrawable-to-the-individual-user.-consider-renaming\u00a0rewardspaidpertoken\u00a0to\u00a0rewardsaccumulatedpertoken.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a05db3215559fad05ebf98ac9f2bd91187a1e442d7\u00a0in\u00a0pull request #13.", "body": "Update:\u00a0Fixed as of commit\u00a05db3215559fad05ebf98ac9f2bd91187a1e442d7\u00a0in\u00a0pull request #13.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a05db3215559fad05ebf98ac9f2bd91187a1e442d7\u00a0in\u00a0pull-request-#13.", "labels": ["OpenZeppelin"]}, {"title": "Missing documentation details", "body": "In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#missing-documentation-details", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0AcceleratingDistributor\u00a0contract several parts of the documentation contain missing or misleading details. For instance:", "body": "In the\u00a0AcceleratingDistributor\u00a0contract several parts of the documentation contain missing or misleading details. For instance:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#in-the\u00a0acceleratingdistributor\u00a0contract-several-parts-of-the-documentation-contain-missing-or-misleading-details.-for-instance:", "labels": ["OpenZeppelin"]}, {"title": "The functions\u00a0getUserRewardMultiplier\u00a0and\u00a0baseRewardPerToken\u00a0return ratios or multipliers represented by a\u00a0uint256\u00a0value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.", "body": "The functions\u00a0getUserRewardMultiplier\u00a0and\u00a0baseRewardPerToken\u00a0return ratios or multipliers represented by a\u00a0uint256\u00a0value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-functions\u00a0getuserrewardmultiplier\u00a0and\u00a0baserewardpertoken\u00a0return-ratios-or-multipliers-represented-by-a\u00a0uint256\u00a0value-with-a-fixed-precision-of-18-decimals.-however,-the-decimal-precision-used-is-not-documented.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0contract-level documentation\u00a0refers to a\u00a0maxEmissionRate. However, the implementation uses a\u00a0maxMultiplier\u00a0which is multiplied with a\u00a0baseEmissionRate\u00a0instead.", "body": "The\u00a0contract-level documentation\u00a0refers to a\u00a0maxEmissionRate. However, the implementation uses a\u00a0maxMultiplier\u00a0which is multiplied with a\u00a0baseEmissionRate\u00a0instead.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0contract-level-documentation\u00a0refers-to-a\u00a0maxemissionrate.-however,-the-implementation-uses-a\u00a0maxmultiplier\u00a0which-is-multiplied-with-a\u00a0baseemissionrate\u00a0instead.", "labels": ["OpenZeppelin"]}, {"title": "To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.", "body": "To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#to-increase-the-overall-readability-of-the-codebase-and-reduce-potential-confusion,-consider-clarifying-the-documentation-and-adding-missing-details-where-appropriate.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0e3e7cf1c46304accc73f25a70f14036841e81239\u00a0in\u00a0pull request #14.", "body": "Update:\u00a0Fixed as of commit\u00a0e3e7cf1c46304accc73f25a70f14036841e81239\u00a0in\u00a0pull request #14.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a0e3e7cf1c46304accc73f25a70f14036841e81239\u00a0in\u00a0pull-request-#14.", "labels": ["OpenZeppelin"]}, {"title": "Not using\u00a0immutable", "body": "Not using\u00a0immutable", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#not-using\u00a0immutable", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0AcceleratingDistributor\u00a0contract the\u00a0rewardToken\u00a0variable could be marked\u00a0immutable\u00a0given that is only ever set in the constructor.", "body": "In the\u00a0AcceleratingDistributor\u00a0contract the\u00a0rewardToken\u00a0variable could be marked\u00a0immutable\u00a0given that is only ever set in the constructor.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#in-the\u00a0acceleratingdistributor\u00a0contract-the\u00a0rewardtoken\u00a0variable-could-be-marked\u00a0immutable\u00a0given-that-is-only-ever-set-in-the-constructor.", "labels": ["OpenZeppelin"]}, {"title": "If\u00a0rewardToken\u00a0is never meant to be modifiable, then consider marking it\u00a0immutable\u00a0to better signal intent and reduce gas consumption.", "body": "If\u00a0rewardToken\u00a0is never meant to be modifiable, then consider marking it\u00a0immutable\u00a0to better signal intent and reduce gas consumption.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#if\u00a0rewardtoken\u00a0is-never-meant-to-be-modifiable,-then-consider-marking-it\u00a0immutable\u00a0to-better-signal-intent-and-reduce-gas-consumption.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0973e002a92e646f5e3af74d235a1e77d03bd69a0\u00a0in\u00a0pull request #15.", "body": "Update:\u00a0Fixed as of commit\u00a0973e002a92e646f5e3af74d235a1e77d03bd69a0\u00a0in\u00a0pull request #15.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a0973e002a92e646f5e3af74d235a1e77d03bd69a0\u00a0in\u00a0pull-request-#15.", "labels": ["OpenZeppelin"]}, {"title": "Test code in production could have security implications", "body": "As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#test-code-in-production-could-have-security-implications", "labels": ["OpenZeppelin"]}, {"title": "As we have\u00a0raised in prior audits (issue L12)\u00a0test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:", "body": "As we have\u00a0raised in prior audits (issue L12)\u00a0test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#as-we-have\u00a0raised-in-prior-audits-(issue-l12)\u00a0test-code-in-production-code-is-less-than-ideal.-we-will-not-simply-rehash-our-previously-raised-concerns-and-suggestions,-but-we-do-feel-it-prudent-to-expound-on-some-of-the-potential-security-implications-of-having-test-code-in-production-in-this-particular-case:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0AcceleratingDistributor\u00a0contract inherits from the\u00a0Testable\u00a0contract. This facilitates modification of the\u00a0getCurrentTime\u00a0function\u2019s behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter\u00a0_timer\u00a0during deployment will disable the testing module and return\u00a0block.timestamp\u00a0instead.", "body": "The\u00a0AcceleratingDistributor\u00a0contract inherits from the\u00a0Testable\u00a0contract. This facilitates modification of the\u00a0getCurrentTime\u00a0function\u2019s behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter\u00a0_timer\u00a0during deployment will disable the testing module and return\u00a0block.timestamp\u00a0instead.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0acceleratingdistributor\u00a0contract-inherits-from-the\u00a0testable\u00a0contract.-this-facilitates-modification-of-the\u00a0getcurrenttime\u00a0function\u2019s-behavior-during-testing.-this-inheritance-is-meant-to-be-kept-in-production.-this-is-considered-safe-because-passing-the-zero-address-for-the-parameter\u00a0_timer\u00a0during-deployment-will-disable-the-testing-module-and-return\u00a0block.timestamp\u00a0instead.", "labels": ["OpenZeppelin"]}, {"title": "The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to\u00a0unstake\u00a0and\u00a0getReward\u00a0are guarded by a modifier which ensures only that a token had been enabled for staking at some time \u2013 not that it is\u00a0currently\u00a0enabled for staking. It does this by verifying the token\u2019s\u00a0lastUpdateTime\u00a0is greater than zero. The contract owner is not meant to be able to set\u00a0lastUpdateTime\u00a0in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.", "body": "The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to\u00a0unstake\u00a0and\u00a0getReward\u00a0are guarded by a modifier which ensures only that a token had been enabled for staking at some time \u2013 not that it is\u00a0currently\u00a0enabled for staking. It does this by verifying the token\u2019s\u00a0lastUpdateTime\u00a0is greater than zero. The contract owner is not meant to be able to set\u00a0lastUpdateTime\u00a0in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-contract-logic-ensures-that-all-staked-tokens-can-be-unstaked-by-their-respective-owners-and-that-all-rewards-can-be-collected-even-if-further-staking-is-disabled-by-the-contract-owner.-calls-to\u00a0unstake\u00a0and\u00a0getreward\u00a0are-guarded-by-a-modifier-which-ensures-only-that-a-token-had-been-enabled-for-staking-at-some-time-\u2013-not-that-it-is\u00a0currently\u00a0enabled-for-staking.-it-does-this-by-verifying-the-token\u2019s\u00a0lastupdatetime\u00a0is-greater-than-zero.-the-contract-owner-is-not-meant-to-be-able-to-set\u00a0lastupdatetime\u00a0in-production-and-it-is-guaranteed-to-be-greater-than-zero-for-each-token-that-has-previously-been-enabled-for-staking.", "labels": ["OpenZeppelin"]}, {"title": "However, a malicious operator could deploy the code with the\u00a0address\u00a0_timer\u00a0pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. What\u2019s worse, the malicious operator could then steal all staked TVL via\u00a0recoverERC20\u00a0(which would no longer recognize the staked token as such when their\u00a0lastUpdateTime\u00a0was equal to zero).", "body": "However, a malicious operator could deploy the code with the\u00a0address\u00a0_timer\u00a0pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. What\u2019s worse, the malicious operator could then steal all staked TVL via\u00a0recoverERC20\u00a0(which would no longer recognize the staked token as such when their\u00a0lastUpdateTime\u00a0was equal to zero).", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#however,-a-malicious-operator-could-deploy-the-code-with-the\u00a0address\u00a0_timer\u00a0pointing-to-a-smart-contract-that-allows-the-attacker-to-arbitrarily-change-time.-they-could-at-first-report-accurate-block-times-and-then-wait-until-a-significant-portion-of-staked-tvl-is-accumulated.-later,-they-could-change-the-reported-time-to-zero.-as-a-consequence,-users-would-be-unable-to-unstake-or-obtain-rewards.-what\u2019s-worse,-the-malicious-operator-could-then-steal-all-staked-tvl-via\u00a0recovererc20\u00a0(which-would-no-longer-recognize-the-staked-token-as-such-when-their\u00a0lastupdatetime\u00a0was-equal-to-zero).", "labels": ["OpenZeppelin"]}, {"title": "A potential risk here is that a third party could uses this exact code, misusing the\u00a0Testable\u00a0functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.", "body": "A potential risk here is that a third party could uses this exact code, misusing the\u00a0Testable\u00a0functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#a-potential-risk-here-is-that-a-third-party-could-uses-this-exact-code,-misusing-the\u00a0testable\u00a0functionality-to-be-genuinely-malicious.-since-ecosystem-tools-such-as-etherscan-can-do-exact-matching-on-bytecode,-the-malicious-deployment-could-end-up-being-directly-linked-to-the-across-protocol,-which-could-lead-to-some-loss-of-reputation.", "labels": ["OpenZeppelin"]}, {"title": "As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.", "body": "As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#as-this-is-a-fairly-general-purpose,-user-facing-system,-with-an-open-source-license,-we-can-certainly-imagine-it-being-reused.-the-subtleties-of-the-deployment-can-have-drastic-implications-for-the-security-model-of-the-deployed-system.-normalizing-such-designs-can-have-unintended-consequences-for-users,-but-also-for-projects-that-may-inadvertently-suffer-from-mere-association-with-some-malicious-deployment.", "labels": ["OpenZeppelin"]}, {"title": "Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.", "body": "Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#consider-better-isolating-test-and-production-code-where-possible.-when-this-is-not-possible,-consider-bolstering-the-warnings-in-the-code-so-that-even-casual-users-could-better-understand-the-implications-if-system-variables-are-are-not-set-as-intended-in-production.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0144293ec5b81c3367ad58738d7bca273b3e8a9e4\u00a0in\u00a0pull request #16.", "body": "Update:\u00a0Fixed as of commit\u00a0144293ec5b81c3367ad58738d7bca273b3e8a9e4\u00a0in\u00a0pull request #16.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a0144293ec5b81c3367ad58738d7bca273b3e8a9e4\u00a0in\u00a0pull-request-#16.", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "The codebase contains the following typographical errors:", "body": "The codebase contains the following typographical errors:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-codebase-contains-the-following-typographical-errors:", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0AcceleratingDistributor.sol:", "body": "In\u00a0AcceleratingDistributor.sol:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#in\u00a0acceleratingdistributor.sol:", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 17\u00a0and\u00a0line 89\u00a0pro-rate\u00a0should be\u00a0pro-rata.", "body": "On\u00a0line 17\u00a0and\u00a0line 89\u00a0pro-rate\u00a0should be\u00a0pro-rata.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#on\u00a0line-17\u00a0and\u00a0line-89\u00a0pro-rate\u00a0should-be\u00a0pro-rata.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 126,\u00a0after the end of the staking program ends\u00a0is ungrammatical.", "body": "On\u00a0line 126,\u00a0after the end of the staking program ends\u00a0is ungrammatical.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#on\u00a0line-126,\u00a0after-the-end-of-the-staking-program-ends\u00a0is-ungrammatical.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 202,\u00a0exists\u00a0should be\u00a0exits.", "body": "On\u00a0line 202,\u00a0exists\u00a0should be\u00a0exits.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#on\u00a0line-202,\u00a0exists\u00a0should-be\u00a0exits.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 203,\u00a0callers\u00a0should be\u00a0caller's.", "body": "On\u00a0line 203,\u00a0callers\u00a0should be\u00a0caller's.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#on\u00a0line-203,\u00a0callers\u00a0should-be\u00a0caller's.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 228,\u00a0the all information associated\u00a0should be\u00a0all the information associated.", "body": "On\u00a0line 228,\u00a0the all information associated\u00a0should be\u00a0all the information associated.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#on\u00a0line-228,\u00a0the-all-information-associated\u00a0should-be\u00a0all-the-information-associated.", "labels": ["OpenZeppelin"]}, {"title": "Consider correcting these typos to improve the overall readability of the codebase.", "body": "Consider correcting these typos to improve the overall readability of the codebase.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#consider-correcting-these-typos-to-improve-the-overall-readability-of-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a07975d8ad19a3766341a115fce83c7752412f837b\u00a0in\u00a0pull request #17.", "body": "Update:\u00a0Fixed as of commit\u00a07975d8ad19a3766341a115fce83c7752412f837b\u00a0in\u00a0pull request #17.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a07975d8ad19a3766341a115fce83c7752412f837b\u00a0in\u00a0pull-request-#17.", "labels": ["OpenZeppelin"]}, {"title": "Conclusions", "body": "0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#conclusions", "labels": ["OpenZeppelin"]}, {"title": "0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.", "body": "0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#0-critical-and-1-high-severity-issues-were-found.-some-changes-were-proposed-to-follow-best-practices-and-reduce-the-potential-attack-surface.", "labels": ["OpenZeppelin"]}, {"title": "Appendix", "body": "Appendix", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#appendix", "labels": ["OpenZeppelin"]}, {"title": "Severity Levels", "body": "Severity Levels", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#severity-levels", "labels": ["OpenZeppelin"]}, {"title": "Not using immutable", "body": "Not using immutable", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#not-using-immutable", "labels": ["OpenZeppelin"]}, {"title": "s", "body": "Token and Token Ditributor Audit  OpenZeppelin Security |  July 21, 2022  Security Audit  May 10th, 2022  Thi ecurity aement wa prepared by OpenZeppelin, protecting the open economy.  Table of Content  Table of Content  Summary  Scope  Sytem Overview  Privileged Role  Finding  High Severity  Anyone can prevent taker from getting their reward  Medium Severity  Lack of input validation  Low Severity  Incomplete and unindexed event Recovery function i not robut Unhandled failure in token interaction Unued inherited contract  Note & Additional Information  Viibility unnecearily permiive Sytem i incompatible with non-tandard ERC20 token Mileading function name Miing documentation detail Not uing immutable Tet code in production could have ecurity implication Typographical error  Concluion  Appendix  Severity Level  Summary  DeFi  From 2022-04-25  To 2022-05-10  Solidity  13 (13 reolved)  0 (0 reolved)  1 (1 reolved)  1 (1 reolved)  4 (4 reolved)  7 (7 reolved)  Scope  We audited the acro-protocol/acro-token repoitory at commit 42130387f81debf2a20d2f7b40d9f0ccc1dcd06a.  In cope were the following contract:  Sytem Overview  Sytem Overview  The ytem i compoed of the Acro token (ACX) and the Acro token ditributor. Together, thee are meant to facilitate a liquidity mining program that will accompany the launch of the mot recent verion of the Acro protocol.  The Acro token i an ERC20 compliant token.  The Acro token ditributor allow uer to take whitelited ERC20 token (LP token) to earn ACX reward. At depoit time depoitor earn a fixed bae emiion rate. The longer depoitor keep their token taked, the higher the reward rate they earn. The reward rate i capped at a value et by the owner of the ditributor. Sequential depoit reult in an average depoit time a a weighted average of previou depoit. If at any point the depoitor claim their reward or untake all LP token, then their reward emiion rate i reet to the bae rate. The contract i deigned to hold multiple LP token, each with independent parameterization for liquidity mining.  Privileged Role  Each contract ha only one privileged role, which i the contract repective owner.  The Acro token owner can mint and burn the token. The owner can alo renounce and tranfer ownerhip.  The Acro token ditributor owner can alo tranfer and renounce ownerhip. In addition, the owner i the only account which receive token recovered from the contract, which are compried of token which were mitakenly ent to and are retrievable from the contract. Finally, the owner can enable and diable token for taking and change parameter of enabled LP token. Thee parameter are et per-token and include the bae ACX emiion rate, an emiion rate cap, and time needed to reach the emiion rate cap.  Finding  Here we preent our finding.  High Severity  Anyone can prevent taker from getting their reward  The recoverErc20 function i meant to facilitate the recovery of any ERC20 token that may be mitakenly ent to the AcceleratingDitributor contract. A thi i a public function with no modifier, anyone can call thi function to tranfer an ERC20 token from the AcceleratingDitributor contract to the owner of AcceleratingDitributor. The only ERC20 token that are explicitly diallowed from being recovered are takedToken that have already been initialized in the ytem.  However, it i currently poible to recover the ERC20 rewardToken uing the recoverErc20 function. Doing o would tranfer ome pecified amount of rewardToken from the AcceleratingDitributor contract to the contract owner. Thi would, ubequently, prevent taker from being able to acce their reward becaue AcceleratingDitributor could be left with an inufficient balance of rewardToken.  Even if the owner were to end rewardToken back to the AcceleratingDitributor contract, a maliciou actor could immediately tranfer all of the rewardToken back to the owner. Redeployment would be neceary to fix the iue.  Conider diallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed a of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull requet #5.  Medium Severity  Lack of input validation  The codebae generally lack ufficient input validation.  In the AcceleratingDitributor contract, the enableStaking function allow the contract owner to configure everal parameter aociated with a takedToken. Several of thee parameter have no input checking. Specifically:  The maxMultiplier parameter ha no upper or lower bound.  It hould be retricted to being larger than the bae multiplier of 1e18, or ele it can lead to uer taking reward decreaing over time rather than increaing.  It hould alo have an upper bound, becaue if it were to be et to ome very large value it could caue the getUerRewardMultiplier function to revert on overflow. Thi could, in turn, caue call to the getOuttandingReward and _updateReward function to revert. Thi would interfere with the normal operation of the ytem. However, it could be fixed by the contract owner uing the enableStaking function to update to a more reaonable maxMultiplier.  Similarly, the econdToMaxMultiplier parameter ha no lower bound. If allowed to be zero then getUerRewardMultiplier could revert due to diviion by zero. Thi could caue the getOuttandingReward and _updateReward function to revert a outlined above. The contract owner could put the ytem back into a table tate by making econdToMaxMultiplier non-zero.  The baeEmiionRate parameter ha no upper bound. If et too high then, a oon a takingToken.cumulativeStaked were ome non-zero value, the baeRewardPerToken function would alway revert due to an overflow. Importantly, thi value could be et to a ytem detabilizing value even when takingToken.cumulativeStaked wa already non-zero. Thi would caue _updateReward to revert even in the cae that the provided account wa the zero addre. Thi detail would prevent the contract owner from fixing the ituation without a complete redeployment of the ytem if any takedToken at all were actively being taked. Any takedToken already in the contract would be locked.  To avoid error and unexpected ytem behavior, conider implementing require tatement to validate all uer-controlled input.  Update: Fixed a of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull requet #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull requet #20.  Low Severity  Incomplete and unindexed event  Throughout the codebae, event are ued to ignify when change are made to the tate of the ytem. However, all of the exiting event lack indexed parameter. Some event are miing parameter neceary to fully indicate how the tate wa modified during a call.  Event lacking indexed parameter include:  The TokenEnabledForStaking, RecoverErc20, Stake, Untake, GetReward, and Exit event in the AcceleratingDitributor contract.  Event emiion which do not fully track tate change include:  The RecoverErc20 event doe not emit the caller, which may be of interet to thoe intereted in call to the recoverErc20 function where the event i emitted.  The Stake, Untake, and Exit event are emitted when a uer call the take, untake, or exit function, repectively. Thee function update the takedToken cumulativeStaked value, but thi i not emitted in the event. Similarly, thee function  a well a the getReward function  update a takedToken latUpdateTime and rewardPerTokenStored a well a a uerDepoit rewardOuttanding and rewardPaidPerToken value, but thee tate change are not captured by any aociated event emiion.  Conider completely indexing exiting event, adding new indexed parameter where they are lacking, and/or adding new event to facilitate off-chain ervice earching and filtering for event. Conider emitting all event in uch a complete manner that they could be ued to rebuild the tate of the contract.  Update: Fixed a of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull requet #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull requet #20.  Recovery function i not robut  Within the AcceleratingDitributor contract, the recoverErc20 function i intended to facilitate the recovery of token which may have been ent to the contract in error. Without uch a function, token ent to the contract in error would generally become completely inacceible.  However, the current implementation of the recovery function i le robut than may be deirable.  For intance, all recovered token are hard-coded to be ent to the contract owner. But the contract alo ha the ability to relinquih ownerhip, whereby the owner i et to the zero addre. After ownerhip i relinquihed then, the recovery function can no longer perform it intended purpoe.  Additionally, any token that have ever been enabled for taking are not recoverable. Unfortunately, it i preciely token that are or were eligible to be taked that are mot likely to be ent to the contract in error, epecially by uer trying to take with the protocol in an incorrect manner.  To better eparate concern, conider having token recovered to a recovery addre that i independent of the owner. Alternatively, conider explicitly documenting the fact that token recoverability i dependent on an owner addre that can be controlled. Alo, ince the cumulativeStaked amount for every taking token i already accounted for, conider uing it to allow for the recovery of taking token which were ent in error and are, a a reult, unaccounted for.  Update: Fixed a of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull requet #8.  Unhandled failure in token interaction  There are ERC20 tranfer operation, executed over potentially untruted ERC20 token, which are not correctly wrapped to enure that they are alway afe and behave a expected.  Specifically, for the tranfer on line 177 of the AcceleratingDitributor contract, the current implementation doe not handle a cae where the call to tranfer fail by returning a fale boolean value (rather than reverting the tranaction).  For more predictable and conitent behavior, conider uing the OpenZeppelin SafeERC20 library which i ued for other tranfer throughout the codebae, a it implement wrapper around ERC20 operation that return fale on failure.  Update: Fixed a of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull requet #9.  Unued inherited contract  The AcceleratingDitributor contract import and inherit from the Pauable contract but doe not ue any of the inherited functionality.  Conider either uing the inherited Pauable functionality or ele not inheriting from the Pauable contract.  Update: Fixed a of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull requet #10.  Note & Additional Information  Viibility unnecearily permiive  mint and  burn function of the  enableStaking,  take,  getCumulativeStaked, and  getUerStake of the  Update: Fixed a of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull requet #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull requet #20.  Sytem i incompatible with non-tandard ERC20 token  Currently, the ytem i incompatible with non-tandard ERC20 token and enabling uch token for taking could lead to lo of fund in the following way:  The ytem internal accounting mechanim doe not currently upport token that can charge fee on tranfer, uch a Tether (USDT) (the mot widely known aet with thi feature). Thi mean that uch token tranfer and tranferFrom function could potentially fail to increae the recipient balance by the amount that i actually tranferred.If AcceleratingDitributor allow taking of token charging uch tranfer fee, then taker would receive more reward than intended.  The recoverErc20 function i currently callable by any addre. Thi could be problematic if the ytem were to allow taking of non-tandard ERC20 token, particularly if thoe token were to have a double entry point. In uch a cae the current retriction may not be ufficient to retrict uch token recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Iue Retropective).  If the protocol i expected to be compatible with thee type of non-tandard ERC20 token, then conider modifying the internal accounting mechanim o that they properly track the actual amount of aet depoited. Additionally, conider limiting the recoverErc20 function o that i can only be called from truted account.  Alternatively, conider documenting that the ytem i incompatible with non-tandard ERC20 token and enuring the contract owner thoroughly vet any ERC20 token that are enabled for taking. If the recoverErc20 function i left unretricted, then conider moving it out of the ADMIN ection of the codebae.  Update: Fixed a of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull requet #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull requet #20.  Mileading function name  In the AcceleratingDitributor contract there are multiple function, torage variable, and event that have mileading name. Thee could potentially confue uer and lead to unintentional or unexpected conequence when interacting with the contract. For intance:  The function name enableStaking implie that it can only be ued to enable a taking token. However, the function can be ued to enable or diable a taking token, and/or modify the propertie baeEmiionRate, maxMultiplier or econdToMaxMultiplier. Conider renaming the function to configureStakingToken.  The enableStaking function emit the event TokenEnabledForStaking. Conider renaming the event to better reflect the actual ue cae of the emitting function a outlined in the above bullet point.  The function prefix get typically indicate a view function, however the function getReward tranfer outtanding reward to the caller. Conider renaming it to withdrawReward.  The function name getTimeFromLatDepoit implie that a difference between the current time and the lat time of depoit i returned. However, the difference i calculated uing the weighted average depoit time. Conider renaming it to getTimeSinceAverageDepoit.  The variable name rewardPaidPerToken appear to imply that the reward contained can be ditributed or have already been ditributed to the individual uer. However, thi variable i ued a a helper variable to allow accurate bookkeeping of the rewardOutanding variable, which contain the fund that are actually withdrawable to the individual uer. Conider renaming rewardPaidPerToken to rewardAccumulatedPerToken.  Update: Fixed a of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull requet #13.  Miing documentation detail  In the AcceleratingDitributor contract everal part of the documentation contain miing or mileading detail. For intance:  The function getUerRewardMultiplier and baeRewardPerToken return ratio or multiplier repreented by a uint256 value with a fixed preciion of 18 decimal. However, the decimal preciion ued i not documented.  The contract-level documentation refer to a maxEmiionRate. However, the implementation ue a maxMultiplier which i multiplied with a baeEmiionRate intead.  To increae the overall readability of the codebae and reduce potential confuion, conider clarifying the documentation and adding miing detail where appropriate.  Update: Fixed a of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull requet #14.  Not uing immutable  In the AcceleratingDitributor contract the rewardToken variable could be marked immutable given that i only ever et in the contructor.  If rewardToken i never meant to be modifiable, then conider marking it immutable to better ignal intent and reduce ga conumption.  Update: Fixed a of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull requet #15.  Tet code in production could have ecurity implication  A we have raied in prior audit (iue L12) tet code in production code i le than ideal. We will not imply rehah our previouly raied concern and uggetion, but we do feel it prudent to expound on ome of the potential ecurity implication of having tet code in production in thi particular cae:  The AcceleratingDitributor contract inherit from the Tetable contract. Thi facilitate modification of the getCurrentTime function behavior during teting. Thi inheritance i meant to be kept in production. Thi i conidered afe becaue paing the zero addre for the parameter _timer during deployment will diable the teting module and return block.timetamp intead.  The contract logic enure that all taked token can be untaked by their repective owner and that all reward can be collected even if further taking i diabled by the contract owner. Call to untake and getReward are guarded by a modifier which enure only that a token had been enabled for taking at ome time  not that it i currently enabled for taking. It doe thi by verifying the token latUpdateTime i greater than zero. The contract owner i not meant to be able to et latUpdateTime in production and it i guaranteed to be greater than zero for each token that ha previouly been enabled for taking.  However, a maliciou operator could deploy the code with the addre _timer pointing to a mart contract that allow the attacker to arbitrarily change time. They could at firt report accurate block time and then wait until a ignificant portion of taked TVL i accumulated. Later, they could change the reported time to zero. A a conequence, uer would be unable to untake or obtain reward. What wore, the maliciou operator could then teal all taked TVL via recoverERC20 (which would no longer recognize the taked token a uch when their latUpdateTime wa equal to zero).  A potential rik here i that a third party could ue thi exact code, miuing the Tetable functionality to be genuinely maliciou. Since ecoytem tool uch a Ethercan can do exact matching on bytecode, the maliciou deployment could end up being directly linked to the Acro protocol, which could lead to ome lo of reputation.  A thi i a fairly general-purpoe, uer-facing ytem, with an open ource licene, we can certainly imagine it being reued. The ubtletie of the deployment can have dratic implication for the ecurity model of the deployed ytem. Normalizing uch deign can have unintended conequence for uer, but alo for project that may inadvertently uffer from mere aociation with ome maliciou deployment.  Conider better iolating tet and production code where poible. When thi i not poible, conider boltering the warning in the code o that even caual uer could better undertand the implication if ytem variable are are not et a intended in production.  Update: Fixed a of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull requet #16.  Typographical error  The codebae contain the following typographical error:  In AcceleratingDitributor.ol:  On line 17 and line 89 pro-rate hould be pro-rata.  On line 126, after the end of the taking program end i ungrammatical.  On line 202, exit hould be exit.  On line 203, caller hould be caller'.  On line 228, the all information aociated hould be all the information aociated.  Conider correcting thee typo to improve the overall readability of the codebae.  Update: Fixed a of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull requet #17.  Concluion  0 critical and 1 high everity iue were found. Some change were propoed to follow bet practice and reduce the potential attack urface.  Appendix  Severity Level  Critical Severity  The iue put a large number of uer enitive information at rik, or i reaonably likely to lead to catatrophic impact for client reputation or eriou financial implication for client and uer.  High Severity  The iue put a large number of uer enitive information at rik, or i reaonably likely to lead to catatrophic impact for client reputation or eriou financial implication for client and uer.  Medium Severity  The iue put a ubet of uer enitive information at rik, would be detrimental for the client reputation if exploited, or i reaonably likely to lead to moderate financial impact.  Low Severity  The rik i relatively mall and could not be exploited on a recurring bai, or i a rik that the client ha indicated it low impact in view of the client buine circumtance.  Note & Additional Information  The rik i relatively mall and could not be exploited on a recurring bai, or i a rik th", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#s", "labels": ["OpenZeppelin"]}, {"title": "Summary", "body": "DeFi  From 2022-04-25  To 2022-05-10  Solidity  13 (13 resolved)  0 (0 resolved)  1 (1 resolved)  1 (1 resolved)  4 (4 resolved)  7 (7 resolved)  Scope  We audited the across-protocol/across-token repository at commit 42130387f81debf2a20d2f7b40d9f0ccc1dcd06a.  In scope were the following contracts:  System Overview  System Overview  The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.  The Across token is an ERC20 compliant token.  The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.  Privileged Roles  Each contract has only one privileged role, which is the contracts respective owner.  The Across tokens owner can mint and burn the token. The owner can also renounce and transfer ownership.  The Across token distributors owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.  Findings  Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any stakedToken at all were actively being staked. Any stakedToken already in the contract would be locked.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input.  Update: Fixed as of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull request #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Low Severity  Incomplete and unindexed events  Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has ", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#summary", "labels": ["OpenZeppelin"]}, {"title": "DeFi", "body": "DeFi", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#defi", "labels": ["OpenZeppelin"]}, {"title": "From 2022-04-25", "body": "From 2022-04-25", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#from-2022-04-25", "labels": ["OpenZeppelin"]}, {"title": "To 2022-05-10", "body": "To 2022-05-10", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#to-2022-05-10", "labels": ["OpenZeppelin"]}, {"title": "Solidity", "body": "Solidity", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#solidity", "labels": ["OpenZeppelin"]}, {"title": "13 (13 resolved)", "body": "13 (13 resolved)", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#13-(13-resolved)", "labels": ["OpenZeppelin"]}, {"title": "0 (0 resolved)", "body": "0 (0 resolved)", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#0-(0-resolved)", "labels": ["OpenZeppelin"]}, {"title": "1 (1 resolved)", "body": "4 (4 resolved)  7 (7 resolved)  Scope  We audited the across-protocol/across-token repository at commit 42130387f81debf2a20d2f7b40d9f0ccc1dcd06a.  In scope were the following contracts:  System Overview  System Overview  The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.  The Across token is an ERC20 compliant token.  The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.  Privileged Roles  Each contract has only one privileged role, which is the contracts respective owner.  The Across tokens owner can mint and burn the token. The owner can also renounce and transfer ownership.  The Across token distributors owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.  Findings  Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any stakedToken at all were actively being staked. Any stakedToken already in the contract would be locked.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input.  Update: Fixed as of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull request #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Low Severity  Incomplete and unindexed events  Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk ", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#1-(1-resolved)", "labels": ["OpenZeppelin"]}, {"title": "4 (4 resolved)", "body": "4 (4 resolved)", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#4-(4-resolved)", "labels": ["OpenZeppelin"]}, {"title": "7 (7 resolved)", "body": "7 (7 resolved)", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#7-(7-resolved)", "labels": ["OpenZeppelin"]}, {"title": "Scope", "body": "We audited the across-protocol/across-token repository at commit 42130387f81debf2a20d2f7b40d9f0ccc1dcd06a.  In scope were the following contracts:  System Overview  System Overview  The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.  The Across token is an ERC20 compliant token.  The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.  Privileged Roles  Each contract has only one privileged role, which is the contracts respective owner.  The Across tokens owner can mint and burn the token. The owner can also renounce and transfer ownership.  The Across token distributors owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.  Findings  Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any stakedToken at all were actively being staked. Any stakedToken already in the contract would be locked.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input.  Update: Fixed as of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull request #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Low Severity  Incomplete and unindexed events  Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be ex", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#scope", "labels": ["OpenZeppelin"]}, {"title": "We audited the\u00a0across-protocol/across-token\u00a0repository at commit\u00a042130387f81debf2a20d2f7b40d9f0ccc1dcd06a.", "body": "We audited the\u00a0across-protocol/across-token\u00a0repository at commit\u00a042130387f81debf2a20d2f7b40d9f0ccc1dcd06a.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#we-audited-the\u00a0across-protocol/across-token\u00a0repository-at-commit\u00a042130387f81debf2a20d2f7b40d9f0ccc1dcd06a.", "labels": ["OpenZeppelin"]}, {"title": "In scope were the following contracts:", "body": "In scope were the following contracts:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#in-scope-were-the-following-contracts:", "labels": ["OpenZeppelin"]}, {"title": "System Overview", "body": "The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.  The Across token is an ERC20 compliant token.  The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.  Privileged Roles  Each contract has only one privileged role, which is the contracts respective owner.  The Across tokens owner can mint and burn the token. The owner can also renounce and transfer ownership.  The Across token distributors owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.  Findings  Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any stakedToken at all were actively being staked. Any stakedToken already in the contract would be locked.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input.  Update: Fixed as of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull request #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Low Severity  Incomplete and unindexed events  Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant conte", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#system-overview", "labels": ["OpenZeppelin"]}, {"title": "The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.", "body": "The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-system-is-composed-of-the-across-token-(acx)-and-the-across-token-distributor.-together,-these-are-meant-to-facilitate-a-liquidity-mining-program-that-will-accompany-the-launch-of-the-most-recent-version-of-the-across-protocol.", "labels": ["OpenZeppelin"]}, {"title": "The Across token is an ERC20 compliant token.", "body": "The Across token is an ERC20 compliant token.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-across-token-is-an-erc20-compliant-token.", "labels": ["OpenZeppelin"]}, {"title": "The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.", "body": "The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-across-token-distributor-allows-users-to-stake-whitelisted-erc20-tokens-(lp-tokens)-to-earn-acx-rewards.-at-deposit-time-depositors-earn-a-fixed-base-emission-rate.-the-longer-depositors-keep-their-tokens-staked,-the-higher-the-reward-rate-they-earn.-the-reward-rate-is-capped-at-a-value-set-by-the-owner-of-the-distributor.-sequential-deposits-result-in-an-average-deposit-time-as-a-weighted-average-of-previous-deposits.-if-at-any-point-the-depositor-claims-their-rewards-or-unstakes-all-lp-tokens,-then-their-rewards-emission-rate-is-reset-to-the-base-rate.-the-contract-is-designed-to-hold-multiple-lp-tokens,-each-with-independent-parameterization-for-liquidity-mining.", "labels": ["OpenZeppelin"]}, {"title": "Privileged Roles", "body": "Each contract has only one privileged role, which is the contracts respective owner.  The Across tokens owner can mint and burn the token. The owner can also renounce and transfer ownership.  The Across token distributors owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.  Findings  Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any stakedToken at all were actively being staked. Any stakedToken already in the contract would be locked.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input.  Update: Fixed as of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull request #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Low Severity  Incomplete and unindexed events  Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#privileged-roles", "labels": ["OpenZeppelin"]}, {"title": "Each contract has only one privileged role, which is the contract\u2019s respective\u00a0owner.", "body": "Each contract has only one privileged role, which is the contract\u2019s respective\u00a0owner.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#each-contract-has-only-one-privileged-role,-which-is-the-contract\u2019s-respective\u00a0owner.", "labels": ["OpenZeppelin"]}, {"title": "The Across token\u2019s owner can mint and burn the token. The owner can also renounce and transfer ownership.", "body": "The Across token\u2019s owner can mint and burn the token. The owner can also renounce and transfer ownership.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-across-token\u2019s-owner-can-mint-and-burn-the-token.-the-owner-can-also-renounce-and-transfer-ownership.", "labels": ["OpenZeppelin"]}, {"title": "The Across token distributor\u2019s owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.", "body": "The Across token distributor\u2019s owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-across-token-distributor\u2019s-owner-can-also-transfer-and-renounce-ownership.-in-addition,-the-owner-is-the-only-account-which-receives-tokens-recovered-from-the-contract,-which-are-comprised-of-tokens-which-were-mistakenly-sent-to-and-are-retrievable-from-the-contract.-finally,-the-owner-can-enable-and-disable-tokens-for-staking-and-change-parameters-of-enabled-lp-tokens.-these-parameters-are-set-per-token-and-include-the-base-acx-emission-rate,-an-emission-rate-cap,-and-time-needed-to-reach-the-emission-rate-cap.", "labels": ["OpenZeppelin"]}, {"title": "Findings", "body": "Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any stakedToken at all were actively being staked. Any stakedToken already in the contract would be locked.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input.  Update: Fixed as of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull request #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Low Severity  Incomplete and unindexed events  Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#findings", "labels": ["OpenZeppelin"]}, {"title": "Here we present our findings.", "body": "Here we present our findings.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#here-we-present-our-findings.", "labels": ["OpenZeppelin"]}, {"title": "High Severity", "body": "High Severity", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#high-severity", "labels": ["OpenZeppelin"]}, {"title": "The issue puts a large number of users\u2019 sensitive information at risk, or is reasonably likely to lead to catastrophic impact for client\u2019s reputation or serious financial implications for client and users.", "body": "The issue puts a large number of users\u2019 sensitive information at risk, or is reasonably likely to lead to catastrophic impact for client\u2019s reputation or serious financial implications for client and users.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-issue-puts-a-large-number-of-users\u2019-sensitive-information-at-risk,-or-is-reasonably-likely-to-lead-to-catastrophic-impact-for-client\u2019s-reputation-or-serious-financial-implications-for-client-and-users.", "labels": ["OpenZeppelin"]}, {"title": "Change of collateral could result in unintended bond value", "body": "The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#change-of-collateral-could-result-in-unintended-bond-value", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission after sensitive actions", "body": "setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#lack-of-event-emission-after-sensitive-actions", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation", "body": "The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Mismatches between UMIP and implementation", "body": "In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#mismatches-between-umip-and-implementation", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0OptimisticGovernor\u00a0contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.", "body": "The\u00a0OptimisticGovernor\u00a0contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0optimisticgovernor\u00a0contract-requires-users-to-provide-a-preconfigured-quantity-of-an-erc20-token-as-bond-to-propose-a-set-of-transactions.-if-the-set-of-transactions-is-rejected,-the-proposer-will-lose-their-bond.", "labels": ["OpenZeppelin"]}, {"title": "To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely\u00a0setBond\u00a0to set the new amount and\u00a0setCollateral\u00a0to set the new ERC20 address of the bond token.", "body": "To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely\u00a0setBond\u00a0to set the new amount and\u00a0setCollateral\u00a0to set the new ERC20 address of the bond token.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-change-the-collateral-token-address-and-its-amount-the-contract-owner-will-generally-have-to-call-two-separate-functions,-namely\u00a0setbond\u00a0to-set-the-new-amount-and\u00a0setcollateral\u00a0to-set-the-new-erc20-address-of-the-bond-token.", "labels": ["OpenZeppelin"]}, {"title": "If the contract owner is an EOA, then\u00a0setBond\u00a0and\u00a0setCollateral\u00a0will be called in two separate transactions which allows a third party to call\u00a0proposeTransactions\u00a0in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.", "body": "If the contract owner is an EOA, then\u00a0setBond\u00a0and\u00a0setCollateral\u00a0will be called in two separate transactions which allows a third party to call\u00a0proposeTransactions\u00a0in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#if-the-contract-owner-is-an-eoa,-then\u00a0setbond\u00a0and\u00a0setcollateral\u00a0will-be-called-in-two-separate-transactions-which-allows-a-third-party-to-call\u00a0proposetransactions\u00a0in-between.-this-will-lead-to-the-creation-of-a-proposal-with-an-unintended-bond-value.-in-fact,-the-realized-bond-could-potentially-have-a-much-lower-value-than-intended.", "labels": ["OpenZeppelin"]}, {"title": "Consider renaming\u00a0setCollateral\u00a0to\u00a0setCollateralAndBond\u00a0and updating both the bond value and the bond token address in the same function call.", "body": "Consider renaming\u00a0setCollateral\u00a0to\u00a0setCollateralAndBond\u00a0and updating both the bond value and the bond token address in the same function call.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-renaming\u00a0setcollateral\u00a0to\u00a0setcollateralandbond\u00a0and-updating-both-the-bond-value-and-the-bond-token-address-in-the-same-function-call.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a05794c2040cc85aced20ef1145aa0329a1c8d8236\u00a0in\u00a0pull request #3912.", "body": "Update:\u00a0Fixed as of commit\u00a05794c2040cc85aced20ef1145aa0329a1c8d8236\u00a0in\u00a0pull request #3912.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a05794c2040cc85aced20ef1145aa0329a1c8d8236\u00a0in\u00a0pull-request-#3912.", "labels": ["OpenZeppelin"]}, {"title": "setUp,", "body": "setUp,", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setup,", "labels": ["OpenZeppelin"]}, {"title": "setBond,", "body": "setBond,", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setbond,", "labels": ["OpenZeppelin"]}, {"title": "setCollateral,", "body": "setCollateral,", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setcollateral,", "labels": ["OpenZeppelin"]}, {"title": "setRules,", "body": "setRules,", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setrules,", "labels": ["OpenZeppelin"]}, {"title": "setLiveness, and", "body": "setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setliveness,-and", "labels": ["OpenZeppelin"]}, {"title": "setIdentifier\u00a0functions do not emit relevant events after executing sensitive actions.", "body": "setIdentifier\u00a0functions do not emit relevant events after executing sensitive actions.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setidentifier\u00a0functions-do-not-emit-relevant-events-after-executing-sensitive-actions.", "labels": ["OpenZeppelin"]}, {"title": "Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts\u2019 activity.", "body": "Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts\u2019 activity.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-emitting-events-after-sensitive-changes-take-place-(including-in-the-constructor-and/or-initializer),-to-facilitate-tracking-and-notify-off-chain-clients-following-the-contracts\u2019-activity.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0f6c3d17ae9e31d2f337d3f887647731959096663\u00a0in\u00a0pull request #3913\u00a0and commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull request #3914.", "body": "Update:\u00a0Fixed as of commit\u00a0f6c3d17ae9e31d2f337d3f887647731959096663\u00a0in\u00a0pull request #3913\u00a0and commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull request #3914.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0f6c3d17ae9e31d2f337d3f887647731959096663\u00a0in\u00a0pull-request-#3913\u00a0and-commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull-request-#3914.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0OptimisticGovernor\u00a0contract has a general lack of input validation. For instance, the\u00a0setUp\u00a0function does not validate that the\u00a0_finder\u00a0argument is non-zero, which can lead to a non-functional module instance. Nor does\u00a0setUp\u00a0validate that the\u00a0_rules\u00a0argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.", "body": "The\u00a0OptimisticGovernor\u00a0contract has a general lack of input validation. For instance, the\u00a0setUp\u00a0function does not validate that the\u00a0_finder\u00a0argument is non-zero, which can lead to a non-functional module instance. Nor does\u00a0setUp\u00a0validate that the\u00a0_rules\u00a0argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0optimisticgovernor\u00a0contract-has-a-general-lack-of-input-validation.-for-instance,-the\u00a0setup\u00a0function-does-not-validate-that-the\u00a0_finder\u00a0argument-is-non-zero,-which-can-lead-to-a-non-functional-module-instance.-nor-does\u00a0setup\u00a0validate-that-the\u00a0_rules\u00a0argument-is-non-empty,-which-could-lead-to-a-loss-of-funds-if-optimistic-governance-proposals-are-the-sole-way-to-manage-an-avatar.", "labels": ["OpenZeppelin"]}, {"title": "In the same function,\u00a0_liveness\u00a0is checked to be greater than zero, in line with the Optimistic Oracle\u2019s\u00a0lower bound\u00a0requirement. However,\u00a0setUp\u00a0does not check that\u00a0_liveness\u00a0is less than 5200 weeks, which is the Optimistic Oracle\u2019s\u00a0upper bound\u00a0requirement.", "body": "In the same function,\u00a0_liveness\u00a0is checked to be greater than zero, in line with the Optimistic Oracle\u2019s\u00a0lower bound\u00a0requirement. However,\u00a0setUp\u00a0does not check that\u00a0_liveness\u00a0is less than 5200 weeks, which is the Optimistic Oracle\u2019s\u00a0upper bound\u00a0requirement.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-the-same-function,\u00a0_liveness\u00a0is-checked-to-be-greater-than-zero,-in-line-with-the-optimistic-oracle\u2019s\u00a0lower-bound\u00a0requirement.-however,\u00a0setup\u00a0does-not-check-that\u00a0_liveness\u00a0is-less-than-5200-weeks,-which-is-the-optimistic-oracle\u2019s\u00a0upper-bound\u00a0requirement.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0setLiveness\u00a0and\u00a0setRules\u00a0functions have the same sort of lacking input validation as\u00a0setUp\u00a0does.", "body": "The\u00a0setLiveness\u00a0and\u00a0setRules\u00a0functions have the same sort of lacking input validation as\u00a0setUp\u00a0does.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0setliveness\u00a0and\u00a0setrules\u00a0functions-have-the-same-sort-of-lacking-input-validation-as\u00a0setup\u00a0does.", "labels": ["OpenZeppelin"]}, {"title": "Both the\u00a0setUp\u00a0and\u00a0setBond\u00a0functions allow a zero bond, which the\u00a0OptimisticOracle\u00a0will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.", "body": "Both the\u00a0setUp\u00a0and\u00a0setBond\u00a0functions allow a zero bond, which the\u00a0OptimisticOracle\u00a0will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#both-the\u00a0setup\u00a0and\u00a0setbond\u00a0functions-allow-a-zero-bond,-which-the\u00a0optimisticoracle\u00a0will-accept.-however,-because-of-the-overall-lack-of-input-validation,-it-becomes-difficult-to-discern-if-a-zero-bond-is-a-legitimately-acceptable-value-or-simply-an-oversight-of-the-validation-logic.", "labels": ["OpenZeppelin"]}, {"title": "To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.", "body": "To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-avoid-errors-and-unexpected-system-behavior,-consider-implementing-require-statements-to-validate-all-user-controlled-input.-where-zero-values-are-acceptable,-consider-leaving-inline-documentation-to-that-effect-to-avoid-ambiguity.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0661b984edcbab12b7e0ed9f9e9739169cb732c33\u00a0in\u00a0pull request #3915, commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull request #3914, commit\u00a055e8f77e748619052b885ce191fee18984a44f29\u00a0in\u00a0pull request #3950\u00a0and commit\u00a0f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe\u00a0in\u00a0pull request #3962.", "body": "Update:\u00a0Fixed as of commit\u00a0661b984edcbab12b7e0ed9f9e9739169cb732c33\u00a0in\u00a0pull request #3915, commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull request #3914, commit\u00a055e8f77e748619052b885ce191fee18984a44f29\u00a0in\u00a0pull request #3950\u00a0and commit\u00a0f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe\u00a0in\u00a0pull request #3962.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0661b984edcbab12b7e0ed9f9e9739169cb732c33\u00a0in\u00a0pull-request-#3915,-commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull-request-#3914,-commit\u00a055e8f77e748619052b885ce191fee18984a44f29\u00a0in\u00a0pull-request-#3950\u00a0and-commit\u00a0f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe\u00a0in\u00a0pull-request-#3962.", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0UMIP-152, the documentation of several data structures is significantly different from their implementation in\u00a0OptmisticGovenor.sol.", "body": "In\u00a0UMIP-152, the documentation of several data structures is significantly different from their implementation in\u00a0OptmisticGovenor.sol.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in\u00a0umip-152,-the-documentation-of-several-data-structures-is-significantly-different-from-their-implementation-in\u00a0optmisticgovenor.sol.", "labels": ["OpenZeppelin"]}, {"title": "Differences can be found in the\u00a0Transaction\u00a0and\u00a0Proposal\u00a0structs as well as the data format of\u00a0ancilliaryData.", "body": "Differences can be found in the\u00a0Transaction\u00a0and\u00a0Proposal\u00a0structs as well as the data format of\u00a0ancilliaryData.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#differences-can-be-found-in-the\u00a0transaction\u00a0and\u00a0proposal\u00a0structs-as-well-as-the-data-format-of\u00a0ancilliarydata.", "labels": ["OpenZeppelin"]}, {"title": "Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the\u00a0module\u00a0address from\u00a0ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.", "body": "Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the\u00a0module\u00a0address from\u00a0ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-updating-the-documentation-to-correspond-to-the-implementation.-additionally,-in-light-of-the-removal-of-the\u00a0module\u00a0address-from\u00a0ancilliarydata,-consider-adding-further-documentation-to-explain-how-uniqueness-of-a-proposal-identifier-across-all-users-of-the-optimistic-oracle-is-maintained.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0not fixed, UMA\u2019s reply: \u201cwill be fixed in separate PR updating the UMIP after code is finalized\u201d.", "body": "Update:\u00a0not fixed, UMA\u2019s reply: \u201cwill be fixed in separate PR updating the UMIP after code is finalized\u201d.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0not-fixed,-uma\u2019s-reply:-\u201cwill-be-fixed-in-separate-pr-updating-the-umip-after-code-is-finalized\u201d.", "labels": ["OpenZeppelin"]}, {"title": "Low Severity", "body": "Low Severity", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#low-severity", "labels": ["OpenZeppelin"]}, {"title": "Events lacking information", "body": "We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#events-lacking-information", "labels": ["OpenZeppelin"]}, {"title": "We identified two events which could benefit from being more complete. Specifically, the\u00a0ProposalDeleted\u00a0and\u00a0TransactionsProposed\u00a0events.", "body": "We identified two events which could benefit from being more complete. Specifically, the\u00a0ProposalDeleted\u00a0and\u00a0TransactionsProposed\u00a0events.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#we-identified-two-events-which-could-benefit-from-being-more-complete.-specifically,-the\u00a0proposaldeleted\u00a0and\u00a0transactionsproposed\u00a0events.", "labels": ["OpenZeppelin"]}, {"title": "Currently,\u00a0ProposalDeleted\u00a0event emissions have an ambiguous interpretation. This is because such emissions can originate from either the\u00a0deleteRejectedProposal\u00a0function or the\u00a0deleteProposal\u00a0function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the\u00a0msg.sender\u00a0when a proposal is deleted.", "body": "Currently,\u00a0ProposalDeleted\u00a0event emissions have an ambiguous interpretation. This is because such emissions can originate from either the\u00a0deleteRejectedProposal\u00a0function or the\u00a0deleteProposal\u00a0function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the\u00a0msg.sender\u00a0when a proposal is deleted.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#currently,\u00a0proposaldeleted\u00a0event-emissions-have-an-ambiguous-interpretation.-this-is-because-such-emissions-can-originate-from-either-the\u00a0deleterejectedproposal\u00a0function-or-the\u00a0deleteproposal\u00a0function-under-different-circumstances.-to-reduce-ambiguity,-consider-augmenting-the-event-so-that-it-also-emits-details-about-the-proposal-status-and-the\u00a0msg.sender\u00a0when-a-proposal-is-deleted.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0TransactionsProposed\u00a0event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.", "body": "The\u00a0TransactionsProposed\u00a0event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0transactionsproposed\u00a0event-currently-emits-the-time-at-which-a-proposal-is-created,-but-it-does-not-emit-the-liveness-time-the-proposal-is-subject-to-or-a-timestamp-that-indicates-when-the-proposal-needs-to-be-disputed-by.-as-this-is-likely-to-be-of-interest-at-the-time-a-proposal-is-created,-consider-emitting-enough-information-to-determine-when-a-proposal-must-be-disputed-by.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0c3ae271a3e9a10dd69fe33ef44417633e53043ec\u00a0in\u00a0pull request #3916.", "body": "Update:\u00a0Fixed as of commit\u00a0c3ae271a3e9a10dd69fe33ef44417633e53043ec\u00a0in\u00a0pull request #3916.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0c3ae271a3e9a10dd69fe33ef44417633e53043ec\u00a0in\u00a0pull-request-#3916.", "labels": ["OpenZeppelin"]}, {"title": "Duplicated code", "body": "There are instances of duplicated code within the codebase.  can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#duplicated-code", "labels": ["OpenZeppelin"]}, {"title": "There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.", "body": "There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#there-are-instances-of-duplicated-code-within-the-codebase.-duplicated-code-can-lead-to-issues-later-in-the-development-lifecycle-and-leaves-the-project-more-prone-to-the-introduction-of-errors-later-if-functionality-changes-are-not-replicated-across-all-instances-of-code-that-should-be-identical.", "labels": ["OpenZeppelin"]}, {"title": "Within the\u00a0OptimisticGovernor\u00a0contract the\u00a0setUp\u00a0function repeats code found in\u00a0several of the\u00a0set*\u00a0\u201csetter\u201d functions.", "body": "Within the\u00a0OptimisticGovernor\u00a0contract the\u00a0setUp\u00a0function repeats code found in\u00a0several of the\u00a0set*\u00a0\u201csetter\u201d functions.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#within-the\u00a0optimisticgovernor\u00a0contract-the\u00a0setup\u00a0function-repeats-code-found-in\u00a0several-of-the\u00a0set*\u00a0\u201csetter\u201d-functions.", "labels": ["OpenZeppelin"]}, {"title": "Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.", "body": "Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#rather-than-duplicating-code,-consider-reusing-existing-functions-as-needed-or-having-just-one-contract-or-library-containing-the-duplicated-code-and-using-it-whenever-the-duplicated-functionality-is-required.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull request #3914.", "body": "Update:\u00a0Fixed as of commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull request #3914.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull-request-#3914.", "labels": ["OpenZeppelin"]}, {"title": "Misleading inline documentation", "body": "There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#misleading-inline-documentation", "labels": ["OpenZeppelin"]}, {"title": "There are instances of misleading or imprecise documentation throughout the codebase.", "body": "There are instances of misleading or imprecise documentation throughout the codebase.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#there-are-instances-of-misleading-or-imprecise-documentation-throughout-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "In particular, in\u00a0OptimisticGovernor.sol:", "body": "In particular, in\u00a0OptimisticGovernor.sol:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-particular,-in\u00a0optimisticgovernor.sol:", "labels": ["OpenZeppelin"]}, {"title": "The public\u00a0sync\u00a0function has a comment beneath it that reads, \u201cSync the oracle contract addresses as well as the final fee.\u201d In fact, the function merely makes a call to the internal\u00a0_sync\u00a0function that then sets only the\u00a0optimisticOracle\u00a0address. No other address or final fee value is stored.", "body": "The public\u00a0sync\u00a0function has a comment beneath it that reads, \u201cSync the oracle contract addresses as well as the final fee.\u201d In fact, the function merely makes a call to the internal\u00a0_sync\u00a0function that then sets only the\u00a0optimisticOracle\u00a0address. No other address or final fee value is stored.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-public\u00a0sync\u00a0function-has-a-comment-beneath-it-that-reads,-\u201csync-the-oracle-contract-addresses-as-well-as-the-final-fee.\u201d-in-fact,-the-function-merely-makes-a-call-to-the-internal\u00a0_sync\u00a0function-that-then-sets-only-the\u00a0optimisticoracle\u00a0address.-no-other-address-or-final-fee-value-is-stored.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 69\u00a0the NatSpec states, \u201cBond required (must be at least as large as final fee for collateral type)\u201d. However, there is no comparison made.", "body": "On\u00a0line 69\u00a0the NatSpec states, \u201cBond required (must be at least as large as final fee for collateral type)\u201d. However, there is no comparison made.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-69\u00a0the-natspec-states,-\u201cbond-required-(must-be-at-least-as-large-as-final-fee-for-collateral-type)\u201d.-however,-there-is-no-comparison-made.", "labels": ["OpenZeppelin"]}, {"title": "The NatSpec of the\u00a0_originalTime\u00a0parameter of the\u00a0deleteRejectedProposal\u00a0function is a copy paste error from the line above describing the\u00a0_proposalId\u00a0parameter.", "body": "The NatSpec of the\u00a0_originalTime\u00a0parameter of the\u00a0deleteRejectedProposal\u00a0function is a copy paste error from the line above describing the\u00a0_proposalId\u00a0parameter.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-natspec-of-the\u00a0_originaltime\u00a0parameter-of-the\u00a0deleterejectedproposal\u00a0function-is-a-copy-paste-error-from-the-line-above-describing-the\u00a0_proposalid\u00a0parameter.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 246\u00a0and\u00a0line 279\u00a0there is an inline comment that reads, \u201cThis will revert if the price has not settled\u201d. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.", "body": "On\u00a0line 246\u00a0and\u00a0line 279\u00a0there is an inline comment that reads, \u201cThis will revert if the price has not settled\u201d. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-246\u00a0and\u00a0line-279\u00a0there-is-an-inline-comment-that-reads,-\u201cthis-will-revert-if-the-price-has-not-settled\u201d.-this-is-not-as-nuanced-as-it-could-be.-the-calls-the-comments-refer-to-will-revert-if-the-price-has-not-and-can-not-currently-be-settled;-the-calls-can-actually-settle-the-the-request-if-the-price-has-not-yet-been-settled-but-is-settle-able.", "labels": ["OpenZeppelin"]}, {"title": "Additionally, in\u00a0OptimisticOracle.sol:", "body": "Additionally, in\u00a0OptimisticOracle.sol:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#additionally,-in\u00a0optimisticoracle.sol:", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 172\u00a0the comment explains the inequality check that follows as: \u201cThis ensures that the ancillary data is below the OO limit\u201d. In fact, the inequality test that the ancillary data is less than\u00a0or equal to\u00a0the Optimistic Oracle (OO) ancillary data limit.", "body": "On\u00a0line 172\u00a0the comment explains the inequality check that follows as: \u201cThis ensures that the ancillary data is below the OO limit\u201d. In fact, the inequality test that the ancillary data is less than\u00a0or equal to\u00a0the Optimistic Oracle (OO) ancillary data limit.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-172\u00a0the-comment-explains-the-inequality-check-that-follows-as:-\u201cthis-ensures-that-the-ancillary-data-is-below-the-oo-limit\u201d.-in-fact,-the-inequality-test-that-the-ancillary-data-is-less-than\u00a0or-equal-to\u00a0the-optimistic-oracle-(oo)-ancillary-data-limit.", "labels": ["OpenZeppelin"]}, {"title": "Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.", "body": "Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#clear-inline-documentation-is-fundamental-to-outline-the-intentions-of-the-code.-mismatches-between-them-and-the-implementation-can-lead-to-serious-misconceptions-about-how-the-system-is-expected-to-behave.-therefore,-consider-fixing-these-errors-to-avoid-potential-confusion-for-developers,-users,-auditors-alike.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a06a3e00d72832e663f191920a796b5cbe52aea774\u00a0in\u00a0pull request #3917\u00a0and commit\u00a0d1a6421e4331861708a5f5bb7b20072d042d17ff\u00a0in\u00a0pull request #3963.", "body": "Update:\u00a0Fixed as of commit\u00a06a3e00d72832e663f191920a796b5cbe52aea774\u00a0in\u00a0pull request #3917\u00a0and commit\u00a0d1a6421e4331861708a5f5bb7b20072d042d17ff\u00a0in\u00a0pull request #3963.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a06a3e00d72832e663f191920a796b5cbe52aea774\u00a0in\u00a0pull-request-#3917\u00a0and-commit\u00a0d1a6421e4331861708a5f5bb7b20072d042d17ff\u00a0in\u00a0pull-request-#3963.", "labels": ["OpenZeppelin"]}, {"title": "Proposals can be deleted repeatedly", "body": "In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#proposals-can-be-deleted-repeatedly", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0OptimisticGovernor\u00a0contract there is no check that a proposal exists before it is deleted with the\u00a0deleteProposal\u00a0function. Similarly, a rejected proposal can be deleted repeatedly via the\u00a0deleteRejectedProposal\u00a0function.", "body": "In the\u00a0OptimisticGovernor\u00a0contract there is no check that a proposal exists before it is deleted with the\u00a0deleteProposal\u00a0function. Similarly, a rejected proposal can be deleted repeatedly via the\u00a0deleteRejectedProposal\u00a0function.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-the\u00a0optimisticgovernor\u00a0contract-there-is-no-check-that-a-proposal-exists-before-it-is-deleted-with-the\u00a0deleteproposal\u00a0function.-similarly,-a-rejected-proposal-can-be-deleted-repeatedly-via-the\u00a0deleterejectedproposal\u00a0function.", "labels": ["OpenZeppelin"]}, {"title": "Although there is no clear economic incentive to do delete a proposal numerous times \u2013 in fact it will waste gas \u2013 the repeated emission of identical\u00a0ProposalDeleted\u00a0events could be confusing for parties monitoring for such events.", "body": "Although there is no clear economic incentive to do delete a proposal numerous times \u2013 in fact it will waste gas \u2013 the repeated emission of identical\u00a0ProposalDeleted\u00a0events could be confusing for parties monitoring for such events.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#although-there-is-no-clear-economic-incentive-to-do-delete-a-proposal-numerous-times-\u2013-in-fact-it-will-waste-gas-\u2013-the-repeated-emission-of-identical\u00a0proposaldeleted\u00a0events-could-be-confusing-for-parties-monitoring-for-such-events.", "labels": ["OpenZeppelin"]}, {"title": "Consider allowing proposals to be deleted only if they have not already been deleted.", "body": "Consider allowing proposals to be deleted only if they have not already been deleted.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-allowing-proposals-to-be-deleted-only-if-they-have-not-already-been-deleted.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0deeb7386be6d1f14c8999fe5316c9feb80b5d0d2\u00a0in\u00a0pull request #3918.", "body": "Update:\u00a0Fixed as of commit\u00a0deeb7386be6d1f14c8999fe5316c9feb80b5d0d2\u00a0in\u00a0pull request #3918.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0deeb7386be6d1f14c8999fe5316c9feb80b5d0d2\u00a0in\u00a0pull-request-#3918.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0deleteProposal\u00a0function may not work as expected with all avatars", "body": "The\u00a0deleteProposal\u00a0function may not work as expected with all avatars", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0deleteproposal\u00a0function-may-not-work-as-expected-with-all-avatars", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0deleteProposal\u00a0function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the\u00a0OptimisticGovernor\u00a0contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.", "body": "The\u00a0deleteProposal\u00a0function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the\u00a0OptimisticGovernor\u00a0contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0deleteproposal\u00a0function-allows-the-owner-to-delete-a-particular-proposal-so-that-it-will-not-be-executed.-in-the-current-implementation-of-the\u00a0optimisticgovernor\u00a0contract-the-owner-and-the-avatar-are-the-same-address.-in-general,-an-avatar-does-not-necessarily-have-the-ability-to-send-arbitrary-transactions-without-having-enabled-some-module-specifically-for-this-purpose.", "labels": ["OpenZeppelin"]}, {"title": "If an avatar were to have only the\u00a0OptimisticGovernor\u00a0module enabled, then it could not initiate a transaction in any way other than calling the\u00a0proposeTransactions\u00a0function. However, in this case the\u00a0deleteProposal\u00a0function would not work as expected.", "body": "If an avatar were to have only the\u00a0OptimisticGovernor\u00a0module enabled, then it could not initiate a transaction in any way other than calling the\u00a0proposeTransactions\u00a0function. However, in this case the\u00a0deleteProposal\u00a0function would not work as expected.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#if-an-avatar-were-to-have-only-the\u00a0optimisticgovernor\u00a0module-enabled,-then-it-could-not-initiate-a-transaction-in-any-way-other-than-calling-the\u00a0proposetransactions\u00a0function.-however,-in-this-case-the\u00a0deleteproposal\u00a0function-would-not-work-as-expected.", "labels": ["OpenZeppelin"]}, {"title": "Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:", "body": "Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-a-scenario-where-an-owner-would-like-to-delete-an-existing-proposal-via-creating-a-new-proposal:", "labels": ["OpenZeppelin"]}, {"title": "If the owner creates a proposal to call\u00a0deleteProposal\u00a0via\u00a0proposeTransactions, then the expiration time of the\u00a0deleteProposal\u00a0proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.", "body": "If the owner creates a proposal to call\u00a0deleteProposal\u00a0via\u00a0proposeTransactions, then the expiration time of the\u00a0deleteProposal\u00a0proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#if-the-owner-creates-a-proposal-to-call\u00a0deleteproposal\u00a0via\u00a0proposetransactions,-then-the-expiration-time-of-the\u00a0deleteproposal\u00a0proposal-will-be-greater-than-expire-time-of-the-original-proposal-which-the-owner-wished-to-delete.-thus-the-owner-would-not-be-guaranteed-to-be-able-delete-the-original-proposal-because-it-could-be-executed-before-the-deletion-proposal-passed-the-liveness-threshold.", "labels": ["OpenZeppelin"]}, {"title": "If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal \u201ctechnically\u201d followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.", "body": "If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal \u201ctechnically\u201d followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#if-the-owner-wanted-to-dispute-the-proposal-they-were-trying-to-delete,-then-they-could-do-so.-but-the-assumption-that-only-proposals-which-break-the-rules-may-not-alway-hold.-additionally,-if-the-proposal-\u201ctechnically\u201d-followed-the-rules,-but-only-elucidated-how-the-rules-themselves-needed-to-be-updated,-any-such-rule-update-proposal-would-also-run-into-the-same-sort-of-liveness-delay-dilemma.", "labels": ["OpenZeppelin"]}, {"title": "Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an\u00a0OptimisticGovernor\u00a0module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.", "body": "Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an\u00a0OptimisticGovernor\u00a0module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-better-documenting-assumptions-about-the-capabilities-of-the-avatar-and-what-may-happen-if-those-assumptions-do-not-hold.-additionally,-if-having-an-avatar-exclusively-controlled-by-an\u00a0optimisticgovernor\u00a0module-is-a-reasonable-use-case,-then-consider-allowing-some-other-form-of-proposal-deletion-capabilities-that-can-bypass-the-standard-liveness-condition-in-case-of-emergencies.", "labels": ["OpenZeppelin"]}, {"title": "Notes & Additional Information", "body": "Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#notes-&-additional-information", "labels": ["OpenZeppelin"]}, {"title": "Commented out code", "body": "The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#commented-out-code", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0proposeTransactions\u00a0and\u00a0executeProposal\u00a0functions in the\u00a0OptimisticGovernor\u00a0contract include commented out lines of code.", "body": "The\u00a0proposeTransactions\u00a0and\u00a0executeProposal\u00a0functions in the\u00a0OptimisticGovernor\u00a0contract include commented out lines of code.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0proposetransactions\u00a0and\u00a0executeproposal\u00a0functions-in-the\u00a0optimisticgovernor\u00a0contract-include-commented-out-lines-of-code.", "labels": ["OpenZeppelin"]}, {"title": "As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.", "body": "As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#as-the-purpose-of-these-lines-is-unclear-and-may-confuse-future-developers-and-external-contributors,-consider-removing-them-from-the-codebase.-if-they-are-meant-to-provide-alternate-implementation-options,-then-consider-extracting-them-to-a-separate-document-where-they-can-be-accompanied-by-a-more-thorough-explanation-of-their-purpose.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0e35c199cc774066c4b65bcec8f82cffcc5aeabd4\u00a0in\u00a0pull request #3919.", "body": "Update:\u00a0Fixed as of commit\u00a0e35c199cc774066c4b65bcec8f82cffcc5aeabd4\u00a0in\u00a0pull request #3919.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0e35c199cc774066c4b65bcec8f82cffcc5aeabd4\u00a0in\u00a0pull-request-#3919.", "labels": ["OpenZeppelin"]}, {"title": "Coding style deviates from Solidity Style Guide", "body": "Coding style deviates from Solidity Style Guide", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#coding-style-deviates-from-solidity-style-guide", "labels": ["OpenZeppelin"]}, {"title": "OptimisticGovernor\u00a0contract the", "body": "OptimisticGovernor\u00a0contract the", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#optimisticgovernor\u00a0contract-the", "labels": ["OpenZeppelin"]}, {"title": "_getOptimisticOracle\u00a0and", "body": "_getOptimisticOracle\u00a0and", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#_getoptimisticoracle\u00a0and", "labels": ["OpenZeppelin"]}, {"title": "_isContract\u00a0functions are declared", "body": "_isContract\u00a0functions are declared", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#_iscontract\u00a0functions-are-declared", "labels": ["OpenZeppelin"]}, {"title": "internal\u00a0functions.", "body": "internal\u00a0functions.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#internal\u00a0functions.", "labels": ["OpenZeppelin"]}, {"title": "This function order deviates from the\u00a0recommended order of: constructor, receive, fallback, external, public, internal, private.", "body": "This function order deviates from the\u00a0recommended order of: constructor, receive, fallback, external, public, internal, private.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#this-function-order-deviates-from-the\u00a0recommended-order-of:-constructor,-receive,-fallback,-external,-public,-internal,-private.", "labels": ["OpenZeppelin"]}, {"title": "To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.", "body": "To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-increase-overall-code-readability,-consider-reordering-these-functions-and-conforming-to-the-solidity-style-guide-where-possible.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0e35c199cc774066c4b65bcec8f82cffcc5aeabd4\u00a0in\u00a0pull request #3920.", "body": "Update:\u00a0Fixed as of commit\u00a0e35c199cc774066c4b65bcec8f82cffcc5aeabd4\u00a0in\u00a0pull request #3920.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0e35c199cc774066c4b65bcec8f82cffcc5aeabd4\u00a0in\u00a0pull-request-#3920.", "labels": ["OpenZeppelin"]}, {"title": "Disabling reentrancy protection is prone to error", "body": "In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#disabling-reentrancy-protection-is-prone-to-error", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0OptimisticOracle\u00a0contract all external functions are protected with a\u00a0nonReentrant\u00a0modifier. However, in designated places the user is allowed to perform a callback into the\u00a0OptimisticOracle\u00a0contract. This is achieved via the functions\u00a0_startReentrantGuardDisabled\u00a0and\u00a0_endReentrantGuardDisabled\u00a0which temporarily disables and manually re-enables reentrancy protection, respectively.", "body": "In the\u00a0OptimisticOracle\u00a0contract all external functions are protected with a\u00a0nonReentrant\u00a0modifier. However, in designated places the user is allowed to perform a callback into the\u00a0OptimisticOracle\u00a0contract. This is achieved via the functions\u00a0_startReentrantGuardDisabled\u00a0and\u00a0_endReentrantGuardDisabled\u00a0which temporarily disables and manually re-enables reentrancy protection, respectively.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-the\u00a0optimisticoracle\u00a0contract-all-external-functions-are-protected-with-a\u00a0nonreentrant\u00a0modifier.-however,-in-designated-places-the-user-is-allowed-to-perform-a-callback-into-the\u00a0optimisticoracle\u00a0contract.-this-is-achieved-via-the-functions\u00a0_startreentrantguarddisabled\u00a0and\u00a0_endreentrantguarddisabled\u00a0which-temporarily-disables-and-manually-re-enables-reentrancy-protection,-respectively.", "labels": ["OpenZeppelin"]}, {"title": "These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.", "body": "These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#these-functions-must-be-used-in-pairs-to-perform-as-expected;-that-process-is-manual-and-potentially-error-prone.", "labels": ["OpenZeppelin"]}, {"title": "To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching\u00a0_start\u00a0and\u00a0_end\u00a0functions and for containment within a function that uses a\u00a0nonReentrant\u00a0modifier.", "body": "To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching\u00a0_start\u00a0and\u00a0_end\u00a0functions and for containment within a function that uses a\u00a0nonReentrant\u00a0modifier.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-reduce-the-likelihood-of-error,-consider-including-a-continuous-integration-or-custom-linter-check-for-pairwise-matching\u00a0_start\u00a0and\u00a0_end\u00a0functions-and-for-containment-within-a-function-that-uses-a\u00a0nonreentrant\u00a0modifier.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0acknowledged by UMA: \u201cThis sort of linting would be helpful, but at the moment, it\u2019s unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.\u201d; no immediate code changes are needed.", "body": "Update:\u00a0acknowledged by UMA: \u201cThis sort of linting would be helpful, but at the moment, it\u2019s unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.\u201d; no immediate code changes are needed.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0acknowledged-by-uma:-\u201cthis-sort-of-linting-would-be-helpful,-but-at-the-moment,-it\u2019s-unclear-how-something-like-this-could-be-implemented-without-a-linter-that-can-interpret-solidity-that-also-supports-custom-plugins.\u201d;-no-immediate-code-changes-are-needed.", "labels": ["OpenZeppelin"]}, {"title": "immutable\u00a0value could be used", "body": "immutable\u00a0value could be used", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#immutable\u00a0value-could-be-used", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0OptimisticGovernor\u00a0contract the\u00a0finder\u00a0variable is only ever\u00a0set in the\u00a0setUp\u00a0initialization function. The value is not modifiable after deployment.", "body": "In the\u00a0OptimisticGovernor\u00a0contract the\u00a0finder\u00a0variable is only ever\u00a0set in the\u00a0setUp\u00a0initialization function. The value is not modifiable after deployment.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-the\u00a0optimisticgovernor\u00a0contract-the\u00a0finder\u00a0variable-is-only-ever\u00a0set-in-the\u00a0setup\u00a0initialization-function.-the-value-is-not-modifiable-after-deployment.", "labels": ["OpenZeppelin"]}, {"title": "In practice, the\u00a0finder\u00a0implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their\u00a0finder\u00a0values. Then, if users do wish to migrate to the new\u00a0finder\u00a0address, they will\u00a0need to deploy a new\u00a0OptimisticGovernor\u00a0module anyway.", "body": "In practice, the\u00a0finder\u00a0implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their\u00a0finder\u00a0values. Then, if users do wish to migrate to the new\u00a0finder\u00a0address, they will\u00a0need to deploy a new\u00a0OptimisticGovernor\u00a0module anyway.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-practice,-the\u00a0finder\u00a0implementation-may-generally-be-modified-solely-by-the-uma-team.-only-after-such-an-update-to-the-implementation-would-users-want-to-update-their\u00a0finder\u00a0values.-then,-if-users-do-wish-to-migrate-to-the-new\u00a0finder\u00a0address,-they-will\u00a0need-to-deploy-a-new\u00a0optimisticgovernor\u00a0module-anyway.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a07aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c\u00a0in\u00a0pull request #3921.", "body": "Update:\u00a0Fixed as of commit\u00a07aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c\u00a0in\u00a0pull request #3921.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a07aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c\u00a0in\u00a0pull-request-#3921.", "labels": ["OpenZeppelin"]}, {"title": "Some\u00a0public\u00a0functions could be\u00a0external", "body": "Some\u00a0public\u00a0functions could be\u00a0external", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#some\u00a0public\u00a0functions-could-be\u00a0external", "labels": ["OpenZeppelin"]}, {"title": "setIdentifier\u00a0functions are marked", "body": "setIdentifier\u00a0functions are marked", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setidentifier\u00a0functions-are-marked", "labels": ["OpenZeppelin"]}, {"title": "Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.", "body": "Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-declaring-functions-with-only-the-most-restrictive-visibility-required-to-reduce-the-overall-surface-for-error-and-better-reflect-intent.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a03fdebf2d48263f5ec9a73255853874535141e220\u00a0in\u00a0pull request #3922.", "body": "Update:\u00a0Fixed as of commit\u00a03fdebf2d48263f5ec9a73255853874535141e220\u00a0in\u00a0pull request #3922.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a03fdebf2d48263f5ec9a73255853874535141e220\u00a0in\u00a0pull-request-#3922.", "labels": ["OpenZeppelin"]}, {"title": "Suboptimal\u00a0struct\u00a0packing", "body": "Suboptimal\u00a0struct\u00a0packing", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#suboptimal\u00a0struct\u00a0packing", "labels": ["OpenZeppelin"]}, {"title": "Transaction", "body": "s in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the  and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and sProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The sProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposes function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposes, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposes and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the    member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposes function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#transaction", "labels": ["OpenZeppelin"]}, {"title": "member labeled\u00a0operation. This member is implicitly of type", "body": "member labeled\u00a0operation. This member is implicitly of type", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#member-labeled\u00a0operation.-this-member-is-implicitly-of-type", "labels": ["OpenZeppelin"]}, {"title": "to\u00a0in order to take advantage of more efficient", "body": "to\u00a0in order to take advantage of more efficient", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to\u00a0in-order-to-take-advantage-of-more-efficient", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0556cd89217c3b96dde2f6dfc394f67a0742e48b3\u00a0in\u00a0pull request #3923.", "body": "Update:\u00a0Fixed as of commit\u00a0556cd89217c3b96dde2f6dfc394f67a0742e48b3\u00a0in\u00a0pull request #3923.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0556cd89217c3b96dde2f6dfc394f67a0742e48b3\u00a0in\u00a0pull-request-#3923.", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "The codebase contains the following typographical errors:", "body": "The codebase contains the following typographical errors:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-codebase-contains-the-following-typographical-errors:", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0OptimisticGovernor.sol:", "body": "On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in\u00a0optimisticgovernor.sol:", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 37,\u00a0address need to\u00a0should be\u00a0address needs to.", "body": "On\u00a0line 37,\u00a0address need to\u00a0should be\u00a0address needs to.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-37,\u00a0address-need-to\u00a0should-be\u00a0address-needs-to.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 167,\u00a0proposals\u00a0should be\u00a0proposal's.", "body": "On\u00a0line 167,\u00a0proposals\u00a0should be\u00a0proposal's.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-167,\u00a0proposals\u00a0should-be\u00a0proposal's.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 292,\u00a0overriden\u00a0should be\u00a0overridden.", "body": "On\u00a0line 292,\u00a0overriden\u00a0should be\u00a0overridden.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-292,\u00a0overriden\u00a0should-be\u00a0overridden.", "labels": ["OpenZeppelin"]}, {"title": "Consider correcting these typos to improve the overall readability of the codebase.", "body": "Consider correcting these typos to improve the overall readability of the codebase.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-correcting-these-typos-to-improve-the-overall-readability-of-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0745a64aeb0c0b61b214931310d08fbe8ac155f0f\u00a0in\u00a0pull request #3924.", "body": "Update:\u00a0Fixed as of commit\u00a0745a64aeb0c0b61b214931310d08fbe8ac155f0f\u00a0in\u00a0pull request #3924.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0745a64aeb0c0b61b214931310d08fbe8ac155f0f\u00a0in\u00a0pull-request-#3924.", "labels": ["OpenZeppelin"]}, {"title": "Undocumented implicit approval requirements", "body": "In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#undocumented-implicit-approval-requirements", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0OptimisticGovernor\u00a0contract, the\u00a0proposeTransactions\u00a0function implicitly assumes that it has been granted an appropriate allowance of\u00a0collateral\u00a0tokens from the\u00a0proposer\u00a0when it attempts to\u00a0safeTransferFrom\u00a0the\u00a0totalBond.", "body": "In the\u00a0OptimisticGovernor\u00a0contract, the\u00a0proposeTransactions\u00a0function implicitly assumes that it has been granted an appropriate allowance of\u00a0collateral\u00a0tokens from the\u00a0proposer\u00a0when it attempts to\u00a0safeTransferFrom\u00a0the\u00a0totalBond.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-the\u00a0optimisticgovernor\u00a0contract,-the\u00a0proposetransactions\u00a0function-implicitly-assumes-that-it-has-been-granted-an-appropriate-allowance-of\u00a0collateral\u00a0tokens-from-the\u00a0proposer\u00a0when-it-attempts-to\u00a0safetransferfrom\u00a0the\u00a0totalbond.", "labels": ["OpenZeppelin"]}, {"title": "In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions\u2019 inline documentation.", "body": "In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions\u2019 inline documentation.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-favor-of-explicitness-and-to-improve-the-overall-clarity-of-the-codebase,-consider-documenting-all-approval-requirements-in-the-relevant-functions\u2019-inline-documentation.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0c6bdb5e02b57d4f4135feca80d08671725141226\u00a0in\u00a0pull request #3925.", "body": "Update:\u00a0Fixed as of commit\u00a0c6bdb5e02b57d4f4135feca80d08671725141226\u00a0in\u00a0pull request #3925.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0c6bdb5e02b57d4f4135feca80d08671725141226\u00a0in\u00a0pull-request-#3925.", "labels": ["OpenZeppelin"]}, {"title": "Unexplained and unused constants", "body": "Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#unexplained-and-unused-constants", "labels": ["OpenZeppelin"]}, {"title": "Throughout the\u00a0OptimisticGovernor\u00a0contract, to check if a proposal has been approved by the Optimistic Oracle the literal value\u00a0int256\u00a01e18\u00a0is used, where\u00a01e18\u00a0signifies that a proposal was not rejected by the Optimistic Oracle.", "body": "Throughout the\u00a0OptimisticGovernor\u00a0contract, to check if a proposal has been approved by the Optimistic Oracle the literal value\u00a0int256\u00a01e18\u00a0is used, where\u00a01e18\u00a0signifies that a proposal was not rejected by the Optimistic Oracle.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#throughout-the\u00a0optimisticgovernor\u00a0contract,-to-check-if-a-proposal-has-been-approved-by-the-optimistic-oracle-the-literal-value\u00a0int256\u00a01e18\u00a0is-used,-where\u00a01e18\u00a0signifies-that-a-proposal-was-not-rejected-by-the-optimistic-oracle.", "labels": ["OpenZeppelin"]}, {"title": "Similarly, in the update to the\u00a0OptimisticOracle\u00a0contract the function\u00a0proposedPrice\u00a0uses a magic value\u00a0type(int256).min\u00a0to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.", "body": "Similarly, in the update to the\u00a0OptimisticOracle\u00a0contract the function\u00a0proposedPrice\u00a0uses a magic value\u00a0type(int256).min\u00a0to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#similarly,-in-the-update-to-the\u00a0optimisticoracle\u00a0contract-the-function\u00a0proposedprice\u00a0uses-a-magic-value\u00a0type(int256).min\u00a0to-indicate-that-an-event-based-proposal-cannot-be-resolved,-because-the-event-has-not-yet-taken-place.", "labels": ["OpenZeppelin"]}, {"title": "Lastly, in the\u00a0OptimisticOracle\u00a0contract the\u00a0MAX_ADDED_ANCILLARY_DATA\u00a0constant is declared on\u00a0line 129. On the\u00a0next line\u00a0the constant should be used, but instead the\u00a0value\u00a0of the constant is used directly to derive another constant.", "body": "Lastly, in the\u00a0OptimisticOracle\u00a0contract the\u00a0MAX_ADDED_ANCILLARY_DATA\u00a0constant is declared on\u00a0line 129. On the\u00a0next line\u00a0the constant should be used, but instead the\u00a0value\u00a0of the constant is used directly to derive another constant.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#lastly,-in-the\u00a0optimisticoracle\u00a0contract-the\u00a0max_added_ancillary_data\u00a0constant-is-declared-on\u00a0line-129.-on-the\u00a0next-line\u00a0the-constant-should-be-used,-but-instead-the\u00a0value\u00a0of-the-constant-is-used-directly-to-derive-another-constant.", "labels": ["OpenZeppelin"]}, {"title": "To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.", "body": "To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-improve-the-overall-readability-of-the-codebase-and-to-facilitate-refactoring,-consider-defining-a-constant-for-every-literal-or-magic-value-used,-giving-it-a-clear-and-self-explanatory-name,-and-then-using-it-in-place-of-literal-values.-also-consider-adding-an-inline-comment-explaining-how-literal-values-were-calculated-or-why-they-were-chosen.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0c7babc3d3082200b55901783f4ceabae82df1cea\u00a0in\u00a0pull request #3909.", "body": "Update:\u00a0Fixed as of commit\u00a0c7babc3d3082200b55901783f4ceabae82df1cea\u00a0in\u00a0pull request #3909.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0c7babc3d3082200b55901783f4ceabae82df1cea\u00a0in\u00a0pull-request-#3909.", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary cast", "body": "In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#unnecessary-cast", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0setUp\u00a0function of the\u00a0OptimisticGovernor\u00a0contract,\u00a0_collateral\u00a0is unnecessarily cast to an\u00a0address\u00a0type.", "body": "In the\u00a0setUp\u00a0function of the\u00a0OptimisticGovernor\u00a0contract,\u00a0_collateral\u00a0is unnecessarily cast to an\u00a0address\u00a0type.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#in-the\u00a0setup\u00a0function-of-the\u00a0optimisticgovernor\u00a0contract,\u00a0_collateral\u00a0is-unnecessarily-cast-to-an\u00a0address\u00a0type.", "labels": ["OpenZeppelin"]}, {"title": "To improve the overall legibility of the codebase, consider removing this unnecessary cast.", "body": "To improve the overall legibility of the codebase, consider removing this unnecessary cast.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-improve-the-overall-legibility-of-the-codebase,-consider-removing-this-unnecessary-cast.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a02819d071df9a3bbcc8a2d15700d6140ae8e5ad9d\u00a0in\u00a0pull request #3928.", "body": "Update:\u00a0Fixed as of commit\u00a02819d071df9a3bbcc8a2d15700d6140ae8e5ad9d\u00a0in\u00a0pull request #3928.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a02819d071df9a3bbcc8a2d15700d6140ae8e5ad9d\u00a0in\u00a0pull-request-#3928.", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary imports", "body": "The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#unnecessary-imports", "labels": ["OpenZeppelin"]}, {"title": "The codebase contains the following unnecessary imports:", "body": "The codebase contains the following unnecessary imports:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-codebase-contains-the-following-unnecessary-imports:", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 13\u00a0OptimisticOracle.sol\u00a0is unnecessarily imported.", "body": "On\u00a0line 13\u00a0OptimisticOracle.sol\u00a0is unnecessarily imported.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on\u00a0line-13\u00a0optimisticoracle.sol\u00a0is-unnecessarily-imported.", "labels": ["OpenZeppelin"]}, {"title": "Consider removing unnecessary imports to improve code clarity.", "body": "Consider removing unnecessary imports to improve code clarity.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-removing-unnecessary-imports-to-improve-code-clarity.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a05833fce724930ba27a01855dcbaf03bcfe7fa7a2\u00a0in\u00a0pull request #3927.", "body": "Update:\u00a0Fixed as of commit\u00a05833fce724930ba27a01855dcbaf03bcfe7fa7a2\u00a0in\u00a0pull request #3927.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a05833fce724930ba27a01855dcbaf03bcfe7fa7a2\u00a0in\u00a0pull-request-#3927.", "labels": ["OpenZeppelin"]}, {"title": "Unused \u201cusing for\u201d directive", "body": "The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#unused-\u201cusing-for\u201d-directive", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0OptimisticOracle\u00a0contract includes the directive\u00a0using\u00a0AncillaryData\u00a0for\u00a0bytes, even though none of the library methods are ever used directly on a bytes value.", "body": "The\u00a0OptimisticOracle\u00a0contract includes the directive\u00a0using\u00a0AncillaryData\u00a0for\u00a0bytes, even though none of the library methods are ever used directly on a bytes value.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0optimisticoracle\u00a0contract-includes-the-directive\u00a0using\u00a0ancillarydata\u00a0for\u00a0bytes,-even-though-none-of-the-library-methods-are-ever-used-directly-on-a-bytes-value.", "labels": ["OpenZeppelin"]}, {"title": "Consider removing the directive if it will remain unused.", "body": "Consider removing the directive if it will remain unused.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-removing-the-directive-if-it-will-remain-unused.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a02ee3f4b2affb7049a156c93705d9918ce5c3a670\u00a0in\u00a0pull request #3910.", "body": "Update:\u00a0Fixed as of commit\u00a02ee3f4b2affb7049a156c93705d9918ce5c3a670\u00a0in\u00a0pull request #3910.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a02ee3f4b2affb7049a156c93705d9918ce5c3a670\u00a0in\u00a0pull-request-#3910.", "labels": ["OpenZeppelin"]}, {"title": "Conclusions", "body": "0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#conclusions", "labels": ["OpenZeppelin"]}, {"title": "0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.", "body": "0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#0-critical-and-0-high-severity-issues-were-found.-some-changes-were-proposed-to-follow-best-practices-and-reduce-the-potential-attack-surface.", "labels": ["OpenZeppelin"]}, {"title": "Appendix", "body": "Appendix", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#appendix", "labels": ["OpenZeppelin"]}, {"title": "Severity Levels", "body": "Severity Levels", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#severity-levels", "labels": ["OpenZeppelin"]}, {"title": "The deleteProposal function may not work as expected with all avatars", "body": "The deleteProposal function may not work as expected with all avatars", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-deleteproposal-function-may-not-work-as-expected-with-all-avatars", "labels": ["OpenZeppelin"]}, {"title": "immutable value could be used", "body": "immutable value could be used", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#immutable-value-could-be-used", "labels": ["OpenZeppelin"]}, {"title": "Some public functions could be external", "body": "Some public functions could be external", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#some-public-functions-could-be-external", "labels": ["OpenZeppelin"]}, {"title": "Suboptimal struct packing", "body": "Suboptimal struct packing", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#suboptimal-struct-packing", "labels": ["OpenZeppelin"]}, {"title": "s", "body": "Thi ecurity aement wa prepared by OpenZeppelin, protecting the open economy.  Table of Content  Table of Content  Summary  Scope  Sytem Overview  Privileged Role  Security Conideration  Finding  Medium Severity  Change of collateral could reult in unintended bond value Lack of event emiion after enitive action Lack of input validation Mimatche between UMIP and implementation  Low Severity  Event lacking information Duplicated code Mileading inline documentation Propoal can be deleted repeatedly The deletePropoal function may not work a expected with all avatar  Note & Additional Information  Commented out code Coding tyle deviate from Solidity Style Guide Diabling reentrancy protection i prone to error immutable value could be ued Some public function could be external Suboptimal truct packing Typographical error Undocumented implicit approval requirement Unexplained and unued contant Unneceary cat Unneceary import Unued uing for directive  Concluion  Appendix  Severity Level  Summary  Governance/Oracle  From 2022-04-25  To 2022-05-10  Solidity  21 (18 reolved)  0 (0 reolved)  0 (0 reolved)  4 (3 reolved)  5 (4 reolved)  12 (11 reolved)  Scope  We audited three eparate et of code, pecifically:  The UMAprotocol/protocol repoitory at commit fca8e24275e928f7ddf660b5651eb93b87f70afb.In cope were the following contract:  OptimiticGovernor.ol  The UMAprotocol/protocol repoitory PR #3880 at commit acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In cope were the following contract:  Lockable.ol OptimiticOracle.ol OptimiticOracleInterface.ol  After the initial audit UMA requeted u to audit the UMAprotocol/protocol repoitory PR #3911 at commit 75bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in cope and audited it.  Sytem Overview  The Optimitic Governor contract i meant to control an avatar that complie with the Gnoi Zodiac framework. The target ue cae i that the avatar i a Gnoi Safe that hold DAO fund and i capable of controlling DAO operation. The Optimitic Governor aim to allow anyone to control DAO fund and activitie a long a their propoed activitie conform to a et of natural language rule that the DAO ha made publicly available. Thi i facilitated via the UMA Optimitic Oracle, which become the final arbiter in cae propoal are conteted for not conforming to DAO rule. In the cae where propoal are not conteted during their livene period, they then become executable by anyone.  The unrelated Optimitic Oracle PR we were aked to review add a mechanim to upend reentrancy guard protection to allow for callback in the body of nonRentrant function (where uch callback would not otherwie be permiable). Additionally, the Oracle wa modified to upport event-baed price requet  that i price requet after ome event in the future occur, rather than at a pecific point in time.  Privileged Role  The Optimitic Governor contract ha only one privileged role, which i that of the contract owner. The owner i able to et the bond amount and bond collateral token required to initiate a propoal. The owner can alo et the rule that propoal mut conform to, et the livene time (window in which a propoal i contetable), and et the identifier ued by the Optimitic Oracle to upport Optimitic Governance propoal. Finally, the owner can delete pecific propoal at any time and can renounce and tranfer ownerhip.  Security Conideration  The UMA team clearly pent time conidering ecurity implication of the Optimitic Governor a evidenced by the UMIP that i required for the Optimitic Oracle to upport thi new ue cae. However, not all ecurity implication are touched on in the UMIP. Some additional conideration follow:  Firt and foremot, the theoretical poibility of corrupting the Optimitic Oracle itelf, by eentially bribing UMA token holder to enrich themelve at the expene of Optimitically Governed DAO() can not be diregarded. The UMA team ha a good undertanding of how to increae the cot of uch corruption, in fact their whitepaper cover the topic at length, but at thi time it i unclear if all of the corruption mitigation mechanim are fully in place and actively enforced. The rik of corruption, a well a any countermeaure in place, need to be well undertood by DAO looking to ue the Optimitic Governor in production.  Additionally, becaue the protocol i o flexible, DAO that ue it need to be fully aware of what the protocol can guarantee and what it cannot. DAO have an immene reponibility not jut for making ure that their rule are a explicit and well-defined a poible, but alo for chooing where to hot uch rule. The protocol allow for rule to be ubmitted a a URI, in which cae the DAO need to conider if thoe rule are immune from being tampered with or are at rik of being taken off line. The flexible nature of the rule argument alo allow rule  or a ubet of rule  to be tored on chain. Thi approach may be worth the aociated cot depending on the individual DAO.  If the avatar i managed by ome mean other than the Optimitic Governor, for intance if it ha an owner, then Optimitic Governance can only work a long a the other mean of avatar management do not interfere. The ability to outright delete propoal and modify parameter for making propoal can undermine the entire Optimitic Governance model depending on how thoe permiion are managed independently of the Optimitic Governor.  On the other hand, if the Optimitic Governor i the ole mean of managing an avatar, it become even more eential that the nuance and limitation of the model are well undertood. Even otenibly rule-abiding propoal could be dangerou. If the tranaction to be executed a part of a propoal involve upgradeable contract, then the code that end up being executed could well be different than that which exited at the time the propoal wa made. Savvy or maliciou actor could frontrun execution call with contract logic upgrade call. DAO mut be vigilant againt thi and hould conider how to handle upgradeable code explicitly in their rule.  Tranaction could be crafted to look afe or even deirable when called, but then be completely maliciou if they are delegate called. Which context a call i executed in come down to a imple uint flag attached to a tranaction. DAO uing the Optimitic Oracle need to be vigilant againt potential tranaction phihing attack that ue the wrong context for a call.  Finally, the Zodiac framework allow for additional module, modifier, and guard  eentially mart contract middleware that can it between EOA interaction with the Optimitic Governor and interaction with the avatar. Thee entire code chain mut be well undertood a they could potentially modify the final behavior of the avatar in way that inpection of propoal and of the Optimitic Governor on it own cannot anticipate.  Finding  Here we preent our finding.  Medium Severity  Change of collateral could reult in unintended bond value  The OptimiticGovernor contract require uer to provide a preconfigured quantity of an ERC20 token a bond to propoe a et of tranaction. If the et of tranaction i rejected, the propoer will loe their bond.  To change the collateral token addre and it amount the contract owner will generally have to call two eparate function, namely etBond to et the new amount and etCollateral to et the new ERC20 addre of the bond token.  If the contract owner i an EOA, then etBond and etCollateral will be called in two eparate tranaction which allow a third party to call propoeTranaction in between. Thi will lead to the creation of a propoal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Conider renaming etCollateral to etCollateralAndBond and updating both the bond value and the bond token addre in the ame function call.  Update: Fixed a of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull requet #3912.  Lack of event emiion after enitive action  etUp,  etBond,  etCollateral,  etRule,  etLivene, and  etIdentifier function do not emit relevant event after executing enitive action.  Conider emitting event after enitive change take place (including in the contructor and/or initializer), to facilitate tracking and notify off-chain client following the contract activity.  Update: Fixed a of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull requet #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull requet #3914.  Lack of input validation  The OptimiticGovernor contract ha a general lack of input validation. For intance, the etUp function doe not validate that the _finder argument i non-zero, which can lead to a non-functional module intance. Nor doe etUp validate that the _rule argument i non-empty, which could lead to a lo of fund if optimitic governance propoal are the ole way to manage an Avatar.  In the ame function, _livene i checked to be greater than zero, in line with the Optimitic Oracle lower bound requirement. However, etUp doe not check that _livene i le than 5200 week, which i the Optimitic Oracle upper bound requirement.  The etLivene and etRule function have the ame ort of lacking input validation a etUp doe.  Both the etUp and etBond function allow a zero bond, which the OptimiticOracle will accept. However, becaue of the overall lack of input validation, it become difficult to dicern if a zero bond i a legitimately acceptable value or imply an overight of the validation logic.  To avoid error and unexpected ytem behavior, conider implementing require tatement to validate all uer-controlled input. Where zero-value are acceptable, conider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed a of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull requet #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull requet #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull requet #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull requet #3962.  Mimatche between UMIP and implementation  In UMIP-152, the documentation of everal data tructure i ignificantly different from their implementation in OptmiticGovenor.ol.  Difference can be found in the Tranaction and Propoal truct a well a the data format of ancilliaryData.  Conider updating the documentation to correpond to the implementation. Additionally, in light of the removal of the module addre from ancilliaryData, conider adding further documentation to explain how uniquene of a propoal identifier acro all uer of the Optimitic Oracle i maintained.  Update: not fixed, UMA reply: will be fixed in eparate PR updating the UMIP after code i finalized.  Low Severity  Event lacking information  We identified two event which could benefit from being more complete. Specifically, the PropoalDeleted and TranactionPropoed event.  Currently, PropoalDeleted event emiion have an ambiguou interpretation. Thi i becaue uch emiion can originate from either the deleteRejectedPropoal function or the deletePropoal function under different circumtance. To reduce ambiguity, conider augmenting the event o that it alo emit detail about the propoal tatu and the mg.ender when a propoal i deleted.  The TranactionPropoed event currently emit the time at which a propoal i created, but it doe not emit the livene time the propoal i ubject to or a timetamp that indicate when the propoal need to be diputed by. A thi i likely to be of interet at the time a propoal i created, conider emitting enough information to determine when a propoal mut be diputed by.  Update: Fixed a of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull requet #3916.  Duplicated code  There are intance of duplicated code within the codebae. Duplicated code can lead to iue later in the development lifecycle and leave the project more prone to the introduction of error later if functionality change are not replicated acro all intance of code that hould be identical.  Within the OptimiticGovernor contract the etUp function repeat code found in everal of the et* etter function.  Rather than duplicating code, conider reuing exiting function a needed or having jut one contract or library containing the duplicated code and uing it whenever the duplicated functionality i required.  Update: Fixed a of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull requet #3914.  Mileading inline documentation  There are intance of mileading or imprecie documentation throughout the codebae.  In particular, in OptimiticGovernor.ol:  The public ync function ha a comment beneath it that read, Sync the oracle contract addree a well a the final fee. In fact, the function merely make a call to the internal _ync function that then et only the optimiticOracle addre. No other addre or final fee value i tored.  On line 69 the NatSpec tate, Bond required (mut be at leat a large a final fee for collateral type). However, there i no comparion made.  The NatSpec of the _originalTime parameter of the deleteRejectedPropoal function i a copy pate error from the line above decribing the _propoalId parameter.  On line 246 and line 279 there i an inline comment that read, Thi will revert if the price ha not ettled. Thi i not a nuanced a it could be. The call the comment refer to will revert if the price ha not and can not currently be ettled; the call can actually ettle the the requet if the price ha not yet been ettled but i ettle-able.  Additionally, in OptimiticOracle.ol:  On line 172 the comment explain the inequality check that follow a: Thi enure that the ancillary data i below the OO limit. In fact, the inequality tet that the ancillary data i le than or equal to the Optimitic Oracle (OO) ancillary data limit.  Clear inline documentation i fundamental to outline the intention of the code. Mimatche between them and the implementation can lead to eriou miconception about how the ytem i expected to behave. Therefore, conider fixing thee error to avoid potential confuion for developer, uer, auditor alike.  Update: Fixed a of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull requet #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull requet #3963.  Propoal can be deleted repeatedly  In the OptimiticGovernor contract there i no check that a propoal exit before it i deleted with the deletePropoal function. Similarly, a rejected propoal can be deleted repeatedly via the deleteRejectedPropoal function.  Although there i no clear economic incentive to do delete a propoal numerou time  in fact it will wate ga  the repeated emiion of identical PropoalDeleted event could be confuing for partie monitoring for uch event.  Conider allowing propoal to be deleted only if they have not already been deleted.  Update: Fixed a of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull requet #3918.  The deletePropoal function may not work a expected with all avatar  The deletePropoal function allow the owner to delete a particular propoal o that it will not be executed. In the current implementation of the OptimiticGovernor contract the owner and the avatar are the ame addre. In general, an avatar doe not necearily have the ability to end arbitrary tranaction without having enabled ome module pecifically for thi purpoe.  If an avatar were to have only the OptimiticGovernor module enabled, then it could not initiate a tranaction in any way other than calling the propoeTranaction function. However, in thi cae the deletePropoal function would not work a expected.  Conider a cenario where an owner would like to delete an exiting propoal via creating a new propoal:  If the owner create a propoal to call deletePropoal via propoeTranaction, then the expiration time of the deletePropoal propoal will be greater than expire time of the original propoal which the owner wihed to delete. Thu the owner would not be guaranteed to be able delete the original propoal becaue it could be executed before the deletion propoal paed the livene threhold.  If the owner wanted to dipute the propoal they were trying to delete, then they could do o. But the aumption that only propoal which break the rule may not alway hold. Additionally, if the propoal technically followed the rule, but only elucidated how the rule themelve needed to be updated, any uch rule update propoal would alo run into the ame ort of livene delay dilemma.  Conider better documenting aumption about the capabilitie of the avatar and what may happen if thoe aumption do not hold. Additionally, if having an avatar excluively controlled by an OptimiticGovernor module i a reaonable ue cae, then conider allowing ome other form of propoal deletion capabilitie that can bypa the tandard livene condition in cae of emergencie.  Update: not fixed, UMA reply: will be fixed in eparate PR updating the UMIP after code i finalized.  Note & Additional Information  Commented out code  The propoeTranaction and executePropoal function in the OptimiticGovernor contract include commented out line of code.  A the purpoe of thee line i unclear and may confue future developer and external contributor, conider removing them from the codebae. If they are meant to provide alternate implementation option, then conider extracting them to a eparate document where they can be accompanied by a more thorough explanation of their purpoe.  Update: Fixed a of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull requet #3919.  Coding tyle deviate from Solidity Style Guide  OptimiticGovernor contract the  _getOptimiticOracle and  _iContract function are declared  internal function.  Thi function order deviate from the recommended order of: contructor, receive, fallback, external, public, internal, private.  To increae overall code readability, conider reordering thee function and conforming to the Solidity Style Guide where poible.  Update: Fixed a of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull requet #3920.  Diabling reentrancy protection i prone to error  In the OptimiticOracle contract all external function are protected with a nonReentrant modifier. However, in deignated place the uer i allowed to perform a callback into the OptimiticOracle contract. Thi i achieved via the function _tartReentrantGuardDiabled and _endReentrantGuardDiabled which temporarily diable and manually re-enable reentrancy protection, repectively.  Thee function mut be ued in pair to perform a expected; that proce i manual and potentially error prone.  To reduce the likelihood of error, conider including a continuou integration or cutom linter check for pairwie matching _tart and _end function and for containment within a function that ue a nonReentrant modifier.  Update: acknowledged by UMA: Thi ort of linting would be helpful, but at the moment, it unclear how omething like thi could be implemented without a linter that can interpret olidity that alo upport cutom plugin.; no immediate code change are needed.  immutable value could be ued  In the OptimiticGovernor contract the finder variable i only ever et in the etUp initialization function. The value i not modifiable after deployment.  In practice, the finder implementation may generally be modified olely by the UMA team. Only after uch an update to the implementation would uer want to update their finder value. Then, if uer do wih to migrate to the new finder addre, they will need to deploy a new OptimiticGovernor module anyway.  Update: Fixed a of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull requet #3921.  Some public function could be external  etBond,  etCollateral,  etRule,  etLivene, and  etIdentifier function are marked  Conider declaring function with only the mot retrictive viibility required to reduce the overall urface for error and better reflect intent.  Update: Fixed a of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull requet #3922.  Suboptimal truct packing  OptimiticGovernor contract the  Tranaction  member labeled operation. Thi member i implicitly of type  to in order to take advantage of more efficient  Update: Fixed a of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull requet #3923.  Typographical error  The codebae contain the following t", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#s", "labels": ["OpenZeppelin"]}, {"title": "Summary", "body": "Governance/Oracles  From 2022-04-25  To 2022-05-10  Solidity  21 (18 resolved)  0 (0 resolved)  0 (0 resolved)  4 (3 resolved)  5 (4 resolved)  12 (11 resolved)  Scope  We audited three separate sets of code, specifically:  The UMAprotocol/protocol repository at commit fca8e24275e928f7ddf660b5651eb93b87f70afb.In scope were the following contracts:  OptimisticGovernor.sol  The UMAprotocol/protocol repository PR #3880 at commit acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In scope were the following contracts:  Lockable.sol OptimisticOracle.sol OptimisticOracleInterface.sol  After the initial audit UMA requested us to audit the UMAprotocol/protocol repository PR #3911 at commit 75bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in scope and audited it.  System Overview  The Optimistic Governor contract is meant to control an avatar that complies with the Gnosis Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their liveness period, they then become executable by anyone.  The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of nonRentrant functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support event-based price requests  that is price requests after some event in the future occurs, rather than at a specific point in time.  Privileged Roles  The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the liveness time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.  Security Considerations  The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.  Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.  Finally, the Zodiac framework allows for additional modules, modifiers, and guards  essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These entire code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.  Findings  Here we present our findings.  Medium Severity  Change of collateral could result in unintended bond value  The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGove", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#summary", "labels": ["OpenZeppelin"]}, {"title": "Governance/Oracles", "body": "Governance/Oracles", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#governance/oracles", "labels": ["OpenZeppelin"]}, {"title": "From 2022-04-25", "body": "From 2022-04-25", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#from-2022-04-25", "labels": ["OpenZeppelin"]}, {"title": "To 2022-05-10", "body": "To 2022-05-10", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-2022-05-10", "labels": ["OpenZeppelin"]}, {"title": "Solidity", "body": "21 (18 resolved)  0 (0 resolved)  0 (0 resolved)  4 (3 resolved)  5 (4 resolved)  12 (11 resolved)  Scope  We audited three separate sets of code, specifically:  The UMAprotocol/protocol repository at commit fca8e24275e928f7ddf660b5651eb93b87f70afb.In scope were the following contracts:  OptimisticGovernor.sol  The UMAprotocol/protocol repository PR #3880 at commit acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In scope were the following contracts:  Lockable.sol OptimisticOracle.sol OptimisticOracleInterface.sol  After the initial audit UMA requested us to audit the UMAprotocol/protocol repository PR #3911 at commit 75bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in scope and audited it.  System Overview  The Optimistic Governor contract is meant to control an avatar that complies with the Gnosis Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their liveness period, they then become executable by anyone.  The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of nonRentrant functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support event-based price requests  that is price requests after some event in the future occurs, rather than at a specific point in time.  Privileged Roles  The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the liveness time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.  Security Considerations  The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.  Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.  Finally, the Zodiac framework allows for additional modules, modifiers, and guards  essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These entire code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.  Findings  Here we present our findings.  Medium Severity  Change of collateral could result in unintended bond value  The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from  Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the  Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 16", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#solidity", "labels": ["OpenZeppelin"]}, {"title": "21 (18 resolved)", "body": "21 (18 resolved)", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#21-(18-resolved)", "labels": ["OpenZeppelin"]}, {"title": "0 (0 resolved)", "body": "4 (3 resolved)  5 (4 resolved)  12 (11 resolved)  Scope  We audited three separate sets of code, specifically:  The UMAprotocol/protocol repository at commit fca8e24275e928f7ddf660b5651eb93b87f70afb.In scope were the following contracts:  OptimisticGovernor.sol  The UMAprotocol/protocol repository PR #3880 at commit acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In scope were the following contracts:  Lockable.sol OptimisticOracle.sol OptimisticOracleInterface.sol  After the initial audit UMA requested us to audit the UMAprotocol/protocol repository PR #3911 at commit 75bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in scope and audited it.  System Overview  The Optimistic Governor contract is meant to control an avatar that complies with the Gnosis Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their liveness period, they then become executable by anyone.  The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of nonRentrant functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support event-based price requests  that is price requests after some event in the future occurs, rather than at a specific point in time.  Privileged Roles  The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the liveness time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.  Security Considerations  The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.  Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.  Finally, the Zodiac framework allows for additional modules, modifiers, and guards  essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These entire code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.  Findings  Here we present our findings.  Medium Severity  Change of collateral could result in unintended bond value  The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#0-(0-resolved)", "labels": ["OpenZeppelin"]}, {"title": "4 (3 resolved)", "body": "4 (3 resolved)", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#4-(3-resolved)", "labels": ["OpenZeppelin"]}, {"title": "5 (4 resolved)", "body": "5 (4 resolved)", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#5-(4-resolved)", "labels": ["OpenZeppelin"]}, {"title": "12 (11 resolved)", "body": "12 (11 resolved)", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#12-(11-resolved)", "labels": ["OpenZeppelin"]}, {"title": "Scope", "body": "We audited three separate sets of code, specifically:  The UMAprotocol/protocol repository at commit fca8e24275e928f7ddf660b5651eb93b87f70afb.In scope were the following contracts:  OptimisticGovernor.sol  The UMAprotocol/protocol repository PR #3880 at commit acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In scope were the following contracts:  Lockable.sol OptimisticOracle.sol OptimisticOracleInterface.sol  After the initial audit UMA requested us to audit the UMAprotocol/protocol repository PR #3911 at commit 75bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in scope and audited it.  System Overview  The Optimistic Governor contract is meant to control an avatar that complies with the Gnosis Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their liveness period, they then become executable by anyone.  The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of nonRentrant functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support event-based price requests  that is price requests after some event in the future occurs, rather than at a specific point in time.  Privileged Roles  The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the liveness time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.  Security Considerations  The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.  Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.  Finally, the Zodiac framework allows for additional modules, modifiers, and guards  essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These entire code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.  Findings  Here we present our findings.  Medium Severity  Change of collateral could result in unintended bond value  The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider ", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#scope", "labels": ["OpenZeppelin"]}, {"title": "We audited three separate sets of code, specifically:", "body": "We audited three separate sets of code, specifically:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#we-audited-three-separate-sets-of-code,-specifically:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0UMAprotocol/protocol\u00a0repository at commit\u00a0fca8e24275e928f7ddf660b5651eb93b87f70afb.In scope were the following contracts:", "body": "The\u00a0UMAprotocol/protocol\u00a0repository at commit\u00a0fca8e24275e928f7ddf660b5651eb93b87f70afb.In scope were the following contracts:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0umaprotocol/protocol\u00a0repository-at-commit\u00a0fca8e24275e928f7ddf660b5651eb93b87f70afb.in-scope-were-the-following-contracts:", "labels": ["OpenZeppelin"]}, {"title": "OptimisticGovernor.sol", "body": ":  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In :  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In :  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#optimisticgovernor.sol", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0UMAprotocol/protocol\u00a0repository\u00a0PR #3880\u00a0at commit\u00a0acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In scope were the following contracts:", "body": "The\u00a0UMAprotocol/protocol\u00a0repository\u00a0PR #3880\u00a0at commit\u00a0acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.In scope were the following contracts:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0umaprotocol/protocol\u00a0repository\u00a0pr-#3880\u00a0at-commit\u00a0acfb166ef521c1b6ab13a82acf5eee6e16ffd9e9.in-scope-were-the-following-contracts:", "labels": ["OpenZeppelin"]}, {"title": "Lockable.sol", "body": "Lockable.sol", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#lockable.sol", "labels": ["OpenZeppelin"]}, {"title": "OptimisticOracle.sol", "body": ":  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13  is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#optimisticoracle.sol", "labels": ["OpenZeppelin"]}, {"title": "OptimisticOracleInterface.sol", "body": "OptimisticOracleInterface.sol", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#optimisticoracleinterface.sol", "labels": ["OpenZeppelin"]}, {"title": "After the initial audit UMA requested us to audit the\u00a0UMAprotocol/protocol\u00a0repository\u00a0PR #3911\u00a0at commit\u00a075bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in scope and audited it.", "body": "After the initial audit UMA requested us to audit the\u00a0UMAprotocol/protocol\u00a0repository\u00a0PR #3911\u00a0at commit\u00a075bdffecdae5c3f0c7a7546e65c99b0be02be223. We included PR in scope and audited it.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#after-the-initial-audit-uma-requested-us-to-audit-the\u00a0umaprotocol/protocol\u00a0repository\u00a0pr-#3911\u00a0at-commit\u00a075bdffecdae5c3f0c7a7546e65c99b0be02be223.-we-included-pr-in-scope-and-audited-it.", "labels": ["OpenZeppelin"]}, {"title": "System Overview", "body": "The Optimistic Governor contract is meant to control an avatar that complies with the Gnosis Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their liveness period, they then become executable by anyone.  The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of nonRentrant functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support event-based price requests  that is price requests after some event in the future occurs, rather than at a specific point in time.  Privileged Roles  The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the liveness time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.  Security Considerations  The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.  Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.  Finally, the Zodiac framework allows for additional modules, modifiers, and guards  essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These entire code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.  Findings  Here we present our findings.  Medium Severity  Change of collateral could result in unintended bond value  The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentatio", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#system-overview", "labels": ["OpenZeppelin"]}, {"title": "The Optimistic Governor contract is meant to control an \u201cavatar\u201d that complies with the\u00a0Gnosis\u2019 Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their \u201cliveness\u201d period, they then become executable by anyone.", "body": "The Optimistic Governor contract is meant to control an \u201cavatar\u201d that complies with the\u00a0Gnosis\u2019 Zodiac framework. The target use case is that the avatar is a Gnosis Safe that holds DAO funds and is capable of controlling DAO operations. The Optimistic Governor aims to allow anyone to control DAO funds and activities as long as their proposed activities conform to a set of natural language rules that the DAO has made publicly available. This is facilitated via the UMA Optimistic Oracle, which becomes the final arbiter in case proposals are contested for not conforming to DAO rules. In the case where proposals are not contested during their \u201cliveness\u201d period, they then become executable by anyone.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-optimistic-governor-contract-is-meant-to-control-an-\u201cavatar\u201d-that-complies-with-the\u00a0gnosis\u2019-zodiac-framework.-the-target-use-case-is-that-the-avatar-is-a-gnosis-safe-that-holds-dao-funds-and-is-capable-of-controlling-dao-operations.-the-optimistic-governor-aims-to-allow-anyone-to-control-dao-funds-and-activities-as-long-as-their-proposed-activities-conform-to-a-set-of-natural-language-rules-that-the-dao-has-made-publicly-available.-this-is-facilitated-via-the-uma-optimistic-oracle,-which-becomes-the-final-arbiter-in-case-proposals-are-contested-for-not-conforming-to-dao-rules.-in-the-case-where-proposals-are-not-contested-during-their-\u201cliveness\u201d-period,-they-then-become-executable-by-anyone.", "labels": ["OpenZeppelin"]}, {"title": "The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of\u00a0nonRentrant\u00a0functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support \u201cevent-based\u201d price requests \u2013 that is price requests after some event in the future occurs, rather than at a specific point in time.", "body": "The unrelated Optimistic Oracle PR we were asked to review adds a mechanism to suspend reentrancy guard protections to allow for callbacks in the body of\u00a0nonRentrant\u00a0functions (where such callbacks would not otherwise be permissable). Additionally, the Oracle was modified to support \u201cevent-based\u201d price requests \u2013 that is price requests after some event in the future occurs, rather than at a specific point in time.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-unrelated-optimistic-oracle-pr-we-were-asked-to-review-adds-a-mechanism-to-suspend-reentrancy-guard-protections-to-allow-for-callbacks-in-the-body-of\u00a0nonrentrant\u00a0functions-(where-such-callbacks-would-not-otherwise-be-permissable).-additionally,-the-oracle-was-modified-to-support-\u201cevent-based\u201d-price-requests-\u2013-that-is-price-requests-after-some-event-in-the-future-occurs,-rather-than-at-a-specific-point-in-time.", "labels": ["OpenZeppelin"]}, {"title": "Privileged Roles", "body": "The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the liveness time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.  Security Considerations  The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.  Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.  Finally, the Zodiac framework allows for additional modules, modifiers, and guards  essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These entire code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.  Findings  Here we present our findings.  Medium Severity  Change of collateral could result in unintended bond value  The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were ", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#privileged-roles", "labels": ["OpenZeppelin"]}, {"title": "The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the \u201cliveness\u201d time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.", "body": "The Optimistic Governor contract has only one privileged role, which is that of the contract owner. The owner is able to set the bond amount and bond collateral token required to initiate a proposal. The owner can also set the rules that proposals must conform to, set the \u201cliveness\u201d time (window in which a proposal is contestable), and set the identifier used by the Optimistic Oracle to support Optimistic Governance proposals. Finally, the owner can delete specific proposals at any time and can renounce and transfer ownership.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-optimistic-governor-contract-has-only-one-privileged-role,-which-is-that-of-the-contract-owner.-the-owner-is-able-to-set-the-bond-amount-and-bond-collateral-token-required-to-initiate-a-proposal.-the-owner-can-also-set-the-rules-that-proposals-must-conform-to,-set-the-\u201cliveness\u201d-time-(window-in-which-a-proposal-is-contestable),-and-set-the-identifier-used-by-the-optimistic-oracle-to-support-optimistic-governance-proposals.-finally,-the-owner-can-delete-specific-proposals-at-any-time-and-can-renounce-and-transfer-ownership.", "labels": ["OpenZeppelin"]}, {"title": "Security Considerations", "body": "The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the UMIP that is required for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:  First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.  Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the rule argument also allows rules  or a subset of rules  to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.  If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an owner, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.  On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.  Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.  Finally, the Zodiac framework allows for additional modules, modifiers, and guards  essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These entire code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.  Findings  Here we present our findings.  Medium Severity  Change of collateral could result in unintended bond value  The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On li", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#security-considerations", "labels": ["OpenZeppelin"]}, {"title": "The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the\u00a0UMIP that is required\u00a0for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:", "body": "The UMA team clearly spent time considering security implications of the Optimistic Governor as evidenced by the\u00a0UMIP that is required\u00a0for the Optimistic Oracle to support this new use case. However, not all security implications are touched on in the UMIP. Some additional considerations follow:", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-uma-team-clearly-spent-time-considering-security-implications-of-the-optimistic-governor-as-evidenced-by-the\u00a0umip-that-is-required\u00a0for-the-optimistic-oracle-to-support-this-new-use-case.-however,-not-all-security-implications-are-touched-on-in-the-umip.-some-additional-considerations-follow:", "labels": ["OpenZeppelin"]}, {"title": "First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.", "body": "First and foremost, the theoretical possibility of corrupting the Optimistic Oracle itself, by essentially bribing UMA token holders to enrich themselves at the expense of Optimistically Governed DAO(s) can not be disregarded. The UMA team has a good understanding of how to increase the costs of such corruption, in fact their whitepaper covers the topic at length, but at this time it is unclear if all of the corruption mitigation mechanisms are fully in place and actively enforced. The risks of corruption, as well as any countermeasures in place, need to be well understood by DAOs looking to use the Optimistic Governor in production.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#first-and-foremost,-the-theoretical-possibility-of-corrupting-the-optimistic-oracle-itself,-by-essentially-bribing-uma-token-holders-to-enrich-themselves-at-the-expense-of-optimistically-governed-dao(s)-can-not-be-disregarded.-the-uma-team-has-a-good-understanding-of-how-to-increase-the-costs-of-such-corruption,-in-fact-their-whitepaper-covers-the-topic-at-length,-but-at-this-time-it-is-unclear-if-all-of-the-corruption-mitigation-mechanisms-are-fully-in-place-and-actively-enforced.-the-risks-of-corruption,-as-well-as-any-countermeasures-in-place,-need-to-be-well-understood-by-daos-looking-to-use-the-optimistic-governor-in-production.", "labels": ["OpenZeppelin"]}, {"title": "Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the \u201crule\u201d argument also allows rules \u2013 or a subset of rules \u2013 to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.", "body": "Additionally, because the protocol is so flexible, DAOs that use it need to be fully aware of what the protocol can guarantee and what it cannot. DAOs have an immense responsibility not just for making sure that their rules are as explicit and well-defined as possible, but also for choosing where to host such rules. The protocol allows for rules to be submitted as a URI, in which case the DAO needs to consider if those rules are immune from being tampered with or are at risk of being taken off line. The flexible nature of the \u201crule\u201d argument also allows rules \u2013 or a subset of rules \u2013 to be stored on chain. This approach may be worth the associated costs depending on the individual DAO.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#additionally,-because-the-protocol-is-so-flexible,-daos-that-use-it-need-to-be-fully-aware-of-what-the-protocol-can-guarantee-and-what-it-cannot.-daos-have-an-immense-responsibility-not-just-for-making-sure-that-their-rules-are-as-explicit-and-well-defined-as-possible,-but-also-for-choosing-where-to-host-such-rules.-the-protocol-allows-for-rules-to-be-submitted-as-a-uri,-in-which-case-the-dao-needs-to-consider-if-those-rules-are-immune-from-being-tampered-with-or-are-at-risk-of-being-taken-off-line.-the-flexible-nature-of-the-\u201crule\u201d-argument-also-allows-rules-\u2013-or-a-subset-of-rules-\u2013-to-be-stored-on-chain.-this-approach-may-be-worth-the-associated-costs-depending-on-the-individual-dao.", "labels": ["OpenZeppelin"]}, {"title": "If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an \u201cowner\u201d, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.", "body": "If the avatar is managed by some means other than the Optimistic Governor, for instance if it has an \u201cowner\u201d, then Optimistic Governance can only work as long as the other means of avatar management do not interfere. The ability to outright delete proposals and modify parameters for making proposals can undermine the entire Optimistic Governance model depending on how those permissions are managed independently of the Optimistic Governor.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#if-the-avatar-is-managed-by-some-means-other-than-the-optimistic-governor,-for-instance-if-it-has-an-\u201cowner\u201d,-then-optimistic-governance-can-only-work-as-long-as-the-other-means-of-avatar-management-do-not-interfere.-the-ability-to-outright-delete-proposals-and-modify-parameters-for-making-proposals-can-undermine-the-entire-optimistic-governance-model-depending-on-how-those-permissions-are-managed-independently-of-the-optimistic-governor.", "labels": ["OpenZeppelin"]}, {"title": "On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.", "body": "On the other hand, if the Optimistic Governor is the sole means of managing an avatar, it becomes even more essential that the nuances and limitations of the model are well understood. Even ostensibly rule-abiding proposals could be dangerous. If the transactions to be executed as part of a proposal involve upgradeable contracts, then the code that ends up being executed could well be different than that which existed at the time the proposal was made. Savvy or malicious actors could frontrun execution calls with contract logic upgrade calls. DAOs must be vigilant against this and should consider how to handle upgradeable code explicitly in their rules.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#on-the-other-hand,-if-the-optimistic-governor-is-the-sole-means-of-managing-an-avatar,-it-becomes-even-more-essential-that-the-nuances-and-limitations-of-the-model-are-well-understood.-even-ostensibly-rule-abiding-proposals-could-be-dangerous.-if-the-transactions-to-be-executed-as-part-of-a-proposal-involve-upgradeable-contracts,-then-the-code-that-ends-up-being-executed-could-well-be-different-than-that-which-existed-at-the-time-the-proposal-was-made.-savvy-or-malicious-actors-could-frontrun-execution-calls-with-contract-logic-upgrade-calls.-daos-must-be-vigilant-against-this-and-should-consider-how-to-handle-upgradeable-code-explicitly-in-their-rules.", "labels": ["OpenZeppelin"]}, {"title": "Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.", "body": "Transactions could be crafted to look safe or even desirable when called, but then be completely malicious if they are delegate called. Which context a call is executed in comes down to a simple uint flag attached to a transaction. DAOs using the Optimistic Oracle need to be vigilant against potential transaction phishing attacks that use the wrong context for a call.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#transactions-could-be-crafted-to-look-safe-or-even-desirable-when-called,-but-then-be-completely-malicious-if-they-are-delegate-called.-which-context-a-call-is-executed-in-comes-down-to-a-simple-uint-flag-attached-to-a-transaction.-daos-using-the-optimistic-oracle-need-to-be-vigilant-against-potential-transaction-phishing-attacks-that-use-the-wrong-context-for-a-call.", "labels": ["OpenZeppelin"]}, {"title": "Finally, the Zodiac framework allows for additional modules, modifiers, and guards \u2013 essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These\u00a0entire\u00a0code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.", "body": "Finally, the Zodiac framework allows for additional modules, modifiers, and guards \u2013 essentially smart contract middleware that can sit between EOA interactions with the Optimistic Governor and interactions with the avatar. These\u00a0entire\u00a0code chains must be well understood as they could potentially modify the final behavior of the avatar in ways that inspection of proposals and of the Optimistic Governor on its own cannot anticipate.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#finally,-the-zodiac-framework-allows-for-additional-modules,-modifiers,-and-guards-\u2013-essentially-smart-contract-middleware-that-can-sit-between-eoa-interactions-with-the-optimistic-governor-and-interactions-with-the-avatar.-these\u00a0entire\u00a0code-chains-must-be-well-understood-as-they-could-potentially-modify-the-final-behavior-of-the-avatar-in-ways-that-inspection-of-proposals-and-of-the-optimistic-governor-on-its-own-cannot-anticipate.", "labels": ["OpenZeppelin"]}, {"title": "Findings", "body": "Here we present our findings.  Medium Severity  Change of collateral could result in unintended bond value  The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull request #3918.  The deleteProposal function may not work as expected with all avatars  The deleteProposal function allows the owner to delete a particular proposal so that it will not be executed. In the current implementation of the OptimisticGovernor contract the owner and the avatar are the same address. In general, an avatar does not necessarily have the ability to send arbitrary transactions without having enabled some module specifically for this purpose.  If an avatar were to have only the OptimisticGovernor module enabled, then it could not initiate a transaction in any way other than calling the proposeTransactions function. However, in this case the deleteProposal function would not work as expected.  Consider a scenario where an owner would like to delete an existing proposal via creating a new proposal:  If the owner creates a proposal to call deleteProposal via proposeTransactions, then the expiration time of the deleteProposal proposal will be greater than expire time of the original proposal which the owner wished to delete. Thus the owner would not be guaranteed to be able delete the original proposal because it could be executed before the deletion proposal passed the liveness threshold.  If the owner wanted to dispute the proposal they were trying to delete, then they could do so. But the assumption that only proposals which break the rules may not alway hold. Additionally, if the proposal technically followed the rules, but only elucidated how the rules themselves needed to be updated, any such rule update proposal would also run into the same sort of liveness delay dilemma.  Consider better documenting assumptions about the capabilities of the avatar and what may happen if those assumptions do not hold. Additionally, if having an avatar exclusively controlled by an OptimisticGovernor module is a reasonable use case, then consider allowing some other form of proposal deletion capabilities that can bypass the standard liveness condition in case of emergencies.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Notes & Additional Information  Commented out code  The proposeTransactions and executeProposal functions in the OptimisticGovernor contract include commented out lines of code.  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are meant to provide alternate implementation options, then consider extracting them to a separate document where they can be accompanied by a more thorough explanation of their purpose.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3919.  Coding style deviates from Solidity Style Guide  OptimisticGovernor contract the  _getOptimisticOracle and  _isContract functions are declared  internal functions.  This function order deviates from the recommended order of: constructor, receive, fallback, external, public, internal, private.  To increase overall code readability, consider reordering these functions and conforming to the Solidity Style Guide where possible.  Update: Fixed as of commit e35c199cc774066c4b65bcec8f82cffcc5aeabd4 in pull request #3920.  Disabling reentrancy protection is prone to error  In the OptimisticOracle contract all external functions are protected with a nonReentrant modifier. However, in designated places the user is allowed to perform a callback into the OptimisticOracle contract. This is achieved via the functions _startReentrantGuardDisabled and _endReentrantGuardDisabled which temporarily disables and manually re-enables reentrancy protection, respectively.  These functions must be used in pairs to perform as expected; that process is manual and potentially error prone.  To reduce the likelihood of error, consider including a continuous integration or custom linter check for pairwise matching _start and _end functions and for containment within a function that uses a nonReentrant modifier.  Update: acknowledged by UMA: This sort of linting would be helpful, but at the moment, its unclear how something like this could be implemented without a linter that can interpret solidity that also supports custom plugins.; no immediate code changes are needed.  immutable value could be used  In the OptimisticGovernor contract the finder variable is only ever set in the setUp initialization function. The value is not modifiable after deployment.  In practice, the finder implementation may generally be modified solely by the UMA team. Only after such an update to the implementation would users want to update their finder values. Then, if users do wish to migrate to the new finder address, they will need to deploy a new OptimisticGovernor module anyway.  Update: Fixed as of commit 7aae2aa34eabf7b3d5896e3537a9cfc8b17b4e6c in pull request #3921.  Some public functions could be external  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#findings", "labels": ["OpenZeppelin"]}, {"title": "Here we present our findings.", "body": "Here we present our findings.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#here-we-present-our-findings.", "labels": ["OpenZeppelin"]}, {"title": "Medium Severity", "body": "Medium Severity", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#medium-severity", "labels": ["OpenZeppelin"]}, {"title": "Locked assets in contracts", "body": "Once the protocol is deployed, the Comet and Bulker contracts will be two important pieces of the system. Comet is the main protocol contract while the Bulker is a useful tool to execute multiple protocol calls into one single transaction.  delegation toward the  receive payable function to accept ETH which is needed to be used in the  docstrings. In this case, any ETH sent through the  withdrawEthTo function. This function unwraps WETH by sending tokens to the WETH contract and receiving back ETH in the same amount in the  Lastly, a separate reference must also be done on ERC20 tokens. The Comet contract has the approveThis function which is enough to let a manager move any ERC20 funds that might get lost in the Comet balance. However, this is not the case for the Bulker contract, where ERC20 tokens might also get lost.  Consider establishing mechanisms to avoid such scenarios, as it results in a direct loss of user funds.  Update: Partially fixed in commit 3681613. In the words of the team: We think its a good idea to add sweep functions to the Bulker to prevent funds from being locked in there. As for Comet, we purposely made the receive function payable in case we ever wanted to support a payable function in CometExt. Doing so allows us to add a payable function to CometExt without having to also upgrade Comet. Since Comet is upgradeable, I dont think we need to support a way to sweep ETH out of the contract right off the bat.  Medium Severity  governor can approve anyone to transfer the base and collateral assets within the Comet contract  The COMP token, the governance module (GovernorBravo) and the Timelock are the three components that make up Compound governance, allowing for the management and upgrade of the protocol.  Comet implementation, there is a variable called  approveThis that only the governor can execute and it approves anyone to transfer the base and collateral assets outside the  Beanstalk and  Curve cases), user funds could be at risk.  If the function is meant to be used for specific purposes and cant be removed, consider properly documenting this risk and establish verification measures on governance proposals to avoid misuse of this feature. To reduce the possibilities of a governance attack, be sure to always rely on a delay mechanism for proposals to be executed and eventually a pause guardian that can take action if a malicious proposal is spotted.  Update: Fixed. The team has improved the docstrings in PR#414. In the words of the team: The main intention for approveThis is to allow governance to transfer out any ERC20s accidentally sent to Comet. We do recognize the ability for governance to give approval for the base and collateral assets and transfer out user funds. However, as OpenZeppelin has noted, this will likely require a governance attack. Wed like to point out that in the case of a governance attack, the attacker would not even need approveThis to steal user funds as they could upgrade the implementation of Comet to whatever they please.  The protocol may end up holding collateral assets in an unwanted manner  The Comet contract has an immutable value that defines the target amount of reserves of the base token. This value is closely related to the buyCollateral function. This function cannot be called successful if the protocol reserves are greater than or equal to this target.  If targetReserves is set to a small value, the contract could easily reach the level. The problem is that the absorptions can continue but the protocol will not be able to sell the collateral because the buyCollateral function cannot be used and the protocol could be in a situation where it would hold assets that may lose value over time.  In the opposite case, where targetReserves is set to a large value, the chance of reaching this level would be much lower so it could be a useless constraint.  Keeping in mind that setting this variable to a small value is more of a problem, be sure to set it to a large value. Also if the value of the target is too high to not have a useful or practical use, consider re-design the system to not make use of it.  Update: Acknowledged. In the words of the team: We intend for targetReserves to be a pretty large value so the protocol can use liquidations to build up a sizable reserve. Once reserves have reached targetReserves, we believe it may be advantageous for the protocol to start HODLing the collateral assets. Weve run backtesting simulations to identify this as the best strategy for the protocol to build up reserves, but this strategy can definitely change as we conduct more research around liquidation auction strategies.  Incorrect accounting of used gas  The asborbInternal function of the Comet contract contains important logic of the protocol where users that are liquidatable have their debts absorbed by the protocol. To do this task frequently and maintain health in the system, users will call this function whenever they detect a liquidatable user position.  As a reward for doing this task recurrently, absorbers (users calling the absorb function) are accounted for their gas expenditure into liquidation points, with the promise of redeeming those points for reward tokens in a separate contract.  The reward mechanism for the liquidation points is out of the scope for the current audit so we cant assess the incentives alignments in performing this task with profitable rewards.  However, how the gas used is measured doesnt reflect entirely the actual transaction cost for the user. In particular:  The priority fee is not taken into account. Absorbers will probably have to compete with each other and be as fast as possible in running absorbs. For this is likely to have a priority fee set as a miners tip in the transaction. Currently, the protocol only uses block.basefee but tx.gasprice = block.basefee + priority fee should be used instead.  Other operations are performed after the gas spent is measured, consuming more gas which is not taken into account.  Potentially, a user could deposit a minimum amount of each of the collateral assets supported by the protocol to increase the cost of the transaction, since it implies iteration over all supported assets recursively. Doing so, the rewards increase proportionally to the cost and it might be used maliciously by an underwater account since they might absorb their own position to earn rewards and potentially reduce damage from the liquidation.  Consider taking these suggestions into account and changing the way the gas used is measured to improve transparency and design correctness.  Update: Acknowledged. The team has improved docstrings in commit 14fbc27.  Low Severity  Everyone can deploy new Comet instances  Each Comet contract implementation that the protocol might decide to create is meant to be deployed in the Configurator contract.  This contract is an intermediate logic to bootstrap the entire protocol configuration and then apply it to a newly deployed Comet contract.  To do this, the Configurator makes use of a CometFactory contract which has a clone function whose sole role is to create a new Comet contract and return its address.  Whenever all protocol parameters are set, the deploy function in the Configurator contract is called. This function calls the clone function in the factory and emits an event to signal that a new Comet is ready with the configuration set so far.  The deploy and clone functions are both public callable functions, so anyone can, at any moment, generate the Comet instance either in the factory, passing arbitrary configurations, or either through the Configurator with the configuration set until that moment.  Is not clear why those functions are public as there is no benefit for users to call them. Moreover, leaving open the door for anyone to deploy instances of Comet with arbitrary configuration or emitting arbitrary events through the Configurator is a concern to take into account as it might be misused by malicious actors trying to create pishing-like attacks.  Consider restricting access to those functions and let them be called only by the governor or consider properly documenting such a design decision, raising awareness over the way it might be misused.  Update: Not fixed. The team acknowledge the issue and in their words: We considered making Configurator.deploy() a governor-only function, however it would require adding a storage slot and complicating the Configurator which does not seem worth the tradeoff. It also doesnt make sense to change CometFactory.clone() to be governor-only as the CometFactory is a stateless contract. We note for future reference that there isnt a great way to get a list of official Comet instances from on-chain, however the canonical repository does have a list (roots.json) for each chain, which seems sufficient until a better solution is established.  Gas inefficiencies  There are many places throughout the codebase where changes can be made to improve gas consumption. For example:  The for loops inside absorb and invoke functions do not cache the length of the array and perform unnecessary operations on each iteration.  The unchecked blocks for loop counters are not used consistently throughout the codebase. It is only used in the Invoke function, although it could be implemented in loops of the rest of the protocol contracts.  updateBasePrincipal in Comet should not check principal = 0 because in that case nothing will happen and gas will be wasted.  It is advisable that if a variable from the contracts storage is going to be read within a function several times, a copy in memory should first be created since reading to the storage directly is expensive. However, if you are only querying for the value once, as in accrueInternal and Comets fallback, it is recommended to read directly from storage without any intermediate steps.  In transferCollateral within the Comet contract, it is recommended to consult with getAssetInfoByAddress at the beginning of the function so that in case the token passed by the parameters is not within the collaterals of the protocol, the function fails early and without wasting gas unnecessarily.  Use unchecked { ++i; } over unchecked { i++; }.  When performing these changes, aim to reach an optimal tradeoff between gas optimization and readability. Having a codebase that is easy to understand reduces the chance of errors in the future and improves transparency for the community.  Update: Partially fixed in commit 90ca4d0.  Inconvenient use of immutable keyword  For accounts that use the protocol, the protocol provides a built-in system for tracking rewards. Comet contracts keep account of all accrued incentives for suppliers and borrowers of the base token, and users can claim them on CometRewards contract. It should be emphasized that all rewards from all the Comets from the same chain are claimed in the same CometRewards contract.  The latter has a governor variable defined which is the role that can set the reward settings and withdraw rewards from the contract. Since the contract does not have an upgradeability mechanism, it is inconvenient to define this variable as immutable. If the governor needs to be changed, a new contract must be deployed and the old contracts state must be migrated to the new one.  Consider adding this variable to the contract storage and specifying a setter function so that the governor can be changed any time it is needed.  Update: Fixed in commits 43b5502 and 4d1c1a4.  Logic contracts initialization allowed  The Configurator contract has an initializable function that is meant to be called by the proxy. However, nothing prevents users from directly calling the initialize function on the contract implementation. If someone does so, the state of the implementation would be initialized to some meaningful value.  We suggest adding a constructor that sets the version to an incredibly high number so that any attempt to call the implementation at the initialize function would revert with an AlreadyInitialized error or even a specific one to signal that initializing the implementation is prohibited.  Leaving an implementation contract not initialized is generally an insecure pattern to follow. In this case, it might lead to a situation where an attacker can take control over the implementation contract by passing himself as governor and try to mislead users toward malicious contracts. This is not a security issue on its own but we strongly suggest avoiding such scenarios in all implementation contracts.  As a source of inspiration, here theres an example of how the scenario can be avoided in general situations.  Update: Fixed in commit 79f59e5.  Missing validations  There are some places in the code base that might benefit from some sanity checks on the input provided:  The transferGovernor and setGovernor functions of the Configurator are not checking the address to be non-zero.  The CometRewards constructor is missing the same check over the address parameter.  In line 260 of the Comet contract, the priceFeed is set but is not checked to retrieve a valid price.  withdrawAndBorrowAmount and repayAndSupplyAmount functions assume certain values over the newPrincipal but those should be required instead.  To reduce possible errors and make the code more rodust, consider adding sanity checks where needed.  Update: Partially fixed in PR 455, merged commit bf20ccf. withdrawAndBorrowAmount and repayAndSupplyAmount have new validations but the rest of the items will not be fixed. In the words of the team: There are arbitrarily many bad addresses which can be set, checking for the zero address seems like added complexity for little gain. In addition, while further checks in Comet.sol could be added, the contract is being optimized for efficiency and is up against a size limit, so we favor the current approach.  Potential function clashes  The TransparentUpgradeableConfiguratorProxy overrides the _beforeCallback function.  Concretely, the _beforeCallback function is implemented in the TransparentUpgradeableProxy contract to avoid the admin of the contract to call the implementation logic directly.  deployAndUpgrade function of the  This is not a security issue on its own but it opens the door for potential clashes to happen. If one function is added either on the proxy or the logic contract, this can clash with any of the other contract functions. At this point, the admin will stop to be able to call the implementation contract (users will still be directed toward the implementation because of the ifAdmin modifier).  This article specifies how crafting clashes may not be too hard of a computational task. This article showcases how a new function in the proxy might actually enable clashes.  To avoid any unwanted behaviors, consider ensuring that the upgrade mechanism for Configurator always checks for potential clashes between the logic implementation and the proxy, especially if new functions are added.  Update: Fixed. The team added an off-chain check to avoid collisions in PR#430. Also, the team acknowledges the issue providing the following comments: The two types of clashes that can happen are:  New function on proxy is introduced that clashes with an existing function in the Configurator. Admin is no longer able to call the function on the Configurator. To recover: The admin should still be able to upgrade the implementation of the proxy because that function lives on the proxy. Governance can simply introduce a new version of Configurator without the clash and upgrade the proxy to this new implementation.  New function on Configurator is introduced that clashes with an existing function on the proxy. Admin cannot call this new Configurator function.To recover: Same recovery path as above. Function clashes only prevent the admin from calling a function on the Configurator, so the admin is still able to call the upgrade function on the proxy itself.  In either case, the contracts are in a recoverable state and nothing malicious can happen unless the admin is malicious.  Underwater accounts can minimize losses  In the Comet contract, during an absorbeInternal call, the updateBasePrincipal function is called, updating the accrued interests on the liquidated user position.  If the seizing of collateral brought the new users balance to positive values the user will:  Have his excess collateral exchanged for the base asset (during an absorb this might be beneficial if the collateral price is crashing).  Have supply interest and tracking indexes accrued straight away after the absorb, over the excess collateral converted into the base asset. Concretely, the accrueInternal will update interest rates and the updateBasePrincipal will update the tracking indexes.  Moreover, an underwater can decide to even liquidate himself, earning additional liquidation points.  Consider the extra value that an underwater can extract from his position to determine if this can be leveraged to create some attacks. If those are intended behaviors, consider improving the docstrings around the absorption mechanism to reflect these details.  Update: Acknowledged. In the words of the team: It sounds like the concern is that a user might absorb themselves for liquidator points and to sell off their collateral to the protocol quickly during a market downturn. In that case, its the purpose of the collateral factor to ensure a buffer in which the account becomes liquidatable and is still profitable to the protocol to liquidate. If a user chooses to absorb themselves it would economically imply governance has somehow created an absorption incentive greater than the liquidation penalty.  Unnecessary complexity  The Comet contract delegates some feature implementations into the CometExt contract. This contract is meant to be an actual extension of Comet logic and implement some functions and parameters, including the version parameter.  At the same time, Comet is built through an upgradeable proxy pattern that requires a new Comet version to be deployed and the proxy pointed toward the new implementation.  During an upgrade, it is convenient to upgrade the version number to a greater value and to do so the protocol must deploy also a new CometExt implementation contract to indicate a new version.  This is because the version parameter is declared as constant and cant be changed as a result of an upgrade mechanism without actually changing it in the contracts code.  In the worst-case scenario, an error is performed in the upgrade mechanism, the version number is not incremented and potential systems integrated with the protocol might depend on that version number to establish some other logic.  To avoid deploying a new CometExt even if its implementation didnt change, consider moving the version parameter into the Comet contract code.  Eventually consider keeping version in both contracts to differentiate between them, as both contracts might require some implementation changes.  Update: Acknowledged. In the words of the team: The version in CometExt is meant specifically as part of the EIP712Domain of the contract. Only changes which affect this domain should be reflected in this version. Furthermore the logic relating to the domain is currently isolated to the extension contract, which is useful because it reduces the main contract size, and the size of the main factory.  Notes & Additional Information  Anyone can set baseTrackingIndex  In the Comet contract, the accrueAccount function is publicly callable and it accrues interest rates and updates tracking indexes on the account specified as the input parameter.  Specifically, the tracking indexes are updated in the updateBasePrincipal function where if newPrincipal >= 0 then the baseTrackingIndex is set to a meaningful value.  So anyone is able to set this value for accounts that do not even exist on the protocol. Even if it is not a security issue on its own, consider restricting t", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#locked-assets-in-contracts", "labels": ["OpenZeppelin"]}, {"title": "governor can approve anyone to transfer the base and collateral assets within the Comet contract", "body": "governor can approve anyone to transfer the base and collateral assets within the Comet contract", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#governor-can-approve-anyone-to-transfer-the-base-and-collateral-assets-within-the-comet-contract", "labels": ["OpenZeppelin"]}, {"title": "The protocol may end up holding collateral assets in an unwanted manner", "body": "The Comet contract has an immutable value that defines the target amount of reserves of the base token. This value is closely related to the buyCollateral function. This function cannot be called successful if the protocol reserves are greater than or equal to this target.  If targetReserves is set to a small value, the contract could easily reach the level. The problem is that the absorptions can continue but the protocol will not be able to sell the collateral because the buyCollateral function cannot be used and the protocol could be in a situation where it would hold assets that may lose value over time.  In the opposite case, where targetReserves is set to a large value, the chance of reaching this level would be much lower so it could be a useless constraint.  Keeping in mind that setting this variable to a small value is more of a problem, be sure to set it to a large value. Also if the value of the target is too high to not have a useful or practical use, consider re-design the system to not make use of it.  Update: Acknowledged. In the words of the team: We intend for targetReserves to be a pretty large value so the protocol can use liquidations to build up a sizable reserve. Once reserves have reached targetReserves, we believe it may be advantageous for the protocol to start HODLing the collateral assets. Weve run backtesting simulations to identify this as the best strategy for the protocol to build up reserves, but this strategy can definitely change as we conduct more research around liquidation auction strategies.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#the-protocol-may-end-up-holding-collateral-assets-in-an-unwanted-manner", "labels": ["OpenZeppelin"]}, {"title": "Incorrect accounting of used gas", "body": "The asborbInternal function of the Comet contract contains important logic of the protocol where users that are liquidatable have their debts absorbed by the protocol. To do this task frequently and maintain health in the system, users will call this function whenever they detect a liquidatable user position.  As a reward for doing this task recurrently, absorbers (users calling the absorb function) are accounted for their gas expenditure into liquidation points, with the promise of redeeming those points for reward tokens in a separate contract.  The reward mechanism for the liquidation points is out of the scope for the current audit so we cant assess the incentives alignments in performing this task with profitable rewards.  However, how the gas used is measured doesnt reflect entirely the actual transaction cost for the user. In particular:  The priority fee is not taken into account. Absorbers will probably have to compete with each other and be as fast as possible in running absorbs. For this is likely to have a priority fee set as a miners tip in the transaction. Currently, the protocol only uses block.basefee but tx.gasprice = block.basefee + priority fee should be used instead.  Other operations are performed after the gas spent is measured, consuming more gas which is not taken into account.  Potentially, a user could deposit a minimum amount of each of the collateral assets supported by the protocol to increase the cost of the transaction, since it implies iteration over all supported assets recursively. Doing so, the rewards increase proportionally to the cost and it might be used maliciously by an underwater account since they might absorb their own position to earn rewards and potentially reduce damage from the liquidation.  Consider taking these suggestions into account and changing the way the gas used is measured to improve transparency and design correctness.  Update: Acknowledged. The team has improved docstrings in commit 14fbc27.  Low Severity", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#incorrect-accounting-of-used-gas", "labels": ["OpenZeppelin"]}, {"title": "Everyone can deploy new Comet instances", "body": "Each Comet contract implementation that the protocol might decide to create is meant to be deployed in the Configurator contract.  This contract is an intermediate logic to bootstrap the entire protocol configuration and then apply it to a newly deployed Comet contract.  To do this, the Configurator makes use of a CometFactory contract which has a clone function whose sole role is to create a new Comet contract and return its address.  Whenever all protocol parameters are set, the deploy function in the Configurator contract is called. This function calls the clone function in the factory and emits an event to signal that a new Comet is ready with the configuration set so far.  The deploy and clone functions are both public callable functions, so anyone can, at any moment, generate the Comet instance either in the factory, passing arbitrary configurations, or either through the Configurator with the configuration set until that moment.  Is not clear why those functions are public as there is no benefit for users to call them. Moreover, leaving open the door for anyone to deploy instances of Comet with arbitrary configuration or emitting arbitrary events through the Configurator is a concern to take into account as it might be misused by malicious actors trying to create pishing-like attacks.  Consider restricting access to those functions and let them be called only by the governor or consider properly documenting such a design decision, raising awareness over the way it might be misused.  Update: Not fixed. The team acknowledge the issue and in their words: We considered making Configurator.deploy() a governor-only function, however it would require adding a storage slot and complicating the Configurator which does not seem worth the tradeoff. It also doesnt make sense to change CometFactory.clone() to be governor-only as the CometFactory is a stateless contract. We note for future reference that there isnt a great way to get a list of official Comet instances from on-chain, however the canonical repository does have a list (roots.json) for each chain, which seems sufficient until a better solution is established.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#everyone-can-deploy-new-comet-instances", "labels": ["OpenZeppelin"]}, {"title": "Gas inefficiencies", "body": "There are many places throughout the codebase where changes can be made to improve gas consumption. For example:  The for loops inside absorb and invoke functions do not cache the length of the array and perform unnecessary operations on each iteration.  The unchecked blocks for loop counters are not used consistently throughout the codebase. It is only used in the Invoke function, although it could be implemented in loops of the rest of the protocol contracts.  updateBasePrincipal in Comet should not check principal = 0 because in that case nothing will happen and gas will be wasted.  It is advisable that if a variable from the contracts storage is going to be read within a function several times, a copy in memory should first be created since reading to the storage directly is expensive. However, if you are only querying for the value once, as in accrueInternal and Comets fallback, it is recommended to read directly from storage without any intermediate steps.  In transferCollateral within the Comet contract, it is recommended to consult with getAssetInfoByAddress at the beginning of the function so that in case the token passed by the parameters is not within the collaterals of the protocol, the function fails early and without wasting gas unnecessarily.  Use unchecked { ++i; } over unchecked { i++; }.  When performing these changes, aim to reach an optimal tradeoff between gas optimization and readability. Having a codebase that is easy to understand reduces the chance of errors in the future and improves transparency for the community.  Update: Partially fixed in commit 90ca4d0.  Inconvenient use of immutable keyword  For accounts that use the protocol, the protocol provides a built-in system for tracking rewards. Comet contracts keep account of all accrued incentives for suppliers and borrowers of the base token, and users can claim them on CometRewards contract. It should be emphasized that all rewards from all the Comets from the same chain are claimed in the same CometRewards contract.  The latter has a governor variable defined which is the role that can set the reward settings and withdraw rewards from the contract. Since the contract does not have an upgradeability mechanism, it is inconvenient to define this variable as immutable. If the governor needs to be changed, a new contract must be deployed and the old contracts state must be migrated to the new one.  Consider adding this variable to the contract storage and specifying a setter function so that the governor can be changed any time it is needed.  Update: Fixed in commits 43b5502 and 4d1c1a4.  Logic contracts initialization allowed  The Configurator contract has an initializable function that is meant to be called by the proxy. However, nothing prevents users from directly calling the initialize function on the contract implementation. If someone does so, the state of the implementation would be initialized to some meaningful value.  We suggest adding a constructor that sets the version to an incredibly high number so that any attempt to call the implementation at the initialize function would revert with an AlreadyInitialized error or even a specific one to signal that initializing the implementation is prohibited.  Leaving an implementation contract not initialized is generally an insecure pattern to follow. In this case, it might lead to a situation where an attacker can take control over the implementation contract by passing himself as governor and try to mislead users toward malicious contracts. This is not a security issue on its own but we strongly suggest avoiding such scenarios in all implementation contracts.  As a source of inspiration, here theres an example of how the scenario can be avoided in general situations.  Update: Fixed in commit 79f59e5.  Missing validations  There are some places in the code base that might benefit from some sanity checks on the input provided:  The transferGovernor and setGovernor functions of the Configurator are not checking the address to be non-zero.  The CometRewards constructor is missing the same check over the address parameter.  In line 260 of the Comet contract, the priceFeed is set but is not checked to retrieve a valid price.  withdrawAndBorrowAmount and repayAndSupplyAmount functions assume certain values over the newPrincipal but those should be required instead.  To reduce possible errors and make the code more rodust, consider adding sanity checks where needed.  Update: Partially fixed in PR 455, merged commit bf20ccf. withdrawAndBorrowAmount and repayAndSupplyAmount have new validations but the rest of the items will not be fixed. In the words of the team: There are arbitrarily many bad addresses which can be set, checking for the zero address seems like added complexity for little gain. In addition, while further checks in Comet.sol could be added, the contract is being optimized for efficiency and is up against a size limit, so we favor the current approach.  Potential function clashes  The TransparentUpgradeableConfiguratorProxy overrides the _beforeCallback function.  Concretely, the _beforeCallback function is implemented in the TransparentUpgradeableProxy contract to avoid the admin of the contract to call the implementation logic directly.  deployAndUpgrade function of the  This is not a security issue on its own but it opens the door for potential clashes to happen. If one function is added either on the proxy or the logic contract, this can clash with any of the other contract functions. At this point, the admin will stop to be able to call the implementation contract (users will still be directed toward the implementation because of the ifAdmin modifier).  This article specifies how crafting clashes may not be too hard of a computational task. This article showcases how a new function in the proxy might actually enable clashes.  To avoid any unwanted behaviors, consider ensuring that the upgrade mechanism for Configurator always checks for potential clashes between the logic implementation and the proxy, especially if new functions are added.  Update: Fixed. The team added an off-chain check to avoid collisions in PR#430. Also, the team acknowledges the issue providing the following comments: The two types of clashes that can happen are:  New function on proxy is introduced that clashes with an existing function in the Configurator. Admin is no longer able to call the function on the Configurator. To recover: The admin should still be able to upgrade the implementation of the proxy because that function lives on the proxy. Governance can simply introduce a new version of Configurator without the clash and upgrade the proxy to this new implementation.  New function on Configurator is introduced that clashes with an existing function on the proxy. Admin cannot call this new Configurator function.To recover: Same recovery path as above. Function clashes only prevent the admin from calling a function on the Configurator, so the admin is still able to call the upgrade function on the proxy itself.  In either case, the contracts are in a recoverable state and nothing malicious can happen unless the admin is malicious.  Underwater accounts can minimize losses  In the Comet contract, during an absorbeInternal call, the updateBasePrincipal function is called, updating the accrued interests on the liquidated user position.  If the seizing of collateral brought the new users balance to positive values the user will:  Have his excess collateral exchanged for the base asset (during an absorb this might be beneficial if the collateral price is crashing).  Have supply interest and tracking indexes accrued straight away after the absorb, over the excess collateral converted into the base asset. Concretely, the accrueInternal will update interest rates and the updateBasePrincipal will update the tracking indexes.  Moreover, an underwater can decide to even liquidate himself, earning additional liquidation points.  Consider the extra value that an underwater can extract from his position to determine if this can be leveraged to create some attacks. If those are intended behaviors, consider improving the docstrings around the absorption mechanism to reflect these details.  Update: Acknowledged. In the words of the team: It sounds like the concern is that a user might absorb themselves for liquidator points and to sell off their collateral to the protocol quickly during a market downturn. In that case, its the purpose of the collateral factor to ensure a buffer in which the account becomes liquidatable and is still profitable to the protocol to liquidate. If a user chooses to absorb themselves it would economically imply governance has somehow created an absorption incentive greater than the liquidation penalty.  Unnecessary complexity  The Comet contract delegates some feature implementations into the CometExt contract. This contract is meant to be an actual extension of Comet logic and implement some functions and parameters, including the version parameter.  At the same time, Comet is built through an upgradeable proxy pattern that requires a new Comet version to be deployed and the proxy pointed toward the new implementation.  During an upgrade, it is convenient to upgrade the version number to a greater value and to do so the protocol must deploy also a new CometExt implementation contract to indicate a new version.  This is because the version parameter is declared as constant and cant be changed as a result of an upgrade mechanism without actually changing it in the contracts code.  In the worst-case scenario, an error is performed in the upgrade mechanism, the version number is not incremented and potential systems integrated with the protocol might depend on that version number to establish some other logic.  To avoid deploying a new CometExt even if its implementation didnt change, consider moving the version parameter into the Comet contract code.  Eventually consider keeping version in both contracts to differentiate between them, as both contracts might require some implementation changes.  Update: Acknowledged. In the words of the team: The version in CometExt is meant specifically as part of the EIP712Domain of the contract. Only changes which affect this domain should be reflected in this version. Furthermore the logic relating to the domain is currently isolated to the extension contract, which is useful because it reduces the main contract size, and the size of the main factory.  Notes & Additional Information  Anyone can set baseTrackingIndex  In the Comet contract, the accrueAccount function is publicly callable and it accrues interest rates and updates tracking indexes on the account specified as the input parameter.  Specifically, the tracking indexes are updated in the updateBasePrincipal function where if newPrincipal >= 0 then the baseTrackingIndex is set to a meaningful value.  So anyone is able to set this value for accounts that do not even exist on the protocol. Even if it is not a security issue on its own, consider restricting this function to users that have a principal strictly greater than zero.  Update: Not fixed. However, the team added a unit test in commit d4abcb2 to check that it doesnt affect the protocol.  Inconsistent coding style  Inconsistencies in coding style were identified throughout the code base. Some examples are:  constants variables version and name and not in UPPER_CASE like other constant variables  The convention of functions named with the _ prefix is not clear. Sometimes it is used for admin functions and other times for internal functions  Some structs use _reserved to fill slots, but others do not.  It is not clear what convention is used for the naming of codebase interfaces. Sometimes the letter I is used as a prefix, sometimes the word Interface at the end or in some cases the contract even misses both.  Taking into consideration how much value a consistent coding style adds to the projects readability, enforcing a standard coding style with help of linter tools such as Solhint is recommended.  Update: Partially fixed. Only the second item has been fixed in commit c04c056.  CometMath is not used consistently  Many functions that could be in CometMath, a utility contract that contains pure mathematical functions, are scattered throughout the codebase and min, one of the functions within the contract, is not being used.  Consider consolidating all the helper math functions in one place and removing unused ones.  Update: Partially fixed in commit 16d213f. The min function has been removed.  Compilation warnings  While compiling the codebase contracts. The compiler raises some warnings. Specifically:  The totalSupply and totalBorrow variables of the getUtilization and of the getReserves functions have the same name as the totalSupply and totalBorrow public functions.  The withdrawAndBorrowAmount function visibility can be restricted to pure.  Consider resolving all compiler warnings.  Update: Fixed in commit 9e2b195.  Incorrect or missing docstrings  Across the codebase, some contracts lack proper documentation and docstrings. In particular, the IWETH9 and CometMath functions or the CometConfiguration and CometStorage variables are having little comments or nothing at all.  Consider thoroughly documenting all functions and parameters that are part of the contracts public API. Functions or parameters implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  have no setters but it doesnt specify where those are set, eventually in the  passed as input in the Configurator initialization.  Consider writing this in the docstrings of the initialize function to improve clarity.  Update: Partially fixed in commit 9227075. Docstring was only changed in the Configurator contract.  Lack of indexed parameters  The CometDeployed, GovernorTransferred, SetFactory, SetGovernor, SetPauseGuardian, SetBaseTokenPriceFeed, SetExtensionsDelegate events lack of any indexed parameter.  Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Fixed in commit 7124b98.  Contracts folder is not properly organized  There is no convenient structure in the contracts folder to easily navigate between them. All contracts, regardless of their type or module they belong to, are mixed in a single folder.  To favor the developer experience and the maintenance of the codebase, consider adding additional folders following the structure within the vendor directory or separating protocol components into different internal folders.  Update: Acknowledged. In the words of the team: The code actually is logically organized in that the protocol code sits at the top-level, with test and vendored contracts being secondary and sitting in subdirectories. In the future, the team might reorganize into subdirectories but not at this time.  rewardsClaimed can be mixed between different tokens  In CometRewards it is possible to change the reward token of each Comet through _setRewardConfig. However, if the reward token is changed, the number of previous reward tokens claimed will persist and once someone claims their new reward asset, it will be added to rewardsClaimed despite being different assets.  Consider removing the ability to change the reward asset once set or changing the way the claimed rewards are stored if the reward asset changes.  Update: Fixed in commit ced8026.  Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Here are some examples:  The name CometProxyAdmin suggests that it is only the admin of the Comet proxy, but in reality, it will also have the same role on the Configurator proxy. Choose another name to avoid confusion.  TransparentUpgradeableConfiguratorProxy can be called ConfiguratorProxy. There is no need to use the inherited contract name as a prefix.  In CometMath, change InvalidUInt to InvalidUint and toUInt to toUint.  rescale and descale have different names but the same value, consider using one variable name scale.  Update: Partially fixed in commit b5a64d0.  Use of Global imports  Non-explicit imports are used throughout all protocol contracts, which reduces code readability and could lead to conflicts between names defined locally and the ones imported.  The inheritance chains within the protocol are long, and for this, the codebase would benefit from refactoring specifically which definitions are being imported in each contract.  On the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged. In the words of the team: We do not consider this important or worth the effort of refactoring at this time.  Potential front-run  The deployAndUpgrade function of the CometProxyAdmin is restricted in access to be called exclusively by the governance. It deploys a new Comet instance through the Configurator and upgrades the implementation address in the proxy.  However, it doesnt call the initializeStorage function of the Comet contract through the proxy, leaving the new implementation not initialized. The function doesnt take any input parameter and it is meant to be called only once without the need to call it again on new implementation upgrades.  Whether the first initialization is performed on a separate transaction or if in the future it will be possible to re-initialize the Comet instance with some input values, any user can front-run any governance attempt to initialize the new deployed Comet.  Consider taking into account that deployAndUpgrade and initializeStorage should be done in one unique transaction to avoid the front-run scenario, especially if input parameters or re-initializations are meant to happen in future developments.  Update: Acknowledged. The team added a scenario in PR#431 to test the governance flow for upgrading to a new version of Comet and calling its initialize function via one proposal.  Potential reentrancies  In the codebase, we found two places where reentrancy can occur. However, those do not pose any security issue or concern but awareness should be raised:  The invoke function of the Bulker contract can be re-entered.  The doTransferIn function of the Comet contract is often executed at the very beginning of executions, being it an anti-pattern to follow against reentrancy. Even if re-entering the same doTransferIn cant be used as vector attack in this case, one can re-enter a different function, modifying the state in an unexpected manner. Making external calls is always suggested to be done after checks and effects.  To improve clarity, consider either reducing the attack surface by making those functions non-reentrant or document and raise awarness on such scenarios.  Update: Acknowledged. The team understands the concerns and replies: Specific concerns due to reentrancies should be addressed with tests, static analysis or formal verification or code changes. Excessive documentation notes about universal theoretical concerns dont likely add much except make the documentation harder to read and maintain.  Repetitive code  In many parts of the codebase, repeated or similar lines of code can be seen. Here are some examples:  In Comet, lines 520-525, 555-561, 593-598 and 628-634 are repeated and loops after those sections have strong similarities.  timeElapsed > 0 check is performed two times, when accrueInternal is called, and when internally accruedInterestIndices is called.  allow and approve in CometExt do the same thing.  Consider reusing the same code defined in just one place or, if appropriate, removing duplicate code.  Update: Acknowledged. In the words of the team: We gave considerable thought to how redundant s", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#gas-inefficiencies", "labels": ["OpenZeppelin"]}, {"title": "Inconvenient use of immutable keyword", "body": "Inconvenient use of immutable keyword", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#inconvenient-use-of-immutable-keyword", "labels": ["OpenZeppelin"]}, {"title": "Logic contracts initialization allowed", "body": "The Configurator contract has an initializable function that is meant to be called by the proxy. However, nothing prevents users from directly calling the initialize function on the contract implementation. If someone does so, the state of the implementation would be initialized to some meaningful value.  We suggest adding a constructor that sets the version to an incredibly high number so that any attempt to call the implementation at the initialize function would revert with an AlreadyInitialized error or even a specific one to signal that initializing the implementation is prohibited.  Leaving an implementation contract not initialized is generally an insecure pattern to follow. In this case, it might lead to a situation where an attacker can take control over the implementation contract by passing himself as governor and try to mislead users toward malicious contracts. This is not a security issue on its own but we strongly suggest avoiding such scenarios in all implementation contracts.  As a source of inspiration, here theres an example of how the scenario can be avoided in general situations.  Update: Fixed in commit 79f59e5.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#logic-contracts-initialization-allowed", "labels": ["OpenZeppelin"]}, {"title": "Missing validations", "body": "There are some places in the code base that might benefit from some sanity checks on the input provided:  The transferGovernor and setGovernor functions of the Configurator are not checking the address to be non-zero.  The CometRewards constructor is missing the same check over the address parameter.  In line 260 of the Comet contract, the priceFeed is set but is not checked to retrieve a valid price.  withdrawAndBorrowAmount and repayAndSupplyAmount functions assume certain values over the newPrincipal but those should be required instead.  To reduce possible errors and make the code more rodust, consider adding sanity checks where needed.  Update: Partially fixed in PR 455, merged commit bf20ccf. withdrawAndBorrowAmount and repayAndSupplyAmount have new validations but the rest of the items will not be fixed. In the words of the team: There are arbitrarily many bad addresses which can be set, checking for the zero address seems like added complexity for little gain. In addition, while further checks in Comet.sol could be added, the contract is being optimized for efficiency and is up against a size limit, so we favor the current approach.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#missing-validations", "labels": ["OpenZeppelin"]}, {"title": "Potential function clashes", "body": "The TransparentUpgradeableConfiguratorProxy overrides the _beforeCallback function.  Concretely, the _beforeCallback function is implemented in the TransparentUpgradeableProxy contract to avoid the admin of the contract to call the implementation logic directly.  deployAndUpgrade function of the  This is not a security issue on its own but it opens the door for potential clashes to happen. If one function is added either on the proxy or the logic contract, this can clash with any of the other contract functions. At this point, the admin will stop to be able to call the implementation contract (users will still be directed toward the implementation because of the ifAdmin modifier).  This article specifies how crafting clashes may not be too hard of a computational task. This article showcases how a new function in the proxy might actually enable clashes.  To avoid any unwanted behaviors, consider ensuring that the upgrade mechanism for Configurator always checks for potential clashes between the logic implementation and the proxy, especially if new functions are added.  Update: Fixed. The team added an off-chain check to avoid collisions in PR#430. Also, the team acknowledges the issue providing the following comments: The two types of clashes that can happen are:  New function on proxy is introduced that clashes with an existing function in the Configurator. Admin is no longer able to call the function on the Configurator. To recover: The admin should still be able to upgrade the implementation of the proxy because that function lives on the proxy. Governance can simply introduce a new version of Configurator without the clash and upgrade the proxy to this new implementation.  New function on Configurator is introduced that clashes with an existing function on the proxy. Admin cannot call this new Configurator function.To recover: Same recovery path as above. Function clashes only prevent the admin from calling a function on the Configurator, so the admin is still able to call the upgrade function on the proxy itself.  In either case, the contracts are in a recoverable state and nothing malicious can happen unless the admin is malicious.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#potential-function-clashes", "labels": ["OpenZeppelin"]}, {"title": "Underwater accounts can minimize losses", "body": "In the Comet contract, during an absorbeInternal call, the updateBasePrincipal function is called, updating the accrued interests on the liquidated user position.  If the seizing of collateral brought the new users balance to positive values the user will:  Have his excess collateral exchanged for the base asset (during an absorb this might be beneficial if the collateral price is crashing).  Have supply interest and tracking indexes accrued straight away after the absorb, over the excess collateral converted into the base asset. Concretely, the accrueInternal will update interest rates and the updateBasePrincipal will update the tracking indexes.  Moreover, an underwater can decide to even liquidate himself, earning additional liquidation points.  Consider the extra value that an underwater can extract from his position to determine if this can be leveraged to create some attacks. If those are intended behaviors, consider improving the docstrings around the absorption mechanism to reflect these details.  Update: Acknowledged. In the words of the team: It sounds like the concern is that a user might absorb themselves for liquidator points and to sell off their collateral to the protocol quickly during a market downturn. In that case, its the purpose of the collateral factor to ensure a buffer in which the account becomes liquidatable and is still profitable to the protocol to liquidate. If a user chooses to absorb themselves it would economically imply governance has somehow created an absorption incentive greater than the liquidation penalty.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#underwater-accounts-can-minimize-losses", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary complexity", "body": "The Comet contract delegates some feature implementations into the CometExt contract. This contract is meant to be an actual extension of Comet logic and implement some functions and parameters, including the version parameter.  At the same time, Comet is built through an upgradeable proxy pattern that requires a new Comet version to be deployed and the proxy pointed toward the new implementation.  During an upgrade, it is convenient to upgrade the version number to a greater value and to do so the protocol must deploy also a new CometExt implementation contract to indicate a new version.  This is because the version parameter is declared as constant and cant be changed as a result of an upgrade mechanism without actually changing it in the contracts code.  In the worst-case scenario, an error is performed in the upgrade mechanism, the version number is not incremented and potential systems integrated with the protocol might depend on that version number to establish some other logic.  To avoid deploying a new CometExt even if its implementation didnt change, consider moving the version parameter into the Comet contract code.  Eventually consider keeping version in both contracts to differentiate between them, as both contracts might require some implementation changes.  Update: Acknowledged. In the words of the team: The version in CometExt is meant specifically as part of the EIP712Domain of the contract. Only changes which affect this domain should be reflected in this version. Furthermore the logic relating to the domain is currently isolated to the extension contract, which is useful because it reduces the main contract size, and the size of the main factory.  Notes & Additional Information  Anyone can set baseTrackingIndex  In the Comet contract, the accrueAccount function is publicly callable and it accrues interest rates and updates tracking indexes on the account specified as the input parameter.  Specifically, the tracking indexes are updated in the updateBasePrincipal function where if newPrincipal >= 0 then the baseTrackingIndex is set to a meaningful value.  So anyone is able to set this value for accounts that do not even exist on the protocol. Even if it is not a security issue on its own, consider restricting this function to users that have a principal strictly greater than zero.  Update: Not fixed. However, the team added a unit test in commit d4abcb2 to check that it doesnt affect the protocol.  Inconsistent coding style  Inconsistencies in coding style were identified throughout the code base. Some examples are:  constants variables version and name and not in UPPER_CASE like other constant variables  The convention of functions named with the _ prefix is not clear. Sometimes it is used for admin functions and other times for internal functions  Some structs use _reserved to fill slots, but others do not.  It is not clear what convention is used for the naming of codebase interfaces. Sometimes the letter I is used as a prefix, sometimes the word Interface at the end or in some cases the contract even misses both.  Taking into consideration how much value a consistent coding style adds to the projects readability, enforcing a standard coding style with help of linter tools such as Solhint is recommended.  Update: Partially fixed. Only the second item has been fixed in commit c04c056.  CometMath is not used consistently  Many functions that could be in CometMath, a utility contract that contains pure mathematical functions, are scattered throughout the codebase and min, one of the functions within the contract, is not being used.  Consider consolidating all the helper math functions in one place and removing unused ones.  Update: Partially fixed in commit 16d213f. The min function has been removed.  Compilation warnings  While compiling the codebase contracts. The compiler raises some warnings. Specifically:  The totalSupply and totalBorrow variables of the getUtilization and of the getReserves functions have the same name as the totalSupply and totalBorrow public functions.  The withdrawAndBorrowAmount function visibility can be restricted to pure.  Consider resolving all compiler warnings.  Update: Fixed in commit 9e2b195.  Incorrect or missing docstrings  Across the codebase, some contracts lack proper documentation and docstrings. In particular, the IWETH9 and CometMath functions or the CometConfiguration and CometStorage variables are having little comments or nothing at all.  Consider thoroughly documenting all functions and parameters that are part of the contracts public API. Functions or parameters implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  have no setters but it doesnt specify where those are set, eventually in the  passed as input in the Configurator initialization.  Consider writing this in the docstrings of the initialize function to improve clarity.  Update: Partially fixed in commit 9227075. Docstring was only changed in the Configurator contract.  Lack of indexed parameters  The CometDeployed, GovernorTransferred, SetFactory, SetGovernor, SetPauseGuardian, SetBaseTokenPriceFeed, SetExtensionsDelegate events lack of any indexed parameter.  Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Fixed in commit 7124b98.  Contracts folder is not properly organized  There is no convenient structure in the contracts folder to easily navigate between them. All contracts, regardless of their type or module they belong to, are mixed in a single folder.  To favor the developer experience and the maintenance of the codebase, consider adding additional folders following the structure within the vendor directory or separating protocol components into different internal folders.  Update: Acknowledged. In the words of the team: The code actually is logically organized in that the protocol code sits at the top-level, with test and vendored contracts being secondary and sitting in subdirectories. In the future, the team might reorganize into subdirectories but not at this time.  rewardsClaimed can be mixed between different tokens  In CometRewards it is possible to change the reward token of each Comet through _setRewardConfig. However, if the reward token is changed, the number of previous reward tokens claimed will persist and once someone claims their new reward asset, it will be added to rewardsClaimed despite being different assets.  Consider removing the ability to change the reward asset once set or changing the way the claimed rewards are stored if the reward asset changes.  Update: Fixed in commit ced8026.  Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Here are some examples:  The name CometProxyAdmin suggests that it is only the admin of the Comet proxy, but in reality, it will also have the same role on the Configurator proxy. Choose another name to avoid confusion.  TransparentUpgradeableConfiguratorProxy can be called ConfiguratorProxy. There is no need to use the inherited contract name as a prefix.  In CometMath, change InvalidUInt to InvalidUint and toUInt to toUint.  rescale and descale have different names but the same value, consider using one variable name scale.  Update: Partially fixed in commit b5a64d0.  Use of Global imports  Non-explicit imports are used throughout all protocol contracts, which reduces code readability and could lead to conflicts between names defined locally and the ones imported.  The inheritance chains within the protocol are long, and for this, the codebase would benefit from refactoring specifically which definitions are being imported in each contract.  On the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged. In the words of the team: We do not consider this important or worth the effort of refactoring at this time.  Potential front-run  The deployAndUpgrade function of the CometProxyAdmin is restricted in access to be called exclusively by the governance. It deploys a new Comet instance through the Configurator and upgrades the implementation address in the proxy.  However, it doesnt call the initializeStorage function of the Comet contract through the proxy, leaving the new implementation not initialized. The function doesnt take any input parameter and it is meant to be called only once without the need to call it again on new implementation upgrades.  Whether the first initialization is performed on a separate transaction or if in the future it will be possible to re-initialize the Comet instance with some input values, any user can front-run any governance attempt to initialize the new deployed Comet.  Consider taking into account that deployAndUpgrade and initializeStorage should be done in one unique transaction to avoid the front-run scenario, especially if input parameters or re-initializations are meant to happen in future developments.  Update: Acknowledged. The team added a scenario in PR#431 to test the governance flow for upgrading to a new version of Comet and calling its initialize function via one proposal.  Potential reentrancies  In the codebase, we found two places where reentrancy can occur. However, those do not pose any security issue or concern but awareness should be raised:  The invoke function of the Bulker contract can be re-entered.  The doTransferIn function of the Comet contract is often executed at the very beginning of executions, being it an anti-pattern to follow against reentrancy. Even if re-entering the same doTransferIn cant be used as vector attack in this case, one can re-enter a different function, modifying the state in an unexpected manner. Making external calls is always suggested to be done after checks and effects.  To improve clarity, consider either reducing the attack surface by making those functions non-reentrant or document and raise awarness on such scenarios.  Update: Acknowledged. The team understands the concerns and replies: Specific concerns due to reentrancies should be addressed with tests, static analysis or formal verification or code changes. Excessive documentation notes about universal theoretical concerns dont likely add much except make the documentation harder to read and maintain.  Repetitive code  In many parts of the codebase, repeated or similar lines of code can be seen. Here are some examples:  In Comet, lines 520-525, 555-561, 593-598 and 628-634 are repeated and loops after those sections have strong similarities.  timeElapsed > 0 check is performed two times, when accrueInternal is called, and when internally accruedInterestIndices is called.  allow and approve in CometExt do the same thing.  Consider reusing the same code defined in just one place or, if appropriate, removing duplicate code.  Update: Acknowledged. In the words of the team: We gave considerable thought to how redundant sections of the code were organized and tried various permutations. Although seemingly redundant, the current form is overall the best we found in terms of the properties we were evaluating (namely clarity, code size, gas cost).  Typos  Line 96 of the CometExt contract has a typo whi and the number of decimals showed here is wrong, as it should be one zero less.  To improve correctness and readability, consider reviewing both the contracts and the documentation for typos.  Update: Fixed in commit a1bd99f.  Unnecessary return values  In the Comet contract, there are functions like the supply or withdraw that return calls to internal functions even if theres no actual final value returned at the end.  Consider reviewing all the occurrences where this happens and avoid returning when not necessary. This will improve readability and correctness.  Update: Acknowledged. In the words of the team: These are used to handoff control flow and can actually improve readability with that understanding.  Lack of explicitness on data type sizes  The protocol heavily relies on different sized variables, which can have also positive or negative values and different scaling factors. Thanks to this, the deployment and execution of the codebase will decrease gas costs.  Given the fact that it adds some complexity and undermines the readability of the codebase, it is of utter importance to maintain explicitness and consistency across different contracts.  Specifically, implicit castings and sizes should be avoided.  To improve the overall quality of the codebase, consider reviewing it in its entirety, changing all occurrences of uint to uint256 and of int to int256. Consider also reviewing implicit castings from small to bigger sizes and always use the appropriate size for each variable.  Update: Partially fixed in PR#421. The team will continue to use the aliases uint and int as they consider them more readable. In their words: We removed all occurrences of implicit upscaling. We accept that uint256 and uint are interchangeable in Solidity and that authors are aware of this. Also, in PR#454, the team fixed an unsafe cast and improved gas usage.  PRICE_SCALE constant is not used  A constant called PRICE_SCALE is defined in the CometCore contract and is supposed to be used to scale the prices returned by Chainlink aggregators.  Although the function priceScale returns the value stored in the bytecode, the constant is not used anywhere else.  Consider removing this constant or alternatively integrating it into the codebase.  Update: Ackwnoledged. The team response: PRICE_SCALE is not used internally, but it is exposed via the priceScale function, which could be used to understand the results of the getPrice function.  Wrong value emitted in event  Lines 1219-1221 of the asborbInternal function in the Comet contract are:  uint104  debtAbsorbed  = unsigned104  (newBalance  oldBalance  );  uint  valueOfDebtAbsorbed  = mulPrice  (debtAbsorbed  , basePrice  uint64  (baseScale  )); emit AbsorbDebt  (absorber  , account  , debtAbsorbed  , valueOfDebtAbsorbed  );  Consider emitting the correct value in the AsborbDebt event or renaming the debtAbsorbed variable to reflect that it does not account only for the debt absorbed but also the excess collateral exchanged for the base asset.  Update: Fixed in commit edc5a0a.  Conclusions  No critical severity issues have been found, along with one high severity issue and many others lower in severity. We strongly recommend addressing even the lowest in severity since they would drastically improve the overall quality, clarity, and security of the protocol.  Update: The team has addressed all issues either fixing them or providing improved docstrings and proper explanation arguments. Some of the changes introduced in the codebase are still open as pull requests and not incorporated into the main codebase. We assume those changes that we reviewed to be merged as they are without introducing any new change that might create new issues.  Appendix  Monitoring Recommendation  The active monitoring of smart contracts is an important practice that can represent additional protection for a project, allowing an immediate response to unforeseen incidents. We recommend implementing monitoring for all sensitive actions and the state of critical variables. For instance:  Monitor if Comet contract reaches the targetReserves. At that point, the collateral tokens seized with the liquidation will be retained by the protocol, and this could represent a risk if it relates to market prices precipitating in prices.  Monitor callable governance functions, especially approveThis, and upgrades to malicious implementations in governance attack scenarios.  Direct transfers of base asset to Comet contract (either to report an erroneous transaction or attempted manipulation).  Large capital liquidations. Either the absorb function is executed for a large position or the position exceeds the borrowCollateralFactor and is at risk. This should inform a possible strong market price drop or the liquidation of a large entity.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#unnecessary-complexity", "labels": ["OpenZeppelin"]}, {"title": "Anyone can set baseTrackingIndex", "body": "Anyone can set baseTrackingIndex", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#anyone-can-set-basetrackingindex", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent coding style", "body": "Inconsistencies in coding style were identified throughout the code base. Some examples are:  constants variables version and name and not in UPPER_CASE like other constant variables  The convention of functions named with the _ prefix is not clear. Sometimes it is used for admin functions and other times for internal functions  Some structs use _reserved to fill slots, but others do not.  It is not clear what convention is used for the naming of codebase interfaces. Sometimes the letter I is used as a prefix, sometimes the word Interface at the end or in some cases the contract even misses both.  Taking into consideration how much value a consistent coding style adds to the projects readability, enforcing a standard coding style with help of linter tools such as Solhint is recommended.  Update: Partially fixed. Only the second item has been fixed in commit c04c056.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "CometMath is not used consistently", "body": "Many functions that could be in CometMath, a utility contract that contains pure mathematical functions, are scattered throughout the codebase and min, one of the functions within the contract, is not being used.  Consider consolidating all the helper math functions in one place and removing unused ones.  Update: Partially fixed in commit 16d213f. The min function has been removed.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#cometmath-is-not-used-consistently", "labels": ["OpenZeppelin"]}, {"title": "Compilation warnings", "body": "While compiling the codebase contracts. The compiler raises some warnings. Specifically:  The totalSupply and totalBorrow variables of the getUtilization and of the getReserves functions have the same name as the totalSupply and totalBorrow public functions.  The withdrawAndBorrowAmount function visibility can be restricted to pure.  Consider resolving all compiler warnings.  Update: Fixed in commit 9e2b195.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#compilation-warnings", "labels": ["OpenZeppelin"]}, {"title": "Incorrect or missing docstrings", "body": "Across the codebase, some contracts lack proper documentation and docstrings. In particular, the IWETH9 and CometMath functions or the CometConfiguration and CometStorage variables are having little comments or nothing at all.  Consider thoroughly documenting all functions and parameters that are part of the contracts public API. Functions or parameters implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  have no setters but it doesnt specify where those are set, eventually in the  passed as input in the Configurator initialization.  Consider writing this in the docstrings of the initialize function to improve clarity.  Update: Partially fixed in commit 9227075. Docstring was only changed in the Configurator contract.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#incorrect-or-missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameters", "body": "The CometDeployed, GovernorTransferred, SetFactory, SetGovernor, SetPauseGuardian, SetBaseTokenPriceFeed, SetExtensionsDelegate events lack of any indexed parameter.  Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Fixed in commit 7124b98.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#lack-of-indexed-parameters", "labels": ["OpenZeppelin"]}, {"title": "Contracts folder is not properly organized", "body": "There is no convenient structure in the contracts folder to easily navigate between them. All contracts, regardless of their type or module they belong to, are mixed in a single folder.  To favor the developer experience and the maintenance of the codebase, consider adding additional folders following the structure within the vendor directory or separating protocol components into different internal folders.  Update: Acknowledged. In the words of the team: The code actually is logically organized in that the protocol code sits at the top-level, with test and vendored contracts being secondary and sitting in subdirectories. In the future, the team might reorganize into subdirectories but not at this time.  rewardsClaimed can be mixed between different tokens  In CometRewards it is possible to change the reward token of each Comet through _setRewardConfig. However, if the reward token is changed, the number of previous reward tokens claimed will persist and once someone claims their new reward asset, it will be added to rewardsClaimed despite being different assets.  Consider removing the ability to change the reward asset once set or changing the way the claimed rewards are stored if the reward asset changes.  Update: Fixed in commit ced8026.  Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Here are some examples:  The name CometProxyAdmin suggests that it is only the admin of the Comet proxy, but in reality, it will also have the same role on the Configurator proxy. Choose another name to avoid confusion.  TransparentUpgradeableConfiguratorProxy can be called ConfiguratorProxy. There is no need to use the inherited contract name as a prefix.  In CometMath, change InvalidUInt to InvalidUint and toUInt to toUint.  rescale and descale have different names but the same value, consider using one variable name scale.  Update: Partially fixed in commit b5a64d0.  Use of Global imports  Non-explicit imports are used throughout all protocol contracts, which reduces code readability and could lead to conflicts between names defined locally and the ones imported.  The inheritance chains within the protocol are long, and for this, the codebase would benefit from refactoring specifically which definitions are being imported in each contract.  On the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged. In the words of the team: We do not consider this important or worth the effort of refactoring at this time.  Potential front-run  The deployAndUpgrade function of the CometProxyAdmin is restricted in access to be called exclusively by the governance. It deploys a new Comet instance through the Configurator and upgrades the implementation address in the proxy.  However, it doesnt call the initializeStorage function of the Comet contract through the proxy, leaving the new implementation not initialized. The function doesnt take any input parameter and it is meant to be called only once without the need to call it again on new implementation upgrades.  Whether the first initialization is performed on a separate transaction or if in the future it will be possible to re-initialize the Comet instance with some input values, any user can front-run any governance attempt to initialize the new deployed Comet.  Consider taking into account that deployAndUpgrade and initializeStorage should be done in one unique transaction to avoid the front-run scenario, especially if input parameters or re-initializations are meant to happen in future developments.  Update: Acknowledged. The team added a scenario in PR#431 to test the governance flow for upgrading to a new version of Comet and calling its initialize function via one proposal.  Potential reentrancies  In the codebase, we found two places where reentrancy can occur. However, those do not pose any security issue or concern but awareness should be raised:  The invoke function of the Bulker contract can be re-entered.  The doTransferIn function of the Comet contract is often executed at the very beginning of executions, being it an anti-pattern to follow against reentrancy. Even if re-entering the same doTransferIn cant be used as vector attack in this case, one can re-enter a different function, modifying the state in an unexpected manner. Making external calls is always suggested to be done after checks and effects.  To improve clarity, consider either reducing the attack surface by making those functions non-reentrant or document and raise awarness on such scenarios.  Update: Acknowledged. The team understands the concerns and replies: Specific concerns due to reentrancies should be addressed with tests, static analysis or formal verification or code changes. Excessive documentation notes about universal theoretical concerns dont likely add much except make the documentation harder to read and maintain.  Repetitive code  In many parts of the codebase, repeated or similar lines of code can be seen. Here are some examples:  In Comet, lines 520-525, 555-561, 593-598 and 628-634 are repeated and loops after those sections have strong similarities.  timeElapsed > 0 check is performed two times, when accrueInternal is called, and when internally accruedInterestIndices is called.  allow and approve in CometExt do the same thing.  Consider reusing the same code defined in just one place or, if appropriate, removing duplicate code.  Update: Acknowledged. In the words of the team: We gave considerable thought to how redundant sections of the code were organized and tried various permutations. Although seemingly redundant, the current form is overall the best we found in terms of the properties we were evaluating (namely clarity, code size, gas cost).  Typos  Line 96 of the CometExt contract has a typo whi and the number of decimals showed here is wrong, as it should be one zero less.  To improve correctness and readability, consider reviewing both the contracts and the documentation for typos.  Update: Fixed in commit a1bd99f.  Unnecessary return values  In the Comet contract, there are functions like the supply or withdraw that return calls to internal functions even if theres no actual final value returned at the end.  Consider reviewing all the occurrences where this happens and avoid returning when not necessary. This will improve readability and correctness.  Update: Acknowledged. In the words of the team: These are used to handoff control flow and can actually improve readability with that understanding.  Lack of explicitness on data type sizes  The protocol heavily relies on different sized variables, which can have also positive or negative values and different scaling factors. Thanks to this, the deployment and execution of the codebase will decrease gas costs.  Given the fact that it adds some complexity and undermines the readability of the codebase, it is of utter importance to maintain explicitness and consistency across different contracts.  Specifically, implicit castings and sizes should be avoided.  To improve the overall quality of the codebase, consider reviewing it in its entirety, changing all occurrences of uint to uint256 and of int to int256. Consider also reviewing implicit castings from small to bigger sizes and always use the appropriate size for each variable.  Update: Partially fixed in PR#421. The team will continue to use the aliases uint and int as they consider them more readable. In their words: We removed all occurrences of implicit upscaling. We accept that uint256 and uint are interchangeable in Solidity and that authors are aware of this. Also, in PR#454, the team fixed an unsafe cast and improved gas usage.  PRICE_SCALE constant is not used  A constant called PRICE_SCALE is defined in the CometCore contract and is supposed to be used to scale the prices returned by Chainlink aggregators.  Although the function priceScale returns the value stored in the bytecode, the constant is not used anywhere else.  Consider removing this constant or alternatively integrating it into the codebase.  Update: Ackwnoledged. The team response: PRICE_SCALE is not used internally, but it is exposed via the priceScale function, which could be used to understand the results of the getPrice function.  Wrong value emitted in event  Lines 1219-1221 of the asborbInternal function in the Comet contract are:  uint104  debtAbsorbed  = unsigned104  (newBalance  oldBalance  );  uint  valueOfDebtAbsorbed  = mulPrice  (debtAbsorbed  , basePrice  uint64  (baseScale  )); emit AbsorbDebt  (absorber  , account  , debtAbsorbed  , valueOfDebtAbsorbed  );  Consider emitting the correct value in the AsborbDebt event or renaming the debtAbsorbed variable to reflect that it does not account only for the debt absorbed but also the excess collateral exchanged for the base asset.  Update: Fixed in commit edc5a0a.  Conclusions  No critical severity issues have been found, along with one high severity issue and many others lower in severity. We strongly recommend addressing even the lowest in severity since they would drastically improve the overall quality, clarity, and security of the protocol.  Update: The team has addressed all issues either fixing them or providing improved docstrings and proper explanation arguments. Some of the changes introduced in the codebase are still open as pull requests and not incorporated into the main codebase. We assume those changes that we reviewed to be merged as they are without introducing any new change that might create new issues.  Appendix  Monitoring Recommendation  The active monitoring of smart contracts is an important practice that can represent additional protection for a project, allowing an immediate response to unforeseen incidents. We recommend implementing monitoring for all sensitive actions and the state of critical variables. For instance:  Monitor if Comet contract reaches the targetReserves. At that point, the collateral tokens seized with the liquidation will be retained by the protocol, and this could represent a risk if it relates to market prices precipitating in prices.  Monitor callable governance functions, especially approveThis, and upgrades to malicious implementations in governance attack scenarios.  Direct transfers of base asset to Comet contract (either to report an erroneous transaction or attempted manipulation).  Large capital liquidations. Either the absorb function is executed for a large position or the position exceeds the borrowCollateralFactor and is at risk. This should inform a possible strong market price drop or the liquidation of a large entity.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#contracts-folder-is-not-properly-organized", "labels": ["OpenZeppelin"]}, {"title": "rewardsClaimed can be mixed between different tokens", "body": "rewardsClaimed can be mixed between different tokens", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#rewardsclaimed-can-be-mixed-between-different-tokens", "labels": ["OpenZeppelin"]}, {"title": "Naming issues", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Here are some examples:  The name CometProxyAdmin suggests that it is only the admin of the Comet proxy, but in reality, it will also have the same role on the Configurator proxy. Choose another name to avoid confusion.  TransparentUpgradeableConfiguratorProxy can be called ConfiguratorProxy. There is no need to use the inherited contract name as a prefix.  In CometMath, change InvalidUInt to InvalidUint and toUInt to toUint.  rescale and descale have different names but the same value, consider using one variable name scale.  Update: Partially fixed in commit b5a64d0.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#naming-issues", "labels": ["OpenZeppelin"]}, {"title": "Use of Global imports", "body": "Non-explicit imports are used throughout all protocol contracts, which reduces code readability and could lead to conflicts between names defined locally and the ones imported.  The inheritance chains within the protocol are long, and for this, the codebase would benefit from refactoring specifically which definitions are being imported in each contract.  On the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged. In the words of the team: We do not consider this important or worth the effort of refactoring at this time.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#use-of-global-imports", "labels": ["OpenZeppelin"]}, {"title": "Potential front-run", "body": "The deployAndUpgrade function of the CometProxyAdmin is restricted in access to be called exclusively by the governance. It deploys a new Comet instance through the Configurator and upgrades the implementation address in the proxy.  However, it doesnt call the initializeStorage function of the Comet contract through the proxy, leaving the new implementation not initialized. The function doesnt take any input parameter and it is meant to be called only once without the need to call it again on new implementation upgrades.  Whether the first initialization is performed on a separate transaction or if in the future it will be possible to re-initialize the Comet instance with some input values, any user can front-run any governance attempt to initialize the new deployed Comet.  Consider taking into account that deployAndUpgrade and initializeStorage should be done in one unique transaction to avoid the front-run scenario, especially if input parameters or re-initializations are meant to happen in future developments.  Update: Acknowledged. The team added a scenario in PR#431 to test the governance flow for upgrading to a new version of Comet and calling its initialize function via one proposal.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#potential-front-run", "labels": ["OpenZeppelin"]}, {"title": "Potential reentrancies", "body": "In the codebase, we found two places where reentrancy can occur. However, those do not pose any security issue or concern but awareness should be raised:  The invoke function of the Bulker contract can be re-entered.  The doTransferIn function of the Comet contract is often executed at the very beginning of executions, being it an anti-pattern to follow against reentrancy. Even if re-entering the same doTransferIn cant be used as vector attack in this case, one can re-enter a different function, modifying the state in an unexpected manner. Making external calls is always suggested to be done after checks and effects.  To improve clarity, consider either reducing the attack surface by making those functions non-reentrant or document and raise awarness on such scenarios.  Update: Acknowledged. The team understands the concerns and replies: Specific concerns due to reentrancies should be addressed with tests, static analysis or formal verification or code changes. Excessive documentation notes about universal theoretical concerns dont likely add much except make the documentation harder to read and maintain.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#potential-reentrancies", "labels": ["OpenZeppelin"]}, {"title": "Repetitive code", "body": "In many parts of the codebase, repeated or similar lines of code can be seen. Here are some examples:  In Comet, lines 520-525, 555-561, 593-598 and 628-634 are repeated and loops after those sections have strong similarities.  timeElapsed > 0 check is performed two times, when accrueInternal is called, and when internally accruedInterestIndices is called.  allow and approve in CometExt do the same thing.  Consider reusing the same code defined in just one place or, if appropriate, removing duplicate code.  Update: Acknowledged. In the words of the team: We gave considerable thought to how redundant sections of the code were organized and tried various permutations. Although seemingly redundant, the current form is overall the best we found in terms of the properties we were evaluating (namely clarity, code size, gas cost).", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#repetitive-code", "labels": ["OpenZeppelin"]}, {"title": "Typos", "body": "Line 96 of the CometExt contract has a typo whi and the number of decimals showed here is wrong, as it should be one zero less.  To improve correctness and readability, consider reviewing both the contracts and the documentation for typos.  Update: Fixed in commit a1bd99f.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#typos", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary return values", "body": "In the Comet contract, there are functions like the supply or withdraw that return calls to internal functions even if theres no actual final value returned at the end.  Consider reviewing all the occurrences where this happens and avoid returning when not necessary. This will improve readability and correctness.  Update: Acknowledged. In the words of the team: These are used to handoff control flow and can actually improve readability with that understanding.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#unnecessary-return-values", "labels": ["OpenZeppelin"]}, {"title": "Lack of explicitness on data type sizes", "body": "The protocol heavily relies on different sized variables, which can have also positive or negative values and different scaling factors. Thanks to this, the deployment and execution of the codebase will decrease gas costs.  Given the fact that it adds some complexity and undermines the readability of the codebase, it is of utter importance to maintain explicitness and consistency across different contracts.  Specifically, implicit castings and sizes should be avoided.  To improve the overall quality of the codebase, consider reviewing it in its entirety, changing all occurrences of uint to uint256 and of int to int256. Consider also reviewing implicit castings from small to bigger sizes and always use the appropriate size for each variable.  Update: Partially fixed in PR#421. The team will continue to use the aliases uint and int as they consider them more readable. In their words: We removed all occurrences of implicit upscaling. We accept that uint256 and uint are interchangeable in Solidity and that authors are aware of this. Also, in PR#454, the team fixed an unsafe cast and improved gas usage.  PRICE_SCALE constant is not used  A constant called PRICE_SCALE is defined in the CometCore contract and is supposed to be used to scale the prices returned by Chainlink aggregators.  Although the function priceScale returns the value stored in the bytecode, the constant is not used anywhere else.  Consider removing this constant or alternatively integrating it into the codebase.  Update: Ackwnoledged. The team response: PRICE_SCALE is not used internally, but it is exposed via the priceScale function, which could be used to understand the results of the getPrice function.  Wrong value emitted in event  Lines 1219-1221 of the asborbInternal function in the Comet contract are:  uint104  debtAbsorbed  = unsigned104  (newBalance  oldBalance  );  uint  valueOfDebtAbsorbed  = mulPrice  (debtAbsorbed  , basePrice  uint64  (baseScale  )); emit AbsorbDebt  (absorber  , account  , debtAbsorbed  , valueOfDebtAbsorbed  );  Consider emitting the correct value in the AsborbDebt event or renaming the debtAbsorbed variable to reflect that it does not account only for the debt absorbed but also the excess collateral exchanged for the base asset.  Update: Fixed in commit edc5a0a.  Conclusions  No critical severity issues have been found, along with one high severity issue and many others lower in severity. We strongly recommend addressing even the lowest in severity since they would drastically improve the overall quality, clarity, and security of the protocol.  Update: The team has addressed all issues either fixing them or providing improved docstrings and proper explanation arguments. Some of the changes introduced in the codebase are still open as pull requests and not incorporated into the main codebase. We assume those changes that we reviewed to be merged as they are without introducing any new change that might create new issues.  Appendix  Monitoring Recommendation  The active monitoring of smart contracts is an important practice that can represent additional protection for a project, allowing an immediate response to unforeseen incidents. We recommend implementing monitoring for all sensitive actions and the state of critical variables. For instance:  Monitor if Comet contract reaches the targetReserves. At that point, the collateral tokens seized with the liquidation will be retained by the protocol, and this could represent a risk if it relates to market prices precipitating in prices.  Monitor callable governance functions, especially approveThis, and upgrades to malicious implementations in governance attack scenarios.  Direct transfers of base asset to Comet contract (either to report an erroneous transaction or attempted manipulation).  Large capital liquidations. Either the absorb function is executed for a large position or the position exceeds the borrowCollateralFactor and is at risk. This should inform a possible strong market price drop or the liquidation of a large entity.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#lack-of-explicitness-on-data-type-sizes", "labels": ["OpenZeppelin"]}, {"title": "PRICE_SCALE constant is not used", "body": "PRICE_SCALE constant is not used", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#price_scale-constant-is-not-used", "labels": ["OpenZeppelin"]}, {"title": "Wrong value emitted in event", "body": "Lines 1219-1221 of the asborbInternal function in the Comet contract are:  uint104  debtAbsorbed  = unsigned104  (newBalance  oldBalance  );  uint  valueOfDebtAbsorbed  = mulPrice  (debtAbsorbed  , basePrice  uint64  (baseScale  )); emit AbsorbDebt  (absorber  , account  , debtAbsorbed  , valueOfDebtAbsorbed  );  Consider emitting the correct value in the AsborbDebt event or renaming the debtAbsorbed variable to reflect that it does not account only for the debt absorbed but also the excess collateral exchanged for the base asset.  Update: Fixed in commit edc5a0a.", "html_url": "https://blog.openzeppelin.com/compound-iii-audit#wrong-value-emitted-in-event", "labels": ["OpenZeppelin"]}, {"title": "Extending the staking duration discards rewards", "body": "OgvStaking contract, updating a users rewards is a two step process: First, the internal function  _collectRewards must be called, which updates the accumulated per share rewards for all users and then computes and transfers an individual users total outstanding rewards. The computation of a users outstanding rewards uses the mapping  The function extend only performs an update on rewardDebt without a prior call to _collectRewards. Hence, it always discards the rewards earned by a user instead of paying them out.  While calling _collectRewards within the extend function would mitigate the issue, consider instead solving the root cause by migrating to a mapping rewardDebtPerShare. This mapping can be updated within the _collectRewards function, which does not need to account for changes in the users balance, thereby avoiding any future mismatches in reward accounting.  Update: Fixed by the changes made in pull requests #88 and #98.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#extending-the-staking-duration-discards-rewards", "labels": ["OpenZeppelin"]}, {"title": "Strongly coupled contracts can break core functionality", "body": "The OgvStaking contract is strongly coupled with the RewardsSource contract:  In OgvStaking the external functions stake, unstake and extend must call the internal function _collectRewards to update and transfer a users rewards.  _collectRewards calls RewardsSource.collectRewards to update the accRewardPerShare variable and receive all rewards that accrued within RewardsSource since the last call to collectRewards.  In consequence, any issue within the rewards distribution of the RewardsSource.collectRewards function will escalate into the governance-related functions of the OgvStaking contract.  RewardsSource.setRewardsTarget function, which contains the comment Okay to be zero, just disables collecting rewards. However, setting the  Consider wrapping the external call to RewardsSource.collectReward into a try/catch block to achieve decoupling of reward mechanics and staking-based governance. Additionally, consider removing the noRewards parameter of the unstake function which was originally intended for emergency withdrawals.  Update: Fixed in pull request #97. In addition, consider catching the error reason and emitting it as an event parameter to allow detection of the otherwise silent error.  Medium Severity", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#strongly-coupled-contracts-can-break-core-functionality", "labels": ["OpenZeppelin"]}, {"title": "Staking function can lead to loss of funds", "body": "OgvStaking contract the function  stake allows anybody to stake  If a user wants to simply stake for themselves, this leaves them with the option to call either stake(amount, duration, msg.sender) or stake(amount, duration, 0x0), both of which are surprising. Moreover, if the user wants to stake on behalf of another address, there are no checks to ensure the supplied account (which may be a contract) is able to call the unstake function or interact with OGV tokens. This behavior may lead to the loss of staked funds.  Consider migrating the staking logic to an internal function _stake and creating two external functions stake(uint256 amount, uint256 duration) and stakeFor(uint256 amount, uint256 duration, address receiver). Optionally, add the onlyGovernor modifier to the latter function to limit staking on behalf of another user to official airdrops. Further, consider verifying, either within the contract or off-chain, that a smart contract receiver can operate on the received stake to prevent an unintended loss of funds.  Update: Partially fixed in pull request #89. It is now simpler and more intuitive for a user to stake for themselves. However, staked funds may still be lost if a smart contract receiver is not designed to operate on the staked funds.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#staking-function-can-lead-to-loss-of-funds", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission", "body": "The following functions do not emit relevant events after executing sensitive actions:  The setRewardsTarget function changes the address OGV tokens are minted to as part of the staking reward system.  The setInflation function deletes and optionally updates the rewards slopes.  Consider emitting events after sensitive changes take place to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed in pull request #96. In addition, consider indexing the event parameters.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#lack-of-event-emission", "labels": ["OpenZeppelin"]}, {"title": "Incomplete test suite", "body": "The testing suite covering in-scope contracts is incomplete. Although OgvStaking.t.sol and Rewards.t.sol test files were provided, the instructions in the README for the project do not sufficiently provide guidance on how to run comprehensive tests for the repo.  As the test suite was left outside the audits scope, please consider thoroughly reviewing the test suite to make sure all tests run successfully after following the instructions in the README file. Extensive unit tests aiming at 95% coverage are recommended in order for the security of the project to be assessed in a future audit. Integrating test coverage reports in every single pull request of the project is also highly advisable.  Update: Fixed in pull request #100.  Low Severity", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#incomplete-test-suite", "labels": ["OpenZeppelin"]}]