[{"title": "1. Issue", "html_url": "https://github.com/oak-security/audit-reports/tree/master/pTokens/20210212_pTokens Bridges Ongoing Audit Report.pdf", "body": "1. Issue", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Attackers can cause a consensus failure by sending coins through IBC", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf", "body": "in x/tariff/keeper/allocation.go:30 During the execution of the BeginBlocker, a panic occurs in the AllocateTokens the function SendCoinsFromModuleToAccount function returns an error. This error can be caused if a zero-amount coin is passed to the SendCoinsFromModuleToAccount function. Currently, there is no check in the AllocateTokens function that prevents a coin with a zero amount from being added to coins. if An unsuspecting user or an attacker could cause such a panic by sending a coin with an amount in the [10_000, 19_999] range through IBC. Since the scale factor is 10_000 and the result is truncated, this would cause the sending of coins with a zero amount using the SendCoinsFromModuleToAccount function, which would cause a panic as described above. Consequently, the chain will be permanently halted since the error is not recoverable without pruning the state. A test case able to reproduce this issue can be found in Appendix 1.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Panic in SendCoinsFromModuleToAccount causes chain to halt", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf", "body": "When the BeginBlocker is executed, AllocateTokens function dened in x/tariff/keeper/allocation.go:30. there is a possibility of a panic in the This panic occurs when the SendCoinsFromModuleToAccount method of bankKeeper encounters an error. One such error can arise if the recipient's address is listed in the Bank modules blacklist. The purpose of blacklisting is to prevent users from sending funds to module accounts or to proactively block specic malicious accounts as determined by the governance. An attacker could forge a message to send coins to these blacklisted accounts, causing a panic that halts the chain.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Fee will round to zero for small fees or amounts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf", "body": "The SendPacket function in x/tariff/keeper/keeper.go:81-82 introduces a rounding issue that can occur when the bpsFee or the fullAmount take small values. The rounding will be in favor of the user and will round down to 0. using example, For in docs/modules/tariff.md, amounts under 10000uDenom will have a fee value that rounds down to 0. TransferFeeBps from the value docs the of", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. A large number of DistributionEntities could slow down and even halt the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf", "body": "The AllocateTokens function dened in x/tariff/keeper/allocation.go:7-33 is responsible for distributing fees to DistributionEntities during the BeginBlocker. Since it performs an unbounded loop through all the registered DistributionEntities, it could cause the BeginBlocker execution to take more time than expected. This could slow down the chain or, in the worst case, halt the node because Tendermints timeouts are hit. classify issue We DistributionEntities. this as informational since only governance can register", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Remove unused functions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf", "body": "There are some instances of unused functions in the codebase:  The String function in x/tariff/types/params.go:139.  The GetAccount function in x/tariff/types/expected_keeper.go:11.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Use of magic numbers decreases maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-07-08 Audit Report - Noble Tariff Module v1.0.pdf", "body": "In the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. In x/tariff/types/params.go:85, transferFeeBPS is greater than a hard-coded value of 10000. there is a validation check if the value of In x/tariff/keeper/keeper.go:81, the values 4 and 1 are hard-coded.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. addr with a length that is not a multiple of 0x20 may lead to incorrect results", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf", "body": "contracts/v0.8/PrecompilesAPI.sol:33, In the resolveAddress function, the provided addr length should be a multiple of 0x20, but a user can provide any arbitrary length of bytes as input and there is a possibility that the user will receive incorrect output because the current code does not validate the length of the provided addr param. execution of during the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Address lookup via PrecompilesAPI.lookupAddress fails due to incorrect memory access", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf", "body": "PrecompilesAPI.lookupAddress The in contracts/v0.8/PrecompilesAPI.sol uses Yul to call the lookup_address FEVM precompile. However, accessed by using mload(actor_id) instead of using a xed length of 32 bytes. mload loads a word from memory at the given address. actor_id is a static variable of the type uint64, not a memory pointer. This leads to incorrect memory access. the actor_id length is incorrectly function library The same issue is present in the PrecompilesAPI.getActorType function in line 73.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Hardcoded outputSize results in data loss during a delegatecall", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf", "body": "contracts/v0.8/utils/Actor.sol:87, In MAX_RAW_RESPONSE_SIZE parameter is used to restrict the outputSize of the delegatecall Yul instruction, while FVM actors can return data sizes greater than 0x300. Due to the hardcoded output length, the return data is truncated, resulting in unexpected behavior of the call function. the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Hardcoded GAS_LIMIT used to call precompiles may lead to gas exhaustion", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf", "body": "The library uses a GAS_LIMIT constant to specify the maximum amount of gas a precompile can consume. The actual gas consumption depends on the actual FEVM implementation, which may change over time. This makes it impossible to predict the Actor.call precompile execution gas cost, and hence with a hardcoded GAS_LIMIT, the precompile call could run out of gas.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Missing sanity check for codec value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf", "body": "According to the comment in contracts/v0.8/utils/Actor.sol:49, codec should always be cbor. However, the user can provide any codec, while the Solidity code assumes it to be cbor. Without validation of the codec parameter, there is potential for incorrect results if the FEVM returns a response that is encoded with a dierent codec than cbor.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Calling the actor precompile conceals the revert reason", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin FEVM Solidity Library v1.1.pdf", "body": "The Actor library in contracts/v0.8/utils/Actor.sol performs a delegatecall to the actor precompile. However, in the event of a revert, the revert reason is suppressed and not returned. This could negatively impact the developer and user experience.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "2. Inconsistent admin duplicate validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-07-13 Audit Report - Astroport Concentrated Liquidity Pool with Injective Orderbook Integration v1.0.pdf", "body": "The free-granter contract performs validation of the submitted admin addresses in contracts/periphery/fee_granter/src/state.rs:15-23. However, no checks on address duplication are performed in this function. While the update function performs its own separated checks, this is not the case with the instantiation function. As there is a maximum of two admins, duplicate addresses would limit operations. tWe classify this issue as minor since admin addresses can be updated to remove duplicated addresses.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Gas is not consumed if the transaction returns an error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The ConsumeGas function is used in the lend module to increase the GasMeters consumed gas by a set amount. Within the Comdex appchain, these amounts are pre-dened based on anticipated values. This method is problematic because gas is only consumed after successful execution and not in the event of an error. Even if the function returns an error, computation still occurs and gas should be consumed. The ConsumeGas function is called in lines:  x/lend/keeper/msg_server.go:30  x/lend/keeper/msg_server.go:44  x/lend/keeper/msg_server.go:58  x/lend/keeper/msg_server.go:72  x/lend/keeper/msg_server.go:84  x/lend/keeper/msg_server.go:96  x/lend/keeper/msg_server.go:108  x/lend/keeper/msg_server.go:121  x/lend/keeper/msg_server.go:135  x/lend/keeper/msg_server.go:147  x/lend/keeper/msg_server.go:176  x/lend/keeper/msg_server.go:190 In these occurrences, the predened gas amount is not consumed in the event of an error because the ConsumeGas invocations are located at the end of the transaction execution. Consequently, a malicious actor is able to spam transactions that trigger errors in the middle of the execution without being charged the dened gas fees.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Input-dependent iteration in Lend modules BeginBlocker may slow down or stop block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "BeginBlocker is a function that is executed at the beginning of every block, even if there are no transactions. It should have a light and constant computational footprint to avoid any negative impacts on block production. Too much computational weight at the beginning of each block may cause block production to slow down, or even surpass Tendermints propose timeout, which results in a halt of the blockchain. Consequently, it is best practice to make the BeginBlocker execution independent, or at least sub-linearly dependent, from the amount of data stored on-chain. In the Lend module in x/lend/abci.go:13-23, the execution loops through all stored borrows in order to balance stable rates. Since borrows cardinality will grow with chain adoption or due to a spam attack, the issue described above will occur.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Batch mechanism in Liquidation modules BeginBlocker may allow malicious manipulations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "the Liquidation In x/liquidation/keeper/liquidate_borrow.go:11-113 x/liquidation/keeper/liquidate_vaults.go:12-93, through all the borrow positions in order to check the collateral ratio health. BeginBlocker, modules specically in and the execution loops Since positions cardinality will grow with chain adoption or due to a spam attack, in order to defend against issues like Input dependent iteration in Lend modules BeginBlocker may slow down or stop block production, functions implement a batching mechanism. It splits borrowing positions slice into dierent partitions of params.LiquidationBatchSize size. This implies that it could happen that positions that are not healthy in a block interval but are not included in a batch of that interval are not liquidated. This implementation also exposes a vulnerability where a malicious actor could manipulate the mentioned slice in order to create positions that will not be liquidated in a dened interval.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Error raised in BeginBlocker could lead to state corruption", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "In x/liquidation/abci.go:13-27 and x/lend/abci.go:13-23 both Lend and Liquidation modules wrap an ApplyFuncIfNoError function in order to gracefully handle errors. BeginBlockers execution logic their in This function logs errors but has no control over the state and no mechanism to revert partial updates. This implies that if an error is raised in the middle of an execution ow, the execution will stop and log the error, but no action will be taken in order to revert state updates that have been done leading to state corruption.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Incorrect conditions when rebalancing stable rates", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "In x/lend/keeper/iter.go:203-209, the RebalanceStableRates function checks conditions to see if rebalancing must be triggered. The Commodo documentation states that stable rates should be decreased if    + 20% and increased if  + 20%         90% . However, the actual implementation is using dierent conditions. Stable rates are decreased if    + 20% and increased if,  + 20%      >  90% . This leads to a malfunctioning stable interest rate model. An attacker may create multiple accounts with borrowing positions with a stable interest rate for an asset and ensure that the borrowing rate is slightly less than 20% so that the increase condition will never be triggered to rebalance the stable rate even though the utilization ratio hits more than 90%. When the utilization ratio hits 100%, it impacts lenders unable to withdraw their stable assets.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. FundModAcc allows funds to be sent to any module which may result in permanently lost funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The FundModAcc function in x/lend/keeper/keeper.go:1388 allows for the caller to specify any module name for funding. This is problematic because funds could be sent to a module that is not designed to handle them making them stuck in the module. The BankKeeper will return an error if the module name is invalid, but as long as the module name specied is valid, this function will allow for funds to be sent. While any address may call this function, we do not classify it as critical since users would not normally be sending funds directly to a module.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Borrow positions InterestAccumulated is not updated before liquidation, leading to an incorrect interest calculation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "in The x/liquidation/keeper/liquidate_borrow.go:11 does not update the borrow positions InterestAccumulated before performing the liquidation operations. LiquidateBorrows function As a result, a stale value of borrowPos.InterestAccumulated is being used in x/liquidation/keeper/liquidate_borrow.go:60, 76, and 94 to calculate the currentCollateralizationRatio, which leads to an incorrect value. a when addition, in In x/liquidation/keeper/liquidate_borrow.go:115, the stale value is used to set LockedVault.UpdatedAmountOut. This can become especially problematic when the borrow position is large and the interest has not been updated for a long time period, in which case the LockedVault.UpdatedAmountOut will be incorrect by a considerable amount. created borrow locked being is", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. BeginBlocker allows for errors to silently pass without being logged", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The functions called during BeginBlocker do not properly propagate error information. Instead, they continue execution and silently pass on the condition that caused the error. This results in suboptimal visibility of the conditions that are causing errors. example, For in x/liquidation/keeper/liquidate_vaults.go:12 simply executes continue when errors are encountered. LiquidateVaults function the While we acknowledge that an error or panic should not necessarily halt the BeginBlocker, it is best practice to log the conditions that are causing errors. In this example, a liquidatable vault could be silently passed because there is no visibility into which errors are being encountered or even which vaults caused the errors.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Missing validation checks in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "There are some missing validation checks in the following transaction message types as well as the Lend modules governance handler messages:  In x/lend/types/pair.go:18, validation is done only on CPoolName eld.  In x/lend/types/pair.go:25, validation on AssetToPairMapping is not implemented.  In x/lend/types/pair.go:29, validation on AssetRatesParams is not implemented.  In x/lend/types/gov.go:195, validation on AuctionParams is not implemented.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Vault collateralitzationRatio does not account for newly accumulated interest", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "LiquidateVaults The in x/liquidation/keeper/liquidate_vaults.go:12 uses an outdated value of because totalOut vault.InterestAccumulated is not updated. collateralitzationRatio calculate function to In fact, the vault interest is updated in line 71 when the CalculateVaultInterest function is called. This results in collateralitzationRatio not reecting the current accumulated interest. We report this as minor because unlike the issue Borrow positions InterestAccumulated is not updated before liquidation, in this case, LiquidateVaults updates the position so the LockedVault.UpdatedAmountOut is correctly evaluated.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Incorrect value provided to VerifyCollateralizationRatio function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The VerifyCollateralizationRatio function takes liquidationThreshold as the last parameter and uses it the collateralization ratio is greater than the liquidation threshold. to perform validation for whether or not in order In four dierent instances, the function is incorrectly called with the LTV instead of the liquidationThreshold:  x/lend/keeper/keeper.go:541  x/lend/keeper/keeper.go:662  x/lend/keeper/keeper.go:720  x/lend/keeper/keeper.go:1159 This implies that depending on the value of LTV set by governance, the function either always returns ErrorCollateralizationRatio or bypasses the validation which could lead to unexpected results.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. UpdateLendPairsRecords allows governance to update lend pairs even if they have liquidity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The UpdateLendPairsRecords function in x/lend/keeper/pair.go:39 allows governance to update either AssetIn or AssetOut for an existing lend pair. If that existing lend pair is currently being utilized, this could have unintended consequences. Based on the documentation it does not seem that there is any specic reason for allowing updates of lend pairs.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. AddAuctionParamsData does not prevent existing data from being overwritten", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The AddAuctionParamsData function in x/lend/keeper/pair.go:227 does not ensure that existing data with the same key does not exist before saving the provided AuctionParams. This allows governance to overwrite existing data. We classify this as a minor issue because only governance can call this function.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. AddAssetRatesParams returns incorrect error message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "The AddAssetRatesParams function in x/lend/keeper/pair.go:200 returns the incorrect error \"Asset Rates Params not found\" when the record already exists.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. CLI uses ags instead of arguments to parse proposals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "In  x/lend/client/cli/tx.go:437,  x/lend/client/cli/tx.go:523,  x/lend/client/cli/tx.go:778, and  x/lend/client/cli/tx.go:901, for the commands the CmdAddNewLendPairsProposal, CmdAddPoolProposal, and CmdAddNewAssetRatesParamsProposal, CmdAddNewAuctionParamsProposal governance proposals currently receive a proposal le as a ag.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Unneeded positivity validation for unsigned integers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "the ValidateBasic functions in x/lend/types/tx.go validate that the ID All parameter is a positive number. As unsigned integer type can never be negative, those checks are redundant. Therefore, they can be removed.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Unnecessary aliases pattern increase technical debt", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "are there Currently, in x/lend/types/expected_keepers.go, while the keeper uses the functions from alias.go that reference expected/keeper.go. Having an alias.go le dening all functions of external modules is not necessary and decreases maintainability. external modules functions dened some for", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Duplicated ValidateBasic invocation in CLI", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-11-23 Audit Report - Comdex Lend and Liquidation Modules v1.0.pdf", "body": "Some CLI commands dened in  x/lend/client/cli/tx.go:426,  x/lend/client/cli/tx.go:517,  x/lend/client/cli/tx.go:615,  x/lend/client/cli/tx.go:693,  x/lend/client/cli/tx.go:761,  x/lend/client/cli/tx.go:894, and  x/lend/client/cli/tx.go:986, call the msg.ValidateBasic function before calling GenerateOrBroadcastTxCLI or GenerateOrBroadcastTxWithFactory. As msg.ValidateBasic is already called inside GenerateOrBroadcastTxWithFactory, this is an unnecessary and duplicated invocation.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Attackers can block pool tuning by voting on many dummy pools", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf", "body": "In the contracts/generator_controller/src/contract.rs:398-416, tune_pools function attempts to process each pools votes in an unbounded iteration. In the case that the number of pools is too many, the execution may run out of gas and fail. An attacker can use this loop to block pool tuning: 1. The attacker creates many addresses and stakes xASTRO for minimum voting power", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Finally, the tune_pools function will attempt to process all child contracts added by the attacker in line 399. The attack will succeed when the function fails due to an out-of-gas error. As a result, the TunePools message will always fail, preventing majority-voted pools from receiving allocation points. Please refer to the test_jam_tuning test case for the attack scenario mentioned above. Recommendation We recommend implementing a whitelist of liquidity pool contracts that can be voted on. Status: Resolved 2. Proposals message order not enforced on IBC execution", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf", "body": "5. Finally, the tune_pools function will attempt to process all child contracts added by the attacker in line 399. The attack will succeed when the function fails due to an out-of-gas error. As a result, the TunePools message will always fail, preventing majority-voted pools from receiving allocation points. Please refer to the test_jam_tuning test case for the attack scenario mentioned above. Recommendation We recommend implementing a whitelist of liquidity pool contracts that can be voted on. Status: Resolved 2. Proposals message order not enforced on IBC execution", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. KickBlacklistedVoters missing from documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf", "body": "In contracts/generator_controller/src/contract.rs:89-108, controllers ExecuteMsg::KickBlacklistedVoters is not dened. documented. messages execution are the generator the However,", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Unnecessary CW20 sender validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf", "body": "contracts/assembly/src/contract.rs:170, In contracts receive_cw20 function performs address validation for the sender parameter of the CW20 message. This is unnecessary because the sender parameter comes from info.sender, validated by Cosmos SDK already. assembly the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Unnecessary conversion to lowercase in addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf", "body": "The contracts within scope used the addr_validate_to_lower helper function to sanitize addresses. Since CosmWasm 1.0.0, the addr_validate utility also validates address capitalization, hence making it redundant to perform this check manually.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Misleading error messages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport Governance Updates v1.0.pdf", "body": "In contracts/assembly/src/contract.rs:680 and 683, the assembly contracts update_ibc_proposal_status function returns Unauthorized errors even for cases that are not related to authorization, which can be misleading for users. This is the case if the proposal.status does not match one of the expected ones in line 671. This also happens if config.ibc_controller is congured to None, the if statement in line 669 will result in an Unauthorized error.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Missing denom validation when adding incentives could lead to insucient funds error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "contracts/incentives/src/helpers.rs:95-100, In validate_incentive_schedule function lacks validation to ensure that denomination matches the incentive denomination. the the sent This is problematic because it allows potential attackers to create an incentive schedule with a dierent denomination as long as the amount sent is correct. Consequently, due to an insucient funds error. legitimate users may encounter diculties in claiming their rightful rewards A test is reproducing test_incorrect_denom_deposit test case. issue case this provided in the Appendix in the", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Incorrect calculation when simulating with multiple routes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "In contracts/oracle/wasm/src/helpers.rs:145-160, the add_route_prices function loads the price source for the denom and multiplies it with the current price. This is incorrect because the third route assets currency is not considered. To illustrate, assume a price source is created with three route assets (e. g. ATOM => MARS => OSMO) while the base denom is congured as USDC. The rst route asset will be simulated in Astroport, making the price currency MARS. After that, the function loads the MARS price from storage and multiplies it, resulting in the price currency becoming USDC. The problem arises when multiplying with the third route assets price, OSMO. When the price source is retrieved, the price currency is expected to be OSMO, not USDC. The function will calculate the price as follows:   =               This is incorrect, because the price currency after the second route asset multiplication (MARS) is not denominated as the third route assets currency (OSMO). Consequently, introduces a aw in the calculation process. this discrepancy in the expected currency versus the actual currency", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Utilization rate can be exploited to surpass 100% for new markets", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "In contracts/red-bank/src/interest_rates.rs:290-294, the utilization rate of a market is determined by the ratio of total debt divided by total collateral. If a new market is instantiated with zero deposits, an attacker can inate the utilization rate to steal funds from the contract. An exemplary step-by-step attack follows: 1. ATOM market is instantiated. 2. The attacker becomes the rst depositor and deposits 1 uatom, increasing the markets total collateral. 3. The attacker donates 1000 ATOM to the contract directly", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. The attacker receives around 84000 ATOM after 10 seconds due to the inated utilization rate. For more information on this type of attack, please refer to the Silo Finance Vulnerability Disclosure. A test case reproducing this issue is provided in the Appendix in the zero_deposit_poc test case. Recommendation We recommend limiting the utilization rate to a maximum value of 100%. Status: Resolved 4. Removing whitelisted denoms causes leftover rewards to get stuck", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "7. The attacker receives around 84000 ATOM after 10 seconds due to the inated utilization rate. For more information on this type of attack, please refer to the Silo Finance Vulnerability Disclosure. A test case reproducing this issue is provided in the Appendix in the zero_deposit_poc test case. Recommendation We recommend limiting the utilization rate to a maximum value of 100%. Status: Resolved 4. Removing whitelisted denoms causes leftover rewards to get stuck", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Duplicated denoms might cause incorrect whitelist counts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "contracts/incentives/src/contract.rs:173 In the execute_update_whitelist function does not dedupe denoms in the add_denoms and remove_denoms vectors. 187, and This is problematic because providing duplicate denoms to be added or removed would inate the whitelist_count variable, causing an incorrect state stored in the contract. We classify this issue as minor because only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Oracle centralization risks with Fixed price sources", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "In the current design, the owner can post arbitrary prices to the oracle using a Fixed price and source contracts/oracle/osmosis/src/price_source.rs381-392. not validated, and every value is accepted. contracts/oracle/wasm/src/price_source.rs:184-195 Prices are in This can be problematic since an attacker that gets access to the private key of the owner can arbitrarily manipulate prices without any restrictions. For example, the attacker could set the price of all assets to 0, which would allow the attacker to liquidate all users at their loss. We classify this issue as minor because only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Misconguring tolerance value to be higher than window size causes incorrect price reported", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "the contracts/oracle/wasm/src/price_source.rs:316-321, In query_astroport_twap_price function iterates over all snapshots to nd those whose period falls within a specied tolerable window. This window is dened as the period ranging from the window size minus tolerance to window size plus tolerance. This calculation implies that the window size exceeds the tolerance period. Suppose the owner miscongures either the tolerance to be higher than the window size or the window size to be lower than the tolerance. In such situations, the above assumption will not hold, and the tolerable window period will not be eectively enforced. Consequently, the valid tolerable window period could be a value smaller than window size minus tolerance or higher than window size plus tolerance, aecting the nal price reported. We classify this issue as minor because only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Removing price sources in the oracle could stop reward collector operations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "In contracts/oracle/base/contract.rs:106, RemovePriceSource messages in order to remove price sources from the oracle. the contract owner can execute However, the removal of asset prices could have a detrimental impact on the operations of the swapper and reward collector contracts. Specically, in contracts/swapper/astroport/src/route.rs:91-92, the swapper retrieves oracle prices during a swap process. If the owner proceeds to remove the price source associated with the fee_collector_denom or the safety_fund_denom, the swap operation will encounter an error. This would render it impossible to carry out asset swaps within the reward collector.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Missing prerequisites check when adding a Pyth price source", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "In and contracts/oracle/wasm/src/price_source.rs:184 contracts/oracle/osmosis/src/price_source.rs:381, when validating a Pyth price source, no validation is performed to enforce prerequisites. In fact, since Pyth prices are denominated in USD, a price source from USD to base_denom is needed in order to compute prices correctly. We classify this issue as minor because only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/address-provider/Cargo.toml  contracts/incentives/Cargo.toml  contracts/oracle/base/Cargo.toml  contracts/oracle/osmosis/Cargo.toml  contracts/oracle/wasm/Cargo.toml  contracts/red-bank/Cargo.toml  contracts/rewards-collector/Cargo.toml  contracts/swapper/base/Cargo.toml  contracts/swapper/astroport/Cargo.toml  contracts/swapper/osmosis/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Funds in the swapper contract can be stolen", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-08-01 Audit Report - Mars Red Bank Updates v1.0.pdf", "body": "In contracts/swapper/base/src/contract.rs:155-182, the swap_exact_in function swaps Coins dened in coin_in input parameter without checking that they are provided by the user in info.funds. This vulnerability enables potential attackers to seize all the coins within the contract by sending swap messages with specically chosen coin_in parameters. We classify this issue as informational because the swapper contract is not intended to hold any funds, as the TransferResult message will distribute all the funds out.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Missing tax deductions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf", "body": "The stable yield manager does not deduct taxes. While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is small.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Price oracle block height not validated which may return out of date values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf", "body": "get_mirror_asset_oracle_uusd_price in The contracts/delta_neutral_position/src/util.rs:39-53 does not validate that the price information for the specied mAsset is up-to-date. Currently, the contract takes the returned rate and returns it as the valid uusd price for the mAsset to the caller without performing a block height validation to ensure that the price feed is accurate. The mirror price response includes both   last_updated_base and last_updated_quote values for this purpose. function The Mirror mint contract does provide the functionality to return an error if the price is not within the get_mirror_asset_oracle_uusd_price query does not currently provide the optional block_time parameter so this operation will not occur. block_time, seconds but the of", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Loss of precision during fee calculation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf", "body": "The contract EthereumManager performs multiplication after division while calculating the fee in line 185. This can lead to imprecision due to rounding.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Consider adding more validations to Solidity contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf", "body": "Consider adding the following validations in the Solidity contract to prevent accidental value updates. 1. EthereumManager.sol: for CROSS_CHAIN_FEE_BPS to prevent any accidental update that can cause wrong fee calculation and result in loss of funds for the end-user. Consider adding upper limit an 2. EthereumManager.sol: Consider adding zero address validation while updating the FEE_SINK address.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Delta neutral position should implement a migrate only if newer pattern", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf", "body": "The delta neutral positions contracts are currently migrated in an asynchronous fashion. This is ne, but the pattern can be improved by adding validation to ensure that the migration is only occurring if the version supplied is newer.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. migrate_position_contracts allows anyone to perform migrations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf", "body": "migrate_position_contracts The in contracts/delta_neutral_position_manager/src/contract.rs:144 does not restrict who can migrate the contracts. Currently, anyone can call this function and pass in whichever positions or position contract addresses they wish to migrate. While this is not inherently malicious, the best practice would be to restrict the entry-point. function We consider this issue to be informational since the code ID thats used after migration can only be set by the administrator.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Certain cross-chain and Terra transfers are overly permissive", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf", "body": "public functions initiate_outgoing_token_transfer and The in process_cross_chain_instruction contracts/terra_manager/src/crosschain.rs:28 and 378 respectively are overly permissive. These functions are callable from any terra address, yet are only intended to be called by the Aperture strategy and manager contracts. In order to limit the attack surface of these contracts, it would be better to add access control to the contracts. found as", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Use of the term info may impact readability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-03-08 Audit Report - Aperture v1.0.pdf", "body": "delta neutral position contract The both and contracts/delta_neutral_position/src/rebalance.rs:123 represent contracts/delta_neutral_position/src/contract.rs:472 terraswap pool info. This may impact readability and maintainability of the code because the name may conict or be confused with info, which is commonly used to represent CosmWasm MessageInfo. info uses term the to in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. The moving average time limit can be incorrectly set to zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf", "body": "In contracts/pair_concentrated/src/const.rs:49, the boundaries of the moving average time limit are dened as an including range between zero seconds and a week. since is However, contracts/pair_concentrated/src/state.rs:304 and it can be set to zero, could cause a division by zero error. ma_half_time denominator used the as in it", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Factory contracts ownership transfer freezes pair contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf", "body": "During the handling of ExecuteMsg, the migration_check function dened in contracts/pair_concentrated/src/contract.rs:215-218 ensures that there is no pending ownership transfer in the factory contract. When the factorys new owner accepts their role by executing the ClaimOwnership message, all registered pairs are added to the PAIRS_TO_MIGRATE vector. When a pair is in this vector, the migration_check function returns an error and all the pair operations are disabled. The factorys new owner can then reactivate pairs by executing the MarkAsMigrated message. This implies that all pair operations will fail while even just one pair is not yet migrated. Such a situation may be caused by a migration issue or a compromise of the factory contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Unnecessary nested loops when initializing cumulative prices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf", "body": "When instantiating the contract, the cumulative price vector is initialized with default values in contracts/pair_concentrated/src/contract.rs:80-84. Within two nested loops, it is then veried that assets are not duplicated before pushing them to the relevant vector. As there can only be two assets, the usage of nested loops is unnecessary, increases code complexity, and reduces readability.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Incorrect error message for CW20 token swap", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf", "body": "a Swap in operation When contracts/pair_concentrated/src/contract.rs:243-245, offer_asset is validated to not be a CW20 token. If it is, an incorrect ContractError::Unauthorized error is returned. performed is This provides a poor user experience as it may be dicult for users to identify the source of the error when executing a swap transaction with a non-native asset.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Unsafe math usage could lead to division by zero error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf", "body": "The query_compute_d function is used to compute the current pool D value by invoking Calc_d and newton_d functions. However, if the pool has no liquidity yet (i. e. before the rst use of provide_liquidity), a division in contracts/pair_concentrated/math/math-decimal.rs:65. occur error zero can by A test case showcasing this issue is provided in the Appendix.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Unclear error message for a single-sided initial deposit", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf", "body": "The contract does not allow the rst deposit to be a single-sided one by returning an in only InvalidZeroAmount contracts/pair_concentrated/src/contract.rs:414-415. provided asset error one is if However, understanding why their liquidity provision is not successful. this error message is not self explanatory and may prevent a user from", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Unnecessary tax deductions are performed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf", "body": "performing When packages/astroport/src/asset.rs:92. tokens native transfers tax deductions are performed in However, calculations. the function to compute tax always returns zero instead of performing actual", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Validation can be performed earlier", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf", "body": "there is a check that In contracts/pair_concentrated/src/contract.rs:59, prevents the code from running if the amount of assets provided in msg.msg_info is dierent waom two. Since this information is always available, check_asset_infos and potentially abort the execution early to save resources. this check can be done before calling in contracts/pair_concentrated/src/contract.rs:377, the check for Similarly, invalid number of assets can be done before querying the pools and running check_assets.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Mismatch between comments and code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf", "body": "In contracts/pair_concentrated/src/state.rs:261, the get_amp_gamma function state that the parameters stored in the future parameters will be returned in case the block time is greater than the value in self.future_time. the comments for However, parameters are also returned if the block time is equal to the self.future_time. contracts/pair_concentrated/src/state.rs:264, in the future", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Arithmetic operations can be optimized", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf", "body": "In contracts/pair_concentrated/src/utils.rs:291, in order to get the index of ask_ind, a subtraction is performed. Given that ask_ind can be either 0 or 1, this is not the most ecient way to compute a bit ip. In contracts/pair_concentrated/src/utils.rs:415, a sum of two dierences is calculated to get to the the deviation, which is dened as the sum of the distances between the value of two deposits and the average deposit value. Given that there are only two elements, this computation is not ecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Duplicated fee address checks during Swap", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-03-16 Audit Report - Astroport Concentrated Liquidity Pool v1.0.pdf", "body": "During the handling of Swap messages, fee_address is provided. there are multiple checks to ensure that the In contracts/pair_concentrated/src/contract.rs:747, an explicit check is made but it is not required since the check in line 748 depends on the logic in line 702 that already validated the existence of the fee address.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "2. No validation of IBC message timeout", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-02-14 Audit Report - Astroport IBC v1.0.pdf", "body": "The length of controller and satellite contracts in: IBC message timeouts is dened during the instantiation and update of  contracts/controller/src/contract.rs:36  contracts/satellite/src/contract.rs:44  contracts/satellite/src/state.rs:55 However, there is no validation of this timeout value, which could lead to timeouts being dened that are of zero value or very high, up to u64::MAX. This may prevent the execution of cross-chain interactions as messages may expire before they can be handled or, in the case of very high timeout values messages may remain active indenitely. We classify this issue as minor since it can only be caused by the contract owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Setting total supply incorrectly when registering a beta invitation will lead to failures when claiming and distributing tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "In contract/src/execute.rs:203-209 of the beta-game-launcher repository, the total supply value is not validated to be higher than the total required amount as seen in lines 398-407 and lines 526-535. If the total supply value is set to be lower than required, it would cause claim, token_distribute, or both to fail due to minting capacity reaching the maximum. This will cause users to be unable to claim their shares of game and fan tokens. Likewise, the admin would be unable to distribute main and game tokens to recipients, causing a loss of funds for the users and recipients.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Updating main token address may cause state inconsistency", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "In contract/src/execute.rs:146-148 of the beta-game-launcher repository, the address of the main token can be updated to a dierent value. If the main token address is updated while the contract has an existing config.main_token value, it would cause an inconsistency between the contracts state and the actual token balance held in the contract. As a result, this would cause a series of problems such as users being unable to withdraw their tokens due to insucient contract balance.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Decimals are not accounted for in calculation of main_token_amount", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "the beta-game-launcher repository, In contract/src/execute.rs:300 of the buy_amount is multiplied by the invitation_price to ensure that sucient main_token and main_token is invitation_price can have dierent numbers of decimal places, the calculation may be performed incorrectly. This could lead to a user being able to purchase at a lower price than expected. supplied. However, the game_token, as", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Equal value of sold amount and soft cap causes inconsistent evaluation of condition", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "In contract/src/execute.rs:371-373 of the beta-game-launcher repository, the claim function would evaluate passed as true only if the sold amount is higher than the soft cap value. This is inconsistent with the token_distribute functionality as seen in lines 508-510 since the execution would continue if the sold amount is equal to or greater than the soft cap value. In an edge case where both the sold amount and the soft cap value are equal, the claim function would determine the invitation as a failure but the token_distribute function would determine the invitation as a success. In a worst-case scenario, the users funds would be incorrectly distributed to the recipients which might cause slow users unable to have their funds refunded back due to insucient balance held in the contract.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Missing validation on main_token_distributions during update cong", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "In contract/src/execute.rs:154-156 of the beta-game-launcher repository, the distribution values in main_token_distributions are not validated as seen in lines 27-36. This means that theres a possibility that the sum of the distribution rate can be over 100%, potentially causing the token_distribute function in lines 515-524 to either distribute more funds than intended or fail due to insucient funds. We consider this to be a minor issue since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Duplicate accounts creation would inate token total supply", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "In src/contract.rs:63-71 of the cw20 repository, duplicate accounts are not veried when creating initial accounts during the contract instantiation phase. If the same account address is passed twice in create_accounts, the accounts balance would be overwritten via BALANCES.save but total_supply would still record the balance amount of both. As a result, the tokens total supply would be inated. We consider this to be a minor issue since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Owner and main_token addresses are not validated during instantiation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "In contract/src/execute.rs:20 of the beta-game-launcher repository, during the handling of the Instantiate message, owner and main_token addresses are not validated. This may cause the contract to be initialized with invalid values. This issue is also present during the cong update phase in lines 146-152.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. cw20 is based on a legacy version of the CW20 standard", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "In the cw20 repository there is a legacy implementation of cw20 token. As stated in that implementation repository :1 This contract is modied for the purpose of migration from a Columbus-4 cw20 token contract to Columbus-5. Using the ocial version of cw20 is strongly recommended for other usages Unlike the latest version, the legacy version does not support the marketing eld which is required in contract/src/execute.rs in lines 254-277. As a result, using the legacy version of CW20 token code id would cause register_beta_invitation functionality to fail due to the dierences between the latest CW20 contract token interface and the one used in this contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Incorrect contract name in cw20", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "In src/contract.rs:21 of the cw20 contract, the CONTRACT_NAME is set equal to crates.io:cw20-base. This is the template contract name of the CW20 contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Centralization of NFT unlocking", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "In contract/src/execute.rs:95-98 of the lock-nft repository, only the owner of the contract can unlock users NFTs and return them back to them. If the owner key is compromised, the remaining locked NFTs in the contract will be inaccessible.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Admin operations implement custom logic", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "In all contracts there is the concept of Admin, which is an account that has exclusive permissions to execute some messages. As there is already a battle-tested implementation of this that takes care of validation and its ready out of the box, it should be better to use that one instead of using custom logic.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. No error message for query of non-existent token", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "In contract/src/query.rs:28-35 of the lock-nft repository, users can query the owner of a token using an nft_address and token_id as the key. In the case that there is no token with such a key an empty string is returned as the owner. This leads to a worsened user experience as incorrect queries cannot be easily diagnosed.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "The following packages and contracts do not enable overflow-checks for the release prole:  lock-nft/contract/cargo.toml  beta-game-launcher/contract/cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Canonical address transformations are inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "While previously recommended as a best practice, usage of canonical addresses for storage is no longer encouraged. The background is that canonical addresses are no longer stored in a canonical Additionally, the codebase is more complicated with address transformations. format, so the transformation just adds overhead without much benet.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Typographical errors found in codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/C2X/2022-05-09 Audit Report - C2X v1.0.pdf", "body": "In contract/src/execute.rs of the beta-game-launcher repository, there were several typographical errors found in lines 35-301. Specically, the word queal should be replaced with equal while the word worng should be replaced with wrong.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Setup function can be used by anyone to take control of the gateway contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "In the Solidity contract contracts/src/AxelarGatewayMultisig.sol the setup function can be called multiple times by anyone, allowing an adversary to take over control of the key privileged roles. This is due to the function being externally callable and not protected by any pre-condition other than not being callable on the implementation contract directly. However, since the storage contract the proxy this guard does not prevent unauthorized invocations. is that of This issue also applies to contracts/src/AxelarGatewaySinglesig.sol (out of scope).", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Non-unique key for identifying voting topics implementations may lead to lost proposals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "In the Solidity contract contracts/src/AdminMultisigBase.sol function the hash of msg.data is used to identify proposal topics. This value is used as a key to store the topic in the eternal storage contract (key-value store). However, msg.data simply encodes functions and parameters, meaning that repeated proposal of the same operation will result in the key being calculated with the same result. In this case, the previous proposal would be overwritten in storage and lost. msg.data can also be malleable due to dierent libraries or wallets adding trailing zeros which could lead to key mismatch (see issue Manual storage management in upgradability pattern used is error-prone and may lead to storage key conicts).", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Gateway contract address depend on token symbol only and might clash", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "Token contracts and burner contracts are deployed using the create2 opcode, in order to deterministically calculate the addresses on both sides. Since the initialization code remains constant for all tokens the only distinguishing factor for dierent deployments is the salt used in the address calculation. To this end, the codebase uses the hash of the token symbol. Since the token symbol becomes the only identier of an asset, tokens with the same symbol will clash, resulting in the same contract address. Eectively, only 3 bytes of input are used to produce a 32-byte hash value. This may lead to accidental overwriting of assets.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Expired polls can be voted on", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "In the x/vote/types/types.go module, the Vote method lacks a check whether the poll has been expired, allowing expired polls to be voted on.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Manual storage management in upgradability pattern used is error-prone and may lead to storage key conicts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "The Solidity smart contracts use an eternal storage pattern using a hash of an identier key as a manual storage pointer.. This introduces a source of potential errors since keys with the same name result in the same hash causing storage to be overwritten. The reverse can also occur if the source of the key calculation may be encoded slightly dierently by o-chain libraries. An example of this occurring is the msg.data eld used as a key in contracts/src/AdminMultisigBase.sol. This eld may have trailing zeros, depending on the wallet implementation used to interact with the smart contract, resulting in dierent key calculations and failure to look up the correct entry.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. ExportGenesis should return the genesis state instead of nil", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "In the x/axelarnet module, the genesis export returns nil.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Panic used for non-eligible validators in ination calculation breaks iteration for the other eligible bonded validator", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "Function handleTssInflation in x/reward/abci.go uses panic during the bonded validator iteration when a validator is found to be not eligible. This will skip the other eligible bonded validators.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Single invalid key causes subsequent valid keys to be skipped when batch-registering external keys", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "In the RegisterExternalKeys function in x/tss/keeper/msg_server.go, the iteration skips valid keys when an invalid key is present in the slice by returning from the method when it nds any validation error.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. RouteIBCTransfer is not considering all the valid chain entries in case of error during iteration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Axelar/Audit Report -  Axelar.pdf", "body": "In the x/axelarnet module message server function, the RouteIBCTransfers returns on encountering an error during iterations. This will cause the method to skip all other entries in the slice over which the iteration is performed.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Users that unbond from yAsset contract in XPrism mode receive twice their bonded amount minus the fees, and fees are not collected", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "StakingMode::XPrism, In contracts/prism-yasset-staking/src/staking.rs:96-108 and 116 if mode user == - withdrawal_fee. At the same time, the fees are not sent to any other contract. This leads to draining funds from other users and fees not being distributed to stakers, compromising incentives to stake. 2*unbonded_amount receives the", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Lack of tax deduction in limit order contract leads to other users funds being spent", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "In contracts/prism-limit-order/src/order.rs:319 and 322 no taxes are deducted during the execution of the swap. Without deducting taxes, the contract will pay taxes for the swap from its own balance, which will consume the oered amounts of other limit orders, leading to a failure to execute those other limit orders in the future. This would aect a wide range of users of the protocol, who would permanently lose their funds.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Missing total bond amount decrease during unbonding from launch pool contract leaves rewards stuck in contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "the in In contracts/prism-launch-pool/src/contract.rs:206-215, the total_bond_amount is not decreased by the unbonded amount. This implies that for any further rewards, the denominator in line 277 will be too big, leading to any bonded users proportionally losing out on further rewards. unbond function", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Users might lose their bonds if unbonding periods of vault contract and Terra protocol are not the same duration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "If no batch is released in contracts/prism-vault/src/unbond.rs:255, the actual unbonded amount is still set to zero in line 317. Moreover, the prev_vault_balance is updated in the calling function execute_withdraw_unbonded in line 191. This might cause lost funds because the vault unbonding period can be freely set, while the Terra unbonding period is xed to 21 days. Two cases are possible. On the one hand, if the unbonding period used in the contract is longer than the actual unbonding period of the Terra protocol, this might lead to lost funds. On the other hand, if the unbonding period is set to less than the actual unbonding period, slashing of validators might lead to a situation where users can avoid being aected by slashing at the cost of other users because the slashing is not executed. Despite the severe implications of a mismatch of the unbonding periods, we classify this issue as minor, since governance can ensure equality of the periods by carefully making required changes.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Exchange rate peg mechanism allows users to prot from slashes and inhibits liquidity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "peg rate exchange in The and contracts/prism-vault/src/bond.rs:119-129 contracts/prism-vault/src/unbond.rs:41-51 might compromise the incentives of users and validators, depending on the parameter values of the threshold and the recovery_fee. There might be a free lunch for any user that bonds directly after a possible slashing event. implemented mechanism this First, compromises contracts/prism-yasset-staking/src/rewards.rs:28-35 stakers_portion could become larger than one. computations made where in the Second, in the worst case, if a potential prot from a free lunch is large enough, validators might be incentivised to trigger slashing in order to realize these prot opportunities. This might compromise the protocol. Third, users that wish to unbond after slashing have to pay up to the maximal peg recovery fee peg_fee in order to restore the peg. This leads to a rst-mover disadvantage in the sense that one single user might need to pay for the whole slashing. This in turn disincentivizes unbonding and reduces the liquidity of all derivative tokens. These issues are caused by the peg recovery mechanism. In contrast to the Anchor protocol, which uses a similar mechanism, Prism does not have a natural peg recovery by accruing rewards on cLUNA.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Withdrawal of funds may fail if a user unbonds many times without withdrawing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "In contracts/prism-vault/src/state.rs:60, 76, 89 and 114, iterations over the UNBOND_WAITLIST may run out of gas, if the list has many entries. Many entries might occur if a user unbonds regularly, but does not withdraw. That could happen for example if the user is a bot that automatically bonds daily. As a consequence, withdrawing funds may fail. There is currently no way to recover from this issue. Similarly the query in line 139 can run out of gas and fail.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Protection against mass withdrawals is weak and can be bypassed with multiple accounts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "In contracts/prism-fair-launch/src/contract.rs:185-187 in order to prevent massive withdraw on phase 2 (as stated in the comment), a fee is charged if withdraw_amount is greater than cfg.withdraw_threshold. This mechanism can easily be avoided by withdrawing multiple times with amounts less than or equal to cfg.withdraw_threshold. Elaborate exploiters can also bypass it easily by using multiple accounts to execute greater withdrawals.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Lack of conguration validation in vault and yAsset staking contracts can cause errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "The conguration of peg_recovery_fee and er_threshold can be set to values larger than one in contracts/prism-vault/src/contract.rs:78-79 as well as in in contracts/prism-vault/src/config.rs:38-39. This might and contracts/prism-vault/src/bond.rs:124-126 contracts/prism-vault/src/unbond.rs:45-47. cause errors An equivalent problem occurs in prism-yasset-staking/src/contract.rs:37 and 42 where protocol_fee and withdraw_fee can be set to values larger than one, which might cause errors in contracts/prism-yasset-staking/src/rewards.rs:70 and prism-yasset-staking/src/contract.rs:116, respectively. We consider this a minor issue, since it can only be caused by oversight of the contract owner. However, errors in production can lead to downtime of the protocol.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Conguration updates in gov contract might aect votes in progress", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-01-20 Audit Report - Prism v1.0.pdf", "body": "be In contracts/prism-gov/src/contract.rs:205-210, quorum and threshold in aects can contracts/prism-gov/src/polls.rs:141-146, which could aect the outcome of a vote. In addition, proposers might lose their deposit on existing polls after a change of the quorum. updated. progress votes This in As the values can only be updated by the contract owner or through governance, we consider this a minor issue. An update coming through governance would be visible by any proposer at the time of poll creation. Since the outcome of a poll that updates quorum or threshold values might not be certain, proposers could be disincentivized to create new polls during such a period.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Lack of authorization for privileged operations in the lpp contract allows users to manipulate the market", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "The lpp contract does not implement an authorization logic for the execution of privileged operations and does not have the concept of a contract owner/administrator. This implies that anyone can send UpdateParameters messages to update critical contract parameters and base_interest_rate, addon_optimal_interest_rate, which can be used to manipulate the market. utilization_optimal like the", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Price feeding mechanism could be permanently inhibited through market alarms", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "The oracle allows contracts to subscribe to MarketAlarms in order to be notied when price changes trigger a particular condition. When a Feeder sends the FeedPrices message to update an asset price, a PriceAlarm message is dispatched and sent to all subscribing contracts. Since an O(n^2) unbounded loop through MarkedAlarms is needed to check and re alarms, a signicant number of subscriptions could lead to out of gas errors. Consequently, feeders will be permanently inhibited from providing new prices. A malicious actor could develop a contract with a computationally expensive PriceAlarm handler and subscribe potentially multiple MarketAlarms in order to cause the FeedPrices message to always run out of gas. Even without malicious intent, this issue is likely to occur since lease contract instances that users can instantiate from the leaser contract subscribe to alarms in the oracle.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Time alarms could be permanently disabled", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "The timealarms contract allows other contracts to subscribe to TimeAlarms in order to be notied at a certain timestamp. The Notify transaction is used to trigger all stored alarms with a timestamp less than the actual time and execute the TimeAlarm transaction in the respective contracts. Since there is not a dened maximum number of stored alarms and a maximum amount of gas that TimeAlarm handlers can consume, the execution of Notify may run out of gas if a signicant amount of alarms are registered. Consequently, no time alarm could be triggered anymore. A malicious actor could intentionally deploy computationally expensive contracts that subscribe to TimeAlarms, consuming more gas than available and hence eectively disabling time alarms.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Lack of instantiation authorization in the lease contract allows attackers to instantiate it with arbitrary parameters and hence prevent liquidation and use arbitrary prices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "During the execution of the InstantiateMsg of the lease contract, it is not enforced that its instantiator is the leaser contract. This implies that an attacker could instantiate a lease contract without the intermediation of the leaser, which allows the attacker to provide arbitrary parameters. For example, he could set a custom oracle address or liability congurations. This gives the attacker the ability to prevent liquidation and set arbitrary prices.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Incomplete Neutron messages support may lead to inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "Contracts implement Neutron message specications but are not implementing their specic Sudo handlers used for handling message responses. This could lead to dierent inconsistencies and partial state updates in the protocol in case of errors or timeouts in the controlled chain. Some examples of the aforementioned behavior exhibited in the code:  In contracts/profit/src/profit.rs:63, a non acknowledged alarm can lead to prots not being transferred.  In contracts/lease/src/liquidation/alarm.rs:127, not properly rescheduled alarms can impact the timing of liquidations.  In contracts/lpp/src/contract/borrow.rs:57, failed attempts to transfer funds using BankMsg::Send through an interchain transaction are not handled.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Lack of alternate recipient address validation may lead to loss of users funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "When sending a ClaimRewards message to the lpp contract, the user can specify an alternate reward recipient in the other_recipient parameter. However, in contracts/lpp/src/contract/rewards.rs:34, during the execution of the try_claim_rewards function, the other_recipient address is valid. there is no validation in place to check that An invalid address will lead to the permanent loss of the users rewards.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Oracle is not resilient to feeders errors or manipulation attempts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "FeedPrices The in contracts/oracle/src/contract/exec.rs:61 enables feeders to submit their oracle prices on chain. message dened its associated Since in contracts/oracle/src/contract/feed.rs:92 does not perform any validation on inputs, it allows feeders to store incorrect data, for example a price equal to zero or multiple prices in the same block. try_feed_prices handler Also, the get_price function in packages/marketprice/src/feed.rs:55, which is responsible for providing the price of an asset, is returning the latest feeded one, without performing any calculation with other stored data points. By not performing any checks, nor transforming the data through any function that might catch outliers and data points that are not representing the real market price, the protocol allows the price to be manipulated by just introducing one corrupted observation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Contract ownership cannot be transferred", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "The treasury, dispatcher, leaser, profit and oracle contracts do not implement an ownership transfer mechanism. Since the dened owner has the right to modify critical contract parameters and execute privileged messages, a compromise of its account would have devastating consequences for the protocol. It is best practice to oer functionality to transfer the ownership to another account.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Lack of price validation could lead to a division by zero error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "In contracts/oracle/src/contract/feed.rs:67, there is no validation to ensure that prices are not equal to zero. Since throughout the codebase there are multiple calls to the inv function with the price value, there is a risk that the protocol performs a division by zero.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. It is not possible to migrate lease contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "In contracts/leaser/src/cmd/borrow.rs:27-34, message is constructed with the admin parameter set to None. the lease contract instantiate This implies that the instantiated contract could not be migrated in case of a bug or a vulnerability disclosure.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Time alarms can be created for the past", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "In packages/time-oracle/src/alarms.rs:60-69 the add function is not enforcing that a new time alerts timestamp is in the future.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Lack of validation for the UpdateParameters message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "In contracts/lpp/src/contract/config.rs:9-22 the try_update_parameters function is updating the contract parameters without validating them. base_interest_rate, Since and addon_optimal_interest_rate are Percent values, they should be validated to be in the [0,1) interval. utilization_optimal We classify this issue as minor since only the contract owner can set those values.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Lack of validation of Dispatcher cong parameters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "In contracts/dispatcher/src/contract.rs:45-50, the tvl_to_apr parameter is not validated during the dispatcher contract instantiation. This could lead to incorrect APR calculations and to not covered TVL intervals. We classify this issue as minor since only the contract owner can set this parameter.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Lack of validation of the leaser instantiation parameters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "In contracts/leaser/src/contract.rs:29, during the leaser contract instantiation, not all the parameters are validated, such as liability and repayment. incorrect congurations could be used in the contract, such as a Liability As a result, instance with an incorrect attribute relationship, for example, a healthy factor smaller than the initial factor or greater than the max factor.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Potential algebraic overows", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "Protocol contracts are not making use of checked operators in order to guard against algebraic overows. For example:  In contracts/lpp/src/state/deposit.rs:79. globals.balance_nlpn is incremented by deposited_nlpn without checking for overows. This assignment can be dangerous if the price of NLP is in the (0,1] range. In that case the entire global value could overow, which would aect rewards calculation.  In contracts/leaser/src/state/leaser.rs:23, an increment of an integer could cause an overow eventually. Since overflow-checks are enabled in Cargo.toml prole, the execution will panic if an overow occurs; however it should be better to be handled gracefully with an error message.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/treasury/Cargo.toml  contracts/dispatcher/Cargo.toml  contracts/timealarms/Cargo.toml  contracts/lpp/Cargo.toml  contracts/leaser/Cargo.toml  contracts/oracle/Cargo.toml  contracts/profit/Cargo.toml  contracts/lease/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Custom access controls implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "The treasury, dispatcher, leaser, profit and oracle contracts implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Wrong variable name for APR", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "In contracts/dispatcher/src/state/tvl_intervals.rs:72, a variable is named arp, when it aims to reect the APR value.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Typographical error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2023-01-27 Audit Report - Nolus Money Market v1.1.pdf", "body": "contracts/leaser/src/error.rs:27, In IvalidLiability, while its correct spelling is InvalidLiability. error an variant is named", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Access nodes are not ltered when approving or setting default node", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf", "body": "In cadence/contracts/DelegatorManager.cdc:957 and 984, the admin can initialize an approved list of node operators or set a default node to stake using the initApprovedNodeIDList and setDefaultNodeIDToStake functions. However, no validation ensures the initialized or selected nodes are not access nodes. nodes access be Since cadence/contracts/standard/emulator/FlowIDTableStaking.cdc:1183-11 86, misconguring an access node as the default staking node prevents users from staking FLOW tokens and redeeming FLOW tokens instantly from the liquid staking contract. delegated cannot seen as to in This could happen when the admin calls setDefaultNodeIDToStake with an access node as the nodeID argument or during the advancing epoch phase in the filterApprovedNodeListOnEpochStart function at line 633. We consider this a minor issue since only the admin can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Migrate function does not enforce minimum staking amount", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf", "body": "In cadence/contracts/LiquidStaking.cdc:185, the migrate function does not check whether the delegated tokens are greater than or equal to the minimum staking amount. Unlike the stake functions precondition check in line 60, the validation is not enforced in the migrate function.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Minimum staking amount and staking cap are not validated against each other", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf", "body": "In cadence/contracts/LiquidStakingConfig.cdc:100-108, the admin can set the minimum staking amount and staking cap for the liquid staking protocol. Since the minimum staking amount is expected to be lower than the staking cap and vice versa, misconguring the values would prevent users from staking their FLOW tokens due to cadence/contracts/LiquidStaking.cdc:60 and 62. there should be a precondition check to ensure the updated values are higher/lower than the other. Ideally, We consider this a minor issue since only the admin can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Trust dependency on admin keys", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf", "body": "In cadence/contracts/stFlowToken.cdc:121, the mintTokens functions access modier is set to access(account). Theoretically, the account owner can mint as many stFlow tokens as required by deploying a new contract that calls the mintTokens function or performing a contract upgrade that modies the access modier access(all) keywords. into pub or The possibility of the admin is malicious or the private key is compromised. With that said, both deploy and update contract actions will emit events that o-chain listeners can fetch, which are easily trackable and monitorable with tools. this happening is that", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Incorrect event emitted when admin modies isMigratingPaused conguration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf", "body": "the cadence/contracts/LiquidStakingConfig.cdc:137, In the emitted ConfigStakingPause isMigratingPaused conguration. This is incorrect, as the ConfigMigratingPause event should be emitted instead. updates admin event when the is", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Supply start index higher than the end index causes collectDelegatorsOnEpochStart to perform empty execution", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf", "body": "In cadence/contracts/DelegatorManager.cdc:503, the while loop attempts to collect all delegators to the next epoch based on the provided start and end index. If the start indexs value is supplied higher than the end index, the loop will not execute, causing the collectDelegatorsOnEpochStart function to collect zero delegators.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. initApprovedNodeIDList gas consumption can be reduced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf", "body": "In cadence/contracts/DelegatorManager.cdc:962-964, the for loop attempts to insert the approvedNodeIDList dictionary with the nodeIDs argument key and value. This causes unnecessary gas consumption as the values can be set directly.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Distributing tokens to the same node operator yield no dierence", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf", "body": "In the cadence/contracts/DelegatorManager.cdc:826, transferCommittedTokens function allows a strategy bot to transfer committed tokens from one delegator to another. Since no validation ensures that fromNodeID and toNodeID are not the same node operator, the result of the execution would yield no dierence.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Typographic errors and duplicate comments found in codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - IncrementFi Liquid Staking.pdf", "body": "In several instances of the codebase, typographical errors were found along with duplicate code comments.  cadence/contracts/DelegatorManager.cdc:125 contains an additional protocol word at the end of the sentence  cadence/contracts/LiquidStakingConfig.cdc:13 contains a typographical error of minimum This aects the readability of the contracts.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Blacklist policy is not enforced for other chain addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/blockibc_middleware.go:111-115, the sender address is checked to not be blacklisted when performing an IBC token transfer. Since ICS-20 token transfers involve escrowing USDC to other chains, the blacklist policy should ensure that other blacklisted chain addresses cannot redeem the locked USDC with their IBC vouchers. However, this is not possible due to the AccAddressFromBech32 validation in x/tokenfactory/types/message_blacklist.go:45-48, which can only validate native Bech32 prex addresses. This implies that addresses on other chains can redeem USDC independent of a blacklist, since they cannot be blocked by the blacklist. For example, the following command fails when trying to blacklist a Juno address: nobled --home $CHAINDIR/$CHAINID tx tokenfactory blacklist juno1t8ehvswxjfn3ejzkjtntcyrqwvmvuknzy3ajxy --from $(nobled keys show blacklister -a) -y Error: invalid blacklist address (invalid Bech32 prefix; expected noble, got juno): invalid address This issue also aects the receiver blacklist policy in app/ante.go:89-93 when initiating an ICS-20 token transfer. Consequently, the blacklister will not be able to prevent users from transferring USDC to malicious addresses on other chains. We classify this issue as major because the blacklist policy is considered an important security feature in Nobles architecture.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Minting denom can be transacted through IBC during a paused state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "x/tokenfactory/blockibc_middleware.go:92-114, In OnRecvPacket handler does not validate the keepers paused state when receiving ICS-20 fungible token transfer packets. When the keepers paused state is true, all internal and external transfers are disallowed, as seen in app/ante.go:39-43. However, other chains can still transact USDC tokens to the native chain, eectively bypassing the paused state. the We classify this issue as major because the paused state is considered an important security feature in Nobles architecture.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. IBC middleware does not parse denoms trace when receiving ICS-20 packet data", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/blockibc_middleware.go:101-103, security measure will be skipped if the packets denom is not the congured minting denom. As mentioned in lines 83-85, this is to ensure that the sender and receiver are not blacklisted if they were to transact an IBC voucher representation of USDC. the blacklist However, this approach will never work because the receiving packets denomination is constructed with a record of channels for which they have been transferred across chains, such as transfer/channel-40/uusdc. Consequently, the condition in line 101 will always evaluate as true, eectively bypassing the blacklist policy in lines 105-115.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Incorrect minterController genesis state validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/types/genesis.go:54, the MinterControllerKey function is used to derive the minter controller key from a minter controller address. However, the minter controller address is passed as an elem.Minter in the current implementation. This sets an incorrect minter controller key to validate a duplicated index. Therefore, as the specied key does not contain any data, accessing data onchain would not be possible.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Deviation from specication: A controller can set up any number of minters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "to the the specication, ConfigureMinter According in x/tokenfactory/keeper/msg_server_configure_minter.go:12 should only be called by the minterController and set its corresponding minter. However, the current implementation of ConfigureMinter does not validate that the minter address being congured matches the specied address that the MinterController controls. The same in issue x/tokenfactory/keeper/msg_server_remove_minter.go:12. Because of that, the relationship between MultiController and minter becomes one-to-many instead of one-to-one. This deviates from the specication. RemoveMinter function function exists the in", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Separation of privileged addresses is not enforced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "While there has been an extensive eort made to develop privileged accessed roles within the Noble chain, privilege separation of these roles is not properly enforced. Currently, there is no validation to ensure that these privileges cannot be shared by a single address. In the unlikely case of a compromised account, account sharing may have severe implications. For example, the Owner can assign the Blacklister, Master Minter, and Pauser roles to itself. While new addresses can easily be generated and all roles can technically be owned by the same entity using dierent addresses, it is best practice to restrict address reuse. Another step that can be taken to reduce the impact of a compromised account is to implement timelocks to prevent frequent updates of addresses.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Modifying minting denom allows blacklisted users to transact the old denom", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/genesis.go:45-47, supplying a dierent MintingDenom will cause the SetMintingDenom function to modify the mint denom. This is problematic since the blacklist functionality only works based on the current minting denom, as the decorator in app/ante.go:67-98 only validates that the addresses are not blacklisted if the transacted denom is the congured minting denom. Consequently, blacklisted users who were previously unable to transact the old minting denom can now transact that denom like other users. Additionally, all minters would need to update their old allowances denom to continue minting new tokens. We classify this issue as minor because only the governance can cause it, which requires cooperation among impacted parties.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Minters can be added during a paused state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/keeper/msg_server_configure_minter_controller.go:12 the x/tokenfactory/keeper/msg_server_configure_minter.go:12, and functions can be ConfigureMinterController and ConfigureMinter keeper executed even if the keepers paused state is set to true. This is inconsistent with the pausing section of the token design specication. As mentioned in that specication, adding minters should be prevented while the contract is paused.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Amino codec must be registered to support end users with hardware devices like Ledger", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/types/codec.go:77, Amino should be used to register all interfaces and concrete types for the tokenfactory module. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Incomplete genesis validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/types/genesis.go:29-63, validating all the provided GenesisState attributes. the Validate function is not There is no logic in place that validates Pauser, Owner and Blacklister addresses and that enforces Denom to be a non-empty string.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Missing validation for existing blacklisted address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In x/tokenfactory/keeper/msg_server_blacklist.go, the Blacklist function is used for adding new addresses, however in its current implementation, it is not veried whether a new address is already on a blacklist or not. As a result, the operation succeeds without an error, which may give indexers or other o-chain services the misleading impression that a specic address has not yet been blacklisted.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Missing blacklist validation during minter conguration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In the x/tokenfactory/keeper/msg_server_configure_minter.go, ConfigureMinter method is used to add a minter. However, its current implementation does not check if the provided msg.Address is on a blacklist. This allows adding a blacklisted address as a minter.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Tokenfactory does not perform two-step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "in The x/tokenfactory/keeper/msg_server_update_owner.go:12 does not perform a UpdateOwner function two-step ownership transfer. In the unlikely event that the new owner is set to an incorrect address, then the owner will not be able to be reset, and the owner functionality will be lost.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Succinct event emission restricts information available to indexers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "All dened messages emit TypedEvent events containing the submitted message. However, those events contain only limited detail and may not represent enough information for indexers and other o-chain services.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Amount and Allowance message attributes are not validated to be greater than zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In the ValidateBasic functions in  x/tokenfactory/types/message_burn.go:45,  x/tokenfactory/types/message_configure_minter.go:41, and  x/tokenfactory/types/message_mint.go:41, the Amount and Allowance attributes are not validated to be greater than zero. This implies that messages that contain invalid values can pass the ValidateBasic validation without triggering an error.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Incorrect eld numbers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "The GenesisState message in proto/tokenfactory/genesis.proto uses an incorrect eld number starting from 9. The minterControllerList should have 9, and mintingDenom should have 10 eld numbers.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. InitChainer and BeginBlocker are set twice", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "In app/app.go:571-572 and app/app.go:593-594, SetBeginBlocker methods are called twice, which is inecient. the SetInitChainer and", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Unnecessary validation of From address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "Additional validation for the From address in ValidateBasic functions in the lines below are not necessary since that address belongs to the transaction sender address and is already validated:  x/tokenfactory/types/message_blacklist.go:41  x/tokenfactory/types/message_burn.go:41  x/tokenfactory/types/message_configure_minter_controller.go:4  x/tokenfactory/types/message_configure_minter.go:42  x/tokenfactory/types/message_mint.go:42  x/tokenfactory/types/message_pause.go:40  x/tokenfactory/types/message_remove_minter_controller.go:41  x/tokenfactory/types/message_remove_minter.go:41  x/tokenfactory/types/message_unblacklist.go:41  x/tokenfactory/types/message_unpause.go:40  x/tokenfactory/types/message_update_blacklister.go:41  x/tokenfactory/types/message_update_master_minter.go:41  x/tokenfactory/types/message_update_owner.go:41  x/tokenfactory/types/message_update_pauser.go:41", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Duplicated ValidateBasic invocation in CLI", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Noble/2023-03-13 Audit Report - Noble v1.0.pdf", "body": "CLI commands transaction All in registered x/tokenfactory/client/cli/tx.go call the msg.ValidateBasic function before calling GenerateOrBroadcastTxCLI. As msg.ValidateBasic is already called inside the GenerateOrBroadcastTxCLI, this is an unnecessary and duplicated invocation. GetTxCmd function the in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Withdrawal and staking of voting rewards fails if too many locked balance entries exist", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mirror/Mirror v2 Audit Report.pdf", "body": "the in In get_withdrawable_polls contracts/mirror_gov/src/staking.rs:317, an unbounded iteration over the entries in locked_balance is performed. In each iteration, two storage entries are read. If the and StakeVotingRewards messages would fail, and it would be impossible for a user to recover and withdraw their rewards. WithdrawVotingRewards transaction function runs gas, out the of This issue only aects individual users and the likelihood of the locked_balance list growing to the point of the described issue is very low. Hence we classify this issue as minor.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Fees held by spot vault are locked forever", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf", "body": "During the instantiation of a spot vault contract the fee_recipient is dened as the contract itself, see contracts/ninja-vault-spot/src/contract.rs:31. However, there is no function that allows the fees accrued to be withdrawn, eectively locking the funds forever.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Inventory imbalance under certain parameter constellations will disable the risk management framework", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf", "body": "In order to conduct risk management, the team modeled a reservation price that is dierent from the current mid-market price to be the center of the orders. To account for changes in volatilities, the orders price is a function of the volatility. However, for every imbalance ratio there exists a parameter combination of reservation_price_sensitivity_ratio and reservation_spread_sensitivity_ratio such that the proposed head and tail can be set to market price, by supplying liquidity or withdrawing liquidity, irrespective of the state of volatility. Specically contracts/ninja-vault-spot/src/mm_bot/order_management.rs:17, variable proposed_buy_head can be equal to in the _  +     where  = __  ___     ___ can be zero if: ___    2  ___ (i.e. states of high volatility and trending price behavior) An attacker with access to signicant liquidity could leverage this property during market turmoil to disable the risk management framework, as described above, pushing the vault to an imbalance such that  = 0 .", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Price threshold for price invalidity is prone to manipulation and might lead to full loss of users funds in case of a breakdown of a market or an asset", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf", "body": "In contracts/ninja-vault-derivatives/src/mm_bot/bot.rs:40 a 30% interval is used to render the mark price as invalid. If the new price is out of this interval, the logic in contracts/ninja-vault-derivatives/src/mm_bot/risk_management/oracl e.rs closes positions if protable, or leaves them open and stops all trading activities if not protable. Although this is meant to be a protection against erroneous or manipulated prices, its ecacy is low as an attacker that is capable of manipulating the price by 30%, will also be able to manipulate the price by 29% in one block and 2% in the next or simply manipulate the price by 29.99%. In case of a non-manipulated change by 30% and a continuing trend in the same direction, a losing position will never close  leading to a  full loss of funds for users. There is a way to recover if an admin updates the last_valid_mark_price in in this is an contracts/ninja-vault-derivatives/src/config.rs:91. However, inadequate risk management for an automated trading system with multiple vaults running simultaneously 24/7. In addition, it goes against best practices that admins can update prices as enabled. tool", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Updating Ninja token address may cause state conicts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf", "body": "The owner of the master contract has the ability to update the address of the Ninja token stored in the contracts cong. Altering the Ninja token address could have the eect of causing a state conict in other contracts that use the address stored within the master contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Vault contract invocations should be prevented prior to registration with master contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf", "body": "Vault contracts are designed to be deployed and instantiated from their owner and then successfully initialized from the ninja-master executing the RegisterForMaster transaction. This message execution sets the subaccount_id and instantiates the CW20 contract responsible for managing the vaults lp_tokens. Before this initialization, the vault is not ready to be used and user space transactions and queries should return a meaningful error message.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Large order_density could lead to the execution running out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Ninja v1.0.pdf", "body": "In contracts/ninja-master/src/contract.rs:111-136, the following functions  get_is_authorized_order_data,  get_is_authorized_spot_order, and  get_is_authorized_derivative_order perform an unbounded iteration through orders. Since the length of the vector is related to order_density and this parameter has not an upper bound, a large value assigned to it could lead the execution to run out of gas. analogous An contracts/ninja-master/src/contract.rs:336-375 synthetic_trade.user_trades. problem also occurs in with", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Bad debt state is not recorded", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "In contracts/margined_engine/src/messages:185, the withdraw function called when executing the WithdrawMargin message is updating the bad_debt attribute of the state. As state is passed as a &mut, the withdraw function caller has in the state variable the updated bad_debt value. The state is not stored though, hence the new value is available only in the current execution scope and cannot be retrieved in a subsequent execution. Consequently, the bad_debt information is never saved in the contract store, and the information is lost. This implies that the margined_engine could be insolvent or with an insolvency risk without being aware. Additionally, the State query, which will be used to track the margined_engine status, would always report the bad_debt metric to be lower than the real accrued debt. See Appendix-1 for a test case that shows this issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Incorrect accounting during liquidation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "The margined engine contract incorrectly keeps track of the funds that should be requested or sent to the insurance funds contract upon liquidation. of the case liquidation_fee In in contracts/margined_engine/src/reply.rs:458, remain_margin.margin is not set to zero at the end of the if block, eectively being used rst in the calculation of bad_debt and later on the transfer of remaining margin at line 474. This results in the engine contract unexpectedly moving additional funds to the insurance fund contract. remain_margin.margin > if there is no previously recorded state.bad_debt and the engine contract In addition, doesnt have enough funds to pay a liquidator, the missing amount would be withdrawn twice from the insurance fund contract: The rst during realize_bad_debt in line 468 and a second time during withdraw in line 479. Given the Bad debt state is not recorded issue, this could cause the Insurance Fund contract to be drained faster than expected, potentially causing insolvency issues if not watched carefully. Additionally, these extra transfers incremented gas costs on every transaction related to the aected feature. See Appendix-3 for a test case that shows this issue.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Bad debt is wrongly reset upon realization", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "the in When realize_bad_debt non-zero is contracts/margined_engine/src/utils.rs:81 state.bad_debt value, instead of updating it with any additional bad_debt and withdrawing funds from the insurance fund contract, it is reset to zero and no transfer from the insurance fund is requested. This implies losing track of any previous debt and not covering the new one given the lack of withdrawal from the insurance fund. function called with a Consequently, the contract could be at an insolvency risk without the team being aware as the bad_debt value being reported would be lower than the real accrued debt.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Possible inconsistencies when conguring decimal values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "values decimal In both margined engine and virtual AMM contracts, contract instantiators are required to in specify and contracts/margined_engine/src/contract.rs:62-66 contracts/margined_vamm/src/contract.rs:40. There is no validation that ensures both values are same and consistent with each other when conguring and updating the decimal values via contracts/margined_engine/src/handle.rs:83. If both it will yield incorrect results when executing contracts assume dierent decimal values, SwapInput and SwapOutput, potentially returning a higher or lower output amount than intended that directly aects trader's position size. seen as the MAX_ORACLE_SPREAD_RATIO in Moreover, contracts/margined_vamm/src/contract.rs:26 is represented as 10% with 8 decimal values, meaning that the intended decimal values should be 9 (100_000_000 / 0.1 = 1_000_000_000). Since the constant value cannot be modied, a misconguration of decimals in contracts/margined_vamm/src/query.rs:230 to return an incorrect spread limit exceeded result. query_is_over_spread_limit constant would cause being not that, native token decimals Besides seen in packages/margined_common/src/asset.rs:191. This collides with the virtual AMM satisfy intends decimals MAX_ORACLE_SPREAD_RATIO constant value. are assumed as 6 as requirement decimals accept values since to to it", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Margined engine cannot support native tokens as collateral during mainnet production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "In the packages/margined_common/src/validate.rs:28-33, validate_eligible_collateral functionality only recognizes ujunox and uwasm as supported native tokens when conguring and updating eligible collateral assets. Since ujunox prex only exists in Juno Testnet and uwasm prex originates from wasmd, the hardcoded native tokens will not be usable during production as they dont exist in the Juno mainnet. Also, as not all native tokens follow the utoken convention and could have a custom decimal digits in packages/margined_common/src/asset.rs:191 could lead to possible wrong calculations. representation, hardcoded value 6u8 the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Emergency ShutdownVamms messages are not able to execute SetOpen transactions due to lack of permissions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "In contracts/margined_insurance_fund/src/handle.rs:78, when handling ShutdownVamms messages, the execution is iterating through all the VAMMs registered in the insurance_fund in order to send VammExecuteMessage::SetOpen { open: false } messages to them. Those messages are wrapped in a SubMsg and have the purpose of pausing that specic VAMM. the SetOpen However line contracts/margined_vamm/src/handle.rs:98 that is only accepting transactions intended to be the insurance_fund contract. from its registered Owner that Consequently all the SetOpen SubMsg will fail due missing Owner role permissions. message handler is not guard has at a", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Updating eligible collateral causes state inconsistencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "the contract owner can In contracts/margined_engine/src/handle.rs:73-84, update the eligible collateral, which also updates the decimal values accordingly. This is problematic for the following reasons: Firstly, it would cause a state inconsistency issue. The actual balance held in the contract for the newly congured eligible collateral might be dierent than the recorded state. As a result, traders might be unable to withdraw excess margin due to insucient balance. Secondly, it causes a decimal collision issue as the virtual AMM that the margined engine contract interacts directly with is unable to have the decimal values updated. This causes inconsistencies between the two contracts and will be further elaborated on in the next section. is the than previous it would cause incorrect ratios and liquidation fees if the newly congured decimal Lastly, initial_margin_ratio, value. lower value maintenance_margin_ratio, and liquidation_fee values use decimal value as limit (i.e. 0% to 100%), a lower decimal congured will cause ratios and liquidation fees to exceed the 100% limit. For example, if the previous decimal value is 9 and the new eligible collateral uses 6 decimals, a congured 10% ratio or liquidation fee would become 10000%, which will likely cause all positions to be undercollateralized due to contracts/margined_engine/src/handle.rs:284. partial_liquidation_margin_ratio Since We classify this issue as minor, since only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Insurance fund beneciary can be updated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Margined Protocol/2022-10-28 Audit Report - Margined Protocol Perpetuals v1.0.pdf", "body": "The insurance fund contract allowed its owner to update the beneciary at any time as seen in contracts/margined_insurance_fund/src/handle.rs:36. A malicious insider or an attacker that compromised the keys of the legitimate administrator would be able to set themselves as the beneciary and then withdraw the contracts funds. We classify this issue as minor since only the owner can update the insurance fund beneciary and it is assumed that the owner is a trusted party.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Pools allow attackers to extract free value with minimal cost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "The compute_swap function in contracts/pair/src/contract.rs:733 uses unsigned integers for its calculations without rounding, which opens up a way for an attacker to extract value from a pool with a very small cost. As an example, imagine a pool with 5_000_000_000_000 A tokens, and a pool with 1_000_000_000 B tokens. If a user now sends 1 B token, we expect the user to get 5_000 A tokens back. When a user sends 1 A token, we expect the user to get 0 B tokens back (actually 0.0002, but since we are dealing with integers here, the remainder will be dropped). The current implementation incorrectly returns 1 B token though. Imagine further that the value of 1 B token is 5_000 USD, and the value of 1 A token is 1 USD, an attacker can now get a risk free return of around 4_999 USD (minus transaction fees) per transaction. If the attacker repeats this attack, they will be able to drain the pool. Even worse, whenever the attacker shifts the balance enough, other arbitrageurs will be able to extract value by bringing the pool back to the 5_000 to 1 ratio, allowing the attacker to repeat the attack from where they started. Here is a failing test case demonstrating the example: #[test] fn compute_swap_rounding() { let offer_pool = Uint128::from(5_000_000_000_000_u128); let ask_pool = Uint128::from(1_000_000_000_u128); let offer_amount = Uint128::from(1_u128); let commission_rate = Decimal::from_ratio(0_u128, 1_u128); let return_amount = Uint128::from(0_u128); let spread_amount = Uint128::from(0_u128); let commission_amount = Uint128::from(0_u128); assert_eq!( compute_swap(offer_pool, ask_pool, offer_amount, commission_rate), Ok((return_amount, spread_amount, commission_amount)) ); }", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Attacker can cause the generators send orphan proxy rewards function to run out of gas, locking orphan rewards in the contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "the send_orphan_proxy_rewards in In contracts/tokenomics/generator/src/contract.rs:721, USER_INFO storage map is iterated over with the LP token prex. That iteration is unbounded. An attacker can deposit many the send_orphan_proxy_rewards function to run out of gas. There is currently no way to recover from such an attack, any orphan rewards would be locked forever in the contract. to make the iteration long enough for function the small amounts The query_orphan_proxy_rewards query handler exhibits the same issue in line 880, which could potentially cause calling contracts to run out of gas.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Lack of access control on maker contracts set cong function allows anyone to set themselves as the fund receiver", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "is no access in There contracts/tokenomics/maker/src/contract.rs:225, implying that anyone can change the maker contracts cong. An attacker can for example set themselves as the fund receiver, or change the percentage of funds that goes to governance. set_config restriction function the on", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Lack of access control on generator contracts set tokens per block function allows anyone to set number of tokens per block and extract value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "is no access restriction on the set_tokens_per_block function in There contracts/tokenomics/generator/src/contract.rs:756, implying that anyone can change the tokens_per_block. An attacker can for example set a high number of tokens per block and extract value.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Lack of mass updating pools before changing alloc points leads to incorrect allocation of pending rewards and causes orphan rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "In the add function in contracts/tokenomics/generator/src/contract.rs:154, total_alloc_point gets updated, which implicitly changes the allocation for all other pools. Currently, no mass update is performed before that change. That implies that any pending rewards will be distributed according to the updated allocation, causing some rewards to stay unclaimed in the contracts. imagine there is only one pool A, which has 100 alloc_point out of a For example, total_alloc_point of also 100. Also suppose that a total of 10 tokens have been accrued so far in rewards, but they have not yet been assigned to pool A. According to these numbers, the LP holders of pool A are entitled to a total of 10 reward tokens. Imagine now that pool B gets added with an alloc_point of 300, and immediately afterwards, the rewards for pool A are calculated and allocated. At that point, pool A will only have 100 alloc_point out of 400 total_alloc_point, and LP holders will now only receive 2.5 of the reward tokens. The remaining 7.5 rewards will stay unallocated in the contract. Those tokens may be withdrawn using the SendOrphanProxyReward message. The same issue exists in the set function in 197.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Vested but not yet claimed tokens will be lost when replacing a vesting schedule for an account", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "from When updating a vesting account in the register_vesting_accounts function, previous vesting schedules may be replaced with updated ones. During that logic, any unclaimed amounts in contracts/tokenomics/vesting/src/contract.rs:136. to_receive is then used to reduce the amount that will be transferred from the owner in line 155 (or is refunded to the owner in line 168). Any vested, but not yet claimed amounts are also part of to_receive, and will hence be lost from a users point of view. to_receive schedule vesting added are the to", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Missing spread calculation of stable pair contract is misleading to users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "is not In the pair stable contracts compute_swap and compute_offer_amount functions, the spread in contracts/pair_stable/src/contract.rs:832 and 872. Without the actual spread, the max spread assertion, as well as the returned spread amount, are useless, which is misleading to users. hardcoded computed, rather but yet to A TODO exists in the code that mentions the need for spread calculation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Lack of access control on the generator contracts set allowed reward proxies function allows anyone to set proxies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "There is no access restriction on the set_allowed_reward_proxies function in contracts/tokenomics/generator/src/contract.rs:655, implying that anyone can set proxies that can be used when adding an LP token to the pool. We consider this only a minor issue since only an owner can add LP tokens to a pool. Still, an attacker can grief the owner by removing reward proxies from the contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Duplicate storage in two contracts could lead to inconsistencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-01-20 Audit Report - Astroport v1.0.pdf", "body": "i. e. asset_infos, contract_addr, liquidity_token, and pair_type, Both factory and pair contracts store the PairInfo struct which contains information about in pairs, in contracts/factory/src/state.rs:19 and contracts/pair/src/state.rs:16 contracts/pair_stable/src/state.rs:17. This duplicate storage might lead to inconsistencies between the two contract states. and", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Anyone can whitelist a new vAMM or overwrite an existing one", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "contracts/factory/src/contract.rs:45, In executing ExecuteMsg::Whitelist message, there is no check on the senders address of the transaction to ensure that it is contained in the admins list. when This may lead to three malicious behaviors:  Anyone can instantiate and whitelist a new vAMM on behalf of admins passing arbitrary parameters.  As vAMMs are indexed in the VAMM_ADDRS Map with the stringication of currency_pair as the key, anyone can overwrite an existing vAMM address mapping with a new one with arbitrary parameters.  Using the DelTranche in contracts/risk-fund/src/contract.rs:86, maliciously registered vAMMs can drain the risk fund completely.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Risk fund is not able to partially disburse creditors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/risk-fund/src/state/tranche.rs:366, when disbursing from the risk fund, the execution tries to take all possible funds from tranches in order to pay the creditor. If there aren't enough funds, it will return an error causing creditors to not get funds, not even partially based on the availability.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. saveSwapInstruction can be executed by anyone with arbitrary values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/risk-fund/src/contract.rs:73, there isnt any check on the message sender role when executing a saveSwapInstruction message. As this message is used to save and update the Astroport swap pair contract address for a specic pair, the execution of it should be restricted to admins only. In fact, a malicious actor could overwrite a legit Astroport swap pair address to a malicious one. Such a malicious pair could receive UST, emit appropriate events, but not actually return another asset. This is also possible because ReplyKind::AstroportSwapUst parses the asset information from the returned event.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. assert_admin might run out of gas and contract-specic admins might lead to inconsistency and misconguration risks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/factory/src/state/admin.rs:13, iterations over ADMIN_ADDRS may run out of gas if the vector has too many entries. Because admins cannot be removed there is currently no way to recover from this issue (see issue 11). Additionally, dierent contracts, e.g. the vAMMs, and the vault, might all contain distinct lists of admins, which the factory, introduces the risk of misconguration.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Risk fund is not aware of the fees sent from the vault", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/vamm/src/contract.rs:98, contracts/vamm/src/state/liquidation.rs:309 and 314, the vAMM is sending a message to the vault VammMsg::SendFunds. in order to send collected fees to the risk fund using The execution of this message is sending funds to the risk fund through a BankMsg::Send but its not directly triggering a mechanism to collect fees. This may lead to the contract not being aware of the collected fees and to capital ineciency of fees that are already in the risk fund but are not in tranches.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. is_vamm_addr might run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/factory/src/state/address.rs, the is_vamm_addr function has an asymptotic cost of O(n) and can make the message run out of gas depending on the length of VAMM_ADDRS and the to_check parameter position in the array. This can happen when calling QueryMsg::IsVamm from the risk funds can_disburse function. Since any user can add vAMMs (see issue 1), an attacker can exploit this vulnerability to deny the expected functionality.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Prices collected from oracle are inverted", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "During liquidation, the current price is calculated as UST/asset, in the same way as it is calculated in or contracts/vamm/src/state/market.rs:112-119. spot_price mark_price for As prices returned from Chainlink are represented as asset/UST and they use a dierent method respecting mark_price,  calculations between those two values are inconsistent.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. CollectFee message execution might run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/risk-fund/src/contract.rs:62, under certain circumstances, the execution of the CollectFee message can consume a big amount of gas and in the worst case can run out of gas. Consider as an example the scenario that the UST tranche is almost full. 1. Alice sends a CollectFee message. 2. The execution will call the collect_fee function and will ll the UST vault with UST in the msg funds. 3. Now, assume that this will not consume all the funds in the msg. The execution will call recursively collect_fee in order to ll the second tranche. 4. This will cause an interaction with Astroport, we need 2 queries to correctly create the message and then send it. 5. Astroport contract execution returns a reply. 6. Contract uses the reply to update the tranche state. 7. If there still are some funds in the msg, the execution will call another time the collect_fee function. 8. Here we can potentially loop several times until the execution will ll all the tranches or user funds sent in the message will be depleted. This issue is not unlikely to happen if the UST tranche is almost full.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. Risk fund can be drained completely due to unpriced vega risk, if highly volatile assets are listed or volatility conditions change", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "Suppose that an asset faces above normal volatility conditions and suppose that an attacker creates two large and maximum leveraged positions with two distinct wallets one short (A) one long (B) such that the expected sum of the payout of the two positions is A+B-fees, and the expected value of A+B is E(A+B) = 0. If the market volatility is large enough to assure that the collateral of one position will not be enough to cover its losses, an exploiter can create a series of payments to drain all funds from the risk fund. In layman's terms this is because the losses of the losing position are limited (since bad debt doesnt exist) and the earnings of the winning position are not capped but are paid out entirely until the risk fund is empty. Because such an attack requires sound nancial engineering and is only possible during adverse market conditions of a given asset, we do not consider this to be a major issue. However, this attack vector also highlights another important vulnerability of the protocol. Because very risky/volatile assets are covered by the same tranches of the risk fund as less risky assets, less risky positions might lose their risk fund coverage from adverse events in the more risky segment. Especially for risk averse users that use the protocol for hedging purposes, this might be an undesired property.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "10. Extensive admin permissions go against best practice", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "It is best practice to restrict admin permissions to actions that do not directly allow access to or could create a loss of user funds. Under the current architecture, admins have several such permissions: 1. 2. contracts/vamm/src/contract.rs:224, using In ExecuteAdminMsg::ForceMarketPrice, the market price can be set to arbitrary values putting users' funds at risk of liquidation. In contracts/vault/src/contract.rs:67, any address can be added as a new vAMMs address using ExecuteMsg::InsertVamm, which then can drain funds from the vault completely via VammMsg::SendFunds. 3. In contracts/vamm/src/state/config.rs:69-111, updated such that: the config can be a. Only full liquidations take place, via updates of config.liquidation_total_ratio. b. The likelihood of liquidations increases drastically, via updates of config.mark_price_divergence. c. Liquidation rewards are sent fully to the liquidating address, via updates of config.liquidation_reward_split. 4. 5. In contracts/risk-fund/src/contract.rs:86, DelTranche can be called by admins and vAMMs. It sends the funds to the sender. In contracts/risk-fund/src/contract.rs:35, it is possible to add a new admin but not possibility to remove an admin. This makes it impossible to stop malicious admins. This issue is especially problematic due to the smart contracts support of multiple admin accounts  administering these requires o-chain maintenance, which is prone to human error.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "11. bigint crate is aected by CVE-2020-35880", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "a In rust/utils/Cargo.toml:17 of the levana-common repository, bigint is specied in as https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35880 and https://rustsec.org/advisories/RUSTSEC-2020-0025.html that crate is aected by a Critical CVE with a score of 9.8. dependency. reported As The crate is not maintained anymore and contains several known bugs (including a soundness bug).", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Address provider does not validate addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/address-provider/src/contract.rs:44, ExecuteMsg::Change function handler execute_change takes a to parameter of type Addr. This may cause an unvalidated address to be stored.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. vAMMs conguration parameters are not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/vamm/src/state/config.rs:69, the update_config function which is called when initializing and updating config lacks validation on conguration parameters before saving them. As some of them are intended to be in a specic range and used in math operations, this may lead to inconsistency and execution errors caused by division by zero or assigning negative values to unsigned integers.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Admins can insert unvalidated vAMM addresses in the vault", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/vault/src/contract.rs:70, insert_vamms allows adding a new vAMM address in the VAMM_ADDRS array without validation. This may cause inconsistencies in VAMM_ADDRS.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Some possible values of vbase_liquidity can make vAMM unusable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "contracts/vamm/src/state/markets.rs:158, In using vbase_liquidity taken from the InstantiateMsg to initialize quote, base and k of the curve. init_curve is As there is no validation for vbase_liquidity, a value of this parameter equals to or less than 0 can make the vAMM unusable as this will cause:  Case vbase_liquidity == 0: quote, base and k all with zero value  Case vbase_liquidity < 0: quote and base with a negative value", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Its not possible to change the admin of the address provider contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/address-provider/src/contract.rs, the admin cw_controller is registering the contract admin address in the instantiate message. After that, its not possible for the admin to change its address.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "17. Its not possible to add or remove admins in Factory, Spot Price, vAMM and Risk Fund contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In Factory, Spot Price, vAMM and Risk Fund contracts instantiate function, the list of admins is taken from the InstantiateMsg message. the instantiation, After its not possible for admins to be added or removed. This is problematic since a compromised admin address cannot be removed or replaced with a new one.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "18. Lack of validation of AddTranche cong values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "In contracts/risk-fund/src/contract.rs:80 when executing the AddTranche message, values in the cong object are not validated. This can lead to a not working tranche registered in the contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "19. Iterations over tranches might run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-03 Audit Report - Levana Perpetual Swaps v1.0.pdf", "body": "the In contracts/risk-fund/src/state/tranche.rs:59-73, tranches might run out of gas, if too many tranches exist. As this can happen only through admin error and is recoverable, we classify this as a minor issue. iterations over", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Unauthorized swap adjustments", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "update_swap_adjustment_handler in The allows contracts/dca/src/handlers/update_swap_adjustment_handler.rs updating the swap adjustments for a specic strategy, eectively increasing or decreasing the number of tokens swapped. However, this function, which is supposed to be callable only by the contract admin, lacks authorization checks. An attacker can save arbitrary swap adjustments for any strategy, potentially grieng the protocol  for example, by setting it to a value of 0. function We would like to point out the described vulnerability was also detected by the Calculated Finance team during the audit. A x was prepared, which was then reviewed by the Oak Security team. that", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Destination address set to the DCA contract address allows disbursement of escrowed funds at any time", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "the DCA contracts In in contracts/dca/src/helpers/disbursement.rs, swapped and escrowed funds are disbursed to the provided destination addresses of a vault. Destination addresses can be used as arbitrary callbacks by specifying a custom message. get_disbursement_messages function However, the destination address is not checked to ensure it is not the DCA contract itself. This allows for the execution of messages in the context of the DCA contract as the caller of the message. For example, providing the DisburseEscrow message would lead to the disbursement of escrowed funds whenever funds are distributed, contradicting the intended behavior of disbursing escrowed funds only in specic situations, e.g., upon vault cancellation.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. PerformanceAssessmentStrategy::CompareToStandardD ca is incorrectly used for a vaults performance_assessment_strategy when choosing SwapAdjustmentStrategyParams::WeightedScale", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "a the with new vault create_vault_handler in Creating contracts/dca/src/handlers/create_vault.rs allows specifying a performance assessment and swap adjustment strategy. The swap adjustment strategy can be either set to or SwapAdjustmentStrategyParams::RiskWeightedAverage SwapAdjustmentStrategyParams::WeightedScale. The performance assessment strategy determines if a vault should continue to swap tokens based on the performance of the for SwapAdjustmentStrategyParams::RiskWeightedAverage. supposed function used vault only and be to is the However, to performance_assessment_strategy PerformanceAssessmentStrategy::CompareToStandardDca in line 120 for both swap adjustment strategies, regardless of the chosen strategy. set is As a result, the vault's escrow_level, supposed to be set to 0, is set to the escrow level in line 127. Additionally, cong value (risk_weighted_average_escrow_level) Instead of imposing swap and automation fees in the incorrect swap fees are charged. in disburse_funds_handler contracts/dca/src/handlers/disburse_funds.rs:43 and 48, performance fees are applied. As the performance fees are calculated based on the protability delta between the standard DCA and the DCA+ strategy and the vault not using the DCA+ strategy, performance fees will be inaccurately calculated. function", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Spot price usage may be exploited through oracle manipulation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "During trigger execution, the belief price is determined using the query_belief_price function in contracts/dca/src/helpers/price.rs:8-48. In line 38, the pools are queried for their spot price, which could be manipulated on low liquidity pools. This issue is exacerbated due to the lax limits on slippage described below in the issue Default slippage_tollerance is set to the maximum value and because ExecuteTrigger is permissionless. An attacker could monitor existing vaults to compile a list of targets and exploit them by executing triggers at the correct time after manipulating the oracles spot price.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. due_date of the disburse escrow task is not enforced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "Canceling a vault through the cancel_vault_handler function stores a task in storage to disburse escrowed funds. The due_date is designed to limit the execution of the task to a specic time in contracts/dca/src/handlers/cancel_vault.rs:35. calculated based on the current block frame and is time However, when disbursing escrowed funds via the disburse_escrow_handler function in contracts/dca/src/handlers/disburse_escrow.rs, the previously stored task is not loaded, and its due_date is not checked. This means that escrowed funds can be disbursed at any time by the contract admin, even when the due_date has been surpassed.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Default slippage_tollerance is set to the maximum value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "Slippage tolerance determines the maximum allowable deviation between the anticipated number of tokens a user expects to receive, such as in a token swap, and the actual number tokens received. A higher value implies a smaller amount of tokens being received, of increasing the loss of value for the user. Within the audited contracts, slippage tolerance is used in two functionalities:  Calling the trigger through the ExecuteTrigger message, which swaps tokens in accordingly the contracts/dca/src/handlers/execute_trigger.rs:207. selected strategy to  Providing the contracts/dca/src/handlers/z_provide_liquidity.rs:37. ZProvideLiquidity liquidity using message in In both instances, the user can optionally dene a custom slippage value. If none is provided, the default value will be used. the default value for slippage_tolerance (for ExecuteTrigger) and However, slippage_tollerance (for ZProvideLiquidity, please note the spelling mistake in the variable name) is Uint128::one(). Consequently, users may experience signicant losses when using these functionalities without dening a custom slippage tolerance value. In the case of pairs with low liquidity, such token swaps may be detected by MEV bots, which could sandwich the messages and thereby extract maximum value from the user. In addition, note that in both of the above-mentioned cases, the functions do not validate the optional user-provided slippage parameters. Consequently, if their value is greater than 1, there will be an underow in contracts/dca/src/helpers/swap.rs:23 and contracts/dca/src/handlers/z_provide_liquidity.rs:49, which will result in a panic.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Vault deposits can trigger recursive trigger executions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "a in via can vault deposit in Anyone deposit_handler contracts/dca/src/handlers/deposit.rs. the vault was inactive prior to the deposit, a new trigger is saved in line 96 with the target time set to the current block time, prompting an immediate execution. If the vault has destination addresses congured to deposit distributed funds directly into other vaults, this can possibly lead to recursive trigger executions. the If function the described vulnerability was also detected by the We would like to point out Calculated Finance team during the audit. A x was prepared, which was then reviewed by the Oak Security team. that", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Lack of conguration parameter validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "Most of the conguration parameters are properly validated before saving them to storage. However, the following parameters are missing validation steps both upon instantiation in contracts/dca/src/handlers/instantiate.rs:23-33 and upon update in contracts/dca/src/handlers/update_config.rs:24-34 :  A maximum size is not enforced for the fee_collectors vector. This could lead to out-of-gas errors during iteration if a big enough list of collectors is supplied.  Empty allocations in the fee_collectors vector are not rejected.  A page_limit of zero is not rejected, even though it would render some of the contracts queries ineective, as no elements would be returned. In addition, the assert_page_limit_is_valid function implements a default value of 30, therefore if the limit is below that number, any query that makes use of the default value will return an error.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Inconsistent pair identication in storage", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "When saving new pairs in contracts/dca/src/state/pairs.rs:7-9, the storage key is determined as format!(\"{}-{}\", denoms[0], denoms[1]). Therefore, both pairs A-B and B-A are saved as dierent pairs with potentially dierent routes. The find_pair function in lines 15-23 checks the existence of both options, however, it will always return the rst that matches the submitted ordering. Returning dierent unexpected inconsistencies in gas costs and swap fees. routes depending on the order of the assets in a pair will cause", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. minimum_received_amount not applied to swaps might give a false sense of security", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "through the execute_trigger_handler function in When executing a trigger contracts/dca/src/handlers/execute_trigger.rs, vault.minimum_received_amount is checked against belief_price. However, it is not instead, vault.slippage_tolerance is supplied. swap message 207-215, provided actual lines the to in Since no verication exists to guarantee that vault.slippage_tolerance aligns with the same the minimum_received_amount creates a false sense of security for users, as it is not eectively used in the nal swapping process. minimum_received_amount, usage level risk as of", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Lack of validation upon swap adjustment", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "The update_swap_adjustment_handle function allows for arbitrary values to be submitted as the swap adjustment, aecting the number of tokens to be swapped by this factor. If a large value is assigned, the swap will fail, as the resulting amount designated for swapping will exceed the available funds.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Lack of validation in liquidity provision cache", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "z_provide_liquidity_handler in The function not contracts/dca/src/handlers/z_provide_liquidity.rs:28-35 validate the saving provider_address PROVIDE_LIQUIDITY_CACHE storage. Providing an incorrect address will cause the subsequent reply handlers to fail, wasting computational resources, or rendering the locking useless if a duration of zero is provided. does to it user-submitted before the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Lack of validation of custom swap fee denom", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "create_custom_swap_fee_handler The function in not contracts/dca/src/handlers/create_custom_swap_fee.rs:9-23 validate that the supplied denom actually exists. In case of a typo, the admin might not be aware of the error, and since the expected denom will not be found, no fee will be applied to the desired operations. does", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Misleading lack of feedback upon fee removal", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "remove_custom_swap_fee_handler in function The not contracts/dca/src/handlers/remove_custom_swap_fee.rs:7-19 validate that the supplied denom is part of the current custom fees. Since no feedback is returned when removing a non-existing element from the storage, the admin would not be aware of the error, for example, in case of a typo. Therefore undesired fees will still be charged afterward. does", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. New vaults may be inactivated right after creation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "create_vault_handler in The contracts/dca/src/handlers/create_vault.rs does not assert the initial token deposit info.funds[0].amount is sucient to guarantee a successful swap of the desired number of tokens, i.e. swap_amount. As a consequence, such a vault would be inactive and unable to perform token swaps due to insucient funds. function that", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Lack of role-based access controls for the pausing mechanism", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "The codebase implements a pausing mechanism, which is in line with best practices. However, all of the administrative functions of the contract are centralized in the admin role, which goes against the principle of least privilege. Segregating the pauser role has the additional benet of swifter reactions in case of need when assigned to an EOA compared to the admin that might be managed by a multisig or a governance contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Swap pair route can have duplicate entries", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "create_pair_handler The in contracts/dca/src/handlers/create_pair.rs allows the contract admin to create and update swap pairs. The pair.route eld is used to specify the route (i.e., pool ids) that should be used for swapping tokens. While there are various checks in place to ensure that the route is not empty and the route matches the base_denom and quote_denom, there is no check to ensure that the route does not contain duplicate entries. function A swap pair with duplicate route entries will increase the total swap fees and gas costs when swapping tokens.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Vault label length is not validated to be less than 100 characters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "Users can specify a label when creating a new vault via the create_vault_handler function in contracts/dca/src/handlers/create_vault.rs. The label is stored in the vault.label eld and is solely used for o-chain display purposes. While updating a vaults in contracts/dca/src/handlers/update_vault.rs is restricted to 100 characters, there is no such restriction when creating a new vault. update_vault_label_handler function label the via In addition, empty labels are allowed which do not serve the intended asset identication purpose.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Inability to update important vault conguration parameters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Calculated Finance/2023-05-23 Audit Report - Calculated Finance v1.1.pdf", "body": "A vault owner can currently update the vault label via the update_vault function in other contracts/dca/src/handlers/update_vault.rs. However, important vault conguration parameters that cannot be updated once the vault is created. This includes the swap slippage tolerance (slippage_tolerance), the minimum receive amount (minimum_receive_amount), and the destination addresses (destinations) for fund disbursement. there are The inability to update these parameters can be problematic in certain situations. For instance, if the vault owner wants to increase the slippage tolerance to ensure that the vault is able to swap tokens even when the market is volatile or liquidity is low, or if the initially provided slippage value was too conservative. In such cases, they would have to cancel the vault and create a new one.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Duplicate member addresses inate the total weight value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "the contract instantiation in phase During contracts/cw4-voting/src/contract.rs:32-37, the msg.initial_members vector that contains the Member struct address and weight is not validated to make sure the If a duplicate member address is member address is unique across the whole contract. provided, the associated address and weight would be overwritten by the USER_WEIGHTS storage state, as seen in line 35. However, the total weight value in line 36 would still include the nonexisting member weight. This would impact voting outcomes. A test case demonstrating the above scenario can be found in appendix 1.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Duplicate item name causes ghost contracts to be instantiated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "In contracts/cw-core/src/contract.rs:83, the msg.initial_items parameter that contains the InitialItem vector is not validated to have unique item names. Having two or more items with the same name would cause them to be instantiated as ghost contracts because eventually, the item name with the highest reply id would be used, as seen in line 746. As a result, this causes ineciencies in the contract.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Lack of delay when executing proposals makes contracts prone to governance attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "In contracts/cw-proposal-single/src/contract.rs:217, there are no time delays when executing passed proposals. An attacker with enough capital can potentially stake many tokens to gain high voting power, create a malicious proposal and then vote for it. Since proposals can pass early as long as the voting threshold is reached (see contracts/cw-proposal-single/src/proposal.rs:112-114) a passed malicious proposal without giving the community enough time to discuss and block the governance attack. As a result, the attacker's governance attack would succeed, causing potentially catastrophic damage to the protocol. This is especially problematic if the contracts hold non-native tokens, which may have a higher value than the cost of the attack. execute to", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Consider checking whether the item key exists before removing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "In contracts/cw-core/src/contract.rs:420-434, any provided key as an argument will be removed from the ITEMS storage state as seen in line 430. Since the remove storage function will not dierentiate whether the key exists or not, it is possible to remove a key that never existed in the storage.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Admin withdrawals will aect the reward distribution", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "execute_withdraw The in contracts/stake-cw20-reward-distributor/src/contract.rs:185 allows the the contract without an option for a partial admin to withdraw the entire balance of withdrawal. function After the admin withdraws funds using a Withdraw message, the contract will have empty funds, which causes the minimum comparison in line 156 to result in a zero amount. This implies that the Distribute message would pay zero rewards to the staking address for the whole staked duration. The staking address would need to wait some time for the pending rewards to recover to the intended value to receive another set of staking rewards. We consider this to be a minor issue since only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Reward duration should be validated as non-zero value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "contracts/stake-cw20-external-rewards/src/contract.rs:65, In msg.reward_duration represents the reward duration value which is used to calculate the reward rate. If the reward duration value provided is 0, it would cause a division by zero error in line 174 during the execute_fund functionality, causing the contract to be unable to be funded. We consider this to be a minor issue since only the contract owner can cause it. Even if it happens, the problem can be resolved by updating the reward duration to a non-zero value via the UpdateRewardDuration message.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Maximum number of items is not sucient to prevent out of gas error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "MAX_ITEM_INSTANTIATIONS_ON_INSTANTIATE The in contracts/cw-core/src/contract.rs:84 is not sucient as it will allow for such a large number of items that the proceeding instantiation loop will run out of gas well before the limit is met. The maximum should be set to a more conservative value rather than u64::MAX - 100. validation", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. execute_pause does not enforce maximum pause duration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "The execute_pause function in contracts/cw-core/src/contract.rs:173 does not enforce a maximum pause duration. The value of pause_duration is added to the current block time and then saved to PAUSED with no checks or validation. This is problematic because if the value is accidentally set to a very high value, it will eectively render the contract useless, without a way to recover. Another potential scenario is that the duration is sent as a Height rather than a Time, which may result in the contract being paused for longer than anticipated.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Incomplete threshold validation in staked balance voting contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "In contracts/cw20-staked-balance-voting/src/contract.rs:84, ActiveThreshold::Percentage is only validated to be smaller than 100%, but not validated to be larger than 0%. Zero values may cause undesired voting outcomes.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Admin rights go against best practices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "It is best practice to restrict admin permissions to actions that do not directly allow access to or could create a loss of user funds. In contracts/cw-core/src/contract.rs:194, the contract admin can run any message, introducing a centralization risk and a single point of failure if the admin keys are lost or compromised. In other reports, centralization risks have been agged with higher severity. In this case, we interpret the admin as a parent DAO which mitigates the centralization risk.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Voting module design is prone to conguration risk", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "The core contract and the voting module are closely interlinked. Because the voting module has only one interface (i.e. to the core contract), updating the voting module introduces an additional point of failure and a conguration risk (e.g. that a proposal module is congured as the voting module) without many benets that come from the modular design. Because this issue is based on a design choice the severity is informational.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Contracts should implement a two-step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Additional funds sent to the contract are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "In contracts/stake-cw20-external-rewards/src/contract.rs:143-153, a check is performed that ensures that in the transaction there is a Coin with the expected denom eld. This validation does not ensure that no other native tokens are sent though, and any additional native tokens are not returned to the user, so they will be stuck in the contract forever.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Voting thresholds can be set to unusual values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2022-06-22 Audit Report - DAO DAO v1.0.pdf", "body": "packages/voting/src/threshold.rs:73-80, In set PercentageThreshold such that a majority can be achieved under very unusual conditions (e.g. if 1% are in favor and 99% percent are against a proposal). While this allows possible to is it for innovative forms of governance, it is prone to user error which may lead to devastating consequences.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. UpdateExchangeRate message leads to delegation of incorrect amount of funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "The execute_update_exchange_rate function tries to delegate more than it should, as it doesnt take into account the protocol_fee that needs to be accrued in case it is not zero. This causes ExecuteMsg::UpdateExchangeRate to error if the contract balance is less than the amount to be delegated plus the protocol fee. variable claimed_rewards in The the contracts/prism_hub/src/autho_compounding.rs:87, in the protocol_fee the message contracts/prism_hub/src/autho_compounding.rs:66. Therefore, moving fee funds will be executed rst and then the delegation message will try to delegate an amount bigger than the actual balance, as protocol_fee has already been transferred. used includes fee_collector transferred incorrectly previously since it that to is is A proof of concept test case for this security issue can be found at Appendix 1.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. State update not stored", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "The execute_update_global function uses the incorrect instance of the loaded STATE to update the principle_balance_before_exchange_update element of the struct. it could Although at dramatically aect future features as an outdated value would result in incorrect results when used as part of calculations. the code base does not make use of this element, the moment of changing Instead in contracts/prism_hub/src/contract.rs:213, the code changes the value that is loaded Consequently, principle_balance_before_exchange_update will never be updated. last_state stored. never value initial state but the the of in Please note that we consider this issue to be a minor issue since the aected variable is not used. In a future release, this issue might have critical consequences.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Custom access control implementation is error-prone and decreases maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "The Hub contract implements custom access controls, which introduce a few issues: The transfer of the creator role to a dierent account is implemented in a one-step fashion without conrmation from the receiving party. This could potentially cause a loss of access to the role in case a mistake is made during the role transfer. In addition, the Access Control logic that enforces these restrictions is duplicated across the handlers of each function, which negatively impacts the code's readability and maintainability, as it is error-prone.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Lack of conguration parameter validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "The Hub contract lacks validation steps on most conguration parameters upon instantiation or update. Although the values are supplied by the owner, the well-functioning of the protocol if an unexpected value were to be assigned by mistake or if a rate parameter were assigned a value outside of the 0 to 1 range. For example, a fee rate of 1 this could aect will not make the protocol usable, while a fee rate greater than 1 will lead to the protocol losing value. The following lines are aected:  contracts/prism_hub/src/config.rs:35-40  contracts/prism_hub/src/contract.rs:70-75", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. uluna coin denom is used instead of underlying_coin_denom", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "The Hub contract denes in the Parameters struct the underlying_coin_denom eld. This parameter represents the denom of the coin that is delegated by the contract to validators. However in lines:  contracts/prism_hub/src/autho_compounding.rs:68  contracts/prism_hub/src/autho_compounding.rs:89  contracts/prism_hub/src/contract.rs:44 instead of using the correct denom saved in the store, uluna is hardcoded. This implies that the contract will work on chains with a uluna denom, such as Terra.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Pseudorandom validator selection can be predicted and gamed by validators", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "In order to fairly select a validator during auto compounding, unbonding, and validator delisting, the protocol is using XorShiftRng with the current block height as a seed to generate a pseudo-random index. This calculation at a certain block height is easy to predict. Validators could use this information to try to execute a specic transaction at a specic block height in order to be selected, in case of auto compounding, or not be selected in case of unbonding and validator delisting.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. WithdrawUnbonded transaction requires the execution of multiple unbounded loops", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "In execute_withdraw_unbonded function running multiple unbounded loops. contracts/prism_hub/src/unbond.rs:146, the handles WithdrawUnbonded messages In line 168 the process_withdraw_rate function executes two unbounded loops over all not processed yet UnbondHistory. In line 170 the get_finished_amount function executes an unbounded loop over the user unbounding waitlist. In line 180 and 181 the get_unbond_batches and remove_unbond_wait_list functions execute an unbounded loop over the user unbonding waitlist. This implies that under specic conditions, for example if the user has a lot of pending batches to unbond in the whitelist or if the user is another contract that does a big number of operations, the execution can run out of gas and the user would not be able to withdraw their funds. We consider this issue to only be of minor severity since it is unlikely to occur in the short to mid-term.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Updating token_contract will aect previously bonded funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "The contracts/prism_hub/src/config.rs:74. update admin can the token_contract parameter in As the entire protocol state relies on information that depends on that parameter or queries using that parameter, any update will aect users that have their funds previously bonded by not allowing them to unbond. We classify this issue as minor since only the owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Outdated and unmaintained dependencies in use", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "The Hub contract uses outdated versions of multiple libraries, version that publicly known vulnerabilities CVE-2021-32810 and CVE-2020-35880. including a cosmwasm-vm In addition, two libraries were aected by lacks some important upgrades. Although bigint is not maintained and therefore there is no x available, crossbeam-deque aected by CVE-2021-32810 has an ocial patch ready. Further details can be found in Appendix 2.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Custom functionality for checking additional funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "The Hub contract makes use of custom functionality to check for additional funds being sent in and contracts/prism_hub/src/bond.rs:35-47 contracts/prism_hub/src/contract.rs:39-45. Although not a security issue, well-known community-driven libraries are recommended for this kind of feature.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Canonical address transformations are inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "While previously recommended as a best practice, usage of canonical addresses for storage is no longer encouraged. The background is that canonical addresses are no longer stored in a canonical format, so the transformation just adds overhead without much benet. Additionally, the codebase is more complicated with address transformations.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Missing tax deductions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero tax rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See this discussion for more details about the tax rate changes on Terra.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Typographical errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "In contracts/prism_hub/src/contract.rs:51 and other places, the wrongly typed porotcol_fee_collector occurs, which should be protocol_fee_collector. The same misspelling will also introduce a cascading eect when other protocols query the config. In addition, in contracts/prism_hub/src/config.rs:139, the conguration is loaded for a function named token, which is potentially another typo.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Duplicated code can negatively impact maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "read_validators in The contracts/prism_hub/src/state.rs:176 and 20 are performing the same logic. Additionally, all validators are valid in the Prism Auto Compounding cAsset protocol. Code duplication increases code complexity and can negatively impact maintainability. read_valid_validators functions and", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Unused code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "Multiple instances of unused code exist in the codebase, including variables and functions that are only used within tests, but not in the actual contract. Unused code aects the overall code readability, and might confuse users since it is suggestive of any features that are currently not being implemented. The following list includes the aected lines:  contracts/prism_hub/src/state.rs:10, 53-63  contracts/prism_hub/src/contract.rs:36, 37, 58  contracts/prism_hub/src/hub.rs:160, 163  The UnbondHistory struct includes elements that are not in use. batch_id is not used as it is the actual key in the history storage instance. Similarly, applied_exchange_rate and withdraw_rate seem to reect the same value here, however, applied_exchange_rate is only used inside tests and not the actual contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Comment contradicts implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "The Hub contract includes comments describing the required privileges for each function for assigned execution message. comment handler The an as of a execute_register_validator in contracts/prism_hub/src/config.rs:96 states that the functionality is callable only by the creator. However, this diers from the implementation as the Hub contract itself is whitelisted too, given that this message is sent by the contract upon instantiation.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Lack of address validation upon querying", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "The Hub contract doesnt validate the input address of the query_unbond_requests function. Although not being a security risk, it may lead to a lowered user experience if incomplete or invalid addresses are provided and no address validation error is returned.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Ineciency in querying a specic validator", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "In contract/prism_hub/src/config.rs:112, the execution is querying the list of all validators in order to check if the provided one is part of the list. Instead of executing query_all_validators and then iterating through the list in order to nd the required one, which has a O(n) complexity, query_validator could be used to directly query the required one.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Lack of pausing mechanism", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Prism/2022-11-04 Audit Report - Prism Auto Compounding cAsset v1.0.pdf", "body": "Currently when the smart contract is deployed, if there is any catastrophic security loophole being discovered there is no quick way to limit its functionality and restrict the potential impact of the vulnerability while the team carries out an investigation/working on an upgrade.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Autocompounder is vulnerable to share ination attack", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "compute_mint_amount The in contracts/autocompounder/src/handlers/reply.rs:130 is vulnerable to a share ination attack. A share ination attack represents a scenario where a malicious actor articially inates the supply of tokens, potentially manipulating the token's value and diluting other holders' shares. function Currently, the function computes the mint amount by using integer division. Due to the nature of integer division, results are always oored. This allows an attacker to inate their current shares while stealing funds from unsuspecting users. The compute_mint_amount is susceptible to this attack because the denominator of the integer division staked_lp can be manipulated for Astroport, representing the total staked amount of the proxy address. An example attack scenario: 1. The attacker makes the rst deposit of 1 token and thus receives one share", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. Finally, the computed lp_tokens_withdraw_amount value will be evaluated to 7501 ((1/2) * 15002), earning the attacker an extra 2499 (7501-5002) liquidity pool tokens. redeems attacker shares. their The Recommendation We recommend enforcing a minimum amount that needs to be met in the rst deposit. This will greatly increase the cost of orchestrating a share ination attack. Note that it is common practice to mint dead shares to the protocol to increase the cost of the attack further. For more details, please see Astroports implementation. Status: Resolved 2. Attackers can cause batch unbondings to fail, preventing users from unstaking liquidity pool tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "6. Finally, the computed lp_tokens_withdraw_amount value will be evaluated to 7501 ((1/2) * 15002), earning the attacker an extra 2499 (7501-5002) liquidity pool tokens. redeems attacker shares. their The Recommendation We recommend enforcing a minimum amount that needs to be met in the rst deposit. This will greatly increase the cost of orchestrating a share ination attack. Note that it is common practice to mint dead shares to the protocol to increase the cost of the attack further. For more details, please see Astroports implementation. Status: Resolved 2. Attackers can cause batch unbondings to fail, preventing users from unstaking liquidity pool tokens", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Unbonding cooldowns are not respected", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "In the contracts/autocompounder/src/handlers/execute.rs:471-488, check_unbonding_cooldown function attempts to verify the last unbonding time has the LATEST_UNBONDING exceeded the minimum unbonding cooldown time. However, storage state is never stored anywhere in the codebase. Consequently, batch unbondings can be repeatedly performed without respecting the congured cooldown period. This issue also causes the query_latest_unbonding function to fail when loading LATEST_UNBONDING from the storage. We classify this issue as major because it aects the correct functioning of the system.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Compounding will fail for zero performance fees", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "In contracts/autocompounder/src/handlers/reply.rs:190-200, the fees are deducted from rewards and sent to the commission address. However, the swap will fail if the performance fee is zero, preventing the auto-compounding from working successfully. Please see the test_zero_performance_fees test case to reproduce the issue. We classify this issue as minor because the manager contract can recover to a correct state by updating the performance fees.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Hard-coded slippage value makes deposits susceptible to sandwich attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "deposit in The a contracts/autocompounder/src/handlers/execute.rs:143 hard-coded max spread value of 5%. Depending on the pair that liquidity is being provided for, this may be a too large value, making the deposit functionality vulnerable to a sandwich attack. species function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Non-updatable conguration can not reect changes in staking contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "the In contracts/autocompounder/src/handlers/instantiate.rs:139-148, conguration and unbonding_period directly from the staking contract. However, there is no entry point to update this data. min_unbonding_cooldown dened taking both as is In case the aected parameters are modied in the staking contract, this will cause inconsistencies in the unbonding mechanism. The underlying messages directed to the staking contract could fail without the users being able to understand why, as the reported information will not reect the new limits.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Minting of zero vault tokens possible", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "The autocompounder contract allows for the minting of zero shares upon depositing in some edge cases. This is possible as CW20 tokens now allow the minting of zero tokens, and the compute_mint_amount function does not perform further validation on the returned in amount contracts/autocompounder/src/handlers/reply.rs:135-143. minted shares be to of Users depositing small amounts of funds could receive zero shares in exchange, eectively losing access to those funds. In addition, this issue causes the Autocompounder is vulnerable to share ination attack to be even more lucrative for an attacker.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Unused variable in codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "In contracts/autocompounder/src/handlers/execute.rs:98, _staking_address variable is declared, but is not used. deposit the function in the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Lack of validation upon deposit lead to ineciencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "The deposit function performs insucient validation on funds to be forwarded for liquidity provision in contracts/autocompounder/src/handlers/execute.rs:111-121. As the funds variable is not explicitly checked to contain pool assets only, the contract would try to provide liquidity with potentially erroneous assets in lines 140-144. This will cause the execution of all the code in the function to end up erroring, consuming an unnecessary amount of gas.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Remove TODO comments", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "The codebase includes multiple TODO comments. It is best practice to remove all pending TODO items before releasing code to production.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Unused commented code in codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "In contracts/autocompounder/src/handlers/instantiate.rs:78-82, there is unused commented code. It is best practice to remove all unused commented code blocks before code is released toproduction.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Misleading variable name when withdrawing liquidity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "In contracts/autocompounder/src/handlers/execute.rs:267 and 382, the swap_msg variable is set when calling withdraw_liquidity on the specic DEX. The swap_msg variable name is misleading, swaps are performed later on the DEX.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. calculate_withdrawals sets expiration to current block height which may become problematic if the function is exposed in a future upgrade", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "the contracts/autocompounder/src/handlers/execute.rs:411-414, In unbonding timestamp defaults to the current block height if config.unbonding_period is None. This is not a security concern in the current implementation, since the calculate_withdrawals function can only be called from the batch_unbond function, which ensures the unbonding period is Some(_), as seen in lines 161-163. If future code was introduced though that allows calling the calculate_withdrawals function without going through the batch_unbond functions, it might cause withdrawals to be unlocked immediately in the next block.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Users cannot query fees through smart queries", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "In contracts/autocompounder/src/handlers/query.rs:16-42, no exposed queries return the fee congurations. Consequently, users cannot query the protocol's congured performance, deposit, and withdrawal fees.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Panicking macros and debugging code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "The autocompounder contract uses Rust panicking macros to handle undesired situations in contracts/autocompounder/src/handlers/instantiate.rs:96 and 130. Panicking macros do not report meaningful error messages for users to understand what went wrong. In addition, an eprintln! statement which is typically used for debugging purposes can be found in contracts/autocompounder/src/handlers/execute.rs:357-360.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "20. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/autocompounder/Cargo.toml  packages/forty-two/Cargo.toml  packages/forty-two-boot/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "21. Additional funds sent to the contract are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/FortyTwo/2023-06-05 Audit Report - FortyTwo v1.1.pdf", "body": "The deposit function does not check whether additional native tokens are sent along the in contracts/autocompounder/src/handlers/execute.rs:89-157. message Any additional native tokens are not returned to the user, so they will be stuck in the contract forever. While blockchains generally do not protect users from sending funds to the wrong accounts, reverting extra funds increases the user experience.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "2. The on-chain entropy is generated by querying Terra for the swap result between LUNA and TerraUSD for the amount of block height plus the block time in seconds. Since the swap amount will increase monotonically by a relatively xed amount, and the exchange rate between LUNA and TerraUSD is expected to uctuate by a few percentage points only per block, the resulting value will have little entropy. Recommendation We recommend relying on a more robust source of randomness. Status: Acknowledged The Ink team states in their documentation that it plans to move to an Oracles VRF as the source of randomness in a future version. 10. Updating Anchor aUST and market contract addresses in Anchor strategy could lead to incorrect states", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Ink Protocol/2021-09-15 Ink - Audit Report.pdf", "body": "2. The on-chain entropy is generated by querying Terra for the swap result between LUNA and TerraUSD for the amount of block height plus the block time in seconds. Since the swap amount will increase monotonically by a relatively xed amount, and the exchange rate between LUNA and TerraUSD is expected to uctuate by a few percentage points only per block, the resulting value will have little entropy. Recommendation We recommend relying on a more robust source of randomness. Status: Acknowledged The Ink team states in their documentation that it plans to move to an Oracles VRF as the source of randomness in a future version. 10. Updating Anchor aUST and market contract addresses in Anchor strategy could lead to incorrect states", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Users can steal all LP tokens from the Apollo static strategy", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf", "body": "the apollo-static strategy Since in contracts/strategies/apollo-static/src/strategy.rs:38 will query the LP token balance of the contract including all previous deposits by other users. All of these deposits will be assigned to the caller, and the user can then extract all that value by immediately withdrawing/zapping out. LP tokens, the query simply holds", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Registering fees in the factory contract does not update the strategys extension reward index", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf", "body": "the handle_register_fee in In the contracts/apollo-factory/src/contract.rs:586, strategys EXTENSION_TOTAL_COLLECTED_FEES extension_reward_index eld is not adjusted. That leads to an inconsistent state. Additionally, update_strategy is called, even though there were no changes to the strategy. updated, function are but the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Users are unable to collect rewards after withdrawing/zapping out of strategy", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf", "body": "In contracts/apollo-factory/src/contract.rs:816, strategies are skipped if a user has no active deposits in a strategy. Users might have withdrawn/zapped out of a strategy, and hence have zero shares, but they might not have collected rewards yet. Such users are unable to collect the condition described above. the rewards from the strategies because of", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Strategies that start with paused rewards can never receive any rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf", "body": "The rewards_paused eld cannot be updated in the handle_update_strategy function in contracts/apollo-factory/src/contract.rs:516. That means that a strategy that started without rewards can never receive any rewards.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Current block height not used in reward calculation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf", "body": "the reward In packages/apollo-protocol/src/vault/vaults/anchor.rs:119, info from Anchor deposits is queried. That query uses a block_height of None, which will cause Anchor to return the latest stored values, rather than recalculating them at the current block height.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. APR calculation might panic if staked liquidity value is zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf", "body": "When contracts/strategies/apollo-static/src/strategy.rs:493, might panic when staked_liquidity_value is 0. calculating APR the in contract the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Price queries do not ensure that price base is not outdated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf", "body": "In multiple price queries from the oracle contract, the time since last_updated_quote is asserted to be greater than the strategys price_age_limit. However, the time since last_updated_base is not asserted  which might lead to usage of outdated prices. Instances of that issue are found in:  contracts/strategies/apollo-static/src/strategy.rs:433  contracts/strategies/apollo-static/src/strategy.rs:467  contracts/strategies/apollo-static/src/strategy.rs:481  packages/apollo-protocol/src/strategy/strategies/autocompound /reuse.rs:409  packages/apollo-protocol/src/strategy/strategies/autocompound /reuse.rs:465  packages/apollo-protocol/src/strategy/strategies/autocompound /reuse.rs:479  packages/apollo-protocol/src/strategy/strategies/autocompound /reuse.rs:423", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Queried reward and LP token prices in Apollo autocompound strategy are not checked to not be outdated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf", "body": "the querying When in packages/apollo-protocol/src/strategy/strategies/autocompound/stra tegy.rs:309-325 and in 369-385, a check should be added to ensure these prices are not outdated. reward_token_price lp_token_price and", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Anchor reward rate calculation does not account for overlaps in distribution schedule", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2022-03-17 Audit Report - Apollo v1.0.pdf", "body": "rate reward in The not packages/apollo-protocol/src/vault/vaults/anchor.rs:147 account for overlaps in the distribution schedule coming from the anchor cong. The Anchor factory does allow overlaps. In the event of an overlap, the reward rate would be o. calculation rewards Anchor does for", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Users will receive incorrect amount of LP tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "execute_balancing_provide_liquidity The in osmosis-liquidity-helper/src/contract.rs:78 allows users to provide either a single asset or a pair of assets to a pool. In the case that a user provides multiple assets, the contract rst performs a double-sided liquidity provision followed by a single-sided provision for any left over assets. function the LP tokens minted during the double sided liquidity provision are never However, transferred to the recipient. The LP tokens received from the initial liquidity provision that will be returned in response to the message in line 122 will never get recorded because the ReturnLpTokens callback was not called with the contracts initial lp_token_balance. The result will be that the caller will only receive LP tokens for the second liquidity provision.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Balanced liquidity provision into constant product pool will fail", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "When a user performs a balanced liquidity provision into a constant product pool in astroport-liquidity-helper/src/contract.rs:90, the contract rst swaps any tokens to ensure the ratio remains constant and then supplies the tokens into the pool. Subsequently, the contract returns the received LP tokens to the recipient using the callback function ReturnLpTokens. During execution of each message the contract will transfer the recently minted LP tokens from itself in astroport-liquidity-helper/src/contract.rs:185-190 and then again in 250-255. the callback function is called twice, rst to the recipient. However, The ReturnLpTokens callback that is dened in lines 185-190 will be executed before the liquidity is provisioned and the contract's balance changes. This will cause return_amount in line 274 to be 0. When the function attempts to transfer a zero amount the CW20 transfer return an error and revert function will execute_balancing_provide_liquidity function. the transaction. This will eectively block the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. No validation of min_out for double sided liquidity provision", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "When providing liquidity in the execute_balancing_provide_liquidity function in osmosis-liquidity-helper/src/contract.rs:78, users are able to specify the min_out value which denes the minimum amount of LP tokens they want to receive when providing liquidity. In the case that a user provides multiple assets to a pool, the amount of LP tokens minted is never checked to ensure it is greater than the value min_out. This means users may in fact receive fewer LP tokens than expected.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Insucient validation of swap paths", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "In function update_path in cw-dex-router/src/contract.rs:231-249, the contract admin is able to add swap paths to enable the liquidation of tokens that both do and do not share a direct pool. Currently, the contract validates that the rst and last assets match the oer and ask assets. In the case that there are swap operations performed there may be a situation where intermediary assets do not match. This would cause the failure of any execution of the function basket_liquidate. We consider this a minor issue as the admin controls the addition of swap paths.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Insucient validation of vault conguration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "When instantiating and updating the cong of a vault, the function check is called in which apollo-vaults/packages/apollo-vault/src/state.rs87-110 than it insuciently Decimal::one(). the performance_fee to ensure that validates less is Specifying a performance fee of greater than Decimal::one() would cause an overow in apollo-vaults/packages/apollo-vault/src/state.rs:94. Additionally, reward_liquidation_target is not enforced to be one of the assets in the pool as specied in lines 32-34, which could potentially cause inconsistencies in the overall behavior of the vault.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Basket liquidation fails if no path is found for oer asset", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "the basket_liquidate function In cw-dex-router/src/contract.rs:251-305, swaps all oer assets into a single receive asset. The swap paths that are used to exchange the oer for the receive asset are dened by the contract admin. In the case that one of the oer assets does not have a path set to the receive asset the throw an error in cw-dex-router/src/contract.rs:276. This would contract will prevent liquidation and the original calling function, execute_compound found in apollo-vault/src/execute_compound.rs, but also the primary function of the relevant vault. the execution of both the basket We consider this only a minor issue as the swap paths are dened by the contract admin.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Lack of Osmosis Vault parameter validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "The osmosis-vault contract from Apollo vaults instantiate function does not validate the submitted msg.pool_id before storing it. This might cause two dierent vaults to coexist with the same ID but dierent base and vault tokens, potentially confusing users. it In addition, is recommended to validate msg.lockup_duration to be within the expected range to avoid creating either a zero or an arbitrarily large lockup duration by mistake.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Use of magic numbers throughout the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "Throughout the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. Instances of magic numbers are listed below:  astroport-liquidity-helper/src/contract.rs:62  astroport-liquidity-helper/src/contract.rs:95  cw-dex/src/implementations/astroport/helpers:185-186", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Additional funds sent to the contract are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Apollo/2023-01-17 Audit Report - Apollo DAO 3 v1.0.pdf", "body": "In apollo-vaults/packages/apollo-vault/src/execute_staking.rs:46, a check is performed that ensures that in the transaction the desired native assets have been received. This validation does not ensure that no other native tokens are sent though, and any additional native tokens are not returned to the user, so they will be stuck in the contract forever.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Truncated CW20 token transfer amount for CW20 tokens with more than 8 decimals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "The Wormhole token bridge contract truncates CW20 token amounts to 8 decimals. implies that a small amount of tokens (the so-called dust) stays in the This token-translator contract and is not transferred to the Wormhole token bridge. The user will hence receive fewer bridged CW20 tokens than initially transferred tokenfactory tokens.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Lack of conguration parameter validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "instantiation, During contract are WORMHOLE_CONTRACT token_bridge_contract InstantiateMsg message. the storage variables TOKEN_BRIDGE_CONTRACT and the initialized the src/contract.rs:33-39 with in values wormhole_contract supplied in and However, the provided values are missing address validation. Invalid strings would lead to a non-functioning contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Contracts are not compliant with the CW2 Migration specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "The token-translator contract does not adhere to the CW2 Migration specication standard. This may lead to unexpected problems during contract migration and code version handling.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Redundant check on the submessage reply", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "the submessage has been successful by The token-translator validates whether checking the replys result this check is unnecessary as the submessage is declared as SubMsg::reply_on_success. For SubMsg::reply_on_success submessages, the reply handler is only called upon the success of the submessage, making it impossible that the result is an Err variant. in src/contract.rs:94-97. However, Although not a security issue, unnecessary code can negatively impact maintainability and slightly increase gas consumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Unused WORMHOLE_CONTRACT storage variable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "During contract instantiation, the WORMHOLE_CONTRACT storage variable is initialized with the wormhole_contract value in src/contract.rs:37-39, which is supplied within the InstantiateMsg message. However, the value of WORMHOLE_CONTRACT is never read from storage or used in any other way.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Missing attributes on some message handlers responses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "informative attributes when The token-translator contract does not make use of returning a response in the convert_and_transfer, convert_bank_to_cw20, and convert_cw20_to_bank message handlers. This could negatively impact o-chain services that try to monitor the state of the protocol. In addition, although the contract does not save any owner eld in the storage. the instantiation function response includes a misleading owner attribute,", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Unhandled zero-amount transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Wormhole/2023-07-06 Audit Report - Wormhole Token Translator v1.1.pdf", "body": "Using the ConvertAndTransfer and ConvertBankToCw20 messages, a user can send tokens to the contract. They are later validated in the context of whether more than one type of coin has been sent, but there is no validation enforcing that the transferred amount is greater than zero. As a consequence, the functions may unnecessarily perform operations, ending up with a panic, and Cw20ExecuteMsg::Transfer do not support transferring zero-amounts. TokenBridgeExecuteMsg::InitiateTransfer because both This leads to unnecessary gas consumption. Also, panics degrade the user experience since they do not provide any context why an error has occurred and how it can be resolved.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "2. Unsuccessful MsgTransfer message could drain the relayers funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Persistence/2023-02-17 Audit Report - pSTAKE Native v1.0.pdf", "body": "In x/lscosmos/keeper/handshake.go:488-500, the function responsible for handling Timeout and Acknowledgement_Error responses (see lines 196 and 258) originated by MsgTransfer messages try to resend them through GenerateAndExecuteICATx. In a scenario where a transaction always has unsuccessful responses, the execution will end up performing a loop between the controller and controlled chains with the result of draining the relayers funds. For example, this could happen if the controlled chain is halted or is performing an update. Additionally, an attacker may trigger multiple such transfers to congest and slow down the chain. As a result, users will nd their transactions taking more time to process.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Liquidated and excess funds are stuck in the liquidation lterer contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "contracts/liquidation-filterer/src/contract.rs:84, the In execute_liquidation function does not properly handle collateral transfer after a liquidation attempt. We outline three possible scenarios that causes funds to be stuck in the contract: Firstly, the liquidation logic forces the caller to provide funds in line 99, but there is a possibility that the user to liquidate is not liquidatable. In this case, the provided funds are not refunded. the red bank refunds excess funds to the liquidation lterer contract (see Secondly, contracts/red-bank/src/execute.rs:1083-1088). There is no way to withdraw these excess funds though. Lastly, the red bank contract will transfer Mars tokens to the contract after a successful liquidation attempt. There is no logic in the contract that allows a withdrawal in return for the liquidated collateral. As a result, the liquidated collaterals are inaccessible.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Liquidation lterer contract cannot process multiple liquidations eciently", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "contracts/liquidation-filterer/src/contract.rs:114, In two of Liquidation messages are constructed, debt_denom or user_address, the transaction will return an error. when them have the same least if at The former happens because the sub-messages reuse the total funds with the same denom. Since the rst message already includes all funds, the contract will not have enough funds to process the subsequent liquidation messages with the same denom. The latter fails because the contract would send duplicate liquidation messages to the red bank contract, and since liquidating a user twice is not possible, the transaction would fail too. Additionally, the liquidation lterer contract does not tolerate failures. The whole liquidation execution would fail if any liquidation attempts were frontrunned by another liquidator. As a result, undercollateralized positions might not be liquidated eciently during high volatility and activity in the market.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Smart contracts holding tokens on Terra classic cannot claim their airdrop", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "of the current airdrop implementation The in contracts/airdrop/src/contract.rs requires users to prove their ownership of Terra tokens by providing signatures using the same private keys that were used in Terra classic. Smart contracts, however, do not have the capability to sign messages as they do not have private keys. As a result, smart contracts are unable to provide the required signatures, making it impossible for them to claim airdrops. This prevents smart contract holders from participating in airdrops, which could lead to a signicant portion of the token holders being excluded from the airdrop distribution. contract smart", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. liquidation-filterer contract is not compliant with CW2 Migration specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "The liquidation-filterer contract does not adhere to the CW2 Migration specication standard. This may lead to unexpected problems during contract migration and code version handling.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. InstantiateMsg is not validated in the airdrop contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "In contracts/airdrop/src/contract.rs:28, when handling the InstantiateMsg, no validation of the merkle_root length and sent funds is performed.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Schedule structs are not validated in the vesting contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "In  contracts/vesting/src/contract.rs:37,  contracts/vesting/src/contract.rs:102, and  contracts/vesting/src/contract.rs:65, the Schedule structs are handled without being validated. This could lead to situations where the start_time timestamp value is less than the current timestamp or the cliff value is greater than or equal to duration.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. liquidation-filterer contract could be optimized", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "The liquidation-filterer contract is designed to be able to trigger a set of liquidations in the red bank. In order to accomplish this, the LiquidateMany message takes a list of Liquidate elements, iterates through all of them, performs a query in order to check if they are liquidatable, and then forwards the Liquidate messages to the red bank. Since the list of Liquidate elements could be of a relevant cardinality and each iteration performed both a query and a transaction, there is a possibility that the execution goes out of gas and reverts all the intended liquidations. Also, transactions can change the health status of a position, which invalidates previous query results.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/liquidation-filterer/Cargo.toml  contracts/airdrop/Cargo.toml  contracts/vesting/Cargo.toml While enabled implicitly through the workspace manifest, future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Contracts should implement a two step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Custom access controls implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "Contracts implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Incorrect comment for LiquidateMany message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "In contracts/liquidation-filterer/src/msg.rs:17, the LiquidateMany message is Set emission per second for an asset to holders of its maToken. This is incorrect because the messages functionality is to liquidate multiple undercollateralized positions from the red bank. the comment for", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Suboptimal voting power calculation in vesting contract allows for unfairness in voting process", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "The current implementation in contracts/vesting/src/contract.rs:199 calculates voting power from staked tokens, locked tokens in the vesting contract and unlocked tokens from the vesting contract that are not yet withdrawn. Ok(Some(position)) => position.total - position.withdrawn However, this calculation method is suboptimal because it does not account for tokens that are currently withdrawable. In fact, it allows users to vote on a proposal and immediately withdraw the withdrawable tokens, which means that the tokens used to vote are no longer staked and do not contribute to the voting power. This can lead to unfairness in the voting process.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Voting power is valid on the same block schedule created", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Periphery v1.0.pdf", "body": "contracts/vesting/src/contract.rs:197, In query_voting_power functionality determines a users voting power by checking the POSITIONS storage state. Since positions are directly updated in the same block when create_position is called, this might allow an exploit similar to the Beanstalk exploit. the it With that said, is currently not exploitable since only the contract owner can create is another smart contract allowing positions. However, suppose the contract owner permissionless position creation. In that case, an attacker can ash loan a big amount of Mars tokens to create a large position for themselves which comes with high voting power. We consider this a minor issue because it may lead to a vulnerability if the architecture changes in the future.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. NOIZDStaking.sol: Instant withdrawal signatures can be replayed to bypass freeze time in some cases", "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf", "body": "Nonces are used as a type of withdrawal id to make instant withdrawal permissions unique, which is veried in function _withdrawInstant. However, nonces are kept on a per-user basis, meaning that a user could re-use an admin generated signature intended for another user currently on the same nonce.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. NOIZDStaking.sol: Refund could be blocked by a malicious or faulty receiver", "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf", "body": "The transaction reverts if a single Ether transfer fails (line 388), allowing a malicious or faulty receiver to block the refund operation. This is mitigated by the fact that the built-in pagination allows the admin caller to avoid such malicious or faulty receivers.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. NOIZDNFT.sol: Unreachable conditional statement", "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf", "body": "The following code in function tokenURI in line 63 will always result in the execution of the rst branch: return string(abi.encodePacked(baseURI, _tokenURIs[tokenId])) : \"\"; bytes(baseURI).length > ? The reason for this is that baseURI is read from the hardcoded value \"ipfs://\".", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Outdated OpenZeppelin release used", "html_url": "https://github.com/oak-security/audit-reports/tree/master/NOIZD/Audit Report - NOIZD.pdf", "body": "The codebase imports a relatively recent version of the OpenZeppelin smart contract library. However, there have been recent security releases that x issues, some of which are related to ECSDA signing. These issues seem not to apply in the present use case of the contracts. However, we recommend using the latest security release, particularly, since the draft EIP-712 implementation used is updated frequently.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Queried voting power when executing proposals is set to current height, allowing anyone to execute proposals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In contracts/proposal/dao-proposal-multiple/src/contract.rs:365, the callers voting power is queried at the current block height to ensure they are one of the DAOs members. This implies that any caller can execute a proposal by staking a small number of funds after the proposal ends and calling the execute_execute function.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Users might be unable to claim NFTs if they unstake a large amount", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In contracts/voting/dao-voting-cw721-staked/src/contract.rs:143-158, the execute_unstake function attempts to validate the outstanding NFT claims is not greater than or equal to the congured max claim amount. Since the outstanding claims do not include the current amount of token_ids to claim, a user can unstake a large number of NFTs in one transaction as long the old outstanding claim amount is smaller than the max claim limit. As result, users would be unable to claim NFTs using the execute_claim_nfts function due to an out-of-gas error. a Please see the test_bypass_max_claims test case to reproduce the issue. We classify this issue as major since it can only happen when the user unstakes a large number of NFTs in one transaction, but the user is not able to recover these NFTs.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Duplicate input elds would be overwritten", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In contracts/dao-core/src/contract.rs:76-78, the InitialItem key from the msg.initial_items vector is being saved into the ITEMS storage state. If there were duplicate keys, the previous ones would get overwritten, causing only the last value to be stored. the that, in Besides duplicate contracts/dao-core/src/contract.rs:497-500 addresses in the to_add vector. Consequently, the previous SubDao charter would get overwritten, causing the SUBDAO_LIST only to save the last charter value. execute_update_sub_daos_list function does lter not", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. DumpState query does not paginate proposal modules which can result in out of gas errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "the query_dump_state In contracts/dao-core/src/contract.rs:665-668, function attempts to fetch all proposal modules stored in the PROPOSAL_MODULES storage. The query will fail if too many stored proposal modules exist due to an out-of-gas error. As a result, the active_proposal_module_count and total_proposal_module_count values cannot be queried, representing the number of active proposal modules and the total number of proposal modules. We classify this issue as minor since only the contract admin can instantiate proposal modules.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Admin can replay migration to overwrite dao_uri and re-enable proposal modules when contract is paused", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "The migrate handler in contracts/dao-core/src/contract.rs:831-879 does not ensure the current contract version is lower than the version to migrate to. This is problematic because the contract admin can abuse the migration function to modify the dao_uri and re-enable all proposal modules when the contract is paused, allowing them to partially bypass the contract state. Ideally, a paused contract should not have its storage state mutable until the expiration ends. Please see the test_replay_migrate test case to reproduce the issue. We classify this issue as minor since only the contract admin can perform migrations.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. DAO has inuence over voting results", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In contracts/proposal/dao-proposal-multiple/src/contract.rs:285, the voters voting power is determined by querying the congured DAO contract. Since the total voting power is queried and stored as seen in line 207, updating the DAO contract to a dierent address might cause incorrect voting results. Suppose the voter staked more tokens in the newly updated DAO contract. This would cause the execute_vote function to query the new voting power and compare it against the old total voting power, leading to an incorrect voting result. Besides that, the DAO can also update the only_members_execute boolean which aects the execute_execute function. Suppose the only_members_execute conguration is set to true during the proposal creation time and set to false after the proposal passes. The DAO members would expect only they can execute the proposal. However, since the only_members_execute value is loaded from the conguration directly, anyone can execute the proposal. close Lastly, the close_proposal_on_execution_failure boolean can be updated by the DAO to the execute to close_proposal_on_execution_failure was set to false and the message to execute fails in line 409. The DAO can interfere by updating the conguration to true and re-execute the function, causing the proposal status to be set to ExecutionFailed. automatically. proposals Suppose that fail This issue is also present contract. in the contracts/proposal/dao-proposal-single We classify this issue as minor since only the DAO contract can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Too many proposal modules stored would cause migration to fail", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "contracts/dao-core/src/contract.rs:837-859 and In contracts/proposal/dao-proposal-single/src/contract.rs:879-919, all stored proposal modules are collected without pagination. This is problematic because if too many proposal modules were stored, the migrate function would fail due to an out-of-gas error, preventing the admin from migrating the contract to the latest version. We classify this issue as minor since only the contract admin can instantiate proposal modules.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Setting AbsoluteCount to zero will always show proposals as active", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In contracts/voting/dao-voting-cw20-staked/src/contract.rs:307-315, no validation ensures the count value inside the ActiveThreshold::AbsoluteCount enum is greater than zero. In comparison, the ActiveThreshold::Percentage enum is validated to ensure the percent value is greater than zero in line 213. If the count value is congured to zero, the query_is_active query will always return true despite the total amount of tokens staked being zero. We classify this issue as minor since only the DAO contract can congure active thresholds.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. A counterparty in escrow can always withdraw, resulting in temporary grief", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In the contracts/external/cw-token-swap/src/contract.rs:197, execute_withdraw function allows a counterparty to withdraw the funds deposited in the contract. Since the escrow completion depends on the payment of the last counterparty, whoever deposited rst can always withdraw their (such as frontrunning the other user), causing the transaction never to be completed. funds from the contract", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Active threshold could be set for a very small percentage", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In contracts/voting/dao-voting-cw20-staked/src/contract.rs:214-229, the execute_update_active_threshold function allows a DAO to set an active threshold. It validates that the threshold is between 0 to 100, meaning the DAO can set it to a very small percentage (e.g. 2%). This may allow malicious participants to execute an attack on the DAO.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. All implemented electoral schemes are Condorcet-incomplete", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "Both intended electoral systems, ranked choice voting and single-member plurality voting, do not satisfy the Condorcet winner criterion. This means both cannot ensure that the Condorcet winner (the alternative that would win a two-option vote against each of the other options in a plurality vote) wins the vote. A mechanism to pick a Condorcet winner is desirable because it is considered prudent decision-making, particularly regarding budgetary decisions.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Migration does not update the latest contract name and version", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In contracts/voting/dao-voting-staking-denom-staked/src/contract.rs:1 16-118, the migrate handler does not automatically set the latest contract name and version. If the admin migrates the contract, the query_info query in line 100 will still show the old contract name and version.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Users can unstake zero amounts of funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In contracts/voting/dao-voting-native-staked/src/contract.rs:180-197, the execute_unstake function does not validate the amount to be 0. Since the amount is not validated, a valid claim is still created for the user, causing the outstanding claims to be increased in line 182. Consequently, the current outstanding claims will be growing and compared to the MAX_CLAIMS amount, potentially causing the user to be unable to unstake tokens as intended.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Permissionless proposal creation policy could result in spam proposals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In contracts/proposal/dao-proposal-single/src/contract.rs:164-166, the DAO contract allows dierent congurations. If the pre-propose module is unset and the proposal_creation_policy is set to Anyone, malicious users can spam the DAO with unnecessary proposals.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. dao-voting-staking-denom-staked allows malicious actors to manipulate voting power", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In contracts/voting/dao-voting-staking-denom-staked/src/contract.rs:5 8-98, the query_voting_power_at_height and query_total_power_at_height function return the current voting power irrespective of the provided height argument. Normally, the total voting power of a proposal is snapshotted at a specic block height using the TotalPowerAtHeight VotingPowerAtHeight is queried with the proposals start height to get the users staked amount. Since both queries return the height based on the users argument value, this means the user-staked amount can be manipulated. contract. When voting votes, user the in a If the user changed their staked amount (e.g., staked more tokens), their staking power would be changed. However, the total power saved in the proposal still uses the old total staking power value. Due to this, users who vote will be queried with current voting power, not snapshotted power. This allows malicious users to manipulate their voting weight. For example, imagine Alice and Bob each have 500 voting power at block height 10. The stored total voting power in the proposal will be 1000 (500+500=1000). At block height 20, Alice stakes more tokens causing her voting power to be 1200. Alice then votes, and the contract queries Alices voting power at block height 10. However, due to the issue described above, her voting power returned will be 1200 instead of 500, causing Alice to have a higher voting power than intended. We classify this issue as minor because ICS chains do not have a staking module, preventing the usage of this contract. However, this would be an issue if the contract is deployed on a chain with a staking module.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Non-token might be miscongured as a staking asset", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In contracts/staking/cw20-stake/src/contract.rs:79, any address could be congured as a staking token, even contracts do not implement token interfaces. We classify this issue as informational because the contract miscongure an incorrect CW20 token address, even if implemented. instantiator can always the recommendation below is", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Ranked choice voting not implemented", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "The documentation mentions the implementation of ranked choice voting, but it is not implemented.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Multiple choice voting is prone to social engineering attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "Multiple choice voting systems, where users can specify options as free text, are prone to social engineering attacks, as users can try to confuse users with odd alternatives. This is particularly problematic in conjunction with Condorcet-incomplete voting schemes, where minority alternatives can win. Users can try to submit duplicate \"No\"-options or introduce \"quasi-No\"-options and split up the \"No\"-voters into smaller subsets such that they do not get a share of votes to prevent any of the other options. An oversimplied example is illustrated below. Question: What kind of horse should we buy? Answers:  Black  Red  We should discuss this again next year  None of the above While both We should discuss this again next year and None of the above are the equivalent of We shouldn't buy a horse now, one of the options Black or Red might win even if the majority of voters do not want to buy a horse, because the No-votes are split.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Iterations over hooks might run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-02-06 Audit Report - DAO DAO 2 v1.0.pdf", "body": "In packages/cw-hooks/src/lib.rs:34-52, gas. iterations over hooks might run out of We classify this issue as informational as only admins can cause it and it is recoverable.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Conict of permissioning prevents feeder from submitting prices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "When feeding prices into a price feed the contract checks that the owner is the sender of the message in contracts/oracle-proxy-feed/src/contract.rs:125. Subsequently when pushing prices to the relevant asset feeds the contract checks whether the message sender is a registered feeder in line 143. This means that only the contract owner who also is the feeder can submit prices to the feeder contracts.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Incorrect price list query in oracle hub", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "hub oracle in The the query_proxy_list contracts/oracle-hub/src/contract.rs:70 function. This incorrectly returns a list of the registered proxies for a specic asset token and not the latest prices. message calls PriceList query", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Unbounded number of oracle proxies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "The number of proxies that can be registered to the oracle hub is unbounded in contracts/oracle-hub/src/state.rs:39. Having a potentially large number of proxies would make execution functions costly and query functions unperformant. In extreme cases, this could cause the querier to run out of gas.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Oracle query functions contain unbounded loops", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "and Band Chainlink The contracts/oracle-proxy-band/src/contract.rs:172 contracts/oracle-proxy-chainlink/src/contract.rs:164. signicant computational resources leading to issues in the calling contracts. functions contain query unbounded loops in and They may use", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Sorting proxy list on every query is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "Every call to query_price in contracts/oracle-hub/src/query.rs:54, 84 and 118 sorts the proxy list. Doing so on every call is computationally inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Legacy price response returns last updated value for quote price in the future", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "The LegacyPriceResponse contains u64::MAX for the last_updated_quote in contracts/oracle-hub/src/query.rs:126. A last updated quote value in the future may be unexpected to callers of the query and may cause errors in calling contract if that edge case is not handled.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "Packages contracts/oracle-proxy-band/Cargo.toml, contracts/oracle-proxy-chainlink/Cargo.toml, contracts/oracle-proxy-feed/Cargo.toml packages/tefi-oracle/Cargo.toml do not enable overflow-checks for release prole. contracts/oracle-hub/Cargo.toml, and the While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Oracle price query variable naming may be confusing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "The oracle hub price query in contracts/oracle-hub/src/query.rs:38 exposes a eld named timeframe, which does not clearly communicate the intent of the eld. Moreover, it is not obvious whether timeframe should be provided in seconds, blocks or the API should be as another unit. Since the oracle may be used by many projects, self-explanatory as possible.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Legacy price query does not support dierent bases", "html_url": "https://github.com/oak-security/audit-reports/tree/master/TeFi/2022-01-14 Audit Report - TeFi Oracle Contracts v1.0.pdf", "body": "The oracle hub price query in contracts/oracle-hub/src/query.rs:102 takes both a base and quote asset as an argument. However, if the quote asset is not base_denom the contract throws an error in line 108. This makes the API less user-friendly as requests for prices the oracle has access to would be rejected unexpectedly.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "2. Iteration over queued stakings in end blocker can be exploited to halt block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/All in Bits/2022-04-04 Audit Report - Budget and Farming Cosmos SDK Modules v1.0.pdf", "body": "Within the EndBlocker of the farming module, multiple iterations occur over all queued stakings in x/farming/keeper/staking.go:399. An attacker could create a large number of stakings in an epoch to cause the end blocker to run too long to nish creation of the block within Tendermints propose timeout. The cost of this attack is relatively small since the staked amount could be minimal, and staking itself is not gas-intensive.", "labels": ["Oak Security", "Severity: High"]}, {"title": "1. Vault deposits are not aected by delisted coins", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf", "body": "In contracts/credit-manager/src/health.rs:160, when a coin is delisted, the LTV is set to zero. However, vault deposits of the delisted coin are not aected, as seen in lines 100-128. Consequently, users can maintain the collateral value of coins deposited prior to delisting. They could even time an attack based on the previous LTV by frontrunning the delist transaction or entering a vault when an announcement to delist a specic coin is published. For example, suppose ATOM is to be delisted by the Mars team. A borrower notices it and enters a locked vault that accepts ATOM as a base deposit. Despite ATOM being delisted, the borrowers collateral in the form of vault tokens still contributes to the overall LTV. The borrower can execute the RequestVaultUnlock message to convert the vault tokens back to ATOM, contributing to the total collateral value using the red banks LTV. Additionally, the client also identied that delisted vaults still contribute to the total collateral value. We classify this issue as major because this aects the correct functioning of the overall system.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. account-nfts contract UpdateConfig message cannot be executed after the minter role is transferred to credit-manager", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf", "body": "The comment in contracts/account-nft/src/msg/instantiate.rs:22-24 states that the minter role will be transferred to the credit-manager contract. However, the the account-nfts credit-manager contract has no message dened to call UpdateConfig, and that implies proposed_new_minter conguration values can no longer be updated once the ownership has been transferred. max_value_for_burn which the We classify this issue as major because this aects the correct functioning of the overall system.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Allowing deposit or duplicate vault tokens may cause unexpected outcomes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf", "body": "In the contracts/credit-manager/src/vault/utils.rs:92-101, rover_vault_balance_value function queries the balance of vault tokens to calculate the tokens value. However, there is no validation to ensure the contract owner does not congure the vault token as allowed coins or that the congured vaults do not contain duplicate token denoms. This is problematic because either of the above would cause the queried balance to include user deposits or other vault balances, causing the following functions to return a greater amount than expected:  vault_utilization_in_deposit_cap_denom  query_all_total_vault_coin_balances  query_total_vault_coin_balance  assert_deposit_is_under_cap As a result, the rst three functions would return incorrect information to users, while the last function would potentially cause a denial of service due to an AboveVaultDepositCap error when users try to deposit into vaults. Please see the test_duplicate_vault_tokens test case to reproduce this issue. We classify this issue as minor because only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Transactions including ProvideLiquidity or WithdrawLiquidity actions may run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf", "body": "In contracts/credit-manager/src/zap.rs:16 and 55, the provide_liquidity and withdraw_liquidity functions could trigger a large number of sub-messages that may consume the transactions entire gas. Those actions send a message to the zapper contract in order to execute a trade on osmosis and then return liquidity pool tokens and remainder coins to the recipient. To achieve this, they have to send a sub-message to osmosis for the trade and (n+1) ReturnCoin sub-messages - where n is the number of coins. Additionally, for each of the sub-messages, a Bank message is created. Since ProvideLiquidity and WithdrawLiquidity actions are only a part of the transaction, the transaction will also include AssertOneVaultPositionOnly and AssertBelowMaxLTV callbacks, which may consume an excessive amount of gas.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Coin whitelist update may run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf", "body": "the UpdateConfig In contracts/credit-manager/src/update_config.rs:45, message handler clears all the ALLOWED_COINS map entries and then inserts all new coins provided in the message into the map. Since this operation requires iterating on both the stored and the proposed whitelists in order to perform the update, the execution may run out of gas if the number of elements in the whitelist is signicant.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Use of magic numbers decreases maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf", "body": "Throughout the codebase, hard-coded number literals without context or a description are used. Using such magic numbers goes against best practices as they reduce code readability and maintenance as developers are unable to easily understand their use and may make inconsistent changes across the codebase. Instances of magic numbers are listed below:  contracts/zapper/base/src/contract.rs:113  contracts/zapper/base/src/contract.rs:159  contracts/account-nft/src/contract.rs:36", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Dependency on unreleased node version", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf", "body": "The current codebase includes a x for spot price queries from Osmosis GAMMs in packages/chains/src/helpers.rs:73-76. However, at the time of writing, the x made in the node client is still unreleased. We classify this issue as informational as it is not expected that these contracts will be deployed prior to the x being released.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Proposed new minter cannot be removed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf", "body": "there are no handlers In contracts/account-nft/src/contract.rs:67-77, exposed to remove the proposed_new_minter from the contract storage. This is problematic because if the pending minter does not intend to accept the role, the current minter cannot set the value back to None. We classify this issue as informational because the contract minter can still overwrite the minter back to the current contract addresses, which is equivalent to an empty proposed new minter.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Withdrawing liquidity requires the coin to be whitelisted", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-02-03 Audit Report - Mars Rover Updates v1.0.pdf", "body": "In contracts/credit-manager/src/zap.rs:61 and 79, the liquidity pool token and withdrawn liquidity are validated to be whitelisted. In the delisting logic pull request, one of the changes allows the withdrawal of assets that are not included in the whitelisted assets. However, this is not applied when withdrawing liquidity tokens.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Schedules start and end point timestamps are not validated to be in the future", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf", "body": "assert_vesting_schedules The contracts/tokenomics/vesting/src/contract.rs:240-254 ensures that scheduled end point is past the start point. function dened in the However, there is no check in place that enforces the start point or the endpoint to be in the future. This implies that there may be vesting schedules that instantly vest, which will probably only happen unintentionally. We classify this issue as minor because only the contract owner can create vesting schedules.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Unbounded iteration through schedules can permanently inhibit the execution of transactions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf", "body": "and In contracts/tokenomics/vesting/src/contract.rs:324 contracts/tokenomics/vesting/src/contract.rs:386, unbounded loops are used to iterate through all the registered schedules. Consequently, if the cardinality of registered schedules is signicant, the execution could run out of gas and revert the transaction. Additionally, since there is no way to remove completed schedules, this could permanently inhibit the execution of transactions. We classify this issue as minor because only the contract owner can create vesting schedules.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Miscongured zero max spread causes swaps to fail", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf", "body": "In contracts/tokenomics/maker/src/contract.rs:59, the max_spread value is not validated to be greater than zero. If the max_spread value is miscongured as zero, all swaps will fail due to a MaxSlippageAssertion contract error. This issue is also present during the conguration update phase in line 698. We classify this issue as minor because only the contract owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Governance fee percentage is not set to 100 if the staking contract address is not set", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf", "body": "The documentation in packages/astroport/src/maker.rs:17 states if staking_contract is set to None, the governance_percent value should be equal to 100. that However, this behavior is not enforced during contract instantiation and the UpdateConfig message handling.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. No events are emitted upon successful contract instantiation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf", "body": "In contracts/tokenomics/maker/src/contract.rs:97, no custom events or attributes are emitted upon successful contract instantiation. This prevents o-chain listeners from indexing parameters congured by the contract instantiator.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Incomplete parameter documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf", "body": "In several instances of the codebase, function comments do not include documentation of all parameters:  contracts/tokenomics/maker/src/contract.rs:106-112 and 614-624  second_receiver_params is not included.  contracts/tokenomics/vesting/src/contract.rs:61-75  The RegisterVestingAccounts, WithdrawFromActiveSchedule, ProposeNewOwner, DropOwnershipProposal, and ClaimOwnership messages are not documented.  contracts/tokenomics/vesting/src/contract.rs:369  The account, receiver, and amount parameters are not documented.  contracts/tokenomics/maker/src/utils.rs:132-143  The bridge_token and factory_contract parameters are not documented.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Outstanding TODO comment", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf", "body": "In contracts/tokenomics/maker/src/utils.rs:21, a TODO comment is present that questions whether the swap simulation should adjust according to the token's precision. This indicates that the codebase might not be ready for production.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Zero amount withdrawal will always fail", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf", "body": "contracts/tokenomics/vesting/src/contract.rs:375, the In withdraw_from_active_schedule function does not validate that to withdraw is not zero. As Cosmos SDK prevents zero-amount native token transfers, specifying zero withdrawal amounts will fail. The resulting transfer error might confuse users. the amount", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Redundant check in calc_schedule_unlocked_amount", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-04 Audit Report - Astroport Maker and Vesting Contract Updates v1.0.pdf", "body": "calc_schedule_unlocked_amount in The the contracts/tokenomics/vesting/src/contract.rs:349 checks whether time_period is not zero. This check is redundant as new schedules are validated through function enforces the assert_vesting_schedules function in line 246. This implying that end_point.time to be strictly greater time_period is always greater than zero. than start_point.time, function", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Unbounded iteration allows attackers to attack validators, slowing down or even halting block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "App modules implement logic that needs to iterate through slices in order to nd a specic element with the selected ID. This has the consequence of having unbounded loops with an asymptotic cost of O(n). This is even worse when a loop is done over arrays that contain other arrays. In this case, the asymptotic cost is O(n^2) or O(n^3). Unbounded loops can allow two dierent types of attack: 1. Validator slashing A malicious actor could spam a transaction, that he knows performs an unbounded loop, to a particular node trying to force it to be not able to compute the transaction before the BroadcastTxCommit timeout. This can prevent that node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. the NewTxTimeoutHeightDecorator will discard all messages with an Also, elapsed heightTimeout. This could be used in a particular event in order to manipulate it. As the validator was not able to sign the block, it implies that this event is decreasing its sign ratio. That could lead the validator to be slashed. 2. Stop or slow down the block production A malicious actor could spam the previous message to a set of validators. If a signicant number of them hit the timeout and halt simultaneously, block production may stop or slow down. Iterations vulnerable to this attack are:  x/asset/keeper/app.go:117  x/asset/keeper/app.go:262  x/asset/keeper/asset.go:160  x/collector/keeper/collector.go:104  x/locker/keeper/msg_server.go:238  x/locker/keeper/msg_server.go:310  x/vault/keeper/vault.go:47  x/vault/keeper/vault.go:57  x/vault/keeper/vault.go:347  x/vault/keeper/vault.go:421  x/vault/keeper/vault.go:441  x/rewards/keeper/keeper.go:86  x/rewards/keeper/keeper.go:156", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Transaction gas price is not related to execution complexity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "In app/ante.go:47, NewConsumeGasForTxSizeDecorator is calculating the gas cost of a transaction. taking care of This decorator computes the gas cost of a transaction by multiplying the size of transaction in bytes with TxSizeCostPerByte. the Even if this is a good heuristic to estimate the potential transaction cost, thats not enough. Transaction cost should be proportional to the computational complexity of its execution. For instance, a transaction that has an asymptotic complexity of O(1) and that is not doing I/O operations, should not have the same cost as another one that has a O(n) complexity and is executing extensive I/O operations. Messages vulnerable to this attack are:  MsgCreateLockerRequest in x/locker/handler.go:18  MsgCreateRequest in x/vault/handler.go:18  MsgWithdrawRequest in x/vault/handler.go:24  MsgDrawRequest in x/vault/handler.go:27  MsgRepayRequest in x/vault/handler.go:30  MsgCloseRequest in x/vault/handler.go:33  MsgCreateGauge in x/rewards/handler.go:19  MsgMintNewTokensRequest in x/tokenmint/handler.go:21  MsgDepositESM in x/esm/handler.go:18 The current lack of accounting for execution complexity can make it aordable for an attacker to perform DoS spamming with expensive messages that have a small payload.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Vault ID collisions could lead to the loss, tampering or overwriting of existing vault data", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "The MsgCreate function, in x/vault/keeper/msg_server.go, creates a new CDP or vault with a unique vaultId. In line 148, an ID is assigned to the newVault, concatenating the apps Shortname and the ExtendedPairs vault counter. However, this formula can lead to collisions, either accidental or intentional, which could cause a loss or tampering of existing vault data. Example:  ShortName1=Test1 and updatedCounter=1, with resulting vaultId=Test11  ShortName2=Test and updatedCounter=11, with resulting vaultId=Test11 It should be noted that this also aects stable vault IDs.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Locker ID collisions could lead to the loss, tampering or overwriting of existing locker data", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "Similarly to the vault ID collision issue, lockerIds are subject to collision due to the concatenation formula that is used to derive new userLocker.lockerId, in the function MsgCreateLocker, in x/locker/keeper/msg_server.go:85. This could lead to the loss or overwriting of key locker data, either accidentally or intentionally.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Users cannot redeem their collateral assets regardless of the ESM status", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "in if condition x/esm/keeper/msg_server.go:71, The the MsgCollateralRedemption handler, will never be executed, which blocks users from redeeming their collateral assets regardless of the ESM status. If the esmStatus.status is True, the condition in line 68 will be True, returning the ErrCoolOffPeriodRemains. And if the esmStatus.status is False, the condition in line 71 will be also False, preventing the execution of the if-block which contains the collateral redemption logic. in", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. GetPriceForAsset returns price of 2000000 for assets when the market is not found", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "The GetPriceForAsset function in x/market/keeper/oracle.go:175 returns a static price of 2000000 for assets when the market is not found. This is problematic because instead of returning an error for this case, the GetPriceForAsset will silently return an incorrect value for the asset's price. This can have unintended consequences that may allow attackers to economically exploit the protocol.", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Computationally heavy operations in BeginBlocker and EndBlocker may slow down or stop block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "BeginBlocker and EndBlocker are functions that are executed at the start/end of each block, even if there are no transactions. To not have a negative impact on block production, it should have a light and constant computational footprint. In fact, it is wise to be cautious about adding too much computational weight at the start of each block, as blocks arrive at approximately seven-second intervals. Also, it should be a good practice to make the BeginBlocker/EndBlocker execution independent, or at least with a sub-linear dependency, from the amount of data stored on-chain. A huge workload may slow down the block production, Tendermints proposal timeout is surpassed. in the worst case so much that The codebase implements multiple BeginBlocker/EndBlocker functions that are computationally heavy and/or depend on on-chain state:  x/auction/abci.go:8  x/esm/abci.go:10  x/market/abci.go:10  x/rewards/abci.go:11  x/liquidity/abci.go:12  x/liquidity/abci.go:29", "labels": ["Oak Security", "Severity: High"]}, {"title": "8. Multi-purpose BeginBlocker error handling may disable critical functionality if an error is raised", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "The BeginBlocker functions in:  x/rewards/abci.go:11  x/auction/abci.go:8 use an error-handling approach that stops the execution if one of the functions returns an error. This means that if the rst function execution returns an error, the other ones that come after that one will not be executed. While this can be a good approach for interdependent functions, it is not a good design in cases when functions are independent. in example, For DebtActivator and DutchActivator are independent SurplusActivator will deny the execution of the other two. the Rewards modules BeginBlocker, SurplusActivator in functions but an error", "labels": ["Oak Security", "Severity: High"]}, {"title": "9. Error handling during slices loop terminates the execution without executing the logic for all items", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "In  x/auction/keeper/surplus.go:27,  x/auction/keeper/surplus.go:33,  x/auction/keeper/dutch.go:56,  x/auction/keeper/dutch_lend.go:49,  x/auction/keeper/debt.go:26,  x/auction/keeper/debt.go:32, and  x/esm/abci.go:32-35, error handling logic during a slice iteration terminates the execution without iterating through all items. This behavior could lead to incoherent functionality if the loop triggers an error in the initial slice items. information inside the slice and to disabled This has the consequence of not checking all the items after the faulty one, and in the worst case, if the error is raised in the 0 position of the slice, to not check at all liquidation for collateralized positions.", "labels": ["Oak Security", "Severity: High"]}, {"title": "10. An attacker could send MsgRemoveMarketForAssetRequest messages every 20 blocks in order to make the Market module unusable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "x/market/handler.go:25, In MsgRemoveMarketForAssetRequest. anyone is allowed to send a An attacker could use this transaction to delete all the Market instances saved in the store, making the Market module unusable. The transaction can be executed every 20 blocks, which is the oracle data fetch interval.", "labels": ["Oak Security", "Severity: High"]}, {"title": "11. Permissionless Rewards module Whitelisting process allows attackers to manipulate the Asset Whitelist and App Vault Whitelist", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "x/rewards/handler.go, WhitelistAsset, and RemoveWhitelistAppIdVault RemoveWhitelistAsset, are messages In, WhitelistAppIdVault permissionless. Since those messages are responsible for the management of the Asset Whitelist and App Vault Whitelist, they should be executable only from privileged users or through governance. In fact, having those messages executable by anyone makes the Whitelist process ineective and exposes an attack surface. For example a malicious actor could delete all Assets from the AssetWhitelist and make the module unusable, or could add an Asset to the whitelist that should not be allowed.", "labels": ["Oak Security", "Severity: High"]}, {"title": "12. Gas is not consumed if the transaction returns an error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "The ConsumeGas function calls in lines:  x/liquidity/keeper/pool.go:182,  x/liquidity/keeper/pool.go:255,  x/liquidity/keeper/pool.go:313,  x/liquidity/keeper/swap.go:123,  x/liquidity/keeper/swap.go:233,  x/liquidity/keeper/swap.go:292,  x/liquidity/keeper/swap.go:362,  x/liquidity/keeper/rewards.go:312, and  x/liquidity/keeper/rewards.go:424, are located at the end of the transaction execution and are not called if an error occurs. Consequently, a malicious actor is allowed to spam transactions that trigger an error in the middle of the execution without being charged of the dened gas fees.", "labels": ["Oak Security", "Severity: High"]}, {"title": "13. CosmWasm - State query binding can perform a GRPC call to an arbitrary URL", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "In contracts/governance/src/msg.rs:12, target eld of type String. the InstantiateMsg is expecting a This eld is then used by the contract to perform State queries in  contracts/governance/src/contract.rs:128 and  contracts/governance/src/contract.rs:442 in order to get the state at a particular BlockHeight. The CosmWasm State query binding is resolved in the Cosmos SDK side by the QueryPlugin in app/wasm/query_plugin.go:54 and handled by the QueryState function in x/locker/keeper/locker.go:328. In x/locker/keeper/locker.go:335 the target eld propagated from the CosmWasm contract is used as URL to create a GRPC insecure connection. This mechanism is intended to work to call a Full Node but it has some possible problems:  Every target URL is allowed so an attacker could use this to perform a DOS or to create a botnet using chain nodes to perform a DDOS.  Exposed GRPC port could be not the same in dierent nodes as it can be congured by see https://docs.cosmos.network/master/core/grpc_rest.html#grpc-server, or it could be behind a Load Balancer, Reverse Proxy, Docker network, Ingress, etc. operators, node  It is performing the call with grpc.WithInsecure() so there is no trust to the It MITM GRPC attacks https://grpc.io/docs/guides/auth/#with-server-authentication-ssltls contacted. allows server like  Congurations and security enforcements rules through iptables or ufw or similar softwares on machines where the chain node is hosted could block this type of calls That means that a CosmWasm contract is able to make the chain node perform a GRPC insecure connection to an arbitrary URL by simply using the State query binding.", "labels": ["Oak Security", "Severity: High"]}, {"title": "14. Error raised in BeginBlocker could lead to state corruption", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "The modules that raise errors in BeginBlocker which could lead to a state where partial state changes are performed but other intended state changes are not committed. This function logs errors but has no control over the state and no mechanism to revert partial updates. This implies that if an error is raised in the middle of an execution ow, the execution will stop and log the error, but no action will be taken in order to revert state updates that have been done leading to state corruption.", "labels": ["Oak Security", "Severity: High"]}, {"title": "15. CosmWasm - Deposited funds of other denom will be stuck in the contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "In contracts/governance/src/contract.rs:534 in the execute_deposit message, if the voter has made a deposit to the given proposal before, the Coins that were previously added in the rst deposit will be increased with the amount of the new deposit. However, there is no check that info.funds.len == 1, so dierent denoms will be accepted and not accounted for, resulting in these funds remaining permanently stuck in the contract. The same issue occurs if a user only sends one coin of a certain denom to an existing proposal with a dierent denom. After the proposal has passed or been rejected, the execute_refund function in 570 will not return the coins whose denoms are dierent from the original deposit.", "labels": ["Oak Security", "Severity: High"]}, {"title": "16. UpdateAssetsRecords is not enforcing a unique Denom for an Asset", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "The UpdateAssetsRecords function in x/asset/keeper/asset.go:189 is not consistently handling the Denom to Id mapping when updating an Asset with a new Denom eld. asset.Denom Since the with DeleteAssetForDenom(ctx, asset.Denom) in line 205 is not deleting the mapping with the old Denom but is instead trying to delete the mapping with the new one. msg.Denom updated 203, line in is This has the consequences of not having a unique Denom for an Asset Id in the Denom to Id mapping.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "17. AddAppRecords may overwrite existing app name entries", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "The AddAppRecords function in x/asset/keeper/app.go:208-210 incorrectly performs an app name validation that will allow for the existing app Id to be overwritten in In line 208 the HasAppForName check is passed msg.ShortName SetAppForName. rather than msg.Name, so in eect the name is not checked currently.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "18. MsgAddWhiteListedAsset allow any caller to add an asset id to a lockers whitelist", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "The MsgAddWhiteListedAsset function in x/locker/keeper/msg_server.go:327 does not include any permission checks to ensure only authorized addresses are able to add asset Ids to the lockers whitelist. Currently any user may send this message to add asset Ids to the lockers whitelist.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "19. AddAppRecords may accept invalid GenesisToken array", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-12-07 Audit Report - Comdex v1.0.pdf", "body": "The AddAppRecords function in x/asset/keeper/app.go:203 does not perform proper validation on the GenesisToken array before setting it in the store. At a minimum, the function should conrm that the slice of MintGenesisToken does not contain duplicates, and that the Recipient is a valid address. stored invalid An AddAssetInAppRecords CheckIfAssetIsAddedToAppMapping function. GenesisToken messages array during could break the the execution handling of of the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Market timestamp checks market prices Since the Recommendation We recommend performing validation on the posted prices. For instance, there could be a maximum allowed delta per time unit, such that a price of 0 would not be accepted. While this does not fully resolve the centralization issue, privilege abuse would be more involved (and require multiple transactions over a longer timespan). This would allow operators and users to react. Furthermore, bugs in the o-chain bots that result in clearly wrong prices would no longer break the whole system. Alternatively, prices could be aggregated, for example by calculating a time-weighted median price to minimize the impact of a single buggy or compromised bot. Status: Acknowledged 11. PID parameter centralization risk", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neptune/2023-04-09 Audit Report - Neptune Protocol v1.0.pdf", "body": "3. Market timestamp checks market prices Since the Recommendation We recommend performing validation on the posted prices. For instance, there could be a maximum allowed delta per time unit, such that a price of 0 would not be accepted. While this does not fully resolve the centralization issue, privilege abuse would be more involved (and require multiple transactions over a longer timespan). This would allow operators and users to react. Furthermore, bugs in the o-chain bots that result in clearly wrong prices would no longer break the whole system. Alternatively, prices could be aggregated, for example by calculating a time-weighted median price to minimize the impact of a single buggy or compromised bot. Status: Acknowledged 11. PID parameter centralization risk", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Liquidation penalty is not validated during struct initialization", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "In cadence/contracts/LendingComptroller.cdc:125-127 of the MoneyMarket repository, the liquidation penalty is not validated to be below 1.0 (ie. 100%) during the Market struct initialization. As a result, misconguring the liquidation penalty value might cause a liquidator to receive more funds than intended, causing a loss of funds for the borrower. We consider this to be a minor issue since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Interest rate model capability is not validated during update", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "In cadence/contracts/LendingPool.cdc:959-970 of the MoneyMarket repository, the newly set interest rate model capability is not validated to exist and can be borrowed. As a result, setting a non-existing capability for the interest rate model would cause several accrueInterestReadonly, functions getPoolBorrowRateScaled, and getPoolSupplyAprScaled. getPoolBorrowAprScaled contract notably fail, the to in We consider this to be a minor issue since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Local resource reference can be used for eciency", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "In cadence/contracts/PriceOracle.cdc:128-130 of the Oracle repository, the certificate argument is passed as an OracleCertificate resource reference which is implemented by the OracleInterface contract interface. The certificate is then veried by checking its type against the local OracleCertificate resource to make sure the caller can only be the current contract. This validation can be removed to introduce eciency by only accepting the local OracleCertificate resource reference as an argument.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Feeders can set non expirable prices by changing the expired duration to arbitrary high value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "In cadence/contracts/PriceOracle.cdc:122-124 of the Oracle repository, feeders can set an arbitrary high expired duration which makes their prices non-expirable. With that said, this doesnt directly aect the prices of assets until more than half of the feeders act maliciously and set the expired duration to an arbitrarily high value. We consider this to be a minor issue since this requires more than half of the feeders to be malicious.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Sorting algorithm can be improved", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "the current In cadence/contracts/PriceOracle.cdc:222 of the Oracle repository, sorting algorithm is inecient due to time complexity. Since takeMedianPrice functionality will be called many times, this causes every other operation that is dependent on it to become gas inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Typographical errors found in codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "there were In cadence/contracts/PriceOracle.cdc of several typographical errors found in lines 104 and 383. Specically, the word oralce_public should be replaced with oracle_public while the word _ExpriedDuration should be replaced with _ExpiredDuration. the Oracle repository,", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Possible chances of path collisions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/IncrementFi/Audit Report - Increment Finance.pdf", "body": "In the MoneyMarket repository, the following storage and public paths are very generic:  cadence/contracts/LendingPool:1086  cadence/contracts/LendingPool:1088  cadence/contracts/LendingPool:1089 This might lead to path collisions, potentially incorrect data access or resources overwriting.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Attacker can bypass self-call validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CronCat/2023-03-14 Audit Report - CronCat CosmWasm v1.0.pdf", "body": "validate_msg_calculate_usage The in contracts/croncat-tasks/src/helpers.rs:88 does not properly validate the value of contract_addr for the WasmMsg::Execute message type. This value is partially the task cannot call any of the validated in check_for_self_calls, associated CronCat addresses, but it does not account for the edge case that one of these addresses can be provided as all uppercase letters. This is possible for WasmMsg::Execute task actions that don't include queries. to check that function For example an attacker can specify an all uppercase version of the manager contract address, and then pass an address to update the owner and take control of the manager contract. These messages will also not cause errors during the address validation by the underlying Cosmos SDK, which is triggered from the wasm modules MsgExecuteContract message validation. The WasmMsg will be routed by the wasm module and will undergo stateless function will check validation in the message's ValidateBasic function. This msg.Contract with the sdk.AccAddressFromBech32, which returns the type AccAddress []byte. It does not dierentiate if the supplied address is in uppercase or lowercase. They will both normalize to the same byte slice, as long as the chain prex has the same case. See Appendex A: Test 1 Case 2 for more detail. The following shows two Bech32 addresses that both evaluate to the same account address: 395441E922FCBDC6BEC9B76EAC2C7D647B50D66F cosmos1892yr6fzlj7ud0kfkah2ctrav3a4p4n060ze8f 395441E922FCBDC6BEC9B76EAC2C7D647B50D66F COSMOS1892YR6FZLJ7UD0KFKAH2CTRAV3A4P4N060ZE8F", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Task contracts execute_update_config is permissionless", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CronCat/2023-03-14 Audit Report - CronCat CosmWasm v1.0.pdf", "body": "execute_update_config in The contracts/croncat-tasks/src/contract.rs:96 allows any caller to execute a cong update for the Tasks contract. This will allow an attacker to gain complete control over the Tasks contract by updating critical parameters, for example, setting themselves as the contract owner. function", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Agents can bypass task delegation mechanism", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CronCat/2023-03-14 Audit Report - CronCat CosmWasm v1.0.pdf", "body": "execute_proxy_call in The contracts/croncat-manager/src/contract.rs:188-208 incorrectly assumes that when a calling agent supplies a task hash the task is event based. This will allow agents to bypass the task delegation logic and directly execute tasks on a rst come rst serve basis. function This is based on the assumption that agents are all behaving according to the client software. But an agent owner could modify the client software to game this system and prot from receiving a disproportionate amount of tasks. For example, a malicious agent client could query to nd out which slot tasks are executable, and then simply call execute_proxy_call with the task_hash to avoid the agent_task checks in line 217. On chains that support Skip, this could even become a MEV opportunity where agents would compete to get their bundle accepted and frontrun the normal task delegation logic. This would completely exclude other agents that are acting normally. A proof of concept for this attack is available i", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Users are unable to withdraw funds once admin deposited all funds in the Red Bank", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "on In the Lockdrop contract, users are able to withdraw funds as long as it's under the congured withdrawal timeline. The withdrawal function will decrease the contracts total locked UST amount based (contracts/lockdrop/src/contract.rs:395). Once the admin deposits all funds to the Red Bank via DepositUstInRedBank, the contracts total locked UST will be set to 0 (L791). Since it only accounts for the deposit timeline instead of the withdrawal timeline (L465-472), users will be unable to withdraw their locked funds even if the withdrawal window is still open. withdrawal user's the We set the severity to Major since the users funds are still recoverable after a certain timeline.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Malicious users can cheat lockup rewards without locking their funds if claim is enabled before withdrawal timeline", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "condition In the Lockdrop contract, users can execute ClaimRewardsAndUnlock to claim rewards in the enabled (contracts/lockdrop/src/contract.rs:686-688). Claims can only be enabled from the Auction contract via AddLiquidityToAstroportPool which accounts in deposit and itself the windows (contracts/auction/src/contract.rs:440-445). withdrawal contract Auction claims only that are for Since both Auction and Lockdrop contracts are independently initialized, theres a possibility that admin might enable claims during the deposit or withdrawal phase of Lockdrop contract. If this happens, a malicious user can potentially cheat the lockup rewards via an attack scenario below: 1. Execute DepositUst to deposit a large amount of funds into any lockup position 2. Claim ClaimRewardsAndUnlock executing rewards via with lockup_to_unlock_duration_option as None 3. contracts/lockdrop/src/contract.rs:703-715, enter In calculate_mars_incentives_for_lockup internal function. Notice that lockup_info.ust_locked variable will be used to calculate users position rewards via calculate_weight. code will 4. Due to the code logic that only updates users MARS rewards when its 0, user_info.total_mars_incentives will not be updated in the future (contracts/lockdrop/src/contract.rs:704). The malicious user will have a denite reward. 5. Execute WithdrawUst to remove all funds locked under that lockup position (funds that can be removed highly depends on window timeline). In L382, the corresponding locked UST amount will decrease, however, the users MARS rewards will still remain the same. We set the severity to minor since this will only be exploitable if the timeline is congured incorrectly/far between Lockdrop and Auction contract which will inuence the execution of EnableClaims.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Users that claimed airdrops will miss out on additional airdrops", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "The current implementation of airdrop claims allows only one claim per user due to the the condition in contracts/airdrop/src/contract.rs:326. At contract owner has the ability to update Merkle roots in L198-200. Taken together, if a user was assigned additional airdrops, they would not be able to claim those additional airdrops. Even without an update, the current design does not allow a user to claim multiple airdrop leaves from the same Merkle tree. the same time,", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Missing validation on Cong parameters can lead to human errors and unexpected behavior", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "The Auction, Lockdrop, and LP Staking contracts are missing validation checks in some of its Cong numerical values. For example, in contracts/auction/src/contract.rs:61, there is no check that msg.init_timestamp corresponds to a future value (i.e. msg.init_timestamp>= env.block.time). in lockdrop/src/contract.rs:45. validation Lockdrop contract present This the in is example An contracts/lp_staking/src/contract.rs:37-39, init_timestamp + cycle_duration <= till_timestamp. Staking the LP in contract in there is no validation that that is Examples of missing validation checks in the Lockdrop contract are:  No validation that there are repeated values in msg.lockup_durations in line 67  No check that msg.seconds_per_duration_unit is non-zero. Examples of missing validation checks in the Auction contract are:  No check that config.mars_vesting_duration is non-zero, which would cause division by zero error.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Missing MARS rewards validation may cause auction participants to lose their deserved rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "In the Auction contract, anyone can deposit MARS to increase the overall reward for users via If no one deposited any MARS token rewards before the IncreaseMarsIncentives. is not possible to continue admin executed AddLiquidityToAstroportPool, depositing minted tokens (contracts/auction/src/contract.rs:199-L203). This would cause auction participants to receive zero Mars token rewards in return for their MARS token delegation. it token already shares MARS due LP to", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Querying the state of the contract may return false information", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "In the LP staking contract, in lines lp_staking/src/contracts.rs:315-352, there is a max function that takes the timestamp provided by the user and the current timestamp. Therefore, if the user-provided timestamp is in the past, the returned information will be false, as it will correspond to the current timestamp. If the user, which can be a 3rd party protocol, relies on this query to do further calculations, this might cause unintended consequences.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Typo in variable names might cause errors in the future", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "In the Lockdrop contract, contracts/lockdrop/src/contract.rs:832, there is a typo in the variable xmars_accured, which may cause development errors in the future.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Overow checks not set for most packages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars Periphery v1.0.pdf", "body": "The following Cargo.toml les do not enable overow-checks for the release prole:  packages/mars-periphery/Cargo.toml  contracts/airdrop/Cargo.toml  contracts/auction/Cargo.toml  contracts/lockdrop/Cargo.toml  contracts/lockdrop/Cargo.toml", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Meta transactions can be replayed across contracts and networks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf", "body": "Currently, the implementation of meta transactions does not verify the contract and network of the transaction. As a result of this, it is possible to replay a meta transaction in dierent contracts such as Alice Terra tokens for UST and EUT and networks such as testnet or mainnet. That could lead to double-spending.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Execute deposit stable function uses relayers funds instead of users funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf", "body": "When a user attempts to deposit funds into Anchor protocol, the request originates from execute_relay into execute_deposit_stable due to meta transactions. In relay.rs:63-65, the relayer attempts to execute the request as the user via mutating info.sender which then executes the message in line 81. as When the operation continues to execute_deposit_stable, the request will see Since funds. info.funds info.sender execute_deposit_stable determines the fund amount via checking info.funds (execute.rs:94-99), this would cause the relayers funds to be deposited into Anchor instead of the users funds. user while relayers are the", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Anchor exchange rate used might be out of date due to missing block height argument", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf", "body": "The Anchor exchange rate is queried from the Anchor contracts, through the utility function in compute_exchange_rate contracts/alice_terra_token/src/utils.rs. However, no block height argument is supplied. Without the block height argument, Anchor returns a raw exchange rate from stored values without accruing interest since the last update, which means an outdated exchange rate is returned. Using this value could lead to slightly incorrect calculations. dened", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Missing validation during instantiate phase allows fee_ratio to be over 100%", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf", "body": "fee_ratio is the percentage of fees Alice protocol would receive from user yields. During the instantiation phase (alice_terra_token/src/contract.rs:50) and migration phase (contract.rs:141) ,  there is no validation to ensure the ratio should be 0-100%.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Sent tokens other than in stable denom are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf", "body": "During execute_deposit_stable and execute_deposit_stable_authorized, the users uusd funds are processed and deposited to Anchor protocol. If the user deposited additional tokens (other than uusd), the funds would get stuck in the contract after the operation succeeds.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Querying registered contracts in Overseer is unbounded", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf", "body": "RegisteredContracts in The alice_overseer/src/contract.rs, which could cause calling transactions to run out of gas. Even if it is unlikely that there would be enough registered contracts to make the query out of gas, since registered contracts cannot be removed an out-of-gas situation could be irreversible. unbounded message query is", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. execute_redeem_stable returned amount might be dierent from actual amount", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf", "body": "The execute_redeem_stable function requests a stable denom amount and then returns a calculated amount to the user. The returned value may be dierent from the actual returned amount due to possible slashing penalties, fees, taxes etc.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. aTerra exchange rate is queried twice during execute_redeem_stable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Alice/Audit Report - Alice.pdf", "body": "functions The and query_aterra_exchange_rate both query aTerra exchange rate individually. During execute_redeem_stable, both functions are used to retrieve the aTerra exchange rate in alice_terra_token/src/execute.rs:163 and 165 which is inecient. compute_and_update_exchange_rate", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Unbounded iteration in the tax modules AnteHandler could be used by an attacker to slow down or halt the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf", "body": "In x/tax/keeper/taxdecorator.go:76-81, the ApplyTax function called from the tax modules AnteHandler is performing an unbounded iteration over the feeCoins provided by users. An attacker could craft a message with a signicant number of Coins with the intention of slowing down the block production, which in extreme cases may lead to Tendermints propose timeout to be surpassed. This can prevent the node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of peers hit the timeout and halt simultaneously, block production may stop. A test case is provided in Appendix 1.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. ValidateMinter does not guarantee that provided parameters are adherent to the dened minting schedule", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf", "body": "In x/mint/types/minter.go:43, the ValidateMinter function does not verify that the parameters passed on genesis are conformant with the equation that denes the minting schedule. There is a risk that one or more of them are not correct, which would lead to a awed minting schedule. Once this happens, there is no straightforward way to return to the intended trajectory. It is important to note, nevertheless, that there are checks to ensure that the total minted amount does not exceed a predened threshold.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Silently handled broken invariant could lead to inconsistent chain state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf", "body": "In x/mint/abci.go:41-44, during the calculation of the time interval between two subsequent blocks, the guard that checks that the timestamp of the current block is greater than the previous one does not panic or return an error. Instead, it assigns blocks with the same timestamp, letting the execution ow continue. Since the code should always enforce the invariant   >  0 incorrect subsequent block order or simultaneous blocks should result in an error and eventually halt the chain. We classify this as a minor issue since Tendermint is already enforcing this invariant.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. The feeCaps parameter is not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf", "body": "In x/tax/types/params.go:103-113, the validateFeeCaps function that is invoked by ValidateBasic is not validating the feeCaps parameter. Instead, a TODO comment is present as a reminder to implement the validation logic. Consequently, every string value could be provided as feeCaps parameter.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Minting cap is not enforced during genesis", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf", "body": "the In x/mint/types/minter.go:48, TotalMinted parameter is positive, but it does not validate that the value is less than the MintingCap. the ValidateMinter function ensures that This implies that during genesis, a TotalMinted parameter value that exceeds the MintingCap amount is accepted and stored.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. The FixedMintedAmount parameter value is incoherent with the documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nolus/2022-12-12 Audit Report - Nolus Core v1.1.pdf", "body": "In x/mint/types/minter.go:11, FixedMintedAmount is set implies that 0.0825% of the total amount of tokens is minted per year. to 103125 which However, implementation and could lead to an unintended minting schedule. the docs dene this number to be 0.08% which is incoherent with the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Lack of stream status validation can be exploited to drain contract funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "The streamswap contracts finalize_stream function does not validate that the current streams status is not Status::Finalized. An attacker could exploit this by repeatedly calling the finalize_stream function to trigger Bankmsg::Send messages using the streams treasury as the beneciary. This results in transfers of both the creation denom and creators_revenue, drainting the contracts funds. A proof of concept test case can be found in the test case Faulty stream state validation lead to draining of funds in the appendix.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Stream status not saved after update allows contract funds being drained", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "The streamswap contracts finalize_stream function does save the new stream status after updating it in src/contract.rs:618-620. Consequently, the status will remain the same when calling the finalize_stream function again. Similarly to the issue Lack of stream state validation lead to draining of funds, this can be exploited by repeatedly calling finalize_stream to trigger Bankmsg::Send messages, which drains the contracts funds. The same proof of concept test case Faulty stream state validation lead to draining of funds in the appendix applies here.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Updating stream_creation_fee or stream_creation_denom will cause ongoing streams to error when nalized or canceled", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "constructed In the execute_finalize_stream and sudo_cancel_stream functions, the BankMsg is and config.stream_creation_denom. Both config values are only checked during stream creation, and any changes to these values after creation will impact streams that have not been nalized. This can cause inconsistent states and errors if the contract does not hold a sucient balance or the right denom to pay the fees. config.stream_creation_fee with suppose there are two non-nalized streams and the value of For example, config.stream_creation_fee is increased. Now the rst stream to nalize would spend a larger amount on fees than was contributed during the stream creation. This will result in the rst streams balance being too low to nalize the second stream. The functions in src/contract.rs:645 and src/killswitch.rs:272 send a and BankMsg config.stream_creation_denom. config.stream_creation_fee using", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Lack of conguration parameter validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "The streamswap contract does not validate several conguration parameters upon instantiation in src/contract.rs:32-45 and in the sudo_update_config function in lines 794-803. The following parameters should be carefully reviewed:  stream_creation_denom: creation as it will fail to match. Incorrect casing of the denom could block stream  stream_creation_fee: If set to zero, it will render the mechanism ineective and may allow spamming/grieng.  exit_fee_percent: If set to a value greater than one, line 630 will underow and streams can never be nalized.  accepted_in_denom: Incorrect casing of the denom could block stream creation as it will fail to match. In addition, operational issues if the account gets compromised or the organization requires a change. it should be noted that protocol_admin is not updatable. This could cause Although some of the consequences outlined above could have a major impact on users, privileged functions are operated by informed users which are less prone to errors. Therefore, we classify this issue as minor.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Exit fee percent validation diers from documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "included the following comment about exit_fee_percent The streamwap contract validation in src/contract.rs:31: exit fee percent can not be higher than 1 and must be greater than 0. Instead, the implementation allows the value to be less than one and greater than or equal to zero.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Stream creation parameters lack validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "The creation of a stream in src/contract.rs:188 is lacking validation, which may lead to unintended consequences for stream creators. Firstly, there should be a validation to ensure that out_denom is not the same as in_denom. Secondly, out_supply should be validated to ensure it is not 0. While fund amount cannot be 0 in Cosmos SDK messages, if out_denom == config.stream_creation_denom the amount of out_supply specied in line 164 could be 0 and still pass the validation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Stream actions performed at streams end time may introduce unintended consequences", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "The streamswap contract allows for the following messages to be executed at the streams end_time:  ExecuteMsg::Subscribe,  ExecuteMsg::Withdraw,  ExecuteMsg::ExitStream, and  ExecuteMsg::PauseStream. This is problematic since it can lead to inconsistent states. in the current For example, the end_time blocktime. This could introduce a scenario similar to the one described in the Unspent tokens could be locked in the contract upon exit nding. implementation, a caller can subscribe at Although no clear exploitation path have been identied, the current implementation is error-prone.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Lack of best-eort validation on stream name and URL", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "The streamswap contract does not perform any validation on the name and url elds of newly created streams in src/contract.rs:189 and 190. Although this does not have direct security related implications, these elds could be used to orchestrate phishing campaigns against unsuspecting users. Also, the name eld could be deliberately set by an attacker to confuse users, for example by setting it as an empty or very lengthy string.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Unspent tokens could be locked in the contract upon exit", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "The documentation on the execute_exit_stream function reads that it should withdraw purchased tokens to his account, and claim unspent tokens. However, the implementation only withdraws the users purchased tokens but does not check for and claim any unspent tokens. The potential impact could be considered to be major or even critical, given that a users tokens could get locked forever in the contract, but no scenario was found where the in_token amount could be greater than zero when exiting a stream. We have raised this issue as informational as, although not having found a clear exploitation path, potential edge cases may arise with future updates to the contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Lack of action along executed messages event attributes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "The streamswap contract is lacking additional event attributes labeled as action on some of its entry points responses. The functions in the following lines were aected:  src/contract.rs:59  src/killswitch.rs:167, 201, 235, and 278 Although not a security issue, some o-chain components may rely on this kind of information being broadcasted upon successful execution of a contracts message handler.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Optimization possible on multiple code paths", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "The streamswap contract currently contains minor ineciencies. While none of these issues pose a security concern, they should be addressed to further optimize the codebase. For example, when a user attempts to withdraw an amount of zero. The following functionalities can be reviewed for inecient code paths:  In src/contract.rs:266-273, updates on out_remaining and dist_index could be included in the if statement inline 276, as both will be left unchanged when the new_distribute_balance is zero. the  In src/contract.rs:295, it is inecient to include the case where the numerator is zero.  In src/contract.rs:499-501, the code never executes, as line 497 already uses info.sender to load the position. Therefore, position.owner will always be equal to info.sender.  In src/contract.rs:554, it is inecient to raise an error if withdraw_amount is equal to zero.  In src/killswitch.rs:46, it is inecient to raise an error if withdraw_amount is equal to zero.  In src/killswitch.rs:256, the assignment is redundant as the variable was already updated and saved to storage in lines 256-254.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Custom access controls implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "The streamswap contract implements custom access controls. Although no instances of broken controls or bypasses have been found, using a single assert function to validate readability and controls maintainability. risks while improving the codebases reduces potential", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Misleading error messages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "The streamswap contract includes several custom errors in src/error.rs:38, 44, 77, and 104 that raise misleading or non-meaningful information to the user. In addition, descriptive of the actual situation. the NoFundsSent custom error raised in src/contract.rs:184 is not", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "contracts/pf-dca/Cargo.toml does not enable overflow-checks for the release prole. While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Additional funds sent to the contract are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Streamswap/2023-03-16 Audit Report - Streamswap v1.1.pdf", "body": "the transaction includes In src/contract.rs:160-187, during stream creation, checks are performed that ensure two Coins with the expected out_denom and that stream_creation_denom eld (one Coin with stream_creation_denom eld if both out_denom and stream_creation_denom are the same). This validation does not ensure that no other native tokens are sent though, and any additional native tokens are not returned to the user, so they will be stuck in the contract forever. While blockchains generally do not protect users from sending funds to wrong accounts, reverting extra funds increases the user experience.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Withdrawing voting tokens will panic if amount is not set", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anchor/Audit Report - Anchor Protocol [20210406].pdf", "body": "Unwrapping contracts/gov/src/contract.rs:303 will panic if the amount is None. withdraw_voting_tokens amount the the in function in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. A validator updating its ConsumerKey to the same key causes a panic in the related consumer chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "In x/ccv/provider/keeper/key_assignment.go:505-523, during the processing the execution appends two abci.ValidatorUpdate of ConsumerKey assignments, elements to the newUpdates slice for each consumer key to replace. The rst abci.ValidatorUpdate is constructed with the old key and Power equal to zero and the second one contains the new key with the validators current Power. If a validator updates its key to the same one, the newUpdates slice will contain two elements with the same key and dierent Power, respectively zero and the current one. This would cause the related consumer chain to panic when trying to update the validator set due to the duplicated ConsumerKey in the validator set.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Attackers can DOS attack consumer chains by sending multiple coins to the provider chains reward address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "the the During execution in SendRewardsToProvider x/ccv/consumer/keeper/distribution.go:103, gets the balance of all the coins in the tstProviderAddr and sends them to the provider chain. EndBlocker, consumer function, dened chains the of In order to do so, it has to iterate through all the coins found in the reward address and send them one by one through IBC to the provider chain. Since anyone is allowed to send coins to the reward address, an attacker could create and send a large number of coins with dierent denoms to it, for example using a chain with the token factory module, in order to attack the mentioned unbounded iteration and DOS attack the chain. Consequently, the execution of the EndBlocker will take more time and resources than expected causing the consumer chain to slow down or in the worst case even halt.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Validators can slow down the provider chain by submitting multiple AssignConsumerKey messages in the same block", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "AssignConsumerKey The in x/ccv/provider/keeper/key_assignment.go:378, enables validators to assign themselves a dierent consumerKey for approved consumer chains. function, dened In order to perform this action the consumerAddrsToPrune AddressList grows by one element in line 428. this AddressList Since in x/ccv/provider/keeper/relay.go:95, it could be utilized by attackers to slow down the provider chain. EndBlocker iterated over the in is To execute such an attack, malicious actors could craft transactions with multiple AssignConsumerKey messages and spam the provider chain with those transactions. The consumerAddrsToPrune AddressList will grow of the same cardinality as the AssignConsumerKey sent messages. Consequently, the execution of the EndBlocker will take more time and resources than expected causing the provider chain to slow down or in the worst case even halt. We classify this issue as major instead of critical since the number of iterations is bounded by the maximum number of messages in a block.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. The provider chain halts on failure to send packets to a single consumer chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "the execution During SendVSCPacketsToChain x/ccv/provider/keeper/relay.go:182, panics if consumer chain. function, provider the of chains EndBlock function, dened it fails to send a packet the in to a This implies that an issue relevant only to a consumer chain will make the provider chain panic. Likewise, consumers will also panic in x/ccv/consumer/keeper/relay.go:180 because they will not be able to send packets to the provider. This evidences a single point of failure  an error occurring on a single packet for a single consumer can halt the entire ICS network. We classify this issue as major instead of critical because in the current version consumer chains, relayers, and light clients are assumed to be non-malicious.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Potential loss of rewards during consumer chain removal", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "In x/ccv/consumer/keeper/distribution.go, the reward distribution process takes place at the end of each block on the consumer chain. When the number of blocks for transmission is exceeded, the accumulated rewards are sent to the provider. If a proposal to remove or stop a consumer chain is successfully executed, the code at x/ccv/provider/keeper/proposal.go:155-232 automatically handles the removal process. This includes tasks such as cleaning up the state, closing the channel, releasing unbonding operations, and deleting all related data. However, it does not explicitly check whether the rewards associated with the consumer chain have been distributed before removing the chain. This may lead to a loss of rewards that have not been sent to the provider.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Consumer chains can DOS the provider chain by sending slash packets", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "In x/ccv/provider/keeper/throttle.go:274-276, a panic occurs if the cardinality of the queue of throttled packets is bigger than the dened MaxThrottledPackets hard cap. This behavior can be exploited by a malicious consumer chain, making the provider unable to process any further packets from other consumers. To execute such an attack, the malicious consumer chain can spam the provider chain with slash packets in order to ll the queue and cause a panic. Since the validation of slash packets in x/ccv/provider/keeper/relay.go does not disregard duplicate or other invalid slash packets, the attack can be performed for example by simply sending a valid slash packet multiple times. This could cause other consumer chains to be removed from the ICS because the provider will not receive relevant maturity notications before the timeout. We classify this issue as minor instead of major because in the current version consumer chains, relayers, and light clients are assumed to be non-malicious.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Validators can evade slashing if an equivocation proposal is submitted seven days or later after the infraction", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "When a validator performs a double-signing infraction on a consumer chain, equivocation slashing should be proposed and voted upon. Since the voting period lasts two weeks and the unbonding period is currently set to three weeks, an equivocation slashing proposal submitted seven days or later after the infraction takes place allows the validator to unbond and evade slashing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Consumer chains can expand provider chain unbonding period", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "The default unbonding period for consumer chains DefaultConsumerUnbondingPeriod is set in x/ccv/consumer/types/params.go:37 to one day less than the default unbonding period, which is currently three weeks. Since a validators unbonding matures only after all consumer chains unbondings mature, the DefaultConsumerUnbondingPeriod is chosen to ensure that the validators can unbond without any delays. However, since the consumer unbonding period is not enforced in the code to be less than the providers, consumer chains congured with a bigger unbonding period will delay the providers unbonding period.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Unbounded loop over proposals in BeginBlock could slow down block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "In x/ccv/provider/keeper/proposal.go:370 and 504, an unbounded loop is used to iterate over the ConsumerAdditionProposals and ConsumerRemovalProcess list. This loop has no set limit for the number of times it can run. Since there are no restrictions on the number of consumer chains that can be supported by the provider chain, a large number of proposals could slow down or halt the chain. We are reporting this with Minor severity since proposals go through governance voting and the likelihood of having multiple proposals with the same SpawnTime or StopTime is low.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Unbounded loops over consumer chains in EndBlock could slow down block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "When the EndBlock function is executed on the provider chain, there are several instances where the GetAllConsumerChains function is called to retrieve a list of all consumer chains. As there are no restrictions on the number of consumer chains that a provider can support, this slice can potentially be very large. The GetAllConsumerChains function is called in:  x/ccv/provider/keeper/proposal.go:60,  x/ccv/provider/keeper/proposal.go:173, and  x/ccv/provider/keeper/proposal.go:224. These unbounded lists are then iterated over to perform various operations for all active there are iterations over leadingVSCMaturedData, consumer chains. Specically, pendingPackets, and MustApplyKeyAssignmentToValUpdates. If the cardinality of these lists increases, block production may slow down, possibly even halting the chain. Operations on time-critical applications running on the network such as auctions or governance proposal execution may be delayed when a consumer chain oods the EndBlocker with fraudulent VSC matured packets, leading to a delay in block production. We are reporting this issue as Minor since consumer chains can only be added through governance.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. LastTransmissionBlockHeight is wrongly updated if the IBC token transfer fails", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "the execution During in the x/ccv/consumer/keeper/distribution.go:21, LastTransmissionBlockHeight is updated with the current timestamp even if the IBC token transfer fails. EndBlockRD function, dened the of This implies that rewards are not re-sent in the next block but in the next epoch, leading to lower rewards for unstaking validators. Also, a misleading value is stored.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Inecient removal of executed proposals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "The BeginBlock function, which is called at the beginning of every block, calls BeginBlockInit in x/ccv/provider/keeper/proposal.go:367 to get the pending consumer addition proposals and then deletes executed proposals in line 391. even the However, DeletePendingAdditionProps function is called to fetch a KVStore from the MultiStore every block, which is inecient. proposal execute, pending there no to is if This ineciency can be removed by changing the function to delete a single executed proposal and moving it inside the for loop. The same issue applies to the DeletePendingRemovalProps function called from BeginBlockCCR in x/ccv/provider/keeper/proposal.go:501.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Emitting incorrect events is misleading", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "In case of unmarshalling packet data failure in the OnRecvPacket function, the ack value will contain an error acknowledgment which is used to emit an event with AttributeKeyAckSuccess in both x/ccv/consumer/ibc_module.go:237 and x/ccv/provider/ibc_module.go:205. This is misleading for client applications and users, since a success ag can be returned along with an error. the DistributeRewardsInternally rewards distributes ConsumerRedistributeName to Similarly, in the x/ccv/consumer/keeper/distribution.go and feeCollector the ConsumerToSendToProviderName DefaultConsumerRedistributeFrac. By the time the sendRewardsToProvider function is called, feeCollector has a zero balance. Thus, in x/ccv/consumer/keeper/distribution.go:138 will always contain 0 emitted fpTokens, which again is misleading for client applications and users the emitted event according function from to", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Redundant checks are inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "The codebase contains redundant checks:  The version check in x/ccv/consumer/ibc_module.go:95 is unnecessary as it is already invoked in line 42.  The ValidateBasic function in x/ccv/provider/client/cli/tx.go:56 is the unnecessary GenerateOrBroadcastTxWithFactory function in line 60. invoked already as in is it", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Outstanding TODOs", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "There are multiple TODOs in the codebase that development: imply that the codebase is still in  x/ccv/types/expected_keepers.go:82,  x/ccv/provider/ibc_module.go:185, and  x/ccv/consumer/keeper/genesis.go:21.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Miscellaneous comments", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cosmos/2023-06-23 Audit Report - Cosmos Interchain Security v1.0.pdf", "body": "Across the codebase, instances of unused/commented code and inaccurate comments have been found. This can negatively impact the maintainability of the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. getAllPrivate function incorrectly returns public capabilities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/CapabilityProxy.cdc:62-64, the getAllPrivate function returns all capabilities stored in the self.publicCapabilities dictionary. This is incorrect because the function should return all private capabilities instead of public ones. Consequently, the function will always return incorrect types of capabilities. We classify this issue as major because it aects the correct functioning of the system.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Deny list lter allows retrieving invalid capabilities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/CapabilityFilter.cdc:44, the allowed function returns true when the capability cannot be borrowed. This is problematic because a malicious parent account can store invalid capabilities and use them once the underlying resource becomes borrowable. Consequently, this allows the parent account to bypass the lter restrictions created by the child account. to the appendix to reproduce the issue. While the provided test case Please refer demonstrates a situation in which the parent account can bypass the manager capability lter, this issue can similarly lead to bypassing the capability lter in the proxy account.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Capabilities are not checked to be valid", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In several instances of the codebase, capabilities are not validated to be borrowable before storing them. The following code locations should have the capability validated:  addCapability function in contracts/CapabilityProxy.cdc:87-94.  Initialization phase in contracts/HybridCustody.cdc:354 where the filter is not nil.  setManagerCapabilityFilter contracts/HybridCustody.cdc:418 managerCapabilityFilter is not nil. function where in the Consequently, the capabilities might fail to borrow the underlying resource reference when used, which is inecient.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Replaying publishToParent causes the ProxyAccount resource to be overwritten", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/HybridCustody.cdc:593, no validation ensures the publishToParent function is not called towards the same parent address more than once. If the function was called twice for the same parent address, the old ProxyAccount resource will be removed, the as seen in line 621. This is inecient because the child account should call removeParent function to overwrite an existing parent.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Potential incorrect owner query before ownership acceptance", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "the giveOwnership function sets the In contracts/HybridCustody.cdc:707, acctOwner to the recipient to indicate they own this child account. However, there is a possibility that the recipient does not claim the published capability from the child's account. Consequently, the getOwner function in line 690 would still show the account owner is the recipient, which is incorrect.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Removing nonexistent capabilities emits events", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "the removeType In contracts/CapabilityFilter.cdc:34-37 and lines 72-75, function removes the capability from the dictionary without checking its existence. This is problematic because the FilterUpdated event would be emitted accordingly to indicate the capability is inactive, which is incorrect. After all, the capability was never added before.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Transferring ownership does not emit an AccountUpdated event", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/HybridCustody.cdc:327-333, the giveOwnerShip function calls the child account to transfer ownership to another user. However, the AccountUpdated event is not emitted to notify event listeners that there is a change in the owned account.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Unlinking the public proxy account resource path is unnecessary", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/HybridCustody.cdc:672, the removeParent function unlinks the public path for the proxy account identier. This is unnecessary because public paths are not linked during the creation of the proxy account resource.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Named parameters are not used for known functionalities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/HybridCustody.cdc:801, the display metadata view is stored in a dictionary with a hardcoded key display. Since the eld and the functionality is already known, hardcoding the parameter can be avoided.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Duplicate function can be removed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "the getAddresses function performs the In contracts/HybridCustody.cdc:279, same action as getChildAddresses. This is inecient because calling both functions returns the same functionality and result.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Default manager capability lter cannot be updated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/HybridCustody.cdc:223, the filter variable acts as a default lter value passed to any newly added child account. Since the manager resource owner cannot modify calling the setManagerCapabilityFilter again. This can easily get complicated when the number of child accounts increases. this, any new lter to add requires the manager intends", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Codebase readability can be improved", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "The readability of contracts/HybridCustody.cdc: the project can be further improved in the following contexts in 1. The variable and function names used to denote the type of account are inconsistent across the contract. Some of them can be useful when referenced within the context it is dened but results in reduced readability in general. Consider explicitly naming the account types and identiers and keeping them consistent across the contract. For example, lines 211 and 363 use both childAccount and account to specify a child account. In this case, explicitly calling out the child's account can improve readability. 2. The seal and removeOwned functions do not sound as cautious as they need to be, possibly causing their impact to be undermined. Consider making their importance more explicit in addition to the comments already given in the contract.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. addFactory function overwrites existing types", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In contracts/CapabilityFactory.cdc:17, the function addFactory doesnt check if the type that is being added already exists or not. If the type to be added already exists, it may be overwritten by mistake.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Outstanding TODO comments in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dapper Labs/Audit Report - Hybrid Custody Smart Contracts.pdf", "body": "In several TODO. This decreases the readability of the codebase. instances of the codebase, many unimplemented functionalities are marked as", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Non-deterministic iteration may break consensus", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf", "body": "the following maps In a Cosmos SDK blockchain, non-determinism of blocks will cause the blockchain to halt. The is not deterministic: blockDistrState.Txs, iteration over blockDistrState.Contracts, in contractDistrState.TxGasUsed x/rewards/keeper/distribution.go:122, 133, 147 and 181 respectively. This can lead to consensus failure, since the order of iteration over a Go map is not guaranteed to be the same every time the program is executed. and", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Contract owners may set excessive FlatFee", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf", "body": "The SetFlatFee function in x/rewards/keeper/msg_server.go:89 does not impose an upper-bound limit on the FlatFee amount. While the FlatFee is determined by the owner of a contract, governance should dene a maximum fee to prevent excessive amounts that may impact the usability of contracts that are popular on the chain. While this is unlikely, contract owners may introduce prohibitively high fee amounts after their contract has achieved mass adoption.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Missing usage description for transaction and query CLI commands", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf", "body": "It is best practice to supply a long message for transaction and query CLI commands of a to both users and external Cosmos SDK application, since such messages are helpful developers. With the exception of getTxSetContractMetadataCmd, all transaction and query CLI commands for the rewards module in x/rewards/client/cli/tx.go:24-28 and x/rewards/client/cli/query.go:22-29 are missing long messages.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Mismatch between technical specication and implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf", "body": "The technical specication in x/rewards/spec/01_state.md:74 species that an Object is pruned (removed) at the BeginBlocker. However, objects are actually pruned in the cleanupTracking function in x/rewards/keeper/distribution.go:237-238, which is executed during the EndBlocker.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Non-standard error codes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf", "body": "to the documentation According Cosmos (https://docs.cosmos.network/main/building-modules/errors), there are restrictions on error codes. One such restriction is that error codes must be greater than one, because the value one in x/rewards/types/errors.go:8 is registered with the error code one. ErrContractNotFound errors. However, reserved internal ocial SDK for is", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Miscellaneous code quality comments", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Archway/2023-06-05 Audit Report - Archway Rewards Module v1.0.pdf", "body": "Throughout the codebase, some instances of inecient code and misleading comments have been found.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. backend-node/helpers/funcitons/utils.ts: Key size mismatch in AES encryption", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Morpher/Audit Report - Morpher Wallet [20210224].pdf", "body": "Server-side encryption only uses the top 16 bytes of the derived value as an encryption key: const key = sha256(secret).substr(0, 32); The above code derives the key as the top 32 characters of a hex string, meaning the actual keyspace is reduced to 128 bits, even though AES-256 is used.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. backend-node/helpers/functions/utils.ts: Backend encryption uses SHA-256 for key derivation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Morpher/Audit Report - Morpher Wallet [20210224].pdf", "body": "The functions encrypt() and decrypt()derive the encryption key hashing the DB_BACKEND_SALT. SHA-256 on its own is not a secure key environment variable derivation function. This issue is marked as minor since the encrypted data has already been encrypted client-side.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Email 2FA codes do not expire", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Morpher/Audit Report - Morpher Wallet [20210224].pdf", "body": "Email backend-node/controllers/wallet.controller.ts, codes 2FA are generated in function updateEmail2fa(). However, considered good practice to limit the time between rst- and second-factor authentication. these codes remain valid indenitely. is generally It", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Outdated dependencies in Backend", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Morpher/Audit Report - Morpher Wallet [20210224].pdf", "body": "versions and Outdated web3-eth-accounts npm packages are used. These modules introduce a nested dependency to an insecure version of the elliptic cryptography library. ethereumjs-util ethereumjs-tx, the for", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Outdated dependencies in SDK", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Morpher/Audit Report - Morpher Wallet [20210224].pdf", "body": "Outdated versions for the web3 and web3-provider-engine npm packages are used. Newer versions of these two modules introduce minor security xes of nested dependencies.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Consider using GCM mode for server-side encryption", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Morpher/Audit Report - Morpher Wallet [20210224].pdf", "body": "The backend uses CBC mode with PKCS#7 padding for 256-bit AES encryption. CBC mode is generally considered less secure because of its inherent vulnerability to oracle padding attacks. Whilst this type of attack should not be an issue in this particular application, GCM is generally recommended as a more secure option.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Lack of propagation of slashes to user deposits may lead to users rushing to unbond since last unbonding users may not be able to receive their stake back", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "The current architecture does not propagate slashes to user deposits, but rather relies on a slashing fund reserve to replenish slashes. That slashing fund is managed by the contract manager. There is currently no logic that reduces any users funds to account for slashes. That makes the whole protocol inherently unstable  any slashing compensation fund will eventually run out of tokens, at which point the last users to undelegate their funds will lose those funds. Rational users will anticipate that loss, which might trigger them to rush to unbond as quickly as possible. The only way to prevent this from happening is a sucient slashing fund reserve, but a rational manager would anticipate that rush and not be incentivized to replenish the reserves. The current slashing compensation is implemented as follows: The validator contracts manager can add or remove slashing funds at any time through the add_slashing_funds and remove_slashing_funds functions. Those funds are tracked in the contracts state in the slashing_funds eld. Whenever rewards are redeemed through the pools contract, the delegations of all validators are queried and a check for slashed validators is performed. If a validator got slashed, the contract uses those slashing_funds to delegate the slashed in contracts/validator/src/contract.rs:309. amount back to the validator their full deposited stake back on undelegation in Independent of slashing, users get contracts/delegator/src/contract.rs:297. As described above, this process makes the Stader protocol unstable. Apart from that, there is another issue: Slashed validators are jailed on Terra, so compensating the slashed amount will not be productive.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Validator removal happens without updating the pools contract, which leads to inconsistent state and implies that removed validators will still receive delegations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "Currently, the only way to remove validators is through the remove_validator function in the validator contract in contracts/validator/src/contract.rs:164. That implies that the validator storage of pools contract will not be updated: Validators are neither removed from the validators vector of PoolRegistryInfo, nor are they removed from the VALIDATOR_REGISTRY. Since removing a validator also leads to a re-delegation of the bonded tokens, these stake changes are not reected in the VALIDATOR_REGISTRY of the pools contract. This has several critical implications: The validator state will be inconsistent between contracts, unbonding through the pools contract will try to unbond from an already unbonded validator, and new deposits through the pools contract will be delegated to a previously removed validator through contracts/pools/src/contract.rs:231.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Rewards are double counted, leading to slashing funds being distributed as rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "In the validator contract, each validator is stored in the VALIDATOR_REGISTRY with their current stake and their accrued rewards. That accrued_rewards eld is incremented in dierent places in the contract, leading to double-counting of rewards instances are contracts/validator/src/contract.rs:238, 321, 394, 410, 490, 691, and 962. Consequently, the total calculated in contracts/validator/src/contract.rs:605 the will swap_and_transfer function transfers too many rewards, distributing funds as rewards that It will also lead to the transfer_reconciled_funds function not returning the error in line 770 even if it is expected to. should be reserved for slashing compensation. collected rewards. actually implies bigger That than that the be", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. First user to deposit rewards into an empty strategy that contains remainder tokens will lose these rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "the contracts/scc/src/helpers.rs:79, In get_strategy_shares_per_token_ratio function returns the default_s_t_ratio in the case where the total tokens in the SIC are zero. It returns zero though in the case where the token balance of the SIC is positive, but the total shares are zero in line 84. That could happen if all deposits have been redeemed, but the SIC still owns a remainder, e. g. from integer division or unclaimed rewards. In such a case, the next user to deposit tokens will not get any shares assigned in contracts/scc/src/contract.rs:1162, and hence lose their deposit.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Multiple reward coins sent to SIC auto-compound and base contracts or coins sent in wrong denom will be locked inaccessibly in contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "check The for in and contracts/sic-auto-compound/src/contract.rs:510 packages/sic-base/src/contract.rs:126 as well as the check for the wrong coin denom in lines 516 and 132 of those respective contracts do not return an Err, but rather Ok, which means that the transactions will not be reverted. Consequently, multiple coins sent multiple coins sent or coins sent in the wrong denom will not be returned, but rather locked inaccessibly in the contract.", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. Undelegating from a strategy with not sucient funds will lead to users losing (part of) their rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "in contracts/scc/src/contract.rs:487. In the undelegate_from_strategies function in the SCC contract, an iteration over all strategies is performed, sending the UndelegateRewards message for each strategy to its SIC contract. That message species the amount to be unbounded in the next undelegation batch that UndelegateRewards message in the SIC auto-compound contract checks whether enough suce in funds are available and returns an Ok message if contracts/sic-auto-compound/src/contract.rs:571. Since an Ok return value does not revert the transaction, no rewards will be undelegated from the SIC, but the SCC will be updated that the undelegation batch was processed, including updated shares and a new release time for the unbonding. No unbonding happened though, and thus users will not get the funds they should have gotten, with no way to recover. funds do not handler The for", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Replacing a validator that is receiving a redelegation will lead to loss of delegation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "When replacing a validator in the SIC auto-compound contract, only the funds in the in will can_redelegate contracts/sic-auto-compound/src/contract.rs:310. The can_redelegate eld will be zero if the outgoing validator is currently receiving a redelegation, and contain the full delegation amount otherwise. In the case where the outgoing validator receives a redelegation, no funds will be redelegated, but the validator will still be removed from the redelegated eld be validator_pool list in line 337. The delegation amount and the received redelegation will be locked in the pool due to the condition in line 268.", "labels": ["Oak Security", "Severity: High"]}, {"title": "8. Usage of stored rather than queried delegation amounts may lead to an inconsistent state when unbonding", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "The current logic that processes undelegation batches in the pool contract iterates over a pools validators in contracts/pools/src/contract.rs:413 to undelegate enough stake to satisfy the amount requested from users. That logic uses the stored stake of validators, rather than querying the currently delegated funds. This is problematic, since validators might have been slashed/jailed or decided to unbond since the storage was last updated. In those cases, the actual undelegated amount would be smaller than the amount requested by users, since Cosmos SDK caps the undelegated amount to the available amount, rather than returning an error. The pools contract would not be aware of the discrepancy, and the stored stake would be inconsistent with actual delegations.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. Util functions iterating over unordered hash maps may lead to Terra node consensus failures", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stader/2021-12-06 Audit Report - Stader v1.0.pdf", "body": "The map_to_coin_vec and map_to_deccoin_vec functions iterate over the keys of a HashMap in packages/stader-utils/src/coin_utils.rs:111, 121 as well as in packages/sic-base/src/helpers.rs:184. Since HashMap keys are returned in an arbitrary order, the resulting vector has an arbitrary order of its entries. That could lead to dierent stored data in the contract storage between Terra nodes, which might cause consensus failures.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Disabled collateral can be re-enabled by depositing on behalf of the user", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/red-bank/src/execute.rs:471, the users collateral to market bit is automatically set if the user deposits a collateral asset. An attacker can re-enable a disabled asset as collateral by depositing a small number of funds on behalf of a victim. As a result, the re-enabled collateral will get liquidated if the borrower does not maintain the sucient liquidation threshold ratio. This might cause an unexpected loss to the victim since they disabled the asset as collateral. Please see the test_enable_asset_as_collateral_for_other_users test case in the appendix to reproduce the issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Swapping assets in the reward collector contract are vulnerable to sandwich attack", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/rewards-collector/osmosis/src/route.rs:121, the minimum amount of swap output is hardcoded to zero. Due to no slippage protection, an attacker can the normal price, calling the perform a sandwich attack by purchasing the asset at SwapAsset operation to buy the asset at an increased price, then immediately selling it for a prot. The attacker can repeatedly perform this attack to force the contract into buying assets at a higher price, resulting in a loss of funds.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Red banks markets with an id greater than 128 cannot be used", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "The red bank contract can handle an indenite amount of Markets that are created by the contract owner and stored in the MARKETS mapping. Each Market struct has a unique index attribute that is responsible for indicating its bit position in borrowed_assets and collateral_assets bitmaps dened in the User struct. Since those bitmaps are Uint128, they can handle a maximum of 128 Markets. This implies that any Market with an index greater than 128 cannot be used because of an overow in contracts/red-bank/src/helpers.rs:29.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Incorrect refund address during debt repayment", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "the caller The repay function allows repayment of a loan on behalf of other accounts. In a scenario where in account contracts/red-bank/src/execute.rs:843, refund the excess amount to the target address passed in the on_behalf_of parameter and not the caller. This implies that the party repaying the loan will lose funds to the debtor. behalf the function will overpays another debt on of", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Computationally heavy unbounded loop during user position health calculation can lead to out-of-gas execution", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "contracts/red-bank/src/health.rs:121, In get_user_positions functionality attempts to loop over all markets initialized in the red bank contract. Since the is unbounded and markets cannot be removed, the execution gets more market count expensive with the number of markets and might eventually run out of gas if there are too many markets initialized. the This issue is also present in the UserDebts and UserCollaterals query messages in contracts/red-bank/src/query.rs:123-149 and 164-180. The queries attempt to loop through all markets without any pagination limit.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Address provider contract does not validate the newly set owner as valid address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/address-provider/src/contract.rs:77, the contract owner is set to the new_owner string provided by the caller. If the new owner is not a valid address, it will cause the address provider contract to have an invalid owner. As a result, it would prevent the SetAddress and TransferOwnership functionality from working correctly. We consider misconguration. this a minor", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Users will be unable to claim rewards if too many asset incentives are added", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In the incentives contract, users can call ClaimReward to retrieve their accrued Mars rewards. The message is handled by the compute_user_unclaimed_rewards function in line contracts/incentives/src/helpers.rs:84 which loops through all the asset incentives. On a long enough timeframe, if many assets get added to the protocol, this gets more expensive and could eventually run out of gas and hence block claiming of rewards for a given user.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Addresses are not validated if a wrong prefix is set in the address-provider contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "contracts/address-provider/src/helpers.rs:11, the In assert_valid_addr function is executed, all addresses that start with a prefix dierent from the stored one are assumed to be valid without executing api.addr_validate. when This implies that invalid addresses can be stored in the contract mapping and that the check on the given prefix can be bypassed.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Setting price source for liquidity token aects Prices query message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/oracle/osmosis/src/price_source.rs:125-127, the liquidity token price source cannot be queried as it will return an Unimplemented error. However, the contract owner can add a liquidity token price source in lines 97-99. This means that the Prices query message would be aected since it includes the liquidity token price source when querying. Note that users can manually avoid querying the LiquidityToken price source by ltering out the aected entry with the start_after and limit arguments. Please see the  test_query_liquidity_token_prices test case in the appendix to reproduce this issue.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Markets reserve_factor attribute is not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In packages/outpost/src/red_bank/market.rs:79, the validate method for the Market struct is not checking reserve_factor. Since this attribute represents the percentile of the borrow rate that is kept as protocol rewards, a value greater than one could cause the execution to distribute an incorrect amount of funds. We consider this issue to be minor since only the owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Contracts are not compliant with CW2 Migration specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "The following contracts do not adhere to the CW2 Migration specication standard:  address-provider  oracle  incentives  red-bank  rewards-collector This may lead to unexpected problems during contract migration and code version handling.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Unversioned dependencies could lead to supply chain attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "oracle The contracts/oracle/osmosis/Cargo.toml:37. requires contract osmo-bindings as a dependency in Since it is fetching it directly from the GitHub repository without specifying the wanted commit hash or tag, any changes to that repositorys main branch may accidentally be included in the contract. This could lead to bugs as well as supply chain attacks.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. optimal_utilization_ratio value could cause a division by zero panic if not correctly validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In the packages/outposts/src/red_bank/interest_rate_model.rs:35, divide_decimal_by_decimal is dividing the current_utilization_rate by optimal_utilization_rate. Since optimal_utilization_rate is not validated to be greater than zero, this division could cause a panic.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Zero Mars token code identier will lead to InitAsset failures", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/red-bank/src/execute.rs:60, when conguring the Mars token code identier, it is not validated to not be zero. If the code identier is congured as zero, it will cause the InitAsset functionality to fail. This issue is also present in line 103 when updating the conguration.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Liquidator is unable to specify the receiver address which negatively impacts integrations and exibility", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/red-bank/src/contract.rs:72, there is no way for the liquidator to specify the recipient address for receiving underlying collateral. This will add overhead for periphery contracts to specify the logic for redirecting the liquidated assets transfers to rightful liquidators.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Avoid meaningless conguration update", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/oracle/base/src/contract.rs:113, the contract owner can update the execution will be the conguration with the owner value as None. As a result, to the meaningless because the option_string_to_addr functionality will default original conguration owner. This would cause no changes to be modied in the end.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. InvalidDepositAmount validation during red bank deposit can be removed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In contracts/red-bank/src/execute.rs:459-464, the check ensures the deposit amount is not zero when depositing in the red bank. This check is unnecessary as the one_coin functionality from cw_utils already prevents zero amounts, as seen in contracts/red-bank/src/contract.rs:53.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "The following packages and contracts do not enable overflow-checks for the release prole:  contracts/address-provider/Cargo.toml  contracts/oracle/base/Cargo.toml  contracts/oracle/osmosis/Cargo.toml  contracts/incentives/Cargo.toml  contracts/red-bank/Cargo.toml  contracts/rewards-collector/base/Cargo.toml  contracts/rewards-collector/osmosis/Cargo.toml While enabled implicitly through the workspace manifest, future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Contracts should implement a two step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "20. TWAPs are more sensitive to manipulation than median prices in \"one-block\" attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "In a \"one-block\" attack, an attacker manipulates the price of an asset and then arbitrages it back in the next block. This type of attack is possible when the attacker knows in advance to be the creator for the next block (e.g. the attacker is a validator in PoS blockchains with deterministic slots) since the validators can order transactions to minimize the risk of the attack. Because TWAPs are calculated using the time-weighted average of prices, a \"one-block\" attack will have a greater impact on the TWAP calculation than on the median price. This is because the manipulated price will be included in the TWAP calculation, whereas it will not aect the median price. Therefore, TWAPs are more sensitive to manipulation than median prices in \"one-block\" attacks.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "21. Custom access control implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2023-01-13 Audit Report - Mars Outposts v1.0.pdf", "body": "Contracts implement custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Subwallet factory updates could lead to inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "During the creation of a subwallet, the addresses of the Anchor Money Market and Terra token contracts are passed from the subwallet factory cong to the newly instantiated wallet - see contracts/subwallet-factory/src/contract.rs:107. These addresses are then stored in the cong of the new subwallet. The subwallet factory contract owner is able to update the addresses of the Anchor Money Market and Terra token. These changes would not be reected in the existing subwallets. This could lead the subwallets to use incorrect addresses for the Anchor market and Terra token.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Product factory updates could lead to inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "During the creation of a xed recurring subscription contract the address of the job registry contract see contracts/sub1-fixed-recurring-subscriptions/src/contract.rs:74. This address is then stored in the cong of the subscription contract. specied is - The product factory contract is able to update the address of the job registry contract. This change would not be reected in the existing recurring subscription contract  unlike the protocol fee and other conguration parameters dened in the product factory, which are queried prior to use rather than stored. This could lead the subscriptions to use an incorrect address for the job registry contract.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Protocol fee decimal places incorrectly specied", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "The protocol fee is dened in basis points during instantiation of the product-factory contract cong. During both, the instantiation and update of the cong, the protocol fee is veried to ensure that is less than the maximum of 5%. As the fee is represented in basis points 5% is dened as 500, which implies that in xed-point arithmetic 4 decimal places are being used - i.e. 500 / 10,000 = 0.05. On lines sub1-fixed-recurring-subscriptions/src/contract.rs:346 and 697, decimal places are applied incorrectly when calculating the ratio of the protocol fee. In each case, the protocol fee could be greater than 100%. Which could lead to users being charged excessive amounts for using the protocol.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Owner cannot freeze admins", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "the function executing When in contracts/admin-core/src/contract.rs:84, the contract veries that the sender is a whitelisted admin. Once this function is executed the contract owner will be unable to append new admins or otherwise unfreeze the admin list. This is contrary to the documentation denition of the owner being the highest-privilege access. execute_freeze, found as Further access verication to the execute_freeze function uses the can_modify function which checks that the sender is on the admin list. However, in the case that the owners address is not on said list this check would fail. Preventing the owner from successfully calling the execute_freeze function.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Owner cannot execute set permissions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "le contracts/subwallet/src/contract.rs:389 In function execute_set_permissions veries that the message sender is an admin whitelisted for the wallet. However, if the sender is the owner and not present on the admin whitelist then the execution will fail. As the owner has the highest-privilege access to a wallet this is contrary to the documentation. the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Admin whitelist cannot be unfrozen", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "le contracts/admin-core/src/contract.rs:54 In function execute_freeze freezes the list of whitelisted admins for a suberra wallet. Once frozen there is no way to reverse this decision, even for the wallet owner. It may be necessary to remove, or add, an admin due to scenarios such as the case of a leaked private key. the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Protocol fee decimal places should be dened as constants", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "The protocol fee is dened in basis points during instantiation of the product-factory contract cong. During both, the instantiation and update of the cong, the protocol fee is veried to ensure that is less than the maximum of 5%. As the fee is represented in basis points 5% is dened as 500, which implies that in xed-point arithmetic 4 decimal places are being used - i.e. 500 / 10,000 = 0.05. However, throughout the code base, there is no constant variable dened to use in protocol fee calculations. Rather values are used on an ad-hoc basis, including:  sub1-fixed-recurring-subscriptions/src/contract.rs:271  sub1-fixed-recurring-subscriptions/src/contract.rs:346  sub1-fixed-recurring-subscriptions/src/contract.rs:697  sub2-p2p-recurring-transfers/src/contract.rs:451", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Unbounded number of contract admins", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "There is no limit dened in contracts/admin-core/src/state.rs:10 to the number of addresses that can be whitelisted as Suberra wallet admins. Should the number of admins be excessively large this could make execution functions costly and query functions unperformant. In extreme cases, this could cause the querier to run out of gas.", "labels": ["Oak Security", "Severity: Informational"]}]