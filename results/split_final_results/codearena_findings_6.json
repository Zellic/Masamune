[{"title": "Missing consistent zero address checks", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/263", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  Some functions in RocketJoeFactory.sol have zero checks for setting specific state variables, but there zero address checks are not always applied. Setting some of these state variables to the zero address, whether intentional or not, can break the protocol functionality. Adding these checks consistently would prevent this scenario.  ## Proof of Concept  The [constructor in RocketJoeFactory.sol](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L53-L61) performs zero address checks before setting the router, factory, penaltyCollector, and rJoe state variables.  Later in the same contract, the functions `setRJoe()`, `setPenaltyCollector()`, `setRouter()`, and `setFactory()` [omit the same zero address checks](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L159-L188) that were applied earlier. Since the issues that can be caused by setting these state variables to the zero address exist whether setting the value in the constructor or in the setter function, these checks should be applied consistently.  ## Recommended Mitigation Steps  Add zero address checks in the setter functions for these state variables just like is done in the constructor. If it is determined that a zero check for any of these state variables is not needed, then the zero check can be removed from the RocketJoeFactory.sol constructor for consistency.  "}, {"title": "Functions can be external", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/262", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `withdrawAVAX()` function of LaunchEvent.sol and `initialize()` function of RocketJoeStaking.sol can be declared external for gas savings  ## Proof of Concept  - [withdrawAVAX](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L349) - [initialize](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L57)  ## Recommended Mitigation Steps  Declare functions as external instead of public when possible  "}, {"title": "Improper Upper Bound Definition on the Fee", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/255", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact The `rJoePerSec` does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L151 ``` function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {         updatePool();         rJoePerSec = _rJoePerSec;         emit UpdateEmissionRate(msg.sender, _rJoePerSec);     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Consider define  upper and lower bounds on the `_rJoePerSec`.  "}, {"title": "`createRJLaunchEvent()` Multiple `launchEvent` can be created unexpectedly by reentrancy", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/248", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/119e12d715ececc31478e833297f124cc15d27c2/contracts/RocketJoeFactory.sol#L97-L154  ```solidity function createRJLaunchEvent(     address _issuer,     uint256 _phaseOneStartTime,     address _token,     uint256 _tokenAmount,     uint256 _tokenIncentivesPercent,     uint256 _floorPrice,     uint256 _maxWithdrawPenalty,     uint256 _fixedWithdrawPenalty,     uint256 _maxAllocation,     uint256 _userTimelock,     uint256 _issuerTimelock ) external override returns (address) {     require(         getRJLaunchEvent[_token] == address(0),         \"RJFactory: token has already been issued\"     );     require(_issuer != address(0), \"RJFactory: issuer can't be 0 address\");     require(_token != address(0), \"RJFactory: token can't be 0 address\");     require(_token != wavax, \"RJFactory: token can't be wavax\");     require(         _tokenAmount > 0,         \"RJFactory: token amount needs to be greater than 0\"     );     require(         IJoeFactory(factory).getPair(_token, wavax) == address(0) ||             IJoePair(IJoeFactory(factory).getPair(_token, wavax))                 .totalSupply() ==             0,         \"RJFactory: liquid pair already exists\"     );      address launchEvent = Clones.clone(eventImplementation);      // msg.sender needs to approve RocketJoeFactory     IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);      ILaunchEvent(payable(launchEvent)).initialize(         _issuer,         _phaseOneStartTime,         _token,         _tokenIncentivesPercent,         _floorPrice,         _maxWithdrawPenalty,         _fixedWithdrawPenalty,         _maxAllocation,         _userTimelock,         _issuerTimelock     );      getRJLaunchEvent[_token] = launchEvent;     isRJLaunchEvent[launchEvent] = true;     allRJLaunchEvents.push(launchEvent);      _emitLaunchedEvent(_issuer, _token, _phaseOneStartTime);      return launchEvent; } ```  At L132, `_token.transferFrom()` can be used to re-enter the `createRJLaunchEvent()` function, before the storage change at L147-149.  This will allow the attacker to create multiple `launchEvent` contracts and get them listed in `allRJLaunchEvents`.  Even though there is no significant impact as far as we can tell from the smart contract code. We believe this is still unexpected and may cause other parts of the system, say the frontend to malfunction in some cases.  ### Recommendation  Consider moving L132 `_token.transferFrom()` to after L147-149 to prevent re-entrance.  "}, {"title": "`RocketJoeFactory.sol#createRJLaunchEvent()` Check of `_issuer != address(0)`, `_token != address(0)`, `_tokenAmount > 0` can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/245", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L98-L155  ```solidity     function createRJLaunchEvent(         address _issuer,         uint256 _phaseOneStartTime,         address _token,         uint256 _tokenAmount,         uint256 _tokenIncentivesPercent,         uint256 _floorPrice,         uint256 _maxWithdrawPenalty,         uint256 _fixedWithdrawPenalty,         uint256 _maxAllocation,         uint256 _userTimelock,         uint256 _issuerTimelock     ) external override returns (address) {         require(             getRJLaunchEvent[_token] == address(0),             \"RJFactory: token has already been issued\"         );         require(_issuer != address(0), \"RJFactory: issuer can't be 0 address\");         require(_token != address(0), \"RJFactory: token can't be 0 address\");         require(_token != wavax, \"RJFactory: token can't be wavax\");         require(             _tokenAmount > 0,             \"RJFactory: token amount needs to be greater than 0\"         );         require(             IJoeFactory(factory).getPair(_token, wavax) == address(0) ||                 IJoePair(IJoeFactory(factory).getPair(_token, wavax))                     .totalSupply() ==                 0,             \"RJFactory: liquid pair already exists\"         );         // ...     } ```  `_issuer != address(0)`, `_token != address(0)`, `_tokenAmount > 0` are cheaper than other checks who read storage or do external call.   Therefore, checking `_issuer != address(0)`, `_token != address(0)`, `_tokenAmount > 0` first can save some gas.   ### Recommendation  Change to:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L98-L155  ```solidity     function createRJLaunchEvent(         address _issuer,         uint256 _phaseOneStartTime,         address _token,         uint256 _tokenAmount,         uint256 _tokenIncentivesPercent,         uint256 _floorPrice,         uint256 _maxWithdrawPenalty,         uint256 _fixedWithdrawPenalty,         uint256 _maxAllocation,         uint256 _userTimelock,         uint256 _issuerTimelock     ) external override returns (address) {         require(_issuer != address(0), \"RJFactory: issuer can't be 0 address\");         require(_token != address(0), \"RJFactory: token can't be 0 address\");         require(             _tokenAmount != 0,             \"RJFactory: token amount needs to be greater than 0\"         );         require(             getRJLaunchEvent[_token] == address(0),             \"RJFactory: token has already been issued\"         );         require(_token != wavax, \"RJFactory: token can't be wavax\");         require(             IJoeFactory(factory).getPair(_token, wavax) == address(0) ||                 IJoePair(IJoeFactory(factory).getPair(_token, wavax))                     .totalSupply() ==                 0,             \"RJFactory: liquid pair already exists\"         );         // ...     } ```  "}, {"title": "`Ownable` library is redundant", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/241", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L19-L19  ```solidity contract LaunchEvent is Ownable { ```  The `LaunchEvent.sol` contract never utilized `onlyOwner` / `owner()` or any other features provided by the `Ownable` library.  Therefore, `is Ownable` can be removed.   "}, {"title": "\"> 0\" is less efficient than \"!= 0\" for unsigned integers", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/240", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  WatchPug   # Vulnerability details  It is cheaper to use `!= 0` than `> 0` for uint256.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L101-L101  ```solidity if (user.amount > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L119-L119  ```solidity _tokenAmount > 0, ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L338-L338  ```solidity if (rJoeNeeded > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L355-L355  ```solidity require(_amount > 0, \"LaunchEvent: invalid withdraw amount\"); ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L370-L370  ```solidity if (feeAmount > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L455-L455  ```solidity if (tokenReserve > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L537-L537  ```solidity if (excessToken > 0) { ```  "}, {"title": "Cache external call results can save gas", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/236", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  `factory.getPair(wavaxAddress, tokenAddress)` and `factory.getPair(tokenAddress, wavaxAddress)` in `LaunchEvent#createPair()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L377-L435  ```solidity function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {     // ...     require(         factory.getPair(wavaxAddress, tokenAddress) == address(0) ||             IJoePair(                 IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)             ).totalSupply() ==             0,         \"LaunchEvent: liquid pair already exists\"     );     // ...     pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));     // ... } ```  note: `factory.getPair(a, b)` \u4e0e  `factory.getPair(b, a)` \u76f8\u540c, see  [code at github](https://github.com/traderjoe-xyz/joe-core/blob/5c2ca96c3835e7f2660f2904a1224bb7c8f3b7a7/contracts/traderjoe/JoeFactory.sol#L41-L42) or [code at avascan](https://avascan.info/blockchain/c/address/0x9Ad6C38BE94206cA50bb0d90783181662f0Cfa10/contract#:~:text=getPair%5Btoken1%5D%5Btoken0%5D%20%3D%20pair%3B%20//%20populate%20mapping%20in%20the%20reverse%20direction)  ```solidity getPair[token0][token1] = pair; getPair[token1][token0] = pair; // populate mapping in the reverse direction ```  `IJoeFactory(factory).getPair(_token, wavax)` in `RocketJoeFactory#createRJLaunchEvent()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L122-L128  ```solidity require(     IJoeFactory(factory).getPair(_token, wavax) == address(0) ||         IJoePair(IJoeFactory(factory).getPair(_token, wavax))             .totalSupply() ==         0,     \"RJFactory: liquid pair already exists\" ); ```   `token.decimals()` in `LaunchEvent#createPair()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L395-L405  ```solidity if (     floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated ) {     tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;     // ... } ```  "}, {"title": "Redundant type casting", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/235", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L82-L82  ```solidity IJoeFactory private factory; ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L385-L385  ```solidity IJoeFactory(factory).getPair(wavaxAddress, tokenAddress) ```  `factory` is defined as `IJoeFactory` already, the type casting is redundant.  "}, {"title": "Code Style: non-constant should not be named in all caps", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/230", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  WatchPug   # Vulnerability details  Non-constant (especially public) variables should not be in `SCREAMING_SNAKE_CASE`, or they may be misunderstood as constants.  Consider changing to `camelCase`.  See: https://docs.soliditylang.org/en/v0.8.11/style-guide.html?highlight=name#local-and-state-variable-names  Instances include:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/interfaces/IRocketJoeFactory.sol#L35-L39  ```solidity function PHASE_ONE_DURATION() external view returns (uint256);  function PHASE_ONE_NO_FEE_DURATION() external view returns (uint256);  function PHASE_TWO_DURATION() external view returns (uint256); ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L29-L31  ```solidity uint256 public override PHASE_ONE_DURATION = 2 days; uint256 public override PHASE_ONE_NO_FEE_DURATION = 1 days; uint256 public override PHASE_TWO_DURATION = 1 days; ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L200-L214  ```solidity function setPhaseDuration(uint256 _phaseNumber, uint256 _duration)     external     override     onlyOwner {     if (_phaseNumber == 1) {         require(             _duration > PHASE_ONE_NO_FEE_DURATION,             \"RJFactory: phase one duration lower than no fee duration\"         );         PHASE_ONE_DURATION = _duration;     } else if (_phaseNumber == 2) {         PHASE_TWO_DURATION = _duration;     } } ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L218-L228  ```solidity function setPhaseOneNoFeeDuration(uint256 _noFeeDuration)     external     override     onlyOwner {     require(         _noFeeDuration < PHASE_ONE_DURATION,         \"RJFactory: no fee duration bigger than phase one duration\"     );     PHASE_ONE_NO_FEE_DURATION = _noFeeDuration; } ```  "}, {"title": "Gas: `RocketJoeStaking.withdraw`", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/210", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  `RocketJoeStaking.withdraw`: The `_safeRJoeTransfer(msg.sender, pending)` only needs to be performed if `pending > 0`.  "}, {"title": "Misleading comment in `LaunchEvent.getReserves`", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/209", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  `LaunchEvent.getReserves`: The comment says: `@notice Returns the current balance of the pool`. The \"of the pool\" part can be misleading as the `tokenIncentivesBalance` are never part of the _pool pair_. Consider changing this to \"Returns the outstanding balance of the launch event contract\".  "}, {"title": "`LaunchEvent.tokenIncentivesPercent` wrong docs", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/208", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  `LaunchEvent.tokenIncentivesPercent`: The math in the comment is wrong: `/// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives`. It should be `105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives`  "}, {"title": "Uninitialized `RocketJoeStaking.lastRewardTimestamp` can inflate `rJoe` supply", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/202", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  The `RocketJoeStaking.lastRewardTimestamp` is initialized to zero. Usually, this does not matter as `updatePool` is called before the first deposit and when `joeSupply = joe.balanceOf(address(this)) == 0`, it is set to the current time.  ```solidity function updatePool() public {     if (block.timestamp <= lastRewardTimestamp) {         return;     }     uint256 joeSupply = joe.balanceOf(address(this));      // @audit lastRewardTimestamp is not initialized. can send 1 Joe to this contract directly => lots of rJoe minted to this contract     if (joeSupply == 0) {         lastRewardTimestamp = block.timestamp;         return;     }     uint256 multiplier = block.timestamp - lastRewardTimestamp;     uint256 rJoeReward = multiplier * rJoePerSec;     accRJoePerShare =         accRJoePerShare +         (rJoeReward * PRECISION) /         joeSupply;     lastRewardTimestamp = block.timestamp;      rJoe.mint(address(this), rJoeReward); } ```  However, if a user first directly transfers `Joe` tokens to the contract before the first `updatePool` call, the `block.timestamp - lastRewardTimestamp = block.timestamp` will be a large timestamp value and lots of `rJoe` will be minted (but not distributed to users). Even though they are not distributed to the users, inflating the `rJoe` total supply might not be desired.  #### Recommendation Consider tracking the actual total deposits in a storage variable and using this value instead of the current balance for `joeSupply`. This way, transferring tokens to the contract has no influence and depositing through `deposit` first calls `updatePool` and initializes `lastRewardTimestamp`.   "}, {"title": "`rJoeAmount` can never be less than the `_avaxAmount`", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/201", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LaunchEvent.rJoePerAvax` variable is an _unscaled_ integer value and used to compute the `rJoeAmount` as:  ```solidity function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {     return _avaxAmount * rJoePerAvax; } ```  This means the required `rJoeAmount` to burn can never be less than the deposited `avaxAmount`. If a launch event desires to use `0.5 rJoe` per AVAX, this is not possible.  #### Recommendation Consider the `rJoePerAvax` value as a value scaled by `1e18` and then divide by this scale in `getRJoeAmount` again.  "}, {"title": "Users can lose value in emergency state", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/199", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  Imagine the following sequence of events:  - `LaunchEvent.createPair()` is called which sets `wavaxReserve = 0`, adds liquidity to the pair and receives `lpSupply` LP tokens. - `LaunchEvent.allowEmergencyWithdraw()` is called which enters emergency / paused mode and disallows normal withdrawals. - Users can only call `LaunchEvent.emergencyWithdraw` which reverts as the WAVAX reserve was already used to provide liquidity and cannot be paid out. Users don't receive their LP tokens either. The users lost their entire deposit in this case.  #### Recommendation Consider paying out LP tokens in `emergencyWithdraw`.   "}, {"title": "Pair creation can be denied", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/197", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LaunchEvent.createPair` requires that no previous pool was created for the `WAVAX <> _token` pair.  ```solidity function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {     (address wavaxAddress, address tokenAddress) = (         address(WAVAX),         address(token)     );     // @audit grief: anyone can create pair     require(         factory.getPair(wavaxAddress, tokenAddress) == address(0),         \"LaunchEvent: pair already created\"     );      // ... } ```  A griefer can create a pool for the `WAVAX <> _token` pair by calling [`JoeFactory.createPair(WAVAX, _token)`](https://snowtrace.io/address/0x9ad6c38be94206ca50bb0d90783181662f0cfa10#contracts) while the launch event phase 1 or 2 is running. No liquidity can then be provided and an emergency state must be triggered for users and the issuer to be able to withdraw again.  #### Recommendation It must be assumed that the pool is already created and even initialized as pool creation and liquidity provisioning is permissionless. Special attention must be paid if the pool is already initialized with liquidity at a different price than the launch event price.  It would be enough to have a standard min. LP return \"slippage\" check (using parameter values for `amountAMin/amountBMin` instead of the hardcoded ones in `router.addLiquidity`) in `LaunchEvent.createPair()`. The function must then be callable with special privileges only, for example, by the issuer. Alternatively, the slippage check can be hardcoded as a percentage of the raised amounts (`amountADesired = 0.95 * wavaxReserve, amountBDesired = 0.95 * tokenAllocated`).  This will prevent attacks that try to provide LP at a bad pool price as the transaction will revert when receiving less than the slippage parameter. If the pool is already initialized, it should just get arbitraged to the auction token price and liquidity can then be provided at the expected rate again.   "}, {"title": "Wrong token allocation computation for token decimals != 18 if floor price not reached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/193", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  In `LaunchEvent.createPair`, when the floor price is not reached (`floorPrice > wavaxReserve * 1e18 / tokenAllocated`), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price.  Note that the `floorPrice` is supposed to have a precision of 18:  > /// @param _floorPrice Price of each token in AVAX, scaled to 1e18  The `floorPrice > (wavaxReserve * 1e18) / tokenAllocated` check is correct but the `tokenAllocated` computation involves the `token` decimals:  ```solidity // @audit should be wavaxReserve * 1e18 / floorPrice tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice; ```  This computation does not work for `token`s that don't have 18 decimals.  #### Example Assume I want to sell `1.0 wBTC = 1e8 wBTC` (8 decimals) at `2,000.0 AVAX = 2,000 * 1e18 AVAX`. The `floorPrice` is `2000e18 * 1e18 / 1e8 = 2e31`  Assume the Launch event only raised `1,000.0 AVAX` - half of the floor price for the issued token amount of `1.0 WBTC` (it should therefore allocate only half a WBTC) - and the token amount will be reduced as: `floorPrice = 2e31 > 1000e18 * 1e18 / 1e8 = 1e31 = actualPrice`. Then, `tokenAllocated = 1000e18 * 1e8 / 2e31 = 1e29 / 2e31 = 0` and no tokens would be allocated, instead of `0.5 WBTC = 0.5e8 WBTC`.  The computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice = 1000e18 * 1e18 / 2e31 = 1e39 / 2e31 = 10e38 / 2e31 = 5e7 = 0.5e8`.  #### Recommendation The new `tokenAllocated` computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice;`.   "}, {"title": "The contracts use unlocked pragma", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/181", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  As different compiler versions have critical behavior specifics if the contract gets accidentally deployed using another compiler version compared to one they tested with, various types of undesired behavior can be introduced.  ## Proof of Concept  All the contracts in scope use unlocked pragma: ```pragma solidity ^0.8.0```, allowing wide enough range of versions.  Examples:  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L4  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeToken.sol#L3   ## Recommended Mitigation Steps  Consider locking compiler version, for example `pragma solidity 0.8.6`.  This can have additional benefits, for example using custom errors to save gas and so forth.  "}, {"title": "LP Tokens May Be Locked in Contract Due to `allowEmergencyWithdraw()` in Stage 3", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/169", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  The function [allowEmergencyWithdraw()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L520) may be called by the `rocketJoeFactory.owner()` at any time. If it is called while the protocol is in Stage 3 and a pair has been created then the LP tokens will be locked and both issues and depositors will be unable to withdraw.  ## Proof of Concept  If `allowEmergencyWithdraw()`  is called `stopped` is set to `true`. As a result functions [withdrawIncentives()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L468) and [withdrawLiquidity()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L438) will revert due to the `isStopped(false)` modifier reverting.  Additionally, [emergencyWithdraw()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L494) will revert since all the `WAVAX` and `token` balances have been transferred to the liquidity pool.  Thus, depositors and issuers will have no methods of removing their LP tokens or incentives.   ## Recommended Mitigation Steps  Consider adding the requirement `require(address(pair) != address(0), \"LaunchEvent: pair not created\");` to the function `allowEmergencyWithdraw()`.  "}, {"title": "Gas Optimisation - Simplify `_atPhase()` Logic", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  The logic in [_atPhase()`](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L590) can be simplified to save gas and code complexity.  The code can be simplified to the follwoing.  ```solidity     function _atPhase(Phase _phase) internal view {             require(currentPhase() == _phase, \"LaunchEvent: incorrect phase\");     } ```  ## Proof of Concept  n/a  ## Tools Used  n/a  ## Recommended Mitigation Steps  Consider updating the code to that procided above.  "}, {"title": "Wrong comment", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/149", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  wuwe1   # Vulnerability details  ## Impact Causing confuse to user and developer.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L55  `105000 * 1e18 / (1e18 + 5e16)` is equal to `100000`    ## Recommended Mitigation Steps  change to  `105000 - 105000 * 1e18 / (1e18 + 5e16) = 5000`  "}, {"title": "Missing event emitting", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/148", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  wuwe1   # Vulnerability details  ## Impact Off-chain tools will not work as expected.  ## Proof of Concept  Missing UserWithdrawn  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L132](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L132)  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L372](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L372)  Missing IssuingTokenDeposited  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L124](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L124)  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L287](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L287)   ## Recommended Mitigation Steps  Add `emit UserWithdrawn(user, amountMinusFee)` after L372  Add `emit IssuingTokenDeposited(_token, balance)` after L287  "}, {"title": "Missing divide by 0 check on tokenAllocated", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/140", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact A division by 0 could occur  ## Proof of Concept There are no checks that the denominator is `!= 0` here: ``` File: LaunchEvent.sol 392:         uint256 tokenAllocated = tokenReserve; 393:  394:         // Adjust the amount of tokens sent to the pool if floor price not met 395:         if ( 396:             floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated 397:         ) { ```  tokenReserve (`uint256 tokenAllocated = tokenReserve;`) can be equal to 0 according to this comment: https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L106  Therefore this could happen  ## Tools Used VS Code  ## Recommended Mitigation Steps Check for `tokenAllocated != 0` before this division  "}, {"title": "Re-enterable Code When Making a Deposit to Stake", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/127", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  Note: this attack requires `rJoe` to relinquish control during `tranfer()` which under the current [RocketJoeToken](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeToken.sol) it does not. Thus this vulnerability is raised as medium rather than high. Although it's not exploitable currently, it is a highly risky code pattern that should be avoided.  This vulnerability would allow the entire rJoe balance to be drained from the contract.  ## Proof of Concept  The function [deposit()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L96) would be vulnerable to reentrancy if rJoe relinquished control flow.  The following lines show the reward calculations in variable `pending`. These calculations use two state variables `user.amount` and `user.rewardDebt`. Each of these are updated after `_safeRJoeTransfer()`.  Thus if an attacker was able to get control flow during the `rJoe::tranfer()` function they would be able to reenter `deposit()` and the value calculated for `pending`would be the same as the previous iteration hence they would again be transferred `pending` rJoe tokens. During the rJoe transfer the would again gain control of the execution and call `deposit()` again. The process could be repeated until the entire rJoe balance of the contract has been transferred to the attacker.  ```solidity         if (user.amount > 0) {             uint256 pending = (user.amount * accRJoePerShare) /                 PRECISION -                 user.rewardDebt;             _safeRJoeTransfer(msg.sender, pending);         }         user.amount = user.amount + _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION; ```   ## Tools Used  n/a  ## Recommended Mitigation Steps  There are two possible mitigations. First is to use the [openzeppelin reentrancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) over the `deposit()` function which will prevent multiple deposits being made simultaneously.  The second mitigation is to follow the [checks-effects-interactions](https://docs.soliditylang.org/en/v0.8.11/security-considerations.html#re-entrancy) pattern. This would involve updating all state variables before making any external calls.  "}, {"title": "Useless storage variable", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  `pendingRJoe()` reads a user into a storage variable, which is redundant since it\u2019s a `view()` function and the variable is never modified in place. It can be replaced by a `memory` variable for readability  ## Proof of Concept  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L82](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L82)  ## Tools Used  Editor  ## Recommended Mitigation Steps  ```jsx UserInfo memory user = userInfo[_user]; ```  "}, {"title": "instead of using && in require. just use require multiple time", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeFactory.sol#L53-L59 && operator cost more gas. ## Tools Used  ## Recommended Mitigation Steps use require multiple times instead of && ``` require(_eventImplementation != address(0), \"RJFactory: Addresses can't be null address\"); require(_rJoe != address(0),  \"RJFactory: Addresses can't be null address\"); ...  ```  "}, {"title": "Explicit initialisation variable wastes gas.", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  LaunchEvent has an explicit `initialized` variable which is in storage. https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L228  To save an SSTORE we could just check that `_auctionStart > 0` as this is a sufficient check for initialisation. If a getter is needed then a function like the below could be added.  ``` function initialized() external view returns bool {   return auctionStart > 0; } ```  ## Recommended Mitigation Steps  As above.  "}, {"title": "LaunchEvent pays out fewer incentives then expected", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  LaunchEvent pays out fewer incentives than expected.  ## Proof of Concept  When creating a launch event, issuers must provide the total amount of tokens they want to send to the contract and what percentage of these are reserved for incentives.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L84-L86  Note that there's an inconsistency between the documentation and the implementation. Documentation implies that the issuer provides `_tokenAmount` tokens and an additional `_tokenAmount * _tokenIncentivesPercent / 1e18` as an incentive whereas in reality they only provide `_tokenAmount`   This can be seen here:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L133  For us to pay out the correct percentage of `_tokenAmount` as incentives would expect that amount to be `(_tokenAmount * _tokenIncentivesPercent) / 1e18` however as can be seen we pay out `_tokenAmount - (_tokenAmount * 1e18) / (1e18 + _tokenIncentivesPercent)`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L273  This will consistently pay out a smaller percentage of the total amount of tokens than `_tokenIncentivesPercent`.  ## Recommended Mitigation Steps  Switch to having the issuer provide explicit amounts `_tokenIssuanceAmount` and `_tokenIncentivesAmount` to avoid mistakes about how percentages are handled.  Add tests to ensure that the contract is initialised with the correct state.  "}, {"title": "Missing Sanity Checks Will Cause To Revert On the Function", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/71", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  In the JoeStaking contract, the amount check should be placed on the contract. IF the amount is more than transfer operations should be completed.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L129  2. _amount is not checked if Its more than zero.  ```     function withdraw(uint256 _amount) external {         UserInfo storage user = userInfo[msg.sender];         require(             user.amount >= _amount,             \"RocketJoeStaking: withdraw amount exceeds balance\"         );          updatePool();          uint256 pending = (user.amount * accRJoePerShare) /             PRECISION -             user.rewardDebt;          user.amount = user.amount - _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;          _safeRJoeTransfer(msg.sender, pending);         joe.safeTransfer(address(msg.sender), _amount);         emit Withdraw(msg.sender, _amount);     }  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to add the following check.   ```     function withdraw(uint256 _amount) external {         UserInfo storage user = userInfo[msg.sender];         require(             user.amount >= _amount,             \"RocketJoeStaking: withdraw amount exceeds balance\"         );          updatePool();          uint256 pending = (user.amount * accRJoePerShare) /             PRECISION -             user.rewardDebt;          user.amount = user.amount - _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;   if(pending != 0) {         _safeRJoeTransfer(msg.sender, pending); }  if(_amount != 0){         joe.safeTransfer(address(msg.sender), _amount); }          emit Withdraw(msg.sender, _amount);      }   ```   "}, {"title": "Initialization Function Is Missing If Token is Equals To WAVAX On the LaunchEvent", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/64", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been observed that the token can be same as WAVAX. The initialize function should not allow if token is equals to wavax. That would affect all asset management.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L219  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L411  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  On the Launchevent, token should not be equal to wavax.   "}, {"title": "withdrawAVAX() function has call to sender without reentrancy protection ", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/32", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In LauchEvent.sol the withdrawAVAX() function makes an external call to the msg.sender by way of _safeTransferAVAX.  This allows the caller to reenter this and other functions in this and other protocol files.  To prevent reentrancy and cross function reentrancy there should be reentrancy guard modifiers placed on the withdrawAVAX() function and any other function that makes external calls to the caller.   ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L368  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L370  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add reentrancy guard modifier to withdrawAVAX() function.   "}, {"title": "Admin Deny of Service", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Owner can Denial of service.  ## Proof of Concept In the contract `RocketJoeStaking` there are two ways to set `rJoePerSec`, one in the `initialize` and the second one in `updateEmissionRate`, in both of them there are no checks of the received value, so it's possible to use a high value and deny the service in line `updatePool:168`.  ## Tools Used Manual review  ## Recommended Mitigation Steps Change the type to uint128 for `rJoePerSec`.  "}, {"title": "Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  It is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelin\u2019s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L457  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L463  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L489  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L513  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L537  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Consider using safeTransfer/safeTransferFrom or require() consistently.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "1.  Title: Using delete statement to empty `rewardsAccrued` can save gas  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L123  Recommended Mitigation Steps: Change to: ```  delete rewardsAccrued[user]; ```  ========================================================================  2.  Title: Using != is more gas efficient  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L167 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L218  Recommended Mitigation Steps: Change to: ```  if (oldRewardBalance != 0) { ```  ========================================================================  3. Title: Using `storage` to declare Struct variable inside function  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L85 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L106  Recommended Mitigation Steps: instead of caching `RewardsState` to memory. read it directly from storage. ```  RewardsState storage state = strategyState[strategy]; ```  ========================================================================  4. Title: Using `calldata` on struct parameter  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L210 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L241  Recommended Mitigation Steps: Using `calldata` to store struct data type can save gas ```  function accrueStrategy(ERC20 strategy, RewardsState calldata state) ```  ========================================================================  5. Title: Using unchecked to calculate can save gas  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelStaticRewards.sol#L60  Recommended Mitigation Steps: `rewards.rewardsEndTimestamp` is checked that it won't `>` than `lastUpdatedTimestamp` ``` unchecked{  elapsed = rewards.rewardsEndTimestamp - lastUpdatedTimestamp; } ```  ========================================================================  6. Title: Using > is cheaper than >=  Proof of Concept: https://github.com/Rari-Capital/solmate/blob/9f16db2144cc9a7e2ffc5588d4bf0b66784283bd/src/tokens/ERC20.sol#L125  Recommended Mitigation Steps: just use `>` can save gas Change to: ```  require(deadline > block.timestamp, \"PERMIT_DEADLINE_EXPIRED\"); ```  ========================================================================  7. Title: Using `immutable` can save gas  Proof of Concept: https://github.com/Rari-Capital/solmate/blob/9f16db2144cc9a7e2ffc5588d4bf0b66784283bd/src/tokens/ERC20.sol#L23  Recommended Mitigation Steps: use `immutable` to declare variable which set once in constructor  ========================================================================  8. Title: Using multiple `require` instead `&&` can save gas  Proof of Concept: https://github.com/Rari-Capital/solmate/blob/9f16db2144cc9a7e2ffc5588d4bf0b66784283bd/src/tokens/ERC20.sol#L154  Recommended Mitigation Steps: Change to: ```  require(recoveredAddress != address(0), \"INVALID_SIGNER\");  require(recoveredAddress == owner, \"INVALID_SIGNER\"); ```  ========================================================================  9. Title: unnecessary value set. the default value of uint is 0.  Proof of Concept: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L134 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L184 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L307 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L384  Recommended Mitigation Steps: remove 0 value can save gas  ========================================================================"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "## 1. Put revert on the first line to save gas   ### Summary It is better to put revert before doing anything to save gas  ### POC https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/xERC4626.sol#L79  before '''   function syncRewards() public virtual {   uint192 lastRewardAmount_ = lastRewardAmount;   uint32 timestamp = block.timestamp.safeCastTo32();      if (timestamp < rewardsCycleEnd) revert SyncError();             //some code   } '''  after '''   function syncRewards() public virtual {      uint32 timestamp = block.timestamp.safeCastTo32();      if (timestamp < rewardsCycleEnd) revert SyncError();      uint192 lastRewardAmount_ = lastRewardAmount;      //some code   } '''  ==========================   ## 2. Separate revert condition so revert can be executed earlier to save gas  ### POC https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L461  Before '''   function _addGauge(address gauge) internal returns (uint112 weight) {          bool newAdd = _gauges.add(gauge);          bool previouslyDeprecated = _deprecatedGauges.remove(gauge);          if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGaugeError();          uint32 currentCycle = _getGaugeCycleEnd();   //some codes  }  '''  After '''   function _addGauge(address gauge) internal returns (uint112 weight) {   if(gauge == address(0)) revert InvalidGaugeError();          bool newAdd = _gauges.add(gauge);          bool previouslyDeprecated = _deprecatedGauges.remove(gauge);          if (!(newAdd || previouslyDeprecated)) revert InvalidGaugeError();          uint32 currentCycle = _getGaugeCycleEnd();   //some codes  }  '''  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/76", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "# QA Report  ## Table of Contents  - [summary](#summary) - [Typos](#typos) - [Comment Missing function parameter](#comment-missing-function-parameter) - [Function missing comments](#function-missing-comments) - [Setters should emit an event](#setters-should-emit-an-event) - [Setters should check the input value](#setters-should-check-the-input-value) - [assert statement should not be used](#assert-statement-should-not-be-used)    # summary  > Few vulnerabilities were found examining the contracts. The main concerns are with the presence of two `assert` statements, which is bad practice. > > Setters should check the input value before updating a storage variable.   # Typos  ## PROBLEM  There are a few typos in the contracts.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  ``` FlywheelCore.sol:97: //user should be secondUser ```    ## TOOLS USED  Manual Analysis    ## MITIGATION  Correct the typos.   # Comment Missing function parameter  ## PROBLEM  Some of the function comments are missing function parameters or returns    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### xTRIBE.sol  ``` xTRIBE.sol:89 address[] calldata accounts ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:133: uint256 numRewards ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:97: address gauge ERC20Gauges.sol:102: address gauge ERC20Gauges.sol:143: address gauge ERC20Gauges.sol:163: address user ERC20Gauges.sol:168: address user, address gauge ERC20Gauges.sol:193: address user ERC20Gauges.sol:198: address user ERC20Gauges.sol:495: address oldGauge, address newGauge ERC20Gauges.sol:510: address account, bool canExceedMax ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:36: address account, uint32 pos ERC20MultiVotes.sol:41: address account ERC20MultiVotes.sol:114: uint256 newMax ERC20MultiVotes.sol:122: address account, bool canExceedMax ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Add a comment for these parameters   # Function missing comments  ## PROBLEM  Some functions are missing comments.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  ``` FlywheelCore.sol:146: _addStrategyForRewards(ERC20 strategy) FlywheelCore.sol:154: getAllStrategies() ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:179:_queueRewards(         address[] memory gauges,         uint32 currentCycle,         uint32 lastCycle,         uint256 totalQueuedForCycle     ) ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:251: _incrementGaugeWeight(         address user,         address gauge,         uint112 weight,         uint32 cycle     ) ERC20Gauges.sol:273: _incrementUserAndGlobalWeights(         address user,         uint112 weight,         uint32 cycle     ) ERC20Gauges.sol:334: _decrementGaugeWeight(         address user,         address gauge,         uint112 weight,         uint32 cycle     )  ERC20Gauges.sol:353: _decrementUserAndGlobalWeights(         address user,         uint112 weight,         uint32 cycle     ) ERC20Gauges.sol:457: _addGauge(address gauge) ERC20Gauges.sol:479: _removeGauge(address gauge) ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:236: _incrementDelegation(         address delegator,         address delegatee,         uint256 amount     ) ERC20MultiVotes.sol:258: _undelegate(         address delegator,         address delegatee,         uint256 amount     ) ERC20MultiVotes.sol:276: _writeCheckpoint(         address delegatee,         function(uint256, uint256) ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add comments to these functions  # Setters should emit an event  ## PROBLEM  All setters should emit an event, so the Dapps can detect important changes    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:273:setRewardsStream(IRewardsStream newRewardsStream)  ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add the following event to the contract, and emit it at the end of the function ``` event RewardsStreamUpdated(IRewardsStream newRewardsStream); ```  # Setters should check the input value  ## PROBLEM  Setters should check the input value - ie make revert if it is the zero address or zero    ## SEVERITY  Low     ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  ``` FlywheelCore.sol:165:setFlywheelRewards(IFlywheelRewards newFlywheelRewards) FlywheelCore.sol:183:setBooster(IFlywheelBooster newBooster) ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:273:setRewardsStream(IRewardsStream newRewardsStream) ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:502:setMaxGauges(uint256 newMax) ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:502:setMaxDelegates(uint256 newMax) ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add non-zero checks   # assert statement should not be used  ## IMPACT  Properly functioning code should never reach a failing assert statement. If it happened, it would indicate the presence of a bug in the contract. A failing assert uses all the remaining gas, which can be financially painful for a user.   ## SEVERITY  Low    ## PROOF OF CONCEPT  Instances include:  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:196: assert(queuedRewards.storedCycle == 0 || queuedRewards.storedCycle >= lastCycle); FlywheelGaugeRewards.sol:235: assert(queuedRewards.storedCycle >= cycle); ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace the assert statement with a require statement or a custom error   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "# Gas Report  ## Table of Contents  - [Caching storage variables in memory to save gas](#caching-storage-variables-in-memory-to-save-gas) - [Calldata instead of memory for RO function parameters](#calldata-instead-of-memory-for-ro-function-parameters)  - [Comparison operators](#comparison-operators) - [Custom errors](#custom-errors) - [Default value initialization](#default-value-initialization) - [Prefix increments](#prefix-increments) - [Shifting cheaper than division](#shifting-cheaper-than-division) - [unnecessary computation](#unnecessary-computation)  # Caching storage variables in memory to save gas   ## IMPACT  Anytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable in memory: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.     ## PROOF OF CONCEPT  Instances include:  ### FlywheelCore.sol  scope: `setFlywheelRewards()`   - `flywheelRewards` is read twice:  ``` FlywheelCore.sol:166 FlywheelCore.sol:168 ```  scope: `accrueStrategy()`  - `flywheelBooster` is read twice:  ``` FlywheelCore.sol:220 FlywheelCore.sol:221 ```  scope: `accrueUser()`  - `flywheelBooster` is read twice:  ``` FlywheelCore.sol:258 FlywheelCore.sol:259 ```       ## TOOLS USED  Manual Analysis    ## MITIGATION  cache these storage variables in memory  # Calldata instead of memory for RO function parameters   ## PROBLEM  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.  Try to use calldata as a data location because it will avoid copies and also makes sure that the data cannot be modified.  ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  scope: `accrueStrategy()` ``` FlywheelCore.sol:210: RewardsState memory state ```  scope: `accrueUser()` ``` FlywheelCore.sol:241: RewardsState memory state ```  ### FlywheelGaugeRewards.sol  scope: `_queueRewards()` ``` FlywheelGaugeRewards.sol:180: address[] memory gauges ```   ## TOOLS USED  Manual Analysis   ## MITIGATION  Replace `memory` with `calldata`      # Comparison Operators   ## IMPACT  In the EVM, there is no opcode for ` >=` or `<=`. When using greater than or equal, two operations are performed: `>` and `=`.  Using strict comparison operators hence saves gas    ## PROOF OF CONCEPT  Instances include:  ### FlywheelGaugeRewards.sol ``` FlywheelGaugeRewards.sol:107 FlywheelGaugeRewards.sol:139 FlywheelGaugeRewards.sol:154 FlywheelGaugeRewards.sol:163 FlywheelGaugeRewards.sol:200 ```  ### ERC20Gauges.sol ``` ERC20Gauges.sol:259 ```  ### ERC20MultiVotes.sol ``` ERC20MultiVotes.sol:379 ```      ## TOOLS USED  Manual Analysis     ## MITIGATION  Replace `<=` with `<`, and `>=` with `>`. Do not forget to increment/decrement the compared variable  example:  ``` -cycle - block.timestamp <= incrementFreezeWindow; +cycle - block.timestamp < incrementFreezeWindow + 1; ```  However, if `1` is negligible compared to the value of the variable, we can omit the increment.  example:  ``` -cycle - block.timestamp <= incrementFreezeWindow; +cycle - block.timestamp < incrementFreezeWindow; ```   # Custom Errors   ## IMPACT  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information, as explained [here](https://blog.soliditylang.org/2021/04/21/custom-errors/)  Custom errors are defined using the error statement    ## PROOF OF CONCEPT  Instances include:   ### FlywheelCore.sol  ``` FlywheelCore.sol:147 ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:114 FlywheelGaugeRewards.sol:153 FlywheelGaugeRewards.sol:154 FlywheelGaugeRewards.sol:195 FlywheelGaugeRewards.sol:200 ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:345 ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:266 ERC20MultiVotes.sol:352 ERC20MultiVotes.sol:379 ERC20MultiVotes.sol:392 ERC20MultiVotes.sol:393 ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace require and revert statements with custom errors.  For instance, in `FlywheelGaugeRewards.sol`:  Replace ``` require(newRewards <= type(uint112).max); ```  with  ``` if (newRewards > type(uint112).max) {   revert IsNotSafeCast(newRewards); } ```  and define the custom error in the contract ``` error IsNotSafeCast(uint256 newRewards); ```   # Default value initialization   ## IMPACT  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    ## PROOF OF CONCEPT  Instances include:    ### xTribe.sol  ``` xTribe.sol:95: uint256 i = 0; ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:189: uint256 i = 0; ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:134: uint256 i = 0; ERC20Gauges.sol:184: uint256 i = 0; ERC20Gauges.sol:307: uint256 i = 0; ERC20Gauges.sol:384: uint256 i = 0; ERC20Gauges.sol:564: uint256 i = 0; ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:79: uint256 low = 0; ERC20MultiVotes.sol:346: uint256 i = 0; ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Remove explicit initialization for default values.      # Prefix increments   ## IMPACT  Prefix increments are cheaper than postfix increments.     ## PROOF OF CONCEPT  Instances include:   ### xTRIBE.sol  ``` xTRIBE.sol:99 ```  ### FlywheelGaugeRewards.sol  ``` FlywheelGaugeRewards.sol:189 ```  ### ERC20Gauges.sol  ``` ERC20Gauges.sol:137 ERC20Gauges.sol:187 ERC20Gauges.sol:314 ERC20Gauges.sol:391 ERC20Gauges.sol:576 ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:346 ERC20MultiVotes.sol:392 ```     ## TOOLS USED  Manual Analysis    ## MITIGATION  change `variable++` to `++variable`.      # Shifting cheaper than division  ## IMPACT   A division by 2 can be calculated by shifting one to the right. While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.    ## PROOF OF CONCEPT  Instances include:  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes:94: return (a & b) + (a ^ b) / 2; ```    ## TOOLS USED  Manual Analysis    ## MITIGATION  ``` -return (a & b) + (a ^ b) / 2; +return (a & b) + (a ^ b) >> 1; ```    # Unnecessary computation  ## IMPACT  When emitting an event that includes a new and an old value, it is cheaper in gas to avoid caching the old value in memory. Instead, emit the event, then save the new value in storage.    ## PROOF OF CONCEPT  Instances include:    ### ERC20Gauges.sol  ``` ERC20Gauges.sol:506 ```  ### ERC20MultiVotes.sol  ``` ERC20MultiVotes.sol:118 ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace ``` uint256 oldMax = maxDelegates; maxDelegates = newMax; emit MaxDelegatesUpdate(oldMax, newMax); ```  with  ``` emit MaxDelegatesUpdate(maxDelegates, newMax); maxDelegates = newMax; ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "# Gas optimizations  * Use delete in the `claimRewards` function of the `FlywheelCore` contract and in the `_decrementVotesUntilFree` function of the `ERC20MultiVotes` contract in order to trigger a gas refund * Loops can be optimized in several ways. Let's take for example the loop in the `incrementGauges` function in `ERC20Gauges` (There is also a loop in the `decrementGauges` function which is similar).     ```sol     // Update gauge specific state     for (uint256 i = 0; i < size; ) {         address gauge = gaugeList[i];         uint112 weight = weights[i];         weightsSum += weight;          _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);         unchecked {             i++;         }     }     ```     We can do multiple things here:     1. Variables in solidity are already initialized to their default value, and initializing them to the same value actually costs more gas. So for example in the loop above, the code can be optimized using `uint i;` instead of `uint i = 0;`.     2. Use ++i instead of i++ to save some gas spent in every iteration.      Let's look at another example:      ```sol     uint256 size = gaugeList.length;     for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight; ) {         address gauge = gaugeList[i];         uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];         if (userGaugeWeight != 0) {             // If the gauge is live (not deprecated), include its weight in the total to remove             if (!_deprecatedGauges.contains(gauge)) {                 totalFreed += userGaugeWeight;             }             userFreed += userGaugeWeight;             _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);              unchecked {                 i++;             }         }     }     ```     First of all, the optimizations from the loop before can be done here too. In addition, there is another optimization that can be done here - the condition of the loop contains 2 conditions - `i < size && (userFreeWeight + totalFreed) < weight`.     In order to avoid calculating `userFreeWeight + totalFreed` in every iteration, you can calculate `weight - userFreeWeight` (let's assume that `weightLeftToFree == weight - userFreeWeight`) once and change the condition to `totalFreed < weightLeftToFree`. You can also use unchecked on the calculation of `weightLeftToFree` because you know for sure that `weight > userFreeWeight` (or there was no weight to free).    * Use unchecked in `_incrementDelegation` and `_undelegate` in `ERC20MultiVotes` In the `_incrementDelegation` function you increment both `_delegatesVotesCount[delegator][delegatee]` and `userDelegatedVotes[delegator]`. We know for sure that `_delegatesVotesCount[delegator][delegatee] <= userDelegatedVotes[delegator]`, because `userDelegatedVotes[delegator]` is incremented at least any time that `_delegatesVotesCount[delegator][delegatee]` (it's also incremented when delegating other delegatees), so unchecked can be used when incrementing `_delegatesVotesCount[delegator][delegatee]` because if it will overflow `userDelegatedVotes[delegator]` will overflow too.     We can see a similar thing in the `_undelegate` function. In that function we decrement both `_delegatesVotesCount[delegator][delegatee]` and `userDelegatedVotes[delegator]`, and for the same reason we know that if `userDelegatedVotes[delegator]` will underflow, `_delegatesVotesCount[delegator][delegatee]` will underflow too, so we can use unchecked when decrementing `userDelegatedVotes[delegator]`.      ```sol     function _incrementDelegation(         address delegator,         address delegatee,         uint256 amount     ) internal virtual {         // ...          userDelegatedVotes[delegator] += amount;         unchecked {             _delegatesVotesCount[delegator][delegatee] += amount;         }                  // ...     }      function _undelegate(             address delegator,             address delegatee,             uint256 amount         ) internal virtual {             uint256 newDelegates = _delegatesVotesCount[delegator][delegatee] - amount;                          // ...              _delegatesVotesCount[delegator][delegatee] = newDelegates;             unchecked {                 userDelegatedVotes[delegator] -= amount;             }     ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/69", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "# Lows and non critical * Typo in the `accrue` function of the `FlyWheelCore` contract - `@notice accrue rewards for a two users on a strategy` (`a` is not needed) * Pragmas should be locked to a specific compiler version, to avoid contracts getting deployed using a different version, which may have a greater risk of undiscovered bugs. * Remove the delegatee anyway (not only if the votes are not zero) - that will make the set not contain delegatees with zero votes     ```sol     function _decrementVotesUntilFree(address user, uint256 votes) internal {         // ...         for (uint256 i = 0; i < size && (userFreeVotes + totalFreed) < votes; i++) {             address delegatee = delegateList[i];             uint256 delegateVotes = _delegatesVotesCount[user][delegatee];             if (delegateVotes != 0) {                 totalFreed += delegateVotes;                                  require(_delegates[user].remove(delegatee)); // Remove from set. Should never fail.                                  _delegatesVotesCount[user][delegatee] = 0;                 _writeCheckpoint(delegatee, _subtract, delegateVotes);                                  emit Undelegation(user, delegatee, delegateVotes);             }         }         userDelegatedVotes[user] -= totalFreed;     }     ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "Issue: Duplicate import https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/StakerVault.sol#L9-L10 ```solidity import \"../libraries/Errors.sol\"; import \"../libraries/Errors.sol\"; ``` Remove duplicate import  Issue: Require message too long Explanation: The require errors below return error messages (found in Errors.sol) that can be shortened to 32 characters or fewer (as shown) to save gas.   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L67 ```solidity         require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE); ``` Error string: \"insufficient funds for updating the position\"  Change to \"insufficient funds to update pos\"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L218 ```solidity         require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE); ``` Error string: \"token not usable for the specific action\"  Change to \"token not usable for this action\"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L578 ```solidity             Error.ESTIMATED_GAS_TOO_HIGH ``` Error string: \"too much ETH will be used for gas\"  Change to \"too much ETH to be used for gas\"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L585 ```solidity             Error.GAS_BANK_BALANCE_TOO_LOW ``` Error string: \"not enough ETH in gas bank to cover gas\"  Change to \"gas bank lacks ETH to cover gas\"  The following two lines use the same error message: https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L159 ```solidity         require(vars.poolImplementation != address(0), Error.INVALID_POOL_IMPLEMENTATION); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L182 ```solidity                 Error.INVALID_POOL_IMPLEMENTATION ``` Error string: \"invalid pool implementation for given coin\"  Change to \"invalid pool imp for given coin\"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L162 ```solidity         require(vars.lpTokenImplementation != address(0), Error.INVALID_LP_TOKEN_IMPLEMENTATION); ``` Error string: \"invalid LP Token implementation for given coin\"  Change to \"inv LP Token imp for given coin\"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L165 ```solidity         require(vars.vaultImplementation != address(0), Error.INVALID_VAULT_IMPLEMENTATION); ``` Error string: \"invalid vault implementation for given coin\"  Change to \"invalid vault imp for given coin\"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/PoolFactory.sol#L172 ```solidity             Error.INVALID_STAKER_VAULT_IMPLEMENTATION ``` Error string: \"invalid stakerVault implementation for given coin\"  Change to \"invalid stakerVault imp for coin\"   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/Vault.sol#L165 ```solidity         require(IPausable(pool).isPaused(), Error.POOL_NOT_PAUSED); ``` Error string: \"Pool must be paused to withdraw from reserve\"  Change to \"Pool must be paused to withdraw\"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/AddressProvider.sol#L285 ```solidity         require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS); ``` Error string: \"a staker vault already exists for the token\"  Change to \"a staker vault exists for token\"  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/CvxCrvRewardsLocker.sol#L85 ```solidity             Error.EXCEEDS_MAX_BOOST ``` Error string: \"Not allowed to exceed maximum boost on Convex\"  Change to \"Can't exceed max boost on Convex\"  Issue: Should use != 0 instead of > 0 in a require statement if variable is an unsigned integer (uint)  Explanation: != 0 should be used instead of > 0 where possible since > 0 costs more gas.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L210 ```solidity         require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT); ``` Change 'record.singleTopUpAmount > 0' to 'record.singleTopUpAmount != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L554 ```solidity         require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE); ``` Change 'position.totalTopUpAmount > 0' to 'position.totalTopUpAmount != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpActionFeeHandler.sol#L123 ```solidity         require(totalClaimable > 0, Error.NOTHING_TO_CLAIM); ``` Change 'totalClaimable > 0' to 'totalClaimable != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L401 ```solidity         require(_depositCap > 0, Error.INVALID_AMOUNT); ``` Change '_depositCap > 0' to '_depositCap != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L471 ```solidity         require(underlyingAmount > 0, Error.INVALID_AMOUNT); ``` Change 'underlyingAmount > 0' to 'underlyingAmount != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L549 ```solidity         require(redeemLpTokens > 0, Error.INVALID_AMOUNT); ``` Change 'redeemLpTokens > 0' to 'redeemLpTokens != 0'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/Vault.sol#L164 ```solidity         require(amount > 0, Error.INVALID_AMOUNT); ``` Change 'amount > 0' to 'amount != 0'   Issue: Should use additional require instead of && within a require function Explanation: Using require instead of && saves gas   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L359-L363 ```solidity         require(             newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&                 newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,             Error.INVALID_AMOUNT         ); ``` Change to:         require(newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE, Error.INVALID_AMOUNT);         require(newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE, Error.INVALID_AMOUNT);    https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L676 ```solidity         require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED); ``` Change to:         require(vars.success, Error.TOP_UP_FAILED);         require(abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);    https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/ConvexStrategyBase.sol#L273-L276 ```solidity         require(             token_ != address(_CVX) && token_ != address(underlying) && token_ != address(_CRV),             Error.INVALID_TOKEN_TO_ADD         ); ``` Change to:         require(token_ != address(_CVX), Error.INVALID_TOKEN_TO_ADD);         require(token_ != address(underlying), Error.INVALID_TOKEN_TO_ADD);         require(token_ != address(_CRV), Error.INVALID_TOKEN_TO_ADD);   Issue: Variables should not be initialized to their default values Explanation: Initializing variables to their default values is unnecessary and costs gas.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L483 ```solidity         uint256 currentFeeRatio = 0; ``` Change 'uint256 currentFeeRatio = 0;' to 'uint256 currentFeeRatio;'  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/StakerVault.sol#L144 ```solidity         uint256 startingAllowance = 0; ``` Change 'uint256 startingAllowance = 0;' to 'uint256 startingAllowance;'         "}, {"title": "Incorrect accounting of free weight in `_decrementWeightUntilFree`", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "# Lines of code  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L547-L583   # Vulnerability details  ## Impact In `_decrementWeightUntilFree`, the free weight is calculated by `balanceOf[user] - getUserWeight[user]` plus weight freed from non-deprecated gauges. The non-deprecated criteria is unnecessary and lead to incorrect accounting of free weight.  ## Proof of Concept https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L547-L583 ```     function _decrementWeightUntilFree(address user, uint256 weight) internal {         uint256 userFreeWeight = balanceOf[user] - getUserWeight[user];          // early return if already free         if (userFreeWeight >= weight) return;          uint32 currentCycle = _getGaugeCycleEnd();          // cache totals for batch updates         uint112 userFreed;         uint112 totalFreed;          // Loop through all user gauges, live and deprecated         address[] memory gaugeList = _userGauges[user].values();          // Free gauges until through entire list or under weight         uint256 size = gaugeList.length;         for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight; ) {             address gauge = gaugeList[i];             uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];             if (userGaugeWeight != 0) {                 // If the gauge is live (not deprecated), include its weight in the total to remove                 if (!_deprecatedGauges.contains(gauge)) {                     totalFreed += userGaugeWeight;                 }                 userFreed += userGaugeWeight;                 _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);                  unchecked {                     i++;                 }             }         }          getUserWeight[user] -= userFreed;         _writeGaugeWeight(_totalWeight, _subtract, totalFreed, currentCycle);     } ``` Consider Alice allocated 3 weight to gauge D, gauge A and gauge B equally where gauge D is depricated 1. Alice call _decrementWeightUntilFree(alice, 2) 2. userFreeWeight = 0 3. gauge D is freed, totalFreed = 0, userFreed = 1 4. (userFreeWeight + totalFreed) < weight, continue to free next gauge 5. gauge A is freed, totalFreed = 1, userFreed = 2 6. (userFreeWeight + totalFreed) < weight, continue to free next gauge 7. gauge B is freed, totalFreed = 2, userFreed = 3 8. All gauge is freed  Alternatively, Alice can 1. Alice call _decrementWeightUntilFree(alice, 1) 2. userFreeWeight = balanceOf[alice] - getUserWeight[alice] = 3 - 3 = 0 3. gauge D is freed, totalFreed = 0, userFreed = 1 4. (userFreeWeight + totalFreed) < weight, continue to free next gauge 5. gauge A is freed, totalFreed = 1, userFreed = 2 6. (userFreeWeight + totalFreed) >= weight, break 7. getUserWeight[alice] -= totalFreed 8. Alice call _decrementWeightUntilFree(alice, 2) 9. userFreeWeight = balanceOf[alice] - getUserWeight[alice] = 3 - 1 = 2 10. (userFreeWeight + totalFreed) >= weight, break 11. Only 2 gauge is freed  ## Recommended Mitigation Steps No need to treat deprecated gauge seperately  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "# Unnecessary checked arithmetic in for loops There is no risk of overflow caused by increments to the iteration index in for loops (the `i++` in `for (uint256 i = 0; i < numIterations; i++)`). Increments perform overflow checks that are not necessary in this case.  ### Recommendation Surround the increment expressions with an `unchecked { ... }` block to avoid the default overflow checks. For example, change the loop ``` for (uint256 i = 0; i < numIterations; i++) {  // ... } ``` to ``` for (uint256 i = 0; i < numIterations;) {  // ...  unchecked { i++; } } ``` It is a little less readable but it saves a significant amount of gas.  # Unnecessary SLOADs and MLOADs in for-each loops There are many for loops that follows this for-each pattern: ``` for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` } ``` In such for loops, the `array.length` is read on every iteration, instead of caching it once in a local variable and read it from there. Storage reads are much more expensive than reading local variables. Memory reads are a bit more expensive than reading local variables.  ### Recommendation Read these values from storage / memory once, cache them in local variables and then read them again from the local variables. For example: ``` uint256 length = array.length; for (uint256 i = 0; i < length; i++) {  // do something with `array[i]` } ```  # Prefix increments / decrements are cheaper than postfix increments / decrements Use prefix increments / decrements (++x / --x) instead of postfix increments / decrements (x++ / x--).  ### Recommendation Change all postfix increments / decrements to prefix increments / decrements."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "# Save gas in for loops by unchecked arithmetic  The for loop has no overflow risk of `i`. Use an unchecked block to save gas.  ## Proof of Concept  ``` flywheel-v2/src/token/ERC20MultiVotes.sol 346:        for (uint256 i = 0; i < size && (userFreeVotes + totalFreed) < votes; i++) {  flywheel-v2/src/rewards/FlywheelGaugeRewards.sol 189:        for (uint256 i = 0; i < size; i++) { ```  ## Recommendation  Use `unchecked` blocks to avoid overflow checks, or use `++i` rather than `i++` if you don't use unchecked blocks.  ``` for (uint256 i = 0; i < length; ) {     ...     unchecked {         ++i;     } } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/56", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "# Summary We list 2 low-critical findings and 2 non-critical findings: * (Low) Doesn\u2019t check whether `newFlywheelRewards` is valid in `setFlywheelRewards()` * (Low) floating pragma * (Non) Using ecrecover is against best practice * (Non) It\u2019s better to emit an event in `setRewardsStream`  # (Low) Doesn\u2019t check whether `newFlywheelRewards` is valid in `setFlywheelRewards()`   ## Impact  Doesn\u2019t check whether `newFlywheelRewards` is valid in `setFlywheelRewards()`. It may be a invalid or malicious. it should add some kind of check  ## Proof of Concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L165  ```     function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {         uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));         if (oldRewardBalance > 0) {             rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);         }          flywheelRewards = newFlywheelRewards;          emit FlywheelRewardsUpdate(address(newFlywheelRewards));     }  ```  ## Tools Used  vim  ## Recommended Mitigation Steps  Check whether `newFlywheelRewards` is valid # (Low) floating pragma  ## Impact  Floating pragma may cause unexpected compilation time behaviour and introduce unintended bugs.  ## Proof of Concept  Contracts have floating pragma problems.  https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L4  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L3  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L4    ## Tools Used  vim  ## Recommended Mitigation Steps  Don't use `^`, lock pragma to ensure compiler version. e.g. `pragma solidity 0.8.0;`   # (Non) Using ecrecover is against best practice  ## Impact  Using ecrecover is against best practice. Preferably use ECDSA.recover instead. EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature unique. However it should be impossible to be a threat by now.   ## Proof of Concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L380  ## Tools Used  vim  ## Recommended Mitigation Steps  Take these implementation into consideration  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/cryptography/draft-EIP712.sol  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-ERC20Permit.sol  # (Non) It\u2019s better to emit an event in `setRewardsStream`  ## Impact  In the function `setRewardsStream` in flywheel-v2/src/rewards/FlywheelGaugeRewards.sol, it\u2019s better to emit an event.  ## Proof of Concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L273  ## Tools Used  vim, ethers.js  ## Recommended Mitigation Steps  Emit an event in set function:  ```      function setRewardsStream(IRewardsStream newRewardsStream) external requiresAuth {          rewardsStream = newRewardsStream; +        emit RewardsStreamUpdate(address(newRewardsStream));      } ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "## 1. `i++` can be replaced with `++i`   ++i consumes less gas than than i++, as the return value of post increment is not used, so it can be replaced with pre increment   ### Proof of concept  https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L99  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L137  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L187  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L314  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L391  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L576  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189  ### Mitigation  post increment can be replaced with pre-increment   ## 2. Avoid initialising variables with default values  When variables are created it contains the default values, explicit initialising with default values is unnecessary  ### Proof of concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L134  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L184  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L307  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L384  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L564  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189  ### Mitigation   Initialising default values can be avoided  ## 3. division can be replaced with shift operator  Shift operator consumed less gas when compared to division, so it can be replaced to save some gas  ### Proof of concept  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L94  ```     return (a & b) + (a ^ b) / 2; ```  ### Mitigation  Division can be replaced with shift operator  ```     return (a & b) + ((a ^ b) >> 1); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "  ## for loops can be optimized  Index increments in most of the for loops are unchecked, but a couple are still checked. Also, prefix increments are cheaper than postfix increments.   ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189     ## Redundant initialisation with default value  Some variables are initialised with their default values which cause unnecessary gas consumption  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L134 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L184 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L307 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L384 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L564 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L79 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189 https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L95     ## Error string longer than 32 characters  Error reason strings take space in the deployed bytecode. Every reason string takes at least 32 bytes so make sure your string fits in 32 bytes or it will become more expensive.   ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L379     ## Non-zero amount check missing before transfers  It is a good practice to apply non-zero amount checks for transfers to avoid unnecessary executions.  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L527 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L532 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L541 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L312 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L317 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L326 https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L121 https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L132 https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L147     ## Public state variables can be private  Private state variables are cheaper than public state variables. There are many instances where public variables can be private.  ### Lines of code There are many instances, some of which are: https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L59 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L63 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L108 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L111 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L35 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L38 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L41 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L76 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L204 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L207     ## Booleans are more expensive than uint256  It is more expensive to operate using booleans because before every write operation an SLOAD is executed to read the contents of the slot. Therefore, it is cheaper to use uint256 instead of bool. On the other hand, using bool is better for the code readability. Hence, it is a tradeoff to be decided by the developers.  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L450 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L111  ### Recommended Mitigation Steps Consider replacing booleans with uint256 if gas efficiency overweighs code readability.     ## Constants can be made private  There is no need for these constants to be public. Changing them to private would save gas.   ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L368 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L201     ## Some internal functions can be made private  Calling private functions are cheaper than calling internal functions. Therefore, it is better to declare functions private if they are not called from inherited contracts.  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L89 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L108 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L256 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L277 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L339 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L357 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L457 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L479 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L92 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L216 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L236 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L262 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L146 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L184   ### Recommended Mitigation Steps Change the visibility to private where possible.     ## average() function can be eliminated  average() is used only once. Therefore, it can be eliminated and the calculation can be implemented where the function is called.  ### Lines of code https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L81 https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L92  ### Recommended Mitigation Steps Line 81 can be changed as -->             uint256 mid = (low & high) + (low ^ high) / 2; And average() function can be deleted. "}, {"title": "[WP-H0] `xERC4626.sol` Some users may not be able to withdraw until `rewardsCycleEnd` the due to underflow in `beforeWithdraw()`", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/48", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "# Lines of code  https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L65-L68   # Vulnerability details  https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L65-L68  ```solidity function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {     super.beforeWithdraw(amount, shares);     storedTotalAssets -= amount; } ```  https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L78-L87  ```solidity function syncRewards() public virtual {     uint192 lastRewardAmount_ = lastRewardAmount;     uint32 timestamp = block.timestamp.safeCastTo32();      if (timestamp < rewardsCycleEnd) revert SyncError();      uint256 storedTotalAssets_ = storedTotalAssets;     uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;      storedTotalAssets = storedTotalAssets_ + lastRewardAmount_; // SSTORE     ... ```  `storedTotalAssets` is a cached value of total assets which will only include the `unlockedRewards` when the whole cycle ends.  This makes it possible for `storedTotalAssets -= amount` to revert when the withdrawal amount exceeds `storedTotalAssets`, as the withdrawal amount may include part of the `unlockedRewards` in the current cycle.  ### PoC  Given:  - rewardsCycleLength = 100 days  1. Alice `deposit()` 100 TRIBE tokens; 2. The owner transferred 100 TRIBE tokens as rewards and called `syncRewards()`; 3. 1 day later, Alice `redeem()` with all shares, the transaction will revert at `xERC4626.beforeWithdraw()`.  Alice's shares worth 101 TRIBE at this moment, but `storedTotalAssets` = 100, making `storedTotalAssets -= amount` reverts due to underflow.  4. Bob `deposit()` 1 TRIBE tokens; 5. Alice `withdraw()` 101 TRIBE tokens, `storedTotalAssets` becomes `0`; 6. Bob can't even withdraw 1 wei of TRIBE token, as `storedTotalAssets` is now `0`.  If there are no new deposits, both Alice and Bob won't be able to withdraw any of their funds until `rewardsCycleEnd`.  ### Recommendation  Consider changing to:  ```solidity function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {     super.beforeWithdraw(amount, shares);     uint256 _storedTotalAssets = storedTotalAssets;     if (amount >= _storedTotalAssets) {         uint256 _totalAssets = totalAssets();         // _totalAssets - _storedTotalAssets == unlockedRewards         lastRewardAmount -= _totalAssets - _storedTotalAssets;         lastSync = block.timestamp;         storedTotalAssets = _totalAssets - amount;     } else {         storedTotalAssets = _storedTotalAssets - amount;     } } ```  "}, {"title": "Oracle data feed is insufficiently validated.", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  throttle   # Vulnerability details  ## Impact Price can be stale and can lead to wrong `quoteAmount` return value  ## Proof of Concept Oracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong `quoteAmount` return value ```javascript function _peek(     bytes6 base,     bytes6 quote,     uint256 baseAmount ) private view returns (uint256 quoteAmount, uint256 updateTime) {     ...      (, int256 daiPrice, , , ) = DAI.latestRoundData();     (, int256 usdcPrice, , , ) = USDC.latestRoundData();     (, int256 usdtPrice, , , ) = USDT.latestRoundData();      require(         daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0,         \"Chainlink pricefeed reporting 0\"     );      ... } ```  ## Tools Used Manual review  ## Recommended Mitigation Steps Validate data feed ```javascript function _peek(     bytes6 base,     bytes6 quote,     uint256 baseAmount ) private view returns (uint256 quoteAmount, uint256 updateTime) {     ...     (uint80 roundID, int256 daiPrice, , uint256 timestamp, uint80 answeredInRound) = DAI.latestRoundData();     require(daiPrice > 0, \"ChainLink: DAI price <= 0\");     require(answeredInRound >= roundID, \"ChainLink: Stale price\");     require(timestamp > 0, \"ChainLink: Round not complete\");      (roundID, int256 usdcPrice, , timestamp, answeredInRound) = USDC.latestRoundData();     require(usdcPrice > 0, \"ChainLink: USDC price <= 0\");     require(answeredInRound >= roundID, \"ChainLink: Stale USDC price\");     require(timestamp > 0, \"ChainLink: USDC round not complete\");      (roundID, int256 usdtPrice, , timestamp, answeredInRound) = USDT.latestRoundData();     require(usdtPrice > 0, \"ChainLink: USDT price <= 0\");     require(answeredInRound >= roundID, \"ChainLink: Stale USDT price\");     require(timestamp > 0, \"ChainLink: USDT round not complete\");      ... } ```  "}, {"title": "Rewards distribution can be disrupted by a early user", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/116", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L206-L224  ```solidity function _calcRewardIntegral(     uint256 _index,     address[2] memory _accounts,     uint256[2] memory _balances,     uint256 _supply,     bool _isClaim ) internal {     RewardType storage reward = rewards[_index];      uint256 rewardIntegral = reward.reward_integral;     uint256 rewardRemaining = reward.reward_remaining;      //get difference in balance and remaining rewards     //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed     uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));     if (_supply > 0 && (bal - rewardRemaining) > 0) {         rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);         reward.reward_integral = uint128(rewardIntegral);     } ```  `reward.reward_integral` is `uint128`, if a early user mint (wrap) just `1` Wei of `convexToken`, and make `_supply == 1`, and then tranferring `5e18` of `reward_token` to the contract.  As a result, `reward.reward_integral` can exceed `type(uint128).max` and overflow, causing the rewards distribution to be disrupted.  ### Recommendation  Consider `wrap` a certain amount of initial totalSupply, e.g. `1e8`, and never burn it. And consider using uint256 instead of uint128 for `reward.reward_integral`. Also, consdier lower `1e20` down to `1e12`.  "}, {"title": "Comment missing function parameter", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/113", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The Cvx3CrvOracle.sol contract has functions that take the baseAmount input parameter but fail to mention or describe this parameter in the function's natspec comments. Issues with comments are low risk based on [Code4rena risk categories](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  The functions missing the baseAmount input parameter in comments include: - [peek()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L59-L66) - [get()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L81-L88) - [_peek()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L102-L109)  ## Recommended Mitigation Steps  Make sure natspec comments include all function input parameters.  "}, {"title": "Unsafe uint128 casting may overflow", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/112", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The _calcRewardIntegral function casts intermediate reward values from uint256 to uint128 and vice versa several times. Because OpenZeppelin SafeCast is not used, casting from uint256 to uint128 may overflow if a large reward value is being calculate. This overflow could result in users receiving less rewards than they are owed.  ## Proof of Concept  There are 4 uint128 casting operations and 2 uint256 casting operations [in the _calcRewardIntegral function of ConvexStakingWrapper.sol](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L222-L253).  ## Recommended Mitigation Steps  Because reward values are an important part of this protocol, use the OpenZeppelin SafeCast library to prevent unexpected overflows when casting. SafeMath and Solidity 0.8.* handles overflows for basic math operations but not for casting.  "}, {"title": "`ConvexYieldWrapper#removeVault()` `found` is redundant", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L74-L95  ```solidity     function removeVault(bytes12 vaultId, address account) public {         address owner = cauldron.vaults(vaultId).owner;         if (account != owner) {             bytes12[] storage vaults_ = vaults[account];             uint256 vaultsLength = vaults_.length;             bool found;             for (uint256 i = 0; i < vaultsLength; i++) {                 if (vaults_[i] == vaultId) {                     bool isLast = i == vaultsLength - 1;                     if (!isLast) {                         vaults_[i] = vaults_[vaultsLength - 1];                     }                     vaults_.pop();                     found = true;                     emit VaultRemoved(account, vaultId);                     break;                 }             }             require(found, \"Vault not found\");             vaults[account] = vaults_;         }     } ```  `found` is redundant, we can just use `return` to stop the whole function when the `vault` to be removed is found and removed.  `removeVault()` can be changed to:  ```solidity function removeVault(bytes12 vaultId, address account) public {     address owner = cauldron.vaults(vaultId).owner;     if (account != owner) {         bytes12[] storage vaults_ = vaults[account];         uint256 vaultsLength = vaults_.length;         for (uint256 i = 0; i < vaultsLength; i++) {             if (vaults_[i] == vaultId) {                 bool isLast = i == vaultsLength - 1;                 if (!isLast) {                     vaults_[i] = vaults_[vaultsLength - 1];                 }                 vaults_.pop();                 found = true;                 emit VaultRemoved(account, vaultId);                 return;             }         }         revert(\"Vault not found\");     } } ```  "}, {"title": "`ConvexYieldWrapper.sol` Redundant code", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L74-L95  ```solidity function removeVault(bytes12 vaultId, address account) public {     address owner = cauldron.vaults(vaultId).owner;     if (account != owner) {         bytes12[] storage vaults_ = vaults[account];         uint256 vaultsLength = vaults_.length;         bool found;         for (uint256 i = 0; i < vaultsLength; i++) {             if (vaults_[i] == vaultId) {                 bool isLast = i == vaultsLength - 1;                 if (!isLast) {                     vaults_[i] = vaults_[vaultsLength - 1];                 }                 vaults_.pop();                 found = true;                 emit VaultRemoved(account, vaultId);                 break;             }         }         require(found, \"Vault not found\");         vaults[account] = vaults_;     } } ```  At L77, `vaults_` is defined as `vaults[account]`, thus `vaults[account] = vaults_` at L93 is redundant.  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L57-L69  ```solidity function addVault(bytes12 vaultId) external {     address account = cauldron.vaults(vaultId).owner;     require(account != address(0), \"No owner for the vault\");     bytes12[] storage vaults_ = vaults[account];     uint256 vaultsLength = vaults_.length;      for (uint256 i = 0; i < vaultsLength; i++) {         require(vaults_[i] != vaultId, \"Vault already added\");     }     vaults_.push(vaultId);     vaults[account] = vaults_;     emit VaultAdded(account, vaultId); } ```  Similarly, L76 is redundant.  "}, {"title": "Perform math inside code branch", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/106", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_calcCvxIntegral()` function in ConvexStakingWrapper.sol doesn't use the same gas optimization that its sibling function `_calcRewardIntegral()` uses.  ## Proof of Concept  This code is from [the `_calcCvxIntegral()` function](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L154) ``` if (_isClaim || userI < cvxRewardIntegral) {     uint256 receiveable = cvx_claimable_reward[_accounts[u]] +         ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);     if (_isClaim) {         if (receiveable > 0) {             cvx_claimable_reward[_accounts[u]] = 0;             IERC20(cvx).safeTransfer(_accounts[u], receiveable);             bal = bal - (receiveable);         }     } else {         cvx_claimable_reward[_accounts[u]] = receiveable;     }     cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral; } ```  The related code from [the `_calcRewardIntegral()` function](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L206) has the receivable calculation inside the `if (_isClaim)` code branch to save gas if _isClaim is false.  ``` if (_isClaim || userI < rewardIntegral) {     if (_isClaim) {         uint256 receiveable = reward.claimable_reward[_accounts[u]] +             ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);         if (receiveable > 0) {             reward.claimable_reward[_accounts[u]] = 0;             IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);             bal = bal - receiveable;         }     } else {         reward.claimable_reward[_accounts[u]] =             reward.claimable_reward[_accounts[u]] +             ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);     }     reward.reward_integral_for[_accounts[u]] = rewardIntegral; } ```  This optimization would save gas each time `_checkpoint()` is called because `_checkpoint()` sets _isClaim to false and doesn't enter the `if(_isClaim)` branch.   ## Recommended Mitigation Steps  Modify the `_calcCvxIntegral()` function to place the receiveable calculation inside the `if (_isClaim)` code branch.  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/105", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  1. https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L114-L114  ```solidity uint256 startIndex = rewardsLength - 1; ```  `rewardsLength - 1` will never underflow.  2. https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L82-L85  ```solidity=82 bool isLast = i == vaultsLength - 1; if (!isLast) {     vaults_[i] = vaults_[vaultsLength - 1]; } ```  "}, {"title": "`ConvexStakingWrapper.sol#` Switching between 1, 2 instead of 0, 1 is more gas efficient", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L54-L55  ```solidity     bool private constant _NOT_ENTERED = false;     bool private constant _ENTERED = true; ```  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L81-L90  ```solidity     modifier nonReentrant() {         // On the first call to nonReentrant, _notEntered will be true         require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");         // Any calls to nonReentrant after this point will fail         _status = _ENTERED;         _;         // By storing the original value once again, a refund is triggered (see         // https://eips.ethereum.org/EIPS/eip-2200)         _status = _NOT_ENTERED;     } ```  `SSTORE` from 0 to 1 (or any non-zero value), the cost is 20000; `SSTORE` from 1 to 2 (or any other non-zero value), the cost is 5000.  By storing the original value once again, a refund is triggered (https://eips.ethereum.org/EIPS/eip-2200).  Since refunds are capped to a percentage of the total transaction's gas, it is best to keep them low, to increase the likelihood of the full refund coming into effect.  Therefore, switching between 1, 2 instead of 0, 1 will be more gas efficient.  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/86bd4d73896afcb35a205456e361436701823c7a/contracts/security/ReentrancyGuard.sol#L29-L33  "}, {"title": "Avoid unnecessary arithmetic operations and storage reads can save gas", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L106-L111  ```solidity     if (rewardsLength == 0) {         RewardType storage reward = rewards.push();         reward.reward_token = crv;         reward.reward_pool = mainPool;         rewardsLength += 1;     } ```  When `rewardsLength` == `0`,  the new `rewardsLength` will always be 1. Therefore, replacing `+=` with `=` can avoid the unnecessary arithmetic operations and memory reads    ### Recommendation  Change to:  ```solidity     if (rewardsLength == 0) {         RewardType storage reward = rewards.push();         reward.reward_token = crv;         reward.reward_pool = mainPool;         rewardsLength = 1;     } ```  "}, {"title": "Cvx3CrvOracle earned function calculates cvx wrongly if pool claimed indirectly", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/95", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  kenzo   # Vulnerability details  The ConvexStakingWrapper that Yield is based on recently published a fix for `earned` function in case the pool is claimed indirectly.  ## Impact Wrong results might be returned from view function `earned`.  ## Proof of Concept This is the fix for earned: [fix commit](https://github.com/convex-eth/platform/commit/9b9dd72bdb822e7f34f241d620cc1f8388bf7d6a#)  ## Recommended Mitigation Steps Apply fix.  "}, {"title": "Malicious Users Can Transfer Vault Collateral To Other Accounts To Extract Additional Yield From The Protocol", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/89", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which: - Approves Ladle to move the tokens. - Transfers the tokens to `ConvexYieldWrapper.sol`. - Wraps/stakes these tokens. - Updates accounting and produces debt tokens within `Ladle.sol`.  `_getDepositedBalance()` takes into consideration the user's total collateral stored in all of their owned vaults. However, as a vault owner, you are allowed to give the vault to another user, move collateral between vaults and add/remove collateral. Therefore, it is possible to manipulate the result of this function by checkpointing one user's balance at a given time, transferring ownership to another user and then create a new checkpoint with this user.   As a result, a user is able to generate protocol yield multiple times over on a single collateral amount. This can be abused to effectively extract all protocol yield.  ## Proof of Concept  Consider the following exploit scenario: - Alice owns a vault which has 100 tokens worth of collateral. - At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards. - Alice then calls `Ladle.give()`, transferring the ownership of the vault to Bob and calls `ConvexYieldWrapper.addVault()`. - Bob is able to call `user_checkpoint()` and effectively update their checkpointed balance. - At this point in time, both Alice and Bob have claim to any yield generated by the protocol, however, there is only one vault instance that holds the underlying collateral.  https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexYieldWrapper.sol#L100-L120 ``` function _getDepositedBalance(address account_) internal view override returns (uint256) {     if (account_ == address(0) || account_ == collateralVault) {         return 0;     }      bytes12[] memory userVault = vaults[account_];      //add up all balances of all vaults registered in the wrapper and owned by the account     uint256 collateral;     DataTypes.Balances memory balance;     uint256 userVaultLength = userVault.length;     for (uint256 i = 0; i < userVaultLength; i++) {         if (cauldron.vaults(userVault[i]).owner == account_) {             balance = cauldron.balances(userVault[i]);             collateral = collateral + balance.ink;         }     }      //add to balance of this token     return _balanceOf[account_] + collateral; } ```  ## Tools Used  Manual code review. Discussion/confirmation with the Yield Protocol team.  ## Recommended Mitigation Steps  Ensure that any change to a vault will correctly checkpoint the previous and new vault owner. The affected actions include but are not limited to; transferring ownership of a vault to a new account, transferring collateral to another vault and adding/removing collateral to/from a vault.  "}, {"title": "Only passing in one depositedBalance in _checkpointAndClaim()", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/88", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  GeekyLumberjack   # Vulnerability details  `uint256[2] memory depositedBalance;` is defined at the beginning of [_checkpointAndClaim](https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L279-L291) only one `depositedBalance` slot is being filed and then the entire array gets passed into `_calcRewardIntegral()` and `_calcCvxIntegral()` along with an array of two `_accounts`. Having only one of the `depositedBalance` and two `_accounts` may cause loss in rewards for the second account. This function is currently only used in `GetReward()` which is passing in a zero address as the second address.   "}, {"title": "Malicious Users Can Duplicate Protocol Earned Yield By Transferring `wCVX` Tokens To Another Account", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/86", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which: - Approves Ladle to move the tokens. - Transfers the tokens to `ConvexYieldWrapper.sol`. - Wraps/stakes these tokens. - Updates accounting and produces debt tokens within `Ladle.sol`.  During `wrap()` and `unwrap()` actions, `_checkpoint()` is used to update the rewards for the `from_` and `to_` accounts. However, the [reference](https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract implements a `_beforeTokenTransfer()` function which has been removed from Yield Protocol's custom implementation.  As a result, it is possible to transfer `wCVX` tokens to another account after an initial checkpoint has been made. By manually calling `user_checkpoint()` on the new account, this user is able to update its deposited balance of the new account while the sender's balance is not updated. This can be repeated to effectively replicate a user's deposited balance over any number of accounts. To claim yield generated by the protocol, the user must only make sure that the account calling `getReward()` holds the tokens for the duration of the call.  ## Proof of Concept  The exploit can be outlined through the following steps: - Alice receives 100 `wCVX` tokens from the protocol after wrapping their convex tokens. - At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards. - Alice transfers her tokens to her friend Bob who then manually calls `user_checkpoint()` to update his balance. - Now from the perspective of the protocol, both Alice and Bob have 100 `wCVX` tokens as calculated by the `_getDepositedBalance()` function. - If either Alice or Bob wants to claim rewards, all they need to do is make sure the 100 `wCVX` tokens are in their account upon calling `getReward()`. Afterwards, the tokens can be transferred out.  ## Tools Used  Manual code review. Discussion/confirmation with the Yield Protocol team.  ## Recommended Mitigation Steps  Consider implementing the `_beforeTokenTransfer()` function as shown in the [reference](https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract. However, it is important to ensure the wrapper contract and collateral vaults are excluded from the checkpointing so they are not considered in the rewards calculations.  "}, {"title": "Unnecessary check on quote in Cvx3CrvOracle", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  L116 of Cvx3CrvOracle enforces for the rest of the function call that `base == ethId <-> quote == cvx3CrvId`  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L116  However on L137 we check both these conditions again.  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L137  We could check just one of these and then rely on the require condition on 116 to enforce the other one. This will prevent us having to SLOAD `ethID` again  ## Recommended Mitigation Steps  Change L137 to `if (base == cvx3CrvId) {`  "}, {"title": "`ConvexStakingWrapper.sol`: `AccessControl` capabilities aren't used", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/75", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact AccessControl capabilities aren't used.  ## Proof of Concept In `ConvexStakingWrapper.sol`, `AccessControl` seem superfluous: ``` 7: import \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\"; ... 15: contract ConvexStakingWrapper is ERC20, AccessControl { ``` In the original `ConvexStakingWrapper.sol`, this `AccessControl` isn't inherited.   In this contract, I believe role-based capabilities were thought of, but were forgotten or abandonned.  ## Tools Used VS Code  ## Recommended Mitigation Steps Either use the capabilities from `AccessControl`, or delete the import + the inheritance to save gas.  "}, {"title": "`ConvexStakingWrapper.sol`: unused `nonReentrant` modifier", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact No protection from reentrancy (besides the gas limit on safeTransfer). Bad practice compared to the original `ConvexStakingWrapper` contract.  ## Proof of Concept The original `ConvexStakingWrapper` contract used the `nonReentrant` modifier on all functions using the `safeTransfer` or `safeTransferFrom` methods: - `deposit`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L337 - `stake`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L352  - `withdraw`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L367 - `withdrawAndUnwrap`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L381  As the current one in the Yield solution is an upgrade, it should follow the same good practices.  ## Tools Used VS Code  ## Recommended Mitigation Steps Use the `nonReentrant` modifier on external functions that end up calling `safeTransfer` or `safeTransferFrom` (`user_checkpoint()` and `getReward()`)  "}, {"title": "less gas usage by calling the `TransferHelper` lib directly", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact spend at least 6930 more gas on deployment, and spend 40 gas more per call (by using current implementasion)  ## Proof of Concept https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L184 https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L239  the `TransferHelper` lib just used twice in this contract. remove:(line 16) https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L16  and just call `TransferHelper.safeTransfer()` directly at those line.  This method is using almost exact the same gas as if we just copying the `safeTransfer()` and remove the `TransferHelper` lib from the contract. (since we need just 1 function from the lib)    "}, {"title": "Gas in `Cvx3CrvOracle.sol:_peek()`: `ethId` and `cvx3CrvId` should get cached ", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive (~100 gas) compared to MLOADs/MSTOREs (~3 gas). Minimizing them can save gas.  ## Proof of Concept The code is as such (see `@audit-info`): ``` File: Cvx3CrvOracle.sol 110:     function _peek( 111:         bytes6 base, 112:         bytes6 quote, 113:         uint256 baseAmount 114:     ) private view returns (uint256 quoteAmount, uint256 updateTime) { 115:         require( 116:             (base == ethId && quote == cvx3CrvId) || // @audit-info ethId SLOAD 1, cvx3CrvId SLOAD 1 117:                 (base == cvx3CrvId && quote == ethId), // @audit-info ethId SLOAD 2, cvx3CrvId SLOAD 2 118:             \"Invalid quote or base\" 119:         ); 120:         (, int256 daiPrice, , , ) = DAI.latestRoundData(); 121:         (, int256 usdcPrice, , , ) = USDC.latestRoundData(); 122:         (, int256 usdtPrice, , , ) = USDT.latestRoundData(); 123:  124:         require( 125:             daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0, 126:             \"Chainlink pricefeed reporting 0\" 127:         ); 128:  129:         // This won't overflow as the max value for int256 is less than the max value for uint256 130:         uint256 minStable = min( 131:             uint256(daiPrice), 132:             min(uint256(usdcPrice), uint256(usdtPrice)) 133:         ); 134:  135:         uint256 price = (threecrv.get_virtual_price() * minStable) / 1e18; 136:  137:         if (base == cvx3CrvId && quote == ethId) { // @audit-info ethId SLOAD 3, cvx3CrvId SLOAD 3 138:             quoteAmount = (baseAmount * price) / 1e18; 139:         } else { 140:             quoteAmount = (baseAmount * 1e18) / price; 141:         } 142:  143:         updateTime = block.timestamp; 144:     } ```  By caching `ethId` and `cvx3CrvId` in memory, it's possible to save 4 SLOADs (~400gas) at the cost of 2 MSTOREs (6 gas) and 4 MLOADs (12 gas)  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `ethId` and `cvx3CrvId` in variables and use these instead  "}, {"title": "Gas in `ConvexStakingWrapper.sol:_calcRewardIntegral()`: `bal - rewardRemaining` can't underflow", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost due to unnecessary automatic underflow checks.  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers.  When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block.  https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  ## Proof of Concept In `ConvexStakingWrapper.sol:_calcRewardIntegral()`, `bal - rewardRemaining` can't underflow at line 222 as the conditional statement line 221 prevents it: ``` File: ConvexStakingWrapper.sol 221:         if (_supply > 0 && (bal - rewardRemaining) > 0) { 222:             rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply); //@audit-info (bal - rewardRemaining) can't underflow because of above if statement ``` This substraction should get computed inside an `unchecked` block and stored in a variable, which would then be used in the checked calculation for `rewardIntegral`.  ## Tools Used VS Code  ## Recommended Mitigation Steps Uncheck arithmetic operations when the risk of underflow or overflow is already contained by wrapping them in an `unchecked` block    "}, {"title": "Gas: Unused Named Returns", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Using both named returns and a return statement isn't necessary. Removing unused named return variables can reduce gas usage and improve code clarity. To save gas and improve code quality: consider using only one of those.      ## Proof of Concept   Instances include:   ``` ConvexStakingWrapper.sol:310:    function earned(address _account) external view returns (EarnedData[] memory claimable) { //@audit-info 342: return claimable;  Cvx3CrvOracle.sol:76:        returns (uint256 quoteAmount, uint256 updateTime) //@audit-info 78: return _peek(base.b6(), quote.b6(), baseAmount);  Cvx3CrvOracle.sol:97:        returns (uint256 quoteAmount, uint256 updateTime) //@audit-info 99: return _peek(base.b6(), quote.b6(), baseAmount); ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Remove the unused named returns   "}, {"title": "Gas: Tight variable packing in `ConvexStakingWrapper.sol`", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Solidity contracts have contiguous 32 bytes (256 bits) slots used in storage. By arranging the variables, it is possible to minimize the number of slots used within a contract's storage and therefore reduce deployment costs.  ## Proof of Concept In `ConvexStakingWrapper.sol`, the order of variables is this way: ```     uint256 public cvx_reward_integral;     uint256 public cvx_reward_remaining;     mapping(address => uint256) public cvx_reward_integral_for;     mapping(address => uint256) public cvx_claimable_reward;      //constants/immutables     address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);     address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);     address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);     address public curveToken;     address public convexToken;     address public convexPool;     address public collateralVault;     uint256 public convexPoolId;      //rewards     RewardType[] public rewards;      //management     bool public isShutdown;     bool private _status;      bool private constant _NOT_ENTERED = false;     bool private constant _ENTERED = true; ``` `address` type variables are each of 20 bytes size (way less than 32 bytes). However, they here take up a whole 32 bytes slot (they are contiguous). As `bool` type variables are of size 1 byte, there's a slot here that can get saved by moving them closer to an address  ## Recommended Mitigation Steps I suggest the following (see the @audit-info tags for more details about what moved and why): ```     uint256 public cvx_reward_integral;     uint256 public cvx_reward_remaining;     mapping(address => uint256) public cvx_reward_integral_for;     mapping(address => uint256) public cvx_claimable_reward;      //constants/immutables     uint256 public convexPoolId; //@audit-info this moved up to free collateralVault's slot.     address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);     address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);     address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);     address public curveToken;     address public convexToken;     address public convexPool;     address public collateralVault; //@audit-info this got freed from convexPoolId. Slot N is at 20/32 here      //management      bool public isShutdown; //@audit-info this moved up. Slot N is full at 21/32 here      bool private _status; //@audit-info this moved up. Slot N is full at 22/32 here      bool private constant _NOT_ENTERED = false; //@audit-info this moved up but doesn't take a slot as it's constant     bool private constant _ENTERED = true; //@audit-info this moved up but doesn't take a slot as it's constant       //rewards     RewardType[] public rewards; ```    "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Typos  ## Proof of Concept The typos are here:  `vaulId` https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexModule.sol#L14 https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexModule.sol#L25  ## Tools Used VS Code  ## Recommended Mitigation Steps Correct the typos  "}, {"title": "caching curveToken in  memory can cost less gas", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Funen   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L94-L95  ``` IERC20(curveToken).approve(convexBooster, 0); IERC20(curveToken).approve(convexBooster, type(uint256).max); ```  `curveToken` was called mutiple times, caching it in `memory` , it can cost less gas  "}, {"title": "Lack of important event", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/43", "labels": ["bug", "0 (Non-critical)", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact owner can change the source without any warning.  ## Proof of Concept The method `Cvx3CrvOracle.setSource` should emit an event in order to be able to detect this call by dapps.  ## Tools Used Manual review  ## Recommended Mitigation Steps Emit an event  "}, {"title": "Missing commenting", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  robee   # Vulnerability details  The following functions are missing commenting as describe below:              ConvexStakingWrapper.sol, user_checkpoint (external), @return is missing  "}, {"title": "Prefix increments are cheaper than postfix increments", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 115         change to prefix increment and unchecked: ConvexStakingWrapper.sol, u, 172         change to prefix increment and unchecked: ConvexStakingWrapper.sol, u, 227         change to prefix increment and unchecked: ConvexYieldWrapper.sol, i, 111         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 287         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 271         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 315         change to prefix increment and unchecked: ConvexYieldWrapper.sol, i, 63  "}, {"title": "Unnecessary array boundaries check when loading an array element twice", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           ConvexStakingWrapper.sol, variable name: _accounts times: 5 at: _calcRewardIntegral         ConvexStakingWrapper.sol, variable name: _accounts times: 5 at: _calcCvxIntegral  "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).           ConvexModule.sol, line 3, import \"@yield-protocol/vault-interfaces/DataTypes.sol\";         ConvexStakingWrapper.sol, line 9, import \"./interfaces/IConvexDeposits.sol\";         ConvexStakingWrapper.sol, line 10, import \"./interfaces/ICvx.sol\";  "}, {"title": "missing whenNotPaused", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-aave-lens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/LensHub.sol#L929   # Vulnerability details  All the external function of LensHub have whenNotPasued modifier. However, LensHub is erc721 and the transfer function doesn't have the whenNotPaused modifier.  ## Impact In case where the governance wants to stop all activity, they still can't stop transferring profiles nfts. an example where stopping transferring tokens was actually very helpful: [https://mobile.twitter.com/flashfish0x/status/1466369783016869892](https://mobile.twitter.com/flashfish0x/status/1466369783016869892)   ## Recommended Mitigation Steps add whenNotPasued to `_beforeTokenTransfer`  "}, {"title": "It's possible to follow deleted profiles", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/70", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-aave-lens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/libraries/InteractionLogic.sol#L49   # Vulnerability details  When someone tries to follow a profile, it checks if the handle exists, and if it doesn't, it reverts because the profile is deleted. The problem is that there might be a new profile with the same handle as the deleted one, allowing following deleted profiles.   ## Proof of Concept Alice creates a profile with the handle \"alice.\" The profile id is 1. she deleted the profile. she opens a new profile with the handle \"alice\". The new profile id is 2. bob tries to follow the deleted profile (id is 1). the check ``` if (_profileIdByHandleHash[keccak256(bytes(handle))] == 0)  revert Errors.TokenDoesNotExist(); ``` doesn't revert because there exists a profile with the handle \"alice\". Therefore bob followed a deleted profile when he meant to follow the new profile.   ## Recommended Mitigation Steps  change to: ``` if (_profileIdByHandleHash[keccak256(bytes(handle))] != profileIds[i])  revert Errors.TokenDoesNotExist(); ```   "}, {"title": "Collect modules can fail on zero amount transfers if treasury fee is set to zero", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-aave-lens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L176   # Vulnerability details  ## Impact  Treasury fee can be zero, while collect modules do attempt to send it in such a case anyway as there is no check in place. Some ERC20 tokens do not allow zero value transfers, reverting such attempts.  This way, a combination of zero treasury fee and such a token set as a collect fee currency will revert any collect operations, rendering collect functionality unavailable  ## Proof of Concept  Treasury fee can be set to zero:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/ModuleGlobals.sol#L109  Treasury fee transfer attempts are now done uncoditionally in all the collect modules.  Namely, FeeCollectModule, LimitedFeeCollectModule, TimedFeeCollectModule and LimitedTimedFeeCollectModule do not check the treasury fee to be send, `treasuryAmount`, before transferring:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L176  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedFeeCollectModule.sol#L194  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/TimedFeeCollectModule.sol#L190  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedTimedFeeCollectModule.sol#L205  The same happens in the FeeFollowModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/follow/FeeFollowModule.sol#L90  ## References  Some ERC20 tokens revert on zero value transfers:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  ## Recommended Mitigation Steps  Consider checking the treasury fee amount and do transfer only when it is positive.  Now: ``` IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount); ```  To be: ``` if (treasuryAmount > 0)  IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount); ```   "}, {"title": "Basis points constant BPS_MAX is used as minimal fee amount requirement", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-aave-lens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L72   # Vulnerability details  ## Impact  Base fee modules require minimum fixed fee amount to be at least BPS_MAX, which is hard coded to be 10000.  This turns out to be a functionality restricting requirement for some currencies.  For example, WBTC (https://etherscan.io/token/0x2260fac5e5542a773aa44fbcfedf7c193bc2c599, #10 in ERC20 token rankings), has decimals of 8 and current market rate around $40k, i.e. if you want to use any WBTC based collect fee, it has to be at least $4 per collect or fee enabled follow.  Tether and USDC (https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7 and https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48, #1 and #3) have decimals of 6, so it is at least $0.01 per collect/follow, which also looks a bit tight for a hard floor minimum.  ## Proof of Concept  BPS_MAX is a system wide constant, now 10000:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/FeeModuleBase.sol#L17  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/ModuleGlobals.sol#L20  This is correct for any fees defined in basis point terms.  When it comes to the nominal amount, 10000 can be too loose or too tight depending on a currency used, as there can be various combinations of decimals and market rates.   The following base collect module implementations require fee amount to be at least BPS_MAX (initialization reverts when amount < BPS_MAX):  All collect module implementations use the same check:  FeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L72  LimitedFeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedFeeCollectModule.sol#L79  TimedFeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/TimedFeeCollectModule.sol#L81  LimitedTimedFeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedTimedFeeCollectModule.sol#L86   FeeFollowModule also uses the same approach:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/follow/FeeFollowModule.sol#L62  ## Recommended Mitigation Steps  As a simplest solution consider adding a separate constant for minimum fee amount in nominal terms, say 1 or 10   "}, {"title": "Governance Voting Dis-proportionally Favours Users Who Stake And Vote After A Poll Has Been Created And Had Its Snapshot Taken", "html_url": "https://github.com/code-423n4/2022-02-anchor-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-anchor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L543-L580 https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L582-L665 https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/staking.rs#L15-L57 https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L364-L455   # Vulnerability details  ## Impact  Polls are created by targeting the `receive_cw20` function which is queried whenever the contract receives tokens. By setting the hook message to `Cw20HookMsg::CreatePoll`, the sender is able to create a poll, assuming the amount sent satisfies the minimum deposit amount for poll creation. Users can also choose to call `ExecuteMsg::SnapshotPoll` or have it handled automatically when a user casts a vote on the newly created poll.  The snapshot simply sets `a_poll.staked_amount`, which represents the total staked amount within the governance contract at a given block. However, during the voting period, other users can stake tokens and effectively have an increasing influence over the outcome of a given poll. There are no check-pointed balances to ensure that a certain user had staked tokens at the time the poll had its snapshot taken.  This can be abused to skew poll results in favour of users who stake their Anchor tokens after a poll has had its snapshot taken.  ## Proof of Concept  Let's assume the share to token exchange rate is `1:1` such that if a user deposits 100 Anchor tokens, they receive 100 shares in return.  Consider the following scenario:  - There are a total of 100 Anchor tokens in the Governance contract. - Alice creates a poll and executes `ExecuteMsg::SnapshotPoll` such that `a_poll.staked_amount == 100`. - Bob deposits 10 Anchor tokens through the `Cw20HookMsg::StakeVotingTokens` hook message which increases the contract's total balance to 110 and shares to 110 as the exchange rate is `1:1` upon minting and redeeming shares. - At this point, the target poll has a `a_poll.staked_amount == 100`, even though there are really 110 Anchor tokens staked. - As a result, if Bob votes on a poll, they have a 10% degree of influence on the outcome of the poll, even though they have less than 10% of the total staked tokens (i.e. 10/110). - Therefore, poll voters are actually incentivised to stake tokens after a poll has had its snapshot taken in order to maximise their voting power.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing a check-pointing mechanism such that when a user casts a vote, the user's staked balance is checked at the block height upon which the snapshot was taken instead of checking its most up-to-date staked balance. This check-pointing behaviour is implemented on Ethereum which has a more restrictive block space. The mechanism will simply store the staker's balance on each stake/unstake action. When user's wish to vote, the protocol will check the balance at a specific block (i.e. the snapshotted block). An example implementation can be found [here](https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol#L189-L221).  "}, {"title": "Simple interest calculation is not exact", "html_url": "https://github.com/code-423n4/2022-02-anchor-findings/issues/41", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-anchor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts%2Fmoney-market-contracts%2Fcontracts%2Fmarket%2Fsrc%2Fborrow.rs#L304   # Vulnerability details  ## Impact The borrow rate uses a simple interest formula to compute the accrued debt, instead of a compounding formula.  ```rust pub fn compute_interest_raw(     state: &mut State,     block_height: u64,     balance: Uint256,     aterra_supply: Uint256,     borrow_rate: Decimal256,     target_deposit_rate: Decimal256, ) {   // @audit simple interest     let passed_blocks = Decimal256::from_uint256(block_height - state.last_interest_updated);      let interest_factor = passed_blocks * borrow_rate;     let interest_accrued = state.total_liabilities * interest_factor;     // ... } ```  This means the actual borrow rate and interest for suppliers depend on how often updates are made. This difference should be negligible in highly active markets, but it could lead to a lower borrow rate in low-activity markets, leading to suppliers losing out on interest.  ## Recommended Mitigation Steps Ensure that the markets are accrued regularly, or switch to a compound interest formula (which has a higher computational cost due to exponentiation, but can be approximated, see Aave).   "}, {"title": "Sandwich attack on astroport sweep", "html_url": "https://github.com/code-423n4/2022-02-anchor-findings/issues/33", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-anchor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts%2Fanchor-token-contracts%2Fcontracts%2Fcollector%2Fsrc%2Fcontract.rs#L130-L137   # Vulnerability details  ## Impact The collector contract allows anyone to `sweep`, swapping an asset token to ANC through astro port. Note that `belief_price` is not set and `config.max_spread` might not be set as well or misconfigured.  This allows an attacker to create a contract to perform a sandwich attack to make a profit on this trade.  > A common attack in DeFi is the sandwich attack. Upon observing a trade of asset X for asset Y, an attacker frontruns the victim trade by also buying asset Y, lets the victim execute the trade, and then backruns (executes after) the victim by trading back the amount gained in the first trade. Intuitively, one uses the knowledge that someone\u2019s going to buy an asset, and that this trade will increase its price, to make a profit. The attacker\u2019s plan is to buy this asset cheap, let the victim buy at an increased price, and then sell the received amount again at a higher price afterwards.  Trades can happen at a bad price and lead to receiving fewer tokens than at a fair market price. The attacker's profit is the protocol's loss.  #### POC Attacker creates a contract that triggers 3 messages for the sandwich attack:  - Astroport: buy ANC with asset - call `sweep` which trades at bad price - Astroport: sell assets from the first message for profit   ## Recommended Mitigation Steps Consider setting a ANC/asset `belief_price` from an oracle.   "}, {"title": "Failed polls still marked as executed in poll indexer", "html_url": "https://github.com/code-423n4/2022-02-anchor-findings/issues/4", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-anchor-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-token-contracts/contracts/gov/src/contract.rs#L530-L531   # Vulnerability details  # Impact Users will still be able to find failed polls under \"Executed\" and \"Failed\"  # Proof of Concept A poll attempts to execute and fails. That poll will stay in the poll indexer as executed and failed.  # Mitigation `Passed` should be `Executed`.   Test proof: https://pastebin.com/Cz0wujn9   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/265", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "1) Use != instead of > for uint256 in StakingReward.sol:   Both amount and reward are of type uin256 comparing, checking for inequality instead of a greater than relation saves gas. The comparisons can be found in the lines below  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L94  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L119  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L119  Cache length before for loop ConcurRewardPool.sol:  2) The length can be cached before the loop avoid calling length many times to save gas.  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L35  3) Assignment to default value   In L51 uint totalAllocPoint is being declared with the default value of 0. Just totalAllocPoint; will save gas. The same thing can also be observed in StakingRewards.sol L21 and L22. Also in ConvexStakingWrapper.sol L36  Similarly bool transferSuccess is also being assigned False in L204  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L51  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L204  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L21  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L22  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L36  4) Resturcture if-else statement to remove else in StakingRewards.sol L142:  if (block.timestamp >= periodFinish) {             rewardRate = reward / rewardsDuration;         } else {             uint256 remaining = periodFinish - block.timestamp;             uint256 leftover = remaining * rewardRate;             rewardRate = (reward + leftover) / rewardsDuration;         }  can be reformulated as:  rewardRate = reward / rewardsDuration; if (block.timestamp < periodFinish) {             uint256 remaining = periodFinish - block.timestamp;             uint256 leftover = remaining * rewardRate;             rewardRate += (leftover / rewardsDuration);         }   https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L142   5) use unchecked{...} to save gas  uint256 is way too big to realistically lead to overflows, unchecked can be used to save gas in the following situations.   https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L121  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L219  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L34        "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/263", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# QA Report **Table of Contents:**  - [QA Report](#qa-report)   - [Transfers](#transfers)     - [Prevent accidentally burning tokens](#prevent-accidentally-burning-tokens)     - [Use safeTransfer or require()/conditional instead of transfer/transferFrom](#use-safetransfer-or-requireconditional-instead-of-transfertransferfrom)     - [Use SafeERC20.safeApprove()](#use-safeerc20safeapprove)   - [Libraries](#libraries)     - [Deprecated library used for Solidity 0.8.11: SafeMath](#deprecated-library-used-for-solidity-0811-safemath)   - [Variables](#variables)     - [Missing Address(0) checks](#missing-address0-checks)     - [Variables that should be constant](#variables-that-should-be-constant)     - [Variables that are assumed to be initialized before a function call, but might not be](#variables-that-are-assumed-to-be-initialized-before-a-function-call-but-might-not-be)     - [Variables that should be bounded](#variables-that-should-be-bounded)     - [Variables that should be grouped together in a struct](#variables-that-should-be-grouped-together-in-a-struct)       - [File: ConvexStakingWrapper.sol](#file-convexstakingwrappersol)       - [File: Shelter.sol](#file-sheltersol)   - [Functions](#functions)     - [Functions that should be declared external](#functions-that-should-be-declared-external)   - [Arithmetics](#arithmetics)     - [Possible division by 0](#possible-division-by-0)  ## Transfers ### Prevent accidentally burning tokens  Transferring tokens to the zero address is usually prohibited to accidentally avoid \"burning\" tokens by sending them to an unrecoverable zero address.  Places where I couldn't find a zero address check (or where the destination isn't a zero-checked address): ``` ConvexStakingWrapper.sol:179:            IERC20(reward.token).transfer(treasury, d_reward / 5); //@audit treasury isn't address(0) checked ConvexStakingWrapper.sol:182:        IERC20(reward.token).transfer(address(claimContract), d_reward);//@audit claimContract isn't address(0) checked MasterChef.sol:206:            transferSuccess = concur.transfer(_to, concurBalance);//@audit _to == _recipient and isn't address(0) checked MasterChef.sol:208:            transferSuccess = concur.transfer(_to, _amount); //@audit _to == _recipient and isn't address(0) checked ```   I suggest adding a check to prevent accidentally burning tokens.  ### Use safeTransfer or require()/conditional instead of transfer/transferFrom  Silent failures (lack of failure detection / revert in case of failure) may happen here: ``` File: ConvexStakingWrapper.sol 178:         if (reward.token == cvx || reward.token == crv) { 179:             IERC20(reward.token).transfer(treasury, d_reward / 5); //@audit return value ignored 180:             d_reward = (d_reward * 4) / 5; 181:         } 182:         IERC20(reward.token).transfer(address(claimContract), d_reward);//@audit return value ignored ``` Consider using safeTransfer. That's already the case at other places on the same contract  ### Use SafeERC20.safeApprove() `approve()` will fail for certain token implementations that do not return a boolean value. It is recommended to use OpenZeppelin's SafeERC20's safeApprove().  Instances include: ``` USDMPegRecovery.sol:79:        usdm.approve(address(usdm3crv), addingLiquidity); USDMPegRecovery.sol:80:        pool3.approve(address(usdm3crv), addingLiquidity); ```  ## Libraries  ### Deprecated library used for Solidity 0.8.11: SafeMath Use Solidity 0.8.*'s default checks instead:  ``` MasterChef.sol:10:import \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; MasterChef.sol:14:    using SafeMath for uint; ```  ## Variables  ### Missing Address(0) checks ```   - rewardNotifier = _notifier (contracts/ConcurRewardPool.sol#16)   - treasury = _treasury (contracts/ConvexStakingWrapper.sol#70)   - treasury = _treasury (contracts/ConvexStakingWrapper.sol#83)   - rewardsDistribution = _rewardsDistribution (contracts/StakingRewards.sol#45)   - rewardsDistribution = _rewardsDistribution (contracts/StakingRewards.sol#195)   - kpiOracle = _kpiOracle (contracts/USDMPegRecovery.sol#57)   - (success,result) = _to.call{value: _value}(_data) (contracts/VoteProxy.sol#33) ```  ### Variables that should be constant ``` MasterChef._concurShareMultiplier (contracts/MasterChef.sol#56) MasterChef._perMille (contracts/MasterChef.sol#57) MasterChef.concurPerBlock (contracts/MasterChef.sol#50) ```  ### Variables that are assumed to be initialized before a function call, but might not be ``` File: ConvexStakingWrapper.sol 50:     IConcurRewardClaim public claimContract; ... 86:     function setRewardPool(address _claimContract) external onlyOwner { 87:         claimContract = IConcurRewardClaim(_claimContract); 88:     } ``` ### Variables that should be bounded  The variable `MasterChef.sol:43: uint16 depositFeeBP;  // Deposit fee in basis points` is never bounded, and UInt16.MaxValue is 65535  ### Variables that should be grouped together in a struct  For maps that use the same key value: having separate fields is error prone (like in case of deletion or future new fields).  #### File: ConvexStakingWrapper.sol  6 maps can be grouped together, as they use the same `pid`: ``` 41:     //convex rewards 42:     mapping(uint256 => address) public convexPool; 43:     mapping(uint256 => RewardType[]) public rewards; 44:     mapping(uint256 => mapping(uint256 => mapping(address => Reward))) 45:         public userReward; 46:     mapping(uint256 => mapping(address => uint256)) public registeredRewards; ... 63:     mapping(uint256 => mapping(address => Deposit)) public deposits; 64:     mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest; ``` I'd suggest these 3 related data get grouped in a struct, let's name it `RewardInfo`:   ``` struct RewardInfo {     address convexPool;     RewardType[] rewards;     mapping(uint256 => mapping(address => Reward)) userReward;     mapping(address => uint256) registeredRewards;     mapping(address => Deposit) deposits;     mapping(address => WithdrawRequest) withdrawRequest;   }   ``` And it would be used as a state variable in this manner (where `uint256` is `pid`):   ```   mapping(uint256 => RewardInfo) rewardInfo;   ```    #### File: Shelter.sol 3 maps can be grouped together, as they use the same `_token`: ```   17:     mapping(IERC20 => mapping(address => bool)) public override claimed; 18:  19:     mapping(IERC20 => uint256) public activated; 20:  21:     mapping(IERC20 => uint256) public savedTokens; ``` I'd suggest these 3 related data get grouped in a struct, let's name it `TokenInfo`:   ``` struct TokenInfo {     mapping(address => bool) claimed;     uint256 activated;     uint256 savedTokens;   }   ``` And it would be used as a state variable in this manner (where `IERC20` is `_token`):   ```   mapping(IERC20 => TokenInfo) tokenInfo;   ```    ## Functions  ### Functions that should be declared external ```  - ConvexStakingWrapper.addRewards(uint256) (contracts/ConvexStakingWrapper.sol#93-140)  - MasterChef.add(address,uint256,uint16,uint256) (contracts/MasterChef.sol#86-101)  - MasterChef.massUpdatePools() (contracts/MasterChef.sol#127-132) ```  ## Arithmetics  ### Possible division by 0 There are no checks that the denominator is `!= 0` at thoses lines: ``` library\\CvxMining.sol:16:        uint256 cliff = supply / reductionPerCliff; MasterChef.sol:120:            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint); MasterChef.sol:121:            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply)); MasterChef.sol:151:        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint); MasterChef.sol:152:        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply)); Shelter.sol:54:        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token); ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/258", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "## Do not recalculate constant results  Since results are constant, the code should not calculate them over and over again.  [https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L116-L117](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L116-L117)  ```  registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1 registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1  ```  ## `StakingRewards.sol` cache variables to save gas  By caching variables, loads from storage can be avoided to save gas.  ```  rewardPerToken() \u2014 rewardPerTokenStored  notifyRewardAmount() \u2014 rewardsDuration, periodFinish  updateReward() \u2014 rewardPerTokenStored (cache the new value)  ```  ## `USDMPegRecovery.sol` cache variables to save gas  By caching variables, loads from storage can be avoided to save gas.  ```  provide() -- step, usdm3crv  ```  ## At setters emit input rather than from storage to save gas  In `StakingRewards.sol`:  ```  setRewardsDuration  setRewardsDistribution  ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/256", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "* Repeated external call to usdm.balanceOf(address(this): ```solidity   require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");   ...   uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step; ```  * Don't need to call owner() here, you can just use msg.sender: ```solidity   function recoverERC20(address tokenAddress, uint256 tokenAmount)       external       onlyOwner   {       ...       IERC20(tokenAddress).safeTransfer(owner(), tokenAmount); ```  * Long revert messages, e.g.: \"Previous rewards period must be complete before changing the duration for the new period\" Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.  * Variables that are set in the constructor and can't be changed can be marked as immutable: ```solidity     uint256 public step;     uint256 public startLiquidity;     uint public startBlock;     uint public endBlock; ```  * Should be constant: ```solidity     uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block     uint private _concurShareMultiplier = 1e18;     uint private _perMille = 1000; // 100% ```  * Variables and events that are not used in any meaningful way can be removed or used where they were intended: ```solidity     uint256 public startLiquidity;     event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount); ```  * Would be cheapier to use local variables when emitting events, e.g.: ```solidity   rewardsDuration = _rewardsDuration;   emit RewardsDurationUpdated(rewardsDuration);    rewardsDistribution = _rewardsDistribution;   emit RewardsDistributionUpdated(rewardsDistribution); ```  * Usually under normal conditions, the first check is not neccessary, as GRACE_PERIOD > block.timestamp should always revert: ```solidity   require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\"); ```  * This could be inlined to optimize for gas usage, from: ```solidity   bool transferSuccess = false;   if (_amount > concurBalance) {       transferSuccess = concur.transfer(_to, concurBalance);   } else {       transferSuccess = concur.transfer(_to, _amount);   }   require(transferSuccess, \"safeConcurTransfer: transfer failed\"); ``` to: ```solidity   if (_amount > concurBalance) {       require(concur.transfer(_to, concurBalance), \"safeConcurTransfer: transfer failed\");   } else {       require(transferSuccess = concur.transfer(_to, _amount), \"safeConcurTransfer: transfer failed\");   } ```  * Repeated access of storage variables should be cached, e.g. convexBooster is accessed 3 times: ```solidity   lpToken.safeApprove(convexBooster, _amount);   IConvexDeposits(convexBooster).deposit(_pid, _amount, true);   lpToken.safeApprove(convexBooster, 0); ``` masterChef twice: ```solidity   uint256 pid = masterChef.pid(address(lpToken));   masterChef.deposit(msg.sender, pid, _amount); ``` convexPool[_pid] twice: ```solidity   IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);   IERC20 lpToken = IERC20(     IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken   ); ``` registeredRewards[_pid] twice: ```solidity   registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1   registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1 ```  * The initialization to default variables is not neccessary: ```solidity     uint256 public periodFinish = 0;     uint256 public rewardRate = 0; ```  * If the same MasterChef implementation will be used, then the pid of the token can't change, so you should cache it once (in the constructor call), and do not make the external calls again and again in stake and withdraw functions of StakingRewards: ```solidity   uint256 pid = masterChef.pid(address(stakingToken)); ```  * Contract MasterChef has declared a compiler version of ^0.8.11 but it still uses the SafeMath library: ```solidity   using SafeMath for uint;   // e.g.:   return _to.sub(_from);   uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);   accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply)); ``` Overflow/underflow protection is built-in starting from version 0.8, so you don't need to use SafeMath here.  * Would be cheaper if you checked not the storage but the _amount paramater against 0 in the first sentence: ```solidity   require(user.amount > 0, \"MasterChef: nothing to withdraw\");   require(user.amount >= _amount, \"MasterChef: withdraw not allowed\"); ```  * currentEpoch() is called twice, should cache after the first call: ```solidity   require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), \"wait\"); ```  * You already have the address of rewardToken() here, no need to fetch it again:  ```solidity   address extraToken = IRewardStaking(extraPool).rewardToken();     ...     else if (registeredRewards[_pid][extraToken] == 0) {       //add new token to list       rewards[_pid].push(           RewardType({               token: IRewardStaking(extraPool).rewardToken() ```  * In _calcRewardIntegral I think these statements: ```solidity     //update remaining reward here since balance could have changed if claiming     if (bal != reward.remaining) {         reward.remaining = uint128(bal);     } ``` should be placed right after this: ```solidity     uint256 d_reward = bal - reward.remaining; ``` or you can even return and skip all the heavy calculations and 0 value transfers if the balance hasn't changed."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/254", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "* Function recoverERC20 in StakingRewards allows an owner to transfer out any token except stakingToken. I see 2 problems with this: 1) It should also forbid transferring of rewardsToken, otherwise an owner can drain the rewards and DDOS users withdrawals because there is no way to get back your stake tokens without claiming the rewards. 2) It may be possible that someone accidentally sent stake tokens directly to the contract and these tokens will not be accounted in _totalSupply, thus it makes sense that an owner should be able to rescue these unaccounted tokens: stakingToken.balanceOf(address(this) - _totalSupply).  I assigned this issue a severity of low because I assume we can trust the owner not to exploit this :?  You should forbid recoverERC20 of rewardsToken, and may also allow transferring the surplus from _totalSupply of stakingToken. Usually, it is a good practice in such contracts to have an emergency withdrawal function, where users can get back their stake tokens but forfeit the rewards.  * Function setRewardsDistribution has a misleading revert message:  \"... changing the duration ...\"  * A small loss in precision due to multiplication and division: ```solidity   IERC20(reward.token).transfer(treasury, d_reward / 5);   d_reward = (d_reward * 4) / 5; ``` A more accurate approach would be something like this: ```solidity   uint toTreasury = d_reward / 5;   IERC20(reward.token).transfer(treasury, toTreasury);   d_reward -= toTreasury; ```  * Consider introducing a reasonable upper limit for the rewards[_pid] array in ConvexStakingWrapper, otherwise if it grows too large it may exceed the gas limit when performing the _checkpoint and there is no way to remove it once added.  * ConvexStakingWrapper function addRewards fetches extraRewards and adds them to the list of rewards, but please note that extra rewards can change: https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L109-L119 Currently, ConvexStakingWrapper has no function to (sync) delete extra rewards. Consider implementing it.  * You should use safe casts here: ```solidity   deposits[_pid][msg.sender].amount += uint192(_amount);   deposits[_pid][msg.sender].amount -= uint192(_amount);   amount : uint192(_amount) ``` Otherwise, if token amounts are exceeding these limits (e.g. rebasing tokens) the accounted and transferred amounts will differ. For instance, in function deposit it will add less to the user's balance but charge the full amount: ```solidity   deposits[_pid][msg.sender].amount += uint192(_amount);   ...   lpToken.safeTransferFrom(msg.sender, address(this), _amount); ```  * I don't think this check in function provide of contract USDMPegRecovery is correct: ```solidity   require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\"); ``` After you provide the liquidity (usdm3crv.add_liquidity), the balance of usdm will decrease, but totalLiquidity.usdm, will not, so the next time it will need to increase even more to reach this condition again. But not sure what was the exact intention here, so submitting this as of low severity FYI.  * Consider introducing a withdrawal deadline to indicate when it is too late and the user has to requestWithdraw again.  * I think the comment and the actual code is misleading here: ```solidity    if (extraToken == cvx) {         //no-op for cvx, crv rewards         rewards[_pid][CVX_INDEX].pool = extraPool;     }  ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/253", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "1. LOW: Solidity version pragma uses caret.  [Example](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L3) Note that this issue is present in pretty much every other contract in the project.  This is a bad practice because `^0.8.11` means that the contracts can be compiled with solidity versions greater than or equal to 0.8.11 but less than 0.9.0. Because any number of solidity versions can be used, it is possible that the contracts are tested with one version of solidity and deployed to production using another version of solidity, which can lead to issues if there are bugs in the solidity compiler. Instead, the lines should be replaced with `pragma solidity 0.8.11;`  so that 0.8.11 is used in production and testing.  3. informational: `safeTransfer` to `msg.sender` in `StakingRewards.withdraw` should come after all effects. [location](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L111) This follows the check-effects-interactions pattern, and is good defense-in-depth (since there function uses `nonReentrant` modifier).  4. Informational: Code layout in StakingRewards doesn't obey conventions, events are on the bottom. [Example](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L213) They should come before functions. Putting events at the end is inconsistent with the other contracts in this repo. [It is also inconsistent with solidity's standard conventions](https://docs.soliditylang.org/en/v0.8.11/style-guide.html#order-of-layout) "}, {"title": "Deposits after the grace period should not be allowed", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/251", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L34 https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L54   # Vulnerability details  ## Impact Function donate in Shelter shouldn't allow new deposits after the grace period ends, when the claim period begins.  Otherwise, it will be possible to increase savedTokens[_token], and thus new user claim amounts will increase after some users might already have withdrawn their shares.  ## Recommended Mitigation Steps Based on my understanding, it should contain this check: ```solidity   require(activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\"); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/247", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "###GAS OPTIMIZATION --1 -unnecessary `i` value set https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L35 unnecessary value set. the default value of uint is zero. just use: ``` uint i; ``` --2 -better increment https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L35 change i++ to ++i --3 -Best way to use `SafeERC20.function` for gas opt https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L10 by not declare: ``` using SafeERC20 for IERC20; ``` and use: ``` SafeERC20.safeTransfer(IERC20(_tokens[i]), msg.sender, getting); ``` can safe gas usage. --4 -unnecessary variable declaration -Unnecessary (uint) `getting` variable declaration https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L36 instead of caching `reward[msg.sender][_tokens[i]]` in `getting`, better just pass it directly into `safeTransfer()` function. `getting` was declared and called once per loop. It cost more gas.  recommended mitigation: ``` IERC20(_tokens[i]).safeTransfer(msg.sender, reward[msg.sender][_tokens[i]]); // L 36 ``` ##ConvexStakingWrapper.sol --5 -Using `storage` to declare Struct variable inside function https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L171 instead of caching `rewardType` to memory. read it directly from storage. ``` RewardType storage reward = rewards[_pid][_index]; ``` --6 -Using `uint` instead `struct` https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L24 The `Reward` struct merely contain 1 property. Instead of declaring it as struct, better as a uint example: uint128 integralReward(example name); https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L44 then modify the `userReward` mapping output from `Reward` to `uint`. ##MasterChef.sol --7 -unnecessary `totalAllocPoint` & `_pid` value set  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L51 https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L129 unnecessary value set. the default value of uint is zero. just use: ``` uint public totalAllocPoint; ``` --8 -use constant for gas saving https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L57 use `constant` to declare `_perMille` & ` _concurShareMultiplier` uint --9 -Unused library https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L15 unused SafeERC20 lib ##Shelter.sol --10 -`&&` is more expensive gas https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L45 using multiple `require()` is cheaper than use && ``` require(activated[_token] != 0 , \"too late\"); require(activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\"); ``` --11 -unnecessary value set https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L21-L22 unnecessary value set. the default value of uint is zero for `rewardRate` & `periodFinish`. uint default value is 0 --12 -`step` declaration https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L22 setting the `step` value directly and use `constant` can save gas. then remove the line: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L56 --13 -using storage to declare struct inside function https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L91 instead of caching `Liquidity` in memory. just read it directly to storage ``` Liquidity storage total = totalLiquidity; ``` it can save gas. And same for `user` variable right below it. --14 -unnecessary math operation https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L116-L117 the value of `registeredRewards[_pid][crv]` and `registeredRewards[_pid][cvx]` is fixed, Set the value(1 and 2) directly then add additional info which explain the math operation behind it: ```             registeredRewards[_pid][crv] = 1; //mark registered CRV_INDEX + 1             registeredRewards[_pid][cvx] = 2; //mark registered CVX_INDEX + 1 ``` --15 -use calldata to store `signature` https://github.com/code-423n4/2022-02-concur/blob/main/contracts/EasySign.sol#L51 replace memory with calldata to save gas --16 -Using `immutable` to declare variable which set once at constructor https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L52-L54 `startBlock`, `endBlock` & `concur` are set once in constructor. Use `immutable` --17 -use `require()` to validate instead `if()` https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L137 by using: ```  require(block.number > pool.lastRewardBlock); ``` to replace: ```         if (block.number <= pool.lastRewardBlock) {             return;         } ``` can save gas with the same output 18-- -Unncessary `multiplier` (uint) declaration https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L150-L151 `multiplier` is called once in `updatePool()`. Its gas consuming to cache `getMultiplier` return in `multiplier`. Remove line 150, and change line it to: ``` uint concurReward = getMultiplier(pool.lastRewardBlock, block.number).mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint); ```     "}, {"title": "Repeated Calls to Shelter.withdraw Can Drain All Funds in Shelter", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/246", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L52-L57   # Vulnerability details  ## Impact tl;dr Anyone who can call `withdraw` to withdraw their own funds can call it repeatedly to withdraw the funds of others. `withdraw` should only succeed if the user hasn't withdrawn the token already.  The shelter can be used for users to withdraw funds in the event of an emergency. The `withdraw` function allows callers to withdraw tokens based on the tokens they have deposited into the shelter client: ConvexStakingWrapper. However, `withdraw` does not check if a user has already withdrawn their tokens. Thus a user that can `withdraw` tokens, can call withdraw repeatedly to steal the tokens of others.  ## Proof of Concept  tl;dr an attacker that can successfully call `withdraw` once on a shelter, can call it repeatedly to steal the funds of others. Below is a detailed scenario where this situation can be exploited.  1. Mallory deposits 1 `wETH` into `ConvexStakingWrapper` using [`deposit`](https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L280). Let's also assume that other users have deposited 2 `wETH` into the same contract. 2. An emergency happens and the owner of `ConvexStakingWrapper` calls `setShelter(shelter)` and `enterShelter([pidOfWETHToken, ...])`. Now `shelter` has 3 `wETH` and is activated for `wETH`. 3. Mallory calls `shelter.withdraw(wETHAddr, MalloryAddr)`, mallory will rightfully receive 1 wETH because her share of wETH in the shelter is 1/3. 4. Mallory calls `shelter.withdraw(wETHAddr, MalloryAddr)` again, receiving 1/3*2 = 2/3 wETH. `withdraw` does not check that she has already withdrawn. This time, the wETH does not belong to her, she has stolen the wETH of the other users. She can continue calling `withdraw` to steal the rest of the funds   ## Tools Used  Manual inspection.  ## Recommended Mitigation Steps  To mitigate this, `withdraw` must first check that `msg.sender` has not withdrawn this token before and `withdraw` must also record that `msg.sender` has withdrawn the token. The exact steps for this are below: 1. Add the following line to the beginning of `withdraw` (line 53): ``` require(!claimed[_token][msg.sender], \"already claimed\") ``` 2.  Replace [line 55](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L55) with the following: ``` claimed[_token][msg.sender] = true; ``` This replacement is necessary because we want to record who is withdrawing, not where they are sending the token which isn't really useful info.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/245", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": " 1. considered using != instead of > can save gas https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L236 // gas cost 45422  Change to: ```  if (_amount != 0) { ``` // gas cost 45419  ========================================================================  2. using calldata can save gas https://github.com/code-423n4/2022-02-concur/blob/main/contracts/EasySign.sol#L51 // gas cost 23523  Change to: ``` function tryRecover(bytes32 hash, bytes calldata signature) ``` // gas cost 23056  ========================================================================  3. considered using require instead of `if` can save gas https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L118 // gas cost 24404  Change to: ```         require (block.number > pool.lastRewardBlock);         require (lpSupply != 0);  ``` // gas cost 24392  ========================================================================  4. considered using require instead of && can save gas  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L45 // gas cost 24475  Change to: ```         require(activated[_token] != 0);         require (activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\"); ``` // gas cost 24162"}, {"title": "Unconstrained fee", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/242", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86-L101   # Vulnerability details  ## Impact  Token fee in `MasterChef` can be set to more than 100%, (for example by accident) causing all `deposit` calls to fail due to underflow on subtraction when reward is lowered by the fee, thus breaking essential mechanics. Note that after the fee has been set to any value, it cannot be undone. A token cannot be removed, added, or added the second time. Thus, mistakenly (or deliberately, maliciously) added fee that is larger than 100% will make the contract impossible to recover from not being able to use the token.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  On setting fee ensure that it is below a set maximum, which is set to no more than 100%.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "1. Tittle Changing memory to storage can safe gas.  ## Impact Bye changing memory pointer to storage pointer and delete line ``https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L206.`` ``https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L105.``, can safe gas.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L206. https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L105."}, {"title": "ConvexStakingWrapper deposits and withdraws will frequently be disabled if a token that doesn't allow zero value transfers will be added as a reward one", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/231", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L182   # Vulnerability details  ## Impact  If deposits and withdraws are done frequently enough, the reward update operation they invoke will deal mostly with the case when there is nothing to add yet, i.e. `reward.remaining` match the reward token balance.  If reward token doesn't allow for zero value transfers, the reward update function will fail on an empty incremental reward transfer, which is now done unconditionally, reverting the caller deposit/withdrawal functionality  ## Proof of Concept  When ConvexStakingWrapper isn't paused, every deposit and withdraw update current rewards via `_checkpoint` function before proceeding:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L233  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L260  `_checkpoint` calls `_calcRewardIntegral` for each of the reward tokens of the pid:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L220  `_calcRewardIntegral` updates the incremental reward for the token, running the logic even if reward is zero, which is frequently the case:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L182  If the reward token doesn't allow zero value transfers, this transfer will fail, reverting the corresponding deposit or withdraw  ## Recommended Mitigation Steps  Consider checking the reward before doing transfer (and the related computations as an efficiency measure):  Now: ``` IERC20(reward.token).transfer(address(claimContract), d_reward); ```  To be: ``` if (d_reward > 0)  IERC20(reward.token).transfer(address(claimContract), d_reward); ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/230", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "1. Tittle execute() should revert, instead of returning false on failing low level call   # Vulnerability details  ## Impact When an owner want to execute something, make sure to revert the transaction when the low level call is failing, this execute() will still returning a success transaction, eventhough the actual execution is failing when doing the low level call  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/VoteProxy.sol#L33 --------------------------------------------------------------------------------------------------------------------------- 2. Tittle claimRewards() didnt follow the safe check effect pattern  ## Impact a user can claim a reward by calling the claimRewards(), however this function didnt follow the correct check effect pattern, where the zero address is set after making an external call, lets say the reward token is erc777 which will make an external during transfer, the user can reenter this function since this function didnt follow the check effect pattern and didnt have a noreentrant modifier, the user can claim token with reentrancy.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L37 --------------------------------------------------------------------------------------------------------------------------- 3. Tittle Unsafe cast from uint256 to uint192  ## Impact  the max value of uint192 is 6277101735386680763835789423207666416102355444464034512895, however when you input the _amount to 6277101735386680763835789423207666416102355444464034512896 value, since it doing an unsafe cast from uint256 to uint192, the _amount value would be 0.  ##Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L235 --------------------------------------------------------------------------------------------------------------------------- 4. Tittle this check can be bypassed  ## Impact this check is useless, since the usdm is allowed a user to flashmint the token, in the usdm contract, the usdm is allowed the user to flashmint the token instead of the usual flashloan, in flashmint you are minting a token instead of borrowing an existing token, therefore the flashmint is allowed the user to borrow up to 115792089237316195423570985008687907853269984665640517394379403123841238667621 usdm token, then deposit the pool3 token.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L100 1. unlockable state is true and totalliquidity usdm is bellow 4m 2. a user/whale is flashmint 4m usdm 3. user deposit 4m usdm token 4. user deposit pool3 token 5. withdraw the 4m usdm that was already deposited 6. pay the fee 7. now the user/whale has deposited the pool3 token eventhough the totalliqudity of usdm still below 4m ------------------------------------------------------------------------------------------------------------------------- 5. Tittle mismatch between description and actual code  ## Impact the actual value in the https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L100 is 4m usdm, but the description said that it is 40m usdm.  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L100 "}, {"title": "StakingRewards.setRewardsDuration allows setting near zero or enormous rewardsDuration, which breaks reward logic", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/223", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L178-185   # Vulnerability details  ## Impact  notifyRewardAmount will be inoperable if rewardsDuration bet set to zero. If will cease to produce meaningful results if rewardsDuration be too small or too big  ## Proof of Concept  The setter do not control the value, allowing zero/near zero/enormous duration:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L178-185  Division by the duration is used in notifyRewardAmount:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L143-156  ## Recommended Mitigation Steps  Check for min and max range in the rewardsDuration setter, as too small or too big rewardsDuration breaks the logic  "}, {"title": "Rewards get diluted because `totalAllocPoint` can only increase.", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/221", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol   # Vulnerability details  ## Impact There is no functionality for removing pools/setting pool's allocPoints. Therefore `totalAllocPoint` only increases and rewards for pool decreases.  ## Proof of Concept Scenario: 1. Owner adds new pool (first pool) for staking with points = 900 (totalAllocPoint=900). 2. 1 week passes 3. First pool staking period ends (or for other reasons that pool is not meaningfully anymore). 4. Owner adds new pool (second pool) for staking with points = 100 (totalAllocPoint=1000) 5. 1 block later Alice stake 10 tokens there (at the same time). 6. 1 week passes 7. After some time Alice claims rewards. But she is eligible only for 10% of the rewards. 90% goes to unused pool.  ## Tools Used Manual review  ## Recommended Mitigation Steps Add functionality for removing pool or functionality for setting pool's `totalAllocPoint` param.  "}, {"title": "Wrong reward token calculation in MasterChef contract", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/219", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86   # Vulnerability details  ## Impact When adding new token pool for staking in MasterChef contract ```javascript function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) ``` All other, already added, pools should be updated but currently they are not. Instead, only totalPoints is updated. Therefore, old (and not updated) pools will lose it's share during the next update. Therefore, user rewards are not computed correctly (will be always smaller).  ## Proof of Concept Scenario 1: 1. Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100)    and 1 block later Alice stakes 10 tokens in the first pool. 2. 1 week passes 3. Alice withdraws her 10 tokens and claims X amount of reward tokens.    and 1 block later Bob stakes 10 tokens in the first pool. 4. 1 week passes 5. Owner adds new pool (second pool) for staking with points = 100 (totalPoints=200)    and 1 block later Bob withdraws his 10 tokens and claims X/2 amount of reward tokens.    But he should get X amount  Scenario 2: 1. Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100). 2. 1 block later Alice, Bob and Charlie stake 10 tokens there (at the same time). 3. 1 week passes 4. Owner adds new pool (second pool) for staking with points = 400 (totalPoints=500) 5. Right after that, when Alice, Bob or Charlie wants to withdraw tokens and claim rewards they will only be able to claim 20% of what they should be eligible for, because their pool is updated with 20% (100/500) rewards instead of 100% (100/100) rewards for the past week.  ## Tools Used Manual review  ## Recommended Mitigation Steps Update all existing pools before adding new pool. Use the massUdpate() function which is already present ... but unused.  "}, {"title": "[WP-M17] `USDMPegRecovery.sol#withdraw()` withdraw may often fail", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/212", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110-L128   # Vulnerability details  Per the doc:  > USDM deposits are locked based on the KPI\u2019s from carrot.eth.  > 3Crv deposits are not locked.  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110-L128  ```solidity function withdraw(Liquidity calldata _withdrawal) external {         Liquidity memory total = totalLiquidity;         Liquidity memory user = userLiquidity[msg.sender];         if(_withdrawal.usdm > 0) {             require(unlockable, \"!unlock usdm\");             usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));             total.usdm -= _withdrawal.usdm;             user.usdm -= _withdrawal.usdm;         }          if(_withdrawal.pool3 > 0) {             pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));             total.pool3 -= _withdrawal.pool3;             user.pool3 -= _withdrawal.pool3;         }         totalLiquidity = total;         userLiquidity[msg.sender] = user;         emit Withdraw(msg.sender, _withdrawal);     } ```  However, because the `withdraw()` function takes funds from the balance of the contract, once the majority of the funds are added to the curve pool via `provide()`. The `withdraw()` may often fail due to insufficient funds in the balance.  ### PoC  1. Alice deposits `4M` USDM and `4M` pool3 tokens; 2. Guardian calls `provide()` and all the `usdm` and `pool3` to `usdm3crv`; 3. Alice calls `withdraw()`, the tx will fail, due to insufficient balance.  ### Recommendation  Consider calling `usdm3crv.remove_liquidity_one_coin()`  when the balance is insufficient for the user's withdrawal.  "}, {"title": "[WP-H29] `StakingRewards.sol` `recoverERC20()` can be used as a backdoor by the `owner` to retrieve `rewardsToken`", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/210", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L166-L176   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L166-L176  ```solidity     function recoverERC20(address tokenAddress, uint256 tokenAmount)         external         onlyOwner     {         require(             tokenAddress != address(stakingToken),             \"Cannot withdraw the staking token\"         );         IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);         emit Recovered(tokenAddress, tokenAmount);     } ```  ### Impact  Users can lose all the rewards to the malicious/compromised `owner`.  ### Recommendation  Change to:  ```solidity  function recoverERC20(     address tokenAddress,     address to,     uint256 amount ) external onlyOwner {     require(tokenAddress != address(stakingToken) && tokenAddress != address(rewardsToken), \"20\");      IERC20(tokenAddress).safeTransfer(to, amount);     emit Recovered(tokenAddress, to, amount); } ```  "}, {"title": "[WP-H28] `StakingRewards.sol#notifyRewardAmount()` Improper reward balance checks can make some users unable to withdraw their rewards", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/209", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L154-L158   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L154-L158  ```solidity     uint256 balance = rewardsToken.balanceOf(address(this));     require(         rewardRate <= balance / rewardsDuration,         \"Provided reward too high\"     ); ```  In the current implementation, the contract only checks if balanceOf `rewardsToken` is greater than or equal to the future rewards.  However, under normal circumstances, since users can not withdraw all their rewards in time, the balance in the contract contains rewards that belong to the users but have not been withdrawn yet. This means the current checks can not be sufficient enough to make sure the contract has enough amount of rewardsToken.  As a result, if the `rewardsDistribution` mistakenly `notifyRewardAmount` with a larger amount, the contract may end up in a wrong state that makes some users unable to claim their rewards.  ### PoC  Given:  - rewardsDuration = 7 days;  1. Alice stakes `1,000` stakingToken; 2. `rewardsDistribution` sends `100` rewardsToken to the contract; 3. `rewardsDistribution` calls `notifyRewardAmount()` with `amount` = `100`; 4. 7 days later, Alice calls `earned()` and it returns `100` rewardsToken, but Alice choose not to `getReward()` for now; 5. `rewardsDistribution` calls `notifyRewardAmount()` with `amount` = `100` without send any fund to contract, the tx will succees; 6. 7 days later, Alice calls `earned()` `200` rewardsToken, when Alice tries to call `getReward()`, the transaction will fail due to insufficient balance of rewardsToken.  Expected Results:  The tx in step 5 should revert.  ### Recommendation  Consider changing the function `notifyRewardAmount` to `addRward` and use `transferFrom` to transfer rewardsToken into the contract:  ```solidity function addRward(uint256 reward)     external     updateReward(address(0)) {     require(         msg.sender == rewardsDistribution,         \"Caller is not RewardsDistribution contract\"     );      if (block.timestamp >= periodFinish) {         rewardRate = reward / rewardsDuration;     } else {         uint256 remaining = periodFinish - block.timestamp;         uint256 leftover = remaining * rewardRate;         rewardRate = (reward + leftover) / rewardsDuration;     }      rewardsToken.safeTransferFrom(msg.sender, address(this), reward);      lastUpdateTime = block.timestamp;     periodFinish = block.timestamp + rewardsDuration;     emit RewardAdded(reward); } ```  "}, {"title": "[WP-H13] `MasterChef.sol` Users won't be able to receive the `concur` rewards", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/200", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L135-L154   # Vulnerability details  According to:  -   README https://github.com/code-423n4/2022-02-concur#-masterchef -   Implementation of `deposit()`: [/contracts/MasterChef.sol#L157-L180](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L157-L180)  MasterChef is only recording the deposited amount in the states, it's not actually holding the `depositToken`.  `depositToken` won't be transferred from `_msgSender()` to the MasterChef contract.  Therefore, in `updatePool()` L140 `lpSupply = pool.depositToken.balanceOf(address(this))` will always be `0`. And the `updatePool()` will be returned at L147.  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L135-L154  ```solidity function updatePool(uint _pid) public {     PoolInfo storage pool = poolInfo[_pid];     if (block.number <= pool.lastRewardBlock) {         return;     }     uint lpSupply = pool.depositToken.balanceOf(address(this));     if (lpSupply == 0 || pool.allocPoint == 0) {         pool.lastRewardBlock = block.number;         return;     }     if(block.number >= endBlock) {         pool.lastRewardBlock = block.number;         return;     }              uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);     uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);     pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));     pool.lastRewardBlock = block.number; } ```   ### Impact  - The MasterChef contract fail to implement the most essential function; - Users won't be able to receive any `Concur` rewards from MasterChef;  ### Recommendation  Consider creating a receipt token to represent the invested token and use the receipt tokens in MasterChef.  See: https://github.com/convex-eth/platform/blob/883ffd4ebcaee12e64d18f75bdfe404bcd900616/contracts/contracts/Booster.sol#L272-L277  "}, {"title": "[WP-H8] `ConvexStakingWrapper.sol#_calcRewardIntegral` Wrong implementation can disrupt rewards calculation and distribution", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/199", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L175-L204   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L175-L204  ```solidity     uint256 bal = IERC20(reward.token).balanceOf(address(this));     uint256 d_reward = bal - reward.remaining;     // send 20 % of cvx / crv reward to treasury     if (reward.token == cvx || reward.token == crv) {         IERC20(reward.token).transfer(treasury, d_reward / 5);         d_reward = (d_reward * 4) / 5;     }     IERC20(reward.token).transfer(address(claimContract), d_reward);      if (_supply > 0 && d_reward > 0) {         reward.integral =             reward.integral +             uint128((d_reward * 1e20) / _supply);     }      //update user integrals     uint256 userI = userReward[_pid][_index][_account].integral;     if (userI < reward.integral) {         userReward[_pid][_index][_account].integral = reward.integral;         claimContract.pushReward(             _account,             reward.token,             (_balance * (reward.integral - userI)) / 1e20         );     }      //update remaining reward here since balance could have changed if claiming     if (bal != reward.remaining) {         reward.remaining = uint128(bal);     } ```  The problems in the current implementation:  - `reward.remaining` is not a global state; the `reward.remaining` of other `reward`s with the same rewardToken are not updated; - `bal` should be refreshed before `reward.remaining = uint128(bal);`; - L175 should not use `balanceOf` but take the diff before and after `getReward()`.  ### PoC  - convexPool[1] is incentivized with CRV as the reward token, `1000 lpToken` can get `10 CRV` per day; - convexPool[2] is incentivized with CRV as the reward token, `1000 lpToken` can get `20 CRV` per day.  1. Alice deposits `1,000` lpToken to `_pid` = `1` 2. 1 day later, Alice deposits `500` lpToken to `_pid` = `1`   - convexPool `getReward()` sends `10 CRV` as reward to contract - `d_reward` = 10, `2 CRV` sends to `treasury`, `8 CRV` send to `claimContract` - `rewards[1][0].remaining` = 10  3. 0.5 day later, Alice deposits `500` lpToken to `_pid` = `1`, and the tx will fail:  - convexPool `getReward()` sends `7.5 CRV` as reward to contract - `reward.remaining` = 10 - `bal` = 7.5 - `bal - reward.remaining` will fail due to underflow  4. 0.5 day later, Alice deposits `500` lpToken to `_pid` = `1`, most of the reward tokens will be left in the contract:  - convexPool `getReward()` sends `15 CRV` as reward to the contract; - `d_reward = bal - reward.remaining` = 5 - `1 CRV` got sent to `treasury`, `4 CRV` sent to `claimContract`, `10 CRV` left in the contract; - `rewards[1][0].remaining` = 15  Expected Results:  All the `15 CRV` get distributed: `3 CRV` to the `treasury`, and `12 CRV` to `claimContract`.  Actual Results:  Only `5 CRV` got distributed. The other `10 CRV` got left in the contract which can be frozen in the contract, see below for the details:  5. Bob deposits `1,000` lpToken to `_pid` = `2`  - convexPool `getReward()` sends `0 CRV` as reward to the contract - `d_reward = bal - reward.remaining` = 10 - `2 CRV` sent to `treasury`, `8 CRV` sent to `claimContract` without calling `pushReward()`, so the `8 CRV` are now frozen in `claimContract`; - `rewards[2][0].remaining` = 10  ### Impact  - The two most important methods: `deposit()` and `withdraw()` will frequently fail as the tx will revert at `_calcRewardIntegral()`; - Rewards distributed to users can often be fewer than expected; - If there are different pools that use the same token as rewards, part of the rewards can be frozen at `claimContract` and no one can claim them.  ### Recommendation  Consider comparing the `balanceOf` reward token before and after `getReward()` to get the actual rewarded amount, and `reward.remaining` should be removed.  "}, {"title": "[WP-H1] Rewards distribution can be disrupted by a early user", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/193", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/ConvexStakingWrapper.sol#L184-L188   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/ConvexStakingWrapper.sol#L184-L188  ```solidity if (_supply > 0 && d_reward > 0) {     reward.integral =         reward.integral +         uint128((d_reward * 1e20) / _supply); } ```  `reward.integral` is `uint128`, if an early user deposits with just `1` Wei of `lpToken`, and make `_supply == 1`, and then transferring `5e18` of `reward_token` to the contract.  As a result, `reward.integral` can exceed `type(uint128).max` and overflow, causing the rewards distribution to be disrupted.  ### Recommendation  Consider `wrap` a certain amount of initial totalSupply at deployment, e.g. `1e8`, and never burn it. And consider using uint256 instead of uint128 for `reward.integral`. Also, consdier lower `1e20` down to `1e12`.  "}, {"title": "[WP-M0] `USDMPegRecovery.sol#provide()` Improper design/implementation make it often unable to add liquidity to the `usdm3crv` pool", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/191", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/USDMPegRecovery.sol#L73-L82   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/USDMPegRecovery.sol#L73-L82  ```solidity function provide(uint256 _minimumLP) external onlyGuardian {     require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");     // truncate amounts under step     uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;     // match usdm : pool3 = 1 : 1     uint256[2] memory amounts = [addingLiquidity, addingLiquidity];     usdm.approve(address(usdm3crv), addingLiquidity);     pool3.approve(address(usdm3crv), addingLiquidity);     usdm3crv.add_liquidity(amounts, _minimumLP); } ```  In the current implementation of `USDMPegRecovery.sol#provide()`, `addingLiquidity` is calculated solely based on `usdm` balance (truncate at a step of 250k), and it always uses the same amount of 3pool tokens to add_liquidity with.  Based on other functions of the contract, the balance of `usdm` can usually be more than the `pool3` balance, in that case, `usdm3crv.add_liquidity()` will fail.  ### Impact  When the balance of `pool3` is less than `usdm` (which is can be a common scenario), funds cannot be added to the curve pool.  For example:  When the contract got 5M of USDM and 4.2M of `pool3` tokens, it won't be possible to call `provide()` and add liquidity to the `usdm3crv` pool, as there are not enough pool3 tokens to match the 5M of USDM yet.  We expect it to add liquidity with 4M of USDM and 4M of pool3 tokens in that case.  ### Recommendation  Change to:  ```solidity function provide(uint256 _minimumLP) external onlyGuardian {     require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");     uint256 tokenBalance = Math.min(usdm.balanceOf(address(this), pool3.balanceOf(address(this));     // truncate amounts under step     uint256 addingLiquidity = (tokenBalance / step) * step;     // match usdm : pool3 = 1 : 1     uint256[2] memory amounts = [addingLiquidity, addingLiquidity];     usdm.approve(address(usdm3crv), addingLiquidity);     pool3.approve(address(usdm3crv), addingLiquidity);     usdm3crv.add_liquidity(amounts, _minimumLP); } ```  "}, {"title": "USDM locked unless guardian remove liquidity", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/187", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90   # Vulnerability details  ## Impact In README.me: > USDM deposits are locked based on the KPI\u2019s from carrot.eth  However, USDM deposits are also locked until guardian remove liquidity because there are no mechanism to remove deposited USDM in `withdraw`  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90  "}, {"title": "`ConvexStakingWrapper._calcRewardIntegral()` Can Be Manipulated To Steal Tokens From Other Pools", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/146", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L216-L259   # Vulnerability details  ## Impact  The `ConvexStakingWrapper.sol` implementation makes several modifications to the original design. One of the key changes is the ability to add multiple pools into the wrapper contract, where each pool is represented by a unique `_pid`. By doing this, we are able to aggregate pools and their LP tokens to simplify the token distribution process.   However, the interdependence between pools introduces new problems. Because the original implementation uses the contract's reward token balance to track newly claimed tokens, it is possible for a malicious user to abuse the unguarded `getReward` function to maximise the profit they are able to generate. By calling `getReward` on multiple pools with the same reward token (i.e. `cvx`), users are able to siphon rewards from other pools. This inevitably leads to certain loss of rewards for users who have deposited LP tokens into these victim pools. As `crv` and `cvx` are reward tokens by default, it is very likely that someone will want to exploit this issue.  ## Proof of Concept  Let's consider the following scenario: - There are two convex pools with `_pid` 0 and 1. - Both pools currently only distribute `cvx` tokens. - Alice deposits LP tokens into the pool with `_pid` 0. - Both pools earn 100 `cvx` tokens which are to be distributed to the holders of the two pools. - While Alice is a sole staker of the pool with `_pid` 0, the pool with `_pid` 1 has several stakers. -  Alice decides she wants to maximise her potential rewards, so she directly calls the unguarded `IRewardStaking(convexPool[_pid]).getReward` function on both pools, resulting in 200 `cvx` tokens being sent to the contract. - She then decides to deposit the 0 amount to execute the `_calcRewardIntegral` function on the pool with `_pid` 0. However, this function will calculate `d_reward` as `bal - reward.remaining` which is effectively the change in contract balance. As we have directly claimed `cvx` tokens over the two pools, this `d_reward` will be equal to 200. - Alice is then entitled to the entire 200 tokens as she is the sole staker of her pool. So instead of receiving 100 tokens, she is able to siphon rewards from other pools.  Altogether, this will lead to the loss of rewards for other stakers as they are unable to then claim their rewards.  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L216-L259 ``` function _calcRewardIntegral(     uint256 _pid,     uint256 _index,     address _account,     uint256 _balance,     uint256 _supply ) internal {     RewardType memory reward = rewards[_pid][_index];      //get difference in balance and remaining rewards     //getReward is unguarded so we use remaining to keep track of how much was actually claimed     uint256 bal = IERC20(reward.token).balanceOf(address(this));     uint256 d_reward = bal - reward.remaining;     // send 20 % of cvx / crv reward to treasury     if (reward.token == cvx || reward.token == crv) {         IERC20(reward.token).transfer(treasury, d_reward / 5);         d_reward = (d_reward * 4) / 5;     }     IERC20(reward.token).transfer(address(claimContract), d_reward);      if (_supply > 0 && d_reward > 0) {         reward.integral =             reward.integral +             uint128((d_reward * 1e20) / _supply);     }      //update user integrals     uint256 userI = userReward[_pid][_index][_account].integral;     if (userI < reward.integral) {         userReward[_pid][_index][_account].integral = reward.integral;         claimContract.pushReward(             _account,             reward.token,             (_balance * (reward.integral - userI)) / 1e20         );     }      //update remaining reward here since balance could have changed if claiming     if (bal != reward.remaining) {         reward.remaining = uint128(bal);     }      rewards[_pid][_index] = reward; } ```  ## Tools Used  Manual code review. Confirmation from Taek.  ## Recommended Mitigation Steps  Consider redesigning this mechanism such that all pools have their `getReward` function called in `_checkpoint`. The `_calcRewardIntegral` function can then ensure that each pool is allocated only a fraction of the total rewards instead of the change in contract balance. Other implementations might be more ideal, so it is important that careful consideration is taken when making these changes.  "}, {"title": "`ConvexStakingWrapper.exitShelter()` Will Lock LP Tokens, Preventing Users From Withdrawing", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/144", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L121-L130 https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L309-L331   # Vulnerability details  ## Impact  The shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. Conversely, the `exitShelter` function will deactivate the shelter and transfer all LP tokens back to the `ConvexStakingWrapper.sol` contract.  Unfortunately, LP tokens aren't restaked in the pool, causing LP tokens to be stuck within the contract. Users will be unable to withdraw their LP tokens as the `withdraw` function attempts to `withdrawAndUnwrap` LP tokens from the staking pool. As a result, this function will always revert due to insufficient staked balance. If other users decide to deposit their LP tokens, then these tokens can be swiped by users who have had their LP tokens locked in the contract.  This guarantees poor UX for the protocol and will most definitely lead to LP token loss.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L121-L130 ``` function exitShelter(uint256[] calldata _pids) external onlyOwner {     for(uint256 i = 0; i<_pids.length; i++){         IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);         IERC20 lpToken = IERC20(             pool.poolInfo(_pids[i]).lptoken         );         amountInShelter[lpToken] = 0;         shelter.deactivate(lpToken);     } } ```  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L309-L331 ``` function withdraw(uint256 _pid, uint256 _amount)     external     nonReentrant     whenNotInShelter(_pid) {     WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];     require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), \"wait\");     require(request.amount >= _amount, \"too much\");     _checkpoint(_pid, msg.sender);     deposits[_pid][msg.sender].amount -= uint192(_amount);     if (_amount > 0) {         IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);         IERC20 lpToken = IERC20(             IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken         );         lpToken.safeTransfer(msg.sender, _amount);         uint256 pid = masterChef.pid(address(lpToken));         masterChef.withdraw(msg.sender, pid, _amount);     }     delete withdrawRequest[_pid][msg.sender];     //events     emit Withdrawn(msg.sender, _amount); } ```  ## Tools Used  Manual code review. Confirmation from Taek.  ## Recommended Mitigation Steps  Consider re-depositing LP tokens upon calling `exitShelter`. This should ensure the same tokens can be reclaimed by users wishing to exit the `ConvexStakingWrapper.sol` contract.  "}, {"title": "Masterchef: Improper handling of deposit fee", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/138", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L170-L172   # Vulnerability details  ## Impact  If a pool\u2019s deposit fee is non-zero, it is subtracted from the amount to be credited to the user.  ```jsx if (pool.depositFeeBP > 0) {   uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);   user.amount = SafeCast.toUint128(user.amount + _amount - depositFee); } ```  However, the deposit fee is not credited to anyone, leading to permanent lockups of deposit fees in the relevant depositor contracts (StakingRewards and ConvexStakingWrapper for now).  ## Proof of Concept  ### Example 1: ConvexStakingWrapper  Assume the following  - The [curve cDai / cUSDC / cUSDT LP token](https://etherscan.io/address/0x9fC689CCaDa600B6DF723D9E47D84d76664a1F23) corresponds to `pid = 1` in the convex booster contract. - Pool is added in Masterchef with `depositFeeBP = 100 (10%)`. 1. Alice deposits 1000 LP tokens via the ConvexStakingWrapper contract. A deposit fee of 100 LP tokens is charged. Note that the `deposits` mapping of the ConvexStakingWrapper contract credits 1000 LP tokens to her. 2. However, Alice will only be able to withdraw 900 LP tokens. The 100 LP tokens is not credited to any party, and is therefore locked up permanently (essentially becomes protocol-owned liquidity). While she is able to do `requestWithdraw()` for 1000 LP tokens, attempts to execute `withdraw()` with amount = 1000 will revert because she is only credited 900 LP tokens in the Masterchef contract.  ### Example 2: StakingRewards  - CRV pool is added in Masterchef with `depositFeeBP = 100 (10%)`. 1. Alice deposits 1000 CRV into the StakingRewards contract. A deposit fee of 100 CRV is charged. 2. Alice is only able to withdraw 900 CRV tokens, while the 100 CRV is not credited to any party, and is therefore locked up permanently.  These examples are non-exhaustive as more depositors can be added / removed from the Masterchef contract.  ## Recommended Mitigation Steps  I recommend shifting the deposit fee logic out of the masterchef contract into the depositor contracts themselves, as additional logic would have to be added in the masterchef to update the fee recipient\u2019s state (rewardDebt, send pending concur rewards, update amount), which further complicates matters. As the fee recipient is likely to be the treasury, it is also not desirable for it to accrue concur rewards.  ```jsx if (pool.depositFeeBP > 0) {   uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);   user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);   UserInfo storage feeRecipient = userInfo[_pid][feeRecipient];   // TODO: update and send feeRecipient pending concur rewards   feeRecipient.amount = SafeCast.toUint128(feeRecipient.amount + depositFee);   // TODO: update fee recipient's rewardDebt } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/127", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L256   # Vulnerability details  ``` ConcurRewardPool.constructor(address)._notifier (contracts/ConcurRewardPool.sol#15) lacks a zero-check on :   - rewardNotifier = _notifier (contracts/ConcurRewardPool.sol#16) ConvexStakingWrapper.constructor(address,MasterChef)._treasury (contracts/ConvexStakingWrapper.sol#69) lacks a zero-check on :   - treasury = _treasury (contracts/ConvexStakingWrapper.sol#70) ConvexStakingWrapper.changeTreasury(address)._treasury (contracts/ConvexStakingWrapper.sol#82) lacks a zero-check on :   - treasury = _treasury (contracts/ConvexStakingWrapper.sol#83) StakingRewards.constructor(address,address,address,MasterChef)._rewardsDistribution (contracts/StakingRewards.sol#38) lacks a zero-check on :   - rewardsDistribution = _rewardsDistribution (contracts/StakingRewards.sol#45) StakingRewards.setRewardsDistribution(address)._rewardsDistribution (contracts/StakingRewards.sol#187) lacks a zero-check on :   - rewardsDistribution = _rewardsDistribution (contracts/StakingRewards.sol#195) USDMPegRecovery.constructor(uint256,address)._kpiOracle (contracts/USDMPegRecovery.sol#50) lacks a zero-check on :   - kpiOracle = _kpiOracle (contracts/USDMPegRecovery.sol#57) VoteProxy.execute(address,uint256,bytes)._to (contracts/VoteProxy.sol#29) lacks a zero-check on :   - (success,result) = _to.call{value: _value}(_data) (contracts/VoteProxy.sol#33) ```  "}, {"title": "If The Staking Token Exists In Both `StakingRewards.sol` And `ConvexStakingWrapper.sol` Then It Will Be Possible To Continue Claiming Concur Rewards After The Shelter Has Been Activated", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/StakingRewards.sol   # Vulnerability details  ## Impact  Staking tokens are used to deposit into the `StakingRewards.sol` and `ConvexStakingWrapper.sol` contracts. Once deposited, the user is entitled to Concur rewards in proportion to their staked balance and the underlying pool's `allocPoint` in the `MasterChef.sol` contract.  The `Shelter.sol` mechanism allows the owner of the `ConvexStakingWrapper.sol` to react to emergency events and protect depositor's assets. The staking tokens can be withdrawn after the grace period has passed. However, these staking tokens can be deposited into the `StakingRewards.sol` contract to continue receiving Concur rewards not only for `StakingRewards.sol` but also for their `ConvexStakingWrapper.sol` deposited balance which has not been wiped. As a result, users are able to effectively claim double the amount of Concur rewards they should be receiving.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/StakingRewards.sol  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Ensure that staking tokens cannot be deposited in both the `StakingRewards.sol` and `ConvexStakingWrapper.sol` contracts. If this is intended behaviour, it may be worthwhile to ensure that the sheltered users have their deposited balance wiped from the `MasterChef.sol` contract upon being sheltered.  "}, {"title": "Users Will Lose Concur Rewards If The Shelter Mechanism Is Enacted On A Pool", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/116", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol   # Vulnerability details  ## Impact  The shelter mechanism aims to protect the protocol's users by draining funds into a separate contract in the event of an emergency. However, while users are able to reclaim their funds through the `Shelter.sol` contract, they will still have a deposited balance from the perspective of `ConvexStakingWrapper.sol`.  However, if the shelter mechanism is enacted before users are able to claim their Concur rewards, any accrued tokens will be lost and the `MasterChef.sol` contract will continue to allocate tokens to the sheltered pool which will be forever locked within this contract.  There is currently no way to remove sheltered pools from the `MasterChef.sol` contract, hence any balance lost in the contract cannot be recovered due to a lack of a sweep mechanism which can be called by the contract owner.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing sheltered pools from the `MasterChef.sol` Concur token distribution. It is important to ensure `massUpdatePools` is called before making any changes to the list of pools. Additionally, removing pools from this list may also create issues with how `_pid` is produced on each new pool. Therefore, it may be worthwhile to rethink this mechanism such that `_pid` tracks some counter variable and not `poolInfo.length - 1`.  "}, {"title": "Users Will Lose Rewards If The Shelter Mechanism Is Enacted Before A Recent Checkpoint", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/115", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol   # Vulnerability details  ## Impact  The shelter mechanism aims to protect the protocol's users by draining funds into a separate contract in the event of an emergency. However, while users are able to reclaim their funds through the `Shelter.sol` contract, they will still have a deposited balance from the perspective of `ConvexStakingWrapper.sol`.  Because users will only receive their rewards upon depositing/withdrawing their funds due to how the checkpointing mechanism works, it is likely that by draining funds to the `Shelter.sol` contract, users will lose out on any rewards they had accrued up and until that point. These rewards are unrecoverable and can potentially be locked within the contract if the reward token is unique and only belongs to the sheltered `_pid`.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider allowing users to call a public facing `_checkpoint` function once their funds have been drained to the `Shelter.sol` contract. This should ensure they receive their fair share of rewards. Careful consideration needs to be made when designing this mechanism, as by giving users full control of the `_checkpoint` function may allow them to continue receiving rewards after they have withdrawn their LP tokens.  "}, {"title": "`ConvexStakingWrapper.enterShelter()` May Erroneously Overwrite `amountInShelter` Leading To Locked Tokens", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/109", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L107-L119 https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L132-L135   # Vulnerability details  ## Impact  The shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. If this function is called again on the same LP token, the `amountInShelter` value is overwritten, potentially by the zero amount. As a result  its possible that the shelter is put in a state where no users can withdraw from it or only a select few users with a finite number of shares are able to. Once the shelter has passed its grace period, these tokens may forever be locked in the shelter contract.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L107-L119 ``` function enterShelter(uint256[] calldata _pids) external onlyOwner {     for(uint256 i = 0; i<_pids.length; i++){         IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);         uint256 amount = pool.balanceOf(address(this));         pool.withdrawAndUnwrap(amount, false);         IERC20 lpToken = IERC20(             pool.poolInfo(_pids[i]).lptoken         );         amountInShelter[lpToken] = amount;         lpToken.safeTransfer(address(shelter), amount);         shelter.activate(lpToken);     } } ```  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L132-L135 ``` function totalShare(IERC20 _token) external view override returns(uint256) {     // this will be zero if shelter is not activated     return amountInShelter[_token]; } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding to the `amountInShelter[lpToken]` mapping instead of overwriting it altogether. This will allow `enterShelter` to be called multiple times with no loss of funds for the protocol's users.  "}, {"title": "Shelter `claimed` mapping is set with `_to` address and not `msg.sender`", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/103", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code   https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L55   # Vulnerability details  # Impact  Any user can withdraw all the funds from the shelter. This is done by calling withdraw repeatedly until all funds are drained. You only need to have a small share.  Even if the `claimed` mapping was checked, there would still be a vulnerability. This is because the `claimed` mapping is updated with the `_to` address, not the `msg.sender` address.  Remediation is to change the `_to` to `msg.sender`. https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L55   "}, {"title": "`USDMPegRecovery.provide()` Will Fail If There Is An Excess Of `usdm` Tokens", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/94", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L73-L82   # Vulnerability details  ## Impact  The `provide` function does not take a `_steps` argument and will instead calculate `addingLiquidity` by truncating amounts under `step`. As a result, if there is an excess of `usdm` such that the truncated amount exceeds the contract's `pool3` truncated balance, then the function will revert due to insufficient `pool3` collateral.  This will prevent guardians from effectively providing liquidity whenever tokens are available. Consider the following example: - The contract has `500000e18` `usdm` tokens and `250000e18` `pool3` tokens. - `addingLiquidity` will be calculated as `500000e18 / 250000e18 * 250000e18`. - The function will attempt to add `500000e18` `usdm` and `pool3` tokens in which there are insufficient `pool3` tokens in the contract. As a result, it will revert even though there is an abundance of tokens that satisfy the `step` amount.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L73-L82 ``` function provide(uint256 _minimumLP) external onlyGuardian {     require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");     // truncate amounts under step     uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;     // match usdm : pool3 = 1 : 1     uint256[2] memory amounts = [addingLiquidity, addingLiquidity];     usdm.approve(address(usdm3crv), addingLiquidity);     pool3.approve(address(usdm3crv), addingLiquidity);     usdm3crv.add_liquidity(amounts, _minimumLP); } ```  ## Tools Used  Manual code review. Discussions with Taek.  ## Recommended Mitigation Steps  Consider modifying the `provide` function such that a `_steps` argument can be supplied. This will allow guardians to maximise the amount of liquidity provided to the Curve pool.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/80", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Non critical  ## Lack of events  The method [ConcurRewardPool.pushReward](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L23) should emit an event in order to be detectable by the `_recipient`.  ## Non exploitable reentrancy  The method [ConcurRewardPool.claimRewards](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L34-L37) allow the reentrancy, it seems that it's not vulnerable but it should be protected in order to be resilient.  # Low  ## Contract management risks  The following contracts are `Ownable` and `Pausable`, so the owner could resign while the contract is paused, causing a Denial of Service. Owner resignation while paused should be avoided: - [ConvexStakingWrapper](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L14) - [StakingRewards](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L12)  ## contracts\\ConvexStakingWrapper.sol  1. It was found some `transfer`, `approve` or `transferFrom` without checking the boolean result, ERC20 standard specify that the token can return false if this call was not made, so it's mandatory to check the result of these methods.  As following you can see the affected locations: - [ConvexStakingWrapper.sol#L179](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L179) - [ConvexStakingWrapper.sol#L182](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L182)  2. There are a lack of checks in the method [requestWithdraw](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L287) that allow to create a request for `_amount=0` it should be denied in order to avoid possible errors. "}, {"title": "USDMPegRecovery Risk of fund locked, due to discrepancy between curveLP token value against internal contract math", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/70", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L73 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L84   # Vulnerability details  ## Impact In `USDMPegRecovery` `deposit` and `withdraw` allow for direct deposits of a specific token (3crv or usdm)  The balances are directly changed and tracked in storage.  `provide` seems to be using the real balances (not the ones store) to provide liquidity. Because of how curve works, you'll be able (first deposit) to provide exactly matching liquidity.  But after (even just 1 or) multiple swaps, the pool will be slightly imbalanced, adding or removing liquidity at that point will drastically change the balances in the contract from the ones tracked in storage.  Eventually users won't be able to withdraw the exact amounts they deposited.  This will culminate with real balances not matching user deposits, sometimes to user advantage and other times to user disadvantage, ultimately to the protocol dismay.    ## Proof of Concept Deposit equal usdm and 3crv LP Do one trade on CRV Withdraw the LP  The real balances are not matching the balances in storage  User tries to withdraw all their balances, inevitable revert  ## Recommended Mitigation Steps Either find a way to price the user contribution based on the LP tokens (use virtual_price) Or simply have people deposit the LP token directly (avoiding the IL math which is a massive headache)  "}, {"title": "StakingRewards.recoverERC20 allows owner to rug the `rewardsToken`", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L166   # Vulnerability details  ## Impact `StakingRewards.recoverERC20` rightfully checks against the `stakingToken` being sweeped away. However there's no check against the `rewardsToken` which over time will sit in this contract.  This is the case of an admin privilege, which allows the owner to sweep the rewards tokens, perhaps as a way to rug depositors  ## Proof of Concept calling `StakingRewards.recoverERC20(rewardsToken, rewardsToken.balanceOf(this))` enables the `owner` to sweep the token  ## Recommended Mitigation Steps Add an additional check ```         require(             tokenAddress != address(rewardsToken),             \"Cannot withdraw the rewards token\"         ); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Report  * [cache values from external function calls](#cache-values-from-external-function-calls) * [remove unnecessary `safeApprove()`](#remove-unnecessary-safeapprove) * [use constant state variables wherever you can](#use-constant-state-variables-wherever-you-can) * [use immutable state variables wherever you can](#use-immutable-state-variables-wherever-you-can)  ## cache values from external function calls  Instead of calling the same function twice, cache the return value and use that.  Example:   - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L131  Replace the call with `extraToken` which was cached here: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L123  ## remove unnecessary `safeApprove()`  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L242-L244  The second `safeApprove()` call can be removed. After the `deposit()` the `convexBooster`'s allowance should be `0` already.  ## use constant state variables wherever you can  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L56-L57 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L50  ## use immutable state variables wherever you can  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L19-L20 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L22-L24"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Report    * [Non-Critical](#non-critical)     * [emit events for address or important state changes](#emit-events-for-address-or-important-state-changes)     * [don't convert to a smaller bit uint without verifying its value](#dont-convert-to-a-smaller-bit-uint-without-verifying-its-value)   * [Low](#low)     * [use SafeERC20 or check return value of ERC20 functions](#use-safeerc20-or-check-return-value-of-erc20-functions)     * [Shelter donations result in wrong internal balance if fee-on-transfer token is used](#shelter-donations-result-in-wrong-internal-balance-if-fee-on-transfer-token-is-used)     * [Shelter can delay the user's ability to withdraw their funds indefinitely](#shelter-can-delay-the-users-ability-to-withdraw-their-funds-indefinitely)      ## Non-Critical  ### emit events for address or important state changes  Stuff like a guardian being added to the contract or the treasury address being changed. All of that should be accompanied by an event.  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L60-L66 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L83  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L87 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L70  ### don't convert to a smaller bit uint without verifying its value  When converting to a smaller bit uint it might result in a smaller number if the value is higher than the maximum value of that uint type. Before converting it check whether the passed value is small enough.  ```sol require(x <= type(uint192).max); uint192 y = uint192(x); ```  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L235  It shouldn't really be an issue here tho and since I don't expect anybody to have more than `2 ** 196 - 1` tokens to abuse this.  ## Low  ### use SafeERC20 or check return value of ERC20 functions  Some tokens don't revert if a transfer fails. Instead they just return `false`. Since the `ConvexStakingWrapper` contract [potentially works with arbitrary ERC20 tokens](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L129-L136) it's recommended to use SafeERC20 when working with it. Or at least check the return values:  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L179 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L182   ### Shelter donations result in wrong internal balance if fee-on-transfer token is used  In case of a fee-on-transfer ERC20 token the `savedTokens` balance will not represent the actual balance of the contract:  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L34-L35  You can either disable the use of fee-on-transfer tokens for donations or use the actual balance:  ```sol // disable uint oldBalance = _token.balanceOf(address(this)); _token.safeTransferFrom(msg.sender, address(this), _amount); uint newBalance = _token.balanceOf(address(this)); require(_amount == (newBalance - oldBalance)); savedTokens[_token] += _amount; ```  ```sol // use actual balance _token.safeTransferFrom(msg.sender, address(this), _amount); savedTokens[_token] = _token.balanceOf(address(this)); ```  ### Shelter can delay the user's ability to withdraw their funds indefinitely  By repedeatly calling the `activate()` function for a specific token they can extend the timestamp at which withdrawal by users is enabled.  - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L39 - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L53  With each call `activated[_token]` is reset to `block.timestamp`. Thus the require statement in `withdraw()` will fail for another week. There's nothing stopping the client from calling the function multiple times to keep delaying the withdrawal.  Fix it by not allowing already activated tokens to be reactivated. But with the current implementation of the contract, the client could deactivate and reactivate it.  ```sol function activate(IERC20 _token) external override onlyClient {     require(!activated[_token]);     activated[_token] = block.timestamp;     savedTokens[_token] = _token.balanceOf(address(this));     emit ShelterActivated(_token); } ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/65", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description In the codebase for the protocol **concur**, There was many places where code do suffer from non-critical findings. Following security best practices can help in mitigating these issues.  # Impact code quality.  ## Proof of Concept  ### Unchecked ERC20 operations https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L179 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L182 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L79 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L80  ### floating pragma compiler version on contracts https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConcurRewardPool.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/EasySign.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L4 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/VoteProxy.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/interfaces/Iauction.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/interfaces/IShelterClient.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/interfaces/IShelter.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/interfaces/IConcurRewardClaim.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/external/ConvexInterfaces.sol#L3 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/external/CurveInterfaces.sol#L3  ### Unused event or missed emit https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L19  ### Hardcoded addresses for external protocols https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L29 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L31 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L33 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L53-L55 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/library/CvxMining.sol#L8  ### Public visibility functions https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L93 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L127  ### Missing parameter validation https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L82 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L86  ## Tools Used c4udit and manual review.  ## Recommended Mitigation Steps - check for ERC20 operation functions return value or wrap it inside require(). - restrict pragma for compiler version unless it's a library. - each declared event should have a corresponding emit statement or remove it from the codebase.  - consider passing value of external protocol addresses instead for hardcoding them since blockchains differ.  - set functions visibility to external if not used inside the same contract file. - missing input validations can lead to contract redeployment or wasted gas.   "}, {"title": "uint256 i = 0 in for loop. uint256 is default 0.", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  kenta   # Vulnerability details  ## Impact The default value of uint256 is 0 and we do not initialize it and save a little bit of gas.   ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L121  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L219  ## Tools Used  ## Recommended Mitigation Steps for (unit256 i; i < length; i++) {}  "}, {"title": "Gas Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  robee   # Vulnerability details  Title: Unnecessary equals boolean Severity: GAS   Boolean variables can be checked within conditionals directly without the use of equality operators to true/false.          VoteProxy.sol, 21: if (auctioneer.isWinningSignature(_hash, _signature) == true) {    Title: State variables that could be set immutable Severity: GAS  In the following files there are state variables that could be set immutable to save gas.           startBlock in MasterChef.sol         client in Shelter.sol         masterChef in ConvexStakingWrapper.sol         endBlock in MasterChef.sol         rewardNotifier in ConcurRewardPool.sol         concur in MasterChef.sol    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           ConcurRewardPool.sol, _tokens, 35    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           just change to unchecked: MasterChef.sol, _pid, 129         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 219         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 121         change to prefix increment and unchecked: ConcurRewardPool.sol, i, 35    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          ConcurRewardPool.sol, 35         ConvexStakingWrapper.sol, 219         MasterChef.sol, 129         ConvexStakingWrapper.sol, 121    Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          EasySign.sol, tryRecover         ConvexStakingWrapper.sol, _calcRewardIntegral         ConvexStakingWrapper.sol, _checkpoint         ConvexStakingWrapper.sol, _getDepositedBalance         ConvexStakingWrapper.sol, _getTotalSupply         EasySign.sol, recover    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           MasterChef.sol, massUpdatePools         MasterChef.sol, add         ConvexStakingWrapper.sol, addRewards    Title: Unnecessary default assignment Severity: GAS   Unnecessary default assignments, you can just declare and it will save gas and have the same meaning.               StakingRewards.sol (L#22) : uint256 public rewardRate = 0;         ConvexStakingWrapper.sol (L#36) : uint256 public constant CRV_INDEX = 0;         MasterChef.sol (L#51) : uint public totalAllocPoint = 0;         StakingRewards.sol (L#21) : uint256 public periodFinish = 0;    Title: Rearrange state variables Severity: GAS  You can change the order of the storage variables to decrease memory uses.  In USDMPegRecovery.sol,rearranging the storage fields can optimize to: 7 slots from: 8 slots. The new order of types (you choose the actual variables):         1. IERC20         2. IERC20         3. ICurveMetaPool         4. uint256         5. uint256         6. Liquidity         7. address         8. bool     Title: Short the following require messages Severity: GAS  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: StakingRewards.sol, In line 170, Require message length to shorten: 33, The message: Cannot withdraw the staking token         Solidity file: MasterChef.sol, In line 210, Require message length to shorten: 35, The message: safeConcurTransfer: transfer failed    Title: Unused imports Severity: GAS   In the following files there are contract imports that aren't used Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore)          ConvexStakingWrapper.sol, line 9, import \"./external/ConvexInterfaces.sol\";         USDMPegRecovery.sol, line 7, import { ICurveMetaPool } from \"./external/CurveInterfaces.sol\";    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           MasterChef.sol, 169: change '_amount > 0' to '_amount != 0'         ConvexStakingWrapper.sol, 262: change '_amount > 0' to '_amount != 0'         MasterChef.sol, 194: change '_amount > 0' to '_amount != 0'         USDMPegRecovery.sol, 74: change 'balance > 0' to 'balance != 0'         ConvexStakingWrapper.sol, 236: change '_amount > 0' to '_amount != 0'         StakingRewards.sol, 94: change 'amount > 0' to 'amount != 0'         StakingRewards.sol, 108: change 'amount > 0' to 'amount != 0'         ConvexStakingWrapper.sol, 184: change '_supply > 0' to '_supply != 0'    Title: Use unchecked to save gas for certain additive calculations that cannot overflow Severity: GAS   You can use unchecked in the following calculations since there is no risk to overflow:          StakingRewards.sol (L#161) - periodFinish = block.timestamp + rewardsDuration;         Shelter.sol (L#53) - require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, \"shelter not activated\");         ConvexStakingWrapper.sol (L#279) - return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;         Shelter.sol (L#45) - require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\");    Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               EasySign.isWinningSignature (_signature)    Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               ConvexStakingWrapper.sol, _getDepositedBalance, { return deposits[_pid][_account].amount; }         ConvexStakingWrapper.sol, _getTotalSupply, { return IRewardStaking(convexPool[_pid]).balanceOf(address(this)); }    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               ConvexStakingWrapper.sol, _calcRewardIntegral         ConvexStakingWrapper.sol, _getDepositedBalance         ConvexStakingWrapper.sol, _getTotalSupply    Title: Check if amount is not zero to save gas Severity: GAS  The following functions could skip other steps if the amount is 0. (A similar issue: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82)           StakingRewards.sol, recoverERC20    "}, {"title": "add() in the MasterChef.sol contract is marked Public.", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  0x510c   # Vulnerability details  ## Impact The function definition of \"add\" is marked \"public\". However, it is never directly called by another function in the same contract or in any of its descendants. Consider to mark it as \"external\" instead.  ## Proof of Concept  MasterChef.sol  function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {         require(_token != address(0), \"zero address\");         uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;         totalAllocPoint = totalAllocPoint.add(_allocationPoints);         require(pid[_token] == 0, \"already registered\"); // pid starts from 0         poolInfo.push(             PoolInfo({                 depositToken: IERC20(_token),                 allocPoint: _allocationPoints,                 lastRewardBlock: lastRewardBlock,                 accConcurPerShare: 0,                 depositFeeBP: _depositFee             })         );         pid[_token] = poolInfo.length - 1;     }  ## Tools Used Manual Review  ## Recommended Mitigation Steps It recommended to change the visibility of the function to External to optimize the usage of gas.  "}, {"title": "Gas report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  wuwe1   # Vulnerability details  # Cache array length in for loops can save gas  ## POC > Caching the array length in the stack saves around 3 gas per iteration.  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L35  ```solidity function claimRewards(address[] calldata _tokens) external override {     for (uint256 i = 0; i < _tokens.length; i++) {         uint256 getting = reward[msg.sender][_tokens[i]];         IERC20(_tokens[i]).safeTransfer(msg.sender, getting);         reward[msg.sender][_tokens[i]] = 0;     } } ```  # Dead code  Remove dead code in  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L19  # public to external  These function can be external.  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L93  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L127  # state can be constant  These state variables can be constant  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L50  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L56  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L57  "}, {"title": "deposit in ConvexStakingWrapper will most certainly revert", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/33", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  wuwe1   # Vulnerability details  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L94-L99  ```solidity         address mainPool = IRewardStaking(convexBooster)             .poolInfo(_pid)             .crvRewards;         if (rewards[_pid].length == 0) {             pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;             convexPool[_pid] = mainPool; ```  `convexPool[_pid]` is set to `IRewardStaking(convexBooster).poolInfo(_pid).crvRewards;`  `crvRewards` is a `BaseRewardPool` like this one https://etherscan.io/address/0x8B55351ea358e5Eda371575B031ee24F462d503e#code.  `BaseRewardPool` does not implement `poolInfo`   https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L238  ```solidity IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken ```  Above line calls `poolInfo` of  `crvRewards` which causes revert.  ## Recommended Mitigation Steps  According to Booster's code   https://etherscan.io/address/0xF403C135812408BFbE8713b5A23a04b3D48AAE31#code  ```solidity     //deposit lp tokens and stake     function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){         require(!isShutdown,\"shutdown\");         PoolInfo storage pool = poolInfo[_pid];         require(pool.shutdown == false, \"pool is closed\");          //send to proxy to stake         address lptoken = pool.lptoken;         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount); ```  `convexBooster` requires `poolInfo[_pid].lptoken`.  change L238 to   ```solidity IRewardStaking(convexBooster).poolInfo(_pid).lptoken ```  "}, {"title": "Deactivate function can be bypassed", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact onlyClient can deactivate a token even after deadline is passed and transfer all token balance to itself  ## Proof of Concept 1. Navigate to contract at https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol  2. Observe that token can only be deactivated if activated[_token] + GRACE_PERIOD > block.timestamp. We will bypass this  3. onlyClient activates a token X using the activate function  4. Assume Grace period is crossed such that activated[_token] + GRACE_PERIOD < block.timestamp  5. Now if onlyClient calls deactivate function, it fails with \"too late\"  6. But onlyClient can bypass this by calling activate function again on token X which will reset the timestamp to latest in activated[_token] and hence onlyClient can now call deactivate function to disable the token and retrieve all funds present in the contract to his own address  ## Recommended Mitigation Steps Add below condition to activate function  ``` function activate(IERC20 _token) external override onlyClient { require(activated[_token]==0, \"Already activated\");         activated[_token] = block.timestamp;         savedTokens[_token] = _token.balanceOf(address(this));         emit ShelterActivated(_token);     } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Low findings  ****  1.  Incorrect Condition Finding:   Contract - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol  In deactivate function, deactivation is rejected even if activated[_token] + GRACE_PERIOD = block.timestamp even when it should be allowed till Grace period.   Remediation: This should be corrected by changing require condition to below:  ``` require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD >= block.timestamp, \"too late\"); ```  2. Zero Address check missing   Contract - https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol  In withdraw function, Zero address checks can be added for **to** address which can prevent losses  Remediation:  ``` require(to!=address(0), \"Incorrect address\"); ```  3. User fund stuck  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol  In withdraw function, Funds will stuck if user deposited a amount and then isDepositor[_depositor] is set to false by Admin. Now user cannot withdraw the amount since onlyDepositor will fail  Remediation: Withdraw should be independent of onlyDepositor  4. Incorrect PID updation  Contract : https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol  In massUpdatePools function, pid 0 should not be updated as poolInfo[_pid] is filled by dummy zero address token in constructor  ``` constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {         startBlock = _startBlock;         endBlock = _endBlock;         concur = _concur;         poolInfo.push(             PoolInfo({             depositToken: IERC20(address(0)),             allocPoint : 0,             lastRewardBlock : _startBlock,             accConcurPerShare : 0,             depositFeeBP : 0         }));     } ```  Remediation: The loop in massUpdatePools function should start with value 1 instead of 0  5. Insecure transfer method used  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol  In safeConcurTransfer function, transfer function is used  Remediation: use safeTransfer instead of transfer which is more secure  6. User funds can be added to 0 or non-existent pid with 0 rewards  Contract : https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol  a. In deposit & withdraw function, both accepts 0 pid which is zero address pool added by constructor, which means user funds would get added to incorrect pool.   b. Similarly non existent pid will also be accepted by both of these functions.   c. Offcourse these incorrect pid will not incur any reward since pool.accConcurPerShare will always be 0 which means user amount is added to a pool without any reward  Remediation: Add a check to see if pid>0 and pid<poolInfo.length  7. Extra reward will be given to users  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol  In notifyRewardAmount function, Since block.timestamp value will change slightly while calculating periodFinish (when compared to lastUpdateTime) so periodFinish will actually become lastUpdateTime+rewardsDuration+x which is incorrect and would impact rewardPerToken by making it slightly higher  ``` lastUpdateTime = block.timestamp;         periodFinish = block.timestamp + rewardsDuration; ```  Remediation: Store block.timestamp locally and then use local variable to update periodFinish and lastUpdateTime  8. Missing condition:  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol  In addRewards function, it is not checked if extraToken is crv. Only cvx check is present  Remediation: Add below check  ``` if (extraToken == crv) {rewards[_pid][CRV_INDEX].pool = extraPool;} ```  9. rewards entries are made even for incorrect/non-existent pid  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol  Non existent pid will create crv and cvx entries for rewards[_pid] since rewards[_pid].length == 0  Remediation: Revert if mainPool is zero address, require (mainPool!=address(0));  ## Non critical findings  10. Missing events  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol  In claimRewards function observe that No emit event is fired after successful reward claim by user. Ideally a new event should be triggered showing that reward was claimed successfully by user  11. Reward lost  Contract: https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol  In notifyRewardAmount function, if Admin added a reward 100 once block.timestamp >= periodFinish. Now if Admin decides to add 200 rewards calling this function at block.timestamp >= periodFinish then contract considers total reward as 200 and discards the reward 100 added initially  ``` if (block.timestamp >= periodFinish) {             rewardRate = reward / rewardsDuration; // old reward is not considered         } ```  "}, {"title": "execute in VoteProxy should be payable", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  wuwe1   # Vulnerability details  ## Impact `execute` will revert when `msg.value > 0`  ## Proof of Concept Lacking `payable` mutability specifier.  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/VoteProxy.sol#L28-L35  ```solidity     function execute(         address _to,         uint256 _value,         bytes calldata _data     ) external onlyOwner returns (bool, bytes memory) {         (bool success, bytes memory result) = _to.call{value: _value}(_data);         return (success, result);     } ```   ## Recommended Mitigation Steps  Add `payable` mutability specifier.  "}, {"title": "Mark ConvexStakingWrapper.addRewards as External", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  Heartless   # Vulnerability details  ## Impact external visibility uses less gas than public visibility. addRewards is never called internally in this project so does not need public visibility. addRewards was public in the original source from convex because they called addRewards() internally in the initialize() function, which ConvexStakingWrapper does not have.  ## Proof of Concept Line 93 in ConvexStakingWrapper.sol  ## Tools Used  ## Recommended Mitigation Steps Change addRewards visibility to external.  "}, {"title": "Gas Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-badger-citadel-findings", "body": "Handle:\r IllIllI\r \r Risk rating:\r Gas Optimizations\r \r Gas report: [See markdown file here](https://github.com/code-423n4/2022-02-badger-citadel-findings/blob/main/data/IllIllI_112.md)"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/57", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-badger-citadel-findings", "body": "## Overall  We find the `2022-02-badger-citadel` codebase well-documented, well-structured, with a fair amount of tests, and pretty gas efficient.  There are 2 Non-critical issues and 1 Low severity issue found.  ### [N1] Inconsistent style of error messages  Some of the error messages are prefixed with `TokenSale:` while some are not.  Consider updating the error messages to keep the style of error messages consistent.  ### [N2] Tokens with fee on transfer are not supported  There are ERC20 tokens that charge fee for every `transfer()` or `transferFrom()`.  In the current implementation, `TokenSaleUpgradeable.sol#buy()` assumes that the received amount is the same as the transfer amount, and uses it to calculate `tokenOutAmount_`.  https://github.com/code-423n4/2022-02-badger-citadel/blob/main/contracts/TokenSaleUpgradeable.sol#L180-L183  Consider calling `balanceOf()` before and after the transfer to get the actual transferred amount if a token with transfer tax as `tokenIn` should be supported.  ### [L3] Allowing `setTokenOutPrice` after the token sale starts can result in unexpected results for buyers  In the current implementation, the owner can call `setTokenOutPrice()` and change the tokenOutPrice anytime, including when the token sale already started. In the case of network congestion or in chance, if the owner `setTokenOutPrice()` to a higher price, it can result in unexpected tokenOutAmount for the buyers who submitted their `buy()` txs before but only get packed into the block after the `setTokenOutPrice()` tx.  We consider this an undesirable situation for users and there is pretty much no other way to prevent it, therefore it should be prevented at the smart contract level.  Consider making `setTokenOutPrice()` only callable before the sale starts."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-badger-citadel-findings", "body": "# Handle  PostMan56   # Vulnerability details  ## Impact This is my first time submitting so please let me know if it's bad or poorly explained   Small gas optimization in the function  'getTokenInLimitLeft' and use of uint256 vs uint8  ## Proof of Concept 'getTokenInLimitLeft'     function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {         if (totalTokenIn < tokenInLimit) {             limitLeft_ = tokenInLimit - totalTokenIn;         }     } In gas estimates(before): ``` \"Creation\": {        \"codeDepositCost\": \"3427600\",     \"executionCost\": \"3828\",     \"totalCost\": \"3431428\" } ```     function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {         if (totalTokenIn <= tokenInLimit) {             limitLeft_ = tokenInLimit - totalTokenIn;         }     }  In gas estimates(after): ``` \"Creation\": {     \"codeDepositCost\": \"3427400\",     \"executionCost\": \"3828\",     \"totalCost\": \"3431228\" } ```  ## Proof of Concept uint256 vs uint8 uint8 can be found in lines: 56, 57, 65, 146  In gas estimates(before): ``` \"Creation\": {     \"codeDepositCost\": \"3427600\",     \"executionCost\": \"3828\",     \"totalCost\": \"3431428\" } ``` In gas estimates(after): ``` \"Creation\": {     \"codeDepositCost\": \"3394800\",     \"executionCost\": \"3787\",     \"totalCost\": \"3398587\" } ``` ## Tools Used Remix gas estimates  ## Recommended Mitigation Steps < & > contains ISZERO opcode making it cost more To negate this add = after < or > to save 200 gas on contract deploy  use of uint256 is cheaper than uint8 in data types  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas optimization  1 Use default value for uint256 and use ++i instead of i++ in for loop  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L136-L139 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L148 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L165 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L261 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L280 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L318  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L103 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L113 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L153 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L213 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L273 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L327 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L369 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L581  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L581  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/OperatorResolver.sol#L40 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/OperatorResolver.sol#L75   Feesplitter.sol  2 Use storage for shareholders[_accountIndex]saves gas in updateShareholder.  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L134-L140  function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {         require(_accountIndex < shareholders.length, \"FS: INVALID_ACCOUNT_INDEX\");         Shareholder storage _shareholder = shareholders[_accountIndex];         totalWeights = totalWeights + _weight - _shareholder.weight;         require(totalWeights != 0, \"FS: TOTAL_WEIGHTS_ZERO\");         _shareholder.weight = _weight;         emit ShareholderUpdated(_shareholder.account, _weight);     }  NestedRecords.sol  3 Check _reserve != address(0) earlier in store save gas.  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L111-L127  require(_reserve != address(0), \u201cNRC: NO_ADDRESS\u201d); must be checked separately at the beginning of function.  4 Use storage for records[_nftId] saves gas in store.  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L111-L132  function store(         uint256 _nftId,         address _token,         uint256 _amount,         address _reserve     ) external onlyFactory {         NftRecord storage _record = records[_nftId];         uint256 amount = _record.holdings[_token];         // uint256 amount = records[_nftId].holdings[_token];         if (amount != 0) {             require(_record.reserve == _reserve, \"NRC: RESERVE_MISMATCH\");             updateHoldingAmount(_nftId, _token, amount + _amount);             return;         }         require(_record.tokens.length < maxHoldingsCount, \"NRC: TOO_MANY_TOKENS\");         require(             _reserve != address(0) && (_reserve == _record.reserve || _record.reserve == address(0)),             \"NRC: INVALID_RESERVE\"         );           _record.holdings[_token] = _amount;         _record.tokens.push(_token);         _record.reserve = _reserve;     }   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/70", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "# QA Report   **Table of Contents:**   - [QA Report](#qa-report)   - [Foreword](#foreword)   - [Comparisons](#comparisons)     - [Comparison that should be inclusive in NestedRecords.sol](#comparison-that-should-be-inclusive-in-nestedrecordssol)   - [Variables](#variables)     - [Missing Address(0) checks](#missing-address0-checks)     - [Check if a value is in an array before a push](#check-if-a-value-is-in-an-array-before-a-push)     - [Variables that should be grouped together in a struct](#variables-that-should-be-grouped-together-in-a-struct)       - [File: FeeSplitter.sol](#file-feesplittersol)   - [Arithmetics](#arithmetics)     - [Possible division by 0](#possible-division-by-0)   - [Revert Strings](#revert-strings)     - [File: NestedFactory.sol](#file-nestedfactorysol)       - [Inconsistent Revert string](#inconsistent-revert-string)     - [File: MixinOperatorResolver.sol](#file-mixinoperatorresolversol)       - [Inconsistent Revert string (1)](#inconsistent-revert-string-1)       - [Misleading + Inconsistent Revert string (2)](#misleading--inconsistent-revert-string-2)     - [File: OwnableProxyDelegation.sol](#file-ownableproxydelegationsol)       - [Inconsistent Revert string (1)](#inconsistent-revert-string-1-1)       - [Inconsistent Revert string (2)](#inconsistent-revert-string-2)     - [File: ZeroExOperator.sol](#file-zeroexoperatorsol)       - [Inconsistent Revert string (1)](#inconsistent-revert-string-1-2)       - [Inconsistent Revert string (2)](#inconsistent-revert-string-2-1)   - [Comments](#comments)     - [File: NestedFactory.sol](#file-nestedfactorysol-1)       - [Missing comment \"@return\" (1)](#missing-comment-return-1)       - [Missing comment \"@return\" (2)](#missing-comment-return-2)       - [Missing comment \"@param\" (1)](#missing-comment-param-1)     - [File: NestedRecords.sol](#file-nestedrecordssol)       - [Missing comment \"@return\" (1)](#missing-comment-return-1-1)       - [Missing comment \"@return\" (2)](#missing-comment-return-2-1)       - [Misleading comment on \"@return\"](#misleading-comment-on-return)     - [File: MixinOperatorResolver.sol](#file-mixinoperatorresolversol-1)       - [Missing 2 comments \"@param\" & changeable \"@return\" comment/variable](#missing-2-comments-param--changeable-return-commentvariable)     - [File: ExchangeHelpers.sol](#file-exchangehelperssol)       - [Missing comment \"@return\"](#missing-comment-return)  ## Foreword - **`@audit` tags** > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Comparisons ### Comparison that should be inclusive in NestedRecords.sol ``` File: NestedRecords.sol 123:         require(records[_nftId].tokens.length < maxHoldingsCount, \"NRC: TOO_MANY_TOKENS\"); //@audit should be inclusive ```  As length isn't 0 indexed, I believe, as an example to illustrate, that if `maxHoldingsCount == 1`, then `records[_nftId].tokens.length == 1` should be a passing condition. Therefore, I suggest changing `<` with `<=`  ## Variables   ### Missing Address(0) checks   ``` File: MixinOperatorResolver.sol 22:     constructor(address _resolver) { 23:         resolver = OperatorResolver(_resolver); //@audit missing address(0) check on immutable just like in the constructors in FeeSplitter.sol and NestedFactory.sol 24:     } ```  ### Check if a value is in an array before a push In `NestedRecords.sol`'s `store` function, it's possible to push an existing `address _token` several times in the same array  ``` File: NestedRecords.sol 130:         records[_nftId].tokens.push(_token); //@audit : should check existence ``` The previous lines of codes don't prevent this. The `store` function has the modifier `onlyFactory` and the only impact seem to be a possible maximization of `records[_nftId].tokens.length` (so that it reaches `maxHoldingsCount`).  ### Variables that should be grouped together in a struct   For maps that use the same key value: having separate fields is error prone (like in case of deletion or future new fields).   By regrouping, it's then possible to delete all related fields with a simple `delete newStruct[previousSameKeyForAllPreviousMaps]`.    #### File: FeeSplitter.sol 2 maps can be grouped together, as they use the same `_account` key:   ```   62:     struct TokenRecords { 63:         uint256 totalShares; 64:         uint256 totalReleased; 65:         mapping(address => uint256) shares; //@audit group  66:         mapping(address => uint256) released; //@audit group  67:     } ```   I'd suggest these 2 related data get grouped in a struct, let's name it `AccountInfo`:    ```   struct AccountInfo {        uint256 shares;        uint256 released;    }    ```   And it would be used in this manner (where `address` is `_account`):    ```        struct TokenRecords {         uint256 totalShares;         uint256 totalReleased;         mapping(address => AccountInfo) accountInfo;     }    ```    ## Arithmetics   ### Possible division by 0   There are no checks that the denominator is `!= 0` here:   ```   File: FeeSplitter.sol 327:     function _computeShareCount( 328:         uint256 _amount, 329:         uint256 _weight, 330:         uint256 _totalWeights 331:     ) private pure returns (uint256) { 332:         return (_amount * _weight) / _totalWeights; // @audit _totalWeights can be equal to 0, see FeeSplitter.sol:L184 333:     } ```  ## Revert Strings ### File: NestedFactory.sol #### Inconsistent Revert string ``` 44:         require(_exists(_tokenId), \"URI query for nonexistent token\"); ``` All other revert strings in `NestedAsset.sol` begin with `NA: `. Only this one doesn't. It's possible to gain consistency and still have an < 32 bytes size string with the following: `\"NA: URI query - inexistent token\"`  ### File: MixinOperatorResolver.sol #### Inconsistent Revert string (1) ``` 100:             require(tokens[0] == _outputToken, \"OH: INVALID_OUTPUT_TOKEN\");//@audit LOW comment : MOR like above ``` Here, `\"OH: INVALID_OUTPUT_TOKEN\"` should be replaced with `\"MOR: INVALID_OUTPUT_TOKEN\"`  #### Misleading + Inconsistent Revert string (2) ``` 101:             require(tokens[1] == _inputToken, \"OH: INVALID_OUTPUT_TOKEN\"); //@audit LOW comment : INVALID_INPUT_TOKEN //@audit LOW comment : MOR ``` Here, `\"OH: INVALID_OUTPUT_TOKEN\"` should be replaced with `\"MOR: INVALID_INPUT_TOKEN\"`  ### File: OwnableProxyDelegation.sol #### Inconsistent Revert string (1) ``` 25:         require(!initialized, \"OFP: INITIALIZED\"); //@audit low OFP doesn't make sense, use OPD instead (example: OwnableFactoryHandler is OFH, MixinOperatorResolver is MOR) ``` Is most contracts, the capital letters from the contract's name are used as a prefix in the revert strings (`OwnableFactoryHandler` has `OFH`, `MixinOperatorResolver` has `MOR`). Here, `OFP` doesn't really reflect `OwnableProxyDelegation`. It should be `OPD`.  #### Inconsistent Revert string (2) ``` 26:         require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, \"OFP: FORBIDDEN\");//@audit should be \"OPD: FORBIDDEN\"  ``` Same as above: `OFP` should be `OPD`.  ### File: ZeroExOperator.sol #### Inconsistent Revert string (1) ``` 32:         require(success, \"ZEO: SWAP_FAILED\"); ... 36:         require(amountBought != 0, \"ZeroExOperator::performSwap: amountBought cant be zero\"); //@audit LOW do like line 32 : \"ZEO: amountBought cant be zero\" < 32 bytes & consistent ``` As said before, the capital letters from the contract's name are used as a prefix in the revert strings. Here, the revert string's size is > 32 bytes and isn't using the same style as 4 lines above it. `ZeroExOperator::performSwap` should be `ZEO`.  #### Inconsistent Revert string (2) ``` 32:         require(success, \"ZEO: SWAP_FAILED\"); ... 37:         require(amountSold != 0, \"ZeroExOperator::performSwap: amountSold cant be zero\");//@audit do like line 32 : \"ZEO: amountSold cant be zero\" < 32 bytes & consistent ``` Same as above: `ZeroExOperator::performSwap` should be `ZEO`.  ## Comments ### File: NestedFactory.sol #### Missing comment \"@return\" (1) ``` 403:     /// @dev Call the operator to submit the order and add the output 404:     /// assets to the reserve (if needed). 405:     /// @param _inputToken Token used to make the orders 406:     /// @param _outputToken Expected output token 407:     /// @param _nftId The nftId 408:     /// @param _order The order calldata 409:     /// @param _toReserve True if the output is store in the reserve/records, false if not. //@audit missing @return  410:     function _submitOrder( 411:         address _inputToken, 412:         address _outputToken, 413:         uint256 _nftId, 414:         Order calldata _order, 415:         bool _toReserve 416:     ) private returns (uint256 amountSpent) { ```  #### Missing comment \"@return\" (2) ``` 474:     /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve 475:     ///      or the user wallet, to the factory. 476:     /// @param _nftId The NFT id 477:     /// @param _inputToken The token to receive 478:     /// @param _inputTokenAmount Amount to transfer 479:     /// @param _fromReserve True to transfer from the reserve 480:     /// @return Token transfered (in case of ETH) 481:     ///         The real amount received after the transfer to the factory //@audit missing @return (not the description, just the keyword) 482:     function _transferInputTokens( 483:         uint256 _nftId, 484:         IERC20 _inputToken, 485:         uint256 _inputTokenAmount, 486:         bool _fromReserve 487:     ) private returns (IERC20, uint256) { ```  #### Missing comment \"@param\" (1) ``` 562:     /// @dev Transfer from factory and collect fees 563:     /// @param _token The token to transfer 564:     /// @param _amount The amount (with fees) to transfer 565:     /// @param _dest The address receiving the funds //@audit missing @param 566:     function _safeTransferWithFees( 567:         IERC20 _token, 568:         uint256 _amount, 569:         address _dest, 570:         uint256 _nftId 571:     ) private { ```  ### File: NestedRecords.sol #### Missing comment \"@return\" (1) ``` 162:     /// @param _nftId The id of the NFT> //@audit missing @return 163:     function getAssetTokens(uint256 _nftId) public view returns (address[] memory) { ```  #### Missing comment \"@return\" (2) ``` 183:     /// @param _token The address of the token //@audit missing @return 184:     function getAssetHolding(uint256 _nftId, address _token) public view returns (uint256) { ```  #### Misleading comment on \"@return\" Here, the comment `@return The holdings`, which is the unique `@return` comment, suggests a returned `mapping(address => uint256) holdings` as seen on `struct NftRecord`. However, the function is actually returning a `uint256[]` and an `address[]`. Therefore, two `@return` are required and the previous one should be deleted.  Code: ``` 188:     /// @notice Returns the holdings associated to a NestedAsset 189:     /// @param _nftId the id of the NestedAsset 190:     /// @return The holdings //@audit \"The holdings\" suggests a \"mapping(address => uint256)\" but a uint256[] and an address[] are returned.   191:     function tokenHoldings(uint256 _nftId) public view returns (address[] memory, uint256[] memory) { ```  ### File: MixinOperatorResolver.sol #### Missing 2 comments \"@param\" & changeable \"@return\" comment/variable ```     /// @dev Build the calldata (with safe datas) and call the Operator     /// @param _order The order to execute //@audit missing @param _inputToken and @param _outputToken     /// @return success If the operator call is successful     /// @return amounts The amounts from the execution (used and received) //@audit why not use uint256[2]?     ///         - amounts[0] : The amount of output token     ///         - amounts[1] : The amount of input token USED by the operator (can be different than expected)     function callOperator(         INestedFactory.Order calldata _order,         address _inputToken,         address _outputToken     ) internal returns (bool success, uint256[] memory amounts) { ``` I suggest changing the returned uint256[] to uint256[2]  ### File: ExchangeHelpers.sol #### Missing comment \"@return\" ``` 10:     /// @dev Perform a swap between two tokens 11:     /// @param _sellToken Token to exchange 12:     /// @param _swapTarget The address of the contract that swaps tokens 13:     /// @param _swapCallData Call data provided by 0x to fill the quote //@audit missing @return 14:     function fillQuote( 15:         IERC20 _sellToken, 16:         address _swapTarget, 17:         bytes memory _swapCallData 18:     ) internal returns (bool) { ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Use cached variable value  ## Impact  The `_submitOutOrders()` function sets `batchLength = _batchedOrders.orders.length`, but in the for loop the value \"_batchedOrders.orders.length\" is used instead of \"batchLength\". Using the cached variable could save gas.  ## Proof of Concept  The for loop on [line 369](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L369) could use the batchLength variable. This approach is used in the similar for loop on [line 327](https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L327).  ## Recommended Mitigation Steps  Use the cached \"batchLength\" variable"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "* function transfer in NestedReserve is never used and can only be called by the factory (onlyFactory), so consider removing it because I think the factory uses a withdraw function from the Reserve.  * Currently never used: ```solidity   function setReserve onlyFactory ``` You can remove it to save some gas, or leave it if it was intended for future use with other factories.  * functions that add or remove operators or shareholders iterate over the whole array, so you can consider using EnumerableSet to store them: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol  * Could just use msg.sender and do not call an owner() function here: ```solidity     function unlockTokens(IERC20 _token) external override onlyOwner {         ...         _token.safeTransfer(owner(), amount); ```  * There are several functions that call _checkMsgValue. This function is quite expensive as it iterates over all the _batchedOrders and is only relevant when the inputToken is ETH. Later the callers will have to iterate over all the _batchedOrders again anyway, so I think this function should be refactored to significantly reduce gas. My suggestion: because processInputOrders and processInputAndOutputOrders both call _processInputOrders, the logic from _checkMsgValue could be moved to _processInputOrders. function create then can be refactored to re-use _processInputOrders. I see 2 discrepancies here: _fromReserve is always false when _submitInOrders is called from create (could be solved if _processInputOrders takes extra parameter), and _processInputOrders has this extra line: ```solidity   require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\"); ``` but this could be solved if you first mint the NFT and then invoke _processInputOrders from create.  * function withdraw calls nestedRecords twice: ```solidity  uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);  ...   address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];  ```  I think it could just substitute these links by first fetching all the tokens, and then calculating the length itself instead of making 2 external calls for pretty much the same data.    * Could use 'unchecked' maths here, as underflow is not possible: ```solidity    if (_amountToSpend > amounts[1]) {       IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);     } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/65", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "-check `_metadataURI` !=\"\" https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedAsset.sol#L106 `backfillTokenURI()` & `mintWithMetadata`was expected to change `tokenURI`. By not validating `metadataURI`!= \"\", it will just spend user gas more and nothing was changed"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "GAS :  1. Title: Unnecessary owner function call  Impact: In the `https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L134` it uses owner function call, instead of _owner, using _owner directly can save some gas  POC :  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L134  2. Title: It cheaper to remove the `&&` operator and make the 2 different require  POC :  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedAsset.sol#L78  Mitigation :  ``` require(_exists(_replicatedTokenId), \"NA: INVALID_REPLICATED_TOKEN_ID\"); require(tokenId != _replicatedTokenId, \"NA: INVALID_REPLICATED_TOKEN_ID\"); ```  3. Title : It Cheaper to use 0 instead of empty string  Impact : change bytes32(\"\") to bytes32(0) can save +- 3 gas, both check for zero bytes32  POC :  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L101  Mitigation :   ``` require(operator != bytes32(0), \"NF: INVALID_OPERATOR_NAME\"); ```  4. Title : It cheaper to cached the operators to a memory instead use storage multiple times  Impact : In the `removeOperator` function it do the check in the loop by calling the operators storage, instead checking it with memory, multiple storage read is more expansive than doing multiple read from memory therefore saving the operator value to a memory first before checking inside a loop can make this call cheaper, just like `addOperator` function do.  POC :  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L111  Mitigation :  ``` function removeOperator(bytes32 operator) external override onlyOwner {         bytes32[] memory operatorsCache = operators;         uint256 operatorsLength = operatorsCache.length;         for (uint256 i = 0; i < operatorsLength; i++) {             if (operatorsCache[i] == operator) {                 operators[i] = operatorsCache[operatorsLength - 1];                 operators.pop();                 emit OperatorRemoved(operator);                 return;             }         }         revert(\"NF: NON_EXISTENT_OPERATOR\");     } ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "## Nested Finance Gas Optimization Report  Unless otherwise noted, manual auditing and testing were done using Visual Studio Code and Remix. The sponsor-provided test suite was used to verify the findings.   The audit was done from February 10-12, 2022 by ye0lde through code4rena.  - [Nested Finance Gas Optimization Report](#nested-finance-gas-optimization-report) - [Findings](#findings)   - [G-1 - Function `store` can be more efficient (NestedRecords.sol)](#g-1---function-store-can-be-more-efficient-nestedrecordssol)   - [G-2 - Save gas and retain code clarity with the `unchecked` keyword (NestedFactory.sol)](#g-2---save-gas-and-retain-code-clarity-with-the-unchecked-keyword-nestedfactorysol)      ## Findings    ### G-1 - Function `store` can be more efficient (NestedRecords.sol)  #### Impact Caching the references to `records[_nftId]` in the `store` function will decrease gas usage as `store` is called frequently from NestedFactory.sol    Below are the relevant numbers from the sponsor's test suite before and after the change:  | Function     | Before (AVG) | After (AVG) |  | ----------- | ----------- | ----------- | | create     | 701747      | 701219 | | processInputAndOutputOrders   | 871716       |  871184 | | processInputOrders   | 406972       |  406779 | | processOutputOrders   | 449829       |  449712 | | store   | 83927       |  83684 |   #### Proof of Concept The `store` function is here: https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L111-L132  ```     function store(         uint256 _nftId,         address _token,         uint256 _amount,         address _reserve     ) external onlyFactory {         uint256 amount = records[_nftId].holdings[_token];         if (amount != 0) {             require(records[_nftId].reserve == _reserve, \"NRC: RESERVE_MISMATCH\");             updateHoldingAmount(_nftId, _token, amount + _amount);             return;         }         require(records[_nftId].tokens.length < maxHoldingsCount, \"NRC: TOO_MANY_TOKENS\");         require(             _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)),             \"NRC: INVALID_RESERVE\"         );           records[_nftId].holdings[_token] = _amount;         records[_nftId].tokens.push(_token);         records[_nftId].reserve = _reserve;     } ```  #### Recommended Mitigation Steps I suggest the following changes:  ```     function store(         uint256 _nftId,         address _token,         uint256 _amount,         address _reserve     ) external onlyFactory {          NftRecord storage nftRecord = records[_nftId];         uint256 amount = nftRecord.holdings[_token];         if (amount != 0) {             require(nftRecord.reserve == _reserve, \"NRC: RESERVE_MISMATCH\");             updateHoldingAmount(_nftId, _token, amount + _amount);             return;         }         require(nftRecord.tokens.length < maxHoldingsCount, \"NRC: TOO_MANY_TOKENS\");         require(             _reserve != address(0) && (_reserve == nftRecord.reserve || nftRecord.reserve == address(0)),             \"NRC: INVALID_RESERVE\"         );          nftRecord.holdings[_token] = _amount;         nftRecord.tokens.push(_token);         nftRecord.reserve = _reserve;     }  ``` ---  ### G-2 - Save gas and retain code clarity with the `unchecked` keyword (NestedFactory.sol)  #### Impact In a previous Code4rena audit, various \"unchecked\" optimizations were suggested.  Some of which were implemented and some were not because the sponsor's focus was code clarity over optimization.    I believe this suggestion meets the requirements for both optimization and clarity. Below are the relevant numbers from the sponsor's test suite before and after the change:  | Function     | Before (AVG) | After (AVG) |  | ----------- | ----------- | ----------- | | create     | 701747      | 701623 | | processInputAndOutputOrders   | 871716       |  871468 | | processInputOrders   | 406972       |  406784 |   #### Proof of Concept The code that can be `unchecked` is here: https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L339-L347  The \"unchecked\" keyword can be applied here since there is a `require` statement at #337 that ensures the arithmetic operations would not cause an integer underflow or overflow.  ``` uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;  if (underSpentAmount != 0) {      tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);  }    // If input is from the reserve, update the records   if (_fromReserve) {       _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);   } ```  #### Recommended Mitigation Steps Add `unchecked` around #L339-L347 as shown below.  ``` require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");  unchecked {     uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;      if (underSpentAmount != 0) {         tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);     }      // If input is from the reserve, update the records     if (_fromReserve) {         _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);     } } ``` ---     "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "1. considered using require instead of && can save gas https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L123 // gas cost 35473  Change to: ``` require(accountsLength != 0); require (accountsLength == _weights.length, \"FS: INPUTS_LENGTH_MUST_MATCH\"); ``` // gas cost 35465  ========================================================================  2. considered add unchecked can save gas https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L327 // gas cost 22798  add unchecked ``` unchecked { return (_amount * _weight) / _totalWeights; } ``` // gas cost 22440  ========================================================================  3. avoid unnecessary `i = 0` because the default of uint is already 0 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L126  considered removing 0 value can save gas  ========================================================================  4. `SafeERC20` Gas Optimization https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L19 by not declaring this ``` using SafeERC20 for IERC20; ```  and for example, use this: ``` SafeERC20.safeTransfer(IERC20(_inputToken)_msgSender(), _amountToSpend - amounts[1]); ```  ========================================================================  5. just read it directly to storage can save gas  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L279 // gas cost 24794  Change to: ``` Shareholder[] storage shareholdersCache = shareholders; ``` // gas cost 24684  ========================================================================  6. the original function will return 0 which a default value for uint256 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L216  // gas cost 24940  Change to: ```      function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];         if (_tokenRecords.totalShares != 0) {          uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));         return             (totalReceived * _tokenRecords.shares[_account]) /             _tokenRecords.totalShares -             _tokenRecords.released[_account];         }     } ``` // gas cost 24919  ========================================================================"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/52", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "## [N1] Unused imports  The following source units are imported but not referenced in the contract:  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/operators/Flat/FlatOperator.sol#L4-L4  ```solidity import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/operators/Flat/IFlatOperator.sol#L4-L4  ```solidity import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; ```  ### Recommendation  Check all imports and remove all unused/unreferenced and unnecessary imports.   ## [N2] Using `public` to generate the getter function can make the code simpler and cleaner  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/operators/ZeroEx/ZeroExStorage.sol#L7-L19  ```solidity contract ZeroExStorage is Ownable {     address private _swapTarget;      /// @notice Returns the address of 0x swaptarget     function swapTarget() external view returns (address) {         return _swapTarget;     }      /// @notice Update the address of 0x swaptarget     function updatesSwapTarget(address swapTargetValue) external onlyOwner {         _swapTarget = swapTargetValue;     } } ```  Can be changed to:  ```solidity contract ZeroExStorage is Ownable {     address public swapTarget;      /// @notice Update the address of 0x swaptarget     function updatesSwapTarget(address swapTargetValue) external onlyOwner {         swapTarget = swapTargetValue;     } } ```  ## [N3] Inconsistent use of `_msgSender()`  Direct use of `msg.sender` vs internal call of `_msgSender()`.  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/operators/ZeroEx/ZeroExOperator.sol#L17-L17  ```solidity ZeroExStorage(operatorStorage).transferOwnership(msg.sender); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/NestedReserve.sol#L30-L30  ```solidity _token.safeTransfer(msg.sender, _amount); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/abstracts/OwnableFactoryHandler.sol#L21-L21  ```solidity require(supportedFactories[msg.sender], \"OFH: FORBIDDEN\"); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/FeeSplitter.sol#L103-L103  ```solidity require(msg.sender == weth, \"FS: ETH_SENDER_NOT_WETH\"); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/FeeSplitter.sol#L166-L168  ```solidity amount = _releaseToken(_msgSender(), _tokens[i]); _tokens[i].safeTransfer(_msgSender(), amount); emit PaymentReleased(_msgSender(), address(_tokens[i]), amount); ```  https://github.com/code-423n4/2022-02-nested/blob/879bae87b1987d6810f25c1082e5bf664390ae7f/contracts/FeeSplitter.sol#L199-L199  ```solidity _token.safeTransferFrom(_msgSender(), address(this), _amount); ```  ### Recommendation  Consider replacing `_msgSender()` with `msg.sender` for consistency."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/50", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "# rebuildCaches lack input validation `rebuildCaches` function will call `rebuildCache()` for arbitary destinations contract https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L74 ```     function rebuildCaches(MixinOperatorResolver[] calldata destinations) public {         for (uint256 i = 0; i < destinations.length; i++) {             destinations[i].rebuildCache();         }     } ```  # Event name must be in CamelCase https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L22 ```     event reserveUpdated(uint256 nftId, address newReserve); ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/45", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "## [L1] Check against same-token `swap`:  Assessed risk: 2/10  Urgency: N/A  Codebase frequency: 1  ### [L1 - Impact]:  Users would typically not swap against the same token, hence, developers must put in place a check against such swaps. Because of the rapid development and innovation that happens within the ETH smart contract ecosystem, one should never assume that what does not go wrong now will not go wrong in a few months, hence no exceptions are to be made when it comes to security and best practices.  ```bash function performSwap(   IERC20 sellToken,   IERC20 buyToken,   bytes calldata swapCallData ) external payable override returns (uint256[] memory amounts, address[] memory tokens) {     amounts = new uint256[](2);     tokens = new address[](2);     uint256 buyBalanceBeforePurchase = buyToken.balanceOf(address(this));     uint256 sellBalanceBeforePurchase = sellToken.balanceOf(address(this));   ... ```  ### [L1 - References]:  ```solidity operators/ZeroEx/ZeroExOperator.sol line 21 ```  ### [L1 - Mitigation]:  Adding a require statement would prevent such a swap.  ```bash require(buyToken != sellToken, \"ERR: same token swap\"); ```  ### [L2] Add `_weight != 0` check in FeeSplitter  Assessed risk: 2/10  Urgency: N/A  Codebase frequency: 1  ### [L2 - Impact]:  Keeping a consistent check among all functions of the contract that deal with `_weight` is important, both from the security and clean code philosophies. One of the functions implemented in `FeeSplitter.sol` does not check against the latest `_weight` to be different than `0`, contrary to all the similar functions that have this check.  ```bash function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {     require(_accountIndex < shareholders.length, \"FS: INVALID_ACCOUNT_INDEX\");     totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;     require(totalWeights != 0, \"FS: TOTAL_WEIGHTS_ZERO\");     shareholders[_accountIndex].weight = _weight;     emit ShareholderUpdated(shareholders[_accountIndex].account, _weight); } ```  ### [L2 - References]:  ```solidity FeeSplitter.sol line 134 ```  ### [L2 - Mitigation]:  Add a check against the `_weight` being 0.  ```bash require(_weight != 0, \"FS: ZERO_WEIGHT\"); ```"}, {"title": "NestedFactory: User can utilise accidentally sent ETH funds via processOutputOrders() / processInputAndOutputOrders()", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L71 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L286-L296 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L370-L375 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L482-L492   # Vulnerability details  ## Impact  Should a user accidentally send ETH to the `NestedFactory`, anyone can utilise it to their own benefit by calling `processOutputOrders()` / `processInputAndOutputOrders()`. This is possible because:  1. `receive()` has no restriction on the sender 2. `processOutputOrders()` does not check `msg.value`, and rightly so, because funds are expected to come from `reserve`. 3. `transferInputTokens()` does not handle the case where `ETH` could be specified as an address by the user for an output order.  ```jsx if (address(_inputToken) == ETH) {   require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");   weth.deposit{ value: _inputTokenAmount }();   return (IERC20(address(weth)), _inputTokenAmount); } ```  Hence, the attack vector is simple. Should a user accidentally send ETH to the contract, create an output `Order` with `token` being `ETH` and amount corresponding to the NestedFactory\u2019s ETH balance.  ## Recommended Mitigation Steps  1. Since plain / direct`ETH` transfers are only expected to solely come from `weth` (excluding payable functions), we recommend restricting the sender to be `weth`, like how it is done in `[FeeSplitter](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L101-L104)`.          We are aware that this was raised previously here: https://github.com/code-423n4/2021-11-nested-findings/issues/188 and would like to add that the restricting the sender in the `receive()` function will not affect `payable` functions. From from what we see, plain ETH transfers are also not expected to come from other sources like `NestedReserve` or operators.       ```jsx receive() external payable {   require(msg.sender == address(weth), \"NF: ETH_SENDER_NOT_WETH\"); } ```  1. Check that `_fromReserve` is false in the scenario `address(_inputToken) == ETH`.  ```jsx if (address(_inputToken) == ETH) {   require(!_fromReserve, \"NF: INVALID_INPUT_TOKEN\");   require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");   weth.deposit{ value: _inputTokenAmount }();   return (IERC20(address(weth)), _inputTokenAmount); } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "# Codebase Impressions & Summary  As this is a mitigation contest, there were far less issues discovered. Overall, the contracts were well-documented and are of high quality. The high and medium severity issues raised previously are rectified in the new codebase while the low and non critical issues are either fixed or acknowledged.  # Non-Critical Findings  ## NC01: Inconsistent capitalization for event `reserveUpdated`  ### Line References  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L22](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L22)  ### Description  All declared events are in PascalCase except `reserveUpdated`.  ## NC02: Spelling Error  ### Line References  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L32-L33](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L32-L33)  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L37](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L37)  `weigth` \u2192 `weight`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "## G01: Redundant variables / events  The following variables / events are initialized / declared, but their values are not used in the contract subsequently. Consider removing them.  ### Variables  ### Events  `[INestedFactory.ReserveUpdated](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/interfaces/INestedFactory.sol#L16-L18)`  ## G02: NestedFactory: Redundant `weth` casting  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L554](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L554)  `weth` is already of type `IWETH`, so the casting is redundant.  ## G03: NestedFactory: Shift `RESERVE_MISMATCH` checks in `_processInputOrders()` and `_processOutputOrders()` to external functions  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L271](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L271)  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L289](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L289)  The checks above can be shifted to the parent functions `processInputOrders()`, `processOutputOrders()` and `processInputAndOutputOrders()` to prevent a duplicate check in the combined function `processInputAndOutputOrders()`.  ## G04: NestedFactory: Use a locally scoped variable in `destroy()`  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L213-L219](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L213-L219)  Instead of calling `tokens[i]` multiple times, you can store it as a locally scoped variable and use the variable multiple times instead.  ## G05: FeeSplitter: Redundant check on `totalWeights` in `updateShareholder()`  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L137](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L137)  The check `require(totalWeights != 0, \"FS: TOTAL_WEIGHTS_ZERO\");` is redundant because `totalWeights` is minimally `royaltiesWeight`, and `royaltiesWeight` is strictly greater than zero when it is set.  ## G06: FeeSplitter: Replace nested loop in `setShareholders` with previous proposed solution of sorting array off-chain, or a mapping  [https://github.com/code-423n4/2021-11-nested-findings/issues/135](https://github.com/code-423n4/2021-11-nested-findings/issues/135)  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L120](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L120)  [https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L315](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L315)  `setShareholders()` iterates through all the accounts to be added but at each iteration, `_addShareholders()` iterates through all the previously added shareholders to ensure there are no duplicates. This nested loop is very expensive.   It would be more gas-efficient to sort the array off-chain first, then check that the next address is greater than the previous, as suggested in our initial finding.  Alternatively, use a mapping to check if a shareholder exists and if it doesn\u2019t, then push it to the `shareholders` array. Note that in order to delete the mapping, you need to iterate through the old `shareholders` array and delete the mapping first before deleting the old `shareholders`."}, {"title": "`NestedFactory` does not track operators properly", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/38", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L99-L108 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L30-L47 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L110-L122 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L49-L55   # Vulnerability details  `NestedFactory` extends the `MixinOperatorResolver` contract which comes from the [`synthetix/MixinResolver.sol`](https://github.com/Synthetixio/synthetix/blob/a1786e5d64b5b51212785ade6d8b42435f69c387/contracts/MixinResolver.sol) code base where the expectation is that `isResolverCached()` returns false until [`rebuildCache()` is called and the cache is fully up to date](https://github.com/Synthetixio/synthetix/blob/a1786e5d64b5b51212785ade6d8b42435f69c387/test/contracts/MixinResolver.js#L82-L105). Due to [a medium issue](https://github.com/code-423n4/2021-11-nested-findings/issues/217) identified in a prior contest, the `OperatorResolver.importOperators()` step was made to be atomically combined with the `NestedFactory.rebuildCache()` step. However, the atomicity was not applied everywhere and the ability to add/remove operators from the `NestedFactory` also had other cache-inconsistency issues. There are *four separate instances* of operator tracking problems in this submission.  ## Impact As with the prior issue, many core operations (such as `NestedFactory.create()` and `NestedFactory.swapTokenForTokens()`) are dependant on the assumption that the `operatorCache` cache is synced prior to these functions being executed, but this may not necessarily be the case. Unlike the prior issue which was about updates to the resolver not getting reflected in the cache, this issue is about changes to the factory not updating the cache.  ## Proof of Concept  ### 1. `removeOperator()` does not call `rebuildCache()` 1. `NestedFactory.removeOperator()` is called to remove an operator 2. A user calls `NestedFactory(MixinOperatorResolver).create()` using that operator and succeedes 3. `NestedFactory.rebuildCache()` is called to rebuild cache This flow is not aware that the cache is not in sync  ```solidity     /// @inheritdoc INestedFactory     function addOperator(bytes32 operator) external override onlyOwner {         require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");         bytes32[] memory operatorsCache = operators;         for (uint256 i = 0; i < operatorsCache.length; i++) {             require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");         }         operators.push(operator);         emit OperatorAdded(operator);     } ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L99-L108  ### 2. Using both `removeOperator()` and `rebuildCache()` does not prevent `create()` from using the operator Even if `removeOperator()` calls `rebuildCache()` the function will still not work because `resolverOperatorsRequired()` only keeps track of remaining operators, and `rebuildCache()` currently has no way of knowing that an entry was removed from that array and that a corresponding entry from `operatorCache` needs to be removed too.  ```solidity     /// @notice Rebuild the operatorCache     function rebuildCache() external {         bytes32[] memory requiredOperators = resolverOperatorsRequired();         bytes32 name;         IOperatorResolver.Operator memory destination;         // The resolver must call this function whenever it updates its state         for (uint256 i = 0; i < requiredOperators.length; i++) {             name = requiredOperators[i];             // Note: can only be invoked once the resolver has all the targets needed added             destination = resolver.getOperator(name);             if (destination.implementation != address(0)) {                 operatorCache[name] = destination;             } else {                 delete operatorCache[name];             }             emit CacheUpdated(name, destination);         }     } ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L30-L47  ### 3. `addOperator()` does not call `rebuildCache()` 1. `NestedFactory.addOperator()` is called to add an operator 2. A user calls `NestedFactory(MixinOperatorResolver).create()` using that operator and fails because the operator wasn't in the `resolverOperatorsRequired()` during the last call to `rebuildCaches()`, so the operator isn't in `operatorCache` 3. `NestedFactory.rebuildCache()` is called to rebuild cache This flow is not aware that the cache is not in sync  ```solidity     /// @inheritdoc INestedFactory     function removeOperator(bytes32 operator) external override onlyOwner {         uint256 operatorsLength = operators.length;         for (uint256 i = 0; i < operatorsLength; i++) {             if (operators[i] == operator) {                 operators[i] = operators[operatorsLength - 1];                 operators.pop();                 emit OperatorRemoved(operator);                 return;             }         }         revert(\"NF: NON_EXISTENT_OPERATOR\");     } ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L110-L122  ### 4. `isResolverCached()` does not reflect the actual updated-or-not state This function, like `removeOperator()` is not able to tell that there is an operator that needs to be removed from `resolverCache`, causing the owner not to know a call to `rebuildCache()` is required to 'remove' the operator ```solidity     /// @notice Check the state of operatorCache     function isResolverCached() external view returns (bool) {         bytes32[] memory requiredOperators = resolverOperatorsRequired();         bytes32 name;         IOperatorResolver.Operator memory cacheTmp;         IOperatorResolver.Operator memory actualValue;         for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L49-L55  ## Tools Used Code inspection  ## Recommended Mitigation Steps Add calls to `rebuildCache()` in `addOperator()` and `removeOperator()`, have `INestedFactory` also track operators that have been removed with a new array, and have `isResolverCached()` also check whether this new array is empty or not.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "# 1. Prefix increaments are cheaper than postfix increaments # Vulnerability details  ## Impact The functions use prefix increaments (i ++) instead of postfix increaments (++ i). Prefix increaments are cheaper than postfix increaments.  ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L40 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L60 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L75 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L103 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L113 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L213 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L273 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L291 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L327 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L369 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L581 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L196 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L126 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L148 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L165 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L261 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L280 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L318 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L36 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L55  ``` for (uint256 i = 0; i < namesLength; i++) { ```  ## Tools Manual analysis  ## Recommended Mitigation Steps Change all prefix increaments to postfix increaments where it doesn't affects the functionality.   # 2. Unnecessary initialization of loop index variable # Vulnerability details   ## Impact For loop indices across the contract functions use explicit 0 initializations which are not required because the default value of uints is 0. Removing this explicit unnecessary initialization will save a little gas.  ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L40 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L60 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L75 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L103 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L113 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L153 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L213 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L273 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L291 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L327 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L369 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L196 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L318  ``` for (uint256 i = 0; i < namesLength; i++) { ```  ## Tools  Remix ## Recommended Mitigation Steps Remove unnecessary initialization of loop index variable  # 3. Cache array length in for loops can save gas # Vulnerability details ## Impact Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack. Caching the array length in the stack saves around 3 gas per iteration. ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L261 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/FeeSplitter.sol#L318 ``` function findShareholder(address _account) external view returns (uint256) {         for (uint256 i = 0; i < shareholders.length; i++) {             if (shareholders[i].account == _account) return i;         }         revert(\"FS: SHAREHOLDER_NOT_FOUND\");     } ``` ## Tools  Manual ## Recommended Mitigation Steps Caching len = shareholders.length and using the len instead will save gas.  # 4. Adding unchecked directive can save gas  # Vulnerability details ## Impact For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks. ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L445-L446  https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L572   ## Tools  Manual analysis ## Recommended Mitigation Steps Consider using 'unchecked' where it is safe to do so.  # 5. Avoid use of state variables in event emissions to save gas # Vulnerability details  ## Impact Where possible, use equivalent function parameters or local variables in event emits instead of state variables to prevent expensive SLOADs. Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase. ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedRecords.sol#L55 ``` function setMaxHoldingsCount(uint256 _maxHoldingsCount) external onlyOwner {         require(_maxHoldingsCount != 0, \"NRC: INVALID_MAX_HOLDINGS\");         maxHoldingsCount = _maxHoldingsCount;         emit MaxHoldingsChanges(maxHoldingsCount);     } ``` ## Tools Manual analysis ## Recommended Mitigation Steps  # 6. Long Revert Strings # Vulnerability details  ## Impact Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L444 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/operators/ZeroEx/ZeroExOperator.sol#L36 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/operators/ZeroEx/ZeroExOperator.sol#L37 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/OwnableProxyDelegation.sol#L56  ```  require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\"); ``` ## Tools Manual analysis ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "# Gas Report **Table of Contents:** - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [File: NestedRecords.sol](#file-nestedrecordssol)     - [function store()](#function-store)       - [Cache `records[_nftId].reserve`](#cache-records_nftidreserve)       - [Inclusive comparison](#inclusive-comparison)     - [function deleteAsset()](#function-deleteasset)       - [Unchecked block](#unchecked-block)   - [File: NestedFactory.sol](#file-nestedfactorysol)     - [function removeOperator()](#function-removeoperator)       - [Unchecked block](#unchecked-block-1)     - [function destroy()](#function-destroy)       - [Unchecked block (1)](#unchecked-block-1)       - [Unchecked block (2)](#unchecked-block-2)     - [function _submitInOrders()](#function-_submitinorders)       - [Unchecked block (1)](#unchecked-block-1-1)       - [Unchecked block (2)](#unchecked-block-2-1)     - [function _submitOutOrders()](#function-_submitoutorders)       - [Unchecked block (1)](#unchecked-block-1-2)       - [Unchecked block (2)](#unchecked-block-2-2)       - [Unchecked block (3)](#unchecked-block-3)       - [Unchecked block (4)](#unchecked-block-4)     - [function _safeSubmitOrder()](#function-_safesubmitorder)       - [Unchecked block](#unchecked-block-2)     - [function _transferToReserveAndStore()](#function-_transfertoreserveandstore)       - [Unchecked block](#unchecked-block-3)     - [function _transferInputTokens()](#function-_transferinputtokens)       - [Unchecked block](#unchecked-block-4)     - [function _safeTransferWithFees()](#function-_safetransferwithfees)       - [Unchecked block](#unchecked-block-5)   - [File: FeeSplitter.sol](#file-feesplittersol)     - [function updateShareholder()](#function-updateshareholder)       - [Cache `totalWeights`](#cache-totalweights)     - [function sendFees()](#function-sendfees)       - [Unchecked block](#unchecked-block-6)     - [function sendFeesWithRoyalties()](#function-sendfeeswithroyalties)       - [Unchecked block](#unchecked-block-7)       - [Cache `totalWeights`](#cache-totalweights-1)     - [function getAmountDue()](#function-getamountdue)       - [Cache `_tokenRecords.totalShares`](#cache-_tokenrecordstotalshares)     - [function _addShareholder()](#function-_addshareholder)       - [A private function used only once can get inlined](#a-private-function-used-only-once-can-get-inlined)   - [File: ZeroExOperator.sol](#file-zeroexoperatorsol)     - [function performSwap()](#function-performswap)       - [Unchecked block (1)](#unchecked-block-1-3)       - [Unchecked block (2)](#unchecked-block-2-3)   - [File: INestedFactory.sol](#file-inestedfactorysol)     - [Storage](#storage)       - [Tightly pack struct `BatchedInputOrders`](#tightly-pack-struct-batchedinputorders)       - [Tightly pack struct `BatchedOutputOrders`](#tightly-pack-struct-batchedoutputorders)       - [Only use 1 struct](#only-use-1-struct)   - [General recommendations](#general-recommendations)     - [Variables](#variables)       - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values)     - [Comparisons](#comparisons)     - [Amounts should be checked for 0 before calling a transfer](#amounts-should-be-checked-for-0-before-calling-a-transfer)     - [For-Loops](#for-loops)       - [`++i` costs less gas compared to `i++`](#i-costs-less-gas-compared-to-i)       - [Increments can be unchecked](#increments-can-be-unchecked)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)     - [Errors](#errors)       - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword - **Storage-reading optimizations** > The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). In the paragraphs below, please see the `@audit-issue` tags in the pieces of code's comments for more information about SLOADs that could be saved by caching the mentioned **storage** variables in **memory** variables.  - **Unchecking arithmetics operations that can't underflow/overflow** > Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block: https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  - **`@audit` tags** > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## File: NestedRecords.sol ### function store() ``` 111:     function store( ... 118:         if (amount != 0) { 119:             require(records[_nftId].reserve == _reserve, \"NRC: RESERVE_MISMATCH\"); //@audit records[_nftId].reserve SLOAD 1  120:             updateHoldingAmount(_nftId, _token, amount + _amount); 121:             return; 122:         } 123:         require(records[_nftId].tokens.length < maxHoldingsCount, \"NRC: TOO_MANY_TOKENS\"); //@audit should be inclusive 124:         require( 125:             _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)), //@audit records[_nftId].reserve SLOAD 1 & 2 126:             \"NRC: INVALID_RESERVE\" 127:         ); ... ``` #### Cache `records[_nftId].reserve` Caching this in memory can save around 1 SLOAD  #### Inclusive comparison By definition, `maxHoldingsCount` is the `The maximum number of holdings for an NFT record`.  Here, as an example, if `maxHoldingsCount == 1` and `records[_nftId].tokens.length == 1`, the function will revert.  I believe this check should be inclusive (like this `records[_nftId].tokens.length <= maxHoldingsCount`). This is both a Low-risk issue and a gas issue as `<` costs 3 more gas than `<=` due to the additional `ISZERO` opcode (even with the Optimizer)  ### function deleteAsset() ``` 88:     function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory { 89:         address[] storage tokens = records[_nftId].tokens; 90:         address token = tokens[_tokenIndex]; 91:  92:         require(records[_nftId].holdings[token] != 0, \"NRC: HOLDING_INACTIVE\"); 93:  94:         delete records[_nftId].holdings[token]; 95:         tokens[_tokenIndex] = tokens[tokens.length - 1]; //@audit gas: can't underflow 96:         tokens.pop(); 97:     }  ``` #### Unchecked block  If `tokens.length == 1`, all assets would be deleted. If `tokens.length == 0`, line 90 would've thrown an error and trigger a revert. As it's impossible for line 95 to underflow, it should be wrapped inside an `unchecked` block.  ## File: NestedFactory.sol ### function removeOperator() ``` 111:     function removeOperator(bytes32 operator) external override onlyOwner { 112:         uint256 operatorsLength = operators.length; 113:         for (uint256 i = 0; i < operatorsLength; i++) { 114:             if (operators[i] == operator) { 115:                 operators[i] = operators[operatorsLength - 1];  //@audit can't underflow ... ``` #### Unchecked block Line 115 can't underflow due to `operatorsLength > 0` (the for-loop wouldn't iterate otherwise). Therefore, line 115 should be wrapped inside an `unchecked` block.  ### function destroy() ``` 200:     function destroy( ... 211:         uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this)); 212:  213:         for (uint256 i = 0; i < tokensLength; i++) { 214:             uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]); 215:             reserve.withdraw(IERC20(tokens[i]), amount); 216:  217:             _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]); 218:             nestedRecords.freeHolding(_nftId, tokens[i]); 219:         } 220:  221:         // Amount calculation to send fees and tokens 222:         uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;//@audit can't underflow  223:         uint256 amountFees = amountBought / 100; // 1% Fee 224:         amountBought -= amountFees; //@audit can't underflow (equivalent to \"amountBought = amountBought - (amountBought / 100)\") ... ```  #### Unchecked block (1) As `buyTokenInitialBalance` is  `<=` to the final `_buyToken.balanceOf(address(this))`, line 222 can't underflow.  Therefore, line 222 should be wrapped inside an `unchecked` block.  #### Unchecked block (2) As `amountBought -= amountFees` is equivalent to `amountBought = amountBought - (amountBought / 100)`, the result can't underflow. Therefore, line 223 should be wrapped inside an `unchecked` block.  ### function _submitInOrders() ``` 311:     function _submitInOrders( ... 337:         require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\"); 338:  339:         uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent; //@audit can't underflow 340:         if (underSpentAmount != 0) { 341:             tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount); 342:         } 343:  344:         // If input is from the reserve, update the records 345:         if (_fromReserve) { 346:             _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount); //@audit can't underflow 347:         } ... ```  #### Unchecked block (1) Line 339 can't underflow due to the require statement line 337.  Therefore, line 339 should be wrapped inside an `unchecked` block.  #### Unchecked block (2) As `underSpentAmount = _inputTokenAmount - feesAmount - amountSpent` (line 339): `_inputTokenAmount >= underSpentAmount`. Therefore, line 346 can't underflow and should be wrapped inside an `unchecked` block.  ### function _submitOutOrders() ``` 357:     function _submitOutOrders( ... 365:         amountBought = _batchedOrders.outputToken.balanceOf(address(this)); ... 385:             require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\"); 386:  387:             uint256 underSpentAmount = _inputTokenAmount - amountSpent; //@audit can't underflow 388:             if (underSpentAmount != 0) { 389:                 _inputToken.safeTransfer(address(reserve), underSpentAmount); 390:             } 391:  392:             _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount); //@audit can't underflow 393:         } 394:  395:         amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought; //@audit can't underflow 396:         feesAmount = amountBought / 100; // 1% Fee //@audit HIGH free stuff under 100 ? Check on Remix. That's one of Secureum's audit findings 397:  398:         if (_toReserve) { 399:             _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);//@audit can't underflow 400:         } 401:     } ```  #### Unchecked block (1) Line 387 can't underflow due to the require statement line 385.  Therefore, line 387 should be wrapped inside an `unchecked` block.  #### Unchecked block (2) As `underSpentAmount = _inputTokenAmount - amountSpent`: `_inputTokenAmount >= underSpentAmount`. Therefore, line 392 can't underflow and should be wrapped inside an `unchecked` block.  #### Unchecked block (3) As the initial `_batchedOrders.outputToken.balanceOf(address(this))` line 365 is  `<=` to the final `_batchedOrders.outputToken.balanceOf(address(this))` line 395: line 395 can't underflow.  Therefore, line 395 should be wrapped inside an `unchecked` block.  #### Unchecked block (4) As `amountBought - feesAmount` is equivalent to `amountBought - (amountBought / 100)`, the result can't underflow. Therefore, line 399 should be wrapped inside an `unchecked` block.  ### function _safeSubmitOrder() ``` 435:     function _safeSubmitOrder( ... 445:             if (_amountToSpend > amounts[1]) { 446:                 IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]); //@audit should be unchecked (see L445) 447:             } ... ```  #### Unchecked block Line 446 can't underflow due to the require statement line 445.  Therefore, line 446 should be wrapped inside an `unchecked` block.  ### function _transferToReserveAndStore() ``` 458:     function _transferToReserveAndStore( 459:         IERC20 _token, 460:         uint256 _amount, 461:         uint256 _nftId 462:     ) private { 463:         address reserveAddr = address(reserve); 464:         uint256 balanceReserveBefore = _token.balanceOf(reserveAddr); 465:  466:         // Send output to reserve 467:         _token.safeTransfer(reserveAddr, _amount); 468:  469:         uint256 balanceReserveAfter = _token.balanceOf(reserveAddr); 470:  471:         nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);//@audit can't underflow 472:     } ```  #### Unchecked block As the initial `_token.balanceOf(reserveAddr)` is  `<=` to the final `_token.balanceOf(reserveAddr)`: line 471 can't underflow.  Therefore, line 471 should be wrapped inside an `unchecked` block.  ### function _transferInputTokens() ``` 482:     function _transferInputTokens( ... 494:         uint256 balanceBefore = _inputToken.balanceOf(address(this)); 495:         if (_fromReserve) { 496:             require( 497:                 nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount, 498:                 \"NF: INSUFFICIENT_AMOUNT_IN\" 499:             ); 500:             // Get input from reserve 501:             reserve.withdraw(IERC20(_inputToken), _inputTokenAmount); 502:         } else { 503:             _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount); 504:         } 505:         return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore); //@audit can't underflow 506:     } ```  #### Unchecked block As the initial `_inputToken.balanceOf(address(this))` is  `<=` to the final `_inputToken.balanceOf(address(this))`: line 505 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  ### function _safeTransferWithFees() ``` 566:     function _safeTransferWithFees( 567:         IERC20 _token, 568:         uint256 _amount, 569:         address _dest, 570:         uint256 _nftId 571:     ) private { 572:         uint256 feeAmount = _amount / 100; // 1% Fee 573:         _transferFeeWithRoyalty(feeAmount, _token, _nftId); 574:         _token.safeTransfer(_dest, _amount - feeAmount);//@audit can't underflow 575:     } ```  #### Unchecked block As `_amount - feeAmount` is equivalent to `_amount - (_amount / 100)`, the result can't underflow. Therefore, line 574 should be wrapped inside an `unchecked` block.  ## File: FeeSplitter.sol  ### function updateShareholder() ```) 134:     function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner { 135:         require(_accountIndex < shareholders.length, \"FS: INVALID_ACCOUNT_INDEX\"); 136:         totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight; //@audit cache 137:         require(totalWeights != 0, \"FS: TOTAL_WEIGHTS_ZERO\"); 138:         shareholders[_accountIndex].weight = _weight; 139:         emit ShareholderUpdated(shareholders[_accountIndex].account, _weight); 140:     } ``` #### Cache `totalWeights` It's possible to save around 1 SLOAD by caching `totalWeights` in memory, like this: ```) 134:     function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner { 135:         require(_accountIndex < shareholders.length, \"FS: INVALID_ACCOUNT_INDEX\"); 136:         uint256 _totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;  //@audit +MSTORE 137:         require(_totalWeights != 0, \"FS: TOTAL_WEIGHTS_ZERO\"); //@audit +MLOAD -SLOAD 138:         totalWeights = _totalWeights; //@audit +MLOAD 139:         shareholders[_accountIndex].weight = _weight; 140:         emit ShareholderUpdated(shareholders[_accountIndex].account, _weight); 141:     } ```  ### function sendFees() ``` 175:     function sendFees(IERC20 _token, uint256 _amount) external nonReentrant { 176:         uint256 weights; 177:         unchecked { 178:             weights = totalWeights - royaltiesWeight; 179:         } 180:  181:         uint256 balanceBeforeTransfer = _token.balanceOf(address(this)); 182:         _token.safeTransferFrom(_msgSender(), address(this), _amount);  183:  184:         _sendFees(_token, _token.balanceOf(address(this)) - balanceBeforeTransfer, weights); //@audit can't underflow (see L181 and L182) 185:     } ```  #### Unchecked block As the initial `_token.balanceOf(address(this))` is  `<=` to the final `_token.balanceOf(address(this))`: line 184 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  ### function sendFeesWithRoyalties() ``` 191:     function sendFeesWithRoyalties( ... 198:         uint256 balanceBeforeTransfer = _token.balanceOf(address(this)); 199:         _token.safeTransferFrom(_msgSender(), address(this), _amount); 200:         uint256 amountReceived = _token.balanceOf(address(this)) - balanceBeforeTransfer;  //@audit can't underflow 201:  202:         uint256 royaltiesAmount = _computeShareCount(amountReceived, royaltiesWeight, totalWeights); //@audit totalWeights SLOAD 1 203:  204:         _sendFees(_token, amountReceived, totalWeights);//@audit totalWeights SLOAD 2 ... ```  #### Unchecked block As the initial `_token.balanceOf(address(this))` is  `<=` to the final `_token.balanceOf(address(this))`: line 200 can't underflow.  Therefore, it should be wrapped inside an `unchecked` block.  #### Cache `totalWeights`  Caching this in memory can save around 1 SLOAD  ### function getAmountDue() ``` 216:     function getAmountDue(address _account, IERC20 _token) public view returns (uint256) { 217:         TokenRecords storage _tokenRecords = tokenRecords[address(_token)]; 218:         if (_tokenRecords.totalShares == 0) return 0;//@audit _tokenRecords.totalShares SLOAD 1 219:  220:         uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this)); 221:         return 222:             (totalReceived * _tokenRecords.shares[_account]) / 223:             _tokenRecords.totalShares - //@audit _tokenRecords.totalShares SLOAD 2 224:             _tokenRecords.released[_account]; 225:     } ```  #### Cache `_tokenRecords.totalShares`  Caching this in memory can save around 1 SLOAD  ### function _addShareholder() #### A private function used only once can get inlined  As this private function is only used once line 127 in function setShareholders(), it can get inlined to save some gas.  ## File: ZeroExOperator.sol ### function performSwap() ``` 21:     function performSwap( ... 28:         uint256 buyBalanceBeforePurchase = buyToken.balanceOf(address(this)); 29:         uint256 sellBalanceBeforePurchase = sellToken.balanceOf(address(this)); 30:  31:         bool success = ExchangeHelpers.fillQuote(sellToken, operatorStorage.swapTarget(), swapCallData); 32:         require(success, \"ZEO: SWAP_FAILED\"); 33:  34:         uint256 amountBought = buyToken.balanceOf(address(this)) - buyBalanceBeforePurchase; //@audit can't underflow (see L28 and L31) 35:         uint256 amountSold = sellBalanceBeforePurchase - sellToken.balanceOf(address(this));//@audit can't underflow (see L29 and L31) 36:         require(amountBought != 0, \"ZeroExOperator::performSwap: amountBought cant be zero\"); //@audit-info move up 1 ? Will certainly cost more gas on happy path while saving some on sad path. Not a good trade-off 37:         require(amountSold != 0, \"ZeroExOperator::performSwap: amountSold cant be zero\"); ... ```  #### Unchecked block (1) As the initial `buyToken.balanc"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/24", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas fee improvement https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L100 there is no need to use extra variable operatorsCache to check if operator exists.   https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L111 In the removeOperator function, no need for this line uint256 operatorsLength = operators.length; Use operators.length directly in the loop  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L177 getAssetTokensLength() function is not called from the contract. If not needed it can removed or should be made external  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L191 Function tokenHoldings() is not called from within the contract. If not needed it can be removed or should be made external  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedAsset.sol#L52 Function originalOwner() is not called from within the contract. If not needed it can be removed or should be made external  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/OperatorResolver.sol#L16 Add empty string check for this function  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/OperatorResolver.sol#L57 If bith names.length and operatorsToImport.length == 0, this check passes. Consider adding empty check to both structures  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L204 Nested _addShare _sendFees calls _addShare But in sendFeesWithRoyalties(), _addShare is called again after _sendFees. This can lead to nested executed. Please consider refactoring this code."}, {"title": "Wrong logic around `areOperatorsImported`", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L42-L43   # Vulnerability details  ## Impact The logic related to the `areOperatorsImported` method is incorrect and can cause an operator not to be updated because the owner thinks it is already updated, and a vulnerable or defective one can be used.  ## Proof of Concept The `operators` mapping is made up of a key `bytes32 name` and a value made up of two values: `implementation` and `selector`, both of which identify the contract and function to be called when an operator is invoked.  The `areOperatorsImported` method tries to check if the operators to check already exist, however, the check is not done correctly, since && is used instead of ||.  If the operator with name `A` and value `{implementation=0x27f8d03b3a2196956ed754badc28d73be8830a6e,selector=\"performSwapVulnerable\"}` exists, and the owner try to check if the operator with name `A` and value `{implementation=0x27f8d03b3a2196956ed754badc28d73be8830a6e,selector=\"performSwapFixed\"}` exists, that function will return `true`, and the owner may decide not to import it , producing unexpected errors. Because operators manage the tokens, this error can produce a token lost.  ## Recommended Mitigation Steps Change && by ||    "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/9", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "## Missing token whitelisting puts stakeholders on risk  Contract: https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L146  1. Attacker can call sendFees with a malicious token contract   2. This increases the share balance of malicious token for each stake holder  3. When stakeholders tries to withdraw there share of malicious token using releaseTokens, malicious contract will be called and code written by attacker will be executed (asking for unauthorized approvals, wasting Gas etc)  ## sendFees & sendFeesWithRoyalties not handling ETH token  Contract: https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L175  1. Both sendFees & sendFeesWithRoyalties are not considering if the input _token is ETH as done in releaseTokens  ## Incorrect return message  Contract: https://github.com/code-423n4/2022-02-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L101  1. The require statement incorrectly mentions INVALID_OUTPUT_TOKEN when it should be INVALID_INPUT_TOKEN"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "## https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol (#L191, #L149, #L166)  1. In sendFeesWithRoyalties, releaseTokens, releaseTokensNoETH function, add check amount!=0  ``` require(amount!=0, \"Incorrect amount\"); ```  ## https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedRecords.sol#L76  1. In updateHoldingAmount function, under the while loop, use return instead of break  ``` if (tokens[tokenIndex] == _token) {                     ...                     return;                 } ```  ## https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L317  1.  No need to check require(batchLength != 0, \"NF: INVALID_ORDERS\"); as this is already checked in all the calling functions like create, _processInputOrders  ## https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L445  1. The condition if (_amountToSpend > amounts[1])  is not required as the parent condition is already checking for require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\");"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Title: State variables that could be set immutable Severity: GAS  In the following files there are state variables that could be set immutable to save gas.           operator in TestableOperatorCaller.sol         resolver in MixinOperatorResolver.sol         operatorStorage in ZeroExOperator.sol    Title: Unused state variables Severity: GAS  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           TestableMixingOperatorResolver.sol, addressesToCache    Title: Unused declared local variables Severity: GAS  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           TestableOperatorCaller.sol, performSwap, data    Title: Unnecessary array boundaries check when loading an array element twice Severity: GAS       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:               NestedFactory.sol._processOutputOrders - double load of _batchedOrders[i]         NestedFactory.sol._processInputOrders - double load of _batchedOrders[i]    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           FeeSplitter.sol, _tokens, 148         MixinOperatorResolver.sol, requiredOperators, 55         NestedFactory.sol, operatorsCache, 103         NestedFactory.sol, orders._batchedOrders, 369         FeeSplitter.sol, shareholders, 261         FeeSplitter.sol, shareholdersCache, 280         FeeSplitter.sol, shareholders, 318         OperatorResolver.sol, names, 60         FeeSplitter.sol, _tokens, 165         OperatorResolver.sol, destinations, 75         MixinOperatorResolver.sol, requiredOperators, 36         NestedFactory.sol, _batchedOrders, 581    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: NestedFactory.sol, i, 153         change to prefix increment and unchecked: MixinOperatorResolver.sol, i, 55         change to prefix increment and unchecked: NestedFactory.sol, i, 103         change to prefix increment and unchecked: NestedFactory.sol, i, 327         change to prefix increment and unchecked: NestedRecords.sol, i, 196         change to prefix increment and unchecked: FeeSplitter.sol, i, 148         change to prefix increment and unchecked: FeeSplitter.sol, i, 318         change to prefix increment and unchecked: OperatorResolver.sol, i, 40         change to prefix increment and unchecked: OperatorResolver.sol, i, 60         change to prefix increment and unchecked: FeeSplitter.sol, i, 280         change to prefix increment and unchecked: FeeSplitter.sol, i, 165         change to prefix increment and unchecked: FeeSplitter.sol, i, 261         change to prefix increment and unchecked: MixinOperatorResolver.sol, i, 36         change to prefix increment and unchecked: NestedFactory.sol, i, 273         change to prefix increment and unchecked: NestedFactory.sol, i, 213         change to prefix increment and unchecked: NestedFactory.sol, i, 369         change to prefix increment and unchecked: NestedFactory.sol, i, 581         change to prefix increment and unchecked: OperatorResolver.sol, i, 75         change to prefix increment and unchecked: FeeSplitter.sol, i, 126         change to prefix increment and unchecked: NestedFactory.sol, i, 113         change to prefix increment and unchecked: NestedFactory.sol, i, 291    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          MixinOperatorResolver.sol, 36         NestedFactory.sol, 153         OperatorResolver.sol, 75         NestedFactory.sol, 273         OperatorResolver.sol, 60         NestedFactory.sol, 213         FeeSplitter.sol, 318         MixinOperatorResolver.sol, 55         FeeSplitter.sol, 261         NestedFactory.sol, 291         NestedFactory.sol, 113         OperatorResolver.sol, 40         NestedFactory.sol, 369         NestedFactory.sol, 581         FeeSplitter.sol, 126         FeeSplitter.sol, 280         NestedFactory.sol, 103         FeeSplitter.sol, 165         NestedFactory.sol, 327         FeeSplitter.sol, 148         NestedRecords.sol, 196    Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          MixinOperatorResolver.sol, callOperator         NestedAsset.sol, _setTokenURI         ExchangeHelpers.sol, setMaxAllowance         ExchangeHelpers.sol, fillQuote         MixinOperatorResolver.sol, requireAndGetAddress    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           DeflationaryMockERC20.sol, transferFrom         TestableMixingOperatorResolver.sol, resolverOperatorsRequired         NestedRecords.sol, tokenHoldings         NestedAsset.sol, originalOwner         NestedRecords.sol, getAssetTokensLength         NestedRecords.sol, freeHolding         NestedAsset.sol, tokenURI         OwnableProxyDelegation.sol, renounceOwnership         OwnableProxyDelegation.sol, owner         OwnableProxyDelegation.sol, transferOwnership    Title: Unnecessary payable Severity: GAS  The following functions are payable but msg.value isn't used - therefore the function payable state modifier isn't necessary. Payable functions are more gas expensive than others, and it's danger the users if they send ETH by mistake.           ZeroExOperator.sol, performSwap is payable but doesn't use msg.value         FlatOperator.sol, transfer is payable but doesn't use msg.value    Title: Rearrange state variables Severity: GAS  You can change the order of the storage variables to decrease memory uses.  In OwnableProxyDelegation.sol,rearranging the storage fields can optimize to: 2 slots from: 3 slots. The new order of types (you choose the actual variables):         1. bytes32         2. address         3. bool     Title: Short the following require messages Severity: GAS  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: OwnableProxyDelegation.sol, In line 56, Require message length to shorten: 38, The message: Ownable: new owner is the zero address    Title: Unused imports Severity: GAS   In the following files there are contract imports that aren't used Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore)          IFlatOperator.sol, line 3, import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";         FlatOperator.sol, line 3, import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";         INestedFactory.sol, line 4, import \"../NestedReserve.sol\";    Title: Unused inheritance Severity: GAS       Some of your contract inherent contracts but aren't use them at all.     We recommend not to inherent those contracts.              NestedAsset.sol; the inherited contracts OwnableFactoryHandler not used         NestedReserve.sol; the inherited contracts OwnableFactoryHandler not used         NestedRecords.sol; the inherited contracts OwnableFactoryHandler not used    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           NestedFactory.sol, 489: change 'balance > 0' to 'balance != 0'    Title: Unnecessary constructor Severity: GAS  The following constructors are empty.      (A similar issue https://github.com/code-423n4/2021-11-fei-findings/issues/12)              TestableMixingOperatorResolver.sol.constructor         NestedAsset.sol.constructor    Title: Unnecessary functions Severity: GAS       The following functions are not used at all. Therefore you can remove them to save deployment gas and improve code clearness.                   MixinOperatorResolver.sol, callOperator         ExchangeHelpers.sol, fillQuote    Title: Unnecessary cast Severity: Gas                IERC20 NestedFactory.sol._transferInputTokens - unnecessary casting IERC20(_inputToken)    Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               NestedAsset.backfillTokenURI (_metadataURI)         ExchangeHelpers.fillQuote (_swapCallData)         NestedAsset._setTokenURI (_metadataURI)         DeflationaryMockERC20.constructor (_name)         NestedAsset.mintWithMetadata (_metadataURI)         MockERC20.constructor (_symbol)         DeflationaryMockERC20.constructor (_symbol)         MockERC20.constructor (_name)    Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               FeeSplitter.sol, _computeShareCount, { return (_amount * _weight) / _totalWeights; }    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               FeeSplitter.sol, _addShareholder         MixinOperatorResolver.sol, requireAndGetAddress         ExchangeHelpers.sol, setMaxAllowance    Title: Check if amount is not zero to save gas Severity: GAS  The following functions could skip other steps if the amount is 0. (A similar issue: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82)           DeflationaryMockERC20.sol, transferFrom         FeeSplitter.sol, sendFees  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/4", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": " Title: Does not validate the input fee parameter Severity: Low Risk  Some fee parameters of functions are not checked for invalid values. Validate the parameters:                  NestedFactory.constructor (_feeSplitter)         NestedFactory.setFeeSplitter (_feeSplitter)      Title: Solidity compiler versions mismatch Severity: Low Risk  The project is compiled with different versions of solidity, which is not recommended due ti  undefined behaviors as a result of it.             Title: Init function calls an owner function Severity: Low Risk       Init function that calls an onlyOwner function is problematic since sometimes the initializer or the one applies      the constructor isn't necessary the owner of the protocol. And if a contract does it then you might get a situation     that all the onlyOwner functions are blocked since only the factory contract may use them but isn't necessary      support it.                    FeeSplitter.sol.constructor - calls setRoyaltiesWeight         FeeSplitter.sol.constructor - calls setShareholders    Title: Not verified owner Severity: Low Risk       owner param should be validated to make sure the owner address is not address(0).     Otherwise if not given the right input all only owner accessible functions will be unaccessible.                   OwnableProxyDelegation.sol.transferOwnership newOwner         OwnableProxyDelegation.sol.initialize ownerAddr         NestedAsset.sol.burn _owner         NestedAsset.sol.mint _owner         NestedAsset.sol.backfillTokenURI _owner         NestedAsset.sol.mintWithMetadata _owner         OwnableProxyDelegation.sol._setOwner newOwner    Title: Two Steps Verification before Transferring Ownership Severity: Low Risk  The following contracts have a function that allows them an admin to change it to a different address. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked. It is important to have two steps admin change where the first is announcing a pending new admin and the new address should then claim its ownership.  A similar issue was reported in a previous contest and was assigned a severity of medium: [code-423n4/2021-06-realitycards-findings#105](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105)           OwnableProxyDelegation.sol    Title: Missing non reentrancy modifier Severity: Low Risk  The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..          FeeSplitter.sol, updateShareholder is missing a reentrancy modifier         NestedFactory.sol, receive is missing a reentrancy modifier         FeeSplitter.sol, receive is missing a reentrancy modifier         NestedFactory.sol, removeOperator is missing a reentrancy modifier         NestedFactory.sol, addOperator is missing a reentrancy modifier         NestedFactory.sol, setFeeSplitter is missing a reentrancy modifier         FeeSplitter.sol, setShareholders is missing a reentrancy modifier         NestedFactory.sol, unlockTokens is missing a reentrancy modifier         FeeSplitter.sol, setRoyaltiesWeight is missing a reentrancy modifier         NestedFactory.sol, updateLockTimestamp is missing a reentrancy modifier    Title: In the following public update functions no value is returned Severity: Low Risk  In the following functions no value is returned, due to which by default value of return will be 0.  We assumed that after the update you return the latest new value.  (similar issue here: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/85).           ZeroExStorage.sol, updatesSwapTarget         NestedRecords.sol, updateHoldingAmount         NestedFactory.sol, updateLockTimestamp         NestedRecords.sol, updateLockTimestamp         FeeSplitter.sol, updateShareholder    Title: Never used parameters Severity: Low Risk  Those are functions and parameters pairs that the function doesn't use the parameter. In case those functions are external/public this is even worst since the user is required to put value that never used and can misslead him and waste its time.           MockERC20.sol: function constructor parameter _symbol isn't used. (constructor is default)         NestedAsset.sol: function backfillTokenURI parameter _owner isn't used. (backfillTokenURI is external)         TestableMixingOperatorResolver.sol: function constructor parameter _resolver isn't used. (constructor is default)         DeflationaryMockERC20.sol: function constructor parameter _symbol isn't used. (constructor is default)         DeflationaryMockERC20.sol: function constructor parameter _name isn't used. (constructor is default)         TestableOperatorCaller.sol: function performSwap parameter own isn't used. (performSwap is external)         MockERC20.sol: function constructor parameter _name isn't used. (constructor is default)    Title: Missing commenting Severity: Low Risk       The following functions are missing commenting as describe below:              FeeSplitter.sol, _addShareholder (private), parameters _account, _weight not commented         NestedRecords.sol, getAssetTokens (public), @return is missing         FeeSplitter.sol, _releaseToken (private), @return is missing         FeeSplitter.sol, _computeShareCount (private), parameters _amount, _weight, _totalWeights not commented         NestedRecords.sol, getAssetHolding (public), @return is missing         FeeSplitter.sol, _releaseToken (private), parameters _account, _token not commented         FeeSplitter.sol, _computeShareCount (private), @return is missing    Title: Anyone can withdraw others Severity: Low Risk  Anyone can withdraw users shares. Although we think that they are sent to the right address, it is still         1) not the desired behavior         2) can be dangerous if the receiver is a smart contract         3) the receiver may not know someone withdraw him                   NestedFactory.withdraw         NestedReserve.withdraw   Title: Not verified input Severity: Low Risk  external / public functions parameters should be validated to make sure the address is not 0. Otherwise if not given the right input it can mistakenly lead to loss of user funds.              FeeSplitter.sol._addShares _token         FeeSplitter.sol._addShares _account         DeflationaryMockERC20.sol.transferFrom recipient         OwnableFactoryHandler.sol.removeFactory _factory  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/123", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": " 1. Floating pragma is used in all the contracts  As different compiler versions have critical behavior specifics if the contracts get accidentally deployed using another compiler version compared to the one they were tested with, various types of undesired behavior can be introduced  ## Proof of Concept  `pragma solidity ^0.8.0` is used in all the system contracts, for example:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L2  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L2  ## Recommended Mitigation Steps  Consider fixing the version to 0.8.x across all the codebase, for example set x to 10   2. Most of events in BribeVault, TokemakBribe and ThecosomataETH aren't indexed  ## Impact  Filtering on not indexed events is disabled, which makes it harder to programmatically use and analyze the system  ## Proof of Concept  The following events are not indexed:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L37-57  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L42-43  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L44-48  ## Recommended Mitigation Steps  Consider making all events ids and addresses indexed to improve their usability   3. bytes32.length check is redundant and doesn't rule zero values out  ## Impact  bytes32.length do not control for bogus values as the bytes32 length is fixed to 32. This way, for example, depositBribe can be successfully called with any identifiers, for example `0x0000000000000000000000000000000000000000000000000000000000000000` id will not be reverted  ## Proof of Concept  bytes32 is a fixed size array, which length will always be 32, but it is checked for positive length anyway in BribeVault deposit functions:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L171-172  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L218-219  ## Recommended Mitigation Steps  If non-zero check is desired, `!= 0` can suffice (will revert on `0x0000000000000000000000000000000000000000000000000000000000000000`):  Now: ``` require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\"); ```  To be: ``` require(bribeIdentifier != 0, \"Invalid bribeIdentifier\"); ``` "}, {"title": "Users Can Frontrun Calls to `updateRewardsMetadata()` And Claim Tokens Twice", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/118", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97-L119 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L209   # Vulnerability details  ## Impact  The `updateRewardsMetadata()` function is called by the `BribeVault` contract by the admin role. The function will take a list of distributions which are used to update the associated reward metadata. It is expected that the merkle root will be updated to correctly identify which claimers have already claimed tokens.   `reward.updateCount` is incremented to reset the claimed tracker, allowing users that may have previously claimed, to claim their updated reward. However, there is potential for mis-use if users frontrun calls to `updateRewardsMetadata()` and claim their reward after the new merkle root has been calculated and updated by the admin role. This may allow the claimer to double claim their rewards or lead to a loss in rewards if the reward metadata completely replaces the previous list of claimers.  ## Proof of Concept  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97-L119 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L209  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing a delay where users cannot claim rewards before a call to `updateRewardsMetadata()` is made. This should ensure the admin role can construct a merkle tree based on the most up-to-date and correct data.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/117", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "## Missing Doc Comments in function `getBrige()`   The parameter `round` is missing in doc comments for the function  `getBrige()` at `TokemakBribe.sol`  Also consider add doc comments at  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol  Doc comments will increase the readability of the code and will avoid other more high risk issues.    For example in this contest I sent a medium severity issue related to the same parameter.  ## Poc  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L188-L204          @notice Get bribe from BribeVault         @param  proposal            address  Proposal         @param  token               address  Token   @audit-issue   need to add round parameter and all thecosomata eth         @return bribeToken          address  Token address         @return bribeAmount         address  Token address      */     function getBribe(         address proposal,         uint256 round,         address token     ) external view returns (address bribeToken, uint256 bribeAmount) {         return             IBribeVault(bribeVault).getBribe(                 generateBribeVaultIdentifier(proposal, round, token)             );     }   # Similar issues  https://github.com/code-423n4/2021-09-swivel-findings/issues/71"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/111", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "Low :  Title : proposal can be frontrun to support malicious token  Impact : When an authorized user set a proposal, a malicious user might call depositBribeERC20() right after the set proposal transaction is finish, since the token is not whitelisted, the malicious user might provide a malicious token, a token that will revert on all interaction with this contract, this can cause a dos on the proposal that just being set.  POC : https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L125"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/103", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "## Redacted Cartel QA Report  Unless otherwise noted, manual auditing and testing were done using Visual Studio Code and Remix. The audit was done from February 15-17, 2022 by ye0lde through code4rena.  Overall, I found the code to be clear to follow and understand. A test suite was provided. Including more tests that tackle edge scenarios and providing coverage and gas reports by default would be useful.  - [Findings](#findings)   - [L-1 - Restrict funds receivable to be only from `BribeVault` (RewardDistributor.sol)](#l-1---restrict-funds-receivable-to-be-only-from-bribevault-rewarddistributorsol)   - [L-2 - Unchecked ERC20 transfer calls](#l-2---unchecked-erc20-transfer-calls)   - [NC-1 - Incorrect return value description for `getBribe` (TokemakBribe.sol)](#nc-1---incorrect-return-value-description-for-getbribe-tokemakbribesol)  ## Findings    ### L-1 - Restrict funds receivable to be only from `BribeVault` (RewardDistributor.sol)  #### Impact Native fund transfers into the `RewardDistributor` contract are only expected from the `BribeVault` contract. It would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  #### Proof of Concept The `receive` function is here: https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L58-L59  ``` // Enables BribeVault to transfer native tokens receive() external payable {} ```  #### Recommended Mitigation Steps Modify the receive() function to only accept transfers from the `BribeVault` contract.  ``` receive() external payable {       require(msg.sender == address(bribeVault), \"Not BribeVault...\"); } ``` ---  ### L-2 - Unchecked ERC20 transfer calls   #### Impact ERC20 transfer and transferFrom calls normally return true on a successful transfer.  If transfers are done with ERC20 token which does not comply with the EIP-20 standard it might return false on a failed transaction rather than revert. In this case, it would count as a valid transaction even though it is not.   #### Proof of Concept Unchecked transfer calls are here: https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L296-L297 https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L337 https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L146 https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L164  #### Recommended Mitigation Steps Consider using OpenZeppelin's library with safe versions of transfer functions as used in other areas of the code.  ---  ### NC-1 - Incorrect return value description for `getBribe` (TokemakBribe.sol)  #### Impact Code clarity  #### Proof of Concept The incorrect comment which appears to be copied from line #192 is here: https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L193  #### Recommended Mitigation Steps Correct the comment/description.  ---"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/99", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "##GasFindingsCartel 1-- -using storage to declare `b` struct https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L152 `b` just called twice in the `gotBribe`(struct data type consume more gas when it chaced and it depend on the size of the struct). Read from storage instead of caching it cost less gas ``` Bribe storage b = bribes[bribeIdentifier]; ```  2-- -using at least pragma 0.8.4 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L2 The advantages of versions 0.8.4 over <0.8.0 are:     1. Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls.     2. Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.     3. Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.  3-- -using && cost more gas https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L262-L266 instead of using &&, using double require to validate can save gas ``` require(             distributions.length == amounts.length,             \"Distributions, amounts, and fees must contain the same # of elements\"         ); require(                 distributions.length == fees.length,             \"Distributions, amounts, and fees must contain the same # of elements\"         ); ``` 4-- -using ++var for increment operation https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L109 using: ```       ++reward.updateCount; ```    is better method to do increment operation for gas opt  5-- -caching `Reward` to memory cost more gas https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L134 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L200 `reward` is merely called once at the `isRewardClaimed()` and twice at `_setClaimed()`. Its gas saving by just read it directly to the storage. ```         Reward storage reward = rewards[_identifier]; ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/97", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "## Summary: During the code assessment, we found multiple issues related to unchecked transfer and no handing of return values. Many functions call like \"transfer,\" \"deposit,\" \"approve,\" etc., returns some value after the function call. Handling these calls is important to prevent unexpected outcomes. Apart from that, we found multiple functions which were missing zero address checks. It is advised to add a zero address check at all possible functions setting an address. In solidity, any error caused to set the value to default, and for an address variable, the default value is zero address. Hence any fund or privilege gets pointed to zero address, it will be unrecoverable.  The contract was found to be using floating pragma, which allows the contract to be compiled to multiple versions and hence can cause inconsistencies or errors on different versions. We also noticed the uses of large number literals. Although it is not a security issue but enhances readability and reduces the chance of errors or missing digits. We also noticed missing events in many critical functions. Events are important for logging purposes. Hence it is recommended to add events and indexed events at all possible function calls for better logging. Lastly, we also noticed that the fee value, which is set by an admin, can be set to zero due lack of proper input validation.    ## Low Severity findings:  ## QA - 1  ### Title:  Unchecked return value in transfer  ### Description: The return value of the token transfers is not checked or validated at all in the functions shown below. This may lead to issues if there's a critical contract logic happening below the transfer that affects or manipulates the number of ether or tokens. Therefore, if the return value is not checked, the adversaries will be able to call those functions without actually transferring any ether and manipulating the token balance.  ### PoC: Transfer: Go to the below lines of code and we will notice that transfer  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L297 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L146 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L164    ### Suggested Fix: Consider the use of safeTransfer instead of transfer that auto asserts and handles in case of transfer failure.     ## QA - 2  ### Title:  Unused return in approve call  ### Description: The contract was found to be making an external call (approve). The function which is called is returning some value which is never used. This may lead to discrepancies and improper assumptions in the calling function.  ### PoC: - Go to the lines below and we will notice that the approve function's return value is not used for any further validation or check. https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L68 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L69  ### Suggested Fix: It is recommended to make use of the return values coming from the external function that is called to make sure that the calculations following the external call are correct.    ## QA - 3  ### Title:  Use of Floating Pragma Version  ### Description: The contract was found to be using a floating pragma which is not considered safe as it can be compiled with all the versions described.  ### PoC: Pragma version^0.8.0 (https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L2)  Pragma version^0.8.0 (https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L2) Pragma version^0.8.0 (https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L2)  Pragma version^0.8.0 (https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L2)   ### Suggested Fix: Use strict pragma version like  Pragma version 0.8.0  ## QA - 4  ### Title:  Missing input validation in setFee function   ### Description: The function `setFee` does not check if the fee value is set to zero.   ## Impact An admin can set fee value to zero by mistake, and it can cause free trades and loss to the organization.   ### PoC: - Notice the function below https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L108-L113 - The `setFee` function just checks if the fee is less than feeDivisor but does not check if the fee is zero.   ### Suggested Fix: Check if the fee is being set to zero.    ## Non-critical findings  ## QA - 5  ### Title:  Use of Large Number Literals  ### Description: Integer literals are formed from a sequence of digits in the range 0-9. They are interpreted as decimals. The use of very large numbers with too many digits was detected in the code that could have been optimized using a different notation also supported by Solidity.   ## Impact  Literals with many digits are difficult to read and review. This may also introduce errors in the future if one of the zeroes is omitted while doing code modifications.   ### PoC: - Go to https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L26 We will notice a large literal  `uint256 public constant feeDivisor = 1000000;` where 1000000 can be represnted as 10e6  ### Suggested Fix: Scientific notation in the form of `2e10` is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal `MeE` is equivalent to `M * 10**E`. Examples include `2e10`, `2e10`, `2e-10`, `2.5e1`.  Reference: [https://docs.soliditylang.org/en/latest/types.html#rational-and-integer-literals](https://docs.soliditylang.org/en/latest/types.html#rational-and-integer-literals)  ## QA - 6  ### Title:  Multiple missing events in critical functions  ### Description: Events are inheritable members of contracts. When you call them, they cause the arguments to be stored in the transaction's log, a special data structure in the blockchain. These logs are associated with the address of the contract, which can then be used by developers and auditors to keep track of the transactions.   The contract was found to be missing these events on certain critical functions, which would make it difficult or impossible to track these transactions off-chain.  ## Impact  Events are used to track the transactions off-chain, and missing these events on critical functions makes it difficult to audit these logs if they're needed at a later stage.    ### PoC: The below functions are missing events. - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L76-L80 The function `setSlippage` is called by an admin and hence should have an event log regarding the change is slippage value.  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L158-L165 The `withdraw` function is called by an admin to withdraw funds and hence should have an event log.   - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L108-L110 The function `setRound` sets a new voting round by admins and hence should have an event log.   ### Suggested Fix: Consider emitting events for the functions mentioned above. It is also recommended to have the addresses indexed.   ## QA - 7  ### Title:  Multiple functions Lacking Zero address checks  ### Description: Address type parameters should include a zero-address check; otherwise, contract functionality may become inaccessible, or tokens burned forever.  ## Impact Tokens may become inaccessible or burnt forever without a zero-address check.  ### PoC: Below is the list of functions lacking zero address checks - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L212-L251 Function `depositBribeERC20` has address `proposal` that is missing zero address checks  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L257-L290 Function `depositBribe` has address input `proposal`, which is lacking zero address checks.    ### Suggested Fix: Address zero address check to all the missing places.      "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "- [S]: Suggested optimation, save a decent amount of gas without compromising readability; - [M]: Minor optimation, the amount of gas saved is minor, change when you see fit; - [N]: Non-preferred, the amount of gas saved is at cost of readability, only apply when gas saving is a top priority.  ## [M] Adding unchecked directive can save gas  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L118-L118  ## [S] Using immutable variable can save gas   https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L28-L28  ```solidity     address public bribeVault; ```  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L60-L65  ```solidity     constructor(address _bribeVault) {         require(_bribeVault != address(0), \"Invalid bribeVault\");         bribeVault = _bribeVault;          _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);     } ```  Considering that `bribeVault` will never change, changing it to immutable variable instead of storage variable can save gas.  ## [S] Remove redundant access control checks can save gas  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L125-L135  ```solidity     function setProposal(address proposal, uint256 deadline)         public         onlyAuthorized     {         require(proposal != address(0), \"Invalid proposal\");         require(deadline >= block.timestamp, \"Deadline must be in the future\");          proposalDeadlines[proposal] = deadline;          emit SetProposal(proposal, deadline, _round);     } ```   https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L142-L157  ```solidity     function setProposals(         address[] calldata proposals,         uint256[] calldata deadlines     ) external onlyAuthorized {         require(proposals.length > 0, \"Need at least 1 proposal\");         require(             proposals.length == deadlines.length,             \"Must be equal # of proposals and deadlines\"         );          for (uint256 i = 0; i < proposals.length; i += 1) {             setProposal(proposals[i], deadlines[i]);         }          emit SetProposals(proposals, deadlines, _round);     } ```    `setProposal()` already got `onlyAuthorized` check, and `setProposals()` will check it again multiple times.  Consider creating `_setProposal()` private function without access control and call it inside the public functions.  ### Recommendation  Change to:  ```solidity     function _setProposal(address proposal, uint256 deadline)         private     {         require(proposal != address(0), \"Invalid proposal\");         require(deadline >= block.timestamp, \"Deadline must be in the future\");          proposalDeadlines[proposal] = deadline;     }      /**         @notice Set a single proposal         @param  proposal  addresss Proposal address         @param  deadline  uint256  Proposal deadline      */     function setProposal(address proposal, uint256 deadline)         public         onlyAuthorized     {         _setProposal(proposal, deadline);         emit SetProposal(proposal, deadline, _round);     }      /**         @notice Set multiple proposals         @param  proposals  address[]  Proposal addresses         @param  deadlines  uint256[]  Proposal deadlines      */     function setProposals(         address[] calldata proposals,         uint256[] calldata deadlines     ) external onlyAuthorized {         require(proposals.length > 0, \"Need at least 1 proposal\");         require(             proposals.length == deadlines.length,             \"Must be equal # of proposals and deadlines\"         );          for (uint256 i = 0; i < proposals.length; i += 1) {             _setProposal(proposals[i], deadlines[i]);         }          emit SetProposals(proposals, deadlines, _round);     } ```  ## [S] Validation can be done earlier to save gas  Check if `ethLiquidity > 0 && btrflyLiquidity > 0` earlier can avoid unnecessary external call (`IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);`) when this check failed.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L124-L155  ```solidity     function performUpkeep() external onlyOwner {         require(checkUpkeep(), \"Invalid upkeep state\");          uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));         uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);         uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);         uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;          // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount         uint256 btrflyLiquidity = ethCap > ethAmount             ? btrfly             : calculateAmountRequiredForLP(ethLiquidity, false);          IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);          // Only complete upkeep only on sufficient amounts         require(ethLiquidity > 0 && btrflyLiquidity > 0, \"Insufficient amounts\");         // ...     } ```  ### Recommendation  Change to:  ```solidity     function performUpkeep() external onlyOwner {         require(checkUpkeep(), \"Invalid upkeep state\");          uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));         uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);         uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);         uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;          // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount         uint256 btrflyLiquidity = ethCap > ethAmount             ? btrfly             : calculateAmountRequiredForLP(ethLiquidity, false);          // Only complete upkeep only on sufficient amounts         require(ethLiquidity > 0 && btrflyLiquidity > 0, \"Insufficient amounts\");          IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);          // ...     } ```  ## [M] `type(uint256).max` is more gas efficient than `2**256 - 1`  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L68-L69  ## [M] `10e18` is more gas efficient than `10**18`  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L102-L108  ## [S] Cache array length in for loops can save gas  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L147-L152  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L261-L275  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L80-L82  ## [S] Avoid unnecessary storage read can save gas  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L213-L248  ```solidity     function depositBribe(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address briber     ) external payable onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");         require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");         require(briber != address(0), \"Invalid briber\");         require(msg.value > 0, \"Value must be greater than 0\");          Bribe storage b = bribes[bribeIdentifier];         address currentToken = b.token;         require(             // For native tokens, the token address is set to this contract to prevent             // overwriting storage - the address can be anything but address(this) safer             currentToken == address(0) || currentToken == address(this),             \"Cannot change token\"         );          b.amount += msg.value; // Allow bribers to increase bribe          // Only set the token address and update the reward-to-bribe mapping if not yet set         if (currentToken == address(0)) {             b.token = address(this);             rewardToBribes[rewardIdentifier].push(bribeIdentifier);         }          emit DepositBribe(             bribeIdentifier,             rewardIdentifier,             b.token,             msg.value,             b.amount,             briber         );     } ```  Based on L224~L230, L235~L236, we know that `b.token == address(this)`, therefore at L243 `b.token` can be replaced with `address(this)`.  Use `address(this)` directly can avoid unnecessary storage read of `b.token` and save some gas.  ### Recommendation  Replace:  ```solidity emit DepositBribe(     bribeIdentifier,     rewardIdentifier,     b.token,     msg.value,     b.amount,     briber ); ```  with:  ```solidity emit DepositBribe(     bribeIdentifier,     rewardIdentifier,     address(this),     msg.value,     b.amount,     briber ); ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/83", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "## [L] `bytes32Value.length > 0` is misused, should be `bytes32Value != bytes32(0)`   `bytes32Value.length > 0` is meanless, as it always be `true`, because `.length` yields the fixed length of the byte array. `bytes32Value.length` == 32.  `bytes32` is a value type, you should use `!=` to do the comparison.  See: https://docs.soliditylang.org/en/v0.8.12/types.html#fixed-size-byte-arrays  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L164-L205  ```solidity     function depositBribeERC20(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address token,         uint256 amount,         address briber     ) external onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");         require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");         // ...     } ```  Can be changed to:  ```solidity     function depositBribeERC20(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address token,         uint256 amount,         address briber     ) external onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length != bytes32(0), \"Invalid bribeIdentifier\");         require(rewardIdentifier.length != bytes32(0), \"Invalid rewardIdentifier\");         // ...     } ```  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L213-L248  ```solidity     function depositBribe(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address briber     ) external payable onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");         require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");         // ...     } ```  Can be changed to:  ```solidity     function depositBribe(         bytes32 bribeIdentifier,         bytes32 rewardIdentifier,         address briber     ) external payable onlyRole(DEPOSITOR_ROLE) {         require(bribeIdentifier.length != bytes32(0), \"Invalid bribeIdentifier\");         require(rewardIdentifier.length != bytes32(0), \"Invalid rewardIdentifier\");         // ...     } ```  ## [L] Unchecked return value for `token.transfer` call  It is usually good to add a require-statement that checks the return value or to use something like safeTransfer; unless one is sure the given token reverts in case of a failure.  Instances include:  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L296-L297  ```solidity IERC20(token).transfer(feeRecipient, feeAmount); IERC20(token).transfer(distributor, distributorAmount); ```  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L146-L146  ```solidity IERC20(token).transfer(TREASURY, tokenBalance); ```  ### Recommendation  Consider adding a require-statement or using `safeTransfer` of SafeERC20."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L38  `rewardForwarding` is redundant as it's not used. also, the function that sets it is redundant. https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L298"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# Pin Solidity Version Pin solidity version to make the compilation more predictable. https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L2  # Fee cap too high The fee can be set as high as `feeDivisor` which equals to 100% https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L108  # Use of transfer might fail in the future `transfer()` only forward 2300 gas which may break when gas cost change in a future ETH upgrade see: https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L181 "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "## BribeVault: `fee` is not used anywhere The variable is [set](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L65) and [allowed to be changed](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L108) and even an event is there, however it is not used anywhere. The fees are [being read](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L272) directly from the admin's sent parameters and there's no check against the fee previously set. Consider removing it or aligning the `transferBribes` function to use it.  ## RewardDistributor: no sender check for ETH receive function [This](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L59) is RB's receive function: ```     // Enables BribeVault to transfer native tokens     receive() external payable {} ``` If it is only used from BribeVault, consider adding a check that verifies that the sender is BribeVault - otherwise misc ether might get sent and locked in the contract.  ## RewardDistributor: ETH being sent using `transfer` In _claim, ETH is [being sent](](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181)) using the `transfer` function. While this might be a design choice, it might cause problems and fail to transfer to smart contracts, [such as gnosis safe](https://help.gnosis-safe.io/en/articles/5249851-why-can-t-i-transfer-eth-from-a-contract-into-a-safe). There are mitigations (see in the article), and this is why I rated it as a low issue and not medium. However, for normal user experience, consider changing the `transfer` to `call`. If the concern is reentrancy, you obviously know that there are other mitigations (CEI pattern and reentrancy guard).  ## TokemakBribe: consider adding sanity check for `round` When [setting a new round](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L108:#L110), as there is no check that `_newRound > _round`, a team member can add rounds \"retroactively\": ```     function setRound(uint256 _newRound) external onlyAuthorized {         _round = _newRound;     } ``` I don't really consider this a danger. The worst case would be that a team member (not the admin) listens to TXs in the mempool, and when somebody deposits a bribe, the team member would change the round to be another one which is more beneficial for the team member, and therefore the bribe would be misattributed. However, we are talking about a team member, plus the emergency withdraw function can withdraw it, plus   anyway further releasing of the bribe to claimers requires admin actions. So I do not believe that this is a real risk. This is why I label this as low and not medium. However adding a check that `_newRound > _round` seems like an easy sanity check to add.  ## TokemakBribe: wrong comment for getRound [The comment](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L113:#L116) for `getRound` is same as for `setRound`. ```     /**         @notice Set a new voting round         @return round uint256 The current round number      */     function getRound() external view returns (uint256) { ```  ## ETH bribes dependent on BribeVault address Regarding using BribeVault's address as the native token address, [a comment](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L226) mentions \"For native tokens, the token address is set to this contract to prevent overwriting storage - the address can be anything but address(this) safer\". I might be missing something but I don't see how BribeVault's address is safer than an immutable like 0xEE..E. Since RewardDistributor [can change](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L65) BribeVault, this means that the reward identifier would also need to be changed. So again, I might be missing something but at the moment it seems to me that using the changing BribeVault address as the native token identifier just adds complexity.  ## BribeVault: transferBribes: unchecked transfer of ERC20 tokens The function [doesn't use](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296:#L297) safeTransfer for sending of tokens: ```                 IERC20(token).transfer(feeRecipient, feeAmount);                 IERC20(token).transfer(distributor, distributorAmount); ``` This might be on purpose, to not totally fail the whole loop and lose gas if one token is problematic and failed to send. If so, make sure the admin properly checks that all transfers succeeded. For easy checking I believe you can change to safeTransfer and use try/catch to emit an event if the transfer failed."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# Codebase Impressions & Summary  This audit scope consisted of 4 contracts. Overall, the code quality is great. Inline comments and documentation provided was adequate. Various parties / roles and contract interactions were well explained.  Most issues raised are minor improvements to improve the security of the contracts. The only notable findings made had to do with the usage of the curve crypto pool\u2019s price oracle, and protection against sandwich attacks when adding liquidity.  In addition, I made a suggestion regarding the syncing of Tokemak\u2019s rounds with the `TokemakBribe` contract.  Note that I refrained raising issues regarding FoT tokens because I assume they are not meant to be supported.  # Low Severity Findings  ## L01: RewardDistributor: Change `payable(account).transfer()` to `.call()` for native fund transfers  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181)  ### Description  `BribeVault` uses `.call()` for native fund transfers, but `RewardDistributor` uses `.transfer()`. They should be standardized to `.call()`, the currently recommended method since [`.transfer()` fowards 2300 gas whereas `.call()` forwards all / set gas.](https://solidity-by-example.org/sending-ether/)  ### Recommended Mitigation Steps  ```jsx (bool sentAccount, ) = _account.call{value: _amount}(\"\"); require(sentAccount, \"Failed to transfer to _account\"); ```  ## L02: BribeVault: Use `safeTransfer` for tokens  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337)  ### Description  Some ERC20 tokens like ZRX don\u2019t revert if the transfer fails. Since the `SafeERC20` has already been imported and the `safeTransferFrom` method used, the same should be done for token transfers.  ### Recommended Mitigation Steps  Replace `transfer` with `safeTransfer`.  ## L03: RewardDistributor: Limit native fund transfers to `bribeVault`  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L58-L59](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L58-L59)  ### Description  Since the only source of native fund transfers is expected to be the `bribeVault` contract, it would be good to restrict incoming fund transfers from other sources to prevent accidental transfers.  ### Recommended Mitigation Steps  ```jsx receive() external payable {   require(msg.sender == bribeVault, 'only bribeVault'); } ```  ## L04: TokemakBribe: `getBribe()` has incorrect description  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L188-L194](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L188-L194)  ### Description  - Missing `round` param - `bribeAmount` has incorrect description  ### Recommended Mitigation Steps  ```jsx /**    @notice Get bribe from BribeVault    @param  proposal            address  Proposal           @param  round               uint256  Round    @param  token               address  Token    @return bribeToken          address  Bribe token address    @return bribeAmount         uint256  Bribe token amount */ ```  ## L05: Emit relevant events in constructor methods when variables are set, or abstract to internal functions  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L59-L74](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L59-L74)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L51-L56](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L51-L56)  ### Description  Some variables are set in the constructor method but do not emit events, unlike their setter counterparts. For instance, `bribeVault` in the `RewardDistributor` contract fails to emit the `SetBribeVault` event, but this is emitted in the `setBribeVault()` function.  ### Recommended Mitigation Steps  Either emit the events in the constructor, or make the setter functions public and have the constructor call it.  # Suggestions  ## S01: TokemakBribe: Sync rounds with Tokemak\u2019s manager instead of manually setting rounds via `setRound()`  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L104-L110](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L104-L110)  ### Description  Instead of manually setting rounds, consider fetching the round number directly from Tokemak\u2019s manager contract via `[manager.currentCycleIndex()](https://etherscan.io/address/0xa86e412109f77c45a3bc1c5870b880492fb86a14#readProxyContract)`. While I initially wrote an issue about being able to set previous round numbers, after having chatted with the sponsor, it is intended to be a feature, not a bug.  ### Recommended Mitigation Steps  ```jsx // TODO: change _round to getRound() wherever it is called in other internal functions function getRound() public view returns (uint256) {   // if round is overridden, return set value   if (_round != 0) return _round;   // otherwise, if value is 0, use Tokemak's currentCycleIndex()   // Tokemak manager at 0xa86e412109f77c45a3bc1c5870b880492fb86a14   return manager.currentCycleIndex(); } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "## G01: Redundant variables  The following variables are initialized, but their values are not used in the contract subsequently. Consider removing them.  ### Variables  [`BribeVault.fee`](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L23)  [`BribeVault.feeDivisor`](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L26)  ## G02: TokemakBribe: `bribeVault` can be made immutable  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L28](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L28)  ### Description  `bribeVault` is only set in the constructor, and there are no mutators to modify its value.  ### Recommended Mitigation Steps  `address public immutable bribeVault;`  ## G03: TokemakBribe: Redundant `SetProposals()` event  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L49](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L49)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L152-L154](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L152-L154)  ### Description  The setting of multiple proposals does not require the `SetProposals()` event to be emitted because the `SetProposal()` event is emitted for each proposal when `setProposal()` is invoked.  ### Recommended Mitigation Steps  Remove the `SetProposals()` event.  ## G04: ThecosmataETH: Change `BTRFLY` and `CURVEPOOL` types to avoid repeated castings  ### Description  `BTRFLY` and `CURVEPOOL` are repeatedly casted to `IBTRFLY` and `ICurveCryptoPool`. It would be better to declare them as these types instead.  ### Recommended Mitigation Steps  ```jsx IBTRFLY public immutable BTRFLY; ICurveCryptoPool public immutable CURVEPOOL; ```  ## G05: ThecosmataETH: Call `add_liquidity()` with receiver specified  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L120](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L120)  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L143-L146](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L143-L146)  ### Description  The curve pool tokens can be transferred directly to the treasury by calling a different `add_liquidity` method.  ### Recommended Mitigation Steps  ```jsx interface ICurveCryptoPool {   function add_liquidity(     uint256[2] calldata amounts,     uint256 min_mint_amount,     bool use_eth,     address receiver   )   external   payable;    ... }  // in addLiquidity() ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount, false, TREASURY); ```  ## G06: RewardDistributor: Include updateCount in  `isRewardClaimed()` and `_setClaimed()` functions  ### Line References  [https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L142](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L142)  ### Description  Based on the current tests, the `claim()` function takes an average of 129k gas (82k min, 206k max). By including the `updateCount` parameter in the `isRewardClaimed()` and `_setClaimed()` functions, this can be reduced by about 2k. With the changes, the `claim()` function will take an average of 127k gas (81k min, 202k max).  There is an added benefit to making this change. By taking the `updateCount` as a parameter in `isRewardClaimed()`, it enables the checking of past claims made.  ### Tools Used  `hardhat-gas-reporter`  ### Recommended Mitigation Steps  ```jsx function isRewardClaimed(bytes32 _identifier, uint256 _index, uint256 _updateCount)   public   view   returns (bool) {   // Get the group index for the specified index along with the bit index   // and check if the corresponding bit index is flipped   uint256 claimedGroup = _index / 256;   uint256 claimedIndex = _index % 256;   uint256 claimedGroupState = claimed[_identifier][_updateCount][       claimedGroup   ];   uint256 mask = (1 << claimedIndex);   return claimedGroupState & mask == mask; }  function _setClaimed(bytes32 _identifier, uint256 _index, uint256 _updateCount) internal {   uint256 claimedGroup = _index / 256;   uint256 claimedIndex = _index % 256;    // Flip the bit state to mark the corresponding index as claimed   claimed[_identifier][_updateCount][claimedGroup] =     claimed[_identifier][_updateCount][claimedGroup] |     (1 << claimedIndex); }  function _claim(..) {   require(     !isRewardClaimed(_rewardIdentifier, _index, reward.updateCount),     \"Reward already claimed\"   );   ...   _setClaimed(_rewardIdentifier, _index, reward.updateCount); } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "## Low severity issues You use IBTRFLY instead of IERC20 to refer to WETH. This is minor because they are both ERC20 tokens but could cause confusion.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L72  You use transfer here, but you could use call instead. Transfer is generally avoided. https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L181  ## Non-critical issues You don't need this event here, frontend will be able to get the information based on each individual SetProposal event  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L49  You don't have an index on any of the TransferBribe or DepositBribe events, consider adding indexes on token and briber so consumers of events can easily go through them.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L42-L56  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/37", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# Report  * [Use SafeERC20 when working with arbitrary ERC20 tokens](#use-safeerc20-when-working-with-arbitrary-erc20-tokens) * [Force a new round to be greater than the old one in `TokemakBribe.sol`](#force-a-new-round-to-be-greater-than-the-old-one-in-tokemakbribesol) * [BribeVault doesn't work with fee-on-transfer tokens](#bribevault-doesnt-work-with-fee-on-transfer-tokens) * [Use `.call()` instead of `transfer()` to send funds](#use-call-instead-of-transfer-to-send-funds)  ## Use SafeERC20 when working with arbitrary ERC20 tokens  `SafeERC20` is already used in a couple of spots but not consistently.  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297 - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337  ## Force a new round to be greater than the old one in `TokemakBribe.sol`  Currently the admin can set the `newRound` to any value. But logically it should always be greater than the previous one. Adding the constraint to the function would prevent that from happening. If a smaller number is used an already finished round might be usable again.  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L109  ```sol function setRound(uint256 _newRound) external onlyAuthorized {     require(_newRound > _round);     _round = _newRound; } ```  ## BribeVault doesn't work with fee-on-transfer tokens  There's no documentation on whether they are supported or not so I wanted to still mention it here. The `bribe.amount` value won't match with the actual tokens the vault holds. An easy way to do that would be to use the actual received amount instead of the user passed `amount` parameter:  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L187-L189  ```sol uint prevBalance = IERC20(token).balanceOf(address(this)); IERC20(token).safeTransferFrom(briber, address(this), amount); uint afterBalance = IERC20(token).balanceOf(address(this));  b.amount += afterBalance - prevBalance; // Allow bribers to increase bribe ```  ## Use `.call()` instead of `transfer()` to send funds  It's generally recommended to use `call()` instead of `transfer()` to send funds. The issue is that contracts might use more than 2300 gas in their receive function. In that case the transfer would fail. Since the state is written before the transfer of funds there shouldn't be a risk of reentrancy:  - https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181  ```sol (bool success, ) = _account.call{value:_amount}(\"\"); require(success, \"Transfer failed.\"); ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           RewardDistributor.sol, _distributions, 103         RewardDistributor.sol, _claims, 82    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           ThecosomataETH.sol, 88: change 'balance > 0' to 'balance != 0'    Title: Cache powers of 10 used several times Severity: GAS  You calculate the power of 10 every time you use it instead of caching it once as a constant variable and using it instead.  Fix the following code lines:   ThecosomataETH.sol, 103 : You should cache the used power of 10 as constant state variable since it's used several times (4):                  (10**_btrflyDecimals);  ThecosomataETH.sol, 107 : You should cache the used power of 10 as constant state variable since it's used several times (2):              (((amount * (10**18)) / priceOracle) *  ThecosomataETH.sol, 108 : You should cache the used power of 10 as constant state variable since it's used several times (4):                  (10**_btrflyDecimals)) / (10**_ethDecimals);  ThecosomataETH.sol, 102 : You should cache the used power of 10 as constant state variable since it's used several times (2):              return (((amount * priceOracle) / (10**18)) * (10**_ethDecimals)) /     Title: Unnecessary array boundaries check when loading an array element twice Severity: GAS       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:               RewardDistributor.sol.claim - double load of _claims[i]    Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          RewardDistributor.sol, _claim         RewardDistributor.sol, _setClaimed         ThecosomataETH.sol, calculateAmountRequiredForLP         ThecosomataETH.sol, addLiquidity    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           RewardDistributor.sol, isRewardClaimed         ThecosomataETH.sol, checkUpkeep    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: RewardDistributor.sol, i, 82         change to prefix increment and unchecked: RewardDistributor.sol, i, 103    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          RewardDistributor.sol, 82         RewardDistributor.sol, 103    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               RewardDistributor.sol, _claim         RewardDistributor.sol, _setClaimed         ThecosomataETH.sol, addLiquidity    Title: Gas Optimization On The 2^256-1 Severity: GAS   Some projects (e.g. Uniswap - https://github.com/Uniswap/interface/blob/main/src/hooks/useApproveCallback.ts#L88) set the default value of the user's allowance to 2^256 - 1. Since the value 2^256 - 1 can also be represented in  hex as 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff. From Ethereum's yellow paper we know  that zeros are cheaper than non-zero values in the hex representation. Considering this fact, an alternative  choice could be now 0x8000000000000000000000000000000000000000000000000000000000000000 or 2^255 to represent  \"infinity\". If you do the calculations with Remix, you will see that the former costs 47'872 gas, while the latter  costs 45'888 gas. If you accept that infinity can also be represented via 2^255 (instead of 2^256-1), which almost  all projects can - you can already save about 4% gas leveraging this optimisation trick on those calculations.                    ThecosomataETH.sol (L#69): IERC20(_WETH).approve(_CURVEPOOL, 2**256 - 1); )         ThecosomataETH.sol (L#68): IERC20(_BTRFLY).approve(_CURVEPOOL, 2**256 - 1);)  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "1. Used both named return and an actual return statement in [ThecosomataETH.sol#L89](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L89)  2. It was found some `transfer`, `approve` or `transferFrom` without checking the boolean result, ERC20 standard specify that the token can return false if this call was not made, so it's mandatory to check the result of these methods. As following you can see the affected locations: - [ThecosomataETH.sol#L68-L69](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L68-L69) - [ThecosomataETH.sol#L146](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L146) - [ThecosomataETH.sol#L164](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L164) - [BribeVault.sol#L296-L297](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L296-L297) - [BribeVault.sol#L337](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L337) "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/17", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "2022-02-redacted-cartel  1 Use Lock pragmas to specific compiler version. If it is possible, set above 0.8.4 and you can use custom errors instead of require statements to save gas.  2 Use naming conventions for constant variable  Constants should be named with all capital letters with underscores separating words.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L31   3 write comments outside of require statement.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L225-L230  4 Use safeTransfer of SafeERC20 or check the return value of IERC().transfer which returns whether the operation succeeded  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337  ThecosomataETH.sol line 146 and 164  5 Add require or custom error to check if sender is BribeVault contract or not and emit msg.value in receive.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L59  For example  require(msg.sender == bribeVault, \u201cOnly from bribeVault allowed\u201d); emit received(msg.value);   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "2022-02-redacted-cartel Gas Optimization  1 Using custom errors instead of require statement saves gas if you can use a solidity version above 0.8.4.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L61 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L68-L72 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L84 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L98 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L129-L130 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L146-L150 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L218-L223 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L259-L263 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L64 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L67 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L70 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L84 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L98 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L109 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L123 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L137 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L171-L175 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L179-L183 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L218-L221 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L225-L230 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L261-L266 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L274-L279 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L286-L289 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L294 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L321 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L334-L335 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L350 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L353 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L52 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L69 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L80 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L100-L101 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L160-L164 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L168-L171  TokemakBribe.sol  2 Use immutable for bribeVault.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L28  There are no functions to update bribeVault, so you can set bribeVault as immutable.  3 Use visibility external function instead of public  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L298  4 Use visibility private instead of internal  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L166-L170 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L180-L184   BribeVault.sol  5 All inputs checks must be executed at the beginning of function in constructor  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L59-L74  constructor(uint256 _fee, address _feeRecipient, address _distributo) {     require(_fee <= feeDivisor, \"Invalid fee\");     require(_feeRecipient != address(0), \"Invalid feeRecipient\");     require(_distributor != address(0), \"Invalid distributor\");          fee = _fee;     feeRecipient = _feeReceipient;     Distributor = _distributor;      _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); }  6 code duplication.  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L310  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L322  Create private function to execute this code duplication. For example,  function _updateRewardsMetadata(     Common.Distribution[] calldata distributions ) private {     IRewardDistributor(distributor).updateRewardsMetadata(distributions); } and use this private function in transferBribes and updateRewardsMetadata.   RewardDistributor.sol  7 set visibility private instead of internal for _claim and _setClaimed in RewardDistributor.sol  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L152-L158  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L199  8 delete unused variable in struct Reward  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L17  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/libraries/Common.sol#L9   ThecosomataETH.sol  9 All inputs checks must be executed at the beginning of function in constructor  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L50-L73  constructor(     address _BTRFLY,      address _WETH,     address _TRESUARY,     address _CURVEPOOL ) {     require(_BTRFLY != address(0), \u201cInvalid BTRFLY address\u201d);     require(_WETH != address(0), \u201cInvalid WRTH address\u201d);     require(_TRESUARY != address(0), \u201cInvalid TRESUARY address\u201d);     require(_CURVEPOOL != address(0), \u201cInvalid CURVEPOOL address\u201d);    }  10 set visibility private instead of internal for calculateAmountRequiredLP and addLiquidity  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L94-L98 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L113                     "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# GAS issues  1. Change the incremental logic from `i++` to `++i` in order to save some opcodes: - [BribeVault.sol#L269](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L269) - [RewardDistributor.sol#L82](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L82) - [RewardDistributor.sol#L103](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L103) - [TokemakBribe.sol#L152](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L152)  2. It's possible to avoid storage access a save gas using `immutable` keyword for the following variables: - [TokemakBribe.sol#L62](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L62)  3. Avoid double events and calls - [TokemakBribe.sol#L156](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L156) `SetProposals` was already emited at line [134](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L134) also `onlyAuthorized`  4. Remove unused code - [setRewardForwarding](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L298-L302) is not used in TokemakBribe.sol  5. Use `type(uint).max` instead of `2**256 - 1` - [ThecosomataETH.sol#L68-L69](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L68-L69)  6. Unneeded `require`, `bytes32.length` is always 32 - [BribeVault.sol#L171-L172](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L171-L172) - [BribeVault.sol#L218-L219](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L218-L219)  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "Below are the places where Gas can be saved:  1. bribeVault can be set to immutable at TokemakBribe.sol#L28  2. Instead of using _setupRole function in TokemakBribe.sol#L64 we can directly use _grantRole as done in grantTeamRole function  3. In revokeTeamRole function at TokemakBribe.sol#L98, require(hasRole(TEAM_ROLE, teamMember), \"Invalid teamMember\"); is not required since this is already checked in _revokeRole function  4. In setProposals function at TokemakBribe.sol#L142, store proposals.length in local variable and use local variable instead at all places in this function  5. In setProposals function at TokemakBribe.sol#L152, use ++i instead of i+=1. Change this in all loops at all contracts (also change i++ to ++i)  6. In depositBribeERC20 function at  TokemakBribe.sol#L222-L223, require(token != address(0), \"Invalid token\"); and require(amount > 0, \"Bribe amount must be greater than 0\"); are not required as they are already checked in depositBribeERC20 function of BribeVault.sol#L173-L174  7. The setRewardForwarding function at TokemakBribe.sol#L298 can be declared external  8. In revokeDepositorRole function at BribeVault.sol#L98, require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\"); is not required since this is already checked in _revokeRole function  9. In transferBribes function at BribeVault.sol#L256, store distributions.length in local variable and use this local variable at all places  10. In claim function at RewardDistributor.sol#L79, add a check to revert when require( _claims[i].amount!=0, \"Invalid amount\")   "}, {"title": "Changing `bribeVault` in `RewardDistributor.sol` will Lock Current ETH Rewards", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/7", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L178-#L182 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L65-#L73   # Vulnerability details  ## Impact  Claiming of the ETH native currency requires `token` to be set to `bribeVault`. If the `bribeVault` is modified in `setBribeVault()` then users who have ETH rewards will now be considered to have `ERC20(bribeVault)` tokens. Since `bribeVault` is not an ERC20 token the `transfer()` call will fail and the users will not be able to claim their funds.   ## Recommended Mitigation Steps  Consider removing the functionality to change the `bribeVault` or ensuring all funds have been withdraw i.e. `balanceOf(address(this)) == 0` before changing the `bribeVault`.  "}, {"title": "SafeERC20.sol is imported but not used in the transferBribes() function ", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296   # Vulnerability details  ## Impact In BribeVault.sol the transferBribes() function uses token.transfer() instead of token.safeTransfer.  Tokens that don\u2019t correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  The fact that the SafeERC20.sol library is imported at the top of the BribeVault.sol implies that safeTransfer should be being used but may have been forgotten.    ## Proof of Concept https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296  ## Tools Used Manual code review   ## Recommended Mitigation Steps It's recommended to use OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.   "}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/3", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164   # Vulnerability details  ## Impact In BribeVault.sol,  the depositBribeERC20() function deposits a bribe which is an ERC20 token from the briber to the contract itself and then updates the Bribe structs amount and token address.  The issue is that there is no whitelist of acceptable ERC20 tokens that are allowed to interact with the protocol.  Without a proper white list malicious attacker controlled tokens are able to be introduced into the protocol which should not be allowed.  ## Proof of Concept https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add a whitelist mapping of acceptable tokens and require that the token address argument in the depositBribeERC20() function is a whitelisted token allowed to interact with the protocol.   "}, {"title": "Send ether with call instead of transfer.", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/2", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181   # Vulnerability details  ## Impact Use call instead of transfer to send ether. And return value must be checked if sending ether is successful or not. Sending ether with the transfer is no longer recommended. ## Proof of Concept https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181  ## Tools Used review ## Recommended Mitigation Steps  (bool result, ) = payable(_account).call{value: _amount}(\"\"); require(result, \"Failed to send Ether\");  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Gas Report  **Table of Contents:**  - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [Summary](#summary)   - [File: AMM.sol](#file-ammsol)     - [function initialize()](#function-initialize)       - [Use `calldata` instead of `memory` for `string _name`](#use-calldata-instead-of-memory-for-string-_name)     - [function openPosition()](#function-openposition)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory)     - [function liquidatePosition()](#function-liquidateposition)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-1)     - [function removeLiquidity()](#function-removeliquidity)       - [Do not cache `positions[maker]` in memory](#do-not-cache-positionsmaker-in-memory)       - [Do not cache `makers[maker]` in memory](#do-not-cache-makersmaker-in-memory)     - [function getNotionalPositionAndUnrealizedPnl()](#function-getnotionalpositionandunrealizedpnl)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-2)       - [Do not cache `makers[trader]` in memory](#do-not-cache-makerstrader-in-memory)     - [function getPendingFundingPayment()](#function-getpendingfundingpayment)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-3)       - [Do not cache `makers[trader]` in memory](#do-not-cache-makerstrader-in-memory-1)     - [function getTakerNotionalPositionAndUnrealizedPnl()](#function-gettakernotionalpositionandunrealizedpnl)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-4)     - [function _emitPositionChanged()](#function-_emitpositionchanged)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-5)     - [function _openReversePosition()](#function-_openreverseposition)       - [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory-6)       - [Unchecked block L597](#unchecked-block-l597)     - [function _calcTwap()](#function-_calctwap)       - [Do not cache `reserveSnapshots[snapshotIndex]` in memory](#do-not-cache-reservesnapshotssnapshotindex-in-memory)       - [Cache `reserveSnapshots.length` in memory](#cache-reservesnapshotslength-in-memory)       - [Unchecked block L684](#unchecked-block-l684)       - [Use the cache for calculation](#use-the-cache-for-calculation)   - [File: ClearingHouse.sol](#file-clearinghousesol)     - [function _disperseLiquidationFee()](#function-_disperseliquidationfee)       - [Unchecked block L214](#unchecked-block-l214)   - [File: InsuranceFund.sol](#file-insurancefundsol)     - [function pricePerShare()](#function-pricepershare)       - [Unchecked block L97](#unchecked-block-l97)   - [File: Oracle.sol](#file-oraclesol)     - [function getUnderlyingTwapPrice()](#function-getunderlyingtwapprice)       - [Unchecked block L81](#unchecked-block-l81)   - [File: Interfaces.sol](#file-interfacessol)     - [struct Collateral](#struct-collateral)       - [Tight packing structs to save slots](#tight-packing-structs-to-save-slots)   - [File: MarginAccount.sol](#file-marginaccountsol)     - [function _getLiquidationInfo()](#function-_getliquidationinfo)       - [Do not cache `supportedCollateral[idx]` in memory](#do-not-cache-supportedcollateralidx-in-memory)     - [function _transferOutVusd()](#function-_transferoutvusd)       - [Unchecked block L588](#unchecked-block-l588)   - [File: VUSD.sol](#file-vusdsol)     - [function processWithdrawals()](#function-processwithdrawals)       - [Unchecked block L57-L65](#unchecked-block-l57-l65)       - [Cache `start` in memory](#cache-start-in-memory)   - [General recommendations](#general-recommendations)     - [Variables](#variables)       - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values)       - [Pre-increments cost less gas compared to post-increments](#pre-increments-cost-less-gas-compared-to-post-increments)     - [Comparisons](#comparisons)       - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof)     - [For-Loops](#for-loops)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)       - [`++i` costs less gas compared to `i++`](#i-costs-less-gas-compared-to-i)       - [Increments can be unchecked](#increments-can-be-unchecked)     - [Arithmetics](#arithmetics)       - [Shift Right instead of Dividing by 2](#shift-right-instead-of-dividing-by-2)     - [Errors](#errors)       - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword  - **Storage-reading optimizations**  > The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). In the paragraphs below, please see the `@audit-issue` tags in the pieces of code's comments for more information about SLOADs that could be saved by caching the mentioned **storage** variables in **memory** variables.  - **Unchecking arithmetics operations that can't underflow/overflow**  > Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Summary  - One pattern that was often seen is caching structs in memory when it's not needed. A copy in memory of a storage struct will trigger as many SLOADs as there are slots. If the struct's fields are only read once, or if the number of storage reading would be inferior to the number of slots: don't cache the struct in memory.  ## File: AMM.sol  ### function initialize()  ``` 093:     function initialize( 094:         address _registry, 095:         address _underlyingAsset, 096:         string memory _name,//@audit readonly: calldata 097:         address _vamm, 098:         address _governance 099:     ) external initializer { 100:         _setGovernace(_governance); 101:  102:         vamm = IVAMM(_vamm); 103:         underlyingAsset = _underlyingAsset; 104:         name = _name; 105:         fundingBufferPeriod = 15 minutes; 106:  107:         syncDeps(_registry); 108:     } ```  #### Use `calldata` instead of `memory` for `string _name`  An external function passing a readonly variable should mark it as `calldata` and not `memory`  ### function openPosition()  ``` 113:     function openPosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit) 114:         override 115:         external 116:         onlyClearingHouse 117:         returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased) 118:     { 119:         require(ammState == AMMState.Active, \"AMM.openPosition.not_active\"); 120:         Position memory position = positions[trader]; //@audit 3 SLOADs vs 1 enough 121:         bool isNewPosition = position.size == 0 ? true : false; 122:         Side side = baseAssetQuantity > 0 ? Side.LONG : Side.SHORT; 123:         if (isNewPosition || (position.size > 0 ? Side.LONG : Side.SHORT) == side) { 124:             // realizedPnl = 0; 125:             quoteAsset = _increasePosition(trader, baseAssetQuantity, quoteAssetLimit); 126:             isPositionIncreased = true; 127:         } else { 128:             (realizedPnl, quoteAsset, isPositionIncreased) = _openReversePosition(trader, baseAssetQuantity, quoteAssetLimit); 129:         } 130:         _emitPositionChanged(trader, realizedPnl); 131:     } ```  #### Do not cache `positions[trader]` in memory  As a copy in memory of a struct makes as many SLOADs as there are slots, here a copy costs 3 SLOADs:  ``` 41:     struct Position { 42:         int256 size; 43:         uint256 openNotional; 44:         int256 lastPremiumFraction; 45:     } ```  However, only the `size` field is read twice. Therefore, only this field should get cached: `int256 _size = positions[trader].size;`  ### function liquidatePosition()  ``` 133:     function liquidatePosition(address trader) 134:         override 135:         external 136:         onlyClearingHouse 137:         returns (int realizedPnl, uint quoteAsset) 138:     { 139:         // don't need an ammState check because there should be no active positions 140:         Position memory position = positions[trader]; //@audit 3 SLOADs vs 1 enough 141:         bool isLongPosition = position.size > 0 ? true : false; 142:         // sending market orders can fk the trader. @todo put some safe guards around price of liquidations 143:         if (isLongPosition) { 144:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, 0); 145:         } else { 146:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, type(uint).max); 147:         } 148:         _emitPositionChanged(trader, realizedPnl); 149:     } ```  #### Do not cache `positions[trader]` in memory  Similar to [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory).  However, only the `size` field is read 3 times. Therefore, only this field should get cached: `int256 _size = positions[trader].size;`  ### function removeLiquidity()  ``` 133:     function liquidatePosition(address trader) 134:         override 135:         external 136:         onlyClearingHouse 137:         returns (int realizedPnl, uint quoteAsset) 138:     { 139:         // don't need an ammState check because there should be no active positions 140:         Position memory position = positions[trader]; //@audit 3 SLOADs vs 1 enough 141:         bool isLongPosition = position.size > 0 ? true : false; 142:         // sending market orders can fk the trader. @todo put some safe guards around price of liquidations 143:         if (isLongPosition) { 144:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, 0); 145:         } else { 146:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, type(uint).max); 147:         } 148:         _emitPositionChanged(trader, realizedPnl); 149:     } ```  #### Do not cache `positions[maker]` in memory  Similar to [Do not cache `positions[trader]` in memory](#do-not-cache-positionstrader-in-memory). However, here, even the fields shouldn't get cached, as they are read only once:  ``` 220:         Position memory _taker = positions[maker];//@audit 3 SLOADs vs 2 enough ... 233:             _taker.size, 234:             _taker.openNotional ```  Therefore, use `220:         Position storage _taker = positions[maker];`  #### Do not cache `makers[maker]` in memory  Similarly, a copy in memory for `Maker` costs 7 SLOADs:  ``` 48:     struct Maker { 49:         uint vUSD; 50:         uint vAsset; 51:         uint dToken; 52:         int pos; // position 53:         int posAccumulator; // value of global.posAccumulator until which pos has been updated 54:         int lastPremiumFraction; 55:         int lastPremiumPerDtoken; 56:     } ```  Here, caching the first 5 fields in memory is enough.  ### function getNotionalPositionAndUnrealizedPnl()  ``` 395:     function getNotionalPositionAndUnrealizedPnl(address trader) 396:         override 397:         external 398:         view 399:         returns(uint256 notionalPosition, int256 unrealizedPnl, int256 size, uint256 openNotional) 400:     { 401:         Position memory _taker = positions[trader];//@audit 3 SLOADs vs 2 enough 402:         Maker memory _maker = makers[trader];//@audit 7 SLOADs vs 3 enough 403:  404:         (notionalPosition, size, unrealizedPnl, openNotional) = vamm.get_notional( 405:             _maker.dToken, 406:             _maker.vUSD, 407:             _maker.vAsset, 408:             _taker.size, 409:             _taker.openNotional 410:         ); 411:     } ```  #### Do not cache `positions[trader]` in memory  Here, we need `Position storage _taker = positions[trader];`  #### Do not cache `makers[trader]` in memory  Here, we need `Maker storage _maker = makers[trader];`  ### function getPendingFundingPayment()  ``` 425:         Position memory taker = positions[trader];//@audit 3 SLOADs vs 2 enough ... 434:         Maker memory maker = makers[trader];//@audit 7 SLOADs vs 5 enough ```  #### Do not cache `positions[trader]` in memory  Here, we need `Position storage _taker = positions[trader];`  #### Do not cache `makers[trader]` in memory  Here, we need `Maker storage _maker = makers[trader];`  ### function getTakerNotionalPositionAndUnrealizedPnl()  ``` 458:     function getTakerNotionalPositionAndUnrealizedPnl(address trader) override public view returns(uint takerNotionalPosition, int256 unrealizedPnl) { 459:         Position memory position = positions[trader];//@audit 3 SLOADs vs 2 enough 460:         if (position.size > 0) { 461:             takerNotionalPosition = vamm.get_dy(1, 0, position.size.toUint256()); 462:             unrealizedPnl = takerNotionalPosition.toInt256() - position.openNotional.toInt256(); 463:         } else if (position.size < 0) { 464:             takerNotionalPosition = vamm.get_dx(0, 1, (-position.size).toUint256()); 465:             unrealizedPnl = position.openNotional.toInt256() - takerNotionalPosition.toInt256(); 466:         } 467:     } ```  #### Do not cache `positions[trader]` in memory  Here, we need to cache these fields: `size` and `openNotional`  ### function _emitPositionChanged()  ``` 527:     function _emitPositionChanged(address trader, int256 realizedPnl) internal { 528:         Position memory position = positions[trader];//@audit 3 SLOADs vs 2 enough 529:         emit PositionChanged(trader, position.size, position.openNotional, realizedPnl); 530:     } ```  #### Do not cache `positions[trader]` in memory  Here, we need `Position storage _taker = positions[trader];`  ### function _openReversePosition()  ``` 584:     function _openReversePosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit) 585:         internal 586:         returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased) 587:     { 588:         Position memory position = positions[trader];//@audit 3 SLOADs vs 1 enough 589:         if (abs(position.size) >= abs(baseAssetQuantity)) { 590:             (realizedPnl, quoteAsset) = _reducePosition(trader, baseAssetQuantity, quoteAssetLimit); 591:         } else { 592:             uint closedRatio = (quoteAssetLimit * abs(position.size).toUint256()) / abs(baseAssetQuantity).toUint256(); 593:             (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, closedRatio); 594:  595:             // this is required because the user might pass a very less value (slippage-prone) while shorting 596:             if (quoteAssetLimit >= quoteAsset) { 597:                 quoteAssetLimit -= quoteAsset; //@audit uncheck (see L596) 598:             } 599:             quoteAsset += _increasePosition(trader, baseAssetQuantity + position.size, quoteAssetLimit); 600:             isPositionIncreased = true; 601:         } 602:     } ```  #### Do not cache `positions[trader]` in memory  Here, we need to cache the `size` field  #### Unchecked block L597  This line can't underflow due to the condition L596. Therefore, it should be wrapped in an `unchecked` block  ### function _calcTwap()  ``` 656:     function _calcTwap(uint256 _intervalInSeconds) 657:         internal 658:         view 659:         returns (uint256) 660:     { 661:         uint256 snapshotIndex = reserveSnapshots.length - 1; //@audit reserveSnapshots.length  SLOAD 1 662:         uint256 currentPrice = reserveSnapshots[snapshotIndex].lastPrice; 663:         if (_intervalInSeconds == 0) { 664:             return currentPrice; 665:         } 666:  667:         uint256 baseTimestamp = _blockTimestamp() - _intervalInSeconds; 668:         ReserveSnapshot memory currentSnapshot = reserveSnapshots[snapshotIndex];//@audit 3 SLOADs vs 1 enough 669:         // return the latest snapshot price directly 670:         // if only one snapshot or the timestamp of latest snapshot is earlier than asking for 671:         if (reserveSnapshots.length == 1 || currentSnapshot.timestamp <= baseTimestamp) {//@audit reserveSnapshots.length  SLOAD 2 ... 675:         uint256 previousTimestamp = currentSnapshot.timestamp; 676:         uint256 period = _blockTimestamp() - previousTimestamp; 677:         uint256 weightedPrice = currentPrice * period; 678:         while (true) { ... 680:             if (snapshotIndex == 0) { 681:                 return weightedPrice / period; 682:             } ... 684:             snapshotIndex = snapshotIndex - 1; //@audit uncheck (see L680-L682) 685:             currentSnapshot = reserveSnapshots[snapshotIndex]; 686:             currentPrice = reserveSnapshots[snapshotIndex].lastPrice; //@audit use currentSnapshot.lastPrice ... 689:             if (currentSnapshot.timestamp <= baseTimestamp) { ... 698:             uint256 timeFraction = previousTimestamp - currentSnapshot.timestamp; ... 701:             previousTimestamp = currentSnapshot.timestamp; ```  #### Do not cache `reserveSnapshots[snapshotIndex]` in memory  Here, we need to cache the `timestamp` field. Copying the struct in memory costs 3 SLOADs.  #### Cache `reserveSnapshots.length` in memory  This would save 1 SLOAD  #### Unchecked block L684  This line can't underflow due to the condition L680-L682. Therefore, it should be wrapped in an `unchecked` block  #### Use the cache for calculation  As we already have `currentSnapshot = reserveSnapshots[snapshotIndex];`: use it here: `currentPrice = currentSnapshot.lastPrice;`  ## File: ClearingHouse.sol  ### function _disperseLiquidationFee()  ``` 210:     function _disperseLiquidationFee(uint liquidationFee) internal { 211:         if (liquidationFee > 0) { 212:             uint toInsurance = liquidationFee / 2; 213:             marginAccount.transferOutVusd(address(insuranceFund), toInsurance); 214:             marginAccount.transferOutVusd(_msgSender(), liquidationFee - toInsurance); //@audit uncheck (see L212) 215:         } 216:     } ```  #### Unchecked block L214  This line can't underflow due to the condition L212. Therefore, it should be wrapped in an `unchecked` block  ## File: InsuranceFund.sol  ### function pricePerShare()  ``` File: InsuranceFund.sol 094:     function pricePerShare() external view returns (uint) { 095:         uint _totalSupply = totalSupply(); 096:         uint _balance = balance(); 097:         _balance -= Math.min(_balance, pendingObligation); //@audit uncheck 098:         if (_totalSupply == 0 || _balance == 0)  099:             return PRECISION; 100:         } 101:         return _balance * PRECISION /  _totalSupply; 102:     } ```  #### Unchecked block L97  This line can't underflow for obvious mathematical reasons (`_balance` substracting at most itself). Therefore, it should be wrapped in an `unchecked` block  ## File: Oracle.sol  ### function getUnderlyingTwapPrice()  #### Unchecked block L81  This line can't underflow due to L76-L79. Therefore, it should be wrapped in an `unchecked` block  ## File: Interfaces.sol  ### struct Collateral  #### Tight packing structs to save slots  While this file is out of scope, it deeply impacts MarginAccount.sol. I suggest going from:  ``` 94:     struct Collateral { 95:         IERC20 token; //@audit 20 bytes 96:         uint weight; //@audit 32 bytes 97:         uint8 decimals; //@au"}, {"title": "All AMMs have to be past nextFundingTime to update", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/130", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L348   # Vulnerability details  # Impact  settleFunding calls will revert until all AMMs are ready to be updated.  # Proof of Concept  1. AMM 1 has a nextFundingTime of now. AMM 2 has a nextFundingTime in 30 minutes. AMM 1 won't be able to be updated until after AMM 2's nextFundingTime elapses.  # Mitigation You shouldn't revert at the place mentioned in the links to affected code. Just return so that the other AMMs can still get updated.  "}, {"title": "Assets sent from MarginAccount to InsuranceFund will be locked forever", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/128", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L377   # Vulnerability details  # Impact Assets sent from MarginAccount to InsuranceFund will be locked forever  # Proof of Concept The insurance fund doesn't have a way to transfer non-vusd out of the contract.  Assets transferred to the InsuranceFund will be locked forever.  # Mitigation Have a way for governance to sweep tokens to swap them.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "#1  ## Impact Light DoS of USDC withdrawal system  ## Proof of Concept Currently, withdrawals are queued in an array and processed sequentially in a for loop. However, a malicious user can post unlimited number of tiny (1 wei) withdrawals. Or, not-malicious user can post multiple withdrawals. User will receive funds from multiple transfers but it's possible to make only 1 transfer.  USDC transfers are actually expensive due to additional, non-standard SLOADs.  There is more...  Unused array's storage is not freed. I propose usage of mappings, so one can free the memory and get a refund.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67  ## Tools Used Manual review  ## Recommended Mitigation Steps There are 3 ways it can be rewritten:  1st, preserve FIFO order + remove unused storage - multiple calls to the same recipient  2nd, don't preserve FIFO order + remove unused storage - most efficient although unfair property  3nd (BEST), preserve FIFO order + remove unused storage + single call to the same recipient (Aggregate)  ### 1st approach ```javascript function withdraw__gas_efficient_1st(uint amount) external {     burn(amount);     pendingWithdrawals[end_index] += Withdrawal(msg.sender, aount);     end_index += 1; } function processWithdrawals__gas_efficient_1st() external {     uint reserve = reserveToken.balanceOf(address(this));     require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');     uint count = (end_index - start_index);     uint end = start_index + min(count, maxWithdrawalProcesses);     uint i;     for (i = startIndex; i < end; ++i) {         Withdrawal memory withdrawal = pendingWithdrawals[i];         if (reserve < withdrawal.amount) {             break;         }         reserveToken.safeTransfer(withdrawal.user, withdrawal.amount);         reserve -= withdrawal.amount;         delete pendingWithdrawals[i]; // save gas         delete pendingWithdrawalsIdx[withdrawal.user]; // save gas     }     start_index = i; } ```  ### 2nd approach ```javascript function withdraw__gas_efficient_2nd(uint amount) external {     burn(amount);     uint user_index = pendingWithdrawalsIndicies[msg.sender];     if (user_index == 0) {         user_index = end_index++;         pendingWithdrawalsIndicies[msg.sender] = user_index;     }     pendingWithdrawals[user_index] += Withdrawal(msg.sender, aount); } function processWithdrawals__gas_efficient_2nd() external {     uint reserve = reserveToken.balanceOf(address(this));     require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');     uint count = (end_index - start_index);     uint end = start_index + min(count, maxWithdrawalProcesses);     uint i;     for (i = startIndex; i < end; ++i) {         Withdrawal memory withdrawal = pendingWithdrawals[i];         if (reserve < withdrawal.amount) {             break;         }         reserveToken.safeTransfer(withdrawal.user, withdrawal.amount);         reserve -= withdrawal.amount;         delete pendingWithdrawals[i]; // save gas         delete pendingWithdrawalsIdx[withdrawal.user]; // save gas     }     start_index = i; } ```  ### 3rd approach ```javascript function withdraw__gas_efficient_3rd(uint amount) external {     burn(amount);     pendingWithdrawals[end_index] += Withdrawal(msg.sender, aount);     end_index += 1; } function processWithdrawals__gas_efficient_3rd() external {     uint reserve = reserveToken.balanceOf(address(this));     require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');     uint count = (end_index - start_index);     uint end = start_index + min(count, maxWithdrawalProcesses);     uint i;     // compute     mapping(address => uint) memory temp_idx;     Withdrawal[] memory temp_withdrawals     for (i = startIndex; i < end; ++i) {         Withdrawal memory withdrawal = pendingWithdrawals[i];         if (reserve < withdrawal.amount) {             break;         }         uint user_index = temp_idx[withdrawal.user];         if (user_index == 0) {             user_index = ++idx;             temp_withdrawals.push(withdrawal);         } else {             temp_withdrawals[user_index - 1].amount += withdrawal.amount;         }         reserve -= withdrawal.amount;         delete pendingWithdrawals[i]; // save gas         delete pendingWithdrawalsIdx[withdrawal.user]; // save gas     }     startIndex = i;      for (uint j = 0; j < temp_withdrawals.length; ++j) {         Withdrawal memory withdrawal = temp_withdrawals[j];         reserveToken.safeTransfer(withdrawal.user, withdrawal.amount); // save gas     } } ```  # 2  ## Impact Excessive SLOAD in a for loop.  ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L57  ## Tools Used Manual review  ## Recommended Mitigation Steps Cache array's length in memory"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "##GAS OPTIMAZATION  #1 Better increment for saving more gas   Using ++i for all the loops in the variable. it is known and common case that implementation by using ++i can cost less gas per iteration than i++  ##POC  it can bee seen from here : https://github.com/ethereum/solidity/issues/10695  ##Occurance  ``` main/contracts/ClearingHouse.sol#L122; main/contracts/ClearingHouse.sol#L170;  main/contracts/ClearingHouse.sol#L194; main/contracts/ClearingHouse.sol#L251; main/contracts/ClearingHouse.sol#L263; main/contracts/ClearingHouse.sol#L278; main/contracts/MarginAccount.sol#L331; main/contracts/MarginAccount.sol#L373; main/contracts/MarginAccount.sol#L521; main/contracts/MarginAccount.sol#L552; ```  ##Mitigation  `i++` change to `++i`  #2 Using `storage` instead `memory` for saving more gas  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L588 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/VUSD.sol#L58  instead of caching with `memory` it can be used by caching with `storage`, just read it directly for saving more gas  change to  `Position storage position = positions[trader];` `Withdrawal storage withdrawal = withdrawals[i];`  #3 using `&&` is more expensive gas   https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L461 using mutiple `require()` is cheaper than use `&&` if this was used many times. Because it can save gas execution cost   ##Mitigation  ``` require(idx > VUSD_IDX && idx < supportedCollateral.length, \"collateral not seizable\"); ```  change to   ``` require idx > VUSD_IDX; require supportedCollateral.length, \"collateral not seizable\"; ```  #4 Using `constructor()` instead `initialize()` or vice versa https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L35-L56 better to execute all the codes in the `initialize()` using `constructor()`. The idea is of using initialize is to run all the code inside it once in a lifetime. The current implementation of some of the contract is using both `constructor()` & `initialize()`  #5 Directly call `msg.sender` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L69 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L65 by using `msg.sender` instead of `_msgSender()` can save gas  6# The vars can set to immutable https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L22-L24 `vusd`, `insuranceFund`, & `marginAccount` set once at `initialize()`. Use immutable  7# There is no int which using `Safecast` lib https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L13 In the `ClearingHouse.sol` there is no int which is using the lib. Remove the line 13  8# Better way to call `SafeCast`lib function https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L12-L13 By removing lines which declaring that this contract is using `SafeCast` lib  and directly call it on each function, it can save execution gas cost ``` int256 marginCharge = realizedPnl - SafeCast.toInt256(fee); ``` The `SafeCast.function` is only called 3 times at `ClearingHouse.sol` so i recommend to change it thes way https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L332  9# Calling `block.timestamp` directly can save gas https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L86 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L201 instead of using `_blockTimestamp()` func to get `block.timestamp` value, using `block.timestamp`  can save gas  10# Caching `position.size` in `isLongPosition` bool is not gas efficient https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L614 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L141 By putting `position.size` inside the `if()` condition, and removing `L141` and `L614`, can save a lot of gas  11# Using != instead > https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L211 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L253 since uint cant be < 0, by using != operator to check condition can save gas  12# Custom error can save gas Using string to throw an error to user is more gas consuming. From solidity 0.8.4 we can use custom error to save gas. Custom errors are defined using the `error` statement https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L51 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L75 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L84 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L101 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L120 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L154 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L164 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L189  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/124", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L540  the comment: ```             makerNotional = newNotional * makerPos / totalPos //<-------- This line             if (side remains same)             reducedOpenNotional = takerOpenNotional * makerPos / takerPos             pnl = makerNotional - reducedOpenNotional  ```  and the actual code was   ```  uint totalPosition = abs(makerPosition + takerPosition).toUint256();         if (abs(takerPosition) > abs(makerPosition)) {  // taker position side remains same             uint reducedOpenNotional = takerOpenNotional * abs(makerPosition).toUint256() /              abs(takerPosition).toUint256();              uint makerNotional = newNotional * abs(makerPosition).toUint256() / totalPosition; //<------- this line             pnlToBeRealized = _getPnlToBeRealized(takerPosition, makerNotional, reducedOpenNotional); ```  the line ```  uint makerNotional = newNotional * abs(makerPosition).toUint256() / totalPosition; ``` was intended to executed outside of `if()` body(Not sure which one is the correct, the comment or the code)"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/120", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "already checked twice: https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/curve-v2/Swap.vy#L669 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/curve-v2/Swap.vy#L671   the check can be removed, as it's an external view function: https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/curve-v2/Swap.vy#L929"}, {"title": "denial fo service", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/119", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53   # Vulnerability details  processWithdrawals can process limited amount in each call. an attacker can push to withdrawals enormous amount of withdrawals with amount = 0. in order to stop the dos attack and process the withdrawal, the governance needs to spend as much gas as the attacker. if the governance doesn't have enough money to pay for the gas, the withdrawals can't be processed.  ## Proof of Concept Alice wants to attack vusd, she spend 1millions dollars for gas to push as many withdrawals of amount = 0 as she can. if the governance wants to process the deposits after alices empty deposits, they also need to spend at least 1 million dollars for gas in order to process alice's withdrawals first. but the governance doesn't have 1 million dollar so the funds will be locked.  ## Recommended Mitigation Steps set  a minimum amount of withdrawal. e.g. 1 dollar  ```     function withdraw(uint amount) external {         require(amount >= 10 ** 6);         burn(amount);         withdrawals.push(Withdrawal(msg.sender, amount));     } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "GAS :  1. Title : Its cheaper using delete  Impact :  In the removeLiquidity function if the diff value is 0, its cheaper to use delete instead setting the pos, vAsset, vUSD, dToken to zero, this can save +- 3 gas  POC :  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L243-L246  Mitigation :  ```  delete __maker.pos;  delete __maker.vAsset;  delete __maker.vUSD;  delete __maker.dToken; ```  2. Title : its cheaper to save length value to a local variable  Impact : when using a loop, its cheaper to save the length value of an array to a variable, so the loop didn't have to read the storage length in each loop, but comparing with the length that was already save in the local variable. For an array that has a length 10 it can save +- 1800 gas.  POC :  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  3.  Title : its cheaper to use block.timestamp directly   Impact :  Its cheaper to use block.timestamp directly instead calling it through a _blocktimestamp() function.  POC :  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L65 "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/115", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "## Hubble QA Report  Unless otherwise noted, manual auditing and testing were done using Visual Studio Code and Remix. The audit was done from February 17-23, 2022 by ye0lde through code4rena.  Overall, I found the code to be clear to follow and read. I'd recommend the team improve the supporting documentation to give a better overall understanding of the protocol.  - [Findings](#findings)   - [L-1 - No validation of parameter `price` in `setStablePrice` (Oracle.sol)](#l-1---no-validation-of-parameter-price-in-setstableprice-oraclesol)   - [L-2 - Unsafe type cast in `getTwapPrice` (AMM.sol)](#l-2---unsafe-type-cast-in-gettwapprice-ammsol)   - [NC-1 - Typo in `getUnderlyingTwapPrice` (Oracle.sol)](#nc-1---typo-in-getunderlyingtwapprice-oraclesol)  ## Findings    ### L-1 - No validation of parameter `price` in `setStablePrice` (Oracle.sol)  #### Impact The `setStablePrice` function does not do any validation of the `price` parameter before setting `stablePrice[underlying] = price`. While this is a governance function, once `stablePrice[underlying]` is set to any non-zero value this overrides any aggregator calls made to access the current price by function `getUnderlyingPrice` and `getUnderlyingTwapPrice`.  `underlying` is checked but not the `price` itself.  #### Proof of Concept `setStablePrice` is here: https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L169-L172  ``` function setStablePrice(address underlying, int256 price) external onlyGovernance {     requireNonEmptyAddress(underlying);     stablePrice[underlying] = price; } ```  #### Recommended Mitigation Steps Consider adding a check for `price > 0`  ---  ### L-2 - Unsafe type cast in `getTwapPrice` (AMM.sol)  #### Impact `getTwapPrice` performs an unsafe type cast to uint128 without checking if the value actually fits into 128 bits. This typecast doesn't seem to directly lead to an exploit but safe typecasts should still be implemented for additional security.  #### Proof of Concept The type cast is here: https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L392  #### Recommended Mitigation Steps I suggest the following change:  ``` function getTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {     return (_calcTwap(_intervalInSeconds).toInt256());  } ``` ---  ### NC-1 - Typo in `getUnderlyingTwapPrice` (Oracle.sol)  #### Impact Code clarity  #### Proof of Concept The typo is here: https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L53  #### Recommended Mitigation Steps Change `form` to `from`.  --- "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "### G-01: use uint256 for best gas saving  ClearingHouse.sol L#17,18,19,20 MarginAccount.sol L#47  ### G-02: uint256 instead of bool ClearingHouse.sol L#79,250  ### G-04: Prefix increments are cheaper than postfix increments. Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change ClearingHouse.sol L#122,130,170,194,251,263,278 MarginAccount.sol L#331,373,521  ### G-05: immutable instead of constant MarginAccount.sol L#34,15,  ### G-06: use calldata instead of memory  ### G-07: use memory instead of storage  ### G-03: bytes32 instead of string"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# C4-001 : Adding unchecked directive can save gas  ## Impact -  Gas Optimization  Using the unchecked keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen. E.g. 'unchecked' can be applied in the following lines of code since there are require statements before to ensure the arithmetic operations would not cause an integer underflow or overflow. For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  ## Proof of Concept  1. Navigate to the following contract function and lines.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L676 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider applying unchecked arithmetic where overflow/underflow is not possible.  # C4-002 : `> 0 can be replaced with != 0 for gas optimization`  ## Impact -  Gas Optimization  `!= 0` is a cheaper operation compared to `> 0`, when dealing with uint.  ## Proof of Concept  1. Navigate to the following contract function and lines.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L141  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L123  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L199  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L271  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L78 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Use \"!=0\" instead of \">0\" for the gas optimization.  # C4-003 : `++i is more gas efficient than i++ in loops forwarding`  ## Impact -  Gas Optimization  ++i is more gas efficient than i++ in loops forwarding.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L331  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L373  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L521  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L552  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L52  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L65  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L78  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L95  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L120  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L137  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L367 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  It is  recommend to use unchecked{++i} and change i declaration to uint256.   # C4-004 : `Cache array length in for loops can save gas`  ## Impact -  Gas Optimization  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L331  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L373  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L521  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L552 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to cache array length.  # C4-005 : Less than 256 uints are not gas efficient  ## Impact -  Gas Optimization  Lower than uint256 size storage instance variables are actually less gas efficient. E.g. using uint16 does not give any efficiency, actually, it is the opposite as EVM operates on default of 256-bit values so uint16 is more expensive in this case as it needs a conversion. It only gives improvements in cases where you can pack variables together, e.g. structs.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L302 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to review all uint types. Change them with uint256 If the integer is not necessary to present with uint16.`   # C4-006 : State variables could be declared constant  ## Impact -  Gas Optimization  State variables that never change can be declared constant. This can greatly reduce gas costs.  ## Proof of Concept  1. Navigate to the following contract variables.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L20  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L23  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L19 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add the constant keyword for state variables whose value never change.   # C4-007 : Immutable Variables  ## Impact -  Gas Optimization  'immutable' greatly reduces gas costs. There are variables that do not change so they can be marked as immutable to greatly improve the gas costs.  ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/ClearingHouse.sol#L23  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/ClearingHouse.sol#L24   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Mark variables as immutable.   # C4-008 : There is no need to assign default values to variables  ## Impact -  Gas Optimization  When a variable is declared solidity assigns the default value. In case the contract assigns the value again, it costs extra gas.  Example: uint x = 0 costs more gas than uint x without having any different functionality.  ## Proof of Concept  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L331  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L373  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L521  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L552  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L52  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L65  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L78  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L95  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L120  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L137  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/HubbleViewer.sol#L367 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  uint x = 0 costs more gas than uint x without having any different functionality.   # C4-009 : Cache external call results can save gas  ## Impact  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.   ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L25 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Cache external call for the gas optimization.    # C4-010 : Redundant Import  ## Impact - Gas Optimization  Safemath is an unnecessary import in all contracts since it is used solely for development. It can therefore be removed.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L9 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to delete redundant import.  # C4-011 : Gas Optimization on the Public Functions  ## Impact  This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract. Calling each function, we can see that the public function uses 496 gas, while the external function uses only 261.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.  Slither Detector:  external-function:  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L69  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L104  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L108  ## Tools Used  Slither  ## Recommended Mitigation Steps  1. Get Smart Contracts from the Repository. 2. Create a python virtual environment with a stable python version. 3. Install Slither Analyzer on the python VEM. 4. Run Slither against all contracts. 5. Define public functions as an external for the gas optimization.   # C4-012 : Avoid unnecessary SafeCast.toInt256() can save gas  ## Impact  Gas Improvement  ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/ClearingHouse.sol#L332  ## Tools Used  None  ## Recommended Mitigation Steps   Avoid unnecessary SafeCast.toInt256() can save gas   # C4-013 : Use of _msgSender()  ## Impact  The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.  ## Proof of Concept  _msgSender() is utilized three times where msg.sender could have been used in the following function.  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L115  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L140  ## Tools Used  None  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/107", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "## [L1] Add check against parameters `_amount` and `_shares`:  Assessed risk: 1/10  Urgency: N/A  Codebase frequency: 2  ### [L1 - Impact]:  The `amount` that the user deposits is not checked against being `!=0`. It\u2019s a good practice to check arbitrary inputs against being null. Although the transaction would revert anyhow(due to arithmetic error of division `/0`) you should consider adding a check against it. The same goes with parameter `_shares` in the `withdraw()` function.  ### [L1 - References]:   InsuranceFund.sol lines [62](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L62) and [39](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L39)   ### [L1 - Mitigation]:  Adding `require` statements would prevent such operations.  ```bash function deposit(uint _amount) external {      require(_amount !=0, \"IF.deposit.amount_zero\");  ... }  function withdraw(uint _shares) external {     require(_shares !=0, \"IF.withdraw.shares_not_zero\");  ... } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/92", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# C4-001 :  PREVENT DIV BY 0  ## Impact -  LOW  On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn\u2019t done.  Oracle price is not checked. That will cause to revert on the several functions.   ## Proof of Concept  1. Navigate to the following contract.  ```  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L34  ```   ## Tools Used  None  ## Recommended Mitigation Steps  Recommend making sure division by 0 won\u2019t occur by checking the variables beforehand and handling this edge case.  # C4-002 : Single-step change of governance address is extremely risky  ## Impact -  LOW   Single-step change of critical governance address and lack of zero address check is extremely risky. If a zero address or incorrect address (private key not available) is used accidentally, or maliciously changed by a compromised governance account then the entire governance of the protocol is locked forever or lost to an attacker. No governance changes can be made by authorized governance account and protocol will have to be redeployed. The reputation of the protocol will take a huge hit. There may be significant fund lock/loss as well.  Interestingly, this 2-step process is applied to the changing of Strategist address but not Governance address. Governance has more authority in the protocol because it can change the Strategist among other things. So this 2-step should definitely be applied to Governance as well.  Given the magnitude of the impact, i.e. permanent lock of all governance actions, potential lock/loss of funds, and the known/documented failures of wallet opsec, this risk is classified as medium severity.  ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L20  ##\u00a0Tool  Code Review  ## Recommended Mitigation Steps  Change of the most critical protocol address i.e. governance should be timelocked and be a 2-step process: approve+claim in two different transactions, instead of a single-step change.   # C4-003 : Use of Block.timestamp  ## Impact -  Non-Critical  Block timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the Entropy Illusion for further details), locking funds for periods of time, and various state-changing conditional statements that are time-dependent. Miners have the ability to adjust timestamps slightly, which can prove to be dangerous if block timestamps are used incorrectly in smart contracts.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/HubbleBase.sol#L49 ```   ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  Block timestamps should not be used for entropy or generating random numbers\u2014i.e., they should not be the deciding factor (either directly or through some derivation) for winning a game or changing an important state.  Time-sensitive logic is sometimes required; e.g., for unlocking contracts (time-locking), completing an ICO after a few weeks, or enforcing expiry dates. It is sometimes recommended to use block.number and an average block time to estimate times; with a 10 second block time, 1 week equates to approximately, 60480 blocks. Thus, specifying a block number at which to change a contract state can be more secure, as miners are unable to easily manipulate the block number.   # C4-004 : Front-runnable Initializers  ## Impact -  LOW  All contract **initializers** were missing access controls, allowing any user to initialize the contract. By front-running the contract deployers to initialize the contract, the incorrect parameters may be supplied, leaving the contract needing to be redeployed.   ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L93  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L20  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L38  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L121 ```  2. initialize functions does not have access control. They are vulnerable to front-running.   ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  While the code that can be run in contract constructors is limited, setting the owner in the contract's constructor to the `msg.sender` and adding the `onlyOwner` modifier to all **initializers** would be a sufficient level of access control.  # C4-005 : Incompatibility With Rebasing/Deflationary/Inflationary tokens  ## Impact -  LOW  The protocol do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L155  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L29 ```   ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  - Ensure that to check previous balance/after balance  equals to amount for any rebasing/inflation/deflation - Add support in contracts for such tokens before accepting user-supplied tokens - Consider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they don't want to lose them.  # C4-006 : Missing zero-address check in constructors and the setter functions  ## Impact -  LOW  Missing checks for zero-addresses may lead to infunctional protocol, if the variable addresses are updated incorrectly.  ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L19  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L39  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L16  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L35  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L121 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider adding zero-address checks in the discussed constructors: require(newAddr != address(0));.   # C4-007 : Missing events for governor only functions that change critical parameters  ## Impact - Non critical  The governor only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users\u2019 perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in the contracts.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L616  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L19  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L162  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L74  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L722  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L737 ```  See similar High-severity H03 finding OpenZeppelin\u2019s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin\u2019s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)  ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all admin/privileged functions that change critical parameters.  # C4-008 : Deprecated safeApprove() function  ## Impact -  LOW  Detailed description of the impact of this finding.  Using this deprecated function can lead to unintended reverts and potentially the locking of funds. A deeper discussion on the deprecation of this function is in OZ issue #2219 (https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219). The OpenZeppelin ERC20 safeApprove() function has been deprecated, as seen in the comments of the OpenZeppelin code.  ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L24 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  As suggested by the OpenZeppelin comment, replace safeApprove() with safeIncreaseAllowance() or safeDecreaseAllowance() instead.   # C4-009 : The Contract Should Approve(0) first  ## Impact -  LOW  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).approve(address(operator), 0); IERC20(token).approve(address(operator), amount); ```  ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L24 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount.   # C4-0010 : The Contract Should Approve(0) first  ## Impact -  LOW  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).approve(address(operator), 0); IERC20(token).approve(address(operator), amount); ```   ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L24 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount.  # C4-0011 : Missing Pause Modifier On the InsuranceFunds contract  ## Impact -  Low  In case a hack occurs or an exploit is discovered, the team should be able to pause functionality until the necessary changes are made to the system.  The deposits should be paused with Pause modifier.   ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L39 ```  There is no pause mechanism has been defined.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Pause functionality on the contract would have helped secure the funds quickly.   # C4-0012 : Missing Re-entrancy Guard  ## Impact -  Non-critical  The re-entrancy guard is missing on the Eth anchor interaction. The external router interaction can cause to the re-entrancy vulnerability.   ## Proof of Concept  1. Navigate to the following contract functions.  ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L39 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Follow the check effect interaction pattern or put re-entrancy guard."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/89", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Unused import https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AdminProxy.sol#L6-7  # Unresolved todos ``` $ egrep -Rn \"todo\" contracts contracts/AMM.sol:142:        // sending market orders can fk the trader. @todo put some safe guards around price of liquidations contracts/AMM.sol:555:            // @todo handle case when totalPosition = 0 contracts/ClearingHouse.sol:172:            // @todo put checks on slippage contracts/MarginAccount.sol:277:            @todo consider providing some incentive from insurance fund to execute a liquidation in this scenario. ```  # Lack checks to make sure minAllowableMargin >= maintenanceMargin User might get liquidated immediated if maintenanceMargin > minAllowableMargin https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L344 ```     function setParams(         int _maintenanceMargin,         int _minAllowableMargin,         uint _tradeFee,         uint _liquidationPenality     ) external onlyGovernance {         tradeFee = _tradeFee;         liquidationPenalty = _liquidationPenality;         maintenanceMargin = _maintenanceMargin;         minAllowableMargin = _minAllowableMargin;     } ```  # Lack events on critical parameters change https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L344 ```     function setParams(         int _maintenanceMargin,         int _minAllowableMargin,         uint _tradeFee,         uint _liquidationPenality     ) external onlyGovernance {         tradeFee = _tradeFee;         liquidationPenalty = _liquidationPenality;         maintenanceMargin = _maintenanceMargin;         minAllowableMargin = _minAllowableMargin;     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L722 ```     function setAmmState(AMMState _state) external onlyGovernance {         require(ammState != _state, \"AMM.setAmmState.sameState\");         ammState = _state;         if (_state == AMMState.Active) {             nextFundingTime = ((_blockTimestamp() + fundingPeriod) / 1 hours) * 1 hours;         }     }      function syncDeps(address _registry) public onlyGovernance {         IRegistry registry = IRegistry(_registry);         clearingHouse = registry.clearingHouse();         oracle = IOracle(registry.oracle());     }      function setFundingBufferPeriod(uint _fundingBufferPeriod) external onlyGovernance {         fundingBufferPeriod = _fundingBufferPeriod;     } ```  # Lack liquidation events in _liquidateMaker https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L163  # Governance can set the orcale price to arbitary number `price` can be set to any number including negative numbers, which will have serious impact  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L169 ```     function setStablePrice(address underlying, int256 price) external onlyGovernance {         requireNonEmptyAddress(underlying);         stablePrice[underlying] = price;     } ```  # Lack chainlink oracle sanity check Recommened to uncoment the sanity check https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L166  # Fund frozen on Oracle malfunction If Oracle malfunction, most fund in the protocol would be frozen "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "  # 1. Loops can be more efficient  ## Impact  The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas. ## Proof of Concept ``` function settleFunding() override external whenNotPaused {         for (uint i = 0; i < amms.length; i++) {             amms[i].settleFunding();         }     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L130  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L170  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L251  The same situation are in other scope contracts where loops use.  Remix ## Recommended Mitigation Steps  Remove explicit 0 initialization of for loop index variable.                    # 2. Cache array length in for loops can save gas # Vulnerability details ## Impact Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack. Caching the array length in the stack saves around 3 gas per iteration. ## Proof of Concept ``` function settleFunding() override external whenNotPaused {         for (uint i = 0; i < amms.length; i++) {             amms[i].settleFunding();         }     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L130  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L170  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L251  The same situation are in other scope contracts where loops use. ## Tools  Manual ## Recommended Mitigation Steps Caching len = amms.length and using the len instead will save gas.                    ## 3. Prefix increments are cheaper than postfix increments (i++)  ## Impact There is no risk of overflow caused by increamenting the iteration index in for loops. Increments perform overflow checks that are not necessary in this case.  ## Proof of Concept ``` function settleFunding() override external whenNotPaused {         for (uint i = 0; i < amms.length; i++) {             amms[i].settleFunding();         }     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L130  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L170  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L251  The same situation are in other scope contracts where loops use.  ## Tools  Remix  ## Recommended Mitigation Steps Surround the increment expressions with an unchecked { ... } block to avoid the default overflow checks                     # 4. Long Revert Strings   ## Impact Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met. ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L101  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L354  There are several other places throughout the codebase where the same optimization can be used.   ## Tools  https://planetcalc.com/9029/ ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.       # 5. > 0 can be replaced with != 0 for gas optimisation # Vulnerability details ## Impact != 0 is a cheaper operation compared to > 0, when dealing with uint. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L574 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L211  There are several other places throughout the codebase where the same optimization can be used.   Remix ## Recommended Mitigation Steps   # 6. Change string to byteX if possible # Vulnerability details  ## Impact In the `AMM.sol`, declaring the type bytes32 can save gas. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L28  https://medium.com/layerx/how-to-reduce-gas-cost-in-solidity-f2e5321e0395#2a78 ## Recommended Mitigation Steps  # 7. Struct layout in AMM.sol ## Impact `ReserveSnapshot` struct in `AMM.sol` can be optimized to reduce 2 storage slot ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L61-L62 ``` struct ReserveSnapshot {         uint256 lastPrice;         uint256 timestamp;         uint256 blockNumber;     } ``` `timestamp`  and `blockNumber` store block numbers, and 2^128 is be enough for a very long time. ## Tools  https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html?highlight=Structs#layout-of-state-variables-in-storage ## Recommended Mitigation Steps Change the struct as suggested above ``` struct ReserveSnapshot {         uint256 lastPrice;         uint128 timestamp;         uint128 blockNumber;     } ``` # 8. Adding unchecked directive can save gas  ## Impact For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L726 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L212 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L175-L177 ``` require(margin[idx][trader] >= amount.toInt256(), \"Insufficient balance\"); margin[idx][trader] -= amount.toInt256(); ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L73 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L81  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L370 ``` uint256 minNextValidFundingTime = _blockTimestamp() + fundingBufferPeriod; ```  ## Recommended Mitigation Steps Consider using 'unchecked' where it is safe to do so.  # 9. Caching variables  ## Impact Some of the variable can be cached to slightly reduce gas usage. ## Proof of Concept   `vamm`  can be cached. https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L188-L195  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L486-L501  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L510-L525  `_blockTimestamp()` can be cahed   https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L656-L704  `vusd` can be cashed  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L572-L579  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L581-L593   ## Tools  Remix ## Recommended Mitigation Steps Consider caching those variable for read and make sure write back to storage      # 10. Placement of require statements ## Impact The require statement in the  `function initialize()` can be placed earlier to reduce gas usage on revert. ## Proof of Concept  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L51  ``` function initialize(         address _governance,         address _insuranceFund,         address _marginAccount,         address _vusd,         int256 _maintenanceMargin,         int256 _minAllowableMargin,         uint _tradeFee,         uint _liquidationPenalty     ) external initializer {         _setGovernace(_governance);          insuranceFund = IInsuranceFund(_insuranceFund);         marginAccount = IMarginAccount(_marginAccount);         vusd = VUSD(_vusd);          require(_maintenanceMargin > 0, \"_maintenanceMargin < 0\");         maintenanceMargin = _maintenanceMargin;         minAllowableMargin = _minAllowableMargin;         tradeFee = _tradeFee;         liquidationPenalty = _liquidationPenalty;     } ```  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/Oracle.sol#L48  ```  function getUnderlyingTwapPrice(address underlying, uint256 intervalInSeconds)         virtual         public         view         returns (int256)     {         if (stablePrice[underlying] != 0) {             return stablePrice[underlying];         }         AggregatorV3Interface aggregator = AggregatorV3Interface(chainLinkAggregatorMap[underlying]);         requireNonEmptyAddress(address(aggregator));         require(intervalInSeconds != 0, \"interval can't be 0\");  ```  ## Tools  Remix ## Recommended Mitigation Steps Relocate the said require statement   # 11. Constant is being assigned its default value.  ## Impact The constant variable is being assigned its default value which is unnecessary. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L31 ``` uint constant VUSD_IDX = 0; ``` ## Recommended Mitigation Steps Remove the assignment.  # 12. Checking non-zero value can avoid an external call to save gas Checking if `_amount > 0 `before making the external call to `vusd.safeTransferFrom()` can save 2600 gas by avoiding the external call in such situations. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L51 ## Recommended Mitigation Steps Add check   # 13. function decimals() can be refactored to a constant variable ## Impact function `decimals()` just returns a constant of uint8(6). To save some gas and improve the readability this can be extracted to a constant variable and used where necessary. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/VUSD.sol#L69 ``` function decimals() public pure override returns (uint8) {         return 6;     } ``` ## Recommended Mitigation Steps  # 14. Avoid use of state variables in event emissions to save gas ## Impact Where possible, use equivalent function parameters or local variables in event emits instead of state variables to prevent expensive SLOADs. Post-Berlin, SLOADs on state variables accessed first-time in a transaction increased from 800 gas to 2100, which is a 2.5x increase. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L205 https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L381  ``` function realizePnL(address trader, int256 realizedPnl)         override    external       onlyClearingHouse    {            if (realizedPnl != 0) {             margin[VUSD_IDX][trader] += realizedPnl;             emit PnLRealized(trader, realizedPnl, _blockTimestamp());         }   ```  ## Recommended Mitigation Steps Use equivalent function parameters or local variables in event emits instead of state variables.  # 15. Unnecessary indirection to access block.timestamp value ## Impact `_blockTimestamp()` returns the block.timestamp value in `AMM` contract. This internal call only to get value of block.timestamp seems unnecessary because there isn\u2019t any other way of getting current time on the blockchain which justifies moving this to a separate function for modularity. Adds an additional jump and other supporting bytecode of making the internal call which increase gas usage unnecessarily. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L652 ``` function _blockTimestamp() internal view virtual returns (uint256) {         return block.timestamp;     } ``` Recommended Mitigation Steps Use block.timestamp directly to save a little gas by avoiding this unnecessary indirection.  # 16. Consider making some constants as non-public to save gas ## Impact Each function part of contract's external interface is part of the function dispatch, i.e., every time a contract is called, it goes through a switch statement (a set of eq ... JUMPI blocks in EVM) matching the selector of each externally available functions with the chosen function selector (the first 4 bytes of calldata). This means that any unnecessary function that is part of contract's external interface will lead to more gas for (almost) every single function calls to the contract. There are several cases where constants were made public. This is unnecessary; the constants can simply be readfrom the verified contract, i.e., it is unnecessary to expose it with a public function. ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L15-L17    # 17. Gas Optimization on the Public Function ## Impact This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract.  ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/VUSD.sol#L69  ## Recommended Mitigation Steps The function  `decimals() public` could be set external instead of public.   # 18. Use Custom Errors to save Gas ## Impact Custom errors from Solidity 0.8.4 are cheaper than revert strings. ## Proof of Concept Source: https://blog.soliditylang.org/2021/04/21/custom-errors/: Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert(\"Insufficient funds.\");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them. Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  ## Recommended Mitigation Steps Replace revert strings with custom errors. # 19. && operator can use more gas ## Impact More expensive gas usage ## Proof of Concept https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L461 ``` require(idx > VUSD_IDX && idx < supportedCollateral.length, \"collateral not seizable\"); ```  ## Tools Used ## Recommended Mitigation Steps Instead of using operator && on single require check  using double require check can save more gas  # 20. Use  `10 ** DECIMALS` for constant ## Impact More expensive gas usage ## Proof of Concept ``` uint8 constant DECIMALS = 6; uint constant PRECISION = 10 ** DECIMALS; ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L17  ## Recommended Mitigation Steps Change to: ``` uint constant PRECISION = 1e6; ```"}, {"title": "Update initializer modifier to prevent reentrancy during initialization", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/81", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/package.json#L17 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L5 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L24   # Vulnerability details  ## Impact  While Governable.sol is out of scope, I figured this issue would still be fair game.  The solution uses: `\"@openzeppelin/contracts\": \"4.2.0\"`. This dependency has a known high severity vulnerability: https://security.snyk.io/vuln/SNYK-JS-OPENZEPPELINCONTRACTS-2320176 Which makes this contract vulnerable: ``` File: Governable.sol 05: import { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\"; ... 24: contract Governable is VanillaGovernable, Initializable {} ```  This contract is inherited at multiple places: ``` contracts/AMM.sol:   11: contract AMM is IAMM, Governable {  contracts/InsuranceFund.sol:   13: contract InsuranceFund is VanillaGovernable, ERC20Upgradeable {  contracts/Oracle.sol:   11: contract Oracle is Governable {  contracts/legos/HubbleBase.sol:   15: contract HubbleBase is Governable, Pausable, ERC2771Context {  contracts/ClearingHouse.sol:   11: contract ClearingHouse is IClearingHouse, HubbleBase {  contracts/MarginAccount.sol:   25: contract MarginAccount is IMarginAccount, HubbleBase { ```   \u00ecnitializer()` is used here: ``` contracts/AMM.sol:   99:     ) external initializer {  contracts/ClearingHouse.sol:   44:     ) external initializer {  contracts/MarginAccount.sol:   124:     ) external initializer {  contracts/Oracle.sol:   20:     function initialize(address _governance) external initializer {  ```  ## Recommended Mitigation Steps Upgrade `@openzeppelin/contracts` to version 4.4.1 or higher.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Hubble contest Gas Optimization   1 use initial value to save gas for uint.      https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L52  uint shares;   2 use cache for array length to save gas.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277      3 Delete unused variable. It seems that the following variable will be not used in this construct and other contracts. If it is not used, you can delete it to save gas.   https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L22      4 Avoid extra mstore.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L121 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L141 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L614   isNewPosition and isLongPosition are used only one time in   https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L123 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L143   https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L616 You can use position.size == 0 and position.size > 0 directly there to save gas.  if (position.size == 0 || (position.size > 0 ? Side.LONG : Side.SHORT) == side) { if (position.size > 0) {  5 Use msg.sender instead of _msgSender() to save gas.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L65 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L69 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L98 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L113 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L214     6 Delete unused import statements in AMM.sol  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L5  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L9 "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Hubble contest  1 Change order of the modifier of functions.  According to solidity doc order of the modifier must be             1 Visibility 2 Mutability 3Virtual 4 Override 5 Custom modifiers In functions, the order is a little different. For example,  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L64 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L242  and so on.    2 missing input validation.  Input _governance is not checked in initialize whether it is empty or not. Nobody can have control as governance if it will be set with an empty address.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L34-L37     3 Use naming convention for constant variables  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L15-L16  uint256 public constant SPOT_PRICE_TWAP_INTERVAL = 1 hours; Uint256 public constant FUNDING_PERIOD = 1 hours;     4 Delete unused return value variable name in getCloseQuote.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L449     5 Input validation must be checked.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L148-L151  add   require(isMaker(trader), 'describe something');     6 Delete unnecessary variables.  In getTotalNotionalPositionAndUnrealizedPnl return values are defined, so following variables must be unnecessary.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L275-L276 "}, {"title": "USDC blacklisted accounts can DoS the withdrawal system", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/76", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67   # Vulnerability details  ## Impact DoS of USDC withdrawal system  ## Proof of Concept Currently, withdrawals are queued in an array and processed sequentially in a for loop. However, a `safeTransfer()` to USDC blacklisted user will fail. It will also brick the withdrawal system because the blacklisted user is never cleared.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67  ## Tools Used Manual review  ## Recommended Mitigation Steps Possible solutions: 1st solution: Implement 2-step withdrawals:     - In a for loop, increase the user's amount that can be safely withdrawn.     - A user himself withdraws his balance  2st solution: Skip blacklisted users in a processWithdrawals loop  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# QA Report  # Low Findings  ## L01: Add modifiers to ensure that dependencies are synced  ### Description  The `syncDeps` function exists in the AMM, InsuranceFund and MarginAccount contracts as a helper function to sync the shared contract addresses between the Registry contract. It does not however ensure that all contracts are actually in synced i.e. if the Registry contract changes, there are no checks to ensure that the addresses are still in sync.  ## L02: Adhere to the Check Effect Interactions pattern best practice  ### Line References  [https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L62-L64](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L62-L64)  ### Description  Update internal state before transferring tokens out.  # Non-Critical Findings  ## NC01: Avoid rebase tokens  ### Line References  [https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L548](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L548)  ### Description  Be mindful when adding collateral as some token implementations e.g. rebase tokens are not handled by the smart contract.  ## NC02: Incorrect comment for `_getLiquidationInfo`  ### Line References  [https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L458](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L458)  ### Description  `_getLiquidationInfo` doesn\u2019t actually revert. It is the parent liquidation function that reverts if it receives a `LiquidationStatus` that is not `IS_LIQUIDATABLE`.  ## NC03: Add a rescue token / ETH function  ### Description  In the event ETH / tokens are mistakenly sent to the contracts, it is possible to withdraw them through a `rescueToken` or `rescueETH` function. This function can only be called by governance."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "### Using memory copies of storage variables when repeated access is required uses less gas `credit` should be copied ```solidity         if (credit > 0) {             uint toBurn = Math.min(vusd.balanceOf(address(this)), credit);             credit -= toBurn; ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L574-L576   ### Functions not called by the contract itself should be `external` rather than `public` ```solidity function getUnderlyingTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {         ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L387  ```solidity function liquidateMaker(address maker) override public whenNotPaused {          ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L148  ```solidity function liquidateTaker(address trader) override public whenNotPaused {          ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L153  ```solidity function syncDeps(IRegistry _registry) public onlyGovernance {           ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L116  ```solidity function getNormalizedMargin(address trader) override public view returns(int256 weighted) {        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L509  ```solidity function syncDeps(address _registry, uint _liquidationIncentive) public onlyGovernance {         ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L599   ### `require()` strings longer than 32 bytes cost extra gas ```solidity require(baseAssetQuantity > 0, \"VAMM._longbaseAssetQuantity is <= 0\");                  ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L487  ```solidity require(baseAssetQuantity < 0, \"VAMM._shortbaseAssetQuantity is >= 0\");                  ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L511  ```solidity require(margin[VUSD_IDX][trader] >= 0, \"Cannot remove margin when vusd balance is negative\");              ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L174  ```solidity require(notionalPosition == 0, \"Liquidate positions before settling bad debt\");                ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L354  ```solidity require(repay <= maxRepay, \"Need to repay more to seize that much\");              ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L453  ```solidity require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this timeNot enough balance');              ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L55  ```solidity require(isAboveMinAllowableMargin(trader), \"CHBelow Minimum Allowable Margin\");                    ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L84  ```solidity require(isAboveMinAllowableMargin(maker), \"CHBelow Minimum Allowable Margin\");                    ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L101  ```solidity require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"HubbleErc20.allowTransfers.noAuth\");                      ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/ERC20Mintable.sol#L32  ```solidity require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"HubbleErc20.allowTransfers.noAuth\");                      ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/ERC20Mintable.sol#L60  ```solidity require(prices[underlying] != 0, \"underlying price has not been set as yet\");              ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/TestOracle.sol#L20  ```solidity require(twapPrices[underlying] != 0, \"underlying twap price has not been set as yet\");             ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/TestOracle.sol#L33   ### Using `> 0` costs more gas than `!= 0` when used in on uints in a `require()` statement ```solidity require(amount > 0, \"Add non-zero margin\");           ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L150  ```solidity require(_round > 0, \"Not enough history\");           ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L153   ### Splitting `require()` statements that use `&&` saves gas See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) for an example ```solidity require(idx > VUSD_IDX && idx < supportedCollateral.length, \"collateral not seizable\");       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol   ### It costs more gas to initialize variables to zero than to let the default of zero be applied ```solidity uint constant VUSD_IDX = 0;            ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L31  ```solidity for (uint i = 0; i < idxs.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L331  ```solidity for (uint i = 0; i < assets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L521  ```solidity for (uint i = 0; i < _collaterals.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L552  ```solidity uint constant VUSD_IDX = 0;            ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccountHelper.sol#L13  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170  ```solidity for (uint i = 0; i < amms.length; i++) { // liquidate all positions   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L251  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277  ```solidity uint shares = 0;             ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L52  ```solidity uint constant VUSD_IDX = 0;            ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L15  ```solidity for (uint i = 0; i < len; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L52  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L65  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L78  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L95  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L120  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L137  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L9  ```solidity uint256 total = 0;             ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L17  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L18  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L21  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L27  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L32  ```solidity for (uint i = 0; i < numTraders; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L43  ```solidity for (uint j = 0; j < l; j++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L45  ```solidity for (uint i = 0; i < targets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Executor.sol#L19  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L25  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L31  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L37   ### `<array>.length` should not be looked up in every loop of a for-loop Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length ```solidity for (uint i = 0; i < idxs.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L331  ```solidity for (uint i = 1 /* skip vusd */; i < assets.length; i++) {   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L373  ```solidity for (uint i = 0; i < assets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L521  ```solidity for (uint i = 0; i < _collaterals.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L552  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170  ```solidity for (uint i = 0; i < amms.length; i++) { // liquidate all positions   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L251  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L65  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L78  ```solidity for (uint i = 1; i < length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L367  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L9  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L18  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L21  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L27  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L32  ```solidity for (uint i = 0; i < targets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Executor.sol#L19  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L25  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L31  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L37   ### `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in for- and while-loops ```solidity for (uint i = 0; i < idxs.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L331  ```solidity for (uint i = 1 /* skip vusd */; i < assets.length; i++) {   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L373  ```solidity for (uint i = 0; i < assets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L521  ```solidity for (uint i = 0; i < _collaterals.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L552  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170  ```solidity for (uint i = 0; i < amms.length; i++) { // liquidate all positions   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L251  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L277  ```solidity for (uint i = 0; i < len; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L52  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L65  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L78  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L95  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L120  ```solidity for (uint i = 0; i < l; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L137  ```solidity for (uint i = 1; i < length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/HubbleViewer.sol#L367  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L9  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L18  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L21  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L27  ```solidity for (uint256 i = 0; i < recipients.length; i++)        ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Disperse.sol#L32  ```solidity for (uint i = 0; i < numTraders; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L43  ```solidity for (uint j = 0; j < l; j++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Leaderboard.sol#L45  ```solidity for (uint i = 0; i < targets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/Executor.sol#L19  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L25  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L31  ```solidity for (uint i = 0; i < traders.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/tests/BatchLiquidator.sol#L37   ### `++i` costs less gas than `++i`, especially when it's used in for-loops (`--i`/`i--` too) ```solidity for (uint i = 0; i < idxs.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L331  ```solidity for (uint i = 1 /* skip vusd */; i < assets.length; i++) {   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L373  ```solidity for (uint i = 0; i < assets.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L521  ```solidity for (uint i = 0; i < _collaterals.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L552  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L122  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L130  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L170  ```solidity for (uint i = 0; i < amms.length; i++) { // liquidate all positions   ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L194  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L251  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L263  ```solidity for (uint i = 0; i < amms.length; i++) {       ``` https://github.c"}, {"title": "Users are able to front-run bad debt settlements to avoid insurance costs", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L71-L75 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L62-L69   # Vulnerability details  ## Impact  A user is able to front-run the call to `seizeBadDebt()` in `InsuranceFund.sol` to avoid paying the insurance costs.  `seizeBadDebt()` is called by `MarginAccount.settleBadDebt()` which is a public function. When this functions is called the transaction will appear in the mem pool.  A user may then call `InsuranceFund.withdraw()` to withdraw all of their shares. If they do this with a higher gas fee it will likely be processed before the `settleBadDebt()` transaction. In this way they will avoid incurring any cost from the assets being seized.  The impact is that users may gain their share of the insurance funding payments with minimal risk (minimal as there is a change the front-run will not succeed) of having to repay these costs.  ## Proof of Concept  ```     function withdraw(uint _shares) external {         settlePendingObligation();         require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");         uint amount = balance() * _shares / totalSupply();         _burn(msg.sender, _shares);         vusd.safeTransfer(msg.sender, amount);         emit FundsWithdrawn(msg.sender, amount, block.timestamp);     } ```  ```     function seizeBadDebt(uint amount) external onlyMarginAccount {         pendingObligation += amount;         emit BadDebtAccumulated(amount, block.timestamp);         settlePendingObligation();     } ```  ## Recommended Mitigation Steps  Consider making the withdrawals a two step process. The first step requests a withdrawal and marks the time. The second request processes the withdrawal but requires a period of time to elapse since the first step.  To avoid having users constantly having pending withdrawal, each withdrawal should have an expiry time and also a recharge time. The if the second step is not called within expiry amount of time it should be considered invalid. The first step must not be able to be called until recharge time has passed.  Another solution involves a design change where the insurance fund is slowly filled up over time without external deposits. However, this has the disadvantage that bad debts received early in the protocols life time may not have sufficient insurance capital to cover them.  "}, {"title": "AMM Cannot Be `initialize()` Except By Governance", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L93-L108 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L730-L734 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L10-L13   # Vulnerability details  ## Impact  The contact `AMM.sol` cannot be initialize unless it is called from the `_governance` address.  This prevents the use of a deployer account and requires the governance to be able to deploy proxy contracts and encode the required arguements. If this is not feasible then the contract cannot be deployed.  ## Proof of Concept  `initialize()` calls `_setGovernace(_governance);` which will store the governance address.   Following this it will call `syncDeps(_registry);` which has `onlyGovernance` modifier.  Thus, if the `msg.sender` of `initialize()` is not the same as the parameter `_governance` then the initialisation will revert.   ```solidity     function initialize(         address _registry,         address _underlyingAsset,         string memory _name,         address _vamm,         address _governance     ) external initializer {         _setGovernace(_governance);          vamm = IVAMM(_vamm);         underlyingAsset = _underlyingAsset;         name = _name;         fundingBufferPeriod = 15 minutes;          syncDeps(_registry);     } ```  ## Recommended Mitigation Steps  Consider adding the steps manually to `initialize()`. i.e.  ```solidity     function initialize(         address _registry,         address _underlyingAsset,         string memory _name,         address _vamm,         address _governance     ) external initializer {         _setGovernace(_governance);          vamm = IVAMM(_vamm);         underlyingAsset = _underlyingAsset;         name = _name;         fundingBufferPeriod = 15 minutes;          IRegistry registry = IRegistry(_registry);         clearingHouse = registry.clearingHouse();         oracle = IOracle(registry.oracle()); } ```  "}, {"title": "ClearingHouse May Whitelist Duplicate AMMs", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L339-L342 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L269-L282   # Vulnerability details  ## Impact  `ClearingHouse.sol` allows the Governance protocol to whitelist `AMM.sol` contracts. These contracts allow users to earn profits based on the price of a base asset against a quote asset.  It is possible to add the same `AMM` twice in the function `whitelistAmm()`. The impact is that unrealized profits will be counted multiple times. As a result the liquidation calculations will be incorrect, potentially allowing users to trade while insolvent or incorrectly liquidating solvent users.  Note `whitelistAmm()` may only be called by Governance.  ## Proof of Concept  The function `getTotalNotionalPositionAndUnrealizedPnl()` will iterate over all `amms` summing the `unrealizedPnl`  and `notinoalPosition`, thus if an `amm` is repeated the `unrealizedPnl` and `notionalPosition` of that asset will be counted multiple times.  This is used in `_calcMarginFraction()` which calculates a users margin as a fraction of the total position. The margin fraction is used to determine if a user is liquitable or is allowed to open new positions.   ## Recommended Mitigation Steps  Consider ensuring the `AMM` does not already exist in the list when adding a new `AMM`.  ```     function whitelistAmm(address _amm) external onlyGovernance {         for (uint256 i; i < amm.length; i++) {             require(amm[i] != IAMM(_amm), \"AMM already whitelisted\");         }         emit MarketAdded(amms.length, _amm);         amms.push(IAMM(_amm));     } ```  "}, {"title": "Liquidations can be run on the bogus Oracle prices", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L24-L35   # Vulnerability details  ## Impact  If the price feed is manipulated in any way or there is any malfunction based volatility on the market, a malicious user can use this to liquidate a healthy position.  An attacker can setup a monitoring of the used Oracle feed and act on observing a price outbreak (for example, zero price, which is usually a subject to filtration), liquidating the trader position which is perfectly healthy otherwise, obtaining the collateral with a substantial discount at the expense of the trader.  The same is for a flash crash kind of scenario, i.e. a price outbreak of any nature will allow for non-market liquidation by an attacker, who has the incentives to setup such a monitoring and act on such an outbreak, knowing that it will not be smoothed or filtered out, allowing a liquidation at a non-market price that happen to be printed in the Oracle feed  ## Proof of Concept  Oracle.getUnderlyingPrice just passes on the latest Oracle answer, not checking it anyhow:  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L24-L35  It is then used in liquidation triggers providing isLiquidatable and _getLiquidationInfo functions:  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L249  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L465  ## Recommended Mitigation Steps  Add a non-zero Oracle price check, possibly add an additional Oracle feed information usage to control that the price is fresh. Please consult the Chainlink for that as OCR introduction might have changed the state of the art approach (i.e. whether and how to use latestRoundData returned data):  https://docs.chain.link/docs/off-chain-reporting/  Regarding any price spikes it is straightforward to construct a mitigation mechanics for such cases, so the system will be affected by sustainable price movements only.  As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.  One of the approaches is to track both current and TWAP prices, and condition all state changing actions, including liquidations, on the current price being within a threshold of the TWAP one. If the liquidation margin level is conservative enough and TWAP window is small enough this is safe for the overall stability of the system, while providing substantial mitigation mechanics by allowing state changes on the locally calm market only.  Another approach is to introduce time delay between liquidation request and actual liquidation. Again, conservative enough margin level plus small enough delay keeps the system safe, while requiring that market conditions allow for liquidation both at request time and at execution time provides ample filtration against price feed outbreaks   "}, {"title": "`Oracle.getUnderlyingPrice` could have wrong decimals", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L34   # Vulnerability details  ## Impact The `Oracle.getUnderlyingPrice` function divides the chainlink price by `100`. It probably assumes that the answer for the underlying is in 8 decimals but then wants to reduce it for 6 decimals to match USDC.  However, arbitrary `underlying` tokens are used and the chainlink oracles can have different decimals.  ## Recommended Mitigation Steps While most USD price feeds use 8 decimals, it's better to take the on-chain reported decimals into account by doing `AggregatorV3Interface(chainLinkAggregatorMap[underlying]).decimals()`, see [Chainlink docs](https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination). The price should then be scaled down to 6 decimals.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/32", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L344-L354 https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L15-L21   # Vulnerability details  When fees/margin or governance are involved it's important to emit events for off-chain monitors/tools to be able to react if necessary.  ## Impact Automated tools especially need all relevant ancillary data to be emitted in order to efficiently react to it. An automated bot trading with the hubble exchange will not be able to see changes to fee/margin changes in real time, and may submit orders which cause it to miscalculate P&L, causing it to lose capital. This is especially true because the contracts do not use timelocks for changes. See [these](https://github.com/code-423n4/2021-06-tracer-findings/issues/64) [examples](https://github.com/code-423n4/2021-09-swivel-findings/issues/101) [where](https://blog.openzeppelin.com/uma-audit-phase-4/) [similar](https://blog.openzeppelin.com/audius-contracts-audit/#high) findings have been flagged as medium/high-severity issues.  ## Proof of Concept ```solidity     function setParams(         int _maintenanceMargin,         int _minAllowableMargin,         uint _tradeFee,         uint _liquidationPenality     ) external onlyGovernance {         tradeFee = _tradeFee;         liquidationPenalty = _liquidationPenality;         maintenanceMargin = _maintenanceMargin;         minAllowableMargin = _minAllowableMargin;     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/ClearingHouse.sol#L344-L354  ```solidity     function setGovernace(address _governance) external onlyGovernance {         _setGovernace(_governance);     }      function _setGovernace(address _governance) internal {         governance = _governance;     } ``` https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L15-L21  The `onlyGovernance` modifier does not emit events ```solidity     address public governance;      modifier onlyGovernance() {         require(msg.sender == governance, \"ONLY_GOVERNANCE\");         _;     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/legos/Governable.sol#L8-L13  The provided deployment script [only uses a signer](https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/scripts/deploy.js#L18) rather than a contract as the governance address. Furthermore, the live environment deployed on testnet has a [deployed](https://testnet.snowtrace.io/address/0x089f4f3b4aedc41d6ffd4908f4ff32e6a915996b) `InsuranceFund` which uses the `onlyGovernance` modifier... ```solidity     function syncDeps(IRegistry _registry) public onlyGovernance {         vusd = IERC20(_registry.vusd());         marginAccount = _registry.marginAccount();     } ``` https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L116-L119  ...and the only transaction interacting with this function appears [here](https://testnet.snowtrace.io/tx/0x31d395e69753469c86a7ed9ab817f15c6a6362ebe31397373daabc83f24d567c) and is called by an [address](https://testnet.snowtrace.io/address/0x835ce0760387bc894e91039a88a00b6a69e65d94), not a contract. There are no other transactions to the insurance fund to change the governance address, so it's clear that the testnet does not use an emitting governor either.  ## Tools Used Code inspection Hardhat snowtrace.io  ## Recommended Mitigation Steps Emit events for these changes   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "## Withdrawals can stuck  1. Consider processWithdrawals function at VUSD.sol#L53 2. Assume contract has balance of 100 3. Withdrawal request are 101,10,20,30 4. processWithdrawals function is called 5. Function fail since contract does not have 101 balance 6. But due to this the remaining transaction also get blocked 10,20,30 for which contract had sufficient balance  Recommendation: If contract does not have balance for particular withdrawal instance, keep that in pending object and try to complete the remaining ones  ## Withdraw timelock missing  1. The withdraw function at VUSD.sol#L48 is not placing any timelock which means user can call withdraw function frequently and push them into withdrawals object. This can delay other user withdrawal which are placed in long queue back and since processWithdrawals can only process maxWithdrawalProcesses at one run, other user withdrawal may delay  Recommendation: There should be a timelock after which withdraw can be called again otherwise this can be called repeatedly for small amounts If user has requested withdraw then he should only be able to call this function again after x timestamp  ## Shares can give lower value  1. Consider withdraw function at InsuranceFund.sol#L62  2. if some big bad debt comes (seizeBadDebt at MarginAccount.sol#L368) then settlePendingObligation function which is called at withdraw function will consume most contract balance. This will reduce amount in balance()  3. Since withdraw amount is directly proportional to balance (uint amount = balance() * _shares / totalSupply();) so same shares will give less amount  ## Missing Oracle price checks  1. In getLatestRoundData function at Oracle.sol#L115, there is no check to see if returned price of _aggregator.latestRoundData() is not stale. More details at https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  Recommendation: Modify the function as below:  ``` (uint80 round, int256 latestPrice, , uint256 latestTimestamp, uint80 answeredInRound) = _aggregator.latestRoundData(); require(feedPrice > 0, \"Chainlink price <= 0\");  require(answeredInRound >= round, \"Stale price\"); require(latestTimestamp != 0, \"Round not complete\"); ```  ## Input validation missing  1. It was observed that price can be set to 0 in setStablePrice function at Oracle.sol#L169. This is incorrect since the contract checks stablePrice[underlying] != 0 in other functions like getUnderlyingPrice.   Recommendation: Add below check  ``` function setStablePrice(address underlying, int256 price) external onlyGovernance { require(price!=0,\"Invalid price\")         requireNonEmptyAddress(underlying);         stablePrice[underlying] = price;     } ```  ## Incorrect condition can give incorrect price  1. The getUnderlyingTwapPrice function at Oracle.sol#L67 is returning latestPrice when latestTimestamp < baseTimestamp.   2. Else it would goto previous rounds  3. This is incorrect. This function should return latestPrice when latestTimestamp = baseTimestamp  Recommendation: Modify the check like below  ``` if (latestTimestamp <= baseTimestamp || round == 0) {             return formatPrice(latestPrice);         } ```  ## Zero address checks are missing   1. For all address arguments at constructor of Registry.sol#L12. Add below require  ``` require(_oracle!=address(0), \"Invalid address\"); require(_clearingHouse!=address(0), \"Invalid address\"); require(_insuranceFund!=address(0), \"Invalid address\"); require(_marginAccount!=address(0), \"Invalid address\"); require(_vusd!=address(0), \"Invalid address\"); ```  2. Initialize function at AMM.sol#L93, add below require  ``` require(_registry!=address(0), \"Invalid address\"); require(_underlyingAsset!=address(0), \"Invalid address\"); require(_vamm!=address(0), \"Invalid address\"); ```  3.  Initialize function at ClearingHouse.sol#L35, add below require  ``` require(_insuranceFund!=address(0), \"Invalid address\"); require(_marginAccount!=address(0), \"Invalid address\"); require(_vusd!=address(0), \"Invalid address\"); ```  4. In getUnderlyingPrice function, check aggregator is non empty address  ``` function getUnderlyingPrice(address underlying)         virtual         external         view         returns(int256 answer)     { AggregatorV3Interface aggregator = AggregatorV3Interface(chainLinkAggregatorMap[underlying]); requireNonEmptyAddress(address(aggregator));         ...     } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "1. In processWithdrawals function at VUSD.sol#L64, modify i+=1 to ++i  2. In processWithdrawals function at VUSD.sol#L63, use unchecked at reserve -= withdrawal.amount; since we already know that reserve > withdrawal.amount  3. In withdraw function at VUSD.sol#L48, add a check require(amount!=0, \"Invalid amount\");  4. In mintWithReserve function at VUSD.sol#L43, add below require  ``` require(amount!=0, \"Invalid amount\"); require(to!=address(0), \"Invalid address\"); ```  5. getRoundData function at Oracle.sol#L124 is not required. Simply change the if(latestPrice < 0) to while(latestPrice < 0) at Oracle.sol#L117 which will eliminate the need of getRoundData function  ``` function getLatestRoundData(AggregatorV3Interface _aggregator)         internal         view         returns (             uint80,             uint256 finalPrice,             uint256         )     {         (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.latestRoundData();         finalPrice = uint256(latestPrice);         while (latestPrice < 0) {             requireEnoughHistory(round);             (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);         }         return (round, finalPrice, latestTimestamp);     } ```  6. In deposit function at InsuranceFund.sol#L39, add a condition require(amount!=0, \"Invalid amount\")  7. In withdraw function at InsuranceFund.sol#L62, add a check require( _shares!=0,\"Invalid shares\");  8. In liquidate function at ClearingHouse.sol#L140, updatePositions function is not required since this is already called in _liquidateMaker and _liquidateTaker function  9. In addMarginFor function at MarginAccount.sol#L149, add new check   ``` require(idx >= supportedCollateral.length,\"Invalid index\"); ```  10. In removeMargin function at MarginAccount.sol#L177, margin[idx][trader] -= amount.toInt256(); can be unchecked since contract has already checked margin[idx][trader] >= amount.toInt256()  11. In removeMargin function at MarginAccount.sol#L168, add a check require(amount!=0,\"Invalid amount\");  12. In settleBadDebt function at MarginAccount.sol#L362, modify require(vusdBal < 0, \"Nothing to repay\"); to require(vusdBal <= 0, \"Nothing to repay\"); since if vusdBal is 0 then also there is nothing to repay  13. In weightedAndSpotCollateral function at MarginAccount.sol#L524 add a check to see margin[i][trader]==0 as shown below  ``` function weightedAndSpotCollateral(address trader)         public         view         returns (int256 weighted, int256 spot)     {         ...          for (uint i = 0; i < assets.length; i++) {             _collateral = assets[i];   if(margin[i][trader]==0){continue}             int numerator = margin[i][trader] * oracle.getUnderlyingPrice(address(assets[i].token));             ...         }     } ```  14. In liquidateFlexible function at MarginAccount.sol#L328, before entering loop check if trader can be liquidated  ``` function liquidateFlexible(address trader, uint maxRepay, uint[] calldata idxs) external whenNotPaused {         clearingHouse.updatePositions(trader); // credits/debits funding (buffer.status, buffer.repayAble, buffer.incentivePerDollar) = isLiquidatable(trader, false); if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {return}  for (uint i = 0; i < idxs.length; i++){         ...     } ```"}, {"title": "Hidden governance", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L11   # Vulnerability details  ## Impact The contract use two governance model, one looks hidden.  ## Proof of Concept The VUSD contract uses `VanillaGovernable` but inherits from `ERC20PresetMinterPauserUpgradeable` and this contract uses roles to use some administrative methods like `pause` or `mint`.  This two-governance model does not seem necessary and can hide or raise suspicion about a rogue pool, thus damaging the user's trust.  ## Recommended Mitigation Steps Unify governance in only one, VanillaGovernable or role based.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/3", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": " Title: Not verified input Severity: Low Risk       external / public functions parameters should be validated to make sure the address is not 0.     Otherwise if not given the right input it can mistakenly lead to loss of user funds.                       AMM.sol.getPendingFundingPayment trader         Oracle.sol.requireNonEmptyAddress _addr         ClearingHouse.sol.whitelistAmm _amm     Title: Named return issue Severity: Low Risk  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           Oracle.sol, getUnderlyingPrice         AMM.sol, updatePosition         MarginAccount.sol, isLiquidatable         Oracle.sol, getLatestRoundData         AMM.sol, getCloseQuote    Title: Mult instead div in compares Severity: Low Risk       To improve algorithm precision instead using division in comparison use multiplication in the following scenario:                          Instead a < b / c use a * c < b.               In all of the big and trusted contracts this rule is maintained.              MarginAccount.sol, 601, require(_liquidationIncentive <= PRECISION / 10, \"MA.syncDeps.LI_GT_10_percent\");    Title: In the following public update functions no value is returned Severity: Low Risk  In the following functions no value is returned, due to which by default value of return will be 0.  We assumed that after the update you return the latest new value.  (similar issue here: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/85).           ClearingHouse.sol, updatePositions    Title: Anyone can withdraw others Severity: Low Risk   Anyone can withdraw users shares. Although we think that they are sent to the right address, it is still     1) not the desired behavior     2) can be dangerous if the receiver is a smart contract     3) the receiver may not know someone withdraw him               InsuranceFund.withdraw         VUSD.setMaxWithdrawalProcesses         VUSD.withdraw         VUSD.processWithdrawals    Title: Does not validate the input fee parameter Severity: Low Risk   Some fee parameters of functions are not checked for invalid values. Validate the parameters:                           ClearingHouse._disperseLiquidationFee (liquidationFee)         ClearingHouse.setParams (_tradeFee)         ClearingHouse.initialize (_tradeFee)    Title: Duplicates in array Severity: Low Risk           You allow in some arrays to have duplicates. Sometimes you assumes there are no duplicates in the array.          ClearingHouse.whitelistAmm pushed (_amm)   {         emit MarketAdded(amms.length, _amm);         amms.push(IAMM(_amm));     } VUSD.withdraw pushed (amount)   {         burn(amount);         withdrawals.push(Withdrawal(msg.sender, amount));     }    Title: Init frontrun Severity: Low Risk  Most contracts use an init pattern (instead of a constructor) to initialize contract parameters. Unless these are enforced to be atomic with contact deployment via deployment script or factory contracts, they are susceptible to front-running race conditions where an attacker/griefer can front-run (cannot access control because admin roles are not initialized) to initially with their own (malicious) parameters upon detecting (if an event is emitted) which the contract deployer has to redeploy wasting gas and risking other transactions from interacting with the attacker-initialized contract.  Many init functions do not have an explicit event emission which makes monitoring such scenarios harder. All of them have re-init checks; while many are explicit some (those in auction contracts) have implicit reinit checks in initAccessControls() which is better if converted to an explicit check in the main init function itself. (details credit to: https://github.com/code-423n4/2021-09-sushimiso-findings/issues/64) The vulnerable initialization functions in the codebase are:           Oracle.sol, initialize, 20         ClearingHouse.sol, initialize, 35         MarginAccount.sol, initialize, 121         AMM.sol, initialize, 93    Title: Open TODOs Severity: Low Risk  Open TODOs can hint at programming or architectural errors that still need to be fixed.  These files has open TODOs:  Open TODO in AMM.sol line 554 :             // @todo handle case when totalPosition = 0  Open TODO in ClearingHouse.sol line 171 :             // @todo put checks on slippage  Open TODO in MarginAccount.sol line 276 :             @todo consider providing some incentive from insurance fund to execute a liquidation in this scenario.  Open TODO in AMM.sol line 141 :         // sending market orders can fk the trader. @todo put some safe guards around price of liquidations     Title: Unbounded loop on array that can only grow can lead to DoS Severity: Low/Med Risk  A malicious attacker that is also a protocol owner can push unlimitedly to an array, that some function loop over this array. If increasing the array size enough, calling the function that does a loop over the array will always revert since there is a gas limit. This is a Med Risk issue since it can lead to DoS with a reasonable chance of having untrusted owner or even an owner that did a mistake in good faith.          ClearingHouse.sol (L250): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L169): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L276): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L129): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L193): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L262): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled         ClearingHouse.sol (L121): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm'] and can't be pulled    Title: Div by 0 Severity: Medium Risk   Division by 0 can lead to accidentally revert, (An example of a similar issue - https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/84)          MarginAccount.sol (L432) buffer might be 0)         AMM.sol (L251) _maker might be 0)         AMM.sol (L551) takerPosition might be 0)         MarginAccount.sol (L497) buffer might be 0)         AMM.sol (L681) period might be 0)         ClearingHouse.sol (L332) notionalPosition might be 0)         MarginAccount.sol (L495) buffer might be 0)         AMM.sol (L556) totalPosition might be 0)         AMM.sol (L552) totalPosition might be 0)         AMM.sol (L710) _underlyingPrice might be 0)         AMM.sol (L251) maker might be 0)         AMM.sol (L250) maker might be 0)         AMM.sol (L703) _intervalInSeconds might be 0)         AMM.sol (L250) _maker might be 0)         AMM.sol (L592) baseAssetQuantity might be 0)    Title: Usage of an incorrect version of Ownbale library can potentially malfunction all onlyOwner functions Severity: High Risk       The current implementaion is using an non-upgradeable version of the Ownbale library.  instead of the upgradeable version: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol.     A regular, non-upgradeable Ownbale library will make the deployer the default owner in the constructor. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. Therefore, there will be no owner when the contract is deployed as a proxy contract     Use @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol and @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol instead.     And add     __Ownable_init(); at the beginning of the initializer.                   Oracle.sol         AMM.sol    Title: Unbounded loop on array can lead to DoS Severity: High Risk  The attacker can push unlimitedly to an array, that some function loop over this array. If increasing the array size enough, calling the function that does a loop over the array will always revert since there is a gas limit. This is an High Risk issue since those arrays are publicly allows to push items into them.          ClearingHouse.sol (L193): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L262): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L169): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L129): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L250): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L121): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']         ClearingHouse.sol (L276): Unbounded loop on the array amms that can be publicly pushed by ['whitelistAmm']  "}, {"title": "`UniswapV2PriceOracle.sol` `currentCumulativePrices()` will revert when `priceCumulative` addition overflow", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/62", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-phuture-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PriceOracle.sol#L62   # Vulnerability details  https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PriceOracle.sol#L62  ```solidity (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) = address(pair).currentCumulativePrices(); ```  Because the Solidity version used by the current implementation of `UniswapV2OracleLibrary.sol` is `>=0.8.7`, and there are some breaking changes in Solidity v0.8.0:  > Arithmetic operations revert on underflow and overflow.   Ref: https://docs.soliditylang.org/en/v0.8.13/080-breaking-changes.html#silent-changes-of-the-semantics  While in `UniswapV2OracleLibrary.sol`, subtraction overflow is desired at `blockTimestamp - blockTimestampLast` in `currentCumulativePrices()`:  https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L25-L33  ```solidity if (blockTimestampLast != blockTimestamp) {     // subtraction overflow is desired     uint32 timeElapsed = blockTimestamp - blockTimestampLast;     // addition overflow is desired     // counterfactual     price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;     // counterfactual     price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed; } ```  In another word, `Uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary` only works at solidity < `0.8.0`.  As a result, when `price0Cumulative` or `price1Cumulative` is big enough, `currentCumulativePrices` will revert due to overflow.  ### Impact  Since the overflow is desired in the original version, and it's broken because of using Solidity version >0.8. The `UniswapV2PriceOracle` contract will break when the desired overflow happens, and further breaks other parts of the system that relies on `UniswapV2PriceOracle`.  ### Recommendation  Note: this recommended fix requires a fork of the library contract provided by Uniswap.  Change to:  ```solidity if (blockTimestampLast != blockTimestamp) {     unchecked {         // subtraction overflow is desired         uint32 timeElapsed = blockTimestamp - blockTimestampLast;         // addition overflow is desired         // counterfactual         price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;         // counterfactual         price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;     } } ```  "}, {"title": "Tokens with fee on transfer are not supported", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-phuture-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-phuture/tree/main/contracts/IndexLogic.sol#L115   # Vulnerability details   There are ERC20 tokens that charge fee for every transfer() / transferFrom().  Vault.sol#addValue() assumes that the received amount is the same as the transfer amount,  and uses it to calculate attributions, balance amounts, etc.  But, the actual transferred amount can be lower for those tokens. Therefore it's recommended to use the balance change before and after the transfer instead of the amount. This way you also support the tokens with transfer fee - that are popular.           https://github.com/code-423n4/2022-04-phuture/tree/main/contracts/IndexLogic.sol#L115  "}, {"title": "Wrong requirement in reweight function (ManagedIndexReweightingLogic.sol)", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/40", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-phuture-findings", "body": "# Lines of code   https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ManagedIndexReweightingLogic.sol#L32 https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/interfaces/IIndexRegistry.sol#L19   # Vulnerability details  ## Impact The list of assets won't be changed after reweight because of reverted tx   ## Proof of Concept  ```require(_updatedAssets.length <= IIndexRegistry(registry).maxComponents())``` when [reweight](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ManagedIndexReweightingLogic.sol#L32) is not true, because as in the [doc](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/interfaces/IIndexRegistry.sol#L19),  ```maxComponent``` is the maximum assets for an index, but ```_updatedAssets``` also contain the assets that you want to remove. So the comparision make no sense  ## Tools Used manual review   ## Recommended Mitigation Steps Require ```assets.length() <= IIndexRegistry(registry).maxComponents()``` at the end of function instead    "}, {"title": "Chainlink's latestRoundData might return stale or incorrect results", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/1", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-phuture-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-phuture/blob/main/contracts/ChainlinkPriceOracle.sol#L83-L84   # Vulnerability details  ## Impact On ChainlinkPriceOracle.sol, we are using latestRoundData, but there is no check if the return value indicates stale data. ```         (, int basePrice, , , ) = baseAggregator.latestRoundData();         (, int quotePrice, , , ) = assetInfo.aggregator.latestRoundData(); ``` This could lead to stale prices according to the Chainlink documentation:  https://docs.chain.link/docs/historical-price-data/#historical-rounds https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round ## Proof of Concept https://github.com/code-423n4/2022-04-phuture/blob/main/contracts/ChainlinkPriceOracle.sol#L83-L84 ## Tools Used None ## Recommended Mitigation Steps Consider adding missing checks for stale data.  For example: ```     (uint80 baseRoundID, int256 basePrice, , uint256 baseTimestamp, uint80 BaseAnsweredInRound) = baseAggregator.latestRoundData();     (uint80 quoteRoundID, int256 quotePrice, , uint256 quoteTimestamp, uint80 quoteAnsweredInRound) = assetInfo.aggregator.latestRoundData();     require(BaseAnsweredInRound >= baseRoundID && quoteAnsweredInRound >=  quoteRoundID, \"Stale price\");     require(baseTimestamp != 0 && quoteTimestamp != 0 ,\"Round not complete\");     require(basePrice > 0 && quotePrice > 0,\"Chainlink answer reporting 0\"); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "## Gas Optimizations\r \r ### Unchecked math will save on gas\r ```\r   function _computeLockUntil(uint96 _lockDuration) internal view returns (uint96) {\r     return uint96(block.timestamp) + _lockDuration; //@audit Gas Optimization Unchecked\r   }\r ```\r The `_computeLockUntil` function in `TWABDelegator.sol` can be optimized by adding the `unchecked` directive as this will never overflow the `uint96` type since it is limited by the `MAX_LOCK` constant (which is currently assigned to 180 days() by the call to `_requireLockDuration(_lockDuration);`.\r ```\r justin@Stealth: 18362 \u00bb frf test.sol\r compiling...\r Compiling 2 files with 0.8.12\r Compilation finished successfully\r success.\r Script ran successfully.\r Gas Used: 5401\r == Logs == \r 180 days, 15552000\r Current timestamp, 1645633955\r Current timestamp + 5000 years, 159325633955\r Max uint96, 79228162514264337593543950335\r \r ```\r \r ### Unneeded Zero Address Check\r In the `stake` function of the `TWABDelegator.sol` file, the `_requireRecipientNotZeroAddress` function is called on the `_to` parameter. However, this is unnecessary since the `_mint` function checks for the zero address when called. As such, it would be more gas efficient to not perform this call.\r ```\r  function stake(address _to, uint256 _amount) external {\r     _requireRecipientNotZeroAddress(_to);\r     //@audit Gas Optimization Above is unneeded since _mint checks whether _to is zero addr or not\r     _requireAmountGtZero(_amount);\r \r     IERC20(ticket).safeTransferFrom(msg.sender, address(this), _amount);\r     _mint(_to, _amount);\r ```\r \r \r ### More efficient order of operations in `updateDelegatee`\r In the `updateDelegatee` function of the `TWABDelegator.sol` file the `_lockUntil` variable is defined by calling the `_computeLockUntil` function. However, if the `_lockDuration` is 0, then this value is the same as the current `block.timestamp`. As a result, the following code would be an optimization:\r \r Original Code:\r ```\r uint96 _lockUntil = _computeLockUntil(_lockDuration); //@audit Gas Optimization\r \r if (_lockDuration > 0) {\r     _delegation.setLockUntil(_lockUntil);\r }\r \r _delegateCall(_delegation, _delegatee);\r \r emit DelegateeUpdated(_delegator, _slot, _delegatee, _lockUntil, msg.sender);\r ```\r \r Optimized Code:\r ```\r uint96 _lockUntil = block.timestamp;\r if (_lockDuration > 0) {\r     _lockUntil = _computeLockUntil(_lockDuration);\r     _delegation.setLockUntil(_lockUntil);\r }\r _delegateCall(_delegation, _delegatee);\r emit DelegateeUpdated(_delegator, _slot, _delegatee, _lockUntil, msg.sender);\r ```\r \r Here are the tests with the optimizations (* indicates Optimized case):\r ```\r \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\r |  Contract              \u00b7  Method                     \u00b7  Min        \u00b7  Max        \u00b7  Avg         \u00b7  # calls      \u00b7  usd (avg)  \u2502\r \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\r |  TWABDelegatorHarness  \u00b7  updateDelegatee            \u00b7     140113  \u00b7     144124  \u00b7      141911  \u00b7            7  \u00b7          -  \u2502\r \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\r |  *TWABDelegatorHarness \u00b7  updateDelegatee            \u00b7     139965  \u00b7     144126  \u00b7      141806  \u00b7            7  \u00b7          -  \u2502\r \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\r ```\r \r \r ## Non-Critcal \r \r ### Missing comment for the `to` parameter\r There is no comment on the `to` parameter for the `TransferredDelegation` event in the `TWABDelegator.sol` file.\r ```\r   /**\r    * @notice Emitted when a delegator withdraws an amount of tickets from a delegation to their wallet.\r    * @param delegator Address of the delegator\r    * @param slot  Slot of the delegation\r    * @param amount Amount of tickets withdrawn\r    */\r    //@audit Missing comment for the `to` parameter\r   event TransferredDelegation(\r     address indexed delegator,\r     uint256 indexed slot,\r     uint256 amount,\r     address indexed to\r   );\r   ```\r \r \r   ## Low\r \r   ### Incorrect Event Parameters\r   The `TWABDelegator.sol`'s `TicketsStaked` event's first parameter should be the delegator, as such, it should be `msg.sender` not `_to` as `_to` is the recipient.\r   ```\r     /**\r    * @notice Emitted when tickets have been staked.\r    * @param delegator Address of the delegator\r    * @param amount Amount of tickets staked\r    */\r   event TicketsStaked(address indexed delegator, uint256 amount);\r \r   ...\r \r     /**\r    * @notice Stake `_amount` of tickets in this contract.\r    * @dev Tickets can be staked on behalf of a `_to` user.\r    * @param _to Address to which the stake will be attributed\r    * @param _amount Amount of tickets to stake\r    */\r   function stake(address _to, uint256 _amount) external {\r     _requireRecipientNotZeroAddress(_to); //@audit See here that the _to is the recipient, not the delegator.\r     _requireAmountGtZero(_amount);\r \r     IERC20(ticket).safeTransferFrom(msg.sender, address(this), _amount);\r     _mint(_to, _amount);\r \r     emit TicketsStaked(_to, _amount);//@audit the first parameter of TicketsStacked should be delegator, not recipient. Should be msg.sender.\r   }\r   ```\r \r ### Incorrect Comment Associated with `transferDelegationTo`\r The comments above the `transferDelegationTo` function are incorrect. The first line, which begins with `@notice`, says `The tickets are transferred to the caller`. However, the tickets are transfered to the `_to` parameter as can be seen by the line `_transfer(_delegation, _to, _amount);`\r In addition, the comment directly below that states `Will directly send the tickets to the delegator wallet.` This is also incorrect per the above reason.\r ```\r   /**\r    * @notice Withdraw an `_amount` of tickets from a delegation. The delegator is assumed to be the caller. The tickets are transferred to the caller.\r    * @dev Will directly send the tickets to the delegator wallet.\r    * @dev Will revert if delegation is still locked.\r    * @param _slot Slot of the delegation\r    * @param _amount Amount to withdraw\r    * @param _to Account to transfer the withdrawn tickets to\r    * @return The address of the Delegation\r    */\r   function transferDelegationTo(\r     uint256 _slot,\r     uint256 _amount,\r     address _to\r   ) external returns (Delegation) {\r     _requireRecipientNotZeroAddress(_to);\r \r     Delegation _delegation = Delegation(_computeAddress(msg.sender, _slot));\r     _transfer(_delegation, _to, _amount);\r \r     emit TransferredDelegation(msg.sender, _slot, _amount, _to);\r \r     return _delegation;\r   }\r   ```\r   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "### Using `bool`s for storage incurs overhead ```     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 ```solidity mapping(address => mapping(address => bool)) internal representatives;          ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L159   ### Functions not called by the contract itself should be `external` rather than `public` ```solidity function initialize(uint96 _lockUntil) public {            ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L29   ### Using `> 0` costs more gas than `!= 0` when used on uints in a `require()` statement ```solidity require(_amount > 0, \"TWABDelegator/amount-gt-zero\");             ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L601   ### `<array>.length` should not be looked up in every loop of a for-loop Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length ```solidity for (uint256 i = 0; i < _data.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L33  ```solidity for (uint256 i = 0; i < calls.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L42   ### `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in for- and while-loops ```solidity for (uint256 i = 0; i < _data.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L33  ```solidity for (uint256 i = 0; i < calls.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L42   ### `++i` costs less gas than `++i`, especially when it's used in for-loops (`--i`/`i--` too) ```solidity for (uint256 i = 0; i < _data.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L33  ```solidity for (uint256 i = 0; i < calls.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L42   ### It costs more gas to initialize variables to zero than to let the default of zero be applied ```solidity for (uint256 i = 0; i < _data.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L33  ```solidity for (uint256 i = 0; i < calls.length; i++) {       ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L42   ### It costs less gas to inline the code of functions that are only called once Doing so saves the cost of allocating the function selector, and the cost of the jump when the function is called. ```solidity   function _requireDelegatorNotZeroAddress(address _delegator) internal pure {     require(_delegator != address(0), \"TWABDelegator/dlgtr-not-zero-adr\");   } ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L608-L610   ### Using stack copies of variables when repeated access is required uses less gas Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length. `calls.length` can be cached ```solidity     bytes[] memory response = new bytes[](calls.length);     for (uint256 i = 0; i < calls.length; i++) { ``` https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/Delegation.sol#L41-L42 "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "# QA Report  **Table of Contents:**  - [QA Report](#qa-report)   - [Foreword](#foreword)   - [Summary](#summary)   - [File: PermitAndMulticall.sol](#file-permitandmulticallsol)     - [function _permitAndMulticall()](#function-_permitandmulticall)       - [Missing `@param _permitToken`](#missing-param-_permittoken)   - [File: TWABDelegator.sol](#file-twabdelegatorsol)     - [event TransferredDelegation()](#event-transferreddelegation)       - [Missing `@param to`](#missing-param-to)     - [function _executeCall()](#function-_executecall)       - [Missing `@return bytes[]`](#missing-return-bytes)  ## Foreword  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Summary  - Only some missing `@param` and `@return` comments were found as low-risk issues according to C4's scale.  - While `Delegator.sol:initialize()` was found to be front-runnable (but not callable multiple times), the issue was severe enough (due to CREATE2) to be sent separately as a medium-risk issue instead of a low-risk one.  ## File: PermitAndMulticall.sol  ### function _permitAndMulticall()  #### Missing `@param _permitToken`  ``` 39:   /** 40:    * @notice Alow a user to approve ticket and run various calls in one transaction. 41:    * @param _from Address of the sender //@audit missing @param _permitToken 42:    * @param _amount Amount of tickets to approve 43:    * @param _permitSignature Permit signature 44:    * @param _data Datas to call with `functionDelegateCall` 45:    */ 46:   function _permitAndMulticall( 47:     IERC20Permit _permitToken, 48:     address _from, 49:     uint256 _amount, 50:     Signature calldata _permitSignature, 51:     bytes[] calldata _data 52:   ) internal { ```  ## File: TWABDelegator.sol  ### event TransferredDelegation()  #### Missing `@param to`  ``` 125:   /** 126:    * @notice Emitted when a delegator withdraws an amount of tickets from a delegation to their wallet. 127:    * @param delegator Address of the delegator 128:    * @param slot  Slot of the delegation 129:    * @param amount Amount of tickets withdrawn //@audit missing @param to 130:    */ 131:   event TransferredDelegation( 132:     address indexed delegator, 133:     uint256 indexed slot, 134:     uint256 amount, 135:     address indexed to 136:   ); ```  ### function _executeCall()  #### Missing `@return bytes[]`  ``` File: TWABDelegator.sol 543:   /** 544:    * @notice Execute a function call on the delegation contract. 545:    * @param _delegation Address of the delegation contract 546:    * @param _data The call data that will be executed //@audit missing @return bytes[] 547:    */ 548:   function _executeCall(Delegation _delegation, bytes memory _data) 549:     internal 550:     returns (bytes[] memory) ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "## [G-00] Reduce Runtime Gas With Modifiers  **Severity**: _Gas_ **Likelihood**: _High_ **Status**: {Submitted} **Scope**: [`TWABDelegator.sol`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol)  Multiple `internal` functions in `TWABDelegator` can be turned into modifiers to reduce runtime gas costs at the expense of increasing the deployment cost.  Below, we show the gas costs of internal functions (first image) and using modifiers instead (second image).  ![Gas costs when using internal function calls](https://i.imgur.com/nDbGkhS.png) _Gas costs when using internal function calls_  ![Gas Costs when using Modifiers](https://i.imgur.com/07q5nys.png) _Gas costs when using modifiers_  Functions changed to modifiers to achieve the above results:  - [`_requireDelegatorOrRepresentative(address _delegator)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L577-L586) - [`_requireDelegateeNotZeroAddress(address _delegatee)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L588-L594) - [`_requireAmountGtZero(uint256 _amount)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L596-L602) - [`_requireDelegatorNotZeroAddress(address _delegator)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L604-L610) - [`_requireRecipientNotZeroAddress(address _to)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L612-L618) - [`_requireLockDuration(uint256 _lockDuration)`](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L636-L642)   **Recommendation**: Change the specified internal functions into modifiers to reduce runtime gas costs at the expense of bytecode bloat (increased deployment costs). This also requires changing their usage into modifier syntax rather than _call_.   ## [G-01] Solmate Port  **Severity**: _Gas_ **Likelihood**: _High_ **Status**: {Submitted} **Scope**: [`contracts/*`](https://github.com/pooltogether/v4-twab-delegator/tree/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts)  **Recommendation**: Port contracts over to using [solmate](https://github.com/Rari-Capital/solmate) to significantly reduce openzeppelin bloat (will require a custom write of ERC20Permit and its interface as well as deterministic cloning (ref: https://github.com/Rari-Capital/vaults)).   ## [I-00] Inconsistent Licensing  **Severity**: _Informational_ **Likelihood**: _High_ **Status**: {Submitted} **Scope**: [`contracts/*`](https://github.com/pooltogether/v4-twab-delegator/tree/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts)  `Delegation.sol` has SPDX Identifier: `// SPDX-License-Identifier: MIT` `LowLevelDelegator.sol` has SPDX Identifier: `// SPDX-License-Identifier: GPL-3.0` `PermitAndMulticall.sol` has SPDX Identifier: `// SPDX-License-Identifier: MIT` `TWABDelegator.sol` has SPDX Identifier: `// SPDX-License-Identifier: GPL-3.0`  `test/TWABDelegatorHarness.sol` has SPDX Identifier: `// SPDX-License-Identifier: GPL-3.0`  **Recommendation**: Coalesce SPDX License Identifiers into one canonical license unless necessary.  "}, {"title": "`permitAndMulticall()` May Be Used to Steal Funds Or as a Denial Of Service if `_from` Is Not The Message Sender", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/20", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "# Lines of code  https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L46-L64 https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L31-L37 https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L438-L445   # Vulnerability details  ## Impact  When the `_from` address is not the `msg.sender` `_multiCall()` will be made on behalf of the `msg.sender`. As a result each of the functions called by `multiCall()` will be made on behalf of `msg.sender` and not `_from`.  If functions such as `transfer()` or `unstake()` are called `msg.sender` will be the original caller which would transfer the attacker the funds if the `to` field is set to an attackers address.  Furthermore, if an attacker we to call `permitAndMulticall()` before the `_from` user they may use their signature and nonce combination. As a nonce is only allowe to be used once the siganture will no longer be valid and `_permitToken.permit()` will fail on the second call.  An attacker may use this as a Denial of Service (DoS) attack by continually front-running `permitAndCall()` using other users signatures.  ## Proof of Concept  ```   function _multicall(bytes[] calldata _data) internal virtual returns (bytes[] memory results) {     results = new bytes[](_data.length);     for (uint256 i = 0; i < _data.length; i++) {       results[i] = Address.functionDelegateCall(address(this), _data[i]);     }     return results;   } ```  ```   function _permitAndMulticall(     IERC20Permit _permitToken,     address _from,     uint256 _amount,     Signature calldata _permitSignature,     bytes[] calldata _data   ) internal {     _permitToken.permit(       _from,       address(this),       _amount,       _permitSignature.deadline,       _permitSignature.v,       _permitSignature.r,       _permitSignature.s     );      _multicall(_data);   } ```  ## Recommended Mitigation Steps  Consider updating the `_from` field to be the `msg.sender` in `permitAndMulticall()` (or alternatively do this in `_permitAndMulticall()` to save some gas).  ```   function permitAndMulticall(     uint256 _amount,     Signature calldata _permitSignature,     bytes[] calldata _data   ) external {     _permitAndMulticall(IERC20Permit(address(ticket)), msg.sender, _amount, _permitSignature, _data);   } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/16", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "# Codebase Impressions & Summary  Overall, code quality for the TWABDelegator contracts is very high. Functions were well commented and ordered in visibility level, and the documentation provided made it easy to understand the intended functionality.  The test suite could be easily run. Almost 100% test coverage is achieved, where only the `Delegation` contract lacked branch coverage for a couple of edge cases.  The findings I made only involved incorrect comments for a function and couple of events.  # Low Severity Findings  ## L01: Incorrect comment on `transferDelegationTo()`  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L370-L371](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L370-L371)  ### Description  The comments say that the withdrawn tickets are transferred to the caller / delegator wallet, but are actually transferred to the `_to` address.  ### Recommended Mitigation Steps  ```jsx * @notice Withdraw an `_amount` of tickets from a delegation. The delegator is assumed to be the caller. * @dev Tickets are sent directly to the passed `_to` address ```  ## L02: Incorrect comment on `TransferredDelegation` event  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L125-L136](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L125-L136)  ### Description  In relation to L01, the `TransferredDelegation` event  - is incorrectly commented that the withdrawn tickets are transferred to the caller / delegator wallet - lacks a description about the `to` indexed parameter.  ### Recommended Mitigation Steps  ```jsx /**  * @notice Emitted when a delegator withdraws an amount of tickets from a delegation to a specified wallet.  * @param delegator Address of the delegator  * @param slot  Slot of the delegation  * @param amount Amount of tickets withdrawn  * @param to Recipient address of withdrawn tickets  */   event TransferredDelegation(     address indexed delegator,     uint256 indexed slot,     uint256 amount,     address indexed to   ); ```  ## L03: Incorrect comment on `DelegationFundedFromStake` event  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L102](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L102)  ### Description  The `DelegationFundedFromStake()` allows a representative or delegator himself to fund a delegation contract using the delegator\u2019s stake. The `user` in the `DelegationFundedFromStake` event refers to `msg.sender`. Since the funds are coming solely from the delegator, its description isn\u2019t entirely correct.  ### Recommended Mitigation Steps  `@param user Address of the user who pulled funds from the delegator to the delegation`  # Non-Critical Findings  ## NC01: Extra whitespace in slot description of `WithdrewDelegationToStake()` event  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L114](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L114)  ### Description  There is an additional spacing between `slot` and `Slot`.  ### Recommended Mitigation Steps  Remove the spacing to become: `* @param slot Slot of the delegation`  # Suggestions  ## S01: TWABDelegator: Consider renaming `_delegateCall()` to `_setDelegateeCall()`  ### Line References  [https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L519](https://github.com/pooltogether/v4-twab-delegator/blob/master/contracts/TWABDelegator.sol#L519)  ### Description  `_delegateCall()` could easily be confused for the inbuilt `delegatecall()` method. I recommend renaming it to something more distinguishable like `_setDelegateeCall()`."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          TWABDelegator.sol, _computeLockUntil         TWABDelegator.sol, _requireDelegateeNotZeroAddress         TWABDelegator.sol, _executeCall         TWABDelegator.sol, _transfer         TWABDelegator.sol, _requireContract         TWABDelegator.sol, _computeAddress         TWABDelegator.sol, _requireAmountGtZero         TWABDelegator.sol, _requireDelegatorNotZeroAddress         LowLevelDelegator.sol, _computeAddress         TWABDelegator.sol, _transferCall         TWABDelegator.sol, _requireRecipientNotZeroAddress         PermitAndMulticall.sol, _permitAndMulticall         TWABDelegator.sol, _requireDelegationUnlocked         TWABDelegator.sol, _requireLockDuration         TWABDelegator.sol, _requireDelegatorOrRepresentative         LowLevelDelegator.sol, _createDelegation         PermitAndMulticall.sol, _multicall         TWABDelegator.sol, _delegateCall         LowLevelDelegator.sol, _computeSalt         Delegation.sol, _executeCall    Title: Unnecessary equals boolean Severity: GAS   Boolean variables can be checked within conditionals directly without the use of equality operators to true/false.          TWABDelegator.sol, 583: _delegator == msg.sender || representatives[_delegator][msg.sender] == true,    Title: State variables that could be set immutable Severity: GAS  In the following files there are state variables that could be set immutable to save gas.           delegationInstance in LowLevelDelegator.sol    Title: Unnecessary array boundaries check when loading an array element twice Severity: GAS       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:               Delegation.sol.executeCalls - double load of calls[i]    Title: Unnecessary functions Severity: GAS       The following functions are not used at all. Therefore you can remove them to save deployment gas and improve code clearness.                   LowLevelDelegator.sol, _createDelegation         LowLevelDelegator.sol, _computeSalt         PermitAndMulticall.sol, _permitAndMulticall         LowLevelDelegator.sol, _computeAddress    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           Delegation.sol, calls, 42         PermitAndMulticall.sol, _data, 33    Title: Unused imports Severity: GAS   In the following files there are contract imports that aren't used Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore)          PermitAndMulticall.sol, line 4, import \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: Delegation.sol, i, 42         change to prefix increment and unchecked: PermitAndMulticall.sol, i, 33    Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               TWABDelegator.sol, _computeLockUntil, { return uint96(block.timestamp) + _lockDuration; }         LowLevelDelegator.sol, _computeSalt, { return keccak256(abi.encodePacked(_delegator, _slot)); }         TWABDelegator.sol, _computeAddress, { return _computeAddress(_computeSalt(_delegator, bytes32(_slot))); }         LowLevelDelegator.sol, _computeAddress, { return address(delegationInstance).predictDeterministicAddress(_salt, address(this)); }    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           Delegation.sol, initialize    Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               TWABDelegator.constructor (name_)         TWABDelegator.constructor (symbol_)         Delegation._executeCall (data)         TWABDelegator._executeCall (_data)    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               TWABDelegator.sol, _transferCall         PermitAndMulticall.sol, _multicall         TWABDelegator.sol, _requireDelegatorNotZeroAddress         Delegation.sol, _executeCall    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          PermitAndMulticall.sol, 33         Delegation.sol, 42    Title: Use unchecked to save gas for certain additive calculations that cannot overflow Severity: GAS   You can use unchecked in the following calculations since there is no risk to overflow:          TWABDelegator.sol (L#511) - return uint96(block.timestamp) + _lockDuration;    Title: Short the following require messages Severity: GAS  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: TWABDelegator.sol, In line 582, Require message length to shorten: 34, The message: TWABDelegator/not-delegator-or-rep    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           TWABDelegator.sol, 273: change '_lockDuration > 0' to '_lockDuration != 0'         TWABDelegator.sol, 601: change '_amount > 0' to '_amount != 0' "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/14", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "  Title: Not verified input Severity: Low Risk       external / public functions parameters should be validated to make sure the address is not 0.     Otherwise if not given the right input it can mistakenly lead to loss of user funds.                       TWABDelegator.sol.permitAndMulticall _from         Delegation.sol._executeCall to         PermitAndMulticall.sol._permitAndMulticall _from         TWABDelegator.sol.stake _to         TWABDelegator.sol._requireDelegateeNotZeroAddress _delegatee         TWABDelegator.sol.setRepresentative _representative         TWABDelegator.sol._computeAddress _delegator         TWABDelegator.sol._requireDelegatorNotZeroAddress _delegator         TWABDelegator.sol.updateDelegatee _delegatee         TWABDelegator.sol.isRepresentativeOf _delegator         TWABDelegator.sol._transfer _to         TWABDelegator.sol._requireContract _address         TWABDelegator.sol._transferCall _to         LowLevelDelegator.sol._computeSalt _delegator         TWABDelegator.sol.createDelegation _delegatee         TWABDelegator.sol.transferDelegationTo _to         TWABDelegator.sol.unstake _to         TWABDelegator.sol.computeDelegationAddress _delegator         TWABDelegator.sol.fundDelegation _delegator         TWABDelegator.sol.isRepresentativeOf _representative         TWABDelegator.sol._delegateCall _delegatee         TWABDelegator.sol.getDelegation _delegator         TWABDelegator.sol._requireRecipientNotZeroAddress _to    Title: Named return issue Severity: Low Risk  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           TWABDelegator.sol, multicall         PermitAndMulticall.sol, _multicall    Title: Never used parameters Severity: Low Risk  Those are functions and parameters pairs that the function doesn't use the parameter. In case those functions are external/public this is even worst since the user is required to put value that never used and can misslead him and waste its time.           Delegation.sol: function _executeCall parameter value isn't used. (_executeCall is internal)         TWABDelegator.sol: function _executeCall parameter _data isn't used. (_executeCall is internal)         Delegation.sol: function _executeCall parameter data isn't used. (_executeCall is internal)         Delegation.sol: function _executeCall parameter to isn't used. (_executeCall is internal)    Title: Mult instead div in compares Severity: Low Risk       To improve algorithm precision instead using division in comparison use multiplication in the following scenario:                          Instead a < b / c use a * c < b.               In all of the big and trusted contracts this rule is maintained.              TWABDelegator.sol, 625, require(block.timestamp >= _delegation.lockUntil(), \"TWABDelegator/delegation-locked\");         TWABDelegator.sol, 601, require(_amount > 0, \"TWABDelegator/amount-gt-zero\");         TWABDelegator.sol, 641, require(_lockDuration <= MAX_LOCK, \"TWABDelegator/lock-too-long\");    Title: Override function but with different argument location Severity: Low/Med Risk                     TWABDelegator.sol._computeAddress inherent LowLevelDelegator.sol._computeAddress but the parameters does not match         TWABDelegator.sol.constructor inherent LowLevelDelegator.sol.constructor but the parameters does not match "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/10", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "# Low and Non-critical ## tickets can get locked if a user calls `transferDelegationTo` with the address of the `TWABDelegator` contract as the `to` parameter, the tokens will be transferred to the address without minting the user the stake token, so maybe you can think of adding this functionality. I know that there is the `withdrawDelegationToStake` function for that, but that can be nice to enable it that way too."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "# Gas Optimizations ## Loop in `Delegation` and `PermitAndMulticall` contracts Loops can be optimized in several ways. Let's take for example the loop in the `executeCalls` function of the `Delegation` contract. ```sol function executeCalls(Call[] calldata calls) external onlyOwner returns (bytes[] memory) {   bytes[] memory response = new bytes[](calls.length);   for (uint256 i = 0; i < calls.length; i++) {     response[i] = _executeCall(calls[i].to, calls[i].value, calls[i].data);   }   return response; } ``` To optimize this loop and make it consume less gas, we can do the foloowing things: 1. Use ++i instead of i++, which is a cheaper operation (in this case there is no difference between i++ and ++i because we dont use the return value of this expression, which is the only difference between these two expression). 2. Save the `calls` array length in a local variable instead of accessing it in every iteration. 3. Save `calls[i]` in a local variable instead of accessing it 3 times in every iteration. This will save accssing the array's ith element 3 times in every iteration ,which requires an address calculation. 4. There's no need to initialize i to its default value, it will be done automatically and it will consume more gas if it will be done (I know, sounds stupid, but trust me - it works). So after applying all these changes, the loop will look something like this: ```sol function executeCalls(Call[] calldata calls) external onlyOwner returns (bytes[] memory) {   bytes[] memory response = new bytes[](calls.length);   uint256 length = calls.length;   Call memory call;   for (uint256 i; i < length; ++i) {     call = calls[i];     response[i] = _executeCall(call.to, call.value, call.data);   }   return response; } ```  ## Inline all these little functions Defining all these little functions cause 2 things: 1. contract's code size gets bigger 2. the function calls consumes more gas than exectuing it as an inlined function (part of the code, without the function call) So in order to save gas, I would reccomend to inline these functions.  ```sol   function _computeAddress(address _delegator, uint256 _slot) internal view returns (address) {     return _computeAddress(_computeSalt(_delegator, bytes32(_slot)));   }    function _computeLockUntil(uint96 _lockDuration) internal view returns (uint96) {     return uint96(block.timestamp) + _lockDuration;   }    function _requireDelegatorOrRepresentative(address _delegator) internal view {     require(       _delegator == msg.sender || representatives[_delegator][msg.sender] == true,       \"TWABDelegator/not-delegator-or-rep\"     );   }    function _requireDelegateeNotZeroAddress(address _delegatee) internal pure {     require(_delegatee != address(0), \"TWABDelegator/dlgt-not-zero-adr\");   }    function _requireAmountGtZero(uint256 _amount) internal pure {     require(_amount > 0, \"TWABDelegator/amount-gt-zero\");   }    function _requireDelegatorNotZeroAddress(address _delegator) internal pure {     require(_delegator != address(0), \"TWABDelegator/dlgtr-not-zero-adr\");   }    function _requireRecipientNotZeroAddress(address _to) internal pure {     require(_to != address(0), \"TWABDelegator/to-not-zero-addr\");   }    function _requireDelegationUnlocked(Delegation _delegation) internal view {     require(block.timestamp >= _delegation.lockUntil(), \"TWABDelegator/delegation-locked\");   }    function _requireContract(address _address) internal view {     require(_address.isContract(), \"TWABDelegator/not-a-contract\");   }    function _requireLockDuration(uint256 _lockDuration) internal pure {     require(_lockDuration <= MAX_LOCK, \"TWABDelegator/lock-too-long\");   } ```"}, {"title": "`adminAccountMigration()` Does Not Update `buyPrice.seller`", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L263-L292 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L125-L141   # Vulnerability details  ## Impact  The `adminAccountMigration()` function is called by the operator role to update all sellers' auctions. The `auction.seller` account is updated to the new address, however, the protocol fails to update `buyPrice.seller`. As a result, the protocol is put in a deadlock situation where the new address cannot cancel the auction and withdraw their NFT without the compromised account first cancelling the buy price and vice-versa. This is only recoverable if the new account is migrated back to the compromised account and then `cancelBuyPrice()` is called before migrating back.  ## Proof of Concept  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider invalidating the buy offer before account migration.  "}, {"title": "`_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/85", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCreators.sol#L49-L251   # Vulnerability details  ## Impact  The `_getCreatorPaymentInfo()` function is utilised by `_distributeFunds()` whenever an NFT sale is made. The function uses `try` and `catch` statements to handle bad API endpoints. As such, a revert in this function would lead to NFTs that are locked in the contract. Some API endpoints receive an array of recipient addresses which are iterated over. If for whatever reason the function reverts inside of a `try` statement, the revert is actually not handled and it will not fall through to the empty `catch` statement.  ## Proof of Concept  The end result is that valid and honest NFT contracts may revert if the call runs out of gas due to an unbounded `_recipients` array. `try` statements are only able to handle external calls.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider bounding the number of iterations to `MAX_ROYALTY_RECIPIENTS_INDEX` as this is already enforced by `_distributeFunds()`. It may be useful to identify other areas where the `try` statement will not handle reverts on internal calls.  "}, {"title": "`buyFromPrivateSaleFor()` Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/77", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L143-L150   # Vulnerability details  ## Impact  The `buyFromPrivateSaleFor()` function allows sellers to make private sales to users. If insufficient `ETH` is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.  ## Proof of Concept  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding a `_cancelBuyersOffer()` call to the `buyFromPrivateSaleFor()` function. This should be added only to the case where insufficient `ETH` was provided to the trade. By cancelling the buyer's offer on the same NFT, we can guarantee that the user has access to the correct amount of funds.  "}, {"title": "Fees Are Incorrectly Charged on Unfinalized NFT Sales", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/73", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L255-L271 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L557 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L510-L515 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketFees.sol#L188-L189   # Vulnerability details  ## Impact  Once an auction has ended, the highest bidder now has sole rights to the underlying NFT. By finalizing the auction, fees are charged on the sale and the NFT is transferred to `auction.bidder`. However, if `auction.bidder` accepts an offer before finalization, fees will be charged on the `auction.bidder` sale before the original sale. As a result, it is possible to avoid paying the primary foundation fee as a creator if the NFT is sold by `auction.bidder` before finalization.  ## Proof of Concept  Consider the following scenario: - Alice creates an auction and is the NFT creator. - Bob bids on the auction and is the highest bidder. - The auction ends but Alice leaves it in an unfinalized state. - Carol makes an offer on the NFT which Bob accepts. - `_acceptOffer()` will distribute funds on the sale between Bob and Carol before distributing funds on the sale between Alice and Bob. - The first call to `_distributeFunds()` will set the `_nftContractToTokenIdToFirstSaleCompleted` to true, meaning that future sales will only be charged the secondary foundation fee.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Ensure the `_nftContractToTokenIdToFirstSaleCompleted` is correctly tracked. It might be useful to ensure the distribution of funds are in the order of when the trades occurred. For example, an unfinalized auction should always have its fees paid before other sales.  "}, {"title": "EIP-712 signatures can be re-used in private sales", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/68", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L123-L174   # Vulnerability details  ## Impact Within a NFTMarketPrivateSale contract, buyers are allowed to purchase a seller's NFT. This is done through a seller providing a buyer a EIP-712 signature. The buyer can then call `#buyFromPrivateSaleFor` providing the v, r, and s values of the signature as well as any additional details to generate the message hash. If the signature is valid, then the NFT is transferred to the buyer.   The problem with the code is that EIP-712 signatures can be re-used within a small range of time assuming that the original seller takes back ownership of the NFT. This is because the NFTMarketPrivateSale#buyFromPrivateSaleFor method has no checks to determine if the EIP-712 signature has been used before.   ## Proof of Concept  Consider the following example:  1. Joe the NFT owner sells a NFT to the malicious buyer Rachel via a private sale.  2. Rachel through this private sale obtains the EIP-712 signature and uses it to purchase a NFT. 3. Joe the NFT owner purchases back the NFT within two days of the original sale to Rachel. 4. Joe the NFT owner puts the NFT back on sale. 5. Rachel, who has the original EIP-712 signature, can re-purchase the NFT by calling `#buyFromPrivateSaleFor` again with the same parameters they provided in the original private sale purchase in step 1.  The `#buyFromPrivateSaleFor` [function](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L123) runs several validation checks before transferring the NFT over to the buyer. The validations are as follows:  1. L#132 - The signature has expired. 2. L#135 - The deadline is beyond 48 hours from now. 3. L#143 - The amount argument is greater than msg.value. 4. L#149 - The msg.value is greater than the amount set. 5. L#171 - This checks that the EIP-712 signature comes from the NFT seller.  As you can see, there are no checks that the EIP-712 signature has been used before. If the original NFT seller purchases back the NFT, then they are susceptible to having the original buyer taking back the NFT. This can be problematic if the NFT has risen in value, as the original buyer can utilize the same purchase amount from the first transaction in this malicious transaction.  ## Tools Used Pen and paper  ## Recommended Mitigation Steps Most contracts utilize nonces when generating EIP-712 signatures to ensure that the contract hasn't been used for. When a nonce is injected into a signature, it makes it impossible for re-use, assuming of course the nonce feature is done correctly.  "}, {"title": "Escrowed NFT can be stolen by anyone if no active buyPrice or auction exists for it", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87   # Vulnerability details     ## Impact  If a NFT happens to be in escrow with neither buyPrice, nor auction being initialised for it, there is a way to obtain it for free by any actor via `makeOffer`, `acceptOffer` combination.  I.e. a malicious user can track the FNDNFTMarket contract and obtain any NFT from it for which there are no buyPrice or auction structures initialised. For example, if a NFT is mistakenly sent to the contract, an attacker can immediately steal it.  This will happen as NFT is being guarded by buyPrice and auction structures only. The severity here is medium as normal usage of the system imply that either one of them is initialised (NFT was sent to escrow as a part of `setBuyPrice` or `createReserveAuction`, and so one of the structures is present), so this seems to leave only mistakenly sent assets exposed.  ## Proof of Concept  An attacker can make a tiny offer with `makeOffer`:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L189  Then call `acceptOffer`, which will lead to `_acceptOffer`.  Direct NFT transfer will fail in `_acceptOffer` as the NFT is being held by the contract and `_transferFromEscrow` will be called instead:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271  `_transferFromEscrow` calls will proceed according to the FNDNFTMarket defined order: ``` function _transferFromEscrow( ... ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {    super._transferFromEscrow(nftContract, tokenId, recipient, seller); } ```  If there are no corresponding structures, the NFTMarketOffer, NFTMarketBuyPrice and NFTMarketReserveAuction versions of `_transferFromEscrow` will pass through the call to NFTMarketCore's plain transfer implementation:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87  This will effectively transfer the NFT to the attacker, which will pay gas costs and an arbitrary small offer price for it.  ## Recommended Mitigation Steps  Consider adding additional checks to control who can obtain unallocated NFTs from the contract.  Protocol controlled entity can handle such cases manually by initial sender's request.  "}, {"title": "An offer made after auction end can be stolen by an auction winner", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/49", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560   # Vulnerability details   ## Impact  An Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as `_transferFromEscrow` being called by `_acceptOffer` will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.  This way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.  ## Proof of Concept  When an auction has ended, there is a possibility to make the offers for an auctioned NFT as:  `makeOffer` checks `_isInActiveAuction`:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L200  `_isInActiveAuction` returns false when `auctionIdToAuction[auctionId].endTime < block.timestamp`, so `makeOffer` above can proceed:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L666-L669  Then, the auction winner can call `acceptOffer -> _acceptOffer` (or `setBuyPrice -> _autoAcceptOffer -> _acceptOffer`).  `_acceptOffer` will try to transfer directly, and then calls `_transferFromEscrow`:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271  If the auction has ended, but a winner hasn't picked up the NFT yet, the direct transfer will fail, proceeding with `_transferFromEscrow` in the FNDNFTMarket defined order: ``` function _transferFromEscrow( address nftContract, uint256 tokenId, address recipient, address seller ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) { super._transferFromEscrow(nftContract, tokenId, recipient, seller); } ```  NFTMarketOffer._transferFromEscrow will call super as `nftContractToIdToOffer` was already deleted:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L296-L302  NFTMarketBuyPrice._transferFromEscrow will call super as there is no buy price set:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L283-L293  Finally, NFTMarketReserveAuction._transferFromEscrow will send the NFT to the winner via `_finalizeReserveAuction`, not to the user who made the offer:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560  The `recipient` user who made the offer is not present in this logic, the NFT is being transferred to the `auction.bidder`, and the original `acceptOffer` will go through successfully.  ## Recommended Mitigation Steps  An attempt to set a buy price from auction winner will lead to auction finalisation, so `_buy` cannot be called with a not yet finalised auction, this way the NFTMarketReserveAuction._transferFromEscrow L550-L560 logic is called from the NFTMarketOffer._acceptOffer only:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L270  is the only user of   https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L550-L560   This way the fix is to update L556-L560 for the described case as:  Now: ``` // Finalization will revert if the auction has not yet ended. _finalizeReserveAuction(auctionId, false);  // Finalize includes the transfer, so we are done here. return; ```  To be, we leave the NFT in the escrow and let L564 super call to transfer it to the recipient: ``` // Finalization will revert if the auction has not yet ended. _finalizeReserveAuction(auctionId, true); ```  "}, {"title": "Missing receiver validation in `withdrawFrom`", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/FETH.sol#L433   # Vulnerability details  ## Impact The `FETH.withdrawFrom` function does not validate its `to` parameter. Funds can be lost if `to` is the zero address.  > Similar issues have been judged as medium recently, see [Sandclock M-15](https://code4rena.com/reports/2022-01-sandclock/) / [Github issue](https://github.com/code-423n4/2022-01-sandclock-findings/issues/183#issuecomment-1024626171)  ## Recommended Mitigation Steps Check that `to != 0`.  "}, {"title": "Creators can steal sale revenue from owners' sales", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/30", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L158-L160 https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L196-L198 https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L97-L99   # Vulnerability details  According to the `README.md` > All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.  https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/README.md?plain=1#L21  Using the Royalty Registry an owner can decide to change the royalty information right before the sale is complete, affecting who gets what.  ## Impact By updating the registry to include the seller as one of the royalty recipients, the creator can steal the sale price minus fees. This is because if code finds that the seller is a royalty recipient the royalties are all passed to the creator regardless of whether the owner is the seller or not.  ## Proof of Concept ```solidity           // 4th priority: getRoyalties override           if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {             try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (               address payable[] memory _recipients,               uint256[] memory recipientBasisPoints             ) {               if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {                 bool hasRecipient;                 for (uint256 i = 0; i < _recipients.length; ++i) {                   if (_recipients[i] != address(0)) {                     hasRecipient = true;                     if (_recipients[i] == seller) {                       return (_recipients, recipientBasisPoints, true); ``` https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L127-L154  When `true` is returned as the final return value above, the following code leaves `ownerRev` as zero because `isCreator` is `true` ```solidity       uint256 ownerRev     )   {     bool isCreator;     (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);      // Calculate the Foundation fee     uint256 fee;     if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {       fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;     } else {       fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;     }      foundationFee = (price * fee) / BASIS_POINTS;      if (creatorRecipients.length > 0) {       if (isCreator) {         // When sold by the creator, all revenue is split if applicable.         creatorRev = price - foundationFee;       } else {         // Rounding favors the owner first, then creator, and foundation last.         creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;         ownerRevTo = seller;         ownerRev = price - foundationFee - creatorRev;       }     } else {       // No royalty recipients found.       ownerRevTo = seller;       ownerRev = price - foundationFee;     }   } ```  In addition, if the index of the seller in `_recipients` is greater than `MAX_ROYALTY_RECIPIENTS_INDEX`, then the seller is omitted from the calculation and gets zero (`_sendValueWithFallbackWithdraw()` doesn't complain when it sends zero) ```solidity         uint256 maxCreatorIndex = creatorRecipients.length - 1;         if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {           maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;         } ``` https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L76-L79  This issue does a lot of damage because the creator can choose whether and when to apply it on a sale-by-sale basis. Two other similar, but separate, exploits are available for the other blocks in `_getCreatorPaymentInfo()` that return arrays but they either require a malicious NFT implementation or can only specify a static seller for which this will affect things. In all cases, not only may the seller get zero dollars for the sale, but they'll potentially owe a lot of taxes based on the 'sale' price. The attacker may or may not be the creator - creators can be bribed with kickbacks.  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always calculate owner/seller revenue separately from royalty revenue   "}, {"title": "NFT owner can create multiple auctions", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/23", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketReserveAuction.sol#L325-L349 https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketReserveAuction.sol#L596-L599   # Vulnerability details  # Impact NFT owner can permanently lock funds of bidders.   # Proof of concept  Alice (the attacker) calls `createReserveAuction`, and creates one like normal. let this be auction id 1.  Alice calls `createReserveAuction` again, before any user has placed a bid (this is easy to guarantee with a deployed attacker contract). We'd expect that Alice wouldn't be able to create another auction, but she can, because `_transferToEscrow` doesn't revert if there's an existing auction. let this be Auction id 2.  Since `nftContractToTokenIdToAuctionId[nftContract][tokenId]` will contain auction id 2, all bidders will see that auction as the one to bid on (unless they inspect contract events or data manually).  Alice can now cancel auction id 1, then cancel auction id 2, locking up the funds of the last bidder on auction id 2 forever.  # Mitigation Prevent NFT owners from creating multiple auctions  "}, {"title": "SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/SendValueWithFallbackWithdraw.sol#L37-L77   # Vulnerability details  ## Impact The NFTMarketFees contract and the NFTMarketReserveAuction contract use the _sendValueWithFallbackWithdraw function to send ether to FoundationTreasury, CreatorRecipients, Seller, Bidder. When the receiver fails to receive due to some reasons (exceeding the gas limit or the receiver contract cannot receive ether), it will record the ether to be sent in the pendingWithdrawals variable.  ```   function _sendValueWithFallbackWithdraw(     address payable user,     uint256 amount,     uint256 gasLimit   ) internal {     if (amount == 0) {       return;     }     // Cap the gas to prevent consuming all available gas to block a tx from completing successfully     // solhint-disable-next-line avoid-low-level-calls     (bool success, ) = user.call{ value: amount, gas: gasLimit }(\"\");     if (!success) {       // Record failed sends for a withdrawal later       // Transfers could fail if sent to a multisig with non-trivial receiver logic       unchecked {         pendingWithdrawals[user] += amount;       }       emit WithdrawPending(user, amount);     }   } ``` The user can then withdraw ether via the withdraw or withdrawFor functions. ```   function withdraw() external {     withdrawFor(payable(msg.sender));   }   function withdrawFor(address payable user) public nonReentrant {     uint256 amount = pendingWithdrawals[user];     if (amount == 0) {       revert SendValueWithFallbackWithdraw_No_Funds_Available();     }     pendingWithdrawals[user] = 0;     user.sendValue(amount);     emit Withdrawal(user, amount);   } ``` However, the withdrawFor function can only send ether to the address recorded in pendingWithdrawals. When the recipient is a contract that cannot receive ether, these ethers will be locked in the contract and cannot be withdrawn. ## Proof of Concept https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/SendValueWithFallbackWithdraw.sol#L37-L77 ## Tools Used None ## Recommended Mitigation Steps Add the withdrawTo function as follows:  ```   function withdrawTo(address payable to) public nonReentrant {     uint256 amount = pendingWithdrawals[msg.sneder];     if (amount == 0) {       revert SendValueWithFallbackWithdraw_No_Funds_Available();     }     pendingWithdrawals[msg.sneder] = 0;     to.sendValue(amount);     emit Withdrawal(msg.sneder, amount);   } ```  "}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/9", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L150   # Vulnerability details  ## Impact In NFTMarketOffer.sol the adminCancelOffers() function has comments above it that mention   \"tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`\"  This means that both the tokensIds and nftContracts arrays must be the same length but this is not required in the code of the function itself which can lead to the function failing.   ## Proof of Concept https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L150  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add to adminCancelOffers() function:   require(nftContracts.length == tokenIds.length, Arrays must be same length\");  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/38", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "2022-03-timeswap  1 delete unused import statement.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/CollateralizedDebt.sol#L5  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "2022-03-timeswap gas optimization  1 Use memory for cache instead of storage.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L62  State memory state = pools[maturity].state; "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# QA Report  **Table of Contents:**  - [QA Report](#qa-report)   - [Global remarks](#global-remarks)   - [File: TimeswapConvenience.sol](#file-timeswapconveniencesol)     - [receive()](#receive)       - [The require statement should have a revert string](#the-require-statement-should-have-a-revert-string)     - [functions timeswapMintCallback() / timeswapLendCallback() / timeswapBorrowCallback() / timeswapPayCallback()](#functions-timeswapmintcallback--timeswaplendcallback--timeswapborrowcallback--timeswappaycallback)       - [A duplicated piece of code should be refactored as a function](#a-duplicated-piece-of-code-should-be-refactored-as-a-function)  ## Global remarks  1. `TimeswapConvenience.sol:receive()` is missing a friendly revert string. 2. For maintainability and readability: duplicated code should be avoided  ## File: TimeswapConvenience.sol  ### receive()  #### The require statement should have a revert string  Here, a friendly message should exist for users to understand what went wrong:  ```jsx File: TimeswapConvenience.sol 74:     receive() external payable { 75:         require(msg.sender == address(weth)); 76:     } ```  This is the only require statement in the whole solution that misses a revert string. This is especially important IMHO as `receive()` is a callback, not a function, and therefore it might be harder to guess why the transaction reverted here.  ### functions timeswapMintCallback() / timeswapLendCallback() / timeswapBorrowCallback() / timeswapPayCallback()  #### A duplicated piece of code should be refactored as a function  Those 4 functions are using a refactorable piece of code:  ```jsx File: TimeswapConvenience.sol 549:     function timeswapMintCallback( 550:         uint256 assetIn, 551:         uint112 collateralIn, 552:         bytes calldata data 553:     ) external override { 554:         (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode( 555:             data, 556:             (IERC20, IERC20, address, address) 557:         ); 558:         IPair pair = factory.getPair(asset, collateral); 559:  560:         require(msg.sender == address(pair), 'E701'); 561:  562:         IWETH _weth = weth; 563:  564:         if (assetFrom == address(this)) { 565:             _weth.deposit{value: assetIn}(); 566:             asset.safeTransfer(pair, assetIn); 567:         } else { 568:             asset.safeTransferFrom(assetFrom, pair, assetIn); 569:         } 570:  571:         if (collateralFrom == address(this)) { 572:             _weth.deposit{value: collateralIn}(); 573:             collateral.safeTransfer(pair, collateralIn); 574:         } else { 575:             collateral.safeTransferFrom(collateralFrom, pair, collateralIn); 576:         } 577:     } 578:  579:     /// @inheritdoc ITimeswapLendCallback 580:     function timeswapLendCallback(uint256 assetIn, bytes calldata data) external override {  581:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 582:         IPair pair = factory.getPair(asset, collateral); 583:  584:         require(msg.sender == address(pair), 'E701'); 585:  586:         if (from == address(this)) { 587:             weth.deposit{value: assetIn}(); 588:             asset.safeTransfer(pair, assetIn); 589:         } else { 590:             asset.safeTransferFrom(from, pair, assetIn); 591:         } 592:     } 593:  594:     /// @inheritdoc ITimeswapBorrowCallback 595:     function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external override { 596:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 597:         IPair pair = factory.getPair(asset, collateral); 598:         require(msg.sender == address(pair), 'E701'); 599:         if (from == address(this)) { 600:             weth.deposit{value: collateralIn}(); 601:             collateral.safeTransfer(pair, collateralIn); 602:         } else { 603:             collateral.safeTransferFrom(from, pair, collateralIn); 604:         } 605:     } 606:  607:     /// @inheritdoc ITimeswapPayCallback 608:     function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override { 609:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 610:  611:         IPair pair = factory.getPair(asset, collateral); 612:         require(msg.sender == address(pair), 'E701'); 613:  614:         if (from == address(this)) { 615:             weth.deposit{value: assetIn}(); 616:             asset.safeTransfer(pair, assetIn); 617:         } else { 618:             asset.safeTransferFrom(from, pair, assetIn); 619:         } 620:     } ```  For maintainability and readability, I suggest creating a private function (here `_timeswapCallback`) and using it as such:  ```jsx File: TimeswapConvenience.sol 549:     function timeswapMintCallback(  550:         uint256 assetIn, 551:         uint112 collateralIn, 552:         bytes calldata data 553:     ) external override { 554:         (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode( 555:             data, 556:             (IERC20, IERC20, address, address) 557:         ); 558:         IPair pair = factory.getPair(asset, collateral); 559:         _timeswapCallback(asset, pair, assetFrom, assetIn, data); 560:         _timeswapCallback(asset, pair, collateralFrom, collateralIn, data); 561:     } 562:  563:     /// @inheritdoc ITimeswapLendCallback 564:     function timeswapLendCallback(uint256 assetIn, bytes calldata data) external override {  565:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 566:         IPair pair = factory.getPair(asset, collateral); 567:         _timeswapCallback(asset, pair, from, assetIn, data); 568:     } 569:  570:     /// @inheritdoc ITimeswapBorrowCallback 571:     function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external override { 572:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 573:         IPair pair = factory.getPair(asset, collateral); 574:         _timeswapCallback(asset, pair, from, collateralIn, data); 575:     } 576:  577:     /// @inheritdoc ITimeswapPayCallback 578:     function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override { 579:         (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address)); 580:         IPair pair = factory.getPair(asset, collateral); 581:         _timeswapCallback(asset, pair, from, assetIn, data); 582:     } 583:  584:     function _timeswapCallback(IERC20 asset, IIPair pair, address from, uint256 assetOrCollateralIn) private { 585:         require(msg.sender == address(pair), 'E701'); 586:         if (from == address(this)) { 587:             weth.deposit{value: assetOrCollateralIn}(); 588:             asset.safeTransfer(pair, assetOrCollateralIn); 589:         } else { 590:             asset.safeTransferFrom(from, pair, assetOrCollateralIn); 591:         } 592:     } ```  Names and arguments can be changed according to the sponsor's preference, this is simply a suggestion. Here, `pair` was evaluated outside of `_timeswapCallback()` and passed as an argument to save gas (1 extra external call). The original piece of code `L562: IWETH _weth = weth;` is also unnecessary as the state variable is immutable. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# Gas Reduction opportunities  To check the actual size of the reduction, ``hardhat-gas-reporter`` is used. ( https://www.npmjs.com/package/hardhat-gas-reporter ). At each result, it lists how many size of the gas is reduced after the change.  --- # Title: ``Borrow.sol`` can shorten the code size and gas fee by extracting common functionality into private function  Here are codes which can be shared by a function. https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L368-L369  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L409-L410  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L452-L453  The above codes use following logic which can be shared: ``` IPair pair = params.factory.getPair(params.asset, params.collateral); require(address(pair) != address(0), 'E501'); ```  Here is an example common function: ``` function _commonCheck(     IFactory factory,     IERC20 asset,     IERC20 collateral ) private view returns(IPair pair) {     pair = factory.getPair(asset, collateral);     require(address(pair) != address(0), 'E501'); } ```  The above function can be used at each place like this: ``` IPair pair = _commonCheck(params.factory, params.asset, params.collateral); ```  Here is the comparison of the gas cost at Borrow.sol - Before: 2591800 - After: 2524220 - Redution: 67580 (About 2.6% reduction)  Borrow.sol  - Before: 11.48 KB - After: 11.17 KB - Reduction: 0.31 KB  ---"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# Gas Report  **Table of Contents:**  - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [File: CollateralizedDebt.sol](#file-collateralizeddebtsol)     - [modifier onlyConvenience()](#modifier-onlyconvenience)       - [Inline a modifier that's only used once](#inline-a-modifier-thats-only-used-once)   - [File: TimeswapPair.sol](#file-timeswappairsol)     - [function mint()](#function-mint)       - [Use memory variables for calculation](#use-memory-variables-for-calculation)     - [function burn()](#function-burn)       - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof)     - [function lend()](#function-lend)       - [Use memory variables for calculation](#use-memory-variables-for-calculation-1)     - [function borrow()](#function-borrow)       - [Use memory variables for calculation](#use-memory-variables-for-calculation-2)     - [function pay()](#function-pay)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)   - [General recommendation](#general-recommendation)     - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword  - **Storage-reading optimizations**  > The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). In the paragraphs below, please see the `@audit-issue` tags in the pieces of code's comments for more information about SLOADs that could be saved by caching the mentioned **storage** variables in **memory** variables.  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## File: CollateralizedDebt.sol  ### modifier onlyConvenience()  #### Inline a modifier that's only used once  As `onlyConvenience()` is only used once in this contract (in `function mint()`), it should get inlined to save gas:  ```jsx File: CollateralizedDebt.sol 80:     modifier onlyConvenience() { 81:         require(msg.sender == address(convenience), 'E403'); 82:         _; 83:     } 84:  85:     function mint(address to, uint256 id) external override onlyConvenience { //@audit onlyConvenience modifier only used only here: inline it. 86:         _safeMint(to, id); 87:     } ```  ## File: TimeswapPair.sol  ### function mint()  #### Use memory variables for calculation  The code can be optimized from this:  ```jsx File: TimeswapPair.sol 185:         pool.state.x += param.xIncrease; 186:         pool.state.y += param.yIncrease; 187:         pool.state.z += param.zIncrease; ... 193:         emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z); //@audit can save 3 SLOADs by using memory for calc ```  to this:  ```jsx File: TimeswapPair.sol 185:         (uint112 _poolStateX, uint112 _poolStateY, uint112 _poolStateZ) = (pool.state.x + param.xIncrease, pool.state.y + param.yIncrease, pool.state.z + param.zIncrease); 186:  187:         pool.state.x = _poolStateX; 188:         pool.state.y = _poolStateY; 189:         pool.state.z = _poolStateZ; ... 195:         emit Sync(param.maturity, _poolStateX, _poolStateY, _poolStateZ); ```  ### function burn()  #### `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  I suggest changing `> 0` with `!= 0` here:  ```jsx File: TimeswapPair.sol 225:         require(pool.state.totalLiquidity > 0, 'E206'); //@audit should be != 0 ```  Also, please enable the Optimizer.  ### function lend()  #### Use memory variables for calculation  Just like in `function mint()` ( [Use memory variables for calculation](#use-memory-variables-for-calculation) ), the code can be optimized here by caching the new values for `pool.state.x`, `pool.state.y` and `pool.state.z` :  ```jsx File: TimeswapPair.sol 310:         pool.state.x += param.xIncrease; 311:         pool.state.y -= param.yDecrease; 312:         pool.state.z -= param.zDecrease; ... 320:         emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);//@audit can save 3 SLOADs by using memory for calc ```  The same way, the final code will look like this (with the difference that `yDecrease` and `zDecreased` are used here):  ```jsx          (uint112 _poolStateX, uint112 _poolStateY, uint112 _poolStateZ) = (pool.state.x + param.xIncrease, pool.state.y - param.yDecrease, pool.state.z - param.zDecrease);            pool.state.x = _poolStateX;          pool.state.y = _poolStateY;          pool.state.z = _poolStateZ; ...          emit Sync(param.maturity, _poolStateX, _poolStateY, _poolStateZ); ```  ### function borrow()  #### Use memory variables for calculation  Just like in `function mint()` ( [Use memory variables for calculation](#use-memory-variables-for-calculation) ) and `function lend()`, the code can be optimized here by caching the new values for `pool.state.x`, `pool.state.y` and `pool.state.z` :  ```jsx File: TimeswapPair.sol 432:         pool.state.x -= param.xDecrease; 433:         pool.state.y += param.yIncrease; 434:         pool.state.z += param.zIncrease; ... 444:         emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);//@audit can save 3 SLOADs by using memory for calc  ```  The same way, the final code will look like this (with the difference that `xDecrease` is used here):  ```jsx          (uint112 _poolStateX, uint112 _poolStateY, uint112 _poolStateZ) = (pool.state.x - param.xDecrease, pool.state.y + param.yIncrease, pool.state.z + param.zIncrease);            pool.state.x = _poolStateX;          pool.state.y = _poolStateY;          pool.state.z = _poolStateZ; ...          emit Sync(param.maturity, _poolStateX, _poolStateY, _poolStateZ); ```  ### function pay()  #### An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead:  ```jsx File: TimeswapPair.sol 480:         for (uint256 i; i < param.ids.length;) { //@audit cache this ```  ## General recommendation  ### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  ```jsx Timeswap/Convenience/contracts/BondInterest.sol:61:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/BondPrincipal.sol:61:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/CollateralizedDebt.sol:45:        require(_owners[id] != address(0), 'E404'); Timeswap/Convenience/contracts/CollateralizedDebt.sol:62:        require(id < pair.totalDuesOf(maturity, address(convenience)), 'E614'); Timeswap/Convenience/contracts/CollateralizedDebt.sol:81:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/InsuranceInterest.sol:61:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/InsurancePrincipal.sol:61:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/Liquidity.sol:52:        require(msg.sender == address(convenience), 'E403'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:64:        require(address(_factory) != address(0), 'E601'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:65:        require(address(_weth) != address(0), 'E601'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:66:        require(address(_factory) != address(_weth), 'E612'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:75:        require(msg.sender == address(weth)); Timeswap/Convenience/contracts/TimeswapConvenience.sol:560:        require(msg.sender == address(pair), 'E701'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:584:        require(msg.sender == address(pair), 'E701'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:598:        require(msg.sender == address(pair), 'E701'); Timeswap/Convenience/contracts/TimeswapConvenience.sol:612:        require(msg.sender == address(pair), 'E701'); Timeswap/Core/contracts/TimeswapFactory.sol:38:        require(_owner != address(0), 'E101'); Timeswap/Core/contracts/TimeswapFactory.sol:48:        require(asset != collateral, 'E103'); Timeswap/Core/contracts/TimeswapFactory.sol:49:        require(asset != IERC20(address(0)) && collateral != IERC20(address(0)), 'E101'); Timeswap/Core/contracts/TimeswapFactory.sol:50:        require(getPair[asset][collateral] == IPair(address(0)), 'E104'); Timeswap/Core/contracts/TimeswapFactory.sol:61:        require(msg.sender == owner, 'E102'); Timeswap/Core/contracts/TimeswapFactory.sol:62:        require(_pendingOwner != address(0), 'E101'); Timeswap/Core/contracts/TimeswapFactory.sol:70:        require(msg.sender == pendingOwner, 'E102'); Timeswap/Core/contracts/TimeswapPair.sol:131:        require(locked == 1, 'E211'); Timeswap/Core/contracts/TimeswapPair.sol:151:        require(block.timestamp < param.maturity, 'E202'); Timeswap/Core/contracts/TimeswapPair.sol:152:        unchecked { require(param.maturity - block.timestamp < 0x100000000, 'E208'); } Timeswap/Core/contracts/TimeswapPair.sol:153:        require(param.liquidityTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:154:        require(param.dueTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:155:        require(param.liquidityTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:156:        require(param.dueTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:157:        require(param.xIncrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:158:        require(param.yIncrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:159:        require(param.zIncrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:172:        require(liquidityOut != 0, 'E212'); Timeswap/Core/contracts/TimeswapPair.sol:217:        require(block.timestamp >= param.maturity, 'E203'); Timeswap/Core/contracts/TimeswapPair.sol:218:        require(param.assetTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:219:        require(param.collateralTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:220:        require(param.assetTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:221:        require(param.collateralTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:222:        require(param.liquidityIn != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:225:        require(pool.state.totalLiquidity > 0, 'E206'); Timeswap/Core/contracts/TimeswapPair.sol:273:        require(block.timestamp < param.maturity, 'E202'); Timeswap/Core/contracts/TimeswapPair.sol:274:        require(param.bondTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:275:        require(param.insuranceTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:276:        require(param.bondTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:277:        require(param.insuranceTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:278:        require(param.xIncrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:281:        require(pool.state.totalLiquidity != 0, 'E206'); Timeswap/Core/contracts/TimeswapPair.sol:342:        require(block.timestamp >= param.maturity, 'E203'); Timeswap/Core/contracts/TimeswapPair.sol:343:        require(param.assetTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:344:        require(param.collateralTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:345:        require(param.assetTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:346:        require(param.collateralTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:347:        require( Timeswap/Core/contracts/TimeswapPair.sol:401:        require(block.timestamp < param.maturity, 'E202'); Timeswap/Core/contracts/TimeswapPair.sol:402:        require(param.assetTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:403:        require(param.dueTo != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:404:        require(param.assetTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:405:        require(param.dueTo != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:406:        require(param.xDecrease != 0, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:409:        require(pool.state.totalLiquidity != 0, 'E206'); Timeswap/Core/contracts/TimeswapPair.sol:468:        require(block.timestamp < param.maturity, 'E202'); Timeswap/Core/contracts/TimeswapPair.sol:469:        require(param.owner != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:470:        require(param.to != address(0), 'E201'); Timeswap/Core/contracts/TimeswapPair.sol:471:        require(param.to != address(this), 'E204'); Timeswap/Core/contracts/TimeswapPair.sol:472:        require(param.ids.length == param.assetsIn.length, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:473:        require(param.ids.length == param.collateralsOut.length, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:478:        require(dues.length >= param.ids.length, 'E205'); Timeswap/Core/contracts/TimeswapPair.sol:482:            require(due.startBlock != BlockNumber.get(), 'E207'); Timeswap/Core/contracts/TimeswapPair.sol:483:            if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213'); Timeswap/Core/contracts/TimeswapPair.sol:484:            require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303'); Timeswap/Core/contracts/TimeswapPair.sol:514:        require(msg.sender == factory.owner(), 'E216'); ```  I suggest replacing revert strings with custom errors. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L166   # Vulnerability details  ## Impact  Standard ERC721 tokenURI call will fail for CollateralizedDebt pools whose underlying pair.asset() or pair.collateral() have decimals lower than 4 whenever the corresponding due quantity is lower than 1e9.  Pair's asset and collateral ERC20 can be arbitrary and some ERC20 contracts have decimals lower than 4, so such a combination is possible. In such cases current tokenURI implementation fails, which can be the issue for all integrations down the line as various systems routinely make tokenURI calls.  Placing severity to be medium per 'Assets not at direct risk, but the function of the protocol or its availability could be impacted', which is the case here as protocol availability is in question when EIP level functionality fails.  ## References  https://eips.ethereum.org/EIPS/eip-721  https://github.com/d-xo/weird-erc20#low-decimals   ## Proof of Concept  NFTTokenURIScaffold.weiToPrecisionString will fail if used for a token with decimals lower than 4 as subtraction is performed without prior checks:  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L166  NFTTokenURIScaffold.weiToPrecisionString is called by NFTTokenURIScaffold.tokenURI for pair's asset and collateral ERC20:  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L16-L39  NFTTokenURIScaffold.tokenURI is used in CollateralizedDebt.tokenURI:  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/CollateralizedDebt.sol#L46  Pair's asset and collateral tokens can be arbitrary, while tokenURI is routinely requested by a variety of external systems  ## Recommended Mitigation Steps  Consider adding the check and special care for low decimals case, for example add another naming rule similarly to how `significantDigits > 1e9` case is being handled  "}, {"title": "Underflown variable in ``borrowGivenDebtETHCollateral`` function", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/32", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L121-L127   # Vulnerability details  ## Impact ``borrowGivenDebtETHCollateral`` function does never properly call ``ETH.transfer`` due to underflow. If ``borrowGivenDebtETHCollateral`` function is not deprecated, it would cause unexpected behaviors for users.   ## Proof of Concept Here are codes which contain a potential issue.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L121-L127 ``` if (maxCollateral > dueOut.collateral) {     uint256 excess;     unchecked {         excess -= dueOut.collateral;     }     ETH.transfer(payable(msg.sender), excess); } ```  ``excess`` variable is ``uint256``, and ``dueOut.collateral`` variable is ``uint112`` as shown below. Hence, both variables will never be less than 0.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/interfaces/IPair.sol#L22-L26 ``` struct Due {     uint112 debt;     uint112 collateral;     uint32 startBlock; } ```  ``uint256 excess`` is initialized to 0. However, subtracting ``dueOut.collateral`` variable which is more than or equal to 0 from ``excess`` variable which is 0 will be less than 0. Hence, ``excess -= dueOut.collateral`` will be less than 0, and ``excess`` will be underflown.   ## Tools Used static code analysis   ## Recommended Mitigation Steps The code should properly initialize ``excess`` variable.  ``borrowGivenPercentETHCollateral`` function uses ``uint256 excess = maxCollateral`` at similar functionality. https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L347  Hence, just initializing ``excess`` variable with ``maxCollateral`` can be a potential workaround to prevent the underflown. ``` if (maxCollateral > dueOut.collateral) {     uint256 excess = maxCollateral;     unchecked {         excess -= dueOut.collateral;     }     ETH.transfer(payable(msg.sender), excess); } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "#1 using != instead < https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L225 https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L225 by using != instead of > or < to validate can save gas  #2 Simple way to set `assetOut` value https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L238-L239 https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L436-L438 In the current implementation the value of `assetOut` was set multipleTime. use this to save gas: ``` assetOut = _assetOut + feeOut; ``` #3  Removing && operator can saving more gas usage  POC it can be seen from my report here : https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L49 instead of using operator && on single require check. using additional require check can save more execution gas. occurance : https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L49  Recommended Mitigation Steps: ``` require(asset != IERC20(address(0)), 'E101'); require(collateral != IERC20(address(0)), 'E101'); ```  #4 Simple way to set `assetIn` value https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L189-L190 https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L314-L316 In the current implementation the value of `assetIn` was set multiple times. use this to save gas: ``` assetIn = param.xIncrease + feeStoredIncrease ``` #5 Unused `SafeERC20` lib https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L18 The `SafeERC20.functions()` was never called in this contract. Remove L6 and L18.  #6 Better way to use library for saving more gas  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/TimeswapConvenience.sol#L29-L35  less gas usage by not declearing library used (L28-L35). Removing line which declare that       using Mint for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Burn for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Lend for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Withdraw for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Borrow for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using Pay for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));     using DeployNative for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));   and call library.function() directly can saving both deploying and execution gas usage.  for ex.      function deployNatives(DeployNatives calldata params) external override {         natives.deploy(this, factory, params);      }       change to   DeployNatives.deploy(natives, this, factory, params); //--> Call the library name directly and passed natives to the first argument.    #7 Unnecessary SafeTransfer Library  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/contracts/TimeswapConvenience.sol#L28  because it was the only SafeERC20.function lib were used, so it better to just use transfer and transferFrom from ERC20.function to saving more gas.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "Title: The `setOwner()` function name https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L60 The `owner` is not set in the function. I recommend to change the name to `setPendingOwner()` (and also the event L 65)   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# Use custom errors Solidity ^0.8.4 allow the use of custom errors to optimize gas usage. https://blog.soliditylang.org/2021/04/21/custom-errors/  # Consolidate operations For example: https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L189 ```         assetIn = param.xIncrease + feeStoredIncrease; ``` https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L238 ```         assetOut = _assetOut + feeOut; ``` https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L314 ```         assetIn = param.xIncrease + feeStoredIncrease + protocolFeeStoredIncrease; ``` https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L436 ```         assetOut = param.xDecrease - feeStoredIncrease - protocolFeeStoredIncrease; ``` There are also a lot of similar case in  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/libraries/TimeswapMath.sol  # Unnecessary modulo https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/libraries/SafeCast.sol#L6 `uint32(x)` is same as `uint32(x % 0x100000000)` ```         y = uint32(x % 0x100000000); ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "1. considered using bool in `modifier lock()` can save gas https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L130  Example: ``` pragma solidity =0.8.4;  contract test {  bool internal _locked = true; uint256 internal _lock = 1;  modifier noReenter() {         require(_locked, \"LOCKED\");         _locked = true;         _;         _locked = false;     } modifier noReentir(){         require(_lock == 1, \"LOCKED\");         _lock = 2;         _;         _lock = 1; }      function abc() public noReenter returns(uint){         return 12121;         // 22066     }     function def() public noReentir returns(uint){         return 1234;         // 23752     } } ```  ========================================================================  2. `> 0` is less efficient than `!= 0` for uint in require condition https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L225  Change it the same as this: https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L281  ========================================================================  3. Shift right instead of dividing by 2 https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/SquareRoot.sol#L6  issue information: https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g008---use-shift-rightleft-instead-of-divisionmultiplication-if-possible  Tools used c4udit  ========================================================================  4. multiple `require` can save gas https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L49  Change to: ``` require(asset != IERC20(address(0)); require(collateral != IERC20(address(0)), 'E101'); ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "**[S]**: Suggested optimation, save a decent amount of gas without compromising readability;  **[M]**: Minor optimation, the amount of gas saved is minor, change when you see fit;  **[N]**: Non-preferred, the amount of gas saved is at cost of readability, only apply when gas saving is a top priority.  ## [S] Avoid unnecessary storage read can save gas  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L56-L64  ```solidity     function constantProduct(uint256 maturity)         external         view         override         returns (uint112, uint112, uint112)     {         State storage state = pools[maturity].state;         return (state.x, state.y, state.z);     } ```  Can be changed to:  ```solidity     function constantProduct(uint256 maturity)         external         view         override         returns (uint112, uint112, uint112)     {         State memory state = pools[maturity].state;         return (state.x, state.y, state.z);     } ```  ## [M] \"> 0\" is less efficient than \"!= 0\" for unsigned integers  It is cheaper to use `!= 0` than `> 0` for uint256.  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L225-L226  ```solidity         require(pool.state.totalLiquidity > 0, 'E206');  ```  ## [S] Cache storage variables in the stack can save gas  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L510  `param.ids.length` can be cached as it will be read for more than 4 times.   ## [S] Do not reduce approval on transferFrom if current allowance is type(uint256).max  The Wrapped Ether (WETH) ERC-20 contract has a gas optimization that does not update the allowance if it is the max uint.  The latest version of OpenZeppelin's ERC20 token contract also adopted this optimization.  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/contracts/base/ERC20.sol#L16-L25  ```solidity function transferFrom(         address from,         address to,         uint256 amount     ) external override returns (bool) {         _approve(from, msg.sender, allowance[from][msg.sender] - amount);         _transfer(from, to, amount);          return true;     } ``` ```  See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162 -   https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085 "}, {"title": "[WP-H1] Wrong timing of check allows users to withdraw collateral without paying for the debt", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/16", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L490   # Vulnerability details  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L490  ```solidity function pay(PayParam calldata param)     external      override      lock      returns (         uint128 assetIn,          uint128 collateralOut     )  {     require(block.timestamp < param.maturity, 'E202');     require(param.owner != address(0), 'E201');     require(param.to != address(0), 'E201');     require(param.to != address(this), 'E204');     require(param.ids.length == param.assetsIn.length, 'E205');     require(param.ids.length == param.collateralsOut.length, 'E205');      Pool storage pool = pools[param.maturity];      Due[] storage dues = pool.dues[param.owner];     require(dues.length >= param.ids.length, 'E205');      for (uint256 i; i < param.ids.length;) {         Due storage due = dues[param.ids[i]];         require(due.startBlock != BlockNumber.get(), 'E207');         if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');         require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');         due.debt -= param.assetsIn[i];         due.collateral -= param.collateralsOut[i];         assetIn += param.assetsIn[i];         collateralOut += param.collateralsOut[i];         unchecked { ++i; }     }     ... ```  At L484, if there is only one `id`, and for the first and only time of the for loop, `assetIn` and `collateralOut` will be `0`, therefore `require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');` will pass.  A attacker can call `pay()` with `param.assetsIn[0] == 0` and `param.collateralsOut[i] == due.collateral`.  ### PoC  The attacker can:   1. `borrow()` `10,000 USDC` with `1 BTC` as `collateral`; 2. `pay()` with `0 USDC` as `assetsIn` and `1 BTC` as `collateralsOut`.  As a result, the attacker effectively stole `10,000 USDC`.  ### Recommendation  Change to:  ```solidity for (uint256 i; i < param.ids.length;) {     Due storage due = dues[param.ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');     due.debt -= param.assetsIn[i];     due.collateral -= param.collateralsOut[i];     assetIn += param.assetsIn[i];     collateralOut += param.collateralsOut[i];     unchecked { ++i; } }  require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303'); ... ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# Gas Optimizations ## optimize the for loop in the pay function of the TimeswapPair contracts The for loop in the pay function can be optimized. Let's look at the for loop: ```sol for (uint256 i; i < param.ids.length;) {     Due storage due = dues[param.ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');     due.debt -= param.assetsIn[i];     due.collateral -= param.collateralsOut[i];     assetIn += param.assetsIn[i];     collateralOut += param.collateralsOut[i];     unchecked { ++i; } } ```  It is pretty optimized, but it can be more optimized: 1. The array's length can be saved instead of being accessed in every iteration. 2. `param.assetsIn[i]` and `param.collateralsOut[i]` can be saved in order to save gas. Instead of accessing it multiple times in every iteration, these values can be saved in a local variable.  The code after these changes will look like this: ```sol uint length = param.ids.length; uint112 collateralOut_i; uint112 assetsIn_i;  for (uint256 i; i < length;) {     Due storage due = dues[param.ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');      assetsIn_i = param.assetsIn[i];     collateralOut_i = param.collateralOut[i];      if (param.owner != msg.sender) require(collateralOut_i == 0, 'E213');     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');     due.debt -= assetsIn_i;     due.collateral -= collateralOut_i;     assetIn += assetsIn_i;     collateralOut += collateralOut_i;     unchecked { ++i; } } ```   ## Use local variables (memory) instead of storage variables In order to save gas, local variables can be used instead of storage variables. For example, let's look at the `mint` function of the `TimeswapPair` contract: ```sol     function mint(MintParam calldata param)         external         override         lock         returns (             uint256 assetIn,             uint256 liquidityOut,             uint256 id,             Due memory dueOut         )     {            // ...          Pool storage pool = pools[param.maturity];          uint256 feeStoredIncrease;         (liquidityOut, dueOut, feeStoredIncrease) = TimeswapMath.mint(             param.maturity,             pool.state,             param.xIncrease,             param.yIncrease,             param.zIncrease         );          require(liquidityOut != 0, 'E212');         pool.state.totalLiquidity += liquidityOut;         pool.liquidities[param.liquidityTo] += liquidityOut;          pool.state.feeStored += feeStoredIncrease;           id = pool.dues[param.dueTo].insert(dueOut);          pool.state.reserves.asset += param.xIncrease;         pool.state.reserves.collateral += dueOut.collateral;         pool.state.totalDebtCreated += dueOut.debt;          pool.state.x += param.xIncrease;         pool.state.y += param.yIncrease;         pool.state.z += param.zIncrease;          assetIn = param.xIncrease;         assetIn += feeStoredIncrease;         Callback.mint(asset, collateral, assetIn, dueOut.collateral, param.data);          // ...     } ``` Here, a lot of changes are made to the pool variable. The pool variable is a storage variable (as we can see in here `Pool storage pool = pools[param.maturity]`), and instead of modifying it we can use a local (memory) variable and assign it to the storage memory in the end. That will made all the memory operations cheaper in gas and will cocnsume less gas.  This optimization can be done to the `pool` variable in more function in the `TimeswapPair` contract - the `burn`, `lend`, `withdraw`, `borrow` and `pay` functions.  ## optimize the `returnDataToString` function in the `SafeMetadata` library ```sol function returnDataToString(bytes memory data) private pure returns (string memory) {     if (data.length >= 64) {         return abi.decode(data, (string));     } else if (data.length == 32) {         uint8 i = 0;         while (i < 32 && data[i] != 0) {             i++;         }         bytes memory bytesArray = new bytes(i);         for (i = 0; i < 32 && data[i] != 0; i++) {             bytesArray[i] = data[i];         }         return string(bytesArray);     } else {         return '???';     } } ```  This function can be optimized in several ways: 1. Use ++i instead of i++. 2. Use unchecked on the increment of i. 3. Not initializing i to it's default value - when declaring the i variable, initializing it to zero actually costs more gas than just declaring it (`uint8 i;` is cheaper than `uint8 i = 0;`). 4. Instead of checking 2 conditions in the second loop, we can run using the new array length (the old i value).     The code after the mentioned changes will look like this: ```sol function returnDataToString(bytes memory data) private pure returns (string memory) {     if (data.length >= 64) {         return abi.decode(data, (string));     } else if (data.length == 32) {         uint8 i;         while (i < 32 && data[i] != 0) {             unchecked { ++i; }         }         bytes memory bytesArray = new bytes(i);         uint length = bytesArray.length;         for (i = 0; i < length; ) {             bytesArray[i] = data[i];             unchecked { ++i; }         }         return string(bytesArray);     } else {         return '???';     } } ```  These changes will save a great amount of gas spent on unnecessary stuff."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "### Storage of `uints`/`ints` smaller than 32 bytes incurs overhead > When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed ```solidity uint16 public immutable override fee;            ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L30  ```solidity uint16 public immutable override protocolFee;            ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L32  ```solidity uint16 public immutable override fee;            ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L21  ```solidity uint16 public immutable override protocolFee;            ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L23   ### `abi.encode()` is less efficient than `abi.encodePacked()` ```solidity bytes32 salt = keccak256(abi.encode(asset, collateral, maturity.toString()));           ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Deploy.sol#L35  ```solidity bytes(abi.encode(params.asset, params.collateral, params.from, params.maturity))             ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Pay.sol#L127  ```solidity bytes(abi.encode(params.asset, params.collateral, params.from))              ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L510  ```solidity bytes(abi.encode(params.asset, params.collateral, params.from))              ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Lend.sol#L383  ```solidity bytes(abi.encode(params.asset, params.collateral, params.assetFrom, params.collateralFrom))             ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Mint.sol#L690  ```solidity pair = new TimeswapPair{saltkeccak256(abi.encode(asset, collateral))}(asset, collateral, fee, protocolFee);         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol#L52   ### `require()` strings longer than 32 bytes cost extra gas Consider not using the version of this function that takes in a `string` ```solidity \"balanceOf Call to IERC20 token not successful\" ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/libraries/SafeBalance.sol#L16  ### Using `> 0` costs more gas than `!= 0` when used on uints in a `require()` statement ```solidity require(pool.state.totalLiquidity > 0, 'E206');             ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L225   ### Splitting `require()` statements that use `&&` saves gas See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) for an example ```solidity require(asset != IERC20(address(0)) && collateral != IERC20(address(0)), 'E101');         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapFactory.sol   ### `<array>.length` should not be looked up in every loop of a for-loop Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length ```solidity for (uint256 i; i < data.length; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L228  ```solidity for (uint256 i; i < param.ids.length;) {          ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L480  ### `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in for- and while-loops ```solidity for (i = 0; i < 32 && data[i] != 0; i++) {    ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/SafeMetadata.sol#L38  ```solidity for (uint256 i; i < lengthDiff; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L146  ```solidity for (uint256 i; i < lengthDiff; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L174  ```solidity for (uint256 i; i < data.length; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L228  ```solidity for (uint256 i; i <= end - begin; i++) {       ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L241   ### `++i` costs less gas than `++i`, especially when it's used in for-loops (`--i`/`i--` too) ```solidity for (i = 0; i < 32 && data[i] != 0; i++) {    ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/SafeMetadata.sol#L38  ```solidity for (uint256 i; i < lengthDiff; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L146  ```solidity for (uint256 i; i < lengthDiff; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L174  ```solidity for (uint256 i; i < data.length; i++) {         ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L228  ```solidity for (uint256 i; i <= end - begin; i++) {       ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L241   ### It costs more gas to initialize variables to zero than to let the default of zero be applied ```solidity uint8 i = 0;             ``` https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/SafeMetadata.sol#L33 "}, {"title": "NPM Dependency confusion. Unclaimed NPM Package and Scope/Org", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/9", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/package.json#L40   # Vulnerability details  ## Impact I discovered an npm package and the scope of the package is unclaimed on the NPM website. This will give any User to claim that package and be able to Upload a Malicious Code under that unclaimed package. This results in achieving the Remote code execution on developers/users' machine who depends on the timeswap repository to build it on local env.  ##Vulnerable Package Name: @timeswap-labs/timeswap-v1-core  ## Proof of Concept 1. Create an Organization called \"timeswap-labs\". 2. Create a package called \"@timeswap-labs/timeswap-v1-core\" under \"timeswap-labs\" Organization. 3. Attacker can able to upload malicious code on unclaimed npm package with a higher version like 99.99.99 4. Now If any user/timeswap developer installs it by npm install package.json. The malicious pkg will be executed.  Till now \"The Package is not claimed on NPM Registry, but it's vulnerable to dependency confusion\".  You can read more dependency confusion here: https://dhiyaneshgeek.github.io/web/security/2021/09/04/dependency-confusion/  ## Tools Used Nothing Just OSINT  ## Recommended Mitigation Steps Claim the Scope name called \"timeswap-labs\" By Following the above POC Step 1.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/7", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "1. Using mixed versions of openzeppelin: - Core:          \"@openzeppelin/contracts\": \"^4.2.0\" - Convenienve:   \"@openzeppelin/contracts\": \"^4.1.0\"  2. It seems that use an outdated version of openzeppelin - Core:          \"@openzeppelin/contracts\": \"^4.2.0\" - Convenienve:   \"@openzeppelin/contracts\": \"^4.1.0\" - **Latest:**        \"@openzeppelin/contracts\": \"4.5.0\"  3. Use a buggy solidity version with immutables. The contract use immutable, and this solidity version defined in the pragma has some issues with them, as you can see [here](https://github.com/ethereum/solidity/blob/develop/Changelog.md#089-2021-09-29).  4. Issue [69](https://github.com/code-423n4/2022-01-timeswap-findings/issues/69) remains active - [SafeMetadata.sol#L8-L27](https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/contracts/libraries/SafeMetadata.sol#L8-L27)"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L513-L522   # Vulnerability details  ## Impact collectProtocolFee function has a missing zero address check on `asset.safeTransfer(to, protocolFeeOut);`  A user may mistakenly make the transfer to a zero address which may lead to loss of Protocol Fee.  ## Proof of Concept https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/TimeswapPair.sol#L519  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require check for the address passed in collectProtocolFee()  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "  Title: Unused state variables Severity: GAS  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           Liquidity.sol, decimals  Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               TimeswapConvenience.repay (params)         TimeswapConvenience.repayETHAsset (params)         TimeswapConvenience.repayETHCollateral (params)    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           TimeswapPair.sol, ids.param, 480    Title: Unused declared local variables Severity: GAS  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           TimeswapConvenience.sol, timeswapMintCallback, _weth     "}, {"title": "[WP-H17] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/140", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L265-L291   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L265-L291  ```solidity function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {     uint256 accumulator = 0;     uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;     uint256 counter = block.timestamp;     uint256 i = rewardRateLog[_baseToken].length - 1;     while (true) {         if (lastUpdatedTime >= counter) {             break;         }         unchecked {             accumulator +=                 rewardRateLog[_baseToken][i].rewardsPerSecond *                 (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));         }         counter = rewardRateLog[_baseToken][i].timestamp;         if (i == 0) {             break;         }         --i;     }      // We know that during all the periods that were included in the current iterations,     // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the     // updates to the pool that happened after the lastUpdatedTime.     accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];     return accumulator + poolInfo[_baseToken].accTokenPerShare; } ```  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L286-L292  ```solidity uint256 mintedSharesAmount; // Adding liquidity in the pool for the first time if (totalReserve[token] == 0) {     mintedSharesAmount = BASE_DIVISOR * _amount; } else {     mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token]; } ```  In `HyphenLiquidityFarming`, the `accTokenPerShare` is calculated based on the total staked shares.  However, as the `mintedSharesAmount` can easily become very large on `LiquidityProviders.sol`, all the users can lose their rewards due to precision loss.  ### PoC  Given:  - rewardsPerSecond is `10e18`; - lastRewardTime is 24 hrs ago;  Then:  1. Alice `addTokenLiquidity()` with `1e8 * 1e18` XYZ on B-Chain, totalSharesMinted == `1e44`; 2. Alice `deposit()` to HyphenLiquidityFarming, totalSharesStaked == `1e44`; 3. 24 hrs later, Alice tries to claim the rewards.   `accumulator = rewardsPerSecond * 24 hours` == 864000e18 == 8.64e23  Expected Results: As the sole staker, Alice should get all the `864000e18` rewards.  Actual Results: Alice received 0 rewards.  That's becasue when `totalSharesStaked > 1e36`, `accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];` will be round down to `0`.  When the `totalSharesStaked` is large enough, all users will lose their rewards due to precision loss.  ### Recommendation  1. Consider lowering the `BASE_DIVISOR` so that the initial share price can be higher; 2. Consider making `ACC_TOKEN_PRECISION` larger to prevent precision loss;  See also the Recommendation on [WP-H14].  "}, {"title": "[WP-H14] `LiquidityProviders.sol` The share price of the LP can be manipulated and making future liquidityProviders unable to `removeLiquidity()`", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/139", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L345-L362   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L345-L362  ```solidity function removeLiquidity(uint256 _nftId, uint256 _amount)     external     nonReentrant     onlyValidLpToken(_nftId, _msgSender())     whenNotPaused {     (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);     require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");      require(_amount != 0, \"ERR__INVALID_AMOUNT\");     require(nftSuppliedLiquidity >= _amount, \"ERR__INSUFFICIENT_LIQUIDITY\");     whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);     // Claculate how much shares represent input amount     uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);      // Calculate rewards accumulated     uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress); ```  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityProviders.sol#L192-L194  ```solidity=192 function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {     return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress]; } ```  The share price of the liquidity can be manipulated to an extremely low value (1 underlying token worth a huge amount of shares), making it possible for `sharesToTokenAmount(totalNFTShares, _tokenAddress)` to overflow in `removeLiquidity()` and therefore freeze users' funds.   ### PoC  1. Alice `addTokenLiquidity()` with `1e8 * 1e18` XYZ on B-Chain, totalSharesMinted == `1e44`; 2. Alice `sendFundsToUser()` and bridge `1e8 * 1e18` XYZ from B-Chain to A-Chain; 3. Alice `depositErc20()` and bridge `1e8 * 1e18` XYZ from A-Chain to B-Chain; 4. Alice `removeLiquidity()` and withdraw `1e8 * 1e18 - 1` XYZ, then: `totalReserve` == `1 wei` XYZ, and `totalSharesMinted` == `1e26`; 5. Bob `addTokenLiquidity()` with `3.4e7 * 1e18` XYZ; 6. Bob tries to `removeLiquidity()`.  Expected Results: Bob to get back the deposits;  Actual Results: The tx reverted due to overflow at `sharesToTokenAmount()`.  ### Recommendation  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L280-L292  ```solidity=280 function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {     (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);      require(_amount > 0, \"ERR__AMOUNT_IS_0\");     whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);      uint256 mintedSharesAmount;     // Adding liquidity in the pool for the first time     if (totalReserve[token] == 0) {         mintedSharesAmount = BASE_DIVISOR * _amount;     } else {         mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];     }     ... ```  Consider locking part of the first mint's liquidity to maintain a minimum amount of `totalReserve[token]`, so that the share price can not be easily manipulated.  "}, {"title": "A `pauser` can brick the contracts", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/137", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/security/Pausable.sol#L65-L68   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/security/Pausable.sol#L65-L68  ```solidity     function renouncePauser() external virtual onlyPauser {         emit PauserChanged(_pauser, address(0));         _pauser = address(0);     } ```  A malicious or compromised `pauser` can call `pause()` and `renouncePauser()` to brick the contract and all the funds can be frozen.  ### PoC  Given:  * Alice (EOA) is the `pauser` of the contract.  1. Alice calls `pause()` ; 2. Alice calls `renouncePauser()`;   As a result, most of the contract's methods are now unavailable, and this cannot be reversed even by the `owner`.  ### Recommendation  Consider removing `renouncePauser()`, or requiring the contract not in `paused` mode when `renouncePauser()`.  "}, {"title": "[WP-H4] Deleting `nft Info` can cause users' `nft.unpaidRewards` to be permanently erased", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/135", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L229-L253   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L229-L253  ```solidity function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {     address msgSender = _msgSender();     uint256 nftsStakedLength = nftIdsStaked[msgSender].length;     uint256 index;     for (index = 0; index < nftsStakedLength; ++index) {         if (nftIdsStaked[msgSender][index] == _nftId) {             break;         }     }      require(index != nftsStakedLength, \"ERR__NFT_NOT_STAKED\");     nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];     nftIdsStaked[msgSender].pop();      _sendRewardsForNft(_nftId, _to);     delete nftInfo[_nftId];      (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);     amount /= liquidityProviders.BASE_DIVISOR();     totalSharesStaked[baseToken] -= amount;      lpToken.safeTransferFrom(address(this), msgSender, _nftId);      emit LogWithdraw(msgSender, baseToken, _nftId, _to); } ```   https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L122-L165  ```solidity function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {     NFTInfo storage nft = nftInfo[_nftId];     require(nft.isStaked, \"ERR__NFT_NOT_STAKED\");      (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);     amount /= liquidityProviders.BASE_DIVISOR();      PoolInfo memory pool = updatePool(baseToken);     uint256 pending;     uint256 amountSent;     if (amount > 0) {         pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;         if (rewardTokens[baseToken] == NATIVE) {             uint256 balance = address(this).balance;             if (pending > balance) {                 unchecked {                     nft.unpaidRewards = pending - balance;                 }                 (bool success, ) = _to.call{value: balance}(\"\");                 require(success, \"ERR__NATIVE_TRANSFER_FAILED\");                 amountSent = balance;             } else {                 nft.unpaidRewards = 0;                 (bool success, ) = _to.call{value: pending}(\"\");                 require(success, \"ERR__NATIVE_TRANSFER_FAILED\");                 amountSent = pending;             }         } else {             IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);             uint256 balance = rewardToken.balanceOf(address(this));             if (pending > balance) {                 unchecked {                     nft.unpaidRewards = pending - balance;                 }                 amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);             } else {                 nft.unpaidRewards = 0;                 amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);             }         }     }     nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;     emit LogOnReward(_msgSender(), baseToken, amountSent, _to); } ```  When `withdraw()` is called, `_sendRewardsForNft(_nftId, _to)` will be called to send the rewards.  In `_sendRewardsForNft()`, when `address(this).balance` is insufficient at the moment, `nft.unpaidRewards = pending - balance` will be recorded and the user can get it back at the next time.  However, at L244, the whole `nftInfo` is being deleted, so that `nft.unpaidRewards` will also get erased.  There is no way for the user to get back this `unpaidRewards` anymore.  ### Recommendation  Consider adding a new parameter named `force` for `withdraw()`, `require(force || unpaidRewards == 0)` before deleting nftInfo.  "}, {"title": " LiquidityFarming variable allows for hash collisions", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/131", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L59 https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L196:L224 https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L229:L253   # Vulnerability details  ## Impact The `nftIdsStaked` variable introduces a hash collision vulnerability into the `LiquidityFarming.sol` contract as it is employing a mapping from address to a variable length of data field. Source: `https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L59`  The easiest attack scenario allows loss of funds for victims as the attackers can stop victims from unstaking their NFT in the `withdraw` function. Two more complicated attack scenarios allow loss of funds as attackers can outright withdraw nfts of victims.   ## Proof of Concept This attack depends very on the address of the victim an attacker would want to attack. Therefore let me just illustrate the problem.  When using an address mapping to some fixed length data field one can rely on keccak to prevent collisions.  When using an address mapping with an attacker controlled length data field an attacker has a somewhat easy path to create collisions and thereby write to or read from victims data.  The first part to understanding the attack is understanding that all the nfts of a victim are going to be in continous storage locations of the contract. Lets assume that a victims mapped to array starts at 0x1337 and the own 2 nft with the Ids: 23 and 38. The memory layout could look like this:  ``` addr  | val | description ------|-----|---- 0x1337| 2   | length of the array 0x1338| 23   | Id of the first owned nft 0x1339| 38   | Id of the second owned nft ```  Please note if the victim were to deposit more nfts those nftIds would be placed in the storage address 0x133a, 0x133b and so on.  ### Less complex attack scenario The easier attack scenario would involve the attacker generating addresses that result in a continous storage region below address 0x1337. Suppose the attacker were to generate an address whose arrays storage of nftIdsStaked lands at 0x1330. The memory layout would look like this.  ``` addr  | val | description ------|-----|---- 0x1330| 0   | length of the array 0x1337| 2   | length of the array 0x1338| 23   | Id of the first owned nft 0x1339| 38   | Id of the second owned nft ```  It is easy to see, that they could grow their array and thereby corrupting the array of the victim.  They could essentially write nftIds of worthless nftId into the storage of the victim, thereby overwriting their nftId and preventing them (or anybody else) from withdrawing them.  ### More complex attack scenario  The more complex attack scenario involves finding two addresses that will have somewhat adjacent storage regions.  Where the lower storage region encroaches on the length field of the array. The length field is attacker controlled, thereby allowing the attacker to call `withdraw` on arbitrary nftId.  ``` addr  | val | description ------|-----|---- 0x1337| 4   | length of lower array 0x1338| 37   | Id of the first owned (worthless) nft 0x1339| 39   | Id of the second owned (worthless) nft 0x133a| 40   | Id of the third owned (worthless) nft 0x133b| N    | length of higher array (attacker controlled) AND 4th nftId of lower array 0x133a| 42   | Id of the first owned (worthless) nft ```   Please note that this \"feels\" like a traditional bruteforce attack on keccak (because it is) but it is orders of magnitude more likely to be succesful.  Attackers can essentially trade bruteforcing addresses with calling `deposit` a bunch of times.  As this attack scenario is somewhat less known and more similar to traditional memory corruption attacks allow me to leave a link describing the issue in more detail: `https://xlab.tencent.com/en/2018/11/09/pay-attention-to-the-ethereum-hash-collision-problem-from-the-stealing-coins-incident/`   ## Tools Used Manual audit  ## Recommended Mitigation Steps Track nftIdsStaked like so:  ``` // user address =>        nth nft =>  nft id mapping(address => mapping(uint256 => uint256)) public nftIdsStaked; ```  "}, {"title": "wrong condition checking in price calculation", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/105", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L180-L186   # Vulnerability details  ## Impact The `getTokenPriceInLPShares` function calculates the token price in LP shares, but it checks a wrong condition - if supposed to return `BASE_DIVISOR` if the total reserve is zero, not if the total shares minted is zero. This might leads to a case where the price is calculated incorrectly, or a division by zero is happening.   ## Proof of Concept This is the wrong function implementation: ```sol function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {     uint256 supply = totalSharesMinted[_baseToken];     if (supply > 0) {         return totalSharesMinted[_baseToken] / totalReserve[_baseToken];     }     return BASE_DIVISOR; } ``` This function is used in this contract only in the removeLiquidity and claimFee function, so it's called only if funds were already deposited and totalReserve is not zero, but it can be problematic when other contracts will use this function (it's a public view function so it might get called from outside of the contract).  ## Recommended Mitigation Steps The correct code should be: ```sol function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {     uint256 reserve = totalReserve[_baseToken];     if (reserve > 0) {         return totalSharesMinted[_baseToken] / totalReserve[_baseToken];     }     return BASE_DIVISOR; } ```  "}, {"title": "Incentive Pool can be drained without rebalancing the pool", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityPool.sol#L149-L173 https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityPool.sol#L263-L277   # Vulnerability details  ## Impact `depositErc20` allows an attacker to specify the destination chain to be the same as the source chain and the receiver account to be the same as the caller account. This enables an attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state.    ## Proof of Concept This requires the attacker to have some collateral, to begin with. The profit also depends on how much the attacker has. Assume the attacker has enough assets.  In each chain, when the pool is very deficit (e.g. `currentLiquidity` is much less than `providedLiquidity`), which often mean there's a good amount in the Incentive pool after some high valued transfers, then do the following.    - step 1 :  borrow the liquidityDifference amount such that one can get the whole incentivePool. ```             uint256 liquidityDifference = providedLiquidity - currentLiquidity;             if (amount >= liquidityDifference) {                 rewardAmount = incentivePool[tokenAddress]; ``` - step 2 : call `depositErc20()` with `toChainId` being the same chain and `receiver` being `msg.sender`.  The executor will call `sendFundsToUser` to msg.sender. Then a rewardAmount, equivalent to the entire incentive pool (up to 10% of the total pool value), will be added to `msg.sender` minus equilibrium fee (~0.01%) and gas fee.    In the end, the pool is back to the deficit state as before, the incentive pool is drained and the exploiter pockets the difference of rewardAmount minus fees.   This attack can be repeated on each deployed chain multiple times whenever the incentive pool is profitable (particularly right after a big transfer).    ## Tools Used  ## Recommended Mitigation Steps - Disallow `toChainId` to be the source chain by validating it in `depositErc20` or in `sendFundsToUser` validate that `fromChainId` is not the same as current chain.  - require `receiver` is not `msg.sender` in `depositErc20`.      "}, {"title": "WhitelistPeriodManager: Improper state handling of exclusion removals", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/72", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/WhitelistPeriodManager.sol#L178-L184 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/WhitelistPeriodManager.sol#L115-L125   # Vulnerability details  ## Impact  The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is removed from the `isExcludedAddress` mapping. While this affects the enforcement of the cap limits and the `getMaxCommunityLpPositon()` function, the worst impact this has is that the address cannot have liquidity removed / transferred due to subtraction overflow.  In particular, users can be prevented from withdrawing their staked LP tokens from the liquidity farming contract should it become non-excluded.  ## Proof of Concept  - Assume liquidity farming address `0xA` is excluded - Bob stakes his LP token - Liquidity farming contract is no longer to be excluded: `setIsExcludedAddressStatus([0xA, false])` - Bob attempts to withdraw liquidity \u2192 reverts because `totalLiquidityByLp[USDC][0xA] = 0`, resulting in subtraction overflow.  ```jsx // insert test case in Withdraw test block of LiquidityFarming.tests.ts it.only('will brick withdrawals by no longer excluding farming contract', async () => {   await farmingContract.deposit(1, bob.address);   await wlpm.setIsExcludedAddressStatus([farmingContract.address], [false]);   await farmingContract.connect(bob).withdraw(1, bob.address); });  // results in // Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block) ```  ## Recommended Mitigation Steps  The simplest way is to prevent exclusion removals.  ```jsx function setIsExcludedAddresses(address[] memory _addresses) external onlyOwner {   for (uint256 i = 0; i < _addresses.length; ++i) {     isExcludedAddress[_addresses[i]] = true;     // emit event     emit AddressExcluded(_addresses[i]);   } } ```  "}, {"title": "Can deposit native token for free and steal funds", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/55", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L151   # Vulnerability details  ## Impact The `depositErc20` function allows setting `tokenAddress = NATIVE` and does not throw an error. No matter the `amount` chosen, the `SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);` call will not revert because it performs a low-level call to `NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`, which is an EOA, and the low-level calls to EOAs always succeed. Because the `safe*` version is used, the EOA not returning any data does not revert either.  This allows an attacker to deposit infinite native tokens by not paying anything. The contract will emit the same `Deposit` event as a real `depositNative` call and the attacker receives the native funds on the other chain.  ## Recommended Mitigation Steps Check `tokenAddress != NATIVE` in `depositErc20`.   "}, {"title": "Wrong formula when add fee `incentivePool` can lead to loss of funds.", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/38", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L319-L322   # Vulnerability details  ## Impact The `getAmountToTransfer` function of `LiquidityPool` updates `incentivePool[tokenAddress]` by adding some fee to it but the formula is wrong and the value of `incentivePool[tokenAddress]` will be divided by `BASE_DIVISOR` (10000000000) each time. After just a few time, the value of `incentivePool[tokenAddress]` will become zero and that amount of `tokenAddress` token will be locked in contract. ## Proof of concept Line 319-322 ``` incentivePool[tokenAddress] = (incentivePool[tokenAddress] + (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) / BASE_DIVISOR; ``` Let `x = incentivePool[tokenAddress]`, `y = amount`, `z = transferFeePerc` and `t = tokenManager.getTokensInfo(tokenAddress).equilibriumFee`. Then that be written as ``` x = (x + (y * (z - t))) / BASE_DIVISOR; x = x / BASE_DIVISOR + (y * (z - t)) / BASE_DIVISOR; ``` ## Recommended Mitigation Steps Fix the bug by change line 319-322 to: ``` incentivePool[tokenAddress] += (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee)) / BASE_DIVISOR; ```   "}, {"title": "DoS by gas limit", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/24", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L220 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L233   # Vulnerability details  In `deposit` function it is possible to push to `nftIdsStaked` of anyone, an attacker can deposit too many nfts to another user, and when the user will try to withdraw an nft at the end of the list, they will iterate on the list and revert because of gas limit.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "Title: Unnecessary Reentrancy Guards Severity: GAS  Where there is onlyOwner or Initializer modifer, the reentrancy gaurd isn't  necessary (unless you don't trust the owner or the deployer, which will lead to full security breakdown of the project and we believe this is not the case) This is a list we found of such occurrences:           LiquidityFarming.sol no need both nonReentrant and onlyOwner modifiers in reclaimTokens    Title: Change transferFrom to transfer Severity: GAS  'transferFrom(address(this), *, **)' could be replaced by the following more gas efficient 'transfer(*, **)'                This replacement is more gas efficient and improves the code quality.          LiquidityFarming.sol, 250 : lpToken.safeTransferFrom(address(this), msgSender, _nftId);   Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           ExecutorManager.sol, getAllExecutors         LPToken.sol, initialize         LPToken.sol, exists         WhitelistPeriodManager.sol, initialize   Title: Use unchecked to save gas for certain additive calculations that cannot overflow Severity: GAS   You can use unchecked in the following calculations since there is no risk to overflow:          LiquidityFarming.sol (L#275) - accumulator += rewardRateLog[_baseToken][i].rewardsPerSecond * (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));    Title: State variables that could be set immutable Severity: GAS  In the following files there are state variables that could be set immutable to save gas.           liquidityProviders in LiquidityFarming.sol         tokenManager in LiquidityPool.sol         lpToken in LiquidityFarming.sol    Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               LiquidityPool.depositErc20 (tag)         LPToken.initialize (_symbol)         LiquidityPool.sendFundsToUser (depositHash)         LiquidityPool.permitEIP2612AndDepositErc20 (tag)         LiquidityPool.permitAndDepositErc20 (tag)         LiquidityPool.depositNative (tag)         LPToken.updateTokenMetadata (_lpTokenMetadata)         LiquidityPool.checkHashStatus (depositHash)         LPToken.initialize (_name)    Title: Caching array length can save gas Severity: GAS   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }           ExecutorManager.sol, executorArray, 31         TokenManager.sol, tokenConfig, 78         ExecutorManager.sol, executorArray, 47         WhitelistPeriodManager.sol, _tokens, 228         LPToken.sol, nftIds, 77         WhitelistPeriodManager.sol, _addresses, 180    Title: Storage double reading. Could save SLOAD Severity: GAS  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           LiquidityProviders.sol: BASE_DIVISOR is read twice in _increaseLiquidity    Title: Unnecessary index init Severity: GAS   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:          WhitelistPeriodManager.sol, 180         WhitelistPeriodManager.sol, 228         LPToken.sol, 77         ExecutorManager.sol, 31         ExecutorManager.sol, 47         TokenManager.sol, 78     Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               TokenManager.sol, _msgData, { return ERC2771Context._msgData(); }         TokenManager.sol, _msgSender, { return ERC2771Context._msgSender(); }         WhitelistPeriodManager.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LiquidityPool.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LiquidityFarming.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LiquidityProviders.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LPToken.sol, _msgData, { return ERC2771ContextUpgradeable._msgData(); }         LiquidityPool.sol, _msgSender, { return ERC2771ContextUpgradeable._msgSender(); }    Title: Use bytes32 instead of string to save gas whenever possible Severity: GAS       Use bytes32 instead of string to save gas whenever possible.     String is a dynamic data structure and therefore is more gas consuming then bytes32.               LPToken.sol (L140), string memory json = Base64.encode( bytes( string( abi.encodePacked( '{\"name\": \"', name(), '\", \"description\": \"', description, '\", \"image\": \"data:image/svg+xml;base64,', Base64.encode(bytes(svgData)), '\", \"attributes\": ', attributes, \"}\" ) ) ) );     Title: Unused state variables Severity: GAS  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.           LPToken.sol, NATIVE    Title: Prefix increments are cheaper than postfix increments Severity: GAS  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           just change to unchecked: ExecutorManager.sol, i, 47         just change to unchecked: LiquidityFarming.sol, index, 233         just change to unchecked: LPToken.sol, i, 77         just change to unchecked: WhitelistPeriodManager.sol, i, 228         just change to unchecked: WhitelistPeriodManager.sol, i, 248         just change to unchecked: TokenManager.sol, index, 78         just change to unchecked: WhitelistPeriodManager.sol, i, 180         just change to unchecked: ExecutorManager.sol, i, 31    Title: Unused inheritance Severity: GAS       Some of your contract inherent contracts but aren't use them at all.     We recommend not to inherent those contracts.              TokenManager.sol; the inherited contracts Pausable not used   Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          WhitelistPeriodManager.sol, _msgData         LiquidityProviders.sol, _addLiquidity         WhitelistPeriodManager.sol, _isSupportedToken   Title: Unused inheritance Severity: GAS       Some of your contract inherent contracts but aren't use them at all.     We recommend not to inherent those contracts.              TokenManager.sol; the inherited contracts Pausable not used   Title: Unused imports Severity: GAS   In the following files there are contract imports that aren't used Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore)          LiquidityPool.sol, line 5, import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";         WhitelistPeriodManager.sol, line 6, import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";         WhitelistPeriodManager.sol, line 5, import \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";     Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           LiquidityProviders.sol, 283: change '_amount > 0' to '_amount != 0'         LiquidityPool.sol, 401: change 'balance > 0' to 'balance != 0'         LiquidityPool.sol, 292: change 'balance > 0' to 'balance != 0'"}, {"title": "Improper Upper Bound Definition on the Fee", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L51 https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L52   # Vulnerability details  ## Impact  The **equilibriumFee** and **maxFee** does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions or the LP user will lost all funds when paying the fee.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L52  2. Owner can identify fee amount. That directly affect to LP management. (https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L352)  3. Here you can see there is no upper bound has been defined.   ```     function changeFee(         address tokenAddress,         uint256 _equilibriumFee,         uint256 _maxFee     ) external override onlyOwner whenNotPaused {         require(_equilibriumFee != 0, \"Equilibrium Fee cannot be 0\");         require(_maxFee != 0, \"Max Fee cannot be 0\");         tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;         tokensInfo[tokenAddress].maxFee = _maxFee;         emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);     }  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider defining upper and lower bounds on the **equilibriumFee** and **maxFee**.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L30 Consider adding require(!executorStatus[executorArray[i]], \"Executor already registered\"); in the for loop before calling addExecutor. This will make the transaction faster and will save some gas fees.   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L55 Check if the executor is present and executorStatus is not already set to false. I can call the function in an infinity loop and it can block other transactions to executed while(i == 1){  executorManager.removeExecutor(address) }   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L99 Add zero check for rewardPerSecond. EVen though onlyOwner, it can create zero records and can exhust gas fees   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L170 Check if the baseToken is already added to rewardRateLog. Unless the business logic is to allow override, the emit will exhuast gas fees.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L182 Add zero check for amount. No point in transfering 0 amount. This will cost extra gas fees.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L113 Add zero check before setting baseGas.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L201 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L225 Add zero check. Although zero check if done in functions called further, having zero check at the begainning will definitly help save some gas "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L10 The executorstatus map is not really helpful in any business logic. If the executor is present in executors array then the status is true or else false.  Once the executor is added, it cannot be added again even though the status is set to FALSE.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L53 The function removeExecutor is just setting the status to false.  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/ExecutorManager.sol#L55 Check if the executor is present and executorStatus is not already set to false.   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/token/svg-helpers/SvgHelperBase.sol#L126 Both inpurt parameters are not used in the function. Remove these.   https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L169 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L330 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L333 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L107 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L113 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L123 If function is not called from inside the contract, better to make it external  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L211 NFTInfo storage nft = nftInfo[_nftId]; require(!nft.isStaked, \"ERR__NFT_ALREADY_STAKED\"); Move above code immidiately after the require(lpToken.isApprovedForAll...). If NFT is not approved, then no need to get token metadata "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "1. Use `!= 0` instead of `> 0` to Save Gas  Proof of Concept: MapleLoan.sol#L201 Migrator.sol#L25  Recommended Mitigation Steps: Change `>` to `!=` for small gas savings.  ========================================================================  2. More efficient gas usage by removing && operator  Proof of Concept: MapleLoanInternals.sol#L296 MapleLoanInternals.sol#L361-L364 MapleLoan.sol#L233  Recommended Mitigation Steps: Change to: ``` require((_nextPaymentDueDate == uint256(0)), \"MLI:FL:LOAN_ACTIVE\"); require((paymentsRemaining != uint256(0)), \"MLI:FL:LOAN_ACTIVE\"); ``` ========================================================================  3. The default of uint is already 0  Proof of Concept: MapleLoanInternals.sol#L369-L371  Recommended Mitigation Steps: considered remove 0 value can save gas  ========================================================================  4. considered using bool in `modifier lock()` can save gas  Proof of Concept: RevenueDistributionToken.sol#L38  Recommended Mitigation Steps: Example: ``` pragma solidity =0.8.7;  contract test {  bool internal _locked = true; uint256 internal _lock = 1;  modifier noReenter() {       require(_locked, \"LOCKED\");       _locked = true;       _;       _locked = false;   } modifier noReentir(){       require(_lock == 1, \"LOCKED\");       _lock = 2;       _;       _lock = 1; }    function abc() public noReenter returns(uint){       return 12121;       // 22066   }   function def() public noReentir returns(uint){       return 1234;       // 23752   } } ```  ======================================================================== "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "## Adding Payable Keyword to Constructor **Context** [ERC20.sol](https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/ERC20.sol), [Migrator.sol](https://github.com/maple-labs/mpl-migration/blob/a99549d96ed12cd4589a02bccf70747dbaebeb5b/contracts/Migrator.sol), [xMPL.sol](https://github.com/maple-labs/xMPL/blob/23301839c389142f9e75d88121316d9751833b71/contracts/xMPL.sol), [RevenueDistributionToken.sol](https://github.com/maple-labs/revenue-distribution-token/blob/41a3e40bf8c109ff19b38b80fde300c44fd42a3d/contracts/RevenueDistributionToken.sol).  **Description** Making the ```constructor()``` payable eliminates the need for an initial check of msg.value == 0 and saves 21 gas. This shouldn't not increase security risk and the savings is on deployment.  **Recommendation**  Add payable keyword to ```constructors()```   ## Catching The Array Length Prior To Loop. **Context** [MapleLoanInternals.sol](https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/MapleLoanInternals.sol).  **Description** One can save gas by caching the array length (in stack) and using that set variable in the loop. This can be done for the function [_acceptNewTerms()](https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/MapleLoanInternals.sol#L229).  **Recommendation**  Simply do something like so before the for loop: ```uint length = calls_.length```. Then add ```length``` in place of ```calls_.length``` in the for loop.   ## Function Ordering via Method ID **Context** [All contracts](https://github.com/code-423n4/2022-03-maple).  **Description** Most called functions could save gas by function ordering via Method ID. Calling a function at runtime will be cheaper if the function is positioned earlier in the order (has a relatively lower Method ID) because 22 gas are added to the cost of a function for every position that came before it. The caller can save on gas if you prioritize most called functions. One could use [This tool](https://emn178.github.io/solidity-optimize-name/) to help find alternative function names with lower Method IDs while keeping the original name intact.  **Recommendation**  Find a lower method ID name for the most called functions for example ```mostCalled()``` vs. ```mostCalled_41q()``` is cheaper by 44 gas.   ## Setting State Variable To Local Variable And Using Keyword delete **Context** [MapleLoanInternals.sol](https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/MapleLoanInternals.sol) and [xMPL.sol](https://github.com/maple-labs/xMPL/blob/23301839c389142f9e75d88121316d9751833b71/contracts/xMPL.sol).  **Description** Several functions are clearing state variables by setting them to ```=uint256(0)```. To make these cheaper you could set the state variables to local variables within the function and then use the delete keyword to set them to their initial value. In ```MapleLoanInternals.sol``` there are: [_clearLoanAccounting()](https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/MapleLoanInternals.sol#L63), [_repossess()](https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/MapleLoanInternals.sol#L358), [_closeLoan()](https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/MapleLoanInternals.sol#L143) and [_makePayment()](https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/MapleLoanInternals.sol#L172).   In ```xMPL.sol``` there is: [_cleanupMigration()](https://github.com/maple-labs/xMPL/blob/23301839c389142f9e75d88121316d9751833b71/contracts/xMPL.sol#L91) which uses the ```delete``` keyword but do so to the state variable directly and it would be cheaper to set the state variables to local variables and then use ```delete```.  [scheduleMigration()](https://github.com/maple-labs/xMPL/blob/23301839c389142f9e75d88121316d9751833b71/contracts/xMPL.sol#L76) just setting the state variable and then using them to save gas.  **Recommendation**  Set the state variables to local variables within the function and then use the delete keyword to set them to their initial value. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "**[S]**: Suggested optimation, save a decent amount of gas without compromising readability;  **[M]**: Minor optimation, the amount of gas saved is minor, change when you see fit;  **[N]**: Non-preferred, the amount of gas saved is at cost of readability, only apply when gas saving is a top priority.  ## [S] `ERC20.sol#transferFrom()` Do not reduce approval on transferFrom if current allowance is type(uint256).max  The Wrapped Ether (WETH) ERC-20 contract has a gas optimization that does not update the allowance if it is the max uint.  The latest version of OpenZeppelin's ERC20 token contract also adopted this optimization.  https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/ERC20.sol#L109-L113  ```solidity     function transferFrom(address owner_, address recipient_, uint256 amount_) external override returns (bool success_) {         _approve(owner_, msg.sender, allowance[owner_][msg.sender] - amount_);         _transfer(owner_, recipient_, amount_);         return true;     } ```  See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/token/ERC20/ERC20.sol#L336 -   https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085  ### Recommendation  Change to:  ```solidity     function transferFrom(address owner_, address recipient_, uint256 amount_) external override returns (bool success_) {         uint256 currentAllowance = allowance[owner_][msg.sender];         if (currentAllowance != type(uint256).max) {             _approve(owner_, msg.sender, currentAllowance - amount_);         }          _transfer(owner_, recipient_, amount_);         return true;     } ```  ## [S] Use immutable variables can save gas  https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/ERC20.sol#L25-L26  ```solidity     string public override name;     string public override symbol; ```  https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/ERC20.sol#L50-L54  ```solidity     constructor(string memory name_, string memory symbol_, uint8 decimals_) {         name     = name_;         symbol   = symbol_;         decimals = decimals_;     } ```  In `ERC20.sol`, `name` and `symbol` will never change, use immutable variable instead of storage variable can save gas.  ## [M] Validation can be done earlier to save gas  https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/ERC20.sol#L75-L102  ```solidity     function permit(address owner_, address spender_, uint256 amount_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external override {         require(deadline_ >= block.timestamp, \"ERC20:P:EXPIRED\");          // Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines         // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}.         require(             uint256(s_) <= uint256(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) &&             (v_ == 27 || v_ == 28),             \"ERC20:P:MALLEABLE\"         );          // Nonce realistically cannot overflow.         unchecked {             bytes32 digest = keccak256(                 abi.encodePacked(                     \"\\x19\\x01\",                     DOMAIN_SEPARATOR(),                     keccak256(abi.encode(PERMIT_TYPEHASH, owner_, spender_, amount_, nonces[owner_]++, deadline_))                 )             );              address recoveredAddress = ecrecover(digest, v_, r_, s_);              require(recoveredAddress == owner_ && owner_ != address(0), \"ERC20:P:INVALID_SIGNATURE\");         }          _approve(owner_, spender_, amount_);     } ```  Check if `owner_ != address(0)` earlier can avoid unnecessary computing when this check failed.   ### Recommendation  Change to:  ```solidity     function permit(address owner_, address spender_, uint256 amount_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external override {         require(deadline_ >= block.timestamp, \"ERC20:P:EXPIRED\");         require(owner_ != address(0), \"...\");          // Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines         // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}.         require(             uint256(s_) <= uint256(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) &&             (v_ == 27 || v_ == 28),             \"ERC20:P:MALLEABLE\"         );          // Nonce realistically cannot overflow.         unchecked {             bytes32 digest = keccak256(                 abi.encodePacked(                     \"\\x19\\x01\",                     DOMAIN_SEPARATOR(),                     keccak256(abi.encode(PERMIT_TYPEHASH, owner_, spender_, amount_, nonces[owner_]++, deadline_))                 )             );              address recoveredAddress = ecrecover(digest, v_, r_, s_);              require(recoveredAddress == owner_, \"ERC20:P:INVALID_SIGNATURE\");         }          _approve(owner_, spender_, amount_);     } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "# Save gas in for loops by unchecked arithmetic  The for loop of `_acceptNewTerms` in MapleLoanInternals.sol: https://github.com/maple-labs/loan/blob/main/contracts/MapleLoanInternals.sol#L258-L261  There is no overflow risk of `i`.  ## Recommendation  Use `unchecked` block to avoid overflow checks:  ```         for (uint256 i; i < calls_.length; ) {             ( bool success, ) = refinancer_.delegatecall(calls_[i]);             require(success, \"MLI:ANT:FAILED\");             unchecked {                 ++i;             }         } ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/21", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "# QA Report  ## Non-Critical Findings  ### Redundant type cast to `address`  #### Description  Variable `asset` is defined as `address public override asset`, the type casting to `address` is redundant.  #### Findings  [RevenueDistributionToken.sol#L162](https://github.com/maple-labs/revenue-distribution-token/blob/v1.0.0-beta.1/contracts/RevenueDistributionToken.sol#L162)   [RevenueDistributionToken.sol#L181](https://github.com/maple-labs/revenue-distribution-token/blob/v1.0.0-beta.1/contracts/RevenueDistributionToken.sol#L181)  #### Recommended mitigation steps  Remove redundant type cast.  From:  ```solidity require(ERC20Helper.transfer(address(asset), receiver_, assets_), \"RDT:B:TRANSFER\"); ```  To:  ```solidity require(ERC20Helper.transfer(asset, receiver_, assets_), \"RDT:B:TRANSFER\"); ```  ---  ### Open TODOs in code  #### Description  Open TODOs can hint at programming or architectural errors that still need to be fixed.  #### Findings  [RevenueDistributionToken.sol#L78](https://github.com/maple-labs/revenue-distribution-token/blob/v1.0.0-beta.1/contracts/RevenueDistributionToken.sol#L78)   [RevenueDistributionToken.sol#L276](https://github.com/maple-labs/revenue-distribution-token/blob/v1.0.0-beta.1/contracts/RevenueDistributionToken.sol#L276)    #### Recommended mitigation steps  Implement open TODOs and remove comments.  ### `xMPL.performMigration()` is safe to be called by everyone  #### Description  `xMPL.performMigration()` is currently only allowed to be called by the contract owner, but as there are no funds at risk and no downsides to having everyone (public) call the function, the modifier `onlyOwner` can be removed.  It even states so in the [README](https://github.com/maple-labs/xMPL/blob/v1.0.0-beta.1/README.md):  ``` 3. After the time delay, anyone can call `performMigration`, which executes the migration with the parameters set 10 days prior. ```  #### Findings  [xMPL.performMigration()](https://github.com/maple-labs/xMPL/blob/v1.0.0-beta.1/contracts/xMPL.sol#L51)  #### Recommended mitigation steps  Remove modifier `onlyOwner`.  ## Low Risk  None found. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "# Gas Optimizations  ### An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  #### Findings  [MapleLoanInternals.sol#L258](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol#L258)  #### Recommended mitigation steps  ```solidity uint length = calls_.length;  for (uint256 i; i < length; ++i) {     ( bool success, ) = refinancer_.delegatecall(calls_[i]);     require(success, \"MLI:ANT:FAILED\"); } ```  ---  ### Use `unchecked {}` primitive within for loops  Given the use of Solidity compiler >= 0.8.0, there are default arithmetic checks for mathematical operations which consume additional gas for such checks internally. In expressions where we are absolutely sure of no overflows/underflows, one can use the `unchecked` primitive to wrap such expressions to avoid checks and save gas.  #### Findings  [MapleLoanInternals.sol#L258](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol#L258)  #### Recommended mitigation steps  Change to  ```solidity for (uint256 i; i < calls_.length;) {     ( bool success, ) = refinancer_.delegatecall(calls_[i]);     require(success, \"MLI:ANT:FAILED\");      unchecked { ++i; } } ```  ---  ### Use assignment `=` instead of `+=`  Named return variable `lateInterest_` is unused before line [MapleLoanInternals.sol#L589](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol#L589), therefore it's not necessary to use `+=`.  #### Findings  [MapleLoanInternals.sol#L589](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol#L589)  #### Recommended mitigation steps  Change to assignment (`=`) to save gas.  ```solidity lateInterest_ = _getInterest(principal_, interestRate_ + lateInterestPremium_, fullDaysLate); lateInterest_ += (lateFeeRate_ * principal_) / SCALED_ONE; ```  ---  ### Unused named returns can be removed  #### Description  Removing unused named return variables can reduce gas usage and improve code clarity.  #### Recommended mitigation steps  Remove the unused named return variables or use them instead of creating additional variables.  #### Findings  **[RevenueDistributionToken.sol](https://github.com/maple-labs/revenue-distribution-token/blob/v1.0.0-beta.1/contracts/RevenueDistributionToken.sol)**  [#L193](https://github.com/maple-labs/revenue-distribution-token/blob/v1.0.0-beta.1/contracts/RevenueDistributionToken.sol#L193) unnecessary named return `apr_`  [#L196](https://github.com/maple-labs/revenue-distribution-token/blob/v1.0.0-beta.1/contracts/RevenueDistributionToken.sol#L196) unnecessary named return `balanceOfAssets_`  [#L258](https://github.com/maple-labs/revenue-distribution-token/blob/v1.0.0-beta.1/contracts/RevenueDistributionToken.sol#L258) unnecessary named return `totalManagedAssets_`  [#L284](https://github.com/maple-labs/revenue-distribution-token/blob/v1.0.0-beta.1/contracts/RevenueDistributionToken.sol#L284) unnecessary named return `result_`  **[MapleLoan.sol](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoan.sol)**  [#L244](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoan.sol#L244) unnecessary named return `collateral_`  [#L274-400](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoan.sol#L274-L400)  **[MapleLoanInternals.sol](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol)**  [#L204](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol#L204) unnecessary named return `proposedRefinanceCommitment_`  [#L397](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol#L397) unnecessary named return `isMaintained_`  [#L434](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol#L434) unnecessary named return `unaccountedAmount_`  [#L442](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol#L422) unnecessary named return `mapleGlobals_`  [#L456](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol#L456) unnecessary named return `collateral_`  [#L495](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol#L495) unnecessary named return `interest_`  [#L594](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol#L594) unnecessary named return `periodicInterestRate_`  [#L599](https://github.com/maple-labs/loan/blob/v3.0.0-beta.1/contracts/MapleLoanInternals.sol#L599) unnecessary named return `refinanceCommitment_` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/17", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "## Low-impact Issues  ### Treasury fees are given to the lender on failure, rather than reverting ```solidity         if (!_sendFee(_mapleGlobals(), IMapleGlobalsLike.mapleTreasury.selector, treasuryFee_)) {             _claimableFunds += treasuryFee_;         } ``` https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/MapleLoanInternals.sol#L321-L323   ### Inconsistent `approve()` behavior between `ERC20` and `RevenueDistributionToken` `RevenueDistributionToken` considers an approval value of `type(uint256).max` as 'allow all amounts': ```solidity         if (callerAllowance == type(uint256).max) return; ``` https://github.com/maple-labs/revenue-distribution-token/blob/41a3e40bf8c109ff19b38b80fde300c44fd42a3d/contracts/RevenueDistributionToken.sol#L279  whereas `ERC20` considers it as a numerical amount: ```solidity         _approve(owner_, msg.sender, allowance[owner_][msg.sender] - amount_); ``` https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/ERC20.sol#L110  These inconsistences will likely lead to confusion at some point in the future.  ### Incorrect revert string in `setEndingPrincipal()` ```solidity         require(endingPrincipal_ <= _principal, \"R:DP:ABOVE_CURRENT_PRINCIPAL\"); ``` https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/Refinancer.sol#L43  It should be `\"R:SEP:ABOVE_CURRENT_PRINCIPAL\"`.  ### IERC20 should be named IERC20Permit 1. File: erc20-1.0.0-beta.2/contracts/interfaces/IERC20.sol (lines [4-5](https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/interfaces/IERC20.sol#L4-L5)) There may be cases in the future where you may not want EIP-2612 functionality due to deployment costs, and having the name `IERC20` taken will cause problems ```solidity /// @title Interface of the ERC20 standard as defined in the EIP, including ERC-2612 permit functionality. interface IERC20 { ```  ### IERC20 incorrectly includes `PERMIT_TYPEHASH` `PERMIT_TYPEHASH` is not part of the requirements for EIP-2612, so it shouldn't appear in the interface.  ```solidity     /**      *  @dev    Returns the permit type hash.      *  @return permitTypehash_ The permit type hash.      */     function PERMIT_TYPEHASH() external view returns (bytes32 permitTypehash_); ``` https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/interfaces/IERC20.sol#L134-L138 OpenZeppelin has it as a `private` `constant`: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/52eeebecda140ebaf4ec8752ed119d8288287fac/contracts/token/ERC20/extensions/draft-ERC20Permit.sol#L28   ### Missing checks for `address(0x0)` when assigning values to `address` state variables  1. File: revenue-distribution-token-1.0.0-beta.1/contracts/RevenueDistributionToken.sol (line [73](https://github.com/maple-labs/revenue-distribution-token/blob/41a3e40bf8c109ff19b38b80fde300c44fd42a3d/contracts/RevenueDistributionToken.sol#L73)) ```solidity         pendingOwner = pendingOwner_; ```  ### Open TODOs There are many open TODOs throughout the various test files, but also some among the code files ``` ./revenue-distribution-token-1.0.0-beta.1/contracts/RevenueDistributionToken.sol:    // TODO: Revisit returns ./revenue-distribution-token-1.0.0-beta.1/contracts/RevenueDistributionToken.sol:        // TODO: investigate whether leave this `require()` in for clarity from error message, or let the safe math check in `callerAllowance - shares_` handle the underflow. ```  ### Incorrect Natspec ```solidity      *  @dev   Emits an event indicating that one account has set the allowance of another account over their tokens. ``` https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/interfaces/IERC20.sol#L12 The natspec doesn't mention that the event is also emitted when `transferFrom()` is called, even though the natspec for `transferFrom()` explicitly mentions it.  ## Non-critical Issues  ### `_processEstablishmentFees()` should emit events when fee processing fails ```solidity     function _processEstablishmentFees(uint256 delegateFee_, uint256 treasuryFee_) internal {         if (!_sendFee(_lender, ILenderLike.poolDelegate.selector, delegateFee_)) {             _claimableFunds += delegateFee_;         }          if (!_sendFee(_mapleGlobals(), IMapleGlobalsLike.mapleTreasury.selector, treasuryFee_)) {             _claimableFunds += treasuryFee_;         }     } ``` https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/MapleLoanInternals.sol#L316-L324  ### Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate  1. File: erc20-1.0.0-beta.2/contracts/ERC20.sol (lines [32-34](https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/ERC20.sol#L32-L34)) ```solidity     mapping(address => uint256) public override balanceOf;      mapping(address => mapping(address => uint256)) public override allowance; ```  ### Use scientific notation (e.g. `10e18`) rather than exponentiation (e.g. `10**18`)  1. File: loan-3.0.0-beta.1/contracts/MapleLoanInternals.sol (line [14](https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/MapleLoanInternals.sol#L14)) ```solidity     uint256 private constant SCALED_ONE = uint256(10 ** 18); ```  ### `public` functions not called by the contract should be declared `external` instead Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.  1. File: loan-3.0.0-beta.1/contracts/MapleLoanFactory.sol (lines [16-18](https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/MapleLoanFactory.sol#L16-L18)) ```solidity     function createInstance(bytes calldata arguments_, bytes32 salt_)         override(IMapleProxyFactory, MapleProxyFactory) public returns (             address instance_ ```  ### Use a more recent version of solidity Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`  1. File: erc20-1.0.0-beta.2/contracts/ERC20.sol (line [2](https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/ERC20.sol#L2)) ```solidity pragma solidity ^0.8.7; ```  ### Typos `owner` => `owner_` https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/interfaces/IERC20.sol#L129 https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/interfaces/IERC20.sol#L132 https://github.com/maple-labs/mpl-migration/blob/a99549d96ed12cd4589a02bccf70747dbaebeb5b/contracts/Migrator.sol#L24 https://github.com/maple-labs/mpl-migration/blob/a99549d96ed12cd4589a02bccf70747dbaebeb5b/contracts/Migrator.sol#L26 https://github.com/maple-labs/mpl-migration/blob/a99549d96ed12cd4589a02bccf70747dbaebeb5b/contracts/Migrator.sol#L27 https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/interfaces/IOwnable.sol#L17  `account` => `account_` https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/interfaces/IOwnable.sol#L11  `Emits an event` => `Emitted when` https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/interfaces/IERC20.sol#L12 https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/interfaces/IERC20.sol#L20  `ERC-2612` => `EIP-2612` https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/interfaces/IERC20.sol#L4   ### Grammar Throughout the various interfaces, most of the comments have fragments that end with periods. They should either be converted to actual sentences with both a noun phrase and a verb phrase, or the periods should be removed. "}, {"title": "Incorrect implementation of Lender can result in lost tokens", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/16", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "# Lines of code  https://github.com/maple-labs/loan/blob/main/contracts/MapleLoanInternals.sol#L332-L344   # Vulnerability details  ## Impact MapleLoanInternals._sendFee should check returnData.length == 32 before decoding, otherwise if it returns bytes data, the abi.decode will return 0x20, result in lost tokens. ## Proof of Concept https://github.com/maple-labs/loan/blob/main/contracts/MapleLoanInternals.sol#L332-L344 This contract can test that when the function returns bytes data, abi.encode will decode the return value as 0x20. ``` pragma solidity 0.8.7; contract A{     address public destination;     uint256 public number;     function convertA() external{         (bool su,bytes memory ret )= address(this).call(abi.encodeWithSelector(this.ret.selector));         number = ret.length;         destination = abi.decode(ret, (address));     }     function ret() public returns(bytes memory){         return \"0x74d754378a59Ab45d3E6CaC83f0b87E8E8719270\";     } } ``` ## Tools Used None ## Recommended Mitigation Steps ```     function _sendFee(address lookup_, bytes4 selector_, uint256 amount_) internal returns (bool success_) {         if (amount_ == uint256(0)) return true;          ( bool success , bytes memory data ) = lookup_.call(abi.encodeWithSelector(selector_));  +       if (!success || data.length != uint256(32)) return false;          address destination = abi.decode(data, (address));          if (destination == address(0)) return false;          return ERC20Helper.transfer(_fundsAsset, destination, amount_);     } ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/14", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "## Low and Non-critical * You should declare that the `RevenueDistributionToken` contract implements the IERC4626 interface * Forgot TODO comments before `updateVestingSchedule` and `_reduceCallerAllowance` functions in the `RevenueDistributionToken` contract * The `ERC20` contract's solidity version is ^0.8.7, while the other contracts' version is 0.8.7 "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/7", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "# Unresolved TODOs ``` ./revenue-distribution-token/contracts/RevenueDistributionToken.sol:78:    // TODO: Revisit returns ./revenue-distribution-token/contracts/RevenueDistributionToken.sol:276:        // TODO: investigate whether leave this `require()` in for clarity from error message, or let the safe math check in `callerAllowance - shares_` handle the underflow. ```  # Lack max fee in `_setEstablishmentFees` Recommend to hardcode some reasonable max fee to protect user https://github.com/maple-labs/loan/blob/4c6fe2cd91d6d16b8434c426fe7eb6d2bc77bc30/contracts/MapleLoanInternals.sol#L347  # Wrong comment re:`issuanceRate` It is the asset/second rate scaled by precision, i.e. already increased precision https://github.com/maple-labs/revenue-distribution-token/blob/41a3e40bf8c109ff19b38b80fde300c44fd42a3d/contracts/RevenueDistributionToken.sol#L28"}, {"title": "Spreads can be minted with a deactivated oracle", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/66", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/FundsCalculator.sol#L91-L117   # Vulnerability details  ## Impact  When deactivateOracle() is called for an oracle in OracleRegistry it is still available for option spreads minting.  This way a user can continue to mint new options within spreads that rely on an oracle that was deactivated. As economic output of spreads is close to vanilla options, so all users who already posses an option linked to a deactivated oracle can surpass this deactivation, being able to mint new options linked to it as a part of option spreads.  ## Proof of Concept  Oracle active state is checked with isOracleActive() during option creation in validateOptionParameters() and during option minting in _mintOptionsPosition().  It isn't checked during spreads creation:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/FundsCalculator.sol#L91-L117  In other words besides vanilla option minting and creation all spectrum of operations is available for the deactivated oracle assets, including spreads minting, which economically is reasonably close to vanilla minting.  ## Recommended Mitigation Steps  If oracle deactivation is meant to transfer all related assets to the close only state then consider requiring oracle to be active on spreads minting as well in the same way it's done for vanilla option minting:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L188-L197   "}, {"title": "Arbitrary code can be run with Controller as msg.sender", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/65", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L497-L516   # Vulnerability details  ## Impact  A malicious user can call Controller's operate with ActionType.QTokenPermit, providing a precooked contract address as qToken, that will be called by Controller contract with IQToken(_qToken).permit(), which implementation can be arbitrary as long as IQToken interface and permit signature is implemented.  The Controller is asset bearing contract and it will be msg.sender in this arbitrary permit() function called, which is a setup that better be avoided.  ## Proof of Concept  When the Controller's operate with a QTokenPermit action, it parses the arguments with Actions library and then calls internal _qTokenPermit:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L91-L92  _qTokenPermit calls the IQToken(_qToken) address provided without performing any additional checks:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L497-L516  This way, contrary to the approach used in other actions, qToken isn't checked to be properly created address and is used right away, while the requirement that the address provided should implement IQToken interface and have permit function with a given signature can be easily met with a precooked contract.  ## Recommended Mitigation Steps  Given that QToken can be called directly please examine the need for QTokenPermit ActionType.  If current approach is based on UI convenience and better be kept, consider probing for IOptionsFactory(optionsFactory).isQToken(_qToken) before calling the address provided.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "## Title 1 Missing input validation on array lengths  ### Impact The functions below fail to perform input validation on arrays to verify the lengths match. A mismatch could lead to an exception or undefined behavior.  ## #Proof of Concept https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L138-L160  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L163-L184  ### Tools Used Manual review on VScode  ### Recommended Mitigation Steps Add input validation to check that the length of both arrays match.  ---------------------------------------------------------------------------------------------------------------------  -------------------------------------------------------------------------------------------------------------------- ## Title 2 Use of ecrecover is susceptible to signature malleability  ### Impact The ecrecover function is used in metaSetApprovalForAll() to recover the address from the signature. The built-in EVM precompile ecrecover is susceptible to signature malleability which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121 and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57).   ## #Proof of Concept https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L218-L219  ### Tools Used Manual review on VScode  ### Recommended Mitigation Steps Consider using the openzeppelin ECDSA library for signature verifications."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/62", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "## Issue 1 (Low) - Exclusive time checks should be inclusive  ### Links https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L325-L328  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L563-L566   ### Impact At least one of the following checks is slightly inaccurate due to exclusive timestamp checks.  ``` require(             block.timestamp > qToken.expiryTime(),             \"Controller: Can not exercise options before their expiry\"         ); ```  ``` require(             IQToken(_qToken).expiryTime() > block.timestamp,             \"Controller: Cannot mint expired options\"         ); ```  The second statement ceases minting the moment the expiryTime is hit which makes sense. The first statement doesn't allow the options to be exercised until after the expiry time, causing a gap in functionality.   ### Recommended Steps The first statement should be:  ``` require(             block.timestamp >= qToken.expiryTime(),             \"Controller: Can not exercise options before their expiry\"         ); ```  ## Issue 2 (Low) - Missing Address(0) Checks in Constructor Address Params  ### Links https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L325-L328  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L563-L566  ### Impact These two contracts do not check for address(0) in their constructors and will require redeployment if necessary.  ### Recommended Steps Add require statements != address(0) in both constructors.  ## Issue 3 (Low) - Front-Runnable Initializers  ### Links https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L134-L159  ### Impact Lack of access control on initialize(), can be front-run.  ### Recommended Steps Add access control for OnlyOwner.  ## Issue 4 (Low) - Function input doesn't match purpose  ### Links https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/QuantCalculator.sol#L61-L163  ### Impact The address parameter in the following function is named `_msgSender` but it can arbitrarily be any account since it has external visibility.  ``` function calculateClaimableCollateral(         uint256 _collateralTokenId,         uint256 _amount,         address _msgSender     )         external         view         override         returns (             uint256 returnableCollateral,             address collateralAsset,             uint256 amountToClaim         )     { ```  ### Recommended Steps Rename to \"user\" or similar.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/61", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# QA Report  ## Non-Critical Findings  ### Contract implementations should inherit their interface  #### Description  It's best practice for a contract to inherit from it's interface. This improves the contract's clarity and makes sure the contract implementation complies with the defined interface.  #### Findings  [QuantConfig.sol](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L13):  ```solidity contract QuantConfig is     AccessControlUpgradeable,     OwnableUpgradeable,     IQuantConfig, // @audit-info add interface IQuantConfig     ITimelockedConfig {   ... } ```  #### Recommended mitigation steps  Inherit from the missing interface or contract.  ---  ### Public functions that could be declared external  #### Description  Following functions should be declared `external`, as functions that are never called by the contract internally should be declared external (to save gas) as well as for code clarity reasons.  #### Findings  [ChainlinkFixedTimeOracleManager.isValidOption()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L56)   [ProviderOracleManager.isValidOption()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L68)   [ChainlinkOracleManager.isValidOption()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L136)   [PriceRegistry.hasSettlementPrice()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L116)    #### Recommended mitigation steps  Use the `external` attribute for functions never called from the contract.  ---  ### Spelling mistakes  #### Description  Spelling mistakes found.  #### Findings  **[timelock/ConfigTimelockController.sol](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol)**  [L623](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L623): `_isProtocoValueSetter` -> `_isProtocolValueSetter`  #### Recommended mitigation steps  Fix spelling mistakes.  ---  ### Redundant storage access - use variable `assetOracle`  #### Description  _I know there are no rewards for gas optimizations, nevertheless I want to address this finding to prevent any future issues and confusions._  The current implementation of [ProviderOracleManager.getAssetOracle()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L78) has a `require` statement which repeatedly accesses `assetOracles[_asset]` from storage:  ```solidity function getAssetOracle(address _asset)     public     view     override     returns (address) {     address assetOracle = assetOracles[_asset];     require(         assetOracles[_asset] != address(0), // @audit repeated storage variable access         \"ProviderOracleManager: Oracle doesn't exist for that asset\"     );     return assetOracle; } ```  #### Findings  [ProviderOracleManager.getAssetOracle()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L78)  #### Recommended mitigation steps  Change code to:  ```solidity function getAssetOracle(address _asset)     public     view     override     returns (address) {     address assetOracle = assetOracles[_asset];     require(         assetOracle != address(0), // @audit use `assetOracle` instead         \"ProviderOracleManager: Oracle doesn't exist for that asset\"     );     return assetOracle; } ```  ## Low Risk  ### Missing documentation of function parameters  #### Description  Function parameters should be fully documented to provide clear instructions what parameters are used for.  #### Findings  [QTokenStringUtils.\\_qTokenName()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/QTokenStringUtils.sol#L41): missing `@param` for `_strikeAsset`   [OptionsUtils.getTargetQTokenAddress()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/OptionsUtils.sol#L32): missing `@param` for `_quantConfig`   [OptionsUtils.getTargetCollateralTokenId()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L67): missing `@param` for `_quantConfig`    #### Recommended mitigation steps  Add `@param` documentation for all parameters.  ---  ### `ChainlinkOracleManager.isValidOption()` always returns `true` for any asset  #### Description  The current implementation of `ChainlinkOracleManager.isValidOption()` always returns true, not matter which `_asset` is passed:  ```solidity function isValidOption(     address,     uint256,     uint256 )     public     view     virtual     override(ProviderOracleManager, IProviderOracleManager)     returns (bool) {     return true; // @audit-info always returns `true` } ```  There are no risks caused by to this implementation as there are checks in place to make sure there's a valid oracle price for the underlying qToken asset (e.g in [PriceRegistry.getSettlementPriceWithDecimals()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L72)).  Nevertheless this function should check if the passed `_asset` is valid.  #### Findings  [ChainlinkOracleManager.isValidOption()](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L133)  #### Recommended mitigation steps  Change implementation to:  ```solidity function isValidOption(     address _asset,     uint256,     uint256 )     public     view     virtual     override(ProviderOracleManager, IProviderOracleManager)     returns (bool) {     getAssetOracle(_asset); // @audit-info add this function call which has a `require` statement to assert `_asset` is supported by oracle      return true; } ```  and fix failing unit test in [ChainlinkOracleManager.test.ts#L385](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/test/ChainlinkOracleManager.test.ts#L385)  ---  ### Shadowed variables  #### Description  Possible incorrect use of variables are at stake which may have bad side effects to the contract if implemented incorrectly.  The variable `_timestamps` does not pose any immediate risk to the contract as it's not used in the contract, incorrect usage of the variable is possible and can cause serious issues if the developer does not pay close attention.  The variable `minDelay` could cause issues as it's used in the contract. As the shadowed `minDelay` variable in the inherited contract `TimelockController.sol` can be changed (with `updateDelay()`), the variable with the same name in contract `ConfigTimelockController` does not change and is out of sync.  #### Findings  [timelock/ConfigTimelockController.sol.\\_timestamps](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L15)   [timelock/ConfigTimelockController.sol.minDelay](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L18)  #### Recommended mitigation steps  **[timelock/ConfigTimelockController.sol.\\_timestamps](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L15)**:  Remove variable declaration `_timestamps`:  ```solidity mapping(bytes32 => uint256) private _timestamps; ```  **[timelock/ConfigTimelockController.sol.minDelay](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L18)**:  Remove variable declaration `minDelay`:  ```solidity uint256 public minDelay; ```  Replace all occurrences of `minDelay` with `getMinDelay()`. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Low 1 Deprecated `_setupRole` function used  ## Impact  The _setupRole function is deprecated according to the Open Zeppelin comment `NOTE: This function is deprecated in favor of {_grantRole}`  Use the recommended _grantRole function instead.  ## Proof of concept  Where _setupRole is used in rolla https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L160-L161 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/TimelockController.sol#L79-L90  Open Zeppelin comment https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L195  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Avoid using deprecated functions. Replace _setupRole with _grantRole  # Low 2 _timestamps variable shadowing  ## Impact  ConfigTimelockController.sol inherits TimelockController.sol but declares a new _timestamps mapping equivalent to the mapping in TimelockController.sol. This shadowing of the mapping will cause problems in calls to parent functions that use the _timestamps mapping, because the _timestamps mapping in ConfigTimelockController.sol is not used.  The same issue exists with minDelay and _minDelay variables in the same two contracts  ## Proof of concept  _timestamps is declared in TimelockController.sol https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/TimelockController.sol#L29  An identical _timestamps mapping is declared in ConfigTimelockController.sol, which inherits TimelockController.sol and does not need to declare an identical mapping with the same name https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L15  The same issue exists with minDelay and _minDelay variables in the same two contracts  ## Tools Used  Slither https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing  ## Recommended Mitigation Steps  Remove the line of code declaring the _timestamps mapping in ConfigTimelockController.sol so that the _timestamps mapping from TimelockController.sol is used throughout.  # Low 3 Roles not added to quantRoles  ## Impact  The quantRoles mapping is intended to store all roles used by QuantConfig.sol. Other contracts import the IQuantConfig.sol interface and call config.quantRoles. Most of the contracts calling config.quantRoles do so for a role that is never added to the quantRoles mapping in QuantConfig.sol. Because solidity variables has a default value, querying an entity of a `string => bytes32` mapping that does not exist with return an empty bytes32 value of bytes32(0). This interferes with the intended logic of the contracts and in some cases will result in if statements that always return one condition because the quantRoles mapping is never updated outside of the _setProtocolRole function.  ## Proof of concept  Observe that the quantRoles mapping has a new role added in the _setProtocolRole function of QuantConfig.sol, and this is the only function in QuantConfig.sol that modifies this mapping https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L177  Because the _setProtocolRole is an internal function, another contract would need to inherit QuantConfig.sol in order to modify the quantRoles mapping. But no other contract in the Rolla project does this. There are several roles, such as FALLBACK_PRICE_ROLE, which are queried in the quantRoles mapping but will never return a value other than bytes32(0) https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L81  Another example is the COLLATERAL_MINTER_ROLE role, which is queried twice but never set and will always return bytes32(0) https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L108 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L145  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  The simplest approach is a manual one that may result in error. The owner of QuantConfig.sol can call setProtocolRole to set these roles after QuantConfig is deployed. This may even be the intended approach with this code, but there is no test or other code that demonstrates setting the FALLBACK_PRICE_ROLE in the quantRoles mapping.  A more robust solution is to call _setProtocolRole with all the hardcoded roles in the initialize function of QuantConfig.sol, like what is done for oracleManagerRole in this line https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L164  # Low 4 Missing reentrancy guard on ERC1155 _mint  ## Impact  The ERC1155 _mint function is vulnerable to reentrancy. A nonreentrant modifier or lock modifier should be applied to functions that have reentrancy weaknesses for protection from this attack vector. Even though no direct reentrancy attack may exist on these Rolla functions today, that could change in the future and proper defensive measures are crucial.  ## Proof of concept  The ERC1155 _mint function is used in mintCollateralToken https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L116  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the nonReentrant modifier from the Open Zeppelin library https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/56", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "### L-01: Missing Zero check QuantCalculator.constructor(contracts/QuantCalculator.sol#55) lacks a zero-check on : optionsFactory = _optionsFactory (contracts/QuantCalculator.sol#57)  ### L-02:  Ether lock Payable function with no method of withdrawal available, eventually ends up locking ether  ``` executeMetaTransaction() (contracts/utils/EIP712MetaTransaction.sol#55-93) ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/54", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# C4-001 : Incompatibility With Rebasing/Deflationary/Inflationary tokens  ## Impact -  LOW  PrePo protocol do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.  ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L200  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L394  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L472 ```  ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  - Ensure that to check previous balance/after balance  equals to amount for any rebasing/inflation/deflation - Add support in contracts for such tokens before accepting user-supplied tokens - Consider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they don't want to lose them.  # C4-002 : Front-runnable Initializers  ## Impact - LOW  All contract **initializers** were missing access controls, allowing any user to initialize the contract. By front-running the contract deployers to initialize the contract, the incorrect parameters may be supplied, leaving the contract needing to be redeployed.   ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L148  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L134 ```  2. initialize functions does not have access control. They are vulnerable to front-running.   ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  While the code that can be run in contract constructors is limited, setting the owner in the contract's constructor to the `msg.sender` and adding the `onlyOwner` modifier to all **initializers** would be a sufficient level of access control.  # C4-003 : Use of ecrecover is susceptible to signature malleability  ## Impact - LOW  The ecrecover function is used in permit() to recover the address from the signature. The built-in EVM precompile ecrecover is susceptible to signature malleability which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121 and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57).  ## Proof of Concept  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L218  ## Tools Used  None  ## Recommended Mitigation Steps  Consider using OpenZeppelin\u2019s ECDSA library (which prevents this malleability) instead of the built-in function.  # C4-004 : transferOwnership should be two step process  ## Impact  \"QuantConfig.sol\" inherit OpenZeppelin's OwnableUpgradeable contract which enables the onlyOwner role to transfer ownership to another address. It's possible that the onlyOwner role mistakenly transfers ownership to the wrong address, resulting in a loss of the onlyOwner role. The current ownership transfer process involves the current owner calling Unlock.transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier. Lack of two-step procedure for critical operations leaves them error-prone if the address is incorrect, the new address will take on the functionality of the new role immediately  for Ex : -Alice deploys a new version of the whitehack group address. When she invokes the whitehack group address setter to replace the address, she accidentally enters the wrong address. The new address now has access to the role immediately and is too late to revert   ## Proof of Concept  1. Navigate to \"https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L15\" 2. The contracts have many onlyOwner function. 3. The contract is inherited from the Ownable which includes transferOwnership.  ## Tools Used  None  ## Recommended Mitigation Steps  Implement zero address check and Consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account. "}, {"title": "Low-level transfer via call() can fail silently", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/TimelockController.sol#L414-L415   # Vulnerability details  ## Impact In the `_call()` function in `TimelockController.sol`, a call is executed with the following code:  ``` function _call(         bytes32 id,         uint256 index,         address target,         uint256 value,         bytes memory data     ) private {         // solhint-disable-next-line avoid-low-level-calls         (bool success, ) = target.call{value: value}(data);         require(success, \"TimelockController: underlying transaction reverted\");          emit CallExecuted(id, index, target, value, data);     } ```  Per the Solidity docs:  \"The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.\"   Therefore, transfers may fail silently.  ## Proof of Concept Please find the documentation here: https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions  ## Tools Used Manual review.  ## Recommended Mitigation Steps Check for the account's existence prior to transferring.  "}, {"title": "[WP-H6] Admin of the upgradeable proxy contract of `Controller.sol` can rug users", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/48", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L22-L34   # Vulnerability details  Use of Upgradeable Proxy Contract Structure allows the logic of the contract to be arbitrarily changed.  This allows the proxy admin to perform malicious actions e.g., taking funds from users' wallets up to the allowance limit.  This action can be performed by the malicious/compromised proxy admin without any restriction.   Considering that the purpose of this particular contract is for accounting of the Collateral and LongShortTokens, we believe the users' allowances should not be hold by this upgradeable contract.  ### PoC  Given:  - collateral: `USDC`  #### Rug Users' Allowances  1. Alice `approve()` and `_mintOptionsPosition()` with `1e8 USDC`; 2. Bob  `approve()` and `_mintOptionsPosition()` with `5e8 USDC`; 3. A malicious/compromised proxy admin can call `upgradeToAndCall()` on the proxy contract and set a malicious contract as `newImplementation` and stolen all the USDC in Alice and Bob's wallets;  #### Rug Contract's Holdings (funds that belongs to users)  A malicious/compromised proxy admin can just call `upgradeToAndCall()` on the proxy contract and send all the USDC held by the contract to an arbitrary address.  ### Severity  A smart contract being structured as an upgradeable contract alone is not usually considered as a high severity risk. But given the severe impact (all the funds in the contract and funds in users' wallets can be stolen), we mark it as a `High` severity issue.  ### Recommendation  Consider using the non-upgradeable `CollateralToken` contract to hold user's allowances instead.  See also the Recommendation of [WP-H7].  "}, {"title": "[WP-M3] `OperateProxy.callFunction()` should check if the `callee` is a contract", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/OperateProxy.sol#L10-L19   # Vulnerability details  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L550-L558  ```solidity     /// @notice Allows a sender/signer to make external calls to any other contract.     /// @dev A separate OperateProxy contract is used to make the external calls so     /// that the Controller, which holds funds and has special privileges in the Quant     /// Protocol, is never the `msg.sender` in any of those external calls.     /// @param _callee The address of the contract to be called.     /// @param _data The calldata to be sent to the contract.     function _call(address _callee, bytes memory _data) internal {         IOperateProxy(operateProxy).callFunction(_callee, _data);     } ```  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/OperateProxy.sol#L10-L19  ```solidity     function callFunction(address callee, bytes memory data) external override {         require(             callee != address(0),             \"OperateProxy: cannot make function calls to the zero address\"         );          (bool success, bytes memory returnData) = address(callee).call(data);         require(success, \"OperateProxy: low-level call failed\");         emit FunctionCallExecuted(tx.origin, returnData);     } ```  As the `OperateProxy.sol#callFunction()` function not payable, we believe it's not the desired behavior to call a non-contract address and consider it a successful call.  For example, if a certain business logic requires a successful `token.transferFrom()` call to be made with the `OperateProxy`, if the `token` is not a existing contract, the call will return `success: true` instead of `success: false` and break the caller's assumption and potentially malfunction features or even cause fund loss to users.  The qBridge exploit (January 2022) was caused by a similar issue.  As a reference, OpenZeppelin's `Address.functionCall()` will check and `require(isContract(target), \"Address: call to non-contract\");`  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/Address.sol#L135  ```solidity     function functionCallWithValue(         address target,         bytes memory data,         uint256 value,         string memory errorMessage     ) internal returns (bytes memory) {         require(address(this).balance >= value, \"Address: insufficient balance for call\");         require(isContract(target), \"Address: call to non-contract\");          (bool success, bytes memory returndata) = target.call{value: value}(data);         return verifyCallResult(success, returndata, errorMessage);     } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/Address.sol#L36-L42  ```solidity     function isContract(address account) internal view returns (bool) {         // This method relies on extcodesize/address.code.length, which returns 0         // for contracts in construction, since the code is only stored at the end         // of the constructor execution.          return account.code.length > 0;     } ```  ### Recommendation  Consider adding a check and throw when the `callee` is not a contract.  "}, {"title": "[WP-H2] `EIP712MetaTransaction.executeMetaTransaction()` failed txs are open to replay attacks", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/45", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86   # Vulnerability details  Any transactions that fail based on some conditions that may change in the future are not safe to be executed again later (e.g. transactions that are based on others actions, or time-dependent etc).  In the current implementation, once the low-level call is failed, the whole tx will be reverted and so that `_nonces[metaAction.from]` will remain unchanged.  As a result, the same tx can be replayed by anyone, using the same signature.  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86  ```solidity     function executeMetaTransaction(         MetaAction memory metaAction,         bytes32 r,         bytes32 s,         uint8 v     ) external payable returns (bytes memory) {         require(             _verify(metaAction.from, metaAction, r, s, v),             \"signer and signature don't match\"         );          uint256 currentNonce = _nonces[metaAction.from];          // intentionally allow this to overflow to save gas,         // and it's impossible for someone to do 2 ^ 256 - 1 meta txs         unchecked {             _nonces[metaAction.from] = currentNonce + 1;         }          // Append the metaAction.from at the end so that it can be extracted later         // from the calling context (see _msgSender() below)         (bool success, bytes memory returnData) = address(this).call(             abi.encodePacked(                 abi.encodeWithSelector(                     IController(address(this)).operate.selector,                     metaAction.actions                 ),                 metaAction.from             )         );          require(success, \"unsuccessful function call\");         emit MetaTransactionExecuted(             metaAction.from,             payable(msg.sender),             currentNonce         );         return returnData;     } ```  See also the implementation of OpenZeppelin's `MinimalForwarder`:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/metatx/MinimalForwarder.sol#L42-L66  ### PoC  Given:  - The collateral is USDC; - Alice got `10,000 USDC` in the wallet.  1. Alice submitted a MetaTransaction to `operate()` and `_mintOptionsPosition()` with `10,000 USDC`; 2. Before the MetaTransaction get executed, Alice sent `1,000 USDC` to Bob; 3. The MetaTransaction submited by Alice in step 1 get executed but failed; 4. A few days later, Bob sent `1,000 USDC` to Alice; 5. The attacker can replay the MetaTransaction failed to execute at step 3 and succeed.  Alice's `10,000 USDC` is now been spent unexpectedly against her will and can potentially cause fund loss depends on the market situation.  ### Recommendation  Failed txs should still increase the nonce.  While implementating the change above, consider adding one more check to require sufficient gas to be paid, to prevent \"insufficient gas griefing attack\" as described in [this article](https://ipfs.io/ipfs/QmbbYTGTeot9ic4hVrsvnvVuHw4b5P7F5SeMSNX9TYPGjY/blog/ethereum-gas-dangers/).  "}, {"title": " [WP-H0] Wrong implementation of `EIP712MetaTransaction`", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/43", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114   # Vulnerability details  1. `EIP712MetaTransaction` is a utils contract that intended to be inherited by concrete (actual) contracts, therefore. it's initializer function should not use the `initializer` modifier, instead, it should use `onlyInitializing` modifier. See the implementation of [openzeppelin `EIP712Upgradeable` initializer function](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L48-L57).  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114  ```solidity     /// @notice initialize method for EIP712Upgradeable     /// @dev called once after initial deployment and every upgrade.     /// @param _name the user readable name of the signing domain for EIP712     /// @param _version the current major version of the signing domain for EIP712     function initializeEIP712(string memory _name, string memory _version)         public         initializer     {         name = _name;         version = _version;          __EIP712_init(_name, _version);     } ```  Otherwise, when the concrete contract's initializer function (with a `initializer` modifier) is calling EIP712MetaTransaction's initializer function, it will be mistok as reentered and so that it will be reverted (unless in the context of a constructor, e.g. Using @openzeppelin/hardhat-upgrades `deployProxy()` to initialize).  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/proxy/utils/Initializable.sol#L50-L53  ```solidity     /**      * @dev Modifier to protect an initializer function from being invoked twice.      */     modifier initializer() {         // If the contract is initializing we ignore whether _initialized is set in order to support multiple         // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the         // contract may have been reentered.         require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");          bool isTopLevelCall = !_initializing;         if (isTopLevelCall) {             _initializing = true;             _initialized = true;         }          _;          if (isTopLevelCall) {             _initializing = false;         }     } ```  See also: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/releases/tag/v4.4.1   2. `initializer` can only be called once, it can not be \"called once after every upgrade\".  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114  ```solidity     /// @notice initialize method for EIP712Upgradeable     /// @dev called once after initial deployment and every upgrade.     /// @param _name the user readable name of the signing domain for EIP712     /// @param _version the current major version of the signing domain for EIP712     function initializeEIP712(string memory _name, string memory _version)         public         initializer     {         name = _name;         version = _version;          __EIP712_init(_name, _version);     } ```   3. A utils contract that is not expected to be deployed as a standalone contract should be declared as `abstract`. It's `initializer` function should be `internal`.  See the implementation of [openzeppelin `EIP712Upgradeable`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28).  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28  ```solidity abstract contract EIP712Upgradeable is Initializable {     // ... } ```  ### Recommendation  Change to:  ```solidity abstract contract EIP712MetaTransaction is EIP712Upgradeable {     // ... } ```  ```solidity     /// @notice initialize method for EIP712Upgradeable     /// @dev called once after initial deployment.     /// @param _name the user readable name of the signing domain for EIP712     /// @param _version the current major version of the signing domain for EIP712     function __EIP712MetaTransaction_init(string memory _name, string memory _version)         internal         onlyInitializing     {         name = _name;         version = _version;          __EIP712_init(_name, _version);     } ```    "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/42", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "## [L] `ConfigTimelockController` One address should not be able to be a `proposer` and a `executor` at the same time  The purpose of the design which have two separate roles of `proposers` and `executors` is to prevent the centralization risk which one can propose a change and get it executed right away by themselves.  However, the current implementation allows the same address to be in `proposers` and `executors` at the same time, this makes such a design becomes a unenforced law.  In operation practise, the admin can and, we believe they have a natural tendency to add both roles to the same address as this is easier in operation.  ### Recommendation  Consider adding a check to make sure `proposers` and `executors` do not include any same address  ## [L] Tokens with fee on transfer are not supported  There are ERC20 tokens that charge fee for every `transfer()` or `transferFrom()`.  In the current implementation, `Controller.sol#_mintOptionsPosition()`, `Controller.sol#_mintSpread()` and `Controller.sol#_claimCollateral()` assumes that the received amount is the same as the transfer amount, and uses it for collateralToken minting and redeeming.  ### Recommendation  Making sure no FOT tokens will be whitelisted in the protocol."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L176-L180   # Vulnerability details  ## Impact  A switch to an assetsRegistry that doesn't contain a particular underlying by mistake or as a part of griefing attack will freeze all the payoff funds accounted for already issued QTokens with this underlying. I.e. all buyers and sellers of the associated QTokens will have the payoff funds frozen until assetsRegistry be updated as Controller's _claimCollateral, _neutralizePosition and _exercise will be failing in this case.  For example, suppose LINK is added as an underlying to assetsRegistry, some time passed and options were minted, then the registry is updated and LINK is no longer listed there. All the users with not yet fulfilled claims on the issued LINK options will have their funds frozen until assetsRegistry be updated again to include LINK back.  In other words, at the moment there is no way to separate new options issuance and existing options settlement, which makes a removal of an underlying a tricky task, given that maturity of the options isn't restricted.  ## Proof of Concept  In QuantConfig the priceRegistry setting is immutable, while oracleRegistry and assetsRegistry can be reset by an owner:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantConfig.sol#L47-L64  oracleRegistry reset affect new option creation and minting only.  On the other hand, apart from QToken creation, assetsRegistry is used in the most of payoff calculations.  This way assetsRegistry reset to a contract that doesn't have a record of a particular underlying will freeze all the payoff calculation functionality as OptionsUtils.getPayoutDecimals, which will become unavailable, is called by QuantCalculator's getCollateralRequirement, getExercisePayout, calculateClaimableCollateral and getNeutralizationPayout.   Here is getPayoutDecimals called by getNeutralizationPayout:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L176-L180  Also, by calculateClaimableCollateral, getCollateralRequirement, getExercisePayout:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L133-L137  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L210-L214  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/QuantCalculator.sol#L261-L265  This way, a switch to an assetsRegistry that doesn't constant the underlying will make most of the QuantCalculator's payoff calculations fail, freezing all the payoff funds accounted for all the QTokens with this underlying.   ## Recommended Mitigation Steps  As getPayoutDecimals is the basic function to request the decimals, which a single constant value, consider moving it to the QToken storage instead of requesting from an outside contracts each time.  Apart from removing this attack surface, this will also provide some gas optimisation, which is viable as mentioned operations are common enough, justifying a minor increase in storage space.   "}, {"title": "QTokens with the same symbol will lead to mistakes", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/38", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L115-L130   # Vulnerability details  The `README.md` states: > Bob can then trade the QToken with Alice for a premium. The method for doing that is beyond the scope of the protocol but can be done via any smart contract trading platform e.g. 0x.  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/README.md?plain=1#L70  It is therefore important that tokens be easily identifiable so that trading on DEXes is not error-prone.  ## Impact Currently the `QToken` `name` includes the full year but the `QToken` symbol only contains the last two digits of the year, which can lead to mistakes. If someone mints a QToken with an expiry 100 years into the future, then the year will be truncated and appear as if the token expired this year. Normal centralized exchanges prevent this by listing options themselves and ensuring that there are never two options with the same identifier at the same time. The Rolla protocol does not have any such protections. Users must be told to not only check that the symbol name is what they expect, but to also separately check the token name or the specific expiry, or they might buy the wrong option on a DEX, or have fat-fingered during minting on a non-Rolla web interface. It's important to minimize the possibility of mistakes, and not including the full year in the symbol makes things error-prone, and will lead to other options providers winning out.  The 0x [REST interface](https://docs.0x.org/0x-api-swap/api-references/get-swap-v1-quote) for swaps has the ability to do a swap by token name rather than by token address. I was unable to figure out whether there was an allow-list of token names, or if it is easy to add a new token. If there is no, or an easily bypassed, access-control for adding new tokens, I would say this finding should be upgraded to high-severity, though I doubt this is the case.  ## Proof of Concept ```solidity         /// concatenated symbol string         tokenSymbol = string(             abi.encodePacked(                 \"ROLLA\",                 \"-\",                 underlying,                 \"-\",                 _uintToChars(day),                 monthSymbol,                 _uintToChars(year),                 \"-\",                 displayStrikePrice,                 \"-\",                 typeSymbol             )         ); ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L115-L130  ```solidity     /// @return 2 characters that correspond to a number     function _uintToChars(uint256 _number)         internal         pure         virtual         returns (string memory)     {         if (_number > 99) {             _number %= 100;         }          string memory str = Strings.toString(_number);          if (_number < 10) {             return string(abi.encodePacked(\"0\", str));         }          return str;     } ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L181-L199  ## Tools Used Code inspection  ## Recommended Mitigation Steps Include the full year in the token's symbol   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/37", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "## Low-impact Issues  ### The current code will not be able to support compound options (options on options) The code that adds new assets checks whether the asset already exists or not by checking the token's symbol. Since  `QToken`s' symbols do not contain the full year, once a token with a specific year is added, a similar token 100 years into the future (or into the past) cannot be added 1. File: contracts/libraries/OptionsUtils.sol (lines [152-165](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/libraries/OptionsUtils.sol#L152-L165)) ```solidity     function isInAssetsRegistry(address _asset, address _quantConfig)         internal         view         returns (bool)     {         string memory symbol;         (, symbol, ) = IAssetsRegistry(             IQuantConfig(_quantConfig).protocolAddresses(                 ProtocolValue.encode(\"assetsRegistry\")             )         ).assetProperties(_asset);          return bytes(symbol).length != 0;     } ```  ### Missing checks for `address(0x0)` when assigning values to `address` state variables  1. File: contracts/QuantCalculator.sol (line [57](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantCalculator.sol#L57)) ```solidity         optionsFactory = _optionsFactory; ```   ### Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.  1. File: contracts/Controller.sol (lines [30-33](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/Controller.sol#L30-L33)) ```solidity contract Controller is     IController,     EIP712MetaTransaction,     ReentrancyGuardUpgradeable ``` 2. File: contracts/utils/EIP712MetaTransaction.sol (line [13](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L13)) ```solidity contract EIP712MetaTransaction is EIP712Upgradeable { ``` 3. File: contracts/QuantConfig.sol (lines [13-16](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantConfig.sol#L13-L16)) ```solidity contract QuantConfig is     AccessControlUpgradeable,     OwnableUpgradeable,     ITimelockedConfig ```  ## Non-critical Issues  ### Use a switch statement for long if-else-if chains involving a single variable https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L59-L123   ### _encodeSetProtocolRole() should take in a `ProtocolValue` like the other functions It's inconsistent for roles to be passed in as strings when they can easily be `ProtocolValue`s  1. File: contracts/timelock/ConfigTimelockController.sol ((lines [434-447](https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L434-L447)) ```solidity     function executeSetProtocolRole(         string calldata protocolRole,         address roleAdmin,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) {         execute(             quantConfig,             0,             _encodeSetProtocolRole(protocolRole, roleAdmin, quantConfig),             bytes32(0),             bytes32(eta)         );     } ```  ### `public` functions not called by the contract should be declared `external` instead Inconsistencies make code hard to maintain Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.  1. File: contracts/Controller.sol (lines [134-139](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/Controller.sol#L134-L139)) ```solidity     function initialize(         string memory _name,         string memory _version,         address _optionsFactory,         address _quantCalculator     ) public override initializer { ``` 2. File: contracts/utils/EIP712MetaTransaction.sol (lines [106-108](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L106-L108)) ```solidity     function initializeEIP712(string memory _name, string memory _version)         public         initializer ``` 3. File: contracts/timelock/ConfigTimelockController.sol (lines [250-255](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L250-L255)) ```solidity     function scheduleBatchSetProtocolAddress(         bytes32[] calldata protocolValues,         address[] calldata newAddresses,         address quantConfig,         uint256 eta     ) public onlyRole(PROPOSER_ROLE) { ``` 4. File: contracts/timelock/ConfigTimelockController.sol (lines [281-286](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L281-L286)) ```solidity     function scheduleBatchSetProtocolUints(         bytes32[] calldata protocolValues,         uint256[] calldata newUints,         address quantConfig,         uint256 eta     ) public onlyRole(PROPOSER_ROLE) { ``` 5. File: contracts/timelock/ConfigTimelockController.sol (lines [312-317](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L312-L317)) ```solidity     function scheduleBatchSetProtocolBooleans(         bytes32[] calldata protocolValues,         bool[] calldata newBooleans,         address quantConfig,         uint256 eta     ) public onlyRole(PROPOSER_ROLE) { ``` 6. File: contracts/timelock/ConfigTimelockController.sol (lines [343-348](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L343-L348)) ```solidity     function scheduleBatchSetProtocolRoles(         string[] calldata protocolRoles,         address[] calldata roleAdmins,         address quantConfig,         uint256 eta     ) public onlyRole(PROPOSER_ROLE) { ``` 7. File: contracts/timelock/ConfigTimelockController.sol (lines [374-379](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L374-L379)) ```solidity     function executeSetProtocolAddress(         bytes32 protocolAddress,         address newAddress,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 8. File: contracts/timelock/ConfigTimelockController.sol (lines [394-399](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L394-L399)) ```solidity     function executeSetProtocolUint256(         bytes32 protocolUint256,         uint256 newUint256,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 9. File: contracts/timelock/ConfigTimelockController.sol (lines [414-419](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L414-L419)) ```solidity     function executeSetProtocolBoolean(         bytes32 protocolBoolean,         bool newBoolean,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 10. File: contracts/timelock/ConfigTimelockController.sol (lines [434-439](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L434-L439)) ```solidity     function executeSetProtocolRole(         string calldata protocolRole,         address roleAdmin,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 11. File: contracts/timelock/ConfigTimelockController.sol (lines [454-459](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L454-L459)) ```solidity     function executeBatchSetProtocolAddress(         bytes32[] calldata protocolValues,         address[] calldata newAddresses,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 12. File: contracts/timelock/ConfigTimelockController.sol (lines [490-495](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L490-L495)) ```solidity     function executeBatchSetProtocolUint256(         bytes32[] calldata protocolValues,         uint256[] calldata newUints,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 13. File: contracts/timelock/ConfigTimelockController.sol (lines [526-531](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L526-L531)) ```solidity     function executeBatchSetProtocolBoolean(         bytes32[] calldata protocolValues,         bool[] calldata newBooleans,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 14. File: contracts/timelock/ConfigTimelockController.sol (lines [562-567](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L562-L567)) ```solidity     function executeBatchSetProtocolRoles(         string[] calldata protocolRoles,         address[] calldata roleAdmins,         address quantConfig,         uint256 eta     ) public onlyRole(EXECUTOR_ROLE) { ``` 15. File: contracts/QuantConfig.sol (lines [148-151](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantConfig.sol#L148-L151)) ```solidity     function initialize(address payable _timelockController)         public         override         initializer ``` 16. File: contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol (lines [53-61](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L53-L61)) ```solidity     function isValidOption(         address,         uint256 _expiryTime,         uint256     )         public         view         override(ChainlinkOracleManager, IProviderOracleManager)         returns (bool) ``` 17. File: contracts/pricing/PriceRegistry.sol (lines [112-116](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/PriceRegistry.sol#L112-L116)) ```solidity     function hasSettlementPrice(         address _oracle,         address _asset,         uint256 _expiryTimestamp     ) public view override returns (bool) { ```  ### Adding a `return` statement when the function defines a named return variable, is redundant  1. File: contracts/utils/EIP712MetaTransaction.sol (line [133](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L133)) ```solidity         return sender; ```    ### Using `calldata` instead of `memory` for read-only arguments in `external` does not follow const-correctness This is an example of [const-correctness](https://stackoverflow.com/questions/8277801/what-is-the-definition-of-const-correctness) 1. File: contracts/Controller.sol (line [49](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/Controller.sol#L49)) ```solidity     function operate(ActionArgs[] memory _actions) ``` 2. File: contracts/utils/EIP712MetaTransaction.sol (line [56](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L56)) ```solidity         MetaAction memory metaAction, ``` 3. File: contracts/utils/OperateProxy.sol (line [10](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/utils/OperateProxy.sol#L10)) ```solidity     function callFunction(address callee, bytes memory data) external override { ``` 4. File: contracts/interfaces/IEIP712MetaTransaction.sol (line [7](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IEIP712MetaTransaction.sol#L7)) ```solidity         bytes memory, ``` 5. File: contracts/interfaces/IEIP712MetaTransaction.sol (line [13](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IEIP712MetaTransaction.sol#L13)) ```solidity     function initializeEIP712(string memory, string memory) external; ``` 6. File: contracts/interfaces/IEIP712MetaTransaction.sol (line [13](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IEIP712MetaTransaction.sol#L13)) ```solidity     function initializeEIP712(string memory, string memory) external; ``` 7. File: contracts/interfaces/IController.sol (line [90](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IController.sol#L90)) ```solidity     function operate(ActionArgs[] memory _actions) external returns (bool); ``` 8. File: contracts/interfaces/IController.sol (line [94](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IController.sol#L94)) ```solidity         string memory, ``` 9. File: contracts/interfaces/IController.sol (line [95](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IController.sol#L95)) ```solidity         string memory, ``` 10. File: contracts/interfaces/IProviderOracleManager.sol (line [25](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IProviderOracleManager.sol#L25)) ```solidity         bytes memory _calldata ``` 11. File: contracts/interfaces/IOperateProxy.sol (line [14](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/interfaces/IOperateProxy.sol#L14)) ```solidity     function callFunction(address callee, bytes memory data) external; ``` 12. File: contracts/pricing/oracle/ChainlinkOracleManager.sol (line [60](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L60)) ```solidity         bytes memory ``` 13. File: contracts/pricing/oracle/ProviderOracleManager.sol (line [47](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L47)) ```solidity         bytes memory _calldata ```  ### Not using the named return variables when a function returns is confusing  1. File: contracts/timelock/TimelockController.sol (line [279](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L279)) ```solidity         return getTimestamp(id) > 0; ``` 2. File: contracts/timelock/TimelockController.sol (line [291](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L291)) ```solidity         return getTimestamp(id) > _DONE_TIMESTAMP; ``` 3. File: contracts/timelock/TimelockController.sol (line [305](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L305)) ```solidity         return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp; ``` 4. File: contracts/timelock/TimelockController.sol (line [317](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L317)) ```solidity         return getTimestamp(id) == _DONE_TIMESTAMP; ``` 5. File: contracts/timelock/TimelockController.sol (line [330](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L330)) ```solidity         return _timestamps[id]; ``` 6. File: contracts/timelock/TimelockController.sol (line [339](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L339)) ```solidity         return _minDelay; ``` 7. File: contracts/timelock/TimelockController.sol (line [353](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L353)) ```solidity         return keccak256(abi.encode(target, value, data, predecessor, salt)); ``` 8. File: contracts/timelock/TimelockController.sol (line [367](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L367)) ```solidity         return keccak256(abi.encode(targets, values, datas, predecessor, salt)); ``` 9. File: contracts/QuantCalculator.sol (line [247](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantCalculator.sol#L247)) ```solidity             return (false, address(0), 0); ``` 10. File: contracts/QuantCalculator.sol (line [247](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantCalculator.sol#L247)) ```solidity             return (false, address(0), 0); ``` 11. File: contracts/QuantCalculator.sol (line [247](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/QuantCalculator.sol#L247)) ```solidity             return (false, address(0), 0); ```  ### Duplicated `require()`/`revert()` checks should be refactored to a modifier or function Copy-paste code shouldn't be done and should always be refactored for clean code 1. File: contracts/timelock/TimelockController.sol (lines [246-249](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L246-L249)) ```solidity         require(             targets.length == values.length,             \"TimelockController: length mismatch\"         ); ``` 2. File: contracts/timelock/TimelockController.sol (lines [250-253](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L250-L253)) ```solidity         require(             targets.length == datas.length,             \"TimelockController: length mismatch\"         ); ``` 3. File: contracts/timelock/TimelockController.sol (lines [424-427](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/TimelockController.sol#L424-L427)) ```solidity         require(             isOperationReady(id),             \"TimelockController: operation is not ready\"         ); ``` 4. File: contracts/timelock/ConfigTimelockController.sol (lines [122-125](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L122-L125)) ```solidity         require(             eta >= delay + block.timestamp,             \"ConfigTimelockController: Estimated execution block must satisfy delay\"         ); ``` 5. File: contracts/timelock/ConfigTimelockController.sol (lines [462-465](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L462-L465)) ```solidity         require(             length == newAddresses.length,             \"ConfigTimelockController: length mismatch\"         ); ``` 6. File: contracts/timelock/ConfigTimelockController.sol (lines [498-501](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L498-L501)) ```solidity         require(             length == newUints.length,             \"ConfigTimelockController: length mismatch\"         ); ``` 7. File: contracts/timelock/ConfigTimelockController.sol (lines [534-537](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L534-L537)) ```solidity         require(             length == newBooleans.length,             \"ConfigTimelockController: length mismatch\"         ); ``` 8. File: contracts/timelock/ConfigTimelockController.sol (lines [570-573](https://github.com/code-423n4/2022-03-rolla/tree/main/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L570-L"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/OptionsFactory.sol#L101 Consider using openzeppelin clones in order to save gas, because contract deployment on ethereum is very expensive."}, {"title": "Mint spread collateral-less and conjuring collateral claims out of thin air with implicit arithmetic rounding and flawed int to uint conversion", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/31", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L137 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L151 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/SignedConverter.sol#L28   # Vulnerability details  ## Impact  This report presents 2 different incorrect behaviour that can affect the correctness of math calculations 1. Unattended Implicit rounding in QuantMath.sol `div` and `mul` 2. Inappropriate method of casting integer to unsigned integer in SignedConverter.sol `intToUint`  Bug 1 affects the correctness when calculating collateral required for `_mintSpread`. Bug 2 expands the attack surface and allows attackers to target the `_claimCollateral` phase instead. Both attacks may result in tokens being stolen from Controller in the worst case, but is most likely too costly to exploit under current BNB chain environment. The potential impact however, should not be taken lightly, since it is known that the ethereum environment in highly volatile and minor changes in the environment can suddenly make those bugs cheap to exploit.   ## Proof of Concept  In this section, we will first present bug 1, and then demonstrate how this bug can be exploited. Then we will discuss how bug 2 opens up more attack chances and go over another PoC.  Before getting started, we should go over an important concept while dealing with fixed point number -- rounding. Math has no limits on precision, but computers do. This problem is especially critical to systems handling large amount of \"money\" that is allowed to be arbitrarily divided. A common way for ethereum smart contract developers to handle this is through rounding numbers. Rolla is no exception.  In QuantMath, Rolla explicitly wrote the `toScaledUint` function to differentiate between rounding numbers up or down when scaling numbers to different precision (or we call it `_decimals` here). The intended usage is to scale calculated numbers (amount of tokens) up when Controller is the receiver, and scale it down when Controller is sender. In theory, this function should guarantee Controller can never \"lose tokens\" due to rounding.  ``` library QuantMath {     ...     struct FixedPointInt {         int256 value;     }      int256 private constant _SCALING_FACTOR = 1e27;     uint256 private constant _BASE_DECIMALS = 27;      ...      function toScaledUint(         FixedPointInt memory _a,         uint256 _decimals,         bool _roundDown     ) internal pure returns (uint256) {         uint256 scaledUint;          if (_decimals == _BASE_DECIMALS) {             scaledUint = _a.value.intToUint();         } else if (_decimals > _BASE_DECIMALS) {             uint256 exp = _decimals - _BASE_DECIMALS;             scaledUint = (_a.value).intToUint() * 10**exp;         } else {             uint256 exp = _BASE_DECIMALS - _decimals;             uint256 tailing;             if (!_roundDown) {                 uint256 remainer = (_a.value).intToUint() % 10**exp;                 if (remainer > 0) tailing = 1;             }             scaledUint = (_a.value).intToUint() / 10**exp + tailing;         }          return scaledUint;     }     ... } ```  In practice, the above function also works quite well (sadly, not perfect, notice the `intToUint` function within. We will come back to this later), but it only works if we can promise that before entering this function, all numbers retain full precision and is not already rounded. This is where `div` and `mul` comes into play. As we can easily see in the snippet below, both functions involve the division operator '/', which by default discards the decimal part of the calculated result (be aware to not confuse this with the `_decimal` used while scaling FixedPointInt). The operation here results in an implicit round down, which limits the effectiveness of  explicit rounding in `toScaledUint` showned above.  ```     function mul(FixedPointInt memory a, FixedPointInt memory b)         internal         pure         returns (FixedPointInt memory)     {         return FixedPointInt((a.value * b.value) / _SCALING_FACTOR);     }       function div(FixedPointInt memory a, FixedPointInt memory b)         internal         pure         returns (FixedPointInt memory)     {         return FixedPointInt((a.value * _SCALING_FACTOR) / b.value);     } ```  Now let's see how this implicit rounding can causes troubles. We start with the `_mintSpread` procedure creating a call credit spread. For brevity, the related code is not shown, but here's a summary of what is done.  * `Controller._mintSpread`   * `QuantCalculator.getCollateralRequirement`     * `FundsCalculator.getCollateralRequirement`       * `FundsCalculator.getOptionCollateralRequirement`         * `FundsCalculator.getCallCollateralRequirement`           * scales `_qTokenToMintStrikePrice` from              `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`           * scales `_qTokenForCollateralStrikePrice` from              `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`           * `collateralPerOption = (collateralStrikePrice.sub(mintStrikePrice)).div(collateralStrikePrice)`         * scale `_optionsAmount` from `_optionsDecimals (18)` to `_BASE_DECIMALS (27)`         * `collateralAmount = _optionsAmount.mul(collateralPerOption)`       * uses `qTokenToMint.underlyingAsset` (weth or wbtc) as collateral     * scale and round up `collateralAmountFP` from `_BASE_DECIMALS (27)` to `payoutDecimals (18)`  If we extract all the math related stuff, it would be something like below  ``` def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):         X1 = _qTokenToMintStrikePrice * 10^19         X2 = _qTokenForCollateralStrikePrice * 10^19         X3 = _optionsAmount * 10^9          assert X1 < X2          #credit spread          Y1 = (X2 - X1) * 10^27 // X2    #implicit round down due to div         Y2 = Y1 * X3 // 10^27   #implicit round down due to mul          Z = Y2 // 10^9         if Y2 % 10^9 > 0:       #round up since we are minting spread (Controller is receiver)                 Z+=1         return Z ```  Both implicit round downs can be abused, but we shall focus on the `mul` one here. Assume we follow the following actions  1. create option `A` with strike price `10 + 10^-8 BUSD (10^9 + 1 under 8 decimals) <-> 1 WETH` 2. create option `B` with strike price `10 BUSD (10^9 under 8 decimals) <-> 1 WETH` 3. mint `10^-18` (1 under 18 decimals) option `A`         3-1. `pay 1 eth` 4. mint `10^-18` (1 under 18 decimals) spread `B` with `A` as collateral         4-1. `X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28`         4-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19`         4-3. `X3 = _optionsAmount * 10^9 = 1 * 10^9 = 10^9`         4-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^28 + 10^19 - 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000`         4-5. `Y2 = Y1 * X3 // 10^27 = 99999999000000000 * 10^9 / 10^27 = 0`         4-6. `Z = Y2 // 10^9 = 0`         4-7. `Y2 % 10^9 = 0` so `Z` remains unchanged  We minted a call credit spread without paying any fee.  Now let's think about how to extract the value we conjured out of thin air. To be able to withdraw excessive collateral, we can choose to do a excercise+claim or neutralize current options. Here we take the neutralize path.  For neutralizing spreads, the procedure is basically the same as minting spreads, except that the explicit round down is taken since `Controller` is the payer here. The neutralize procedure returns the `qToken` used as collateral and pays the collateral fee back. The math part can be summarized as below.  ``` def neutralizeCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):         X1 = _qTokenToMintStrikePrice * 10^19         X2 = _qTokenForCollateralStrikePrice * 10^19         X3 = _optionsAmount * 10^9          assert X1 < X2          #credit spread          Y1 = (X2 - X1) * 10^27 // X2    #implicit round down due to div         Y2 = Y1 * X3 // 10^27   #implicit round down due to mul          Z = Y2 // 10^9  #explicit scaling         return Z ```  There are two challenges that need to be bypassed, the first one is to avoid implicit round down in `mul`, and the second is to ensure the revenue is not rounded away during explicit scaling. To achieve this, we first mint `10^-9 + 2 * 10^-18` spreads seperately (10^9 + 2 under 18 decimals), and as shown before, no additional fees are required while minting spread from original option. Then we neutralize all those spreads at once, the calculation is shown below  1. neutralize `10^-9 + 2 * 10^-18` (10^9 + 2 under 18 decimals) spread `B`         4-1. `X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28`         4-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19`         4-3. `X3 = _optionsAmount * 10^9 = (10^9 + 2) * 10^9 = 10^18 + 2`         4-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^28 + 10^19 - 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000`         4-5. `Y2 = Y1 * X3 // 10^27 = 99999999000000000 * (10^18 + 2) / 10^27 = 1000000000`         4-6. `Z = Y2 // 10^9 = 10^9 // 10^9 = 1`  And with this, we managed to generate 10^-18 weth of revenue.  This approach is pretty impractical due to the requirement of minting 10^-18 for `10^9 + 2` times. This montrous count mostly likely requires a lot of gas to pull off, and offsets the marginal revenue generated through our attack. This leads us to explore other possible methods to bypass this limitation.  It's time to start looking at the second bug.  Recall we mentioned the second bug is in `intToUint`, so here's the implementation of it. It is not hard to see that this is actually an `abs` function named as `intToUint`.  ```     function intToUint(int256 a) internal pure returns (uint256) {         if (a < 0) {             return uint256(-a);         } else {             return uint256(a);         }     } ```  Where is this function used? And yes, you guessed it, in `QuantCalculator.calculateClaimableCollateral`. The process of claiming collateral is quite complex, but we will only look at the specific case relevant to the exploit. Before reading code, let's first show the desired scenario. Note that while we wait for expiry, there are no need to sell any option/spread.  1. mint a `qTokenLong` option 2. mint a `qTokenShort` spread with `qTokenLong` as collateral 3. wait until expire, and expect expiryPrice to be between qTokenLong and qTokenShort  ``` ----------- qTokenLong strike price  ----------- expiryPrice  ----------- qTokenShort strike price ```  Here is the outline of the long waited claimCollateral for spread.  * `Controller._claimCollateral`   * `QuantCalculator.calculateClaimableCollateral`     * `FundsCalculator.getSettlementPriceWithDecimals`     * `FundsCalculator.getPayout` for qTokenLong       * qTokenLong strike price is above expiry price, worth 0     * `FundsCalculator.getCollateralRequirement`       * This part we saw earlier, omit details     * `FundsCalculator.getPayout` for qTokenShort       * uses `qTokenToMint.underlyingAsset` (weth or wbtc) as collateral       * `FundsCalculator.getPayoutAmount` for qTokenShort         * scale `_strikePrice` from           `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`         * scale `_expiryPrice.price` from           `_expiryPrice.decimals (8)` to `_BASE_DECIMALS (27)`         * scale `_amount` from           `_optionsDecimals (18)` to `_BASE_DECIMALS (27)`         * `FundsCalculator.getPayoutForCall` for qTokenShort           * `payoutAmount = expiryPrice.sub(strikePrice).mul(amount).div(expiryPrice)`     * `returnableCollateral = payoutFromLong.add(collateralRequirement).sub(payoutFromShort)`     * scale and round down `abs(returnableCollateral)` from `_BASE_DECIMALS (27)` to `payoutDecimals (18)`   Again, we summarize the math part into a function  ``` def claimableCollateralCallCreditSpreadExpiryInbetween(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _expiryPrice, _amount):          def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):                 X1 = _qTokenToMintStrikePrice * 10^19                 X2 = _qTokenForCollateralStrikePrice * 10^19                 X3 = _optionsAmount * 10^9                  Y1 = (X2 - X1) * 10^27 // X2                 Y2 = Y1 * X3 // 10^27                 return Y2          def callCreditSpreadQTokenShortPayout(_strikePrice, _expiryPrice, _amount):                 X1 = _strikePrice * 10^19                 X2 = _expiryPrice * 10^19                 X3 = _amount * 10^9                  Y1 = (X2-X1) * X3 // 10^27                 Y2 = Y1 * 10^27 // X2                 return Y2           assert _qTokenShortStrikePrice > _expiryPrice > _qTokenLongStrikePrice          A1 = payoutFromLong = 0         A2 = collateralRequirement = callCreditSpreadCollateralRequirement(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _amount)         A3 = payoutFromShort = callCreditSpreadQTokenShortPayout(_qTokenShortStrikePrice, _expiryPrice, _amount)          B1 = A1 + A2 - A3          Z = abs(B1) // 10^9         return Z ```  Given the context, it should be pretty easy to imagine what I am aiming here, to make `B1 < 0`. We already know `A1 = 0`, so the gaol basically boils down to making `A2 < A3`. Let's further simplify this requirement and see if the equation is solvable.  ``` X = _qTokenLongStrikePrice (8 decimals) Y = _expiryPrice (8 decimals) Z = _qTokenShortStrikePrice (8 decimals) A = _amount (scaled to 27 decimals)  assert X>Y>Z>0 assert X,Y,Z are integers assert (((X - Z) * 10^27 // X) * A // 10^27) < (((Y - Z) * A // 10^27) * 10^27 // Y) ```  Notice apart from the use of `X` and `Y`, the two sides of the equation only differs by when `A` is mixed into the equation, meaning that if we temporarily ignore the limitation and set `X = Y`, as long as left hand side of equation does an implicit rounding after dividing by X, right hand side will most likely be larger.  Utilizing this, we turn to solve the equation of  ``` (X-Z) / X - (Y-Z) / Y < 10^-27 => Z / Y - Z / X < 10^-27 => (Z = 1 yields best solution) => 1 / Y - 1 / X < 10^-27 => X - Y < X * Y * 10^-27 => 0 < X * Y - 10^27 * X + 10^27 * Y  => require X > Y, so model Y as X - B, where B > 0 and B is an integer => 0 < X^2 - B * X - 10^27 * B ```  It is not easy to see that the larger `X` is, the larger the range of allowed `B`. This is pretty important since `B` stands for the range of expiry prices where attack could work, so the larger it is, the less accurate our guess can be to profit.  Apart form range of `B`, value of `X` is the long strike price and upper bound of range `B`, so we would also care about it, a simple estimation shows that `X` must be above `10^13.5 (8 decimals)` for there to be a solution, which amounts to about `316228 BUSD <-> 1 WETH`. This is an extremely high price, but not high enough to be concluded as unreachable in the near future. So let's take a slightly generous number of `10^14 - 1` as X and calculate the revenue generated following this exploit path.  ``` 0 < (10^14 - 1)^2 - B * (10^14 - 1) - 10^27 * B => (10^14 - 1)^2 / (10^14 - 1 + 10^27) > B => B <= 9 ```  Now we've got the range of profitable expiry price. As we concluded earlier, the range is extremely small with a modest long strike price, but let's settle with this for now and see how much profit can be generated if we get lucky. To calculate profit, we take `_qTokenLongStrikePrice = 10^14 - 1 (8 decimals)`, `_qTokenShortStrikePrice = 1 (8 decimals)`, `_expiryPrice = 10^14 - 2 (8 decimals)` and `_amount = 10^28 (18 decimals)` and plug it back into the function. 1. in `callCreditSpreadCollateralRequirement`         1-1. `X1 = _qTokenForCollateralStrikePrice * 10^19 = 1 * 10^19 = 10^19`         1-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^14 - 1) * 10^19 = 10^33 - 10^19`         1-3. `X3 = _optionsAmount * 10^9 = 10^28 * 10^9 = 10^37`         1-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^33 - 2 * 10^19) * 10^27 // (10^33 - 10^19) = 999999999999989999999999999`         1-5. `Y2 = Y1 * X3 // 10^27 = 999999999999989999999999999 * 10^37 // 10^27 = 999999999999989999999999999 * 10^10` 2. in `callCreditSpreadQTokenShortPayout`         2-1. `X1 = _strikePrice * 10^19 = 1 * 10^19 = 10^19`         2-2. `X2 = _expiryPrice * 10^19 = (10^14 - 2) * 10^19 = 10^33 - 2 * 10^19`         2-3. `X3 = _amount * 10^9 = 10^28 * 10^9 = 10^37`         2-4. `Y1 = (X2 - X1) * X3 // 10^27 = (10^33 - 3 * 10^19) * 10^37 // 10^27 = 99999999999997 * 10^29`         2-5. `Y2 = Y1 * 10^27 / X2 = (99999999999997 * 10^28) * 10^27 / (10^33 - 2 * 10^19) = 9999999999999899999999999997999999999 3. combine terms         3-1. `B1 = A1 + A2 - A3 = 0 + 9999999999999899999999999990000000000 - 9999999999999899999999999997999999999 = -2000000001         3-2. `Z = abs(B1) // 10^9 = 2000000000 // 10^9 = 2  And with this, we managed to squeeze 2 wei from a presumably worthless collateral.  This attack still suffers from several problems 1. cost of WETH in BUSD is way higher than current market 2. need to predict target price accurately to profit 3. requires large amount of WETH to profit  While it is still pretty hard to pull off attack, the requirements seems pretty more likely to be achievable compared to the first version of exploit. Apart from this, there is also the nice property that this attack allows profit to scale with money invested.  This concludes our demonstration of two attacks against the potential flaws in number handling.  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  For `div` and `mul`, adding in a similar opt-out round up argument would work. This would require some refactoring of code, but is the only way to fundamentally solve the problem.  For `intToUint`, I still can't understand what the original motive is to design it as `abs` in disguise. Since nowhere in this project would we benefit from the current `abs` behaviour, in my opinion, it would be best to adopt a similar strategy to the `uintToInt` function. If the value goes out of directly convertable range ( < 0), revert and throw an error message.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "## Summary  We found 1 low-critical finding and 1 non-critical finding: * Low-Critical Findings - Uninitialized qTokenDetails.longStrikePrice for non-spread options in CollateralToken.sol/getCollateralTokenInfo * Non-Critical Findings - Usage of ecrecover for metaTransactions without checking r/s in CollateralToken.sol/metaSetApprovalForAll  In summary of recommended security practices, it's better to initialize memory even if it's 0 and use public and verified libraries rather than craft by hand. The first finding is uninitialized memory, due to solidity doesn't guarantee uninitialized memory is almost always 0. It's better to initialize for improving security practices. The second finding is ecrecover. It's better to use a public and verified library like ECDSA. Because EIP-2 still allows signature malleability for ecrecover(), use ECDSA to remove this possibility and make the signature unique.   ## Low-Critical Findings - Uninitialized qTokenDetails.longStrikePrice for non-spread options in CollateralToken.sol/getCollateralTokenInfo  ## Impact  Uninitialize memory is almost always 0 due to solidity\u2019s no memory recycle policy. However, this is not guaranteed in solidity documents and it would be better to initialize `qTokenDetails.longStrikePrice`. Although it won't cause any problems right now, it could be a potential threat in the future.  ## Proof of Concept  `qTokensDetails.longStrikePrice` isn't initialized when `info.qTokenAsCollateral == address(0)`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L237  ```     function getCollateralTokenInfo(uint256 id)         external         view         override         returns (QTokensDetails memory qTokensDetails)     {         CollateralTokenInfo memory info = idToInfo[id];          require(             info.qTokenAddress != address(0),             \"CollateralToken: Invalid id\"         );          IQToken.QTokenInfo memory shortDetails = IQToken(info.qTokenAddress)             .getQTokenInfo();          qTokensDetails.underlyingAsset = shortDetails.underlyingAsset;         qTokensDetails.strikeAsset = shortDetails.strikeAsset;         qTokensDetails.oracle = shortDetails.oracle;         qTokensDetails.shortStrikePrice = shortDetails.strikePrice;         qTokensDetails.expiryTime = shortDetails.expiryTime;         qTokensDetails.isCall = shortDetails.isCall;          if (info.qTokenAsCollateral != address(0)) {             // the given id is for a CollateralToken representing a spread             qTokensDetails.longStrikePrice = IQToken(info.qTokenAsCollateral)                 .strikePrice();         }     } ```  ## Recommended Mitigation Steps  Initialize qTokensDetails.longStrikePrice  ## Non-Critical Findings - Usage of ecrecover for metaTransactions without checking r/s in CollateralToken.sol/metaSetApprovalForAll  ## Impact  Using ecrecover is against best practice. Preferably use ECDSA.recover instead. EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature unique. However since address and nonce are included in message, it should be impossible to reuse or steal signatures.  ## Proof of Concept  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/CollateralToken.sol#L218  ``` address signer = ecrecover(hash, v, r, s); ```  ## Recommended Mitigation Steps  Use ECDSA.recover instead "}, {"title": "Incorrect strike price displayed in name/symbol of qToken ", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/28", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L38 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L90 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L136 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L206   # Vulnerability details  ## Impact  `_slice()` in `options/QTokenStringUtils.sol` cut a string into `string[start:end]` However, while fetching bytes, it uses `bytes(_s)[_start+1]` instead of `bytes(_s)[_start+i]`. This causes the return string to be composed of `_s[start]*(_end-_start)`. The result of this function is then used to represent the decimal part of strike price in name/symbol of qToken, leading to potential confusion over the actual value of options.   ## Proof of Concept  ERC20 tokens are usually identified by their name and symbol. If the symbols are incorrect, confusions may occur. Some may argue that even if names and symbols are not accurate, it is still possible to identify correct information/usage of tokens by querying the provided view functions and looking at its interactions with other contracts. However, the truth is many users of those tokens are not very tech savvy, and it is reasonable to believe a large proportion of users are not equipped with enough knowledge, or not willing to dig further than the plain symbols and names. This highlights the importance of maintaining a correct facade for ERC20 tokens.  The bug demonstrated here shows that any qToken with decimals in its strike price will be misdisplayed, and the maximal difference between actual price and displayed one can be up to 0.1 BUSD.  The exploit can be outlined through the following steps:  * Alice created a call option with strike price 10000.90001. The expected symbol should for this qToken should be : `ROLLA WETH 31-December-2022 10000.90001 Call`  * Both `_qTokenName()` and `_qTokenSymbol()` in `options/QTokenStringUtils.sol` use `_displayedStrikePrice()` to get the strike price string which should be `10000.90001`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L38 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L90  ```     function _qTokenName(         address _quantConfig,         address _underlyingAsset,         address _strikeAsset,         uint256 _strikePrice,         uint256 _expiryTime,         bool _isCall     ) internal view virtual returns (string memory tokenName) {         string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);         string memory displayStrikePrice = _displayedStrikePrice(             _strikePrice,             _strikeAsset         );            ...            tokenName = string(             abi.encodePacked(                 \"ROLLA\",                 \" \",                 underlying,                 \" \",                 _uintToChars(day),                 \"-\",                 monthFull,                 \"-\",                 Strings.toString(year),                 \" \",                 displayStrikePrice,                 \" \",                 typeFull             )         );     } ```  ```      function _qTokenSymbol(         address _quantConfig,         address _underlyingAsset,         address _strikeAsset,         uint256 _strikePrice,         uint256 _expiryTime,         bool _isCall     ) internal view virtual returns (string memory tokenSymbol) {         string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);         string memory displayStrikePrice = _displayedStrikePrice(             _strikePrice,             _strikeAsset         );          // convert the expiry to a readable string         (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(             _expiryTime         );          // get option type string         (string memory typeSymbol, ) = _getOptionType(_isCall);          // get option month string         (string memory monthSymbol, ) = _getMonth(month);          /// concatenated symbol string         tokenSymbol = string(             abi.encodePacked(                 \"ROLLA\",                 \"-\",                 underlying,                 \"-\",                 _uintToChars(day),                 monthSymbol,                 _uintToChars(year),                 \"-\",                 displayStrikePrice,                 \"-\",                 typeSymbol             )         );     } ```  * `_displayedStrikePrice()` combines the quotient and the remainder to form the strike price string. The remainder use `_slice` to compute. In this case, the quotient is `10000` and the remainder is `90001`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L136 ``` function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)         internal         view         virtual         returns (string memory)     {         uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();         uint256 strikePriceScale = 10**strikePriceDigits;         uint256 remainder = _strikePrice % strikePriceScale;         uint256 quotient = _strikePrice / strikePriceScale;         string memory quotientStr = Strings.toString(quotient);          if (remainder == 0) {             return quotientStr;         }          uint256 trailingZeroes;         while (remainder % 10 == 0) {             remainder /= 10;             trailingZeroes++;         }          // pad the number with \"1 + starting zeroes\"         remainder += 10**(strikePriceDigits - trailingZeroes);          string memory tmp = Strings.toString(remainder);         tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);          return string(abi.encodePacked(quotientStr, \".\", tmp));     } ```  * However inside the loop of `_slice()`, `slice[i] = bytes(_s)[_start + 1];` lead to an incorrect string, which is `90001`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L206  ```     function _slice(         string memory _s,         uint256 _start,         uint256 _end     ) internal pure virtual returns (string memory) {         uint256 range = _end - _start;         bytes memory slice = new bytes(range);         for (uint256 i = 0; i < range; ) {             slice[i] = bytes(_s)[_start + 1];             unchecked {                 ++i;             }         }          return string(slice);     } ```  * The final qtoken name now becomes `ROLLA WETH 31-December-2022 10000.99999 Call`, which results in confusion over the actual value of options.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Fix the bug in the `_slice()`  ```     function _slice(         string memory _s,         uint256 _start,         uint256 _end     ) internal pure virtual returns (string memory) {         uint256 range = _end - _start;         bytes memory slice = new bytes(range);         for (uint256 i = 0; i < range; ) {             slice[i] = bytes(_s)[_start + i];             unchecked {                 ++i;             }         }          return string(slice);     } ```   "}, {"title": "ConfigTimeLockController will put QuantConfig in a stalemate(rendering it unusable) ", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28 https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27   # Vulnerability details  The QuantConfig contract has these important setters, setProtocolAddress(), setProtocolUint256, setProtocolBoolean() and setProtocolRole(). This contract is subjected to a timelock before all such processes above are executed. But, the issue arises in the fact that in configTimeLockController, the state variable minimum delay can be set to an arbitrary value, up to type(uint256).max(cannot assume what value will be set) and could potentially render the QuantConfig contract unusable . All the previous values and addresses would not be able to be changed because of a very high delay being set:  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28   I discussed with one of the devs about the use of this specific mapping :  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27  After discussions with one of the devs(#0xca11.eth) , it was understood  that these values are for the rollaOrderFee which is a part of their limit order protocol contract(outside of the scope of the contest) but given the argument above,  its configuration will be severely impacted (old percentage fees won't be able to be changed).Rolla limit order protocol depends on this configuration setting within QuantConfig.  It is recommended that a constant be declared with a MAXIMUM_DELAY and whatever \u2018minimum delay\u2019 that is set thereafter should be below this value since there's another function setDelay () which can also be of high arbitrary value:  require(minimum delay \u2264MAXIMUM_DELAY, \u201c too high\u201d)  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "@return in NatSpec comment missing for :  Controller.sol:  [https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L176]  [https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L242]  EIP712MetaTx.sol:  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L148   ConfigTimeLockController.sol:  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L648  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L665  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L682  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L699  ChainLinkFixedTimeOracleManager.sol:  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L77    "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Missing Zero Chcks  ## impact Zero-address checks for input validation of address-type variables is a best-practice. While this is implemented in some places, there are missing ones.  ## POC  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/ QuantCalculator.sol#L55-L57  strikeAssetDecimals and optionsFactory variables do not perform zero checks which could result in lose of funds or malfunctions.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add zero-address checks   # Arbitrary send  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/TimelockController.sol#L414  ## impact Unprotected call to a function sending Ether to an arbitrary address.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Ensure that an arbitrary user cannot withdraw unauthorized funds."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/22", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# addAssetOracle lack oracle validation Recommended to add a check to make sure the oracle return 8 decimals https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L25  # Extra lines https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L26  # Lack event on critical parameters change - Timelock delay change https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L34  # isSettled must already be true isSettled must already be true https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/QuantCalculator.sol#L249  # Should revert if newDelay < minDelay Should revert if newDelay < minDelay instead of silently set to minDelay https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L39  # Variables can be mark immutable https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/options/QToken.sol#L21 ```     /// @inheritdoc IQToken     IQuantConfig public override quantConfig;      /// @inheritdoc IQToken     address public override underlyingAsset;      /// @inheritdoc IQToken     address public override strikeAsset;      /// @inheritdoc IQToken     address public override oracle;      /// @inheritdoc IQToken     uint256 public override strikePrice;      /// @inheritdoc IQToken     uint256 public override expiryTime;      /// @inheritdoc IQToken     bool public override isCall; ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/20", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Confusing error message at ``deactivateOracle`` function in ``OracleRegistry.sol``   ## Target codebase https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/OracleRegistry.sol#L67  ``` require(     config.hasRole(         config.quantRoles(\"ORACLE_MANAGER_ROLE\"),         msg.sender     ),     \"OracleRegistry: Only an oracle admin can add an oracle\" ); ```  Statement \"Only an oracle admin can add an oracle\" seems not to be right.   ## Potential fix It should say \"Only an oracle admin can deactivate an oracle\" or others.  ---  # Confusing error message at ``activateOracle`` function in ``OracleRegistry.sol``   ## Target codebase https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/OracleRegistry.sol#L81-L87  ``` require(     config.hasRole(         config.quantRoles(\"ORACLE_MANAGER_ROLE\"),         msg.sender     ),     \"OracleRegistry: Only an oracle admin can add an oracle\" ); ```  Statement \"Only an oracle admin can add an oracle\" seems not to be right.   ## Potential fix It should say \"Only an oracle admin can activate an oracle\" or others.  ---    "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L128 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L30 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L107 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L250   # Vulnerability details  ## Impact The `ChainlinkOracleManager` contract expects every oracle to provide the price data with 8 decimals. But, that's not always the case. Depending on the asset, the decimals could also be 16. In that case, the protocol would continue the computation with the wrong price which brings up a whole lot of problems.  List of assets and their decimals: https://docs.chain.link/docs/ethereum-addresses/#Ethereum%20Mainnet  ## Proof of Concept The received price is standardized to a `FixedPointInt` using the decimals value: https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L128  The contract uses a constant value `8` for that.  ## Tools Used none  ## Recommended Mitigation Steps Use `aggregator.decimals()` to get the correct number of decimals for the current asset. Use that for the computation  "}, {"title": "Usage of deprecated Chainlink functions", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L120 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L81 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L84   # Vulnerability details  ## Impact The Chainlink functions `latestAnswer()` and `getAnswer()` are deprecated. Instead, use the [`latestRoundData()`](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata) and [`getRoundData()`](https://docs.chain.link/docs/price-feeds-api-reference/#getrounddata) functions.  ## Proof of Concept https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L120  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L81  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L84  Go to https://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419#code and search for `latestAnswer()` or `getAnswer()`. You'll find the deprecation notice.  ## Tools Used none  ## Recommended Mitigation Steps Switch to `latestRoundData()` as described [here](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata)  "}, {"title": "COLLATERAL_MINTER_ROLE can be granted by the deployer of QuantConfig and mint arbitrary amount of tokens", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L101-L117   # Vulnerability details  ## Impact ```     function mintCollateralToken(         address recipient,         uint256 collateralTokenId,         uint256 amount     ) external override {         require(             quantConfig.hasRole(                 quantConfig.quantRoles(\"COLLATERAL_MINTER_ROLE\"),                 msg.sender             ),             \"CollateralToken: Only a collateral minter can mint CollateralTokens\"         );          emit CollateralTokenMinted(recipient, collateralTokenId, amount);          _mint(recipient, collateralTokenId, amount, \"\");     } ```  Using the mintCollateralToken() function of CollateralToken, an address with COLLATERAL_MINTER_ROLE can mint an arbitrary amount of tokens.  If the private key of the deployer or an address with the COLLATERAL_MINTER_ROLE is compromised, the attacker will be able to mint an unlimited amount of collateral tokens.  We believe this is unnecessary and poses a serious centralization risk.  ## Proof of Concept https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L101-L117 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L138-L160 ## Tools Used None  ## Recommended Mitigation Steps Consider removing the COLLATERAL_MINTER_ROLE, make the CollateralToken only mintable by the owner, and make the Controller contract to be the owner and therefore the only minter.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/8", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "1. `collateralTokenId` is used as `deadline` and it could be confused, it's better to rename it or add a specific comment about that. - [Actions.sol#L110](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/libraries/Actions.sol#L110) - [Actions.sol#L135](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/libraries/Actions.sol#L135)  2. It's possible to call he method [addAsset](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/AssetsRegistry.sol#L60) multiple times with the same `_underlying`, if you call `addAsset` with empty `symbol` it will bypass the [validAsset](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/AssetsRegistry.sol#L37) modifier, and it will be possible to call again the `addAsset` with different values. It will produce a mismatch with the reality and `getAssetsLength` This could cause a loss of funds if it is not verified before that this `symbol` is other than empty. It is mandatory to add a require to verify that the `symbol` is not empty. It's also recommended to add a require in [_assetSymbol](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L24) to ensure non-existence tokens are returned.  3. It's possible to call he method [createCollateralToken](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L61) multiple times with the same `_qTokenAddress`, if you call `createCollateralToken` with empty `_qTokenAddress` it will bypass the [require(idToInfo[id].qTokenAddress == address(0))](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L81), and it will be possible to call again the `createCollateralToken` with different values. It will produce a mismatch with the reality and `collateralTokenIds` It is mandatory to add a require to verify that the `_qTokenAddress` is not empty.  4. It's possible to approve with [metaSetApprovalForAll](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L218-L219) an empty address for any operator, `ecrecover` is not checked to return `address(0)`, so using `owner=address(0)` it is possible to approve or reject empty owners for any operator. It's recommended to use ECDSA from open-zeppelin.  5. When calling [_getMonth](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L255) with a value greater than 12 \"December\" is returned, it's best to make sure the value is as expected.  6. Use `uint8` for `decimals` in [QTokenStringUtils.sol#L142](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L142)  7. Use a buggy solidity version with immutables. The contract use immutable, and this solidity version defined in the pragma has some issues with them, as you can see [here](https://github.com/ethereum/solidity/blob/develop/Changelog.md#089-2021-09-29).  8. The [minDelay](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/TimelockController.sol#L112) must always be greater than 0, otherwise it could be proposed and executed in the same block, this could cause reputation problems for the project. Since that would make a TimeLock into a EOA owned.  9. There following methods and constructors doesn't check the inputs arguments - [QuantCalculator.sol#L56-L57](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantCalculator.sol#L56-L57) - [OracleRegistry.sol#L27](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/OracleRegistry.sol#L27) - [PriceRegistry.sol#L25-L26](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/PriceRegistry.sol#L25-L26) - [ProviderOracleManager.sol#L21](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L21) - [ChainlinkFixedTimeOracleManager.sol#L21-L22](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L21-L22)  10. It's possible to call he method [addAssetOracle](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L25) multiple times with the same `_asset`, if you call `addAssetOracle` with empty `_oracle` it will bypass the [assetOracles[_asset] == address(0)](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L34), and it will be possible to call again the `addAssetOracle` with different values. It will produce a mismatch with the reality and `assets` It is mandatory to add a require to verify that the `_oracle` is not empty. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/1", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  ChainlinkOracleManager   # Vulnerability details   use openzeppilin's safeCast in:           ChainlinkOracleManager._binarySearchStep : unsafe cast uint64(_firstRoundProxy)         ChainlinkOracleManager._setExpiryPriceInRegistryByRound : unsafe cast uint64(_roundIdAfterExpiry)         ChainlinkOracleManager._binarySearchStep : unsafe cast uint64(_lastRoundProxy)  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/254", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "## Low ### Use a 2 step procedure to update feeManager Use a 2 step procedure to update feeManager to reduce risk of burning the admin key https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeAssetDepositor.sol#L53-L57  ```solidity     function setFeeManager(address _feeManager) external {         require(msg.sender == feeManager, \"!auth\");         feeManager = _feeManager;         emit FeeManagerUpdated(_feeManager);     } ```  ## Non Critical ### Outdated Solidity Consider upgrade to latest 0.8.14"}, {"title": "Misconfiguration of Fees Incentive Might Cause Tokens To Be Stuck In `Booster` Contract", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/215", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L193 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L576   # Vulnerability details  ## Proof-of-Concept  The `Booster.setFeeInfo` function is responsible for setting the allocation of gauge fees between lockers and $VE3D stakers.  `lockFeesIncentive` and `stakerLockFeesIncentive` should add up to `10000` , which is equivalent to `100%`.  However, there is no validation check to ensure that that `_lockFeesIncentive` and `_stakerLockFeesIncentive` add up to `10000`. Thus, it entirely depends on the developer to get these two values right.  As such, it is possible to set `lockFeesIncentive + takerLockFeesIncentive` to be less than `100%`. This might happen due to human error. For instance, a typo (forget a few zero) or newly joined developer might not be aware of the fee denomination and called `setFeeInfo(40, 60)` instead of `setFeeInfo(4000, 6000)`.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L193](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L193)  ```solidity uint256 public constant FEE_DENOMINATOR = 10000;  // Set reward token and claim contract, get from Curve's registry function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {     require(msg.sender == feeManager, \"!auth\");      lockFeesIncentive = _lockFeesIncentive;     stakerLockFeesIncentive = _stakerLockFeesIncentive;     ..SNIP.. } ```  Assume that `setFeeInfo(40, 60)` is called instead of of `setFeeInfo(4000, 6000)`, only `1%` of the fee collected will be transferred to the users and the remaining `99%` of the fee collected will be stuck in the `Booster` contract.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L576](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L576)  ```solidity function earmarkFees() external returns (bool) {     //claim fee rewards     IStaker(staker).claimFees(feeDistro, feeToken);     //send fee rewards to reward contract     uint256 _balance = IERC20(feeToken).balanceOf(address(this));      uint256 _lockFeesIncentive = _balance.mul(lockFeesIncentive).div(FEE_DENOMINATOR);     uint256 _stakerLockFeesIncentive = _balance.mul(stakerLockFeesIncentive).div(         FEE_DENOMINATOR     );     if (_lockFeesIncentive > 0) {         IERC20(feeToken).safeTransfer(lockFees, _lockFeesIncentive);         IRewards(lockFees).queueNewRewards(_lockFeesIncentive);     }     if (_stakerLockFeesIncentive > 0) {         IERC20(feeToken).safeTransfer(stakerLockRewards, _stakerLockFeesIncentive);         IRewards(stakerLockRewards).queueNewRewards(feeToken, _stakerLockFeesIncentive);     }     return true; } ```  ### Can we retrieve or \"save\" the tokens stuck in `Booster` contract?  Any veAsset (e.g. CRV, ANGLE) sitting on the `Booster` contract is claimable. However, in this case, the `feeToken` is likely not a veAsset, thus the remaining gauge fee will be stuck in the `Booster` contract perpetually. For instance, in Curve, the gauge fee is paid out in 3CRV, the LP token for the TriPool. ([Source](https://resources.curve.fi/crv-token/understanding-crv#staking-trading-fees))  ## Impact  Users will lost their gauge fee if this happens.  ## Recommended Mitigation Steps  Implement validation check to ensure that `lockFeesIncentive` and `takerLockFeesIncentive` add up to 100% to eliminate any risk of misconfiguration.  ```solidity uint256 public constant FEE_DENOMINATOR = 10000;  // Set reward token and claim contract, get from Curve's registry function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {     require(msg.sender == feeManager, \"!auth\");     require(_lockFeesIncentive + _stakerLockFeesIncentive == FEE_DENOMINATOR, \"Invalid fees\");      lockFeesIncentive = _lockFeesIncentive;     stakerLockFeesIncentive = _stakerLockFeesIncentive;     ..SNIP.. } ```  "}, {"title": "Gauge Rewards Stuck In `VoterProxy` Contract When `ExtraRewardStashV3` Is Used Within Angle Deployment", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/209", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495   # Vulnerability details  > Note: This report aims to discuss the issue encountered when `ExtraRewardStashV3` is used within Angle Deployment. There is also another issue when `ExtraRewardStashV2` is used within Angle Deployment, but I will raise it in a separate report since `ExtraRewardStashV2` and `ExtraRewardStashV3` operate differently, and the proof-of-concept and mitigation are different too.  ## Proof-of-Concept  In this example, assume the following Angle's gauge setup  > Name = Angle sanDAI_EUR Gauge > > Symbol = SsanDAI_EUR > > reward_count = 2 > > reward_tokens(0) = ANGLE > > reward_tokens(1) = DAI > > Gauge Contract: [LiquidityGaugeV4.vy](https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy) > > Stash Contract: [ExtraRewardStashV3](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol)  To collect the gauge rewards, users would trigger the `Booster._earmarkRewards` function to claim veAsset and extra rewards from a gauge.   Per the code logic, the function will attempt to execute the following two key operations:  1) First Operation -  Claim the veAsset by calling `VoterProxy.claimVeAsset`. Call Flow as follow: `VoterProxy.claimVeAsset() > IGauge(_gauge).claim_rewards()`. 2) Second Operation - Claim extra rewards by calling `ExtraRewardStashV3.claimRewards`. Call flow as follows: `ExtraRewardStashV3.claimRewards > Booster.claimRewards > VoterProxy.claimRewards > IGauge(_gauge).claim_rewards()` .   Note that`IGauge(_gauge).claim_rewards()` will claim all available reward tokens from the Angle's gauge.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495)  ```solidity //claim veAsset and extra rewards and disperse to reward contracts function _earmarkRewards(uint256 _pid) internal {     PoolInfo storage pool = poolInfo[_pid];     require(pool.shutdown == false, \"pool is closed\");      address gauge = pool.gauge;      //claim veAsset     IStaker(staker).claimVeAsset(gauge);      //check if there are extra rewards     address stash = pool.stash;     if (stash != address(0)) {         //claim extra rewards         IStash(stash).claimRewards();         //process extra rewards         IStash(stash).processStash();     }  ..SNIP.. } ```  ### First Operation -  Claim the veAsset  Since this is a Angle Deployment, when the `VoterProxy.claimVeAsset` is triggered,  it will go through the if-else logic (`escrowModle == IVoteEscrow.EscrowModle.ANGLE`) and execute ` IGauge(_gauge).claim_rewards()`, and all rewards tokens will be sent to `VoterProxy` contract. Assume that `100 ANGLE` and `100 DAI` were received.  Note that in this example, we have two reward tokens (ANGLE and DAI). Additionally, gauge redirection was not configured on the gauge at this point, thus the gauge rewards will be sent to the caller, which is the `VoterProxy` contract.  Subsequently, the code `IERC20(veAsset).safeTransfer(operator, _balance);` will be executed, and veAsset (`100 ANGLE`) reward tokens will be transferred to the `Booster` contract for distribution. However, the `100 DAI` reward tokens will remain stuck in the `VoterProxy` contract. As such, users will not be able to get any reward tokens (e.g. DAI, WETH) except veAsset (ANGLE) tokens from the gauges.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VoterProxy.sol#L224](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VoterProxy.sol#L224)  ```solidity function claimVeAsset(address _gauge) external returns (uint256) {     require(msg.sender == operator, \"!auth\");      uint256 _balance = 0;      if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {         try IGauge(_gauge).getReward() {} catch {             return _balance;         }     } else if (         escrowModle == IVoteEscrow.EscrowModle.CURVE ||         escrowModle == IVoteEscrow.EscrowModle.RIBBON     ) {         try ITokenMinter(minter).mint(_gauge) {} catch {             return _balance;         }     } else if (escrowModle == IVoteEscrow.EscrowModle.IDLE) {         try ITokenMinter(minter).distribute(_gauge) {} catch {             return _balance;         }     } else if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {         try IGauge(_gauge).claim_rewards() {} catch {             return _balance;         }     }      _balance = IERC20(veAsset).balanceOf(address(this));     IERC20(veAsset).safeTransfer(operator, _balance);      return _balance; } ```  Following is Angle's Gauge Contract for reference:  [https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L344](https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L344)  (Mainnet Deployed Address: https://etherscan.io/address/0x8E2c0CbDa6bA7B65dbcA333798A3949B07638026)   > Note: Angle Protocol is observed to use LiquidityGaugeV4 contract for all of their gauges. Thus, ExtraRewardStashV3 is utilised during pool creation.  ```python @external @nonreentrant('lock') def claim_rewards(_addr: address = msg.sender, _receiver: address = ZERO_ADDRESS):     \"\"\"     @notice Claim available reward tokens for `_addr`     @param _addr Address to claim for     @param _receiver Address to transfer rewards to - if set to                      ZERO_ADDRESS, uses the default reward receiver                      for the caller     \"\"\"     if _receiver != ZERO_ADDRESS:         assert _addr == msg.sender  # dev: cannot redirect when claiming for another user     self._checkpoint_rewards(_addr, self.totalSupply, True, _receiver) ```  ### Second Operation - Claim extra rewards  After the `IStaker(staker).claimVeAsset(gauge);` code within the `Booster._earmarkRewards` function is executed, `IStash(stash).claimRewards();`  and `IStash(stash).processStash();` functions will be executed next. `stash` == `ExtraRewardStashV3`.  The `ExtraRewardStashV3.claimRewards` will call the `Booster.setGaugeRedirect` first so that all the gauge rewards will be redirected to `ExtraRewardStashV3` stash contract. Subsequently, `ExtraRewardStashV3.claimRewards` will trigger `Booster.claimRewards` to claim the gauge rewards from the Angle's gauge.   Note that this is the second time the contract attempts to claim gauge rewards from the gauge. Thus, no gauge rewards will be received since we already claimed them earlier. Next, `ExtraRewardStashV3` will attempt to process all the tokens stored in its contract and send them to the respective reward contracts for distribution to the users. However, the contract does not have any tokens stored in it because the earlier attempt to claim gauge rewards return nothing.  As we can see, the DAI reward tokens are still stuck in the `VoterProxy` contract at this point.  [https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L332](https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L332)  ```python def set_rewards_receiver(_receiver: address):     \"\"\"     @notice Set the default reward receiver for the caller.     @dev When set to ZERO_ADDRESS, rewards are sent to the caller     @param _receiver Receiver address for any rewards claimed via `claim_rewards`     \"\"\"     self.rewards_receiver[msg.sender] = _receiver ```  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol#L61](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol#L61)  ```solidity //try claiming if there are reward tokens registered function claimRewards() external returns (bool) {     require(msg.sender == operator, \"!authorized\");      //this is updateable from v2 gauges now so must check each time.     checkForNewRewardTokens();      //make sure we're redirected     if (!hasRedirected) {         IDeposit(operator).setGaugeRedirect(pid);         hasRedirected = true;     }      uint256 length = tokenCount;     if (length > 0) {         //claim rewards on gauge for staker         //using reward_receiver so all rewards will be moved to this stash         IDeposit(operator).claimRewards(pid, gauge);     }     return true; } ```  ## Impact  User's gauge rewards are frozen/stuck in `VoterProxy` contract. Additionally, there is no method to sweep/collect the reward tokens stuck in the `VoterProxy` contract.  ## Recommended Mitigation Steps  > Note: I do not see `Booster.setGaugeRedirect` being called in the deployment and testing scripts. Thus, it is fair to assume that the team is not aware of the need to trigger `Booster.setGaugeRedirect` during deployment. If the gauge redirection has been set to the stash contract `ExtraRewardStashV3` right from the start before anyone triggered the `earmarkRewards` function, this issue should not occur.  Consider triggering `Booster.setGaugeRedirect` during the deployment to set gauge redirection to stash contract (`ExtraRewardStashV3`) so that the Angle's gauge rewards will not be redirected to `VoterProxy` contract and get stuck there.  Alternatively, update the `Booster._earmarkRewards` to as follows:  ```solidity //claim veAsset and extra rewards and disperse to reward contracts function _earmarkRewards(uint256 _pid) internal {  PoolInfo storage pool = poolInfo[_pid];  require(pool.shutdown == false, \"pool is closed\");   address stash = pool.stash;  if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {   //claims gauges rewards   IStash(stash).claimRewards();   //process gauges rewards   IStash(stash).processStash();  } else {   //claim veAsset         IStaker(staker).claimVeAsset(gauge);          //check if there are extra rewards         address stash = pool.stash;         if (stash != address(0)) {             //claim extra rewards             IStash(stash).claimRewards();             //process extra rewards             IStash(stash).processStash();         }  }   //veAsset balance     uint256 veAssetBal = IERC20(veAsset).balanceOf(address(this));  ..SNIP.. } ```  There is no need to specifically call `VoterProxy.claimVeAsset` to fetch ANGLE for Angle Protocol because calling `IStash(stash).claimRewards()` will fetch both ANGLE and other reward tokens from the gauge anyway. When the stash contract receives the ANGLE tokens, it will automatically transfer all of them back to `Booster` contract when `IStash(stash).processStash()` is executed. The `IStash(stash).claimRewards()` function also performs a sanity check to ensure that the gauge redirection is pointing to itself before claiming the gauge rewards, and automatically configure them if it is not, so it will not cause the reward tokens to get stuck in `VoterProxy` contract.  - Curve uses an older version of LiquidityGauge contract. Thus, two calls are needed (`Minter.mint` to claim CRV and `LiquidityGauge.claim_rewards` to claim other rewards).   - Angle uses newer version of LiquidityGauge (V4) contract that just need one function call (`LiquidityGauge.claim_rewards` ) to fetch both veAsset and other rewards. - IDLE uses LiquidityGauge (V3) contract. veAsset (IDLE) is minted by calling `DistributorProxy.distribute` and gauge rewards are claimed by calling `LiquidityGauge.claim_rewards`.  Due to the discrepancies between different protocols in the reward claiming process, additional care must be taken to ensure that the flow of veAsset and gauge rewards are transferred to the appropriate contracts during integration. Otherwise, rewards will be stuck.  Lastly, I only see test cases written for claiming veAsset from the gauge. For completeness, it is recommended to also write test cases for claiming extra rewards from the gauge apart from veAsset.  "}, {"title": "Unable To Get Rewards If Admin Withdraws $VE3D tokens From `VeTokenMinter` Contract", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/202", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48   # Vulnerability details  ## Vulernability Details  It was observed that users will not be able to get their rewards from the reward contract at certain point of time if admin withdraws $VE3D token from the `VeTokenMinter` contract.  ## Proof-of-Concept  Based on the deployment script, it was understood that at the start of the project deployment, 30 million $VE3D tokens will be pre-minted for the `VeTokenMinter` contract. Thus, the `veToken.balanceOf(VeTokenMinter.address)` will be 30 million $VE3D tokens after the deployment.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/2_deploy_basic_contracts.js#L18](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/2_deploy_basic_contracts.js#L18)  ```javascript // vetoken minter await deployer.deploy(VeTokenMinter, veTokenAddress); let vetokenMinter = await VeTokenMinter.deployed(); addContract(\"system\", \"vetokenMinter\", vetokenMinter.address); global.created = true; //mint vetoke to minter contract const vetoken = await VeToken.at(veTokenAddress); await vetoken.mint(vetokenMinter.address, web3.utils.toWei(\"30000000\"), { from: vetokenOperator }); addContract(\"system\", \"vetoken\", veTokenAddress); ```  In the `VeTokenMinter ` contract, there is a function called `VeTokenMinter.withdraw` that allows the admin to withdraw $VE3D tokens from the contract. Noted that this withdraw function only perform the transfer, but did not update any of the state variables (e.g. totalSupply, maxSupply) in the contract.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L77](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L77)  ```solidity function withdraw(address _destination, uint256 _amount) external onlyOwner {     veToken.safeTransfer(_destination, _amount);      emit Withdraw(_destination, _amount); } ```  Assuming that an admin withdrawed 29 million $VE3D tokens from the `VoteProxy` with the appropriate approval from the DAO or community for some valid purposes. The `veToken.balanceOf(VeTokenMinter.address)` will be 1 million $VE3D tokens after the withdrawal.  At this point, notice that `veToken.balanceOf(VeTokenMinter.address)` is 1 million, while the `VeTokenMinter.maxSupply` constant is 30 million. Therefore, there exists a discrepency between the actual amount of $VE3D tokens (1 million) stored in the contact versus the max supply (30 million).  This discrepency will cause an issue in the `VeTokenMinter.mint` function because the calculation of the amount of $VE3D tokens to be transferred is based on the fact that 30 million $VE3D tokens is always sitting in the `VeTokenMinter` contract, and thus there is always sufficient $VE3D tokens available in the `VeTokenMinter` contract to send to its users.  The `uint256 amtTillMax = maxSupply.sub(supply);` code shows that the calculation is based on `maxSupply` constant, which is 30 million.  Assume that `mint(0x001, 10 million)` is called, and the value of the state variables when stepping through this function are as follows:  - `maxSupply` constant = 30 million - `veToken.balanceOf(VeTokenMinter.address)` = 1 million - `supply` & `totalSupply` = 20 million - `totalCliffs` = 1000 - `reductionPerCliff ` = 30,000 (maxSupply / totalCliffs) - `cliff` = 666 (supply/reductionPerCliff) - `reduction` = 1000 - 666 = 334 - `_amount` = 10 million * (334/1000) = 3.340 million - `amtTillMax` = 10 million (maxSupply - supply) (Over here the contract assume that it still has 10 million VE3D tokens more to reach the max supply) - `(_amount > amtTillMax)` = `False` (since \"3.340 million > 10 million\" = false ) - `veToken.safeTransfer(0x001, 3.340 million)` (This will revert. Insufficent balance)  The `veToken.safeTransfer(0x001, 3.340 million` will fail and revert because `VeTokenMinter` contract does not hold sufficent amount of $VE3D tokens to transfer out.`veToken.balanceOf(VeTokenMinter.address)` = 1 million, while the contract was attempting to send out 3.340 million.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48)  ```solidity function mint(address _to, uint256 _amount) external {     require(operators.contains(_msgSender()), \"not an operator\");      uint256 supply = totalSupply;      //use current supply to gauge cliff     //this will cause a bit of overflow into the next cliff range     //but should be within reasonable levels.     //requires a max supply check though     uint256 cliff = supply.div(reductionPerCliff);     //mint if below total cliffs     if (cliff < totalCliffs) {         //for reduction% take inverse of current cliff         uint256 reduction = totalCliffs.sub(cliff);         //reduce         _amount = _amount.mul(reduction).div(totalCliffs);          //supply cap check         uint256 amtTillMax = maxSupply.sub(supply);         if (_amount > amtTillMax) {             _amount = amtTillMax;         }          //mint         veToken.safeTransfer(_to, _amount);         totalSupply += _amount;     } } ```  The failure/revert of `VeTokenMinter.mint` function will cascade up to `Booster.rewardClaimed`, and futher cascade up to `BaseRewardPool.getReward`. Thus, `BaseRewardPool.getReward` will stop working. As a result, the users will not be able to get any rewards from the reward contracts.   This issue will affect all projects (Curve, Pickle, Ribbon, Idle, Angle, Balancer) because `VeTokenMinter ` contract is deployed once, and referenced by all the projects. Thus, the impact could be quite widespread if this occurs, and many users would be affected.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598)  ```solidity function rewardClaimed(     uint256 _pid,     address _address,     uint256 _amount ) external returns (bool) {     address rewardContract = poolInfo[_pid].veAssetRewards;     require(msg.sender == rewardContract || msg.sender == lockRewards, \"!auth\");     ITokenMinter veTokenMinter = ITokenMinter(minter);     //calc the amount of veAssetEarned     uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div(         veTokenMinter.totalWeight()     );     //mint reward tokens     ITokenMinter(minter).mint(_address, _veAssetEarned);      return true; } ```  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/BaseRewardPool.sol#L267](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/BaseRewardPool.sol#L267)  ```solidity function getReward(address _account, bool _claimExtras)     public     updateReward(_account)     returns (bool) {     uint256 reward = earned(_account);     if (reward > 0) {         rewards[_account] = 0;         rewardToken.safeTransfer(_account, reward);         IDeposit(operator).rewardClaimed(pid, _account, reward);         emit RewardPaid(_account, reward);     }      //also get rewards from linked rewards     if (_claimExtras) {         for (uint256 i = 0; i < extraRewards.length; i++) {             IRewards(extraRewards[i]).getReward(_account);         }     }     return true; } ```  ## Recommended Mitigation Steps  Remove the `VeTokenMinter.withdraw` function if possible. Otherwise, update the internal accounting of `VeTokenMinter` contract during withdrawal so that the actual balance of the $VE3D tokens is taken into consideration within the `VeTokenMinter.mint`, and the contract will not attempt to transfer more tokens than what it has.  On a side note, [Convex's Minter contract](https://github.com/convex-eth/platform/blob/main/contracts/contracts/Cvx.sol), will mint the `CRX` gov tokens to the users on the fly. See https://github.com/convex-eth/platform/blob/1f11027d429e454dacc4c959502687eaeffdb74a/contracts/contracts/Cvx.sol#L76. Thus, there will not be a case where there is not sufficient `CRV` tokens in the contract to send to it users.  However, in VeToken Protocol, it attempts to transfer the portion of pre-minted $VE3D tokens (30 millions) to the users. See https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L72. Thus, it is possible that there is not enough $VE3D tokens to send to its users if the admin withdraw the pre-minted $VE3D tokens.  "}, {"title": "Missing sane bounds on asset weights", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/192", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L41-L46   # Vulnerability details  ## Impact The admin may fat-finger a change, or be malicious, and have the weights be extreme - ranging from zero to `type(uint256).max`, which would cause the booster to pay out unexpected amounts  ## Proof of Concept No bounds checks in the update function: ```solidity File: contracts/VeTokenMinter.sol   #1  41       function updateveAssetWeight(address veAssetOperator, uint256 newWeight) external onlyOwner { 42           require(operators.contains(veAssetOperator), \"not an veAsset operator\"); 43           totalWeight -= veAssetWeights[veAssetOperator]; 44           veAssetWeights[veAssetOperator] = newWeight; 45           totalWeight += newWeight; 46       } ``` https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L41-L46  The value is used by the reward contract to determine how much to mint: ```solidity File: contracts/Booster.sol   #2  598       function rewardClaimed( 599           uint256 _pid, 600           address _address, 601           uint256 _amount 602       ) external returns (bool) { 603           address rewardContract = poolInfo[_pid].veAssetRewards; 604           require(msg.sender == rewardContract || msg.sender == lockRewards, \"!auth\"); 605           ITokenMinter veTokenMinter = ITokenMinter(minter); 606           //calc the amount of veAssetEarned 607           uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div( 608               veTokenMinter.totalWeight() 609           ); 610           //mint reward tokens 611           ITokenMinter(minter).mint(_address, _veAssetEarned); ``` https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598-L611  Wrong values will lead to excessive inflation/deflation  ## Tools Used Code inspection  ## Recommended Mitigation Steps Have sane upper/lower limits on the values   "}, {"title": "Consistently check account balance before and after transfers for Fee-On-Transfer discrepancies", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/190", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L356 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L337   # Vulnerability details  As arbitrary ERC20 tokens can be passed, the amount here should be calculated every time to take into consideration a possible fee-on-transfer or deflation. Also, it's a good practice for the future of the solution.  Affected code:  - File: Booster.sol  ```solidity 345:     function deposit( 346:         uint256 _pid, 347:         uint256 _amount, 348:         bool _stake 349:     ) public returns (bool) { ... 356:         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount); //@audit medium: not compatible with Fee On Transfer Tokens ... 372:             ITokenMinter(token).mint(address(this), _amount); ... 374:             IERC20(token).safeApprove(rewardContract, _amount); 375:             IRewards(rewardContract).stakeFor(msg.sender, _amount); ... 378:             ITokenMinter(token).mint(msg.sender, _amount); ... 381:         emit Deposited(msg.sender, _pid, _amount); ... ```  - File: VE3DRewardPool.sol  ```solidity 336:     function donate(address _rewardToken, uint256 _amount) external { 337:         IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount); //@audit medium: not compatible with Fee On Transfer Tokens 338:         rewardTokenInfo[_rewardToken].queuedRewards += _amount; 339:     } ```  ## Recommended Mitigation Steps  Use the balance before and after the transfer to calculate the received amount instead of assuming that it would be equal to the amount passed as a parameter.  "}, {"title": "`VE3DRewardPool` claim in loop depend on pausable token", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/166", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L296-L299 https://github.com/code-423n4/2022-05-vetoken/blob/1be2f03670e407908f175c08cf8cc0ce96c55baf/contracts/VeAssetDepositor.sol#L134-L152   # Vulnerability details  Project veToken is supposed to be a generalized version of Convex for non-Curve token. There is only one contract for all rewards token in the platform.  All ve3Token rewards are bundled together inside `ve3DLocker` and `ve3DRewardPool` in a loop. Instead of having its own unique contract like `VeAssetDepositer` or `VoterProxy` for each token.  ## Impact  If one token has pausable transfer, user cannot claim rewards or withdraw if they have multiple rewards include that pause token.  Right now the project intends to support only 6 tokens, including Ribbon token which has [pausable transfer](https://etherscan.io/address/0x6123b0049f904d730db3c36a31167d9d4121fa6b#code#L810) controlled by Ribbon DAO.  Normally, this would not be an issue in Convex where only a few pools would be affected by single coin. Since, veAsset are bundled together into single reward pool, it becomes a major problem.  ## Proof of concept  - Token like Ribbon pause token transfer by DAO due to an unfortunate event. - `VE3DRewardPool` try call `getReward()`, `VeAssetDepositor` [try deposit token from earned rewards](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L296-L299) does not work anymore because `IERC20.transfer` [is blocked](https://github.com/code-423n4/2022-05-vetoken/blob/1be2f03670e407908f175c08cf8cc0ce96c55baf/contracts/VeAssetDepositor.sol#L134-L152). This effectively reverts current function if user have this token reward > 0.  ## Recommended mitigation step  It would be a better practice if we had a second `getReward()` function that accepts an array of token that we would like to interact with. It saves gas and only requires some extra work on frontend website. Instead of current implementation, withdraw all token bundles together.   "}, {"title": "`VE3DLocker.sol` Wrong implementation of inversely traverse for loops always reverts", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/150", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L305-L329 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L349-L373 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L376-L396 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L399-L415   # Vulnerability details  ```solidity function totalSupplyAtEpoch(uint256 _epoch) external view returns (uint256 supply) {     uint256 epochStart = uint256(epochs[_epoch].date).div(rewardsDuration).mul(         rewardsDuration     );     uint256 cutoffEpoch = epochStart.sub(lockDuration);      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) <= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; } ````  In `VE3DLocker.sol`, there are multiple instances in which an inversely traverse for loop is used \"to make more current queries more gas efficient\".  For example:  - `totalSupplyAtEpoch()` - `balanceAtEpochOf()` - `pendingLockAtEpochOf()` - `totalSupply()`  The implementation of the inversely traverse for loop is inherited from Convex's original version: https://github.com/convex-eth/platform/blob/main/contracts/contracts/CvxLockerV2.sol#L333-L334  However, Convex's locker contract is using Solidity 0.6.12, in which the arithmetic operations will overflow/underflow without revert.  As the solidity version used in the current implementation of `VE3DLocker.sol` is `0.8.7`, and there are some breaking changes in Solidity v0.8.0, including:  > Arithmetic operations revert on underflow and overflow.   Ref: https://docs.soliditylang.org/en/v0.8.7/080-breaking-changes.html#silent-changes-of-the-semantics  Which makes the current implementation of inversely traverse for loops always reverts.  More specifically:  1. `for (uint i = locks.length - 1; i + 1 != 0; i--) {` will revert when `locks.length == 0` at `locks.length - 1` due to underflow; 2. `for (uint256 i = _epoch; i + 1 != 0; i--) {` will loop until `i == 0` and reverts at `i--` due to underflow.  As a result, all these functions will be malfunctioning and all the internal and external usage of these function will always revert.  ### Recommendation  Change `VE3DLocker.sol#L315` to:  ```solidity for (uint256 i = locks.length; i > 0; i--) {     uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);     //lock epoch must be less or equal to the epoch we're basing from.     if (lockEpoch <= epochTime) {         if (lockEpoch > cutoffEpoch) {             amount = amount.add(locks[i - 1].amount); ```  Change `VE3DLocker.sol#L360` to:  ```solidity for (uint256 i = locks.length; i > 0; i--) {     uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);      //return the next epoch balance     if (lockEpoch == nextEpoch) {         return locks[i - 1].amount;     } else if (lockEpoch < nextEpoch) {         //no need to check anymore         break;     } ```  Change `VE3DLocker.sol#L387` to:  ```solidity for (uint256 i = epochindex; i > 0; i--) {     Epoch storage e = epochs[i - 1]; ```  Change `VE3DLocker.sol#L406` to:  ```solidity for (uint256 i = _epoch + 1; i > 0; i--) {     Epoch storage e = epochs[i - 1];     if (uint256(e.date) <= cutoffEpoch) {         break;     }     supply = supply.add(e.supply); } ```  "}, {"title": "Owner should be allowed to change feeManager", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/99", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/Booster.sol#L129   # Vulnerability details  ## Impact Once Fee Manager has been set initially by owner, then owner has no power to change it. Owner should be allowed to change fees manager in case if he feels current fee manager is behaving maliciously  ## Proof of Concept 1. Observe the setFeeManager function and see that only feeManager is allowed to change it once set initially  ``` function setFeeManager(address _feeM) external {         require(msg.sender == feeManager, \"!auth\");         feeManager = _feeM;         emit FeeManagerUpdated(_feeM);     } ```  ## Recommended Mitigation Steps Change the setFeeManager function like below. Same can be done with other important functionality involving setArbitrator and setVoteDelegate  ``` require(msg.sender == owner, \"!auth\"); ```  "}, {"title": "No check for existing extraRewards during push", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/89", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L138 ttps://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DLocker.sol#L156   # Vulnerability details  ## Impact Similar to a reported I submitted for BaseRewardPool.sol (https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/BaseRewardPool.sol#L126)  When adding `extraRewards` to the extra reward pool in https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L138 , there's no check for already existing address. Assume a particular address takes up 2 slots out of 3, and a user withdraws staked extra rewards, the user will receive double the amount requested in https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L257-L258  ## Proof of Concept 1.  Assume `rewardManager` had mistakenly added the same address twice in `addExtraReward()` 2. A user calls `stake()` , linked rewards is staked twice to the same address (unexpected behaviour I guess but not severe issue) 3. Now, user calls `withdraw()` to withdraw linked rewards (this is already 2x in step 2) 4. User will receive double the linked rewards due to the iteration in `https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L257-L258`  ## Tools Used Manual review  ## Recommended Mitigation Steps Guess a check for an already existing extraRewards can be added before Line 138  ##Similar issue **https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DLocker.sol#L156 - not so sure of the severity for this. **https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/BaseRewardPool.sol#L126  - reported in a seperate report    "}, {"title": "Incorrect deployment parameters", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/52", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/25_deploy_angle_pools.js#L68 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/25_deploy_angle_pools.js#L80   # Vulnerability details  ## Impact The address of G-Uni tokens in the deployment scripts are not up to date.   ## Proof of concept For example for agEUR/USDC it is 0xedecb43233549c51cc3268b5de840239787ad56c and not 0x2bD9F7974Bc0E4Cb19B8813F8Be6034F3E772add  ## Mitigation steps For safety why not fetching directly the LP token from the staking contract ?\u2028  "}, {"title": "Contracts should be robust to upgrades of underlying gauges and eventually changes of the underlying tokens", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VoterProxy.sol   # Vulnerability details  ## Impact  For some veAsset project (for example Angle\u2019s [gauges](https://github.com/AngleProtocol/angle-core/blob/main/contracts/staking/LiquidityGaugeV4UpgradedToken.vy), gauge contracts are upgradable, so interfaces and underlying LP tokens are subject to change, blocking and freezing the system. Note that this is not hypothetic as it happened a few weeks ago: see this [snapshot vote]( https://snapshot.org/#/anglegovernance.eth/proposal/0x1adb0a958220b3dcb54d2cb426ca19110486a598a41a75b3b37c51bfbd299513). Therefore, the system should be robust to a change in the pair gauge / token.   Note that is doable in the current setup for the veToken team to rescue the funds in such case, hence it is only a medium issue. You\u2019d have to do as follow: a painful shutdown of the `Booster` (which would lead to an horrible situation where you\u2019d have to preserve backwards compatibility for LPs to save their funds in the new Booster), an operator change in `VoterProxy` to be able to call `execute`.  ## Mitigation steps To deal with upgradeable contracts, either the `VoterProxy` needs to be upgradable to deal with any situation that may arise, either you need to add upgradeable \u201cintermediate\u201d contracts between the `staker` and the gauge that could be changed to preserve the logic.  "}, {"title": "ExtraRewardStashV2's stashRewards can become unavailable", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/36", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L193-L203   # Vulnerability details  There is no check for the reward token amount to be transferred out in stashRewards(). As reward token list is external (controlled with `IGauge(gauge).reward_tokens`), and an arbitrary token can end up there, in the case when such token doesn't allow for zero amount transfers, the stashRewards() managed extra rewards retrieval can become unavailable.  I.e. stashRewards() can be blocked for even an extended period of time, so all other extra rewards gathering will not be possible. This cannot be controlled by the system as pool reward token list is external.  Setting the severity to medium as reward gathering is a base functionality of the system and its availability is affected.  ## Proof of Concept  stashRewards() attempts to send the `amount` to rewardArbitrator() without checking:  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L193-L203  ```solidity     if (activeCount > 1) {         //take difference of before/after(only send new tokens)         uint256 amount = IERC20(token).balanceOf(address(this));         amount = amount.sub(before);          //send to arbitrator         address arb = IDeposit(operator).rewardArbitrator();         if (arb != address(0)) {             IERC20(token).safeTransfer(arb, amount);         }     } ```  If `IStaker(staker).withdraw()` produced no new tokens for any reason, the `amount = amount.sub(before)` above can be zero:  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L188-L189  ```solidity     uint256 before = IERC20(token).balanceOf(address(this));     IStaker(staker).withdraw(token); ```  As reward `token` can be arbitrary, it can also be reverting on an attempt to transfer zero amounts:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  If this be the case then the whole stashRewards() call will be failing until `IStaker(staker).withdraw()` manage to withdraw some `tokens` or such `token` be removed from gauge's reward token list. Both events aren\u2019t directly controllable by the system.  ## Recommended Mitigation Steps  Consider running the transfer only when amount is positive:  ```solidity -   if (activeCount > 1) { +   if (amount > 0 && activeCount > 1) {         //take difference of before/after(only send new tokens)         uint256 amount = IERC20(token).balanceOf(address(this));         amount = amount.sub(before);          //send to arbitrator         address arb = IDeposit(operator).rewardArbitrator();         if (arb != address(0)) {             IERC20(token).safeTransfer(arb, amount);         }     } ```  "}, {"title": "Highly Unsafe Pattern of Minting the Additional Reward Tokens at `VeAssetDepositor.sol`", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/29", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeAssetDepositor.sol#L117-L120   # Vulnerability details  ## Impact   In [VeAssetDepositor.sol#L117-L120](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeAssetDepositor.sol#L117-L120), the condition to mint the additional rewards tokens to the user is `if (incentiveVeAsset > 0)`. However, the `incentiveVeAsset` variable is only updated to zero after an external call to the `ITokenMinter` contract. This lacks the Checks Effects and Interactions safety pattern. In the event that the **wrong** minter contract has been initialised, an attacker could potentially drain all the additional reward tokens via a reentrancy attack.  ## Proof of Concept  - <https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html>  ## Recommended Mitigation Steps  Be sure to follow the [Checks Effects and Interactions safety pattern](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) and update the `incentiveVeAsset = 0` before minting the token for the user. Alternatively, the developers can also add the `nonReentrant()` [modifier](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard) from OpenZeppelin to prevent any sort of potential reentrancy attacks.  "}, {"title": "Duplicate LP token could lead to incorrect deposits", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/Booster.sol#L256   # Vulnerability details  ## Impact It was observed that addPool function is not checking for duplicate lpToken which allows 2 or more pools to have exact same lpToken. This can cause issue with deposits.  In case of duplicate lpToken, the first pool calling depositAll will take away all lpToken and deposit them under there own pid. This leaves no balance for 2nd pool  ## Proof of Concept  1. PoolManager call addPool function and uses lpToken as A 2. PoolManager again call addPool function and mistakenly provides lpToken as A 3. Now 2 pools will be created with lpToken as A 4. depositAll function is called passing first pool.  5. This takes all balance of lpToken A and depsoit it under first pool pid 6. This mean no balance is left for second pool now  ## Recommended Mitigation Steps Add a global variable keeping track of all lpToken added for pool. In case of duplicate lpToken addPool function should fail.  "}, {"title": "[WP-M10] Wrong formula of `getSharesForAmount()` can potentially cause fund loss when being used to calculate the `shares` to be used in `withdraw()`", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/81", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L306-L329   # Vulnerability details  In `Collateral`, the getter functions `getAmountForShares()` and `getSharesForAmount()` is using `totalAssets()` instead of `_strategyController.totalValue()`, making the results can be different than the actual shares amount needed to `withdraw()` a certain amount of `_baseToken` and the amount of shares expected to get by `deposit()` a certain amount.  Specifically, `totalAssets()` includes the extra amount of `_baseToken.balanceOf(Collateral)`.  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L306-L329  ```solidity function getAmountForShares(uint256 _shares)     external     view     override     returns (uint256) {     if (totalSupply() == 0) {         return _shares;     }     return (_shares * totalAssets()) / totalSupply(); }  function getSharesForAmount(uint256 _amount)     external     view     override     returns (uint256) {     uint256 _totalAssets = totalAssets();     return         (_totalAssets > 0)             ? ((_amount * totalSupply()) / _totalAssets)             : 0; } ```  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L339-L343  ```solidity function totalAssets() public view override returns (uint256) {     return         _baseToken.balanceOf(address(this)) +         _strategyController.totalValue(); } ```  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L137-L148  ```solidity function withdraw(uint256 _amount)     external     override     nonReentrant     returns (uint256) {     require(_withdrawalsAllowed, \"Withdrawals not allowed\");     if (_delayedWithdrawalExpiry != 0) {         _processDelayedWithdrawal(msg.sender, _amount);     }     uint256 _owed = (_strategyController.totalValue() * _amount) /         totalSupply();     ... ```  ### PoC  Given:  - `_baseToken.balanceOf(Collateral)` == 90 - `_strategyController.totalValue()` == 110 - totalSupply of shares = 100  `totalAssets()` returns: 200  `getSharesForAmount(100)` returns: 50, while `withdraw(50)` will actual only get: 55.  When `Collateral` is used by another contract that manages many users' funds, and if it's using `getSharesForAmount()` to calculate the amount of shares needed for a certain amount of underlying tokens to be withdrawn.  This issue can potentially cause fund loss to the user of that contract because it will actually send a lesser amount of `_baseToken` than expected.  ### Recommendation  Consider changing `Collateral.totalValue()` to:   ```solidity function totalAssets() public view override returns (uint256) {     return         _strategyController.totalValue(); } ```  "}, {"title": "SingleStrategyController doesn't verify that new strategy uses the same base token", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72 https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/interfaces/IStrategy.sol#L52   # Vulnerability details  ## Impact When migrating from one strategy to another, the controller pulls out the funds of the old strategy and deposits them into the new one. But, it doesn't verify that both strategies use the same base token. If the new one uses a different base token, it won't \"know\" about the tokens it received on migration. It won't be able to deposit and transfer them. Effectively they would be lost.  The migration is done by the owner. So the owner must make a mistake and migrate to the wrong strategy by accident. In a basic protocol with 1 controller and a single active strategy managing that should be straightforward. There shouldn't be a real risk of that mistake happening. But, if you have multiple controllers running at the same time each with a different base token, it gets increasingly likelier.   According to the `IStrategy` interface, there is a function to retrieve the strategy's base token: `getBaseToken()`. I'd recommend adding a check in the `migrate()` function to verify that the new strategy uses the correct base token to prevent this issue from being possible.  ## Proof of Concept https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/interfaces/IStrategy.sol#L52  ## Tools Used none  ## Recommended Mitigation Steps Add  `require(_baseToken == _newStrategy.getBaseToken());` to the beginning of `migrate()`  "}, {"title": "`getSharesForAmount` returns wrong value when `totalAssets == 0`", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/55", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L328   # Vulnerability details  ## Impact The [`getSharesForAmount`](https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L328) function returns `0` if `totalAssets == 0`.  However, if **`totalSupply == 0`**, the actual shares that are minted in a [`deposit` are `_amount`](https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L83) even if `totalAssets == 0`.  Contracts / frontends that use this function to estimate their deposit when `totalSupply == 0` will return a wrong value.  ## Recommended Mitigation Steps  ```diff function getSharesForAmount(uint256 _amount)     external     view     override     returns (uint256) { +   // to match the code in `deposit` +   if (totalSupply() == 0) return _amount;      uint256 _totalAssets = totalAssets();     return         (_totalAssets > 0)             ? ((_amount * totalSupply()) / _totalAssets)             : 0; // @audit this should be _amount according to `deposit` } ```  "}, {"title": "Withdrawal delay can be circumvented", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/54", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/f63584133a0329781609e3f14c3004c1ca293e71/contracts/core/Collateral.sol#L97   # Vulnerability details  ## Impact After initiating a withdrawal with `initiateWithdrawal`, it's still possible to transfer the collateral tokens. This can be used to create a second account, transfer the accounts to them and initiate withdrawals at a different time frame such that one of the accounts is always in a valid withdrawal window, no matter what time it is. If the token owner now wants to withdraw they just transfer the funds to the account that is currently in a valid withdrawal window.  Also, note that each account can withdraw the specified `amount`. Creating several accounts and circling & initiating withdrawals with all of them allows withdrawing larger amounts **even at the same block** as they are purchased in the future.  I consider this high severity because it breaks core functionality of the Collateral token.  #### POC For example, assume the `_delayedWithdrawalExpiry = 20` blocks. Account A owns 1000 collateral tokens, they create a second account B. - At `block=0`, A calls `initiateWithdrawal(1000)`. They send their balance to account B. - At `block=10`, B calls `initiateWithdrawal(1000)`. They send their balance to account A. - They repeat these steps, alternating the withdrawal initiation every 10 blocks. - One of the accounts is always in a valid withdrawal window (`initiationBlock < block && block <= initiationBlock + 20`). They can withdraw their funds at any time.  ## Recommended Mitigation Steps If there's a withdrawal request for the token owner (`_accountToWithdrawalRequest[owner].blockNumber > 0`), disable their transfers for the time.  ```solidity // pseudo-code not tested beforeTransfer(from, to, amount) {   super();   uint256 withdrawalStart =  _accountToWithdrawalRequest[from].blockNumber;   if(withdrawalStart > 0 && withdrawalStart + _delayedWithdrawalExpiry < block.number) {     revert(); // still in withdrawal window   } } ```  "}, {"title": "First depositor can break minting of shares", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/27", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/Collateral.sol#L82-L91   # Vulnerability details  ## Details  The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large \u201cdonation\u201d.  ## Proof of Concept  - Attacker deposits 2 wei (so that it is greater than min fee) to mint 1 share - Attacker transfers exorbitant amount to `_strategyController` to greatly inflate the share\u2019s price. Note that the `_strategyController` deposits its entire balance to the strategy when its `deposit()` function is called. - Subsequent depositors instead have to deposit an equivalent sum to avoid minting 0 shares. Otherwise, their deposits accrue to the attacker who holds the only share.  ```jsx it(\"will cause 0 share issuance\", async () => {  // 1. first user deposits 2 wei because 1 wei will be deducted for fee  let firstDepositAmount = ethers.BigNumber.from(2)  await transferAndApproveForDeposit(      user,      collateral.address,      firstDepositAmount  )    await collateral      .connect(user)      .deposit(firstDepositAmount)    // 2. do huge transfer of 1M to strategy to controller  // to greatly inflate share price  await baseToken.transfer(strategyController.address, ethers.utils.parseEther(\"1000000\"));    // 3. deployer tries to deposit reasonable amount of 10_000  let subsequentDepositAmount = ethers.utils.parseEther(\"10000\");  await transferAndApproveForDeposit(      deployer,      collateral.address,      subsequentDepositAmount  )   await collateral      .connect(deployer)      .deposit(subsequentDepositAmount)    // receives 0 shares in return  expect(await collateral.balanceOf(deployer.address)).to.be.eq(0) }); ```  ## Recommended Mitigation Steps  - [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. - Ensure the number of shares to be minted is non-zero: `require(_shares != 0, \"zero shares minted\");` - Create a periphery contract that contains a wrapper function that atomically calls `initialize()` and `deposit()` - Call `deposit()` once in `initialize()` to achieve the same effect as the suggestion above.  "}, {"title": "Strategy Migration May Leave Tokens in the Old Strategy Impacting Share Calculations", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/26", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72   # Vulnerability details  ## Impact  If a strategy does not have sufficient funds to `withdraw()` for the full amount then it is possible that tokens will be left in this yield contract during `migrate()`.  It is common for withdrawal from a strategy to withdraw less than a user's balance. The reason is that these yield protocols may lend the deposited funds to borrowers, if there is less funds in the pool than the withdrawal amount the withdrawal may succeed but only transfer the funds available rather than the full withdrawal amount.  The impact of tokens remaining in the old strategy is that when we call `StrategyController.totalValue()` this will only account for the tokens deposited in the new strategy and not those stuck in the previous strategy. Therefore `totalValue()` is undervalued.   Thus, when a user calls `Collateral.deposit()` the share calculations `_shares = (_amountToDeposit * totalSupply()) / (_valueBefore);` will be over stated (note: `uint256 _valueBefore = _strategyController.totalValue();`). Hence, the user will receive more shares than they should.  The old tokens may be recovered by calling `migrate()` back to the old strategy. If this is done then `totalValue()` will now include the tokens previously stuck. The recent depositer may now withdraw and will be owed `(_strategyController.totalValue() * _amount) / totalSupply()`. Since `totalValue()` is now includes the previously stuck tokens  `_owed` will be overstated and the user will receive more collateral than they should.  The remaining users who had deposited before `migrate()` will lose tokens proportional to their share of the `totalSupply()`.  ## Proof of Concept  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72 ```     function migrate(IStrategy _newStrategy)         external         override         onlyOwner         nonReentrant     {         uint256 _oldStrategyBalance;         IStrategy _oldStrategy = _strategy;         _strategy = _newStrategy;         _baseToken.approve(address(_newStrategy), type(uint256).max);         if (address(_oldStrategy) != address(0)) {             _baseToken.approve(address(_oldStrategy), 0);             _oldStrategyBalance = _oldStrategy.totalValue();             _oldStrategy.withdraw(address(this), _oldStrategyBalance);             _newStrategy.deposit(_baseToken.balanceOf(address(this)));         }         emit StrategyMigrated(             address(_oldStrategy),             address(_newStrategy),             _oldStrategyBalance         );     } ```  ## Recommended Mitigation Steps  The recommendation is to ensure that `require(_oldStrategy.totalValue() == 0)` after calling `_oldStrategy.withdraw()`. This ensures that no funds are left in the strategy. Consider the code example below.  ```     function migrate(IStrategy _newStrategy)         external         override         onlyOwner         nonReentrant     {         uint256 _oldStrategyBalance;         IStrategy _oldStrategy = _strategy;         _strategy = _newStrategy;         _baseToken.approve(address(_newStrategy), type(uint256).max);         if (address(_oldStrategy) != address(0)) {             _baseToken.approve(address(_oldStrategy), 0);             _oldStrategyBalance = _oldStrategy.totalValue();             _oldStrategy.withdraw(address(this), _oldStrategyBalance);             require(_oldStrategy.totalValue() == 0)             _newStrategy.deposit(_baseToken.balanceOf(address(this)));         }         emit StrategyMigrated(             address(_oldStrategy),             address(_newStrategy),             _oldStrategyBalance         );     } ```  "}, {"title": "Duplicate  _tokenNameSuffix and _tokenSymbolSuffix will incorrectly update current Market", "html_url": "https://github.com/code-423n4/2022-03-prepo-findings/issues/2", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-prepo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/PrePOMarketFactory.sol#L42   # Vulnerability details  ## Impacted Function: createMarket  ## Description:  1. Owner calls createMarket with  _tokenNameSuffix S1 and _tokenSymbolSuffix S2 which creates a new market M1 with _deployedMarkets[_salt] pointing to M1. Here salt can be S which is computed using  _tokenNameSuffix and _tokenSymbolSuffix 2. This market is now being used 3. After some time owner again mistakenly calls createMarket with  _tokenNameSuffix S1 and _tokenSymbolSuffix S2  4. Instead of returning error mentioning that this name and symbol already exists, new market gets created. The problem here is that salt which is computed using _tokenNameSuffix and _tokenSymbolSuffix will again come as S (as in step 1) which means _deployedMarkets[_salt] will now get updated to M2. This means reference to M1 is gone  ## Recommendation: Add below check:  ``` require(_deployedMarkets[_salt]==address(0), \"Market already exists\"); ```  "}, {"title": "Pool Credit Line May Not Able to Start When _borrowAsset is Non ERC20 Compliant Tokens", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-sublime-findings", "body": "# Lines of code  https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L327   # Vulnerability details  ## Impact ```IERC20(_borrowAsset).transfer(_to, _fee);```  If the USDT token is supported as _borrowAsset, the unsafe version of .transfer(_to, _fee) may revert as there is no return value in the USDT token contract\u2019s transfer() implementation (but the IERC20 interface expects a return value).  Function start() will break when _borrowAsset is USDT or Non ERC20 Compliant Tokens. USDT is one of the most borrowed Asset in DEFI. This may cause losing a lot of potential users.  ## Proof of Concept https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L327  ## Recommended Mitigation Steps Use .safeTransfer instead of .transfer  ```IERC20(_borrowAsset).safeTransfer(_to, _fee);```  "}, {"title": "PooledCreditLine: termination likely fails because _principleWithdrawable is treated as shares", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/21", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-sublime-findings", "body": "# Lines of code  https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L404-L406   # Vulnerability details  ## Details & Impact  `_principalWithdrawable` is denominated in the borrowAsset, but subsequently treats it as the share amount to be withdrawn.  ```jsx // _notBorrowed = borrowAsset amount that isn't borrowed // totalSupply[_id] = ERC1155 total supply of _id // _borrowedTokens = borrower's specified borrowLimit uint256 _principalWithdrawable = _notBorrowed.mul(totalSupply[_id]).div(_borrowedTokens);  SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _principalWithdrawable.add(_totalInterestInShares), false); ```  ## Recommended Mitigation Steps  The amount of shares to withdraw can simply be `_sharesHeld`.  Note that this comes with the assumption that `terminate()` is only called when the credit line is `ACTIVE` or `EXPIRED` (consider ensuring this condition on-chain), because `_sharesHeld` **excludes principal withdrawals,** so the function will fail once a lender withdraws his principal.  ```jsx function terminate(uint256 _id, address _to) external override onlyPooledCreditLine nonReentrant {   address _strategy = pooledCLConstants[_id].borrowAssetStrategy;   address _borrowAsset = pooledCLConstants[_id].borrowAsset;   uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;    SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _sharesHeld, false);   delete pooledCLConstants[_id];   delete pooledCLVariables[_id]; } ```  "}, {"title": "LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee", "html_url": "https://github.com/code-423n4/2022-03-sublime-findings/issues/19", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-sublime-findings", "body": "# Lines of code  https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L594-L599 https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L399-L404   # Vulnerability details  ## Details & Impact  The `_principalWithdrawable` calculated will be more than expected if `_start()` is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting in `totalSupply[id]` not being 1:1 with the borrow limit.  ```jsx function _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {   uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;   uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));   uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);   return _principalWithdrawable; } ```  ## Proof of Concept  Assume the following conditions:  - Alice, the sole lender, provided `100_000` tokens: `totalSupply[_id] = 100_000` - `borrowLimit = 99_000` because of a 1% startFee - Borrower borrowed zero amount  When Alice attempts to withdraw her tokens, the `_principalWithdrawable` amount is calculated as   ```jsx _borrowedTokens = 99_000 _totalLiquidityWithdrawable = 99_000 - 0 = 99_000 _principalWithdrawable = 99_000 * 100_000 / 99_000 = 100_000 ```  This is more than the available principal amount of `99_000`, so the withdrawal will fail.  ## Recommended Mitigation Steps  One hack-ish way is to save the initial supply in `minBorrowAmount` (perhaps rename the variable to `minInitialSupply`) when the credit line is accepted, and replace `totalSupply[_id]` with it.   The other places where `minBorrowAmount` are used will not be affected by the change because:  - startTime has been zeroed, so `start()` cannot be invoked (revert with error S1) - credit line status would have been changed to `ACTIVE` and cannot be changed back to `REQUESTED`, meaning the check below will be false regardless of the value of `minBorrowAmount`.          ```jsx     _status == PooledCreditLineStatus.REQUESTED &&     block.timestamp > pooledCLConstants[_id].startTime &&     totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount     ```       Code amendment example:  ```jsx  function _accept(uint256 _id, uint256 _amount) internal {   ...   // replace delete pooledCLConstants[_id].minBorrowAmount; with the following:   pooledCLConstants[_id].minInitialSupply = totalSupply[_id]; }  // update comment in _withdrawLiquidity // Case 1: Pooled credit line never started because desired amount wasn't reached // state will never revert back to REQUESTED if credit line is accepted so this case is never run  function _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {   uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;   uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));   // totalSupply[id] replaced with minInitialSupply   uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(minInitialSupply);   return _principalWithdrawable; } ```  In `terminate()`, the shares withdrawable can simply be `_sharesHeld`.  ```jsx function terminate(uint256 _id, address _to) external override onlyPooledCreditLine nonReentrant {   address _strategy = pooledCLConstants[_id].borrowAssetStrategy;   address _borrowAsset = pooledCLConstants[_id].borrowAsset;   uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;    SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _sharesHeld, false);   delete pooledCLConstants[_id];   delete pooledCLVariables[_id]; } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/131", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "* different pragma versions - the core-contracts use `pragma solidity ^0.8.0` and the rest of the contracts use `pragma solidity ^0.8.4`  * use a specific solidity version instead of using `^`, to prevent future solidity versions impacting your code and creating issues.  * In the comments and variable names you wrote ETH instead of wETH, which is un-correct (that's an ERC20 so it must be wETH) ```sol function transferSplitAsset(address to, uint256 value)     private     returns (bool didSucceed) {     // Try to transfer ETH to the given recipient.     didSucceed = IERC20(splitAsset).transfer(to, value);     require(didSucceed, \"Failed to transfer ETH\");     emit TransferETH(to, value, didSucceed); } ```  * In the comment before the function, you wrote returns instead of the known `@return` tag ```sol /**  * @notice Mint token  * @dev A starting index is calculated at the time of first mint  * returns a tokenId  * @param _to Token recipient  */ function mint(address _to) private returns (uint256 tokenId) {     if (startingIndex == 0) {         setStartingIndex();     }     tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;     _mint(_to, tokenId); } ```  * Low level calls (call, delegate call and static call) return success if the called contract doesn\u2019t exist (not deployed or destructed), can be seen here https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf (report #9) and here https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions.  That means that in `attemptETHTransfer`, if `to` doesn't exist the call will fail but success will be set to true, which will act like the call was successful. ```sol function attemptETHTransfer(address to, uint256 value)     private     returns (bool)     {         // Here increase the gas limit a reasonable amount above the default, and try         // to send ETH to the recipient.         // NOTE: This might allow the recipient to attempt a limited reentrancy attack.         (bool success, ) = to.call{value: value, gas: 30000}(\"\");         return success;     } ```  * add `onlyUnInitialized` modifier to the `initialize` function, otherwise the owner can initialize the contract more than one time  * `HASHED_PROOF` - upper case variable name that is not constant  * if `startingIndex + totalSupply()` will reach `type(uint256).max` the system will be in a stuck state, that's because the calculation in the _mint function will overflow  * contracts not declaring that they implement their interfaces - for example `CoreCollection` and `CoreFactory` don't declare that they implement `ICoreCollection` and `ICoreFactory`  * `ICoreFactory` is imported but not used in `CoreProxy`  * didn't check that the address of the given vault is not zero in the `setPlatformFee` function  * wrong comment in `RoyaltyVaultFactory` and `SplitFactory` ```sol /**  * @dev Set Platform fee for collection contract.  * @param _platformFee Platform fee in scaled percentage. (5% = 200)  * @param _vault vault address.  */ function setPlatformFee(address _vault, uint256 _platformFee) external {     IRoyaltyVault(_vault).setPlatformFee(_platformFee); }  /**  * @dev Set Platform fee recipient for collection contract.  * @param _vault vault address.  * @param _platformFeeRecipient Platform fee recipient.  */ function setPlatformFeeRecipient(     address _vault,     address _platformFeeRecipient ) external {     require(_vault != address(0), \"Invalid vault\");     require(         _platformFeeRecipient != address(0),         \"Invalid platform fee recipient\"     );     IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient); } ```"}, {"title": "`RoyaltyVault.sol` is Not Equipped to Handle On-Chain Royalties From Secondary Sales", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/130", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol   # Vulnerability details  ## Impact  The Joyn documentation mentions that Joyn royalty vaults should be equipped to handle revenue generated on a collection's primary and secondary sales. Currently, `CoreCollection.sol` allows the collection owner to receive a fee on each token mint, however, there is no existing implementation which allows the owner of a collection to receive fees on secondary sales.   After discussion with the Joyn team, it appears that this will be gathered from Opensea which does not have an on-chain royalty mechanism. As such, each collection will need to be added manually on Opensea, introducing further centralisation risk. It is also possible for users to avoid paying the secondary fee by using other marketplaces such as Foundation.   ## Recommended Mitigation Steps  Consider implementing the necessary functionality to allow for the collection of fees through an on-chain mechanism. `ERC2981` outlines the approiate behaviour for this.  "}, {"title": "Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/121", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L139-L167 https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50-L56   # Vulnerability details  ## Impact  The `mintToken()` function is called to mint unique tokens from an `ERC721` collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a `payableToken`. However, because the `payableToken` is paid before a token is minted, it may be possible to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. Because `totalSupply()` has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply` check. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again.  ## Proof of Concept  For the sake of this example, let's say `startingIndex = 0` and `maxSupply = 100`. `tokenId` is minted according to `((startingIndex + totalSupply()) % maxSupply) + 1`. If we see that a user mints a token where `totalSupply() = maxSupply - 1 = 99` and they reenter the function, then the next token to mint will actually be of index `1` as `totalSupply() % maxSupply = 0`. Calculating the first `tokenId`, we get `((0 + 0) % maxSupply) + 1 = 1` which is a duplicate of our example.  ## Recommended Mitigation Steps  Consider adding reentrancy protections to prevent users from abusing this behaviour. It may also be useful to follow the checks-effects pattern such that all external/state changing calls are made at the end.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/110", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "# QA Report  1. Immutable addresses should be 0-checked  Consider adding an `address(0)` check in the constructors for these variables:  ```solidity core-contracts/contracts/CoreFactory.sol:   22:   address public immutable collection;   23:   address public immutable splitFactory;  core-contracts/contracts/CoreProxy.sol:   9:     address private immutable _implement;  splits/contracts/SplitFactory.sol:   11:   /**** Immutable storage ****/   13:   address public immutable splitter;   14:   address public immutable royaltyVault; ```  2. Missing comments  The following comments are missing (see `@audit` tags):  ```solidity core-contracts/contracts/CoreCollection.sol:   254      /**   255       * @notice Mint token   256       * @dev A starting index is calculated at the time of first mint   257       * returns a tokenId   258:      * @param _to Token recipient //@audit missing @return uint256 tokenId   259       */   260      function mint(address _to) private returns (uint256 tokenId) {  core-contracts/contracts/CoreFactory.sol:   101    /**   102     * @notice Allows to add a collection to a project   103     * @dev Can only be called by project creator   104     * Collection's ownership is transferred to the caller   105     * @param _projectId Project id which is a unique identifier   106:    * @param _collection Collection that needs to be deployed //@audit missing @return address   107     */   108    function addCollection(   109      string memory _projectId,   110      Collection memory _collection     111    ) external onlyProjectOwner(_projectId) returns (address) {    138    /**   139     * @notice Instanciates/Deploys a collection   140:    * @param _collection Collection that needs to be deployed //@audit missing @return address   141     */   142    function _createCollection(Collection memory _collection)   143      private   144      onlyAvailableCollection(_collection.id)   145      returns (address)  core-contracts/contracts/ERC721Claimable.sol:   49    /**   50     * @notice Verifies whether an address can claim tokens   51     * @dev    52     * @param who Claimer address   53     * @param claimableAmount Amount airdropped to claimer   54     * @param claimedAmount Amount of tokens claimer wants to claim   55:    * @param merkleProof Proof //@audit missing @return bool   56     */   57    function canClaim(   58      address who,   59      uint256 claimableAmount,   60      uint256 claimedAmount,   61      bytes32[] calldata merkleProof   62    ) public view returns (bool) {  splits/contracts/SplitFactory.sol:    55    /**    56     * @dev Constructor    57:    * @param _splitter The address of the Splitter contract. //@audit missing @param _royaltyVault    58     */    59    constructor(address _splitter, address _royaltyVault) {     68    /**    69     * @dev Deploys a new SplitProxy and initializes collection's royalty vault.    70     * @param _merkleRoot The merkle root of the asset.    71     * @param _splitAsset The address of the asset to split.    72     * @param _collectionContract The address of the collection contract.    73:    * @param _splitId The split identifier. //@audit missing @return address splitProxy    74     */    75    function createSplit(    76      bytes32 _merkleRoot,    77      address _splitAsset,    78      address _collectionContract,    79      string memory _splitId    80    ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {     96    /**    97     * @dev Deploys a new SplitProxy.    98     * @param _merkleRoot The merkle root of the asset.    99     * @param _splitAsset The address of the asset to split.   100:    * @param _splitId The split identifier. //@audit missing @return address splitProxy   101     */   102    function createSplit(   103      bytes32 _merkleRoot,   104      address _splitAsset,   105      string memory _splitId   106    ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {  splits/contracts/Splitter.sol:   226      /**   227       * @dev Function to transfer split asset to the given address.   228       * @param to {address} Address to transfer the split asset to.   229:      * @param value {uint256} Amount to transfer. //@audit missing @return bool didSucceed   230       */   231      function transferSplitAsset(address to, uint256 value)   232          private   233          returns (bool didSucceed) ```  3. Avoid floating pragmas / The pragmas used are not the same everywhere: the version should be locked mandatorily at >= `0.8.4` as Custom Errors are only introduced there and several contracts wouldn't compile at an older version than this:  ```solidity core-contracts/contracts/CoreCollection.sol:   2: pragma solidity ^0.8.0;  core-contracts/contracts/CoreFactory.sol:   2: pragma solidity ^0.8.0;  core-contracts/contracts/CoreProxy.sol:   2: pragma solidity ^0.8.0;  core-contracts/contracts/ERC721Claimable.sol:   2: pragma solidity ^0.8.0;  core-contracts/contracts/ERC721Payable.sol:   2: pragma solidity ^0.8.0;  royalty-vault/contracts/ProxyVault.sol:   2: pragma solidity ^0.8.4;  royalty-vault/contracts/RoyaltyVault.sol:   2: pragma solidity ^0.8.4;  splits/contracts/SplitFactory.sol:   2: pragma solidity ^0.8.4;  splits/contracts/SplitProxy.sol:   2: pragma solidity ^0.8.4;  splits/contracts/Splitter.sol:   2: pragma solidity ^0.8.4; ```  4. `CoreCollection.sol` should use implement a 2-step ownership transfer pattern instead of using `Ownable`'s default one.  5. `platformFee` should be upper bounded to avoid DoS and excessive fees  `platformFee` can take a value of 10000 (100%) which could be seen as a trust issue:  ```solidity File: RoyaltyVault.sol 67:     function setPlatformFee(uint256 _platformFee) external override onlyOwner { 68:         platformFee = _platformFee; //@audit low should be upperbounded to 10000 or L41 will get DOSed by an underflow. A reasonable upperbound should be declared for trust 69:         emit NewRoyaltyVaultPlatformFee(_platformFee); 70:     } ```  Also, although unlikely and remediable by calling again `setPlatformFee` with another value, `sendToSplitter` can get DOSed by the admin by setting `platformFee` to more than 10000:  ```solidity File: RoyaltyVault.sol 40:         uint256 platformShare = (balanceOfVault * platformFee) / 10000; 41:         uint256 splitterShare = balanceOfVault - platformShare; //@audit DOSed by the admin if platformFee > 10000, which is possible ```"}, {"title": "STORAGE COLLISION BETWEEN PROXY AND IMPLEMENTATION (LACK EIP 1967)", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/108", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L9   # Vulnerability details  ## Impact Storage collision because of lack of EIP1967 could cause conflicts and override sensible variables  ## Proof of Concept      contract CoreProxy is Ownable {            address private immutable _implement;  When you implement proxies, logic and implementation share the same storage layout.    In order to avoid storage conflicts  EIP1967 was proposed.(https://eips.ethereum.org/EIPS/eip-1967)   The idea is to set proxy variables at fixed positions (like  `impl` and `admin` ).    For example, according to the standard,  the slot for for logic address should be  `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` (obtained as `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`  ).  In this case, for example, as you inherits from `Ownable` the variable _owner is at the first slot and can be overwritten in the implementation.   There is a table at OZ site that explains this scenario more in detail  https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies  section  \"Unstructured Storaged Proxies\"  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider using EIP1967     "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/106", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "# QA Report  ## Low Issues  ### Unsafe ERC20 transfers  ERC20 operations can be unsafe due to different implementations and vulnerabilities in the standard.  It is therefore recommended to always either use OpenZeppelin's SafeERC20 library or at least to wrap each operation in a require statement.  Following functions have unsafe ERC20 transfers: - CoreCollection::withdraw - ERC721Payable::_handlePayment  ### Missing upper limit for platform fee  The platform fee can be set to arbitraty values in the `RoyaltyVault::setPlatformFee` function. The highest logical value is 10,000 = 100%.  Consider introducing an upper limit for the platform fee through a `require` statement.  Note that it's recommended to set the upper limit far lower than 100% to disable rug vectors.  ### Issues with comments  The `Splitter::transferSplitAsset` function has a faulty comment stating `// Try to transfer ETH to the given recipient.`, eventhough an ERC20 token is transfered. The error message in case of failure is off too.  A parameter document for function `RoyaltyVaultFactory::setPlatformFee` states `5% = 200` as example for the percentage scale. This conversion rate is false.  ## Gas Optimizations  ### Don't Initialize Variables with Default Value  Issue Information: [G001](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g001---dont-initialize-variables-with-default-value)  #### Findings: ``` core-contracts/contracts/CoreCollection.sol::280 => for (uint256 i = 0; i < _amount; i++) { splits/contracts/Splitter.sol::52 => uint256 amount = 0; splits/contracts/Splitter.sol::53 => for (uint256 i = 0; i < currentWindow; i++) { splits/contracts/Splitter.sol::278 => for (uint256 i = 0; i < proof.length; i++) { ``` #### Tools used [c4udit](https://github.com/byterocket/c4udit)  ### Cache Array Length Outside of Loop  Issue Information: [G002](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g002---cache-array-length-outside-of-loop)  #### Findings: ``` core-contracts/contracts/CoreFactory.sol::79 => for (uint256 i; i < _collections.length; i++) { splits/contracts/Splitter.sol::278 => for (uint256 i = 0; i < proof.length; i++) { ``` #### Tools used [c4udit](https://github.com/byterocket/c4udit)  ### Long Revert Strings  Issue Information: [G007](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g007---long-revert-strings)  #### Findings: ``` core-contracts/contracts/CoreCollection.sol::47 => require(!initialized, \"CoreCollection: Already initialized\"); core-contracts/contracts/CoreCollection.sol::146 => require(amount > 0, \"CoreCollection: Amount should be greater than 0\"); core-contracts/contracts/CoreCollection.sol::192 => \"CoreCollection: Only Split Factory or owner can initialize vault.\" core-contracts/contracts/CoreCollection.sol::207 => \"CoreCollection: Hashed Proof is set\" core-contracts/contracts/CoreCollection.sol::223 => \"CoreCollection: Starting index is already set\" royalty-vault/contracts/RoyaltyVault.sol::36 => \"Vault does not have enough royalty Asset to send\" royalty-vault/contracts/RoyaltyVault.sol::45 => \"Failed to transfer royalty Asset to splitter\" royalty-vault/contracts/RoyaltyVault.sol::49 => \"Failed to increment splitter window\" royalty-vault/contracts/RoyaltyVault.sol::56 => \"Failed to transfer royalty Asset to platform fee recipient\" splits/contracts/Splitter.sol::123 => \"NFT has already claimed the given window\" ``` #### Tools used [c4udit](https://github.com/byterocket/c4udit)  ### Unspecific Compiler Version Pragma  Issue Information: [L003](https://github.com/byterocket/c4-common-issues/blob/main/2-Low-Risk.md#l003---unspecific-compiler-version-pragma)  All contracts use a floating pragma. Consider specifying a concrete solidity version for non-interface contracts.  #### Tools used [c4udit](https://github.com/byterocket/c4udit) "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/103", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L156-L159   # Vulnerability details  ## Proof of Concept  ```solidity         require(             IRoyaltyVault(msg.sender).getSplitter() == address(this),             \"Unauthorised to increment window\"         ); ```  The authorization check in `incrementWindow` can be easily passed. However, `incrementWindow` can change the value of `currentWindow` which is used for loop. It should be guard properly.  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L50   ```solidity for (uint256 i = 0; i < currentWindow; i++) { ```   ## Recommended Mitigation Steps  Consider using white list for this task.  "}, {"title": "ERC20 tokens with no return value will fail to transfer", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/83", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L43-L46 https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57   # Vulnerability details   Although the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard (including high profile, like USDT) . In that case, the .transfer() call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.  Recommendation: Consider using OpenZeppelin\u2019s SafeERC20  "}, {"title": "Not handling return value of transferFrom command can create inconsistency", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/81", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L175-L176 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L54-L55   # Vulnerability details  The below transferFrom command is called at two places in the core contracts, followed by an emit event ``` payableToken.transferFrom(msg.sender,recipient,_amount) emit ...(...); ``` The return value is not checked during the payableToken.transferFrom  ## Impact In the event of failure of payableToken.transferFrom(...), the emit event is still generated causing the downstream applications to capture wrong transaction / state of the protocol.  ## Proof of Concept 1. Contract CoreCollection.sol      function withdraw()  2. Contract ERC721Payable.sol    function _handlePayment   ## Recommended Mitigation Steps Add a require statement as being used in the RoyaltyVault.sol ``` require( payableToken.transferFrom(msg.sender,recipient,_amount) == true,             \"Failed to transfer amount to recipient\" ); ```  "}, {"title": "Funds cannot be withdrawn in `CoreCollection.withdraw`", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/80", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L175   # Vulnerability details   The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the `msg.sender` ( who is the owner of the contract). The usage of `transferFrom` can result in serious issues. In fact, many ERC20 always require that in `transferFrom` `allowance[from][msg.sender] >= amount`, so in this case the call to the `withdraw` function will revert as the `allowance[CoreCollection][CoreCollection] == 0` and therefore the funds cannot ben withdrawn and will be locked forever in the contract.  Recommendation : replace `transferFrom` with `transfer`  "}, {"title": "`CoreCollection.setRoyaltyVault` doesn't check `royaltyVault.royaltyAsset` against `payableToken`, resulting in potential permanent lock of `payableTokens` in royaltyVault", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/73", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L185 https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50 https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L31   # Vulnerability details  ## Impact  Each CoreProxy is allowed to be associated with a RoyaltyVault, the latter which would be responsible for collecting minting fees and distributing to beneficiaries. Potential mismatch between token used in CoreProxy and RoyaltyVault might result in minting tokens being permanently stuck in RoyaltyVault.  ## Proof of Concept  Each RoyaltyVault can only handle the `royaltyVault.royaltyAsset` token assigned upon creation, if any other kind of tokens are sent to the vault, it would get stuck inside the vault forever.  ```     function sendToSplitter() external override {         ...         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             \"Failed to transfer royalty Asset to splitter\"         );         ...         require(             IERC20(royaltyAsset).transfer(                 platformFeeRecipient,                 platformShare             ) == true,             \"Failed to transfer royalty Asset to platform fee recipient\"         );         ...     } ```  Considering that pairing of CoreProxy and RoyaltyVault is not necessarily handled automatically, and can sometimes be manually assigned, and further combined with the fact that once assigned, CoreProxy does not allow modifications of the pairing RoyaltyVault. We can easily conclude that if a CoreProxy is paired with an incompatible RoyaltyVault, the `payableToken` minting fees automatically transferred to RoyaltyVault by `_handlePayment` will get permanently stuck.  ```      function setRoyaltyVault(address _royaltyVault)          external          onlyVaultUninitialized      {          ...          royaltyVault = _royaltyVault;          ...      }       function _handlePayment(uint256 _amount) internal {          address recipient = royaltyVaultInitialized()              ? royaltyVault              : address(this);          payableToken.transferFrom(msg.sender, recipient, _amount);          ...      } ```  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  While assigning vaults to CoreProxy, check if `payableToken` is the same as `royaltyVault.royaltyAsset`   ```      function setRoyaltyVault(address _royaltyVault)          external          onlyVaultUninitialized      {          require(              payableToken == _royaltyVault.royaltyAsset(),              \"CoreCollection : payableToken must be same as royaltyAsset.\"          );          ...          royaltyVault = _royaltyVault;          ...      } ```   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "**[S]**: Suggested optimation, save a decent amount of gas without compromising readability;  **[M]**: Minor optimation, the amount of gas saved is minor, change when you see fit;  **[N]**: Non-preferred, the amount of gas saved is at cost of readability, only apply when gas saving is a top priority.  ## [S] Avoid unnecessary external call can save gas  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, avoiding unnecessary external call can save gas if possible.  For example:  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVaultFactory.sol#L37-L50  ```solidity     function createVault(address _splitter, address _royaltyAsset)         external         returns (address vault)     {         splitterProxy = _splitter;         royaltyAsset = _royaltyAsset;          vault = address(             new ProxyVault{salt: keccak256(abi.encode(_splitter))}()         );          delete splitterProxy;         delete royaltyAsset;     } ```  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/ProxyVault.sol#L16-L22  ```solidity     constructor() {         royaltyVault = IVaultFactory(msg.sender).royaltyVault();         splitterProxy = IVaultFactory(msg.sender).splitterProxy();         royaltyAsset = IVaultFactory(msg.sender).royaltyAsset();         platformFee = IVaultFactory(msg.sender).platformFee();         platformFeeRecipient = IVaultFactory(msg.sender).platformFeeRecipient();     } ```  Can be changed to:  ```solidity     constructor(address _royaltyVault, address _splitterProxy, address _royaltyAsset, uint256 _platformFee, address _platformFeeRecipient) {         royaltyVault = _royaltyVault;         splitterProxy = _splitterProxy;         royaltyAsset = _royaltyAsset;         platformFee = _platformFee;         platformFeeRecipient = _platformFeeRecipient;     } ```  ```solidity     function createVault(address _splitter, address _royaltyAsset)         external         returns (address vault)     {         splitterProxy = _splitter;         royaltyAsset = _royaltyAsset;          vault = address(             new ProxyVault{salt: keccak256(abi.encode(_splitter))}(royaltyVault, splitterProxy, royaltyAsset, platformFee, platformFeeRecipient)         );          delete splitterProxy;         delete royaltyAsset;     } ```  It can save 5 times of external calls.  ## [M] Setting `uint256` variables to `0` is redundant  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L49-L49  ```solidity         uint256 amount = 0; ```  Setting `uint256` variables to `0` is redundant as they default to `0`.  Other examples include:  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279-L279  ## [S] Cache array length in for loops can save gas  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `CoreFactory.sol#createProject()`      https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79-L92  - `Splitter.sol#verifyProof()`      https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274-L288  ## [M] `++i` is more efficient than `i++`  Using `++i` is more gas efficient than `i++`, especially in for loops.  For example:  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274-L274  ```solidity         for (uint256 i = 0; i < proof.length; i++) ```  Change to:  ```solidity         for (uint256 i = 0; i < proof.length; +i) ```  ## [M] Unused constant variable  Unused constant variables in contracts increase contract size and gas usage at deployment.   https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L14-L15  ```solidity     uint256 public constant PERCENTAGE_SCALE = 10e5;  ```  In the contract, the constant variable `PERCENTAGE_SCALE` is set once but has never been read, therefore it can be removed.  ## [M] Use short reason strings can save gas  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146-L146  ```solidity require(amount > 0, \"CoreCollection: Amount should be greater than 0\"); ```  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L189-L192  ```solidity         require(             msg.sender == splitFactory || msg.sender == owner(),             \"CoreCollection: Only Split Factory or owner can initialize vault.\"         ); ```  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L220-L223  ```solidity         require(             startingIndex == 0,             \"CoreCollection: Starting index is already set\"         ); ```  ## [M] Unused events  Unused events increase contract size and gas usage at deployment.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVaultFactory.sol#L19-L19  ```solidity     event VaultCreated(address vault); ```  `VaultCreated` is unused.  ## [M] Unused function parameters  Unused private function increase contract size and gas usage at deployment.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248-L257  ```solidity     function attemptETHTransfer(address to, uint256 value)         private         returns (bool)     {         // Here increase the gas limit a reasonable amount above the default, and try         // to send ETH to the recipient.         // NOTE: This might allow the recipient to attempt a limited reentrancy attack.         (bool success, ) = to.call{value: value, gas: 30000}(\"\");         return success;     } ```  `attemptETHTransfer()` is unused.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L217-L224  ```solidity     function amountFromPercent(uint256 amount, uint32 percent)         private         pure         returns (uint256)     {         // Solidity 0.8.0 lets us do this without SafeMath.         return (amount * percent) / 100;     } ```  `amountFromPercent()` is unused.  ## [S] Use `immutable` instead of getter to save gas  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L8-L37  ```solidity contract CoreProxy is Ownable {     address private immutable _implement;      constructor(address _imp) {         _implement = _imp;     }      fallback() external {         address _impl = implement();         assembly {             let ptr := mload(0x40)             calldatacopy(ptr, 0, calldatasize())             let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)             let size := returndatasize()             returndatacopy(ptr, 0, size)              switch result             case 0 {                 revert(ptr, size)             }             default {                 return(ptr, size)             }         }     }      function implement() public view returns (address) {         return _implement;     } } ```  ### Recommendation  Change to:  ```solidity contract CoreProxy is Ownable {     address private immutable _implement;      constructor(address _imp) {         _implement = _imp;     }      fallback() external {         address _impl = _implement;         assembly {             let ptr := mload(0x40)             calldatacopy(ptr, 0, calldatasize())             let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)             let size := returndatasize()             returndatacopy(ptr, 0, size)              switch result             case 0 {                 revert(ptr, size)             }             default {                 return(ptr, size)             }         }     }      function implement() external view returns (address) {         return _implement;     } } ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/63", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "# QA Report  ## Low severity findings  ### token transfer in `CoreCollection:withdraw` will fail  In function `CoreCollection` mintfee is transfered to same address if vault is not initialized, these tokens can be withdrawn by owner using `withdraw` function, but transferFrom function will fail due to lack of allowance  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L173  ``` function withdraw() external onlyOwner {     uint256 amount = payableToken.balanceOf(address(this));     payableToken.transferFrom(address(this), msg.sender, amount);      emit NewWithdrawal(msg.sender, amount); } ```  #### Mitigation  `transferFrom` can be replaced with `transfer`  ### Increment window and transfer funds  Function `Splitter:incrementWindow` is executed by `vault:sendToSplitter` transfered tokens is pushed into `balanceForWindow` array and window is incremented, but the function can be executed by any contract and more than allowed share of tokens can be transfered by whitelisted users  #### Proof of concept  ``` bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;  function incrementWindow(uint256 royaltyAmount) public returns (bool) {     uint256 wethBalance;      require(         IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),         \"Royalty Vault not supported\"     );     require(         IRoyaltyVault(msg.sender).getSplitter() == address(this),         \"Unauthorised to increment window\"     );      wethBalance = IERC20(splitAsset).balanceOf(address(this));     require(wethBalance >= royaltyAmount, \"Insufficient funds\");      require(royaltyAmount > 0, \"No additional funds for window\");     balanceForWindow.push(royaltyAmount);     currentWindow += 1;     emit WindowIncremented(currentWindow, royaltyAmount);     return true; } ``` The function can be executed by any contract with function `supportsInterface` and `getSplitter` that returns splitter address     royaltyAmount equivalent to current unclaimed balance can be added to window and the window can be incremented to add windows  `claimForAllWindows` can be executed by whitelisted user to transfer percent allocated tokens from each new window    #### Mitigation  A storage variable with tokens added to the window can be added, and `total-windowBalance` can be added to next window, and when token is transfered windowBalance can be decremented  ### `CoreCollection` can be re-initialized by owner  Function `CoreCollection:initialize` can be executed by owner after initialisation and state variables like mintFee, maxSupply can be changed to increase/decrease fee and supply, isForSale can be set to false to stop token sale  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L78-L97  #### Mitigation   require statement can be added to revert if function is already initialized   ## Non-critical findings  ### Unused import  Imported file is not used in the contract and can be removed  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L6  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L6  #### Mitigation  import statement can be removed  ### Lack of input validation  #### Impact  Input validation is absent for address variables which may result in re-deployment if address is wrong in constructor or value transfer to wrong address, it is recommended to add validation statements in all address inputs especially in value transfers and immutable variable initialisation.  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L27   https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L140  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L59-64  #### Mitigation  Add address validation statement    ### Lack of comments  #### Impact  Some functions in the code are not commented or missing parts of comments. Adding comments can improve readability of the code   #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L128  missing return comment https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L108  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L33  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L41  missing param comment https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L57  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L230  #### Mitigation  Comments can be added to the functions  ### boolean comparison with constant  In function `RoyaltyVault:sentToSplitter` external function return value boolean is compared with boolean constant. The return value can be directly used in the require statement  #### Proof of concept   https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L47  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L51  #### Mitigation  The return value of the function can be directly used in the require statement  ### Code Layout  #### Impact   Code can be structed in order type declarations, state variables, events and functions which can improve readability Refer: https://docs.soliditylang.org/en/v0.8.10/style-guide.html#order-of-layout  #### Proof of concept  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/59", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "1. There are a lack of input checks around the contracts: - [CoreCollection.sol#L88-L96](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L88-L96) - [CoreCollection.sol#L125-L126](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L125-L126) - [CoreCollection.sol#L193](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L193) and [CoreCollection.sol#L209](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L209) could be critical because only can be assigned once. - [CoreFactory.sol#L28-L29](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L28-L29)  2. It was found some `transfer`, `approve` or `transferFrom` without checking the boolean result, ERC20 standard specify that the token can return false if this call was not made, so it's mandatory to check the result of approve methods. - [CoreCollection.sol#L175](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L175) - [ERC721Payable.sol#L54](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L54)  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "### `require()`/`revert()` strings longer than 32 bytes cost extra gas  1. File: core-contracts/contracts/ERC721Payable.sol (lines [21-24](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L21-L24)) ```solidity     require(       !royaltyVaultInitialized(),       'CoreCollection: Royalty Vault already initialized'     ); ``` 2. File: core-contracts/contracts/ERC721Payable.sol (lines [29-32](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L29-L32)) ```solidity     require(       royaltyVaultInitialized(),       'CoreCollection: Royalty Vault not initialized'     ); ``` 3. File: core-contracts/contracts/ERC721Claimable.sol (line [23](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L23)) ```solidity     require(!claimableSet(), 'ERC721Claimable: Claimable is already set'); ``` 4. File: core-contracts/contracts/CoreCollection.sol (line [47](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L47)) ```solidity         require(!initialized, \"CoreCollection: Already initialized\"); ``` 5. File: core-contracts/contracts/CoreCollection.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L52-L55)) ```solidity         require(             _maxSupply > 0,             \"CoreCollection: Max supply should be greater than 0\"         ); ``` 6. File: core-contracts/contracts/CoreCollection.sol (line [146](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146)) ```solidity         require(amount > 0, \"CoreCollection: Amount should be greater than 0\"); ``` 7. File: core-contracts/contracts/CoreCollection.sol (lines [189-192](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L189-L192)) ```solidity         require(             msg.sender == splitFactory || msg.sender == owner(),             \"CoreCollection: Only Split Factory or owner can initialize vault.\"         ); ``` 8. File: core-contracts/contracts/CoreCollection.sol (lines [204-207](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L204-L207)) ```solidity         require(             bytes(HASHED_PROOF).length == 0,             \"CoreCollection: Hashed Proof is set\"         ); ``` 9. File: core-contracts/contracts/CoreCollection.sol (lines [220-223](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L220-L223)) ```solidity         require(             startingIndex == 0,             \"CoreCollection: Starting index is already set\"         ); ``` 10. File: core-contracts/contracts/CoreFactory.sol (lines [35-38](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L35-L38)) ```solidity     require(       projects[_projectId].creator == address(0),       'CoreFactory: Unavailable project id'     ); ``` 11. File: core-contracts/contracts/CoreFactory.sol (lines [43-46](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L43-L46)) ```solidity     require(       projects[_projectId].creator == msg.sender,       'CoreFactory: Not an owner of the project'     ); ``` 12. File: core-contracts/contracts/CoreFactory.sol (lines [51-54](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L51-L54)) ```solidity     require(       collections[_collectionId] == address(0),       'CoreFactory: Unavailable collection id'     ); ``` 13. File: core-contracts/contracts/CoreFactory.sol (lines [74-77](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L74-L77)) ```solidity     require(       _collections.length > 0,       'CoreFactory: should have more at least one collection'     ); ``` 14. File: royalty-vault/contracts/RoyaltyVault.sol (lines [34-37](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L34-L37)) ```solidity         require(             balanceOfVault > 0,             \"Vault does not have enough royalty Asset to send\"         ); ``` 15. File: royalty-vault/contracts/RoyaltyVault.sol (lines [43-46](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L46)) ```solidity         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             \"Failed to transfer royalty Asset to splitter\"         ); ``` 16. File: royalty-vault/contracts/RoyaltyVault.sol (lines [47-50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L47-L50)) ```solidity         require(             ISplitter(splitterProxy).incrementWindow(splitterShare) == true,             \"Failed to increment splitter window\"         ); ``` 17. File: royalty-vault/contracts/RoyaltyVault.sol (lines [51-57](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L51-L57)) ```solidity         require(             IERC20(royaltyAsset).transfer(                 platformFeeRecipient,                 platformShare             ) == true,             \"Failed to transfer royalty Asset to platform fee recipient\"         ); ``` 18. File: splits/contracts/SplitFactory.sol (lines [48-51](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L48-L51)) ```solidity     require(       splits[_splitId] == address(0),       'SplitFactory : Split ID already in use'     ); ``` 19. File: splits/contracts/SplitFactory.sol (lines [81-84](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L81-L84)) ```solidity     require(       ICoreCollection(_collectionContract).owner() == msg.sender,       'Transaction sender is not collection owner'     ); ``` 20. File: splits/contracts/Splitter.sol (lines [118-121](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L118-L121)) ```solidity         require(             !isClaimed(msg.sender, window),             \"NFT has already claimed the given window\"         ); ```  ### Use a more recent version of solidity Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  1. File: royalty-vault/contracts/RoyaltyVault.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L2)) ```solidity pragma solidity ^0.8.4; ``` 2. File: royalty-vault/contracts/ProxyVault.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/ProxyVault.sol#L2)) ```solidity pragma solidity ^0.8.4; ``` 3. File: splits/contracts/SplitFactory.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L2)) ```solidity pragma solidity ^0.8.4; ``` 4. File: splits/contracts/SplitProxy.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitProxy.sol#L2)) ```solidity pragma solidity ^0.8.4; ``` 5. File: splits/contracts/Splitter.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L2)) ```solidity pragma solidity ^0.8.4; ```  ### Use a more recent version of solidity Use a solidity version of at least 0.8.2 to get compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  1. File: core-contracts/contracts/ERC721Payable.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L2)) ```solidity pragma solidity ^0.8.0; ``` 2. File: core-contracts/contracts/CoreProxy.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L2)) ```solidity pragma solidity ^0.8.0; ``` 3. File: core-contracts/contracts/ERC721Claimable.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L2)) ```solidity pragma solidity ^0.8.0; ``` 4. File: core-contracts/contracts/CoreCollection.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L2)) ```solidity pragma solidity ^0.8.0; ``` 5. File: core-contracts/contracts/CoreFactory.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L2)) ```solidity pragma solidity ^0.8.0; ```  ### Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27  1. File: core-contracts/contracts/ERC721Payable.sol (line [8](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L8)) ```solidity   bool public isForSale; ``` 2. File: core-contracts/contracts/CoreCollection.sol (line [20](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L20)) ```solidity     bool public initialized; ```  ### Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement  1. File: core-contracts/contracts/CoreCollection.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L52-L55)) ```solidity         require(             _maxSupply > 0,             \"CoreCollection: Max supply should be greater than 0\"         ); ``` 2. File: core-contracts/contracts/CoreCollection.sol (line [146](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146)) ```solidity         require(amount > 0, \"CoreCollection: Amount should be greater than 0\"); ``` 3. File: royalty-vault/contracts/RoyaltyVault.sol (lines [34-37](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L34-L37)) ```solidity         require(             balanceOfVault > 0,             \"Vault does not have enough royalty Asset to send\"         ); ``` 4. File: splits/contracts/Splitter.sol (line [164](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L164)) ```solidity         require(royaltyAmount > 0, \"No additional funds for window\"); ```  ### `<array>.length` should not be looked up in every loop of a `for`-loop Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length  1. File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79)) ```solidity     for (uint256 i; i < _collections.length; i++) { ``` 2. File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274)) ```solidity         for (uint256 i = 0; i < proof.length; i++) { ```  ### It costs more gas to initialize variables to zero than to let the default of zero be applied  1. File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279)) ```solidity         for (uint256 i = 0; i < _amount; i++) { ``` 2. File: splits/contracts/Splitter.sol (line [49](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L49)) ```solidity         uint256 amount = 0; ``` 3. File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50)) ```solidity         for (uint256 i = 0; i < currentWindow; i++) { ``` 4. File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274)) ```solidity         for (uint256 i = 0; i < proof.length; i++) { ```  ### State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second access of a state variable within a function. Less obvious optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, or having local caches of state variable contracts/addresses.  1. File: core-contracts/contracts/CoreCollection.sol (line [231](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L231)) ```solidity         emit StartingIndexSet(startingIndex); ``` 2. File: core-contracts/contracts/CoreCollection.sol (line [264](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L264)) ```solidity         tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1; ``` 3. File: splits/contracts/SplitFactory.sol (line [161](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L161)) ```solidity     delete merkleRoot; ``` 4. File: splits/contracts/SplitFactory.sol (line [171](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L171)) ```solidity     delete splitterProxy; ```  ### Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas  1. File: core-contracts/contracts/CoreCollection.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L79)) ```solidity         string memory _collectionName, ``` 2. File: core-contracts/contracts/CoreCollection.sol (line [80](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L80)) ```solidity         string memory _collectionSymbol, ``` 3. File: core-contracts/contracts/CoreCollection.sol (line [81](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L81)) ```solidity         string memory _collectionURI, ``` 4. File: core-contracts/contracts/CoreCollection.sol (line [122](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L122)) ```solidity         string memory _collectionName, ``` 5. File: core-contracts/contracts/CoreCollection.sol (line [123](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L123)) ```solidity         string memory _collectionSymbol ``` 6. File: core-contracts/contracts/CoreFactory.sol (line [71](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L71)) ```solidity     string memory _projectId, ``` 7. File: core-contracts/contracts/CoreFactory.sol (line [72](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L72)) ```solidity     Collection[] memory _collections ``` 8. File: core-contracts/contracts/CoreFactory.sol (line [109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L109)) ```solidity     string memory _projectId, ``` 9. File: core-contracts/contracts/CoreFactory.sol (line [110](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L110)) ```solidity     Collection memory _collection ``` 10. File: core-contracts/contracts/CoreFactory.sol (line [128](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L128)) ```solidity   function getProject(string memory _projectId) ``` 11. File: splits/contracts/SplitFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L79)) ```solidity     string memory _splitId ``` 12. File: splits/contracts/SplitFactory.sol (line [105](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L105)) ```solidity     string memory _splitId ```  ### `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops  1. File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279)) ```solidity         for (uint256 i = 0; i < _amount; i++) { ``` 2. File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79)) ```solidity     for (uint256 i; i < _collections.length; i++) { ``` 3. File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50)) ```solidity         for (uint256 i = 0; i < currentWindow; i++) { ``` 4. File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274)) ```solidity         for (uint256 i = 0; i < proof.length; i++) { ```  ### `++i` costs less gas than `++i`, especially when it's used in `for`-loops (`--i`/`i--` too"}, {"title": "Differing percentage denominators causes confusion and potentially brick claims", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/53", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L14 https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L103   # Vulnerability details  ## Details & Impact  There is a `PERCENTAGE_SCALE = 10e5` defined, but the actual denominator used is `10000`. This is aggravated by the following factors:  1. Split contracts are created by collection owners, not the factory owner. Hence, there is a likelihood for someone to mistakenly use `PERCENTAGE_SCALE` instead of `10000`. 2. The merkle root for split distribution can only be set once, and a collection\u2019s split and royalty vault can\u2019t be changed once created.  Thus, if an incorrect denominator is used, the calculated claimable amount could exceed the actual available funds in the contract, causing claims to fail and funds to be permanently locked.  ## Recommended Mitigation Steps  Remove `PERCENTAGE_SCALE` because it is unused, or replace its value with `10_000` and use that instead.   P.S: there is an issue with the example scaled percentage given for platform fees `(5% = 200)`. Should be `500` instead of `200`.  "}, {"title": "ERC20 transferFrom return values not checked", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/52", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L54   # Vulnerability details  ## Details  The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.  Some tokens like [EURS](https://etherscan.io/address/0xdb25f211ab05b1c97d595516f45794528a807ad8#code) and [BAT](https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code) will **not** revert if the transfer failed but return `false` instead. Tokens that don't actually perform the transfer and return `false` are still counted as a correct transfer.  ## Impact  Users would be able to mint NFTs for free regardless of mint fee if tokens that don\u2019t revert on failed transfers were used.  ## Recommended Mitigation Steps  Check the\u00a0`success` boolean of all\u00a0`transferFrom()` calls. Alternatively, use OZ\u2019s `SafeERC20`\u2019s `safeTransferFrom()` function.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/45", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "# 1. Low - transfer return value is ignored  ## Impact  Some ERC20 tokens, such as USDT, don't revert when transfer/transferFrom fails. The transfer return value has to be checked (as there are some other tokens that returns false instead revert). safeTransfer should be used instead of transfer  ## Proof of Concept  safeTransferFrom should be used instead of transferFrom on this line https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L175  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Use safeTransfer instead of transfer or check the return value of transfer. The return value of transfer is checked properly in these locations https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L44 https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L52 https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L237  # 2. Low - onlyUnInitialized modifier missing from initialize function  ## Impact  The CoreCollection initialize function is missing the onlyUnInitialized function. The onlyUnInitialized modifier is not used in the contract right now and this allows the initialize function to be called more than once.  ## Proof of Concept  The onlyUnInitialized modifier prevents functions from being run if the initialized is set to true https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L46  This modifier is missing from the initialize function https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L87  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the onlyUnInitialized modifier to the initialize function"}, {"title": "Ineffective Handling of FoT or Rebasing Tokens", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50   # Vulnerability details  ## Impact  Certain ERC20 tokens may change user's balances over time (positively or negatively) or charge a fee when a transfer is called (FoT tokens). The accounting of these tokens is not handled by `RoyaltyVault.sol` or `Splitter.sol` and may result in tokens being stuck in `Splitter` or overstating the balance of a user   Thus, for FoT tokens if all users tried to claim from the Splitter there would be insufficient funds and the last user could not withdraw their tokens.  ## Proof of Concept  The function `RoyaltyVault.sendToSplitter()` will transfer `splitterShare` tokens to the `Splitter` and then call `incrementWindow(splitterShare)` which tells the contract to split `splitterShare` between each of the users.  ```         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             \"Failed to transfer royalty Asset to splitter\"         );         require(             ISplitter(splitterProxy).incrementWindow(splitterShare) == true,             \"Failed to increment splitter window\"         ); ```  Since the `Splitter` may receive less than `splitterShare` tokens if there is a fee on transfer the `Splitter` will overstate the amount split and each user can claim more than their value (except the last user who claims nothing as the contract will have insufficient funds to transfer them the full amount).  Furthermore, if the token rebase their value of the tokens down while they are sitting in the `Splitter` the same issue will occur. If the tokens rebase their value up then this will not be accounted for in the protocol.  ## Recommended Mitigation Steps  It is recommend documenting clearly that rebasing token should not be used in the protocol.  Alternatively, if it is a requirement to handle rebasing tokens balance checks should be done before and after the transfer to ensure accurate accounting. Note: this makes the contract vulnerable to reentrancy and so a [reentrancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) must be placed over the function `sendToSplitter()`.  ```         uint256 balanceBefore = IERC20(royaltyAsset).balanceOf(splitterProxy);         require(             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,             \"Failed to transfer royalty Asset to splitter\"         );         uint256 balanceAfter = IERC20(royaltyAsset).balanceOf(splitterProxy);         require(             ISplitter(splitterProxy).incrementWindow(balanceAfter - balanceBefore) == true,             \"Failed to increment splitter window\"         ); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/40", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "### l01: Event emission is missing CoreCollection.initialize() (core-contracts/contracts/CoreCollection.sol#78-97) should emit an event for:           - maxSupply = _maxSupply (core-contracts/contracts/CoreCollection.sol#91)    ### l02: lack of zero checks CoreCollection.initialize()._splitFactory (core-contracts/contracts/CoreCollection.sol#86) lacks a zero-check on :                  - splitFactory = _splitFactory (core-contracts/contracts/CoreCollection.sol#95)  CoreCollection.setRoyaltyVault()._royaltyVault (core-contracts/contracts/CoreCollection.sol#185) lacks a zero-check on :                  - royaltyVault = _royaltyVault (core-contracts/contracts/CoreCollection.sol#193)   ### l03: use safe erc20 functions  ERC721Payable._handlePayment() (core-contracts/contracts/ERC721Payable.sol#50-56)  ignores return value by payableToken.transferFrom() (core-contracts/contracts/ERC721Payable.sol#54)  consider safeTransferFrom to prevent any locks or loss of funds "}, {"title": "CoreCollection's token transfer can be disabled", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/37", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57 https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164   # Vulnerability details  ## Impact  When royaltyAsset is an ERC20 that doesn't allow zero amount transfers, the following griefing attack is possible, entirely disabling CoreCollection token transfer by precision degradation as both reward distribution and vault balance can be manipulated.  Suppose splitterProxy is set, all addresses and fees are configured correctly, system is in normal operating state.  POC:  Bob the attacker setup a bot which every time it observes positive royaltyVault balance:  1) runs `sendToSplitter()`, distributing the whole current royaltyAsset balance of the vault to splitter and platform, so vault balance becomes zero  2) sends `1 wei` of royaltyAsset to the royaltyVault balance  3) each next CoreCollection token transfer will calculate `platformShare = (balanceOfVault * platformFee) / 10000`, which will be 0 as platformFee is supposed to be less than 100%, and then there will be an attempt to transfer it to `platformFeeRecipient`  If royaltyAsset reverts on zero amount transfers, the whole operation will fail as the success of `IERC20(royaltyAsset).transfer(platformFeeRecipient, platformShare)` is required for each CoreCollection token transfer, which invokes `sendToSplitter()` in `_beforeTokenTransfer()` as vault balance is positive in (3).  Notice, that Bob needn't to front run the transfer, it is enough to empty the balance in a lazy way, so cumulative gas cost of the attack can be kept moderate.  Setting severity to medium as on one hand, the attack is easy to setup and completely blocks token transfers, making the system inoperable, and it looks like system has to be redeployed on such type of attack with some manual management of user funds, which means additional operational costs and reputational damage. On the another, it is limited to the zero amount reverting royaltyAsset case or the case when platformFee is set to 100%.  That is, as an another corner case, if platformFee is set to 100%, `platformShare` will be `1 wei` and `splitterShare` be zero in (3), so this attack be valid for any royaltyAsset as it is required in Splitter's `incrementWindow` that `splitterShare` be positive.  ## Proof of Concept  As royaltyAsset can be an arbitrary ERC20 it can be reverting on zero value transfers:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  `_beforeTokenTransfer` runs `IRoyaltyVault(royaltyVault).sendToSplitter()` whenever royaltyVault is set and have positive balance:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L307  `sendToSplitter()` leaves vault balance as exactly zero as `splitterShare = balanceOfVault - platformShare`, i.e. no dust is left behind:  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L41  This way the balance opens up for the tiny amount manipulation.  One require that can fail the whole operation is `platformShare` transfer:  https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57  Another is positive `royaltyAmount` = `splitterShare` requirement:  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164  ## Recommended Mitigation Steps  The issue is that token transfer, which is core system operation, require fee splitting to be done on the spot. More failsafe design is to try to send the fees and record the amounts not yet distributed, not requiring immediate success. The logic here is that transfer itself is more important than fee distribution, which is simple enough and can be performed in a variety of ways later.  Another issue is a combination of direct balance usage and the lack of access controls of the sendToSplitter function, but it only affects fee splitting and is somewhat harder to address.  As one approach consider trying, but not requiring `IRoyaltyVault(royaltyVault).sendToSplitter()` to run successfully as it can be executed later with the same result.  Another, a simpler one (the same is in `Griefing attack is possible making Splitter's claimForAllWindows inaccessible` issue), is to introduce action threshold, `MIN_ROYALTY_AMOUNT`, to `sendToSplitter()`, for example:  Now: ``` /**  * @dev Send accumulated royalty to splitter.  */ function sendToSplitter() external override {     uint256 balanceOfVault = getVaultBalance();      require(         balanceOfVault > 0,         \"Vault does not have enough royalty Asset to send\"     );  ...      emit RoyaltySentToSplitter(...);     emit FeeSentToPlatform(...); } ```  To be: ``` /**  * @dev Send accumulated royalty to splitter if it's above MIN_ROYALTY_AMOUNT threshold.  */ function sendToSplitter() external override {     uint256 balanceOfVault = getVaultBalance();      if (balanceOfVault > MIN_ROYALTY_AMOUNT) {   ...       emit RoyaltySentToSplitter(...);      emit FeeSentToPlatform(...);     } } ```  "}, {"title": "DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/33", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L153-L155   # Vulnerability details  ## Impact  A `merkleRoot` may only be used once in `createSplit()` since it is used as `salt` to the deployment of a `SplitProxy`.   The result is an attacker may front-run any `createSplit()` transaction in the mem pool and create another `createSplit()` transaction with a higher gas price that uses the same `merkleRoot` but changes the other fields such as the `_collectionContract` or `_splitAsset()`.  The original transaction will revert and the user will not be able to send any more transaction with this `merkleRoot`.  The user would therefore have to generate a new merkle tree with different address, different allocations or a different order of leaves in the tree to create a new merkle root. However, the attack is repeateable and there is no guarantee this new merkle root will be successfully added to a split without the attacker front-running the transaction again.  ## Proof of Concept  The excerpt from `createSplitProxy()` shows the `merkleRoot()` being used as a `salt`.  ```   splitProxy = address(     new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()   ); ```  ## Recommended Mitigation Steps  As seems to be the case here if the transaction address does NOT need to be known ahead of time consider removing the `salt` parameter from the contract deployment.  Otherwise, if the transaction address does need to be known ahead of time then consider concatenating `msg.sender` to the `merkleRoot`. e.g.  ``` splitProxy = address(     new SplitProxy{salt: keccak256(abi.encode(msg.sender, merkleRoot))}()   ) ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/30", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "## Issue 1 (Low) - All function inputs should verify address != address(0)  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L193 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L60-L61 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L76  There are several input addresses that should be verified != address(0). Most notably, the royaltyVault and platformFeeRecipient.  ## Issue 2 (Low) - platformFeeRecipient must be trusted  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L51-L57  In the event that `royaltyAsset` gives control on transfer such as with an ERC777, a malicious `platformFeeRecipient` will have the power to stop all executions of `sendToSplitter()`  ## Issue 3 (Low) - Function definition doesn't match purpose  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L231-L240  The `transferSplitAsset()` function contains comments about sending ETH, and the event that is emitted is called `TransferETH` despite only ERC20 transfers.  ## Issue 4 (Non-critical) - Private attemptETHTransfer() never used  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248  Since `attemptETHTransfer()` is private and not used in the contract, it can safely be removed.  ## Issue 5 (non-critical) - Internal functions should start with underscore  Example: https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/MultiSigWallet.sol#L284  Code style best practice.  ## Issue 6 (non-critical) - Unnecessary bool in TransferETH event  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L237-L239   The function reverts if transfer fails, so bool in event will always be true.    "}, {"title": "Gas costs will likely result in any fees sent to the Splitter being economically unviable to recover.", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50 https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169   # Vulnerability details  ## Impact  Collection owners will likely lose money by claiming fees unless the fees from a single NFT sale outweighs the cost of claiming it (not guaranteed).  ## Proof of Concept  Consider a new `Collection` with a `RoyaltyVault` and `Splitter` set and a nonzero mint fee.  When calling `mintToken`, the `_handlePayment` function is called https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163  This will transfer the minting fee to the `RoyaltyVault` contract.  On each transfer of an NFT within the collection (for instance in the `_mint` call which occurs directly after calling `_handlePayment`), the `Collection` contract will call `sendToSplitter` on the `RoyaltyVault`: https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307  This function will forward the collection owners' portion of the minting on to the `Splitter` contract but another important thing to note is that we call `Splitter.incrementWindow`.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50  This results in the fees newly deposited into the `Splitter` contract being held in a separate \"window\" to the fees from previous or later mints and need to be claimed separately. Remember that this process happens on every NFT sale so the only funds which will be held in this window will be the minting fees for this particular mint.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169  From this we can see that the `claim` function will only claim the fraction of the fees which are owed to the caller from a single NFT mint.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L112-L142  Note that we can attempt to claim from multiple windows in a single transaction using `claimForAllWindow` but as the name suggests it performs an unbounded loop trying to claim all previous windows (even ones which have already been claimed!) and it is likely that with a new window for every NFT sold this function will exceed the gas limit (consider an 10k token collection resulting in trying to do 10k SSTOREs at 20k gas each.), leaving us to claim each window individually with `claim`.  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L35-L62  We're then forced to claim the royalties from each NFT sold one by one, having to send huge numbers of calls to `claim` incurring the base transaction cost many times over and performing many ERC20 transfers when we could have just performed one.  Compound on this that this needs to be repeated by everyone included in the split, multiplying the costs of claiming.  Medium risk as it's gas inefficiency to the point of significant value leakage where collection owners will lose a large fraction of their royalties.  ## Recommended Mitigation Steps  It doesn't seem like the \"window\" mechanism does anything except raise gas costs to the extent that it will be very difficult to withdraw fees so it should be removed.  "}, {"title": "createProject can be frontrun", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L77   # Vulnerability details  ## Impact  This is dangerous in scam senario because the malicious user can frontrun and become the owner of the collection. As owner, one can withdraw `paymentToken`. (note that _collections.isForSale can be change by frontrunner)  ## Proof of Concept  1. Anyone can call `createProject`.  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L77  ```solidity   function createProject(     string memory _projectId,     Collection[] memory _collections   ) external onlyAvailableProject(_projectId) {     require(       _collections.length > 0,       'CoreFactory: should have more at least one collection'     ); ```  ## Recommended Mitigation Steps  Two way to mitigate.  1. Consider use white list on project creation. 2. Ask user to sign their address and check the signature against `msg.sender`.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol#L102  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/25", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": "# Report  ## Don't ignore ERC20 transfer return values  You're ignoring the return value of an ERC20 transfer twice:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L175  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L54  Either use SafeERC20 or check the return value as you do in other places in the code base.  ## Add a max boundary for the platform fee  Fees should have a boundary of 100% (10000): https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L68  Otherwise the contract will try to transfer more than possible which will result in reverts: https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L40  It might also be helpful the have an fixed upper boundary that doesn't allow the platform to collect more than a set amount of fees, e.g. 10%.  ## No connection between a project & collection  When creating a project with collections, there is no ID linking the collections to that specific project. Both entities exist independent of each other. There seems to be no way of associating them with each other after the creation (besides the emitted event).  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L99"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/15", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-joyn-findings", "body": " Title: Does not validate the input fee parameter Severity: Low Risk   Some fee parameters of functions are not checked for invalid values. Validate the parameters:                           RoyaltyVaultFactory.setPlatformFeeRecipient (_platformFeeRecipient)         RoyaltyVaultFactory.setPlatformFee (_platformFee)         SplitFactory.setPlatformFeeRecipient (_platformFeeRecipient)         CoreCollection.initialize (_mintFee)         RoyaltyVault.setPlatformFeeRecipient (_platformFeeRecipient)         RoyaltyVault.setPlatformFee (_platformFee)         SplitFactory.setPlatformFee (_platformFee)    Title: Never used parameters Severity: Low Risk  Those are functions and parameters pairs that the function doesn't use the parameter. In case those functions are external/public this is even worst since the user is required to put value that never used and can misslead him and waste its time.           Splitter.sol: function attemptETHTransfer parameter value isn't used. (attemptETHTransfer is private)    Title: Not verified claimer Severity: Low Risk   If a functions gets as input a claimer param, then it should make sure the claimer address is not address(0). Otherwise it will cause to loss of the funds or access.           ERC721Claimable.sol._claim claimer    Title: Missing commenting Severity: Low Risk           The following functions are missing commenting as describe below:                  MultiSigWallet.sol, external_call (private), parameters destination, value, dataLength, data not commented         SplitProxy.sol, splitter (public), @return is missing         MultiSigWallet.sol, external_call (private), @return is missing    Title: Two Steps Verification before Transferring Ownership Severity: Low Risk  The following contracts have a function that allows them an admin to change it to a different address. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked. It is important to have two steps admin change where the first is announcing a pending new admin and the new address should then claim its ownership.  A similar issue was reported in a previous contest and was assigned a severity of medium: [code-423n4/2021-06-realitycards-findings#105](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105)           ICoreCollection.sol    Title: Not verified owner Severity: Low Risk           owner param should be validated to make sure the owner address is not address(0).         Otherwise if not given the right input all only owner accessible functions will be unaccessible.                           MultiSigWallet.sol.replaceOwner owner         MultiSigWallet.sol.removeOwner owner         MultiSigWallet.sol.addOwner owner         MultiSigWallet.sol.replaceOwner newOwner    Title: Duplicates in array Severity: Low Risk  You allow in some arrays to have duplicates. Sometimes you assumes there are no duplicates in the array.              MultiSigWallet.addOwner pushed (owner)    Title: Solidity compiler versions mismatch Severity: Low Risk   The project is compiled with different versions of solidity, which is not recommended because it can lead to undefined behaviors.                      Title: Not verified input Severity: Low Risk       external / public functions parameters should be validated to make sure the address is not 0.     Otherwise if not given the right input it can mistakenly lead to loss of user funds.                       MockCollection.sol.setRoyaltyVault _royaltyVault         Splitter.sol.setClaimed who         CoreCollection.sol.setRoyaltyVault _royaltyVault         RoyaltyVault.sol.setPlatformFeeRecipient _platformFeeRecipient    Title: Require with empty message Severity: Low Risk  The following requires are with empty messages.  This is very important to add a message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: MultiSigWallet.sol, In line 99 with Empty Require message.         Solidity file: CoreMultiSig.sol, In line 21 with Empty Require message.  "}, {"title": "Centralisation RIsk: Owner Of `RoyaltyVault` Can Take All Funds", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/9", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L76-L83   # Vulnerability details  ## Impact  The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g. 100% = 10000) and that share of the contracts balance and future balances will be set to the `platformFeeRecipient` (which is in the owners control) rather than the splitter contract.  As a result the owner can steal the entire contract balance and any future balances avoiding the splitter.  ## Proof of Concept  ```     function setPlatformFee(uint256 _platformFee) external override onlyOwner {         platformFee = _platformFee;         emit NewRoyaltyVaultPlatformFee(_platformFee);     } ```  ## Recommended Mitigation Steps  This issue may be mitigated by add a maximum value for the `_platformFee` say 5% (or some reasonable value based on the needs of the platform).  Also consider calling `sendToSplitter()` before adjusting the `platformFee`. This will only allow the owner to change the fee for future value excluding the current contract balance.  Consider the following code. ```     function setPlatformFee(uint256 _platformFee) external override onlyOwner {         require(_platformFee < MAX_FEE);         sendToSplitter(); // @audit this will need to be public rather than external         platformFee = _platformFee;         emit NewRoyaltyVaultPlatformFee(_platformFee);     } ```  "}, {"title": "Fixed Amount of Gas Sent in Call May Be Insufficient", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248-L257   # Vulnerability details  ## Impact  The function `attemptETHTransfer()` makes a call with a fixed amount of gas, 30,000. If the receiver is a contract this may be insufficient to process the `receive()` function. As a result the user would be unable to receive funds from this function.  ## Proof of Concept  ```     function attemptETHTransfer(address to, uint256 value)         private         returns (bool)     {         // Here increase the gas limit a reasonable amount above the default, and try         // to send ETH to the recipient.         // NOTE: This might allow the recipient to attempt a limited reentrancy attack.         (bool success, ) = to.call{value: value, gas: 30000}(\"\");         return success;     } ```  ## Recommended Mitigation Steps  Consider removing the `gas` field to use the default amount and protect from reentrancy by using reentrancy guards and the [check-effects-interaction pattern](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html). Note this pattern is already applied correctly.  "}, {"title": "DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/6", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50-L59   # Vulnerability details  ## Impact  When the value of `currentWindow` is raised sufficiently high `Splitter.claimForAllWindows()` will not be able to be called due to the block gas limit.  `currentWindow` can only ever be incremented and thus will always increase. This value will naturally increase as royalties are paid into the contract.  Furthermore, an attacker can continually increment `currentWindow` by calling `incrementWindow()`. An attacker can impersonate a `IRoyaltyVault` and send 1 WEI worth of WETH to pass the required checks.  ## Proof of Concept  Excerpt from `Splitter.claimForAllWindows()` demonstrating the for loop over `currentWindow` that will grow indefinitely. ```         for (uint256 i = 0; i < currentWindow; i++) {             if (!isClaimed(msg.sender, i)) {                 setClaimed(msg.sender, i);                  amount += scaleAmountByPercentage(                     balanceForWindow[i],                     percentageAllocation                 );             }         } ```  `Splitter.incrementWindow()` may be called by an attacker increasing `currentWindow`. ```     function incrementWindow(uint256 royaltyAmount) public returns (bool) {         uint256 wethBalance;          require(             IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),             \"Royalty Vault not supported\"         );         require(             IRoyaltyVault(msg.sender).getSplitter() == address(this),             \"Unauthorised to increment window\"         );          wethBalance = IERC20(splitAsset).balanceOf(address(this));         require(wethBalance >= royaltyAmount, \"Insufficient funds\");          require(royaltyAmount > 0, \"No additional funds for window\");         balanceForWindow.push(royaltyAmount);         currentWindow += 1;         emit WindowIncremented(currentWindow, royaltyAmount);         return true;     } ```  ## Recommended Mitigation Steps  Consider modifying the function `claimForAllWindows()` to instead claim for range of windows. Pass the function a `startWindow` and `endWindow` and only iterate through windows in that range. Ensure that `endWindow < currentWindow`.  "}, {"title": "CoreCollection can be reinitialized", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/4", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L78-L97   # Vulnerability details  ## Impact  Reinitialization is possible for CoreCollection as `initialize` function sets `initialized` flag, but doesn't control for it, so the function can be rerun multiple times.  Such types of issues tend to be critical as all core variables can be reset this way, for example `payableToken`, which provides a way to retrieve all the contract funds.  However, setting priority to be medium as `initialize` is `onlyOwner`. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.  ## Proof of Concept  `initialize` doesn't control for repetitive runs:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L87  ## Recommended Mitigation Steps  Add `onlyUnInitialized` modifier to the `initialize` function:  https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L46-L49   "}, {"title": "Splitter: Anyone can call incrementWindow to steal the tokens in the contract", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/3", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L149-L169   # Vulnerability details  ## Impact In general, the Splitter contract's incrementWindow function is only called when tokens are transfer to the contract, ensuring that the number of tokens stored in balanceForWindow is equal to the contract balance. However, anyone can use a fake RoyaltyVault contract to call the incrementWindow function of the Splitter contract, so that the amount of tokens stored in balanceForWindow is greater than the contract balance, after which the verified user can call the claim or claimForAllWindows functions to steal the tokens in the contract. ```     function incrementWindow(uint256 royaltyAmount) public returns (bool) {         uint256 wethBalance;          require(             IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),             \"Royalty Vault not supported\"         );         require(             IRoyaltyVault(msg.sender).getSplitter() == address(this),             \"Unauthorised to increment window\"         );          wethBalance = IERC20(splitAsset).balanceOf(address(this));         require(wethBalance >= royaltyAmount, \"Insufficient funds\");          require(royaltyAmount > 0, \"No additional funds for window\");         balanceForWindow.push(royaltyAmount);         currentWindow += 1;         emit WindowIncremented(currentWindow, royaltyAmount);         return true;     } ``` ## Proof of Concept https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L149-L169 ## Tools Used None ## Recommended Mitigation Steps Add the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-joyn-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-joyn-findings", "body": "# Gas Report  **Table of Contents:**  - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [Findings](#findings)     - [Version](#version)       - [Upgrade pragma to at least 0.8.4](#upgrade-pragma-to-at-least-084)     - [Contract size](#contract-size)       - [Contract is Ownable but owner capabilites are not used](#contract-is-ownable-but-owner-capabilites-are-not-used)     - [Storage](#storage)       - [Caching storage values in memory](#caching-storage-values-in-memory)     - [Variables](#variables)       - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values)     - [Comparisons](#comparisons)       - [Boolean comparisons](#boolean-comparisons)       - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof)     - [For-Loops](#for-loops)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)       - [`++i` costs less gas compared to `i++` or `i += 1`](#i-costs-less-gas-compared-to-i-or-i--1)       - [Increments can be unchecked](#increments-can-be-unchecked)     - [Arithmetics](#arithmetics)       - [Unchecking arithmetics operations that can't underflow/overflow](#unchecking-arithmetics-operations-that-cant-underflowoverflow)     - [Visibility](#visibility)       - [Consider making some constants as non-public to save gas](#consider-making-some-constants-as-non-public-to-save-gas)     - [Errors](#errors)       - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Findings  ### Version  #### Upgrade pragma to at least 0.8.4  Using newer compiler versions and the optimizer give gas optimizations. Also, additional safety checks are available for free.  The advantages here are:  - **Low level inliner** (>= 0.8.2): Cheaper runtime gas (especially relevant when the contract has small functions). - **Optimizer improvements in packed structs** (>= 0.8.3) - **Custom errors** (>= 0.8.4): cheaper deployment cost and runtime cost. *Note*: the runtime cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.  Consider upgrading pragma to at least 0.8.4:  ```jsx core-contracts/contracts/CoreCollection.sol:2:pragma solidity ^0.8.0; core-contracts/contracts/CoreFactory.sol:2:pragma solidity ^0.8.0; core-contracts/contracts/CoreProxy.sol:2:pragma solidity ^0.8.0; core-contracts/contracts/ERC721Claimable.sol:2:pragma solidity ^0.8.0; core-contracts/contracts/ERC721Payable.sol:2:pragma solidity ^0.8.0; ```  ### Contract size  #### Contract is Ownable but owner capabilites are not used  Reduce contract size by removing Ownable given that its functionalities are not used here:  ```solidity core-contracts/contracts/CoreProxy.sol:4:import {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\"; core-contracts/contracts/CoreProxy.sol:8:contract CoreProxy is Ownable { royalty-vault/contracts/ProxyVault.sol:6:import {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\"; royalty-vault/contracts/ProxyVault.sol:8:contract ProxyVault is VaultStorage, Ownable { ```  ### Storage  #### Caching storage values in memory  The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, storage values should get cached in memory (see the `@audit` tags for further details):  ```solidity core-contracts/contracts/CoreCollection.sol:   225          startingIndex =   226              (uint256(   227                  keccak256(abi.encodePacked(\"CoreCollection\", block.number))   228              ) % maxSupply) +   229:             1; //@audit gas: this calculation should be cached and saved in memory before being saved in startingIndex, so that the cached value can be emitted Line L231   230          startingIndexBlock = uint256(block.number);   231:         emit StartingIndexSet(startingIndex); //@audit gas: should emit the suggested cached memory variable in comment L229 instead of making a storage read (SLOAD) here    304:             royaltyVault != address(0) && //@audit gas: royaltyVault should get cached in memory   305:             IRoyaltyVault(royaltyVault).getVaultBalance() > 0 //@audit gas: should use the suggested cached royaltyVault   306          ) {   307:             IRoyaltyVault(royaltyVault).sendToSplitter(); //@audit gas: should use the suggested cached royaltyVault  royalty-vault/contracts/RoyaltyVault.sol:   38:         require(splitterProxy != address(0), \"Splitter is not set\"); //@audit gas: splitterProxy should get cached in memory      44:             IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true, //@audit gas: should use the suggested cached splitterProxy //@audit gas: royaltyAsset should get cached in memory    45              \"Failed to transfer royalty Asset to splitter\"   46          );   47          require(   48:             ISplitter(splitterProxy).incrementWindow(splitterShare) == true, //@audit gas: should use the suggested cached splitterProxy   49              \"Failed to increment splitter window\"   50          );   51          require(   52:             IERC20(royaltyAsset).transfer( //@audit gas: should use the suggested cached royaltyAsset    53:                 platformFeeRecipient, //@audit gas: platformFeeRecipient should get cached in memory   54                  platformShare   55              ) == true,   56              \"Failed to transfer royalty Asset to platform fee recipient\"   57          );   58     59:         emit RoyaltySentToSplitter(splitterProxy, splitterShare); //@audit gas: should use the suggested cached splitterProxy   60:         emit FeeSentToPlatform(platformFeeRecipient, platformShare); //@audit gas: should use the suggested cached platformFeeRecipient ```  ### Variables  #### No need to explicitly initialize variables with default values  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Instances include:    ```solidity core-contracts/contracts/CoreCollection.sol:279:        for (uint256 i = 0; i < _amount; i++) { splits/contracts/Splitter.sol:49:        uint256 amount = 0; splits/contracts/Splitter.sol:50:        for (uint256 i = 0; i < currentWindow; i++) { splits/contracts/Splitter.sol:274:        for (uint256 i = 0; i < proof.length; i++) { ```  I suggest removing explicit initializations for default values.  ### Comparisons  #### Boolean comparisons  Comparing to a constant (`true` or `false`) is a bit more expensive than directly checking the returned boolean value. I suggest using `if(directValue)` instead of `if(directValue == true)` and `if(!directValue)` instead of `if(directValue == false)` here:  ```solidity royalty-vault/contracts/RoyaltyVault.sol:44:            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true, royalty-vault/contracts/RoyaltyVault.sol:48:            ISplitter(splitterProxy).incrementWindow(splitterShare) == true, royalty-vault/contracts/RoyaltyVault.sol:55:            ) == true, ```  #### `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  I suggest changing `> 0` with `!= 0` here:  ```solidity core-contracts/contracts/CoreCollection.sol:    52          require(    53:             _maxSupply > 0,    146:         require(amount > 0, \"CoreCollection: Amount should be greater than 0\");  core-contracts/contracts/CoreFactory.sol:   74      require(   75:       _collections.length > 0,  royalty-vault/contracts/RoyaltyVault.sol:   34          require(   35:             balanceOfVault > 0,  splits/contracts/Splitter.sol:   164:         require(royaltyAmount > 0, \"No additional funds for window\"); ```  Also, please enable the Optimizer.  ### For-Loops  #### An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead:  ```solidity core-contracts/contracts/CoreFactory.sol:79:    for (uint256 i; i < _collections.length; i++) { splits/contracts/Splitter.sol:274:        for (uint256 i = 0; i < proof.length; i++) { ```  #### `++i` costs less gas compared to `i++` or `i += 1`  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:      ```solidity uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ```solidity uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:    ```solidity core-contracts/contracts/CoreCollection.sol:279:        for (uint256 i = 0; i < _amount; i++) { core-contracts/contracts/CoreFactory.sol:79:    for (uint256 i; i < _collections.length; i++) { splits/contracts/Splitter.sol:50:        for (uint256 i = 0; i < currentWindow; i++) { splits/contracts/Splitter.sol:166:        currentWindow += 1; splits/contracts/Splitter.sol:274:        for (uint256 i = 0; i < proof.length; i++) { ```  I suggest using `++i` instead of `i++` to increment the value of an uint variable.  #### Increments can be unchecked  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Instances include:    ```solidity core-contracts/contracts/CoreCollection.sol:279:        for (uint256 i = 0; i < _amount; i++) { core-contracts/contracts/CoreFactory.sol:79:    for (uint256 i; i < _collections.length; i++) { splits/contracts/Splitter.sol:50:        for (uint256 i = 0; i < currentWindow; i++) { splits/contracts/Splitter.sol:274:        for (uint256 i = 0; i < proof.length; i++) { ```  The code would go from:      ```solidity for (uint256 i; i < numIterations; i++) {    // ...   }   ```  to:    ```solidity for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ```  The risk of overflow is inexistant for a `uint256` here.  ### Arithmetics    #### Unchecking arithmetics operations that can't underflow/overflow  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  I suggest wrapping with an `unchecked` block here (see `@audit` tags for more details):  ```solidity File: RoyaltyVault.sol 40:         uint256 platformShare = (balanceOfVault * platformFee) / 10000; 41:         uint256 splitterShare = balanceOfVault - platformShare; //@audit gas: should be unchecked (as L40: platformFee == 500 < 10000 so platformShare < balanceOfVault and I don't believe platformFee would ever be set to >= 10000) ```  ### Visibility  #### Consider making some constants as non-public to save gas  Reducing from `public` to `private` or `internal` can save gas when a constant isn't used outside of its contract. I suggest changing the visibility from `public` to `internal` or `private` here:  ```solidity splits/contracts/Splitter.sol:14:    uint256 public constant PERCENTAGE_SCALE = 10e5; splits/contracts/Splitter.sol:15:    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId; ```  ### Errors  #### Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity core-contracts/contracts/CoreCollection.sol:47:        require(!initialized, \"CoreCollection: Already initialized\"); core-contracts/contracts/CoreCollection.sol:54:            \"CoreCollection: Max supply should be greater than 0\" core-contracts/contracts/CoreCollection.sol:146:        require(amount > 0, \"CoreCollection: Amount should be greater than 0\"); core-contracts/contracts/CoreCollection.sol:191:            \"CoreCollection: Only Split Factory or owner can initialize vault.\" core-contracts/contracts/CoreCollection.sol:206:            \"CoreCollection: Hashed Proof is set\" core-contracts/contracts/CoreCollection.sol:222:            \"CoreCollection: Starting index is already set\" royalty-vault/contracts/RoyaltyVault.sol:36:            \"Vault does not have enough royalty Asset to send\" royalty-vault/contracts/RoyaltyVault.sol:45:            \"Failed to transfer royalty Asset to splitter\" royalty-vault/contracts/RoyaltyVault.sol:49:            \"Failed to increment splitter window\" royalty-vault/contracts/RoyaltyVault.sol:56:            \"Failed to transfer royalty Asset to platform fee recipient\" splits/contracts/Splitter.sol:120:            \"NFT has already claimed the given window\"  ```  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next.  #### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  ```solidity core-contracts/contracts/CoreCollection.sol:42:        require(initialized, \"CoreCollection: Not initialized\"); core-contracts/contracts/CoreCollection.sol:47:        require(!initialized, \"CoreCollection: Already initialized\"); core-contracts/contracts/CoreCollection.sol:52:        require( core-contracts/contracts/CoreCollection.sol:60:        require(_exists(_tokenId), \"CoreCollection: Invalid token id\"); core-contracts/contracts/CoreCollection.sol:146:        require(amount > 0, \"CoreCollection: Amount should be greater than 0\"); core-contracts/contracts/CoreCollection.sol:147:        require( core-contracts/contracts/CoreCollection.sol:153:            require(claimableSet(), \"CoreCollection: No claimable\"); core-contracts/contracts/CoreCollection.sol:154:            require( core-contracts/contracts/CoreCollection.sol:160:            require(isForSale, \"CoreCollection: Not for sale\"); core-contracts/contracts/CoreCollection.sol:189:        require( core-contracts/contracts/CoreCollection.sol:204:        require( core-contracts/contracts/CoreCollection.sol:220:        require( core-contracts/contracts/CoreFactory.sol:35:    require( core-contracts/contracts/CoreFactory.sol:43:    require( core-contracts/contracts/CoreFactory.sol:51:    require( core-contracts/contracts/CoreFactory.sol:74:    require( core-contracts/contracts/ERC721Claimable.sol:13:    require(root != bytes32(0), 'ERC721Claimable: Not valid root'); core-contracts/contracts/ERC721Claimable.sol:18:    require(claimableSet(), 'ERC721Claimable: No claimable'); core-contracts/contracts/ERC721Claimable.sol:23:    require(!claimableSet(), 'ERC721Claimable: Claimable is already set'); core-contracts/contracts/ERC721Claimable.sol:63:    require( core-contracts/contracts/ERC721Payable.sol:21:    require( core-contracts/contracts/ERC721Payable.sol:29:    require( royalty-vault/contracts/RoyaltyVault.sol:34:        require( royalty-vault/contracts/RoyaltyVault.sol:38:        require(splitterProxy != address(0), \"Splitter is not set\"); royalty-vault/contracts/RoyaltyVault.sol:43:        require( royalty-vault/contracts/RoyaltyVault.sol:47:        require( royalty-vault/contracts/RoyaltyVault.sol:51:        require( splits/contracts/SplitFactory.sol:48:    require( splits/contracts/SplitFactory.sol:81:    require( splits/contracts/SplitFactory.sol:136:    require(_vault != address(0), 'Invalid vault'); splits/contracts/SplitFactory.sol:137:    require( splits/contracts/Splitter.sol:40:        require( splits/contracts/Splitter.sol:117:        require(currentWindow > window, \"cannot claim for a future window\"); splits/contracts/Splitter.sol:118:        require( splits/contracts/Splitter.sol:125:        require( splits/contracts/Splitter.sol:152:        require( splits/contracts/Splitter.sol:156:        require( splits/contracts/Splitter.sol:162:        require(wethBalance >= royaltyAmount, \"Insufficient funds\"); splits/contracts/Splitter.sol:164:        require(royaltyAmount > 0, \"No additional funds for window\"); splits/contracts/Splitter.sol:237:        require(didSucceed, \"Failed to transfer ETH\"); ```  I suggest replacing revert strings with custom errors. "}, {"title": "Div by 0", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/58", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-volt-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-volt/tree/main/contracts/utils/Deviation.sol#L23   # Vulnerability details   Division by 0 can lead to accidentally revert, (An example of a similar issue - https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/84)          https://github.com/code-423n4/2022-03-volt/tree/main/contracts/utils/Deviation.sol#L23 a might be 0  It's internal function but since it is used in another internal functions that are used in public and neither of them has this protection I thought it can be considered as medium (e.g. isWithinDeviationThreshold)  Thanks.  "}, {"title": "Setting new buffer does not reduce current buffer to cap", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/29", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-volt-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol#L142   # Vulnerability details  ## Impact The `RateLimited.setBufferCap` function first updates the buffer and then sets the new cap, but does not apply the new cap to the updated buffer. Meaning, the updated buffer value can be larger than the new buffer cap which should never be the case. Actions consuming more than the new buffer cap can be performed.  ```solidity function _setBufferCap(uint256 newBufferCap) internal {     // @audit still uses old buffer cap, should set buffer first     _updateBufferStored();      uint256 oldBufferCap = bufferCap;     bufferCap = newBufferCap;       emit BufferCapUpdate(oldBufferCap, newBufferCap); } ```  ## Recommended Mitigation Steps Update the buffer after setting the new cap:  ```diff function _setBufferCap(uint256 newBufferCap) internal { -   _updateBufferStored();     uint256 oldBufferCap = bufferCap;     bufferCap = newBufferCap;  +   _updateBufferStored();      emit BufferCapUpdate(oldBufferCap, newBufferCap); } ```   "}, {"title": "Updating rate limit for addresses restores their entire buffer amount", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-volt-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol#L280   # Vulnerability details  ## Impact When the `bufferCap` is updated for an address in `_updateAddress`, the address's allowed buffer (`bufferStored`) is replenished to the entire `bufferCap`.  The address could frontrun the `updateAddress` call and spend their entire buffer, then the buffer is replenished and they can spend their entire buffer a second time.  ## Recommended Mitigation Steps Keep the old buffer value, capped by the new `bufferCap`:  ```diff + uint256 newBuffer = individualBuffer(rateLimitedAddress);    rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();   rateLimitData.bufferCap = _bufferCap;   rateLimitData.rateLimitPerSecond = _rateLimitPerSecond; - rateLimitData.bufferStored = _bufferCap; + rateLimitData.bufferStored = min(_bufferCap, newBuffer); ```   "}, {"title": "`OracleRef` assumes backup oracle uses the same normalizer as main oracle", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-volt-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/OracleRef.sol#L104   # Vulnerability details  ## Impact The `OracleRef` assumes that the backup oracle uses the same normalizer as the main oracle. This generally isn't the case as it could be a completely different oracle, not even operated by Chainlink.  If the main oracle fails, the backup oracle could be scaled by a wrong amount and return a wrong price which could lead to users being able to mint volt cheap or redeem volt for inflated underlying amounts.  ## Recommended Mitigation Steps Should there be two scaling factors, one for each oracle?   "}, {"title": "Oracle price does not compound", "html_url": "https://github.com/code-423n4/2022-03-volt-findings/issues/22", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-volt-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L136 https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L113   # Vulnerability details  ## Impact The oracle does not correctly compound the monthly APRs - it resets on `fulfill`. Note that the [`oraclePrice` storage variable](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L198) is only set in `_updateCPIData` as part of the oracle `fulfill` callback. It's set to the old price (price from 1 month ago) plus the interpolation from **`startTime`** to now. However, `startTime` is **reset** in `requestCPIData` due to the `afterTimeInit` modifier, and therefore when Chainlink calls `fulfill` in response to the CPI request, the `timeDelta = block.timestamp - startTime` is close to zero again and `oraclePrice` is updated to itself again.  This breaks the core functionality of the protocol as the oracle does not track the CPI, it always resets to `1.0` after every `fulfill` instead of compounding it. In addition, there should also be a way for an attacker to profit from the sudden drop of the oracle price to `1.0` again.  #### POC As an example, assume `oraclePrice = 1.0 (1e18)`, `monthlyAPR = 10%`. The time elapsed is 14 days. Calling `getCurrentOraclePrice()` now would return `1.0 + 14/28 * 10% = 1.05`.  - it's now the 15th of the month and one can trigger `requestCPIData`. **This resets `startTime = now`**. - Calling `getCurrentOraclePrice()` now would return `1.0` again as `timeDelta` (and `priceDelta`) is zero: `oraclePriceInt + priceDelta = oraclePriceInt = 1.0`. - When `fulfill` is called it sets `oraclePrice = getCurrentOraclePrice()` which will be close to `1.0` as the `timeDelta` is tiny.  ## Recommended Mitigation Steps The `oraclePrice` should be updated in `requestCPIData()` not in `fulfill`. Cover this scenario of multi-month accumulation in tests.   "}, {"title": "Increasing the Lock Amount on an Expired Lock Will Cause Users to Miss Out on Rewards", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/95", "labels": ["2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code\r \r https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L284-L294\r \r https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1137-L1233\r \r # Vulnerability details\r \r ## Impact\r \r Paladin protocol allows users to increase the amount or duration of their lock while it is stil active. Increasing the amount of an active lock should only increase the total locked amount and it shouldn't make any changes to the associated bonus ratios as the duration remains unchanged. \r \r However, if a user increases the lock amount on an expired lock, a new lock will be created with the duration of the previous lock and the provided non-zero amount. Because the `action != LockAction.INCREASE_AMOUNT` check later on in the function does not hold true, `userCurrentBonusRatio` will contain the last updated value from the previous lock. As a result, the user will not receive any rewards for their active lock and they will need to increase the duration of the lock to fix lock's bonus ratio.\r \r ## Recommended Mitigation Steps\r \r Consider preventing users from increasing the amount on an expired lock. This should help to mitigate this issue.\r "}, {"title": "Users Can Bypass Emergency Restrictions on updateUserRewardState()", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/94", "labels": ["2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code\r \r https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1338-L1378\r \r https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L876-L906\r \r # Vulnerability details\r \r ## Impact\r \r The `emergencyWithdraw()` function intends to withdraw their tokens regardless if they are locked up for any duration. This emergency must be triggered by the owner of the contract by calling `triggerEmergencyWithdraw()`. A number of functions will revert when the protocol is in an emergency state, including all stake, lock, unlock and kick actions and the updating of a user's rewards. However, a user could bypass the restriction on `_updateUserRewards()` by transferring a small amount of unlocked tokens to their account. `_beforeTokenTransfer()` will call `_updateUserRewards()` on the `from` and `to` accounts. As a result, users can continue to accrue rewards while the protocol is in an emergency state and it makes sense for users to delay their emergency withdraw as they will be able to claim a higher proportion of the allocated rewards.\r \r ## Recommended Mitigation Steps\r \r Consider adding a check for the boolean `emergency` value in `_beforeTokenTransfer()` to not call `_updateUserRewards` on any account if this value is set. Alternatively, a check could be added into the `_updateUserRewards()` function to return if `emergency` is true.\r "}, {"title": "System could be wrapped and made useless without contract whitelisting", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/77", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L253 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L284 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L268   # Vulnerability details  ## Impact Anyone could create a contract or a contract factory \"PAL Locker\" with a fonction to deposit PAL tokens through a contract, lock them and delegate the voting power to the contract owner. Then, the ownership of this contract could be sold. By doing so, locked hPAL would be made liquid and transferrable again. This would eventually break the overall system of hPAL, where the idea is that you have to lock them to make them non liquid to get a boosted voting power and reward rate.   Paladin should expect this behavior to happen as we've seen it happening with veToken models and model implying locking features (see https://lockers.stakedao.org/ and https://www.convexfinance.com/).   This behavior could eventually be beneficial to the original DAO (ex. https://www.convexfinance.com/ for Curve and Frax), but the original DAO needs to at least be able to blacklist / whitelist such contracts and actors to ensure their interests are aligned with the protocol.  ## Proof of Concept  To make locked hPAL liquid, Alice could create a contact C. Then, she can deposit hPAL through the contract, lock them and delegate voting power to herself. She can then sell or tokenize the ownership of the contract C.  ## Recommended Mitigation Steps  Depending of if Paladin wants to be optimistic or pessimistic, implement a whitelisting / blacklisting system for contracts.   See: https://github.com/curvefi/curve-dao-contracts/blob/4e428823c8ae9c0f8a669d796006fade11edb141/contracts/VotingEscrow.vy#L185  https://github.com/FraxFinance/frax-solidity/blob/7375949a73042c1e6dd14848fc4ea1ba62e36fb5/src/hardhat/contracts/FXS/veFXS_Solidity.sol.old#L370  "}, {"title": "UserLock information can be found during emergency mode", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L446-L468   # Vulnerability details   When the contract is in blocked state (emergency mode), the protocol wants to return an empty UserLock info, on calling the function getUserLock. However, there is another way, by which the users can find the same information.  The below function is not protected when in emergency mode, and users can use this alternatively. Line#466 function getUserPastLock(address user, uint256 blockNumber)   ## Impact There is no loss of funds, however the intention to block information (return empty lock info) is defeated, because not all functions are protected. There is inconsistency in implementing the emergency mode check.  ## Proof of Concept Contract Name : HolyPaladinToken.sol Functions getUserLock and getUserPastLock  ## Recommended Mitigation Steps Add checking for emergency mode for this function getUserPastLock. ``` if(emergency) revert EmergencyBlock(); ``` Additional user access check can be added, so that the function returns correct value when the caller(msg.sender) is admin or owner.   "}, {"title": "Function cooldown() is not protected when protocol in emergency mode", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L228-L235   # Vulnerability details  Function cooldown() is not protected when protocol is in emergency mode. Its behavior is not consistent with the other major functions defined.  ## Impact While other major functions like stake, unstake, lock, unlock, etc., of this contract is protected by checking for emergency flag and reverting,  this function cooldown() is not checked. The impact of this is that during emergency mode, users can set immediately the cooldown() and plan for unstaking when the emergency mode is lifted and cooldown period expires. This may not be the desirable behaviour expected by the protocol.  ## Proof of Concept Contract Name : HolyPaladinToken.sol Function cooldown()  ## Recommended Mitigation Steps Add checking for emergency mode for this function also. ``` if(emergency) revert EmergencyBlock(); ```   "}, {"title": "`DropPerSecond` is not updated homogeneously, the rewards emission can be much higher than expected in some cases", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/44", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L715-L743   # Vulnerability details  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L715-L743  ```solidity function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates => decrease duration is over     if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; } ```  When current time is `lastDropUpdate + (2*MONTH-1)`:  `nbMonthEllapsed` will be round down to `1`, while it's actually 1.99 months passed, but because of precision loss, the smart contract will believe it's only 1 month elapsed, as a result, `DropPerSecond` will only decrease by 1 * `dropDecreasePerMonth`.  In another word, due to the precision loss in calculating the number of months elapsed, for each `_updateDropPerSecond()` there can be a short of up to `1 * dropDecreasePerMonth` for the decrease of emission rate.  At the very edge case, if all the updates happened just like the scenario above. by the end of the `dropDecreaseDuration`, it will drop only `12 * dropDecreasePerMonth` in total, while it's expected to be `24 * dropDecreasePerMonth`.  So only half of `(startDropPerSecond - endDropPerSecond)` is actually decreased. And the last time `updateDropPerSecond` is called, `DropPerSecond` will suddenly drop to `endDropPerSecond`.  ### Impact  As the `DropPerSecond` is not updated correctly, in most of the `dropDecreaseDuration`, the actual rewards emission rate is much higher than expected. As a result, the total rewards emission can be much higher than expected.  ### Recommendation  Change to:  ```solidity function _updateDropPerSecond() internal returns (uint256){     // If no more need for monthly updates => decrease duration is over     if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {         // Set the current DropPerSecond as the end value         // Plus allows to be updated if the end value is later updated         if(currentDropPerSecond != endDropPerSecond) {             currentDropPerSecond = endDropPerSecond;             lastDropUpdate = block.timestamp;         }          return endDropPerSecond;     }      if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month      uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);     uint256 nbMonthEllapsed = UNIT * (block.timestamp - lastDropUpdate) / MONTH;      uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed / UNIT;      // We calculate the new dropPerSecond value     // We don't want to go under the endDropPerSecond     uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;      currentDropPerSecond = newDropPerSecond;     lastDropUpdate = block.timestamp;      return newDropPerSecond; } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/36", "labels": ["bug", "resolved", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L729   # Vulnerability details  ## Impact If `startDropPerSecond` is initialized at less than `endDropPerSecond` the contract will be unusable. There will be an underflow in `_updateDropPerSecond` which will always revert. This function is called throughout the contract, in critical functions like `lock` and `claim`, if it were to always revert the contract would be broken and unusable.  ## Proof of Concept If `startDropPerSecond` is initialized at less than `endDropPerSecond` in the constructor, the contract will be deployed without issue but will be broken.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add a check in the constructor that ensures `startDropPerSecond` >= `endDropPerSecond`  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "## Don't Initialize Variables with Default Value  ### Impact Issue Information: [G001](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md#g001---dont-initialize-variables-with-default-value)  ### Findings: ``` HolyPaladinToken.sol::516 => uint256 low = 0; HolyPaladinToken.sol::688 => uint256 low = 0; HolyPaladinToken.sol::796 => uint256 userLockedBalance = 0; HolyPaladinToken.sol::807 => uint256 lockingRewards = 0; HolyPaladinToken.sol::940 => uint256 low = 0; HolyPaladinToken.sol::972 => uint256 low = 0; HolyPaladinToken.sol::1004 => uint256 low = 0; ``` ### Tools used [c4udit](https://github.com/byterocket/c4udit)"}, {"title": "PaladinRewardReserve.sol may have potential bugs if it uses new tokens as rewards", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol   # Vulnerability details  ## Impact ``PaladinRewardReserve.sol`` may have potential bugs if it uses new tokens as rewards.  ## Proof of Concept Currently, ``PaladinRewardReserve.sol`` has following behaviors:  - ``mapping(address => bool) public approvedSpenders`` does not store the info regarding which token it targets - ``setNewSpender``, ``updateSpenderAllowance``, ``removeSpender`` and ``transferToken`` functions can set ``token`` arbitrarily  Hence, some corner cases may happen as follows: - Use TokenA at PaladinRewardReserve.sol and do operations. - Start TokenB as rewards at PaladinRewardReserve.sol.  - All the information stored in ``approvedSpenders`` was intended for TokenA. So it is possible that following corner cases happen:   - ``setNewSpender`` function cannot set new token   - If userA is already added in ``approvedSpenders`` for TokenA, it can call ``updateSpenderAllowance``.   ## Tools Used Statis code analysis  ## Recommended Mitigation Steps Do either of followings depending on the product specification:  (1) If PAL token is only used and other token will never be used at ``PaladinRewardReserve.sol``, stop having ``address token`` argument at ``setNewSpender``, ``updateSpenderAllowance``, ``removeSpender`` and ``transferToken`` functions. Instead, set ``token`` at the constructor or other ways, and limit the ability to flexibly set ``token`` from functions.  (2) If other tokens potentially will be used at ``PaladinRewardReserve.sol``, update data structure of ``approvedSpenders`` mapping and change the logic.  Firstly, it should also contain the info which ``token`` it targets such as ``mapping(address => address => bool)``.  Secondly, it should rewrite the ``require`` logic at each function as follows.  ``` require(!approvedSpenders[spender][token], \"Already Spender on the specified Token\"); ```  ``` require(approvedSpenders[spender][token], \"Not approved Spender on the specified Token\"); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/22", "labels": ["bug", "resolved", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "# Summary  We list 3 low-critical findings and 1 non-critical finding here: * (Low) Rewrite `_updateDropPerSecond` to avoid loss of precision * (Low) Rewrite `_getUserAccruedRewards` to avoid loss of precision * (Low) Lock pragma to ensure compiler version * (Non) `_getNewReceiverCooldown` revert when divided by zero  In summary of recommended security practices, it's better to rewrite formulas to avoid loss of precision, lock pragma version, and check division by zero.  # (Low) Rewrite `_updateDropPerSecond` to avoid loss of precision  ## Impact  In `_updateDropPerSecond`:  ```         uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH); ```  `dropDecreasePerMonth` may suffer from loss of precision due to ordering of operations.  ## Proof of Concept  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L729  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  rewrite to avoid loss of precision:  ```         uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) * MONTH / dropDecreaseDuration; ```  # (Low) Rewrite `_getUserAccruedRewards` to avoid loss of precision  ## Impact  In `_getUserAccruedRewards`:  ```         lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT; ```  `lockingRewards` may suffer from loss of precision.  ## Proof of Concept  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L842  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  rewrite to avoid loss of precision:  ```         lockingRewards = userLockedBalance * indexDiff * vars.periodBonusRatio / UNIT / UNIT; ```  # (Low) Lock pragma to ensure compiler version  ## Impact  Floating pragma may cause unexpected compilation time behaviour and introduce unintended bugs.  ## Proof of Concept  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L2 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/PaladinRewardReserve.sol#L2  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Don't use `^`, lock pragma to ensure compiler version. e.g. `pragma solidity 0.8.4;`  # (Non) `_getNewReceiverCooldown` revert when divided by zero  ## Impact  `_getNewReceiverCooldown` reverts on transferring 0 amount to someone with 0 balance due to division by 0.  ## Proof of Concept  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1108  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Explicitly check `(amount + receiverBalance)` should not equal to 0. "}, {"title": "Past state query results are susceptible to manipulation due to multiple states with same block number", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/20", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L466 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L492 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L644 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L663 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L917 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L961 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L993 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1148 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1164 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1184 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1199 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1225 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1250 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1260 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1287 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1293 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1324 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1352 https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1357   # Vulnerability details  ## Impact  4 kinds of states (`UserLock`, `TotalLock`, `Checkpoint`, `DelegateCheckpoint`) are maintained in the protocol to keep record of history. For functions that query history states, target block number is used as an index to search for the corresponding state.  However, 3 (`DelegateCheckpoint`, `TotalLock`, `UserLocks`) out of the 4 states are allowed to have multiple entries with same `fromBlock`, resulting in a one-to-many mapping between block number and history entry. This makes queried results at best imprecise, and at worst manipulatable by malicious users to present an incorrect history.  ## Proof of Concept  Functions that query history states including `_getPastLock`, `getPastTotalLock`, `_getPastDelegate` perform a binary search through the array of history states to find entry matching queried block number. However, the searched arrays can contain multiple entries with the same `fromBlock`.  For example the `_lock` function pushes a new `UserLock` to `userLocks[user]` regardless of previous lock block number.  ```     function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {         require(user != address(0)); //Never supposed to happen, but security check         require(amount != 0, \"hPAL: Null amount\");         uint256 userBalance = balanceOf(user);         require(amount <= userBalance, \"hPAL: Amount over balance\");         require(duration >= MIN_LOCK_DURATION, \"hPAL: Lock duration under min\");         require(duration <= MAX_LOCK_DURATION, \"hPAL: Lock duration over max\");          if(userLocks[user].length == 0){             ...         }         else {             // Get the current user Lock             uint256 currentUserLockIndex = userLocks[user].length - 1;             UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];             // Calculate the end of the user current lock             uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;              uint256 startTimestamp = block.timestamp;              if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) {                 // User locked, and then unlocked                 // or user lock expired                  userLocks[user].push(UserLock(                     safe128(amount),                     safe48(startTimestamp),                     safe48(duration),                     safe32(block.number)                 ));             }             else {                 // Update of the current Lock : increase amount or increase duration                 // or renew with the same parameters, but starting at the current timestamp                 require(amount >=  currentUserLock.amount,\"hPAL: smaller amount\");                 require(duration >=  currentUserLock.duration,\"hPAL: smaller duration\");                  // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock                  userLocks[user].push(UserLock(                     safe128(amount),                     action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),                     safe48(duration),                     safe32(block.number)                 ));                 ...             }         ...     } ```  This makes the history searches imprecise at best. Additionally, if a user intends to shadow his past states from queries through public search functions, it is possible to control the number of entries precisely such that binsearch returns the entry he wants to show.   ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Adopt the same strategy as checkpoint, and modify last entry in array instead of pushing new one if it `fromBlock == block.number`   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/18", "labels": ["bug", "resolved", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L31 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L38-L39 https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L47   # Vulnerability details  ## Impact - In function  `updateSpenderAllowance` of `PaladinRewardReserve`, line 38 `safeApprove` to 0 before `safeApprove` to amount in line 39. This is because we can only approve their allowance to zero or from zero in `SafeERC20`.  - In `SafeERC20`, it is used to prevent front-run by approved addresses and usually users have to do 2 TXs. - But when we do both in 1 TX, it does not add any layer of security and just wasting gas. Such behavior creates a false sense of security. Also `safeApprove` is deprecated by OZ (ref) ## Proof of concept - https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L31 - https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L38-L39 - https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L47 ## Recommended Mitigation Steps - As suggested by the OpenZeppelin comment, replace `safeApprove()` with `safeIncreaseAllowance()`. - And in the case of line 38-39, just use normal `approve` instead of 2 `safeApprove`.   "}, {"title": "cooldown is set to 0 when the user sends all tokens to himself.", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L891-L905   # Vulnerability details  ## Impact In the _beforeTokenTransfer function, cooldowns will be set to 0 when the user transfers all tokens to himself. Consider the following scenario Day 0: The user stakes 100 tokens and calls the cooldown function Day 10: the user wanted to unstake the tokens, but accidentally transferred all the tokens to himself, which caused the cooldown to be set to 0 and the user could not unstake. ## Proof of Concept https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L891-L905 ## Tools Used None ## Recommended Mitigation Steps ```   function _beforeTokenTransfer(       address from,       address to,       uint256 amount   ) internal virtual override {       if(from != address(0)) { //check must be skipped on minting           // Only allow the balance that is unlocked to be transfered           require(amount <= _availableBalanceOf(from), \"hPAL: Available balance too low\");       }        // Update user rewards before any change on their balance (staked and locked)       _updateUserRewards(from);        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0        if(from != to) {           // Update user rewards before any change on their balance (staked and locked)           _updateUserRewards(to);           // => we don't want a self-transfer to double count new claimable rewards           // + no need to update the cooldown on a self-transfer            uint256 previousToBalance = balanceOf(to);           cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);           // If from transfer all of its balance, reset the cooldown to 0           uint256 previousFromBalance = balanceOf(from);           if(previousFromBalance == amount && fromCooldown != 0) {               cooldowns[from] = 0;           }       }   } ```  "}, {"title": "Users at UNSTAKE_PERIOD can assist other users in unstaking tokens.", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/7", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1131   # Vulnerability details  ## Impact Consider the following scenario: Day 0: User A stakes 200 tokens and calls the cooldown function. At this time, user A's cooldown is Day 0. Day 15: User B stakes 100 tokens, but then wants to unstake tokens. So user A said that he could assist user B in unstaking tokens, and this could be done by deploying a smart contract. In the smart contract deployed by user A, user B first needs to transfer 100 tokens to user A. In the _getNewReceiverCooldown function, _senderCooldown is Day 15 and receiverCooldown is Day 0, so the latest cooldown of user A is (100 * Day 15 + 200 * Day 0)/(100+200) = Day 5. ```     function _getNewReceiverCooldown(         uint256 senderCooldown,         uint256 amount,         address receiver,         uint256 receiverBalance     ) internal view returns(uint256) {         uint256 receiverCooldown = cooldowns[receiver];          // If receiver has no cooldown, no need to set a new one         if(receiverCooldown == 0) return 0;          uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);          // If last receiver cooldown is expired, set it back to 0         if(receiverCooldown < minValidCooldown) return 0;          // In case the given senderCooldown is 0 (sender has no cooldown, or minting)         uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;          // If the sender cooldown is better, we keep the receiver cooldown         if(_senderCooldown < receiverCooldown) return receiverCooldown;          // Default new cooldown, weighted average based on the amount and the previous balance         return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);      } ``` Since User A is still at UNSTAKE_PERIOD after receiving the tokens, User A unstakes 100 tokens and sends it to User B.  After calculation, we found that when user A has a balance of X and is at the edge of UNSTAKE_PERIOD, user A can assist in unstaking the X/2 amount of tokens just staked.  ## Proof of Concept https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L1131  ## Tools Used None ## Recommended Mitigation Steps After calculation, we found that the number of tokens that users at the edge of UNSTAKE_PERIOD can assist in unstaking conforms to the following equation UNSTAKE_PERIOD/COOLDOWN_PERIOD = UNSTAKE_AMOUNT/USER_BALANCE, when COOLDOWN_PERIOD remains unchanged, the smaller the UNSTAKE_PERIOD, the less tokens the user can assist in unstaking, so UNSTAKE_PERIOD can be adjusted to alleviate this situation.  "}, {"title": "Incorrect number of seconds in `ONE_YEAR` variable", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L25   # Vulnerability details  ## Impact In `HolyPaladinToken.sol` the `ONE_YEAR` variable claims that there are `31557600` seconds in a year when this is incorrect.  The `ONE_YEAR` variable is used in the `getCurrentVotes()` function as well as the `getPastVotes()` function so it is vital that the correct time in seconds be used as it can effect users negatively.   ## Proof of Concept https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/HolyPaladinToken.sol#L25  86,400 seconds in a day x 365 = 31_536_000  ## Tools Used Manual code review   ## Recommended Mitigation Steps The correct number of seconds in a year is 31_536_000 so the `ONE_YEAR` variable should be changed to `ONE_YEAR = 31_536_000`   "}, {"title": "`HolyPaladinToken.sol` uses `ERC20` token with a highly unsafe pattern", "html_url": "https://github.com/code-423n4/2022-03-paladin-findings/issues/3", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/open-zeppelin/ERC20.sol#L149   # Vulnerability details  ## Impact In `HolyPaladinToken.sol` it imports `ERC20.sol` with some changes from the original Open Zeppelin standard.  One change is that the `transferFrom()` function does not follow the Checks Effect and Interactions safety pattern to safely make external calls to other contracts. All checks should be handled first, then any effects/state updates,  followed by the external call to prevent reentrancy attacks.  Currently the `transferFrom()` function in `ERC20.sol` used by `HolyPaladinToken.sol` calls `_transfer()` first and then updates the `sender` allowance which is highly unsafe.  The openZeppelin `ER20.sol` contract which is the industry standard first updates the `sender` allowance before calling `_transfer`.  The external call should always be done last to avoid any double spending bugs or reentrancy attacks.   ## Proof of Concept https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  https://github.com/code-423n4/2022-03-paladin/blob/main/contracts/open-zeppelin/ERC20.sol#L149  Open Zeppelins Implementation https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol  ## Tools Used Manual code review   ## Recommended Mitigation Steps Be sure to follow the Checks Effects and Interactions safety pattern as the `transferFrom` function is one of the most important functions in any protocol.  Consider importing the Open Zeppelin `ERC20.sol` contract code directly as it is battle tested and safe code.   "}, {"title": "Update initializer modifier to prevent reentrancy during initialization", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/227", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/package.json#L18-L19   # Vulnerability details  ## Impact  The solution uses: ```jsx     \"@openzeppelin/contracts\": \"^4.0.0\",     \"@openzeppelin/contracts-upgradeable\": \"^4.3.2\", ``` These dependencies have a known high severity vulnerability:  - https://security.snyk.io/vuln/SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177 - https://snyk.io/test/npm/@openzeppelin/contracts-upgradeable/4.3.2#SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177 - https://snyk.io/test/npm/@openzeppelin/contracts/4.0.0#SNYK-JS-OPENZEPPELINCONTRACTS-2320176  Which makes these contracts vulnerable: ```jsx contracts/helpers/CryptoPunksHelper.sol:   19:     function initialize(address punksAddress) external initializer {  contracts/helpers/EtherRocksHelper.sol:   19:     function initialize(address rocksAddress) external initializer {  contracts/staking/JPEGStaking.sol:   21:     function initialize(IERC20Upgradeable _jpeg) external initializer {  contracts/vaults/FungibleAssetVaultForDAO.sol:   71:     ) external initializer {  contracts/vaults/NFTVault.sol:   149:     ) external initializer { ```  ## Recommended Mitigation Steps Upgrade `@openzeppelin/contracts` and `@openzeppelin/contracts-upgradeable` to version 4.4.1 or higher.  "}, {"title": "`StrategyPUSDConvex.balanceOfJPEG` uses incorrect function signature while calling `extraReward.earned`, causing the function to unexpectedly revert everytime", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/139", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234   # Vulnerability details  ## Impact  As specified in Convex [BaseRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L149) and [VirtualRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/VirtualBalanceRewardPool.sol#L127), the function signature of `earned` is `earned(address)`. However, `balanceOfJPEG` did not pass any arguments to `earned`, which would cause `balanceOfJPEG` to always revert.  This bug will propagate through `Controller` and `YVault` until finally reaching the source of the call in `YVaultLPFarming ._computeUpdate`, and render the entire farming contract unuseable.  ## Proof of Concept  Both `BaseRewardPool.earned` and `VirtualBalanceRewardPool.earned` takes an address as argument  ```     function earned(address account) public view returns (uint256) {         return             balanceOf(account)                 .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))                 .div(1e18)                 .add(rewards[account]);     }      function earned(address account) public view returns (uint256) {         return             balanceOf(account)                 .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))                 .div(1e18)                 .add(rewards[account]);     } ```  But `balanceOfJPEG` does not pass any address to `extraReward.earned`, causing the entire function to revert when called ```     function balanceOfJPEG() external view returns (uint256) {         uint256 availableBalance = jpeg.balanceOf(address(this));          IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;         uint256 length = baseRewardPool.extraRewardsLength();         for (uint256 i = 0; i < length; i++) {             IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));             if (address(jpeg) == extraReward.rewardToken()) {                 availableBalance += extraReward.earned();                 //we found jpeg, no need to continue the loop                 break;             }         }          return availableBalance;     } ```  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Pass `address(this)` as argument of `earned`.  Notice how we modify the fetching of reward. This is reported in a separate bug report, but for completeness, the entire fix is shown in both report entries.  ```     function balanceOfJPEG() external view returns (uint256) {         uint256 availableBalance = jpeg.balanceOf(address(this));          IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;         availableBalance += baseRewardPool.earned(address(this));         uint256 length = baseRewardPool.extraRewardsLength();         for (uint256 i = 0; i < length; i++) {             IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));             if (address(jpeg) == extraReward.rewardToken()) {                 availableBalance += extraReward.earned(address(this));             }         }          return availableBalance;     } ```   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "**Table of Contents:**  - [`NFTEscrow._executeTransfer()`: Cheap Contract Deployment Through Clones](#nftescrow_executetransfer-cheap-contract-deployment-through-clones) - [`LPFarming.newEpoch()`: L128 and L133 should be unchecked due to parent if/else condition](#lpfarmingnewepoch-l128-and-l133-should-be-unchecked-due-to-parent-ifelse-condition) - [`LPFarming.withdraw()`: L248 should be unchecked due to L243](#lpfarmingwithdraw-l248-should-be-unchecked-due-to-l243) - [`LPFarming._withdrawReward()`: `poolInfo[_pid].accRewardPerShare` should get cached](#lpfarming_withdrawreward-poolinfo_pidaccrewardpershare-should-get-cached) - [`yVaultLPFarming.withdraw()`: L124 should be unchecked due to L119](#yvaultlpfarmingwithdraw-l124-should-be-unchecked-due-to-l119) - [`yVaultLPFarming._withdrawReward()`: `accRewardPerShare` should get cached](#yvaultlpfarming_withdrawreward-accrewardpershare-should-get-cached) - [`JPEGLock.unlock()`: use `storage` instead of copying struct in memory L69](#jpeglockunlock-use-storage-instead-of-copying-struct-in-memory-l69) - [`FungibleAssetVaultForDAO._collateralPriceUsd()`: `oracle` should get cached](#fungibleassetvaultfordao_collateralpriceusd-oracle-should-get-cached) - [`FungibleAssetVaultForDAO._collateralPriceUsd()`: return statement should be unchecked](#fungibleassetvaultfordao_collateralpriceusd-return-statement-should-be-unchecked) - [`FungibleAssetVaultForDAO.deposit()`: `collateralAsset` should get cached](#fungibleassetvaultfordaodeposit-collateralasset-should-get-cached) - [`FungibleAssetVaultForDAO.repay)`: L184 should be unchecked due to L182](#fungibleassetvaultfordaorepay-l184-should-be-unchecked-due-to-l182) - [`FungibleAssetVaultForDAO.withdraw()`: L196 should be unchecked due to L194](#fungibleassetvaultfordaowithdraw-l196-should-be-unchecked-due-to-l194) - [`FungibleAssetVaultForDAO.withdraw()`: `collateralAmount` should get cached](#fungibleassetvaultfordaowithdraw-collateralamount-should-get-cached) - [`NFTVault._normalizeAggregatorAnswer()`: return statement should be unchecked](#nftvault_normalizeaggregatoranswer-return-statement-should-be-unchecked) - [`NFTVault._calculateAdditionalInterest()`: `totalDebtAmount` should get cached](#nftvault_calculateadditionalinterest-totaldebtamount-should-get-cached) - [`NFTVault.sol`: `struct PositionPreview` can be tightly packed to save 1 storage slot](#nftvaultsol-struct-positionpreview-can-be-tightly-packed-to-save-1-storage-slot) - [`NFTVault.showPosition()`: L659 should be unchecked due to L649](#nftvaultshowposition-l659-should-be-unchecked-due-to-l649) - [`NFTVault.showPosition()`: `positions[_nftIndex].liquidatedAt` should get cached](#nftvaultshowposition-positions_nftindexliquidatedat-should-get-cached) - [`NFTVault.showPosition()`: Help the optimizer by saving a storage variable's reference instead of repeatedly fetching it (`positions[_nftIndex]`)](#nftvaultshowposition-help-the-optimizer-by-saving-a-storage-variables-reference-instead-of-repeatedly-fetching-it-positions_nftindex) - [`NFTVault.borrow()`: `totalDebtPortion` should get cached](#nftvaultborrow-totaldebtportion-should-get-cached) - [`NFTVault.repay()`: L781 should be unchecked due to ternary operator](#nftvaultrepay-l781-should-be-unchecked-due-to-ternary-operator) - [`NFTVault.repay()`: `totalDebtPortion` and `totalDebtAmount` should get cached](#nftvaultrepay-totaldebtportion-and-totaldebtamount-should-get-cached) - [`Controller.setStrategy()`: boolean comparison L87](#controllersetstrategy-boolean-comparison-l87) - [`StrategyPUSDConvex.balanceOfJPEG()`: `jpeg` should get cached](#strategypusdconvexbalanceofjpeg-jpeg-should-get-cached) - [`StrategyPUSDConvex.balanceOfJPEG()`: use a `return` statement instead of `break`](#strategypusdconvexbalanceofjpeg-use-a-return-statement-instead-of-break) - [`StrategyPUSDConvex.withdraw()`: L281 should be unchecked due to L279](#strategypusdconvexwithdraw-l281-should-be-unchecked-due-to-l279) - [`StrategyPUSDConvex.harvest()`: L362 should be unchecked due to L359-L360 and how performanceFee is set L183](#strategypusdconvexharvest-l362-should-be-unchecked-due-to-l359-l360-and-how-performancefee-is-set-l183) - [`yVault.earn()`: `token` and `controller` should get cached](#yvaultearn-token-and-controller-should-get-cached) - [`yVault.withdraw()`: L178 should be unchecked due to L177](#yvaultwithdraw-l178-should-be-unchecked-due-to-l177) - [`yVault.withdraw()`: `token` should get cached](#yvaultwithdraw-token-should-get-cached) - [`yVault.withdrawJPEG()`: `farm` should get cached](#yvaultwithdrawjpeg-farm-should-get-cached) - [Upgrade pragma to at least 0.8.4](#upgrade-pragma-to-at-least-084) - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values) - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof) - [`>=` is cheaper than `>`](#-is-cheaper-than-) - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops) - [`++i` costs less gas compared to `i++` or `i += 1`](#i-costs-less-gas-compared-to-i-or-i--1) - [Increments can be unchecked](#increments-can-be-unchecked) - [Use `calldata` instead of `memory`](#use-calldata-instead-of-memory) - [Consider making some constants as non-public to save gas](#consider-making-some-constants-as-non-public-to-save-gas) - [Public functions to external](#public-functions-to-external) - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings) - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## `NFTEscrow._executeTransfer()`: Cheap Contract Deployment Through Clones  See `@audit` tag:  ```solidity 67:     function _executeTransfer(address _owner, uint256 _idx) internal { 68:         (bytes32 salt, ) = precompute(_owner, _idx); 69:         new FlashEscrow{salt: salt}( //@audit gas: deployment can cost less through clones  70:             nftAddress, 71:             _encodeFlashEscrowPayload(_idx) 72:         ); 73:     } ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  I suggest applying a similar pattern.  ## `LPFarming.newEpoch()`: L128 and L133 should be unchecked due to parent if/else condition  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  I suggest wrapping with an `unchecked` block here (see `@audit` tag):  ```solidity 107:     function newEpoch( ... 111:     ) external onlyOwner { 127:         if (remainingRewards > newRewards) { 128:             jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);  //@audit gas: should be unchecked (can't underflow due to L127) 129:         } else if (remainingRewards < newRewards) { 130:             jpeg.safeTransferFrom( 131:                 msg.sender, 132:                 address(this), 133:                 newRewards - remainingRewards  //@audit gas: should be unchecked (can't underflow due to L129) 134:             ); 135:         } 136:     } ```  ## `LPFarming.withdraw()`: L248 should be unchecked due to L243  See `@audit` tag:  ```solidity 235:     function withdraw(uint256 _pid, uint256 _amount) 236:         external 237:         noContract(msg.sender) 238:     { 239:         require(_amount > 0, \"invalid_amount\"); 240:  241:         PoolInfo storage pool = poolInfo[_pid]; 242:         UserInfo storage user = userInfo[_pid][msg.sender]; 243:         require(user.amount >= _amount, \"insufficient_amount\"); 244:  245:         _updatePool(_pid); 246:         _withdrawReward(_pid); 247:  248:         user.amount -= _amount;  //@audit gas: should be unchecked (can't underflow due to L243) ```  ## `LPFarming._withdrawReward()`: `poolInfo[_pid].accRewardPerShare` should get cached  The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, the storage value should get cached in memory (see the `@audit` tags for further details):  ```solidity 315:     function _withdrawReward(uint256 _pid) internal returns (uint256) { 316:         UserInfo storage user = userInfo[_pid][msg.sender]; 317:         uint256 pending = (user.amount * 318:             (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) / //@audit gas: SLOAD 1 poolInfo[_pid].accRewardPerShare 319:             1e36; 320:         if (pending > 0) { 321:             userRewards[msg.sender] += pending; 322:         } 323:  324:         user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare; //@audit gas: SLOAD 2 poolInfo[_pid].accRewardPerShare 325:  326:         return pending; 327:     } ```  ## `yVaultLPFarming.withdraw()`: L124 should be unchecked due to L119  See `@audit` tag:  ```solidity 117:     function withdraw(uint256 _amount) external noContract(msg.sender) { 118:         require(_amount > 0, \"invalid_amount\"); 119:         require(balanceOf[msg.sender] >= _amount, \"insufficient_amount\"); 120:  121:         _update(); 122:         _withdrawReward(msg.sender); 123:  124:         balanceOf[msg.sender] -= _amount;  //@audit gas: should be unchecked (can't underflow due to L119) ```  ## `yVaultLPFarming._withdrawReward()`: `accRewardPerShare` should get cached  See `@audit` tags:  ```solidity 177:     function _withdrawReward(address account) internal returns (uint256) { 178:         uint256 pending = (balanceOf[account] * 179:             (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36; //@audit gas: SLOAD 1 accRewardPerShare 180:  181:         if (pending > 0) userPendingRewards[account] += pending; 182:  183:         userLastAccRewardPerShare[account] = accRewardPerShare; //@audit gas: SLOAD 2 accRewardPerShare 184:  185:         return pending; 186:     } ```  ## `JPEGLock.unlock()`: use `storage` instead of copying struct in memory L69  See `@audit` tag:  ```solidity 68:     function unlock(uint256 _nftIndex) external nonReentrant { 69:         LockPosition memory position = positions[_nftIndex]; //@audit gas: costing 3 SLOADs while only lockAmount is needed twice. Replace \"memory\" with \"storage\" and cache only position.lockAmount  70:         require(position.owner == msg.sender, \"unauthorized\"); 71:         require(position.unlockAt <= block.timestamp, \"locked\"); 72:  73:         delete positions[_nftIndex]; 74:  75:         jpeg.safeTransfer(msg.sender, position.lockAmount); 76:  77:         emit Unlock(msg.sender, _nftIndex, position.lockAmount); 78:     } ```  Here, a copy in memory is costing 3 SLOADs and 3 MSTORES. The, 2 variables are only read once through MLOAD (`position.owner` and `position.unlockAt`) and one is read twice (`position.lockAmount`). I suggest replacing the `memory` keyword with `storage` at L69 and only copying `position.lockAmount` in memory.  ## `FungibleAssetVaultForDAO._collateralPriceUsd()`: `oracle` should get cached  See `@audit` tags:  ```solidity 104:     function _collateralPriceUsd() internal view returns (uint256) { 105:         int256 answer = oracle.latestAnswer();  //@audit gas: SLOAD 1 oracle 106:         uint8 decimals = oracle.decimals();  //@audit gas: SLOAD 2 oracle 107:  ```  ## `FungibleAssetVaultForDAO._collateralPriceUsd()`: return statement should be unchecked  See `@audit` tag:  ```solidity 104:     function _collateralPriceUsd() internal view returns (uint256) { ... 111:         return //@audit gas: whole return statement should be unchecked (obviously can't underflow/overflow here) 112:             decimals > 18 113:                 ? uint256(answer) / 10**(decimals - 18)   114:                 : uint256(answer) * 10**(18 - decimals);   115:     } ```  Due to the ternary condition and the fact that `int256 answer = oracle.latestAnswer();`, the return statement can't underflow and should be unchecked.  ## `FungibleAssetVaultForDAO.deposit()`: `collateralAsset` should get cached  See `@audit` tags:  ```solidity 141:     function deposit(uint256 amount) external payable onlyRole(WHITELISTED_ROLE) { 142:         require(amount > 0, \"invalid_amount\"); 143:  144:         if (collateralAsset == ETH) {  //@audit gas: SLOAD 1 collateralAsset 145:             require(msg.value == amount, \"invalid_msg_value\"); 146:         } else { 147:             require(msg.value == 0, \"non_zero_eth_value\"); 148:             IERC20Upgradeable(collateralAsset).safeTransferFrom(  //@audit gas: SLOAD 2 collateralAsset 149:                 msg.sender, 150:                 address(this), 151:                 amount 152:             ); 153:         } ```  ## `FungibleAssetVaultForDAO.repay)`: L184 should be unchecked due to L182  See `@audit` tag:  ```solidity 179:     function repay(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant { 180:         require(amount > 0, \"invalid_amount\"); 181:  182:         amount = amount > debtAmount ? debtAmount : amount; 183:  184:         debtAmount -= amount; //@audit gas: should be unchecked (can't underflow due to L182) ```  ## `FungibleAssetVaultForDAO.withdraw()`: L196 should be unchecked due to L194  See `@audit` tag:  ```solidity 193:     function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant { 194:         require(amount > 0 && amount <= collateralAmount, \"invalid_amount\"); 195:  196:         uint256 creditLimit = getCreditLimit(collateralAmount - amount); //@audit gas: should be unchecked (can't underflow due to L194) ```  ## `FungibleAssetVaultForDAO.withdraw()`: `collateralAmount` should get cached  See `@audit` tags:  ```solidity 193:     function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant { 194:         require(amount > 0 && amount <= collateralAmount, \"invalid_amount\");  //@audit gas: SLOAD 1 collateralAmount 195:  196:         uint256 creditLimit = getCreditLimit(collateralAmount - amount); //@audit gas: SLOAD 2 collateralAmount 197:         require(creditLimit >= debtAmount, \"insufficient_credit\"); 198:  199:         collateralAmount -= amount; //@audit gas: SLOAD 3 collateralAmount (could've used the a cached value for calculation) ```  ## `NFTVault._normalizeAggregatorAnswer()`: return statement should be unchecked  See `@audit` tag:  ```solidity 454:     function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator) 455:         internal 456:         view 457:         returns (uint256) 458:     { ... 464:         return //@audit gas: whole return statement should be unchecked (obviously can't underflow/overflow) 465:             decimals > 18 466:                 ? uint256(answer) / 10**(decimals - 18) 467:                 : uint256(answer) * 10**(18 - decimals); 468:     } ```  ## `NFTVault._calculateAdditionalInterest()`: `totalDebtAmount` should get cached  See `@audit` tags:  ```solidity 578:     function _calculateAdditionalInterest() internal view returns (uint256) { ... 585:         if (totalDebtAmount == 0) {  //@audit gas: SLOAD 1 totalDebtAmount 586:             return 0; 587:         } 588:  589:         // Accrue interest 590:         uint256 interestPerYear = (totalDebtAmount *  //@audit gas: SLOAD 2 totalDebtAmount ```  ## `NFTVault.sol`: `struct PositionPreview` can be tightly packed to save 1 storage slot  From (see `@audit` tags):  ```solidity 610:     struct PositionPreview { // @audit gas: can be tightly packed by moving borrowType and liquidatable at the end 611:         address owner; 612:         uint256 nftIndex; 613:         bytes32 nftType; 614:         uint256 nftValueUSD; 615:         VaultSettings vaultSettings; 616:         uint256 creditLimit; 617:         uint256 debtPrincipal; 618:         uint256 debtInterest; // @audit gas: 32 bytes 619:         BorrowType borrowType; // @audit gas: 1 byte (this enum is equivalent to uint8 as it has less than 256 options) 620:         bool liquidatable; // @audit gas: 1 byte 621:         uint256 liquidatedAt; // @audit gas: 32 bytes 622:         address liquidator; // @audit gas: 20 bytes 623:     } ```  To:  ```solidity     struct PositionPreview {         address owner;         uint256 nftIndex;         bytes32 nftType;         uint256 nftValueUSD;         VaultSettings vaultSettings;         uint256 creditLimit;         uint256 debtPrincipal;         uint256 debtInterest; // @audit gas: 32 bytes         uint256 liquidatedAt; // @audit gas: 32 bytes         BorrowType borrowType; // @audit gas: 1 byte (this enum is equivalent to uint8 as it has less than 256 options)         bool liquidatable; // @audit gas: 1 byte         address liquidator; // @audit gas: 20 bytes     } ```  ## `NFTVault.showPosition()`: L659 should be unchecked due to L649  See `@audit` tag:  ```solidity File: NFTVault.sol 628:     function showPosition(uint256 _nftIndex) ... 649:         if (debtPrincipal > debtAmount) debtAmount = debtPrincipal; ... 659:             debtInterest: debtAmount - debtPrincipal, //@audit gas: should be unchecked (can't underflow due to L649) ```  ## `NFTVault.showPosition()`: `positions[_nftIndex].liquidatedAt` should get cached  See `@audit` tags:  ```solidity File: NFTVault.sol 628:     function showPosition(uint256 _nftIndex) ... 661:             liquidatable: positions[_nftIndex].liquidatedAt == 0 &&  //@audit gas: SLOAD 1 positions[_nftIndex].liquidatedAt 662:                 debtAmount >= _getLiquidationLimit(_nftIndex), 663:             liquidatedAt: positions[_nftIndex].liquidatedAt,  //@audit gas: SLOAD 2 positions[_nftIndex].liquidatedAt ```  ## `NFTVault.showPosition()`: Help the optimizer by saving a storage variable's reference instead of repeatedly fetching it (`positions[_nftIndex]`)  To help the optimizer, declare a `storage` type variable and use it instead of repeatedly fetching the reference in a map or an array.  The effect can be quite significant.  Here, instead of repeatedly calling `positions[_nftIndex]`, save its reference like this: `Position storage _position = positions[_nftIndex]` and use it.  Impacted lines (see `@audit` tags):  ```solidity   636:         uint256 debtPrincipal = positions[_nftIndex].debtPrincipal; //@audit gas: use the suggested storage variable \"Position storage _position\"   637:         uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0 //@audit gas: use the suggested storage variable \"Position storage _position\"   638:             ? positions[_nftIndex].debtAmountForRepurchase //@audit gas: use the suggested storage variable \"Position storage _position\"   641:                 positions[_nftIndex].debtPortion, //@audit gas: use the suggested storage variable \"Position storage _position\"   660:             borrowType: positions[_nftIndex].borrowType, //@audit gas: use the suggested storage variable \"Position storage _position\"   661:             liquidatable: positions[_nftIndex].liquidatedAt == 0 && //@audit gas: use the suggested storage variable \"Position storage _position\"   663:             liquidatedAt: positions[_nftIndex].liquidatedAt, //@audit gas: use the suggested storage variable \"Position storage _position\"   664:             liquidator: positions[_nftIndex].liquidator //@audit gas: use the suggested storage variable \"Position storage _position\" ```  This practice already exists in the solution, as seen in `NFTVault.borrow()`:  ```solidity 675:     function"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/90", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "1. It was found some `transfer` or `transferFrom` without checking the boolean result, ERC20 standard specify that the token can return false if this call was not made, so it's mandatory to check the result of approve methods. - [NFTVault.sol#L899](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L899) - [JPEGStaking.sol#L34](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/staking/JPEGStaking.sol#L34) - [JPEGStaking.sol#L52](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/staking/JPEGStaking.sol#L52)  2. Lack of input checks. - [LPFarming.sol#L77](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L77) "}, {"title": "Reentrancy issue in `yVault.deposit`", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/81", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L144-L145   # Vulnerability details  ## Impact In `deposit`, the balance is cached and then a `token.transferFrom` is triggered which can lead to exploits if the `token` is a token that gives control to the sender, like ERC777 tokens.  #### POC Initial state: `balance() = 1000`, shares `supply = 1000`. Depositing 1000 amount should mint 1000 supply, but one can split the 1000 amounts into two 500 deposits and use re-entrancy to profit.  - Outer `deposit(500)`: `balanceBefore = 1000`. Control is given to attacker ... - Inner `deposit(500)`: `balanceBefore = 1000`. `shares = (_amount * supply) / balanceBefore = 500 * 1000 / 1000 = 500` shares are minted ... - Outer `deposit(500)` continues with the mint: `shares = (_amount * supply) / balanceBefore = 500 * 1500 / 1000 = 750` are minted. - Withdrawing the `500 + 750 = 1250` shares via `withdraw(1250)`, the attacker receives `backingTokens = (balance() * _shares) / supply = 2000 * 1250 / 2250 = 1111.111111111`. The attacker makes a profit of `1111 - 1000 = 111` tokens. - They repeat the attack until the vault is drained.  ## Recommended Mitigation Steps The `safeTransferFrom` should be the last call in `deposit`.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/79", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L799   # Vulnerability details  ## Impact The owner of an **insured** position that has been liquidated can claim back their NFT without paying back the debt by calling `closePosition` instead of `repurchase`.  ```solidity function closePosition(uint256 _nftIndex)     external     // @audit NFT is still valid (ownerOf(nft) == this)     validNFTIndex(_nftIndex) {     accrue();     // @audit owner is still original owner (depositor)     require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");     // @audit debt is zero as it's been repaid by liquidator     require(_getDebtAmount(_nftIndex) == 0, \"position_not_repaid\");      positionOwner[_nftIndex] = address(0);     delete positions[_nftIndex];     positionIndexes.remove(_nftIndex);      // transfer nft back to owner if nft was deposited     if (nftContract.ownerOf(_nftIndex) == address(this)) {         nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);     }      emit PositionClosed(msg.sender, _nftIndex); } ```  The `liquidate` function sets `position.debtPortion = 0;` and does not clear the `owner` which means all `closePosition` checks pass. This means that PUSD can be minted for free by:  - Attacker deposits NFT collateral in insured state and borrow PUSD against it - Let it be liquidated (the liquidator unexpectedly loses as they cannot get the NFT through `claimExpiredInsuranceNFT` anymore) - Attacker claims it back through `closePosition` - Repeat  ## Recommended Mitigation Steps Consider checking in `closePosition` that the position has not been liquidated.   "}, {"title": "`setDebtInterestApr` should accrue debt first", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/78", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/NFTVault.sol#L212   # Vulnerability details  ## Impact The `setDebtInterestApr` changes the debt interest rate without first accruing the debt. This means that the new debt interest rate is applied retroactively to the unaccrued period on next `accrue()` call.  It should never be applied retroactively to a previous time window as this is unfair & wrong. Borrowers can incur more debt than they should.  ## Recommended Mitigation Steps Call `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`.  "}, {"title": "Controller: Strategy migration will fail", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/57", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/Controller.sol#L95 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L266   # Vulnerability details  ## Details  The controller calls the `withdraw()` method to withdraw JPEGs from the contract, but the strategy might blacklist the JPEG asset, which is what the PUSDConvex strategy has done.  The migration would therefore revert.  ## Proof of Concept  Insert this test into [`StrategyPUSDConvex.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/StrategyPUSDConvex.ts).  ```jsx it.only(\"will revert when attempting to migrate strategy\", async () => {   await controller.setVault(want.address, yVault.address);   await expect(controller.setStrategy(want.address, strategy.address)).to.be.revertedWith(\"jpeg\"); }); ```  ## Recommended Mitigation Steps  Replace `_current.withdraw(address(jpeg));` with `_current.withdrawJPEG(vaults[_token])`.  "}, {"title": "yVaultLPFarming: No guarantee JPEG currentBalance > previousBalance", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/56", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/yVaultLPFarming.sol#L169-L170   # Vulnerability details  ## Details & Impact  yVault users participating in the farm have to trust that:  - `vault.balanceOfJPEG()`  returns the correct claimable JPEG amount by its strategy / strategies - the strategy / strategies will send all claimable JPEG to the farm  Should either of these assumptions break, then it could be possibly be the case that `currentBalance` is less than `previousBalance`, causing deposits and crucially, withdrawals to fail due to subtraction overflow.  ## Proof of Concept  For instance,   - Farm migration occurs. A new farm is set in `yVault`, then `withdrawJPEG()` is called, which sends funds to the new farm. Users of the old farm would be unable to withdraw their deposits.  ```jsx it.only(\"will revert old farms' deposits and withdrawals if yVault migrates farm\", async () => {   // 0. setup   await token.mint(owner.address, units(1000));   await token.approve(yVault.address, units(1000));   await yVault.depositAll();   await yVault.approve(lpFarming.address, units(1000));   // send some JPEG to strategy prior to deposit   await jpeg.mint(strategy.address, units(100));   // deposit twice, so that the second deposit will invoke _update()   await lpFarming.deposit(units(250));   await lpFarming.deposit(units(250));     // 1. change farm and call withdrawJPEG()   await yVault.setFarmingPool(user1.address);   await yVault.withdrawJPEG();     // deposit and withdrawal will fail   await expect(lpFarming.deposit(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)');   await expect(lpFarming.withdraw(units(500))).to.be.revertedWith('reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)'); }); ```  - Strategy migration occurs, but JPEG funds held by the old strategy were not claimed, causing `vault.balanceOfJPEG()` to report a smaller amount than previously recorded - `jpeg` could be accidentally included in the StrategyConfig, resulting in JPEG being converted to other assets - A future implementation takes a fee on the `jpeg` to be claimed  ## Recommended Mitigation Steps  A simple fix would be to `return` if `currentBalance \u2264 previousBalance`. A full fix would properly handle potential shortfall.  ```jsx if (currentBalance <= previousBalance) return; ```  "}, {"title": "Oracle data feed is insufficiently validated.", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L105   # Vulnerability details  ## Impact Price can be stale and can lead to wrong `answer` return value.  ## Proof of Concept Oracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong  `answer`  return value.  ``` function _collateralPriceUsd() internal view returns (uint256) {         int256 answer = oracle.latestAnswer();         uint8 decimals = oracle.decimals();          require(answer > 0, \"invalid_oracle_answer\");          ...  ```  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L105  ## Tools Used Manual review ## Recommended Mitigation Steps Validate data feed  ``` function _collateralPriceUsd() internal view returns (uint256) {  (uint80 roundID, int256 answer, , uint256 timestamp, uint80 answeredInRound) = oracle.latestRoundData();         require(answer > 0, \"invalid_oracle_answer\");     require(answeredInRound >= roundID, \"ChainLink: Stale price\");     require(timestamp > 0, \"ChainLink: Round not complete\");           ...  ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/39", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L201   # Vulnerability details  ## Impact  Function `FungibleAssetVaultForDAO.withdraw` in line 201 uses native `transfer` function to send ETH to `msg.sender`.  This is unsafe as transfer has hard coded gas budget (2300 gas) and can fail when the user is a smart contract. Especially when this contract is for DAO and ecosystem contracts as documentation.   ## Proof-of-concept https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L201   ## Tools Used Manual code review  ## Recommended Mitigation Steps  All functions have a `nonReentrant` modifier already, so reentrancy is not an issue and `transfer()` can be replaced.  Using low-level call.value(amount) with the corresponding result check or using the OpenZeppelin Address.sendValue is advised https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/22", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/JPEG.sol#L20 Consider added valid check for the to address. The to address can be of a contract or another token or user. See below test code to replicate the behavior it(\"should return the correct JPEG balance\", async () => {     await controller.approveStrategy(token.address, strategy.address);     await controller.setStrategy(token.address, strategy.address);     await jpeg.mint(token.address, units(500)); --- the to address can be any address.     expect(await controller.balanceOfJPEG(token.address)).to.equal(units(500)); });  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L115 setFarmingPool is declared public but not called from within the contract. Consider makin it external. Public visiility will persist the parameters which can incurr as fees.  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L35 The whitelistedContractMap is not necessary. It can be an address array. If contract is whitelisted, then add to array, if not, remove it. Removing the extra flag will save some space in the contract.  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L187 Function withdrawJPEG() seems duplicate of Controller.withdrawJPEG() and is not necessay. Remove the function or make it a utility.  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L61 Modifier noContract() is duplicated, can be abstracted out  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/tokens/yVault.sol#L89 setContractWhitelisted is duplicated, can be abstracted out"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/21", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "Use ```assert``` instead of ```require``` https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/helpers/CryptoPunksHelper.sol#L79 https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/helpers/EtherRocksHelper.sol#L81   ## proof of concept  https://ethereum.stackexchange.com/questions/15166/difference-between-require-and-assert-and-the-difference-between-revert-and-thro "}, {"title": "rewards will be locked if user transfer directly to pool without using deposit function ", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/19", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/LPFarming.sol#L190   # Vulnerability details  ## Impact ###### LpFarming.sol reward will be locked in the farming, when user execute a direct transfer with lpToken to farm without using deposit    ## Proof of Concept \"pls add this test to LpFarming.ts to check\"   ``` it(\"a part of rewards can't be distributed if user execute a direct transfer to farm\", async() => {       // manual mine new block         await network.provider.send(\"evm_setAutomine\", [false]);        // prepare        const attacker = bob;       await lpTokens[0].transfer(alice.address, units(1000));       await lpTokens[0].transfer(attacker.address, units(1000));       await lpTokens[0].connect(alice).approve(farming.address, units(1000));       await mineBlocks(1);        // attacker direct deposit lp token to the pool        await lpTokens[0].connect(attacker).transfer(farming.address, units(100));        // create new pool       await farming.add(10, lpTokens[0].address);       await mineBlocks(1);       expect(await farming.poolLength()).to.equal(1);        let pool = await farming.poolInfo(0);       expect(pool.lpToken).to.equal(lpTokens[0].address);       expect(pool.allocPoint).to.equal(10);        // create new epoch ==> balance of pool will be 1000        let blockNumber = await ethers.provider.getBlockNumber();       await farming.newEpoch(blockNumber + 1, blockNumber + 11, 100);        // alice deposit        await farming.connect(alice).deposit(0, units(100));       await mineBlocks(1);        expect(await jpeg.balanceOf(farming.address)).to.equal(1000);        // when pool end, alice can just take 500 jpeg, and 500 jpeg will be locked in the contract forever !!!       await mineBlocks(13);       console.log(\"reward of alice: \", (await   farming.pendingReward(0, alice.address)).toString());       expect(await farming.pendingReward(0, alice.address)).to.equal(BigNumber.from('500'));     }); ``` In the test above, the attacker transfers 100 lpToken to the farm without using deposit function, and alice deposit 100 lpToken. Because the contract uses ```pool.lpToken.balanceOf(address(this))``` to get the total supply of lpToken in the pool, it will sum up 100 lpToken of attacker and 100 lpToken of alice. This will lead to the situation where Alice will only be able to claim 500 token (at epoch.endBlock), the rest will be locked in the pool forever. Not only with this pool, it also affects the following, a part of the reward will be locked in the pool when the farm end.  ## Tools Used typescript   ## Recommended Mitigation Steps Declare a new variable ```totalLPSupply``` to the struct ```PoolInfo```, and use it instead of ```pool.lpToken.balanceOf(address(this))```   "}, {"title": "yVault: First depositor can break minting of shares", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/12", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/yVault.sol#L148-L153   # Vulnerability details  ## Details  The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large \u201cdonation\u201d.  ## Proof of Concept  - Attacker deposits 1 wei to mint 1 share - Attacker transfers exorbitant amount to the `StrategyPUSDConvex` contract to greatly inflate the share\u2019s price. Note that the strategy deposits its entire balance into Convex when its `deposit()` function is called. - Subsequent depositors instead have to deposit an equivalent sum to avoid minting 0 shares. Otherwise, their deposits accrue to the attacker who holds the only share.  Insert this test into [`yVault.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/yVault.ts).  ```jsx it.only(\"will cause 0 share issuance\", async () => {   // mint 10k + 1 wei tokens to user1   // mint 10k tokens to owner   let depositAmount = units(10_000);   await token.mint(user1.address, depositAmount.add(1));   await token.mint(owner.address, depositAmount);   // token approval to yVault   await token.connect(user1).approve(yVault.address, 1);   await token.connect(owner).approve(yVault.address, depositAmount);      // 1. user1 mints 1 wei = 1 share   await yVault.connect(user1).deposit(1);      // 2. do huge transfer of 10k to strategy   // to greatly inflate share price (1 share = 10k + 1 wei)   await token.connect(user1).transfer(strategy.address, depositAmount);      // 3. owner deposits 10k   await yVault.connect(owner).deposit(depositAmount);   // receives 0 shares in return   expect(await yVault.balanceOf(owner.address)).to.equal(0);    // user1 withdraws both his and owner's deposits   // total amt: 20k + 1 wei   await expect(() => yVault.connect(user1).withdrawAll())     .to.changeTokenBalance(token, user1, depositAmount.mul(2).add(1)); }); ```  ## Recommended Mitigation Steps  - [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. - Ensure the number of shares to be minted is non-zero: `require(_shares != 0, \"zero shares minted\");`  "}, {"title": "The noContract modifier does not work as expected.", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/vaults/yVault/yVault.sol#L61 https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/farming/yVaultLPFarming.sol#L54 https://github.com/code-423n4/2022-04-jpegd/blob/59e288c27e1ff1b47505fea2e5434a7577d85576/contracts/vaults/yVault/yVault.sol#L61   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  The expectation of the noContract modifier is to allow access only to accounts inside EOA or Whitelist, if access is controlled using ! access control with _account.isContract(), then because isContract() gets the size of the code length of the account in question by relying on extcodesize/address.code.length, this means that the restriction can be bypassed when deploying a smart contract through the smart contract's constructor call.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  ## Recommended Mitigation Steps  Modify the code to `require(msg.sender == tx.origin);`  "}, {"title": "Existing user\u2019s locked JPEG could be overwritten by new user, causing permanent loss of JPEG funds", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/10", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L375 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/lock/JPEGLock.sol#L54-L62   # Vulnerability details  ## Details & Impact  A user\u2019s JPEG lock schedule can be overwritten by another user\u2019s if he (the other user) submits and finalizes a proposal to change the same NFT index\u2019s value.  The existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.  ## Proof of Concept  1. `user` successfully proposes and finalizes a proposal to change his NFT\u2019s collateral value 2. Another user (`owner`) does the same for the same NFT index 3. `user` will be unable to withdraw his locked JPEG because schedule has been overwritten  Insert this test case into [`NFTVault.ts`](https://github.com/code-423n4/2022-04-jpegd/blob/main/tests/NFTVault.ts).  ```jsx it.only(\"will overwrite existing user's JPEG lock schedule\", async () => {   // 0. setup   const index = 7000;   await erc721.mint(user.address, index);   await nftVault     .connect(dao)     .setPendingNFTValueETH(index, units(50));   await jpeg.transfer(user.address, units(150000));   await jpeg.connect(user).approve(locker.address, units(500000));   await jpeg.connect(owner).approve(locker.address, units(500000));    // 1. user has JPEG locked for finalization   await nftVault.connect(user).finalizePendingNFTValueETH(index);    // 2. owner submit proposal to further increase NFT value   await nftVault     .connect(dao)     .setPendingNFTValueETH(index, units(100));      // 3. owner finalizes, has JPEG locked   await nftVault.connect(owner).finalizePendingNFTValueETH(index);    // user schedule has been overwritten   let schedule = await locker.positions(index);   expect(schedule.owner).to.equal(owner.address);    // user tries to unstake   // wont be able to because schedule was overwritten   await timeTravel(days(366));   await expect(locker.connect(user).unlock(index)).to.be.revertedWith(\"unauthorized\"); }); ```  ## Recommended Mitigation Steps  1. Release the tokens of the existing schedule. Simple and elegant.  ```jsx // in JPEGLock#lockFor() LockPosition memory existingPosition = positions[_nftIndex]; if (existingPosition.owner != address(0)) {   // release jpegs to existing owner   jpeg.safeTransfer(existingPosition.owner, existingPosition.lockAmount); } ```  2. Revert in `finalizePendingNFTValueETH()` there is an existing lock schedule. This is less desirable IMO, as there is a use-case for increasing / decreasing the NFT value.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/6", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L675 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L560   # Vulnerability details  ## Impact In `NFTVault.sol` the `borrow()` function does not follow the Checks Effects Interactions pattern. There are important state updates that occur after an external call which happens in `_openPosition()`.  Assuming that the `nonReentrant` modifier makes this ok is false due to the threat of cross function reentrancy. `require` checks should be done followed by state updates and then any external calls in accord with the Checks Effects Interactions pattern  ## Proof of Concept  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L675  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L560  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  ## Tools Used Manual code review   ## Recommended Mitigation Steps The `borrow()` function should fully implement the Checks Effects Interactions pattern performing all external calls last and not making important state updates after external calls.   "}, {"title": "Chainlink pricer is using a deprecated API", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/FungibleAssetVaultForDAO.sol#L105   # Vulnerability details  ## Impact According to Chainlink's documentation, the latestAnswer function is deprecated. This function might suddenly stop working if Chainlink stop supporting deprecated APIs. And the old API can return stale data.  ## Proof of Concept https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/FungibleAssetVaultForDAO.sol#L105 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/NFTVault.sol#L459 ## Tools Used None ## Recommended Mitigation Steps Use the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete https://docs.chain.link/docs/price-feeds-api-reference/  "}, {"title": "When _lpToken is jpeg, reward calculation is incorrect", "html_url": "https://github.com/code-423n4/2022-04-jpegd-findings/issues/1", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-jpegd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L141-L154   # Vulnerability details  ## Impact In the LPFarming contract, a new staking pool can be added using the add() function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the _lpToken is the same as the reward token (jpeg) or not. ```     function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {         _massUpdatePools();          uint256 lastRewardBlock = _blockNumber();         totalAllocPoint = totalAllocPoint + _allocPoint;         poolInfo.push(             PoolInfo({                 lpToken: _lpToken,                 allocPoint: _allocPoint,                 lastRewardBlock: lastRewardBlock,                 accRewardPerShare: 0             })         );     } ```  When the _lpToken is the same token as jpeg, reward calculation for that pool in the updatePool() function can be incorrect. This is because the current balance of the _lpToken in the contract is used in the calculation of the reward. Since the _lpToken is the same token as the reward, the reward minted to the contract will inflate the value of lpSupply, causing the reward of that pool to be less than what it should be. ```     function _updatePool(uint256 _pid) internal {         PoolInfo storage pool = poolInfo[_pid];         if (pool.allocPoint == 0) {             return;         }          uint256 blockNumber = _blockNumber();         //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch         uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);         if (blockNumber <= lastRewardBlock) {             return;         }         uint256 lpSupply = pool.lpToken.balanceOf(address(this));         if (lpSupply == 0) {             pool.lastRewardBlock = blockNumber;             return;         }         uint256 reward = ((blockNumber - lastRewardBlock) *             epoch.rewardPerBlock *             1e36 *             pool.allocPoint) / totalAllocPoint;         pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;         pool.lastRewardBlock = blockNumber;     } ```  ## Proof of Concept https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L141-L154 https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/farming/LPFarming.sol#L288-L311 ## Tools Used None  ## Recommended Mitigation Steps  Add a check that _lpToken is not jpeg in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/134", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "## Low Risk Issues  ### Loans can be created and paid with non-existent/destructed tokens `@rari-capital/solmate/src/utils/SafeTransferLib.sol` has functions named similarly to functions that OpenZeppelin has, but they act differently. At the top of the file is the following comment: ```solidity /// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller. ``` https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/utils/SafeTransferLib.sol#L9  If the caller of these functions does not check that the token has code, calls to these functions will be no-ops, since low level calls to non-contracts always return success. There are many instances of these calls throughout the file with no code existence checks: ``` contracts/NFTLoanFacilitator.sol:155:            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount); contracts/NFTLoanFacilitator.sol:157:            ERC20(loanAssetContractAddress).safeTransfer( contracts/NFTLoanFacilitator.sol:200:                ERC20(loanAssetContractAddress).safeTransferFrom( contracts/NFTLoanFacilitator.sol:205:                ERC20(loanAssetContractAddress).safeTransfer( contracts/NFTLoanFacilitator.sol:210:                ERC20(loanAssetContractAddress).safeTransfer( contracts/NFTLoanFacilitator.sol:215:                ERC20(loan.loanAssetContractAddress).safeTransferFrom( contracts/NFTLoanFacilitator.sol:241:        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount); contracts/NFTLoanFacilitator.sol:242:        IERC721(loan.collateralContractAddress).safeTransferFrom( contracts/NFTLoanFacilitator.sol:262:        IERC721(loan.collateralContractAddress).safeTransferFrom( contracts/NFTLoanFacilitator.sol:297:        ERC20(asset).safeTransfer(to, amount); ```  ### `originationFeeRate`s of less than 1000 may charge no fees if amounts are small 1. File: contracts/NFTLoanFacilitator.sol (line [156](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L156)) ```solidity             uint256 facilitatorTake = amount * originationFeeRate / SCALAR; ``` Add a `require()` for `facilitatorTake` to be non-zero if `originationFeeRate` is non-zero, or state the fee logic for small amounts  ### A malicious owner can keep the fee rate at zero, but if a large value transfer enters the mempool, the owner can jack the rate up to the maximum 1. File: contracts/NFTLoanFacilitator.sol (lines [306-312](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L306-L312)) ```solidity     function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {         require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\");                  originationFeeRate = _originationFeeRate;          emit UpdateOriginationFeeRate(_originationFeeRate);     } ``` Store the fee rate during loan creation, along with the maximum fee rate the user will allow, and update to the new rate for that particular loan only when loans are bought out  ### A malicious owner can set an effectively infinite improvement rate with `type(uint256).max` after he/she has entered into a loan to prevent others from buying them out 1. File: contracts/NFTLoanFacilitator.sol (lines [320-326](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L320-L326)) ```solidity     function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {         require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');          requiredImprovementRate = _improvementRate;          emit UpdateRequiredImprovementRate(_improvementRate);     } ``` Have a sane upper limit to the improvement rate, and don't allow it to change as above  ### `tokenURI()` reverts for tokens that don't implement `IERC20Metadata` While the ticket descriptors are not in scope, the code calling them is. `NFTLoanTicket.tokenURI()`, which is in scope, ends up calling descriptor code which casts the asset to `IERC20Metadata`. This interface is separate from `IERC20` because EIP-20 does not require those functions to exist. If a valid ERC20 token does not implement this interface, casting it and attempting to call non-existant functions will cause the code to revert, which will cause `tokenURI()` to revert. https://github.com/code-423n4/2022-04-backed/blob/d34ddbdaf8d1bc1bf17446df830db629ee551308/contracts/descriptors/libraries/PopulateSVGParams.sol#L65 https://github.com/code-423n4/2022-04-backed/blob/d34ddbdaf8d1bc1bf17446df830db629ee551308/contracts/descriptors/libraries/PopulateSVGParams.sol#L69 https://github.com/code-423n4/2022-04-backed/blob/d34ddbdaf8d1bc1bf17446df830db629ee551308/contracts/descriptors/libraries/PopulateSVGParams.sol#L83 Use [`safeDecimals()`](https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L33-L55) etc  ### `_safeMint()` should be used rather than `_mint()` wherever possible `_mint()` is [discouraged](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271) in favor of `_safeMint()` which ensures that the recipient is either an EOA or implements `IERC721Receiver`. Both open [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L238-L250) and [solmate](https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L180) have versions of this function so that NFTs aren't lost if they're minted to contracts that cannot transfer them back out.  1. File: contracts/NFTLoanTicket.sol (line [34](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanTicket.sol#L34)) ```solidity         _mint(to, tokenId); ```  ### `loanFacilitatorTransfer()` does not verify that the receiver is capable of handling an NFT EIP-721 states: ```solidity     /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE     ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE     ///  THEY MAY BE PERMANENTLY LOST ``` https://github.com/ethereum/EIPs/blob/904be2534386631358766607f4a098e11a401e95/EIPS/eip-721.md?plain=1#L103-L105  The code below was copied from `transferFrom()`, so any function calling `_transfer()` needs to confirm that `to` is capable of receiving NFTs. `loanFacilitatorTransfer()` calls `_transfer()` without completing this check, which can lead to the loss of NFTs. Checking if the address is zero or not is not sufficient; it needs the other checks in [`safeTransferFrom()`](https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L105-L110). 1. File: contracts/LendTicket.sol (lines [24-34](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/LendTicket.sol#L24-L34)) ```solidity     /// @dev exact copy of      /// https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol#L69-L96     /// with L78 - L81 removed to enable loanFacilitatorTransfer     function _transfer(         address from,         address to,         uint256 id     ) internal {         require(from == ownerOf[id], \"WRONG_FROM\");          require(to != address(0), \"INVALID_RECIPIENT\"); ```  ### Missing checks for `address(0x0)` when assigning values to `address` state variables  1. File: contracts/NFTLoanFacilitator.sol (line [282](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L282)) ```solidity         lendTicketContract = _contract; ``` 2. File: contracts/NFTLoanFacilitator.sol (line [292](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L292)) ```solidity         borrowTicketContract = _contract; ```  ## Non-critical Issues   ### `constant`s should be defined rather than using magic numbers  1. File: contracts/NFTLoanFacilitator.sol (line [307](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L307)) ```solidity         require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\"); ``` 2. File: contracts/NFTLoanFacilitator.sol (line [384](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L384)) ```solidity             * (perAnumInterestRate * 1e18 / 365 days) ``` 3. File: contracts/NFTLoanFacilitator.sol (line [384](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L384)) ```solidity             * (perAnumInterestRate * 1e18 / 365 days) ``` 4. File: contracts/NFTLoanFacilitator.sol (line [385](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L385)) ```solidity             / 1e21 // SCALAR * 1e18 ```  ### Typos  1. File: contracts/NFTLoanFacilitator.sol (line [303](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L303)) ```solidity      * @notice Updates originationFeeRate the faciliator keeps of each loan amount ``` faciliator  2. File: contracts/interfaces/INFTLoanFacilitator.sol (line [65](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L65)) ```solidity      * @param minLoanAmount mimimum loan amount ``` mimimum   ### NatSpec is incomplete  1. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [286-288](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L286-L288)) ```solidity      * @param loanId The loan id      */     function totalOwed(uint256 loanId) view external returns (uint256); ``` Missing: `@return`   2. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [292-294](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L292-L294)) ```solidity      * @param loanId The loan id      */     function interestOwed(uint256 loanId) view external returns (uint256); ``` Missing: `@return`   3. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [298-300](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L298-L300)) ```solidity      * @param loanId The loan id      */     function loanEndSeconds(uint256 loanId) view external returns (uint256); ``` Missing: `@return`    ### Event is missing `indexed` fields Each `event` should use three `indexed` fields if there are three or more fields  1. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [68-77](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L68-L77)) ```solidity     event CreateLoan(         uint256 indexed id,         address indexed minter,         uint256 collateralTokenId,         address collateralContract,         uint256 maxInterestRate,         address loanAssetContract,         uint256 minLoanAmount,         uint256 minDurationSeconds         ); ``` 2. File: contracts/interfaces/INFTLoanFacilitator.sol (lines [93-99](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L93-L99)) ```solidity     event Lend(         uint256 indexed id,         address indexed lender,         uint256 interestRate,         uint256 loanAmount,         uint256 durationSeconds     ); ``` 3. File: contracts/interfaces/INFTLoanFacilitator.sol (line [145](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L145)) ```solidity      event WithdrawOriginationFees(address asset, uint256 amount, address to); ``` 4. File: contracts/interfaces/INFTLoanFacilitator.sol (line [152](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L152)) ```solidity      event UpdateOriginationFeeRate(uint32 feeRate); ``` 5. File: contracts/interfaces/INFTLoanFacilitator.sol (line [159](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/interfaces/INFTLoanFacilitator.sol#L159)) ```solidity      event UpdateRequiredImprovementRate(uint256 improvementRate); ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# QA Report  1. Immutable addresses should be 0-checked  Consider adding an `address(0)` check here:  ```solidity File: NFTLoanTicket.sol 20:     constructor( 21:         string memory name,  22:         string memory symbol,  23:         NFTLoanFacilitator _nftLoanFacilitator,  24:         NFTLoansTicketDescriptor _descriptor 25:     )  26:         ERC721(name, symbol)  27:     { 28:         nftLoanFacilitator = _nftLoanFacilitator;  //@audit low: should be 0 checked 29:         descriptor = _descriptor;  //@audit low: should be 0 checked 30:     } ```  2. `NFTLoanFacilitator.sol` uses `Ownable`'s default `transferOwnership()` instead of implementing a 2-step ownership transfer pattern  3. `renounceOwnership()` can be called in `NFTLoanFacilitator.sol`. Consider overriding the method to always keep an owner.  4. Comment says \"private\" instead of \"internal\" :  ```solidity File: NFTLoanFacilitator.sol 369:     // === private === //@audit should say internal 370:  371:     /// @dev Returns the total interest owed on loan 372:     function _interestOwed( 373:         uint256 loanAmount, 374:         uint256 lastAccumulatedTimestamp, 375:         uint256 perAnumInterestRate, 376:         uint256 accumulatedInterest 377:     )  378:         internal  379:         view  380:         returns (uint256)  381:     { ```  5. `onERC721Received` not implemented in `borrowTicketContract` (`BorrowTicket.sol`)  The `IERC721.safeTransferFrom` call will trigger `onERC721Received` here:  ```solidity File: NFTLoanFacilitator.sol 242:         IERC721(loan.collateralContractAddress).safeTransferFrom( 243:             address(this), 244:             IERC721(borrowTicketContract).ownerOf(loanId), 245:             loan.collateralTokenId 246:         ); ```  It must return its Solidity `selector` to confirm the token transfer. If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.  The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.  6. Code style: some strings are declared with `''`, others with `\"\"`. I suggest only using one style.  Strings with `''`:  ``` contracts/NFTLoanFacilitator.sol:    81:         require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');    82:         require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');    84:         'NFTLoanFacilitator: cannot use tickets as collateral');    86:         'NFTLoanFacilitator: cannot use tickets as collateral');   146:             require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');   147:             require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');   148:             require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');   171:                 require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');   172:                 require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');   280:         require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');   290:         require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');   321:         require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate'); ```  Strings with `\"\"`:  ``` contracts/LendTicket.sol:   32:         require(from == ownerOf[id], \"WRONG_FROM\");   34:         require(to != address(0), \"INVALID_RECIPIENT\");  contracts/NFTLoanFacilitator.sol:    53:         require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\");   118:         \"NFTLoanFacilitator: borrow ticket holder only\");   121:         require(loan.lastAccumulatedTimestamp == 0, \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\");   144:             require(loanAssetContractAddress != address(0), \"NFTLoanFacilitator: invalid loan\");   178:                 \"NFTLoanFacilitator: proposed terms must be better than existing terms\");   189:             \"NFTLoanFacilitator: accumulated interest exceeds uint128\");   255:         \"NFTLoanFacilitator: lend ticket holder only\");   259:         \"NFTLoanFacilitator: payment is not late\");   307:         require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\");   contracts/NFTLoanTicket.sol:   15:         require(msg.sender == address(nftLoanFacilitator), \"NFTLoanTicket: only loan facilitator\"); ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/120", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "Thanks for a very well documented and tested codebase.  Just one note to pass on here: there's a typo in the terms `maxPerAnumInterest` and `perAnumInterestRate`, which are used in a few places in the codebase. This should be \"per annum\" to mean \"per year.\" (Or just consider \"per year\" or \"annual\" in English instead). The phrase \"per anum\" is a medical term that means something entirely different :)"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/103", "labels": ["bug", "duplicate", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Gas optimization report  ## Keep revert strings below 32 bytes  Strings are stored in slots of 32 bytes, and hence the length of the revert string should be at max 32 bytes to fit inside 1 slot. If the string is just 33 bytes it will occupy 2 slots (64 bytes). Keeping the string size at 32 bytes or below will save gas on both deployment and when the revert condition is met.  Since the used version of Solidity is `>=0.8.4` it would also be worth considering using [Custom Errors](https://blog.soliditylang.org/2021/04/21/custom-errors/) which is both more gas efficient and allows thorough error descriptions using [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html).  The relevant code:  ``` NFTLoanFacilitator.sol line 84:   \"NFTLoanFacilitator: cannot use tickets as collateral\" NFTLoanFacilitator.sol line 86:   \"NFTLoanFacilitator: cannot use tickets as collateral\" NFTLoanFacilitator.sol line 118:  \"NFTLoanFacilitator: borrow ticket holder only\" NFTLoanFacilitator.sol line 121:  \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\" NFTLoanFacilitator.sol line 146:  \"NFTLoanFacilitator: rate too high\" NFTLoanFacilitator.sol line 147:  \"NFTLoanFacilitator: duration too low\" NFTLoanFacilitator.sol line 148:  \"NFTLoanFacilitator: amount too low\" NFTLoanFacilitator.sol line 171:  \"NFTLoanFacilitator: rate too high\" NFTLoanFacilitator.sol line 172:  \"NFTLoanFacilitator: duration too low\" NFTLoanFacilitator.sol line 178:  \"NFTLoanFacilitator: proposed terms must be better than existing terms\" NFTLoanFacilitator.sol line 189:  \"NFTLoanFacilitator: accumulated interest exceeds uint128\" NFTLoanFacilitator.sol line 255:  \"NFTLoanFacilitator: lend ticket holder only\" NFTLoanFacilitator.sol line 259:  \"NFTLoanFacilitator: payment is not late\" NFTLoanFacilitator.sol line 321:  \"NFTLoanFacilitator: 0 improvement rate\" NFTLoanFacilitator.sol line 86:  NFTLoanTicket.sol line 15:        \"NFTLoanTicket: only loan facilitator\" ```  ## Cache loanAmount  In the following code the variable `loanInfo[loanId].loanAmount` is read from storage 3 times (see audit-info comments), and hence should be cached so it is only read from storage once.  ```solidity function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {         Loan storage loan = loanInfo[loanId];          uint256 interest = _interestOwed(             loan.loanAmount, @audit-info SLOAD1             loan.lastAccumulatedTimestamp,             loan.perAnumInterestRate,             loan.accumulatedInterest         );         address lender = IERC721(lendTicketContract).ownerOf(loanId);         loan.closed = true;         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount); @audit-info SLOAD2         IERC721(loan.collateralContractAddress).safeTransferFrom(             address(this),             IERC721(borrowTicketContract).ownerOf(loanId),             loan.collateralTokenId         );          emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount); @audit-info SLOAD3         emit Close(loanId);     } ```  Change this into   ```solidity function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {         Loan storage loan = loanInfo[loanId];         uint128 loanAmount = loan.loanAmount;          uint256 interest = _interestOwed(             loanAmount,             loan.lastAccumulatedTimestamp,             loan.perAnumInterestRate,             loan.accumulatedInterest         );         address lender = IERC721(lendTicketContract).ownerOf(loanId);         loan.closed = true;         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loanAmount);         IERC721(loan.collateralContractAddress).safeTransferFrom(             address(this),             IERC721(borrowTicketContract).ownerOf(loanId),             loan.collateralTokenId         );          emit Repay(loanId, msg.sender, lender, interest, loanAmount);         emit Close(loanId);     } ```  The change is passing the provided test suite, and the `.gas-snapshot` reflected the change by reducing the gas costs from:  ```solidity NFTLoanFacilitatorGasBenchMarkTest:testRepayAndClose() (gas: 81320 -> 81064) NFTLoanFacilitatorTest:testRepayAndCloseSuccessful() (gas: 447725 -> 447469) NFTLoanFacilitatorTest:testRepayInterestOwedExceedingUint128() (gas: 465901 -> 465645) ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/95", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "Summary: The codebase and security practices are well implemented, with no comments on that apart from some low and non-critical findings.    Low  findings :   [N01]  Inconsistent use of safeTransferFrom and transferFrom for ERC721:  NFTLoanFacilitator.sol uses both,  for example in line 88 it uses transferFrom and in line 242 it uses safeTransferFrom.  It is a bit confusing for the reader the intentions of using the 2 of them in the same contract. Try to choose one of them for better consistency in the code.   [N02] Leap-years considerations  The function _interestOwed in line 372 of NFTLoanFacilitator.sol calculates interest always considering a year like 365 days. Try 36525 instead for more precision and multiply the numerator by 100.     Non-critical findings:    [N03] Confusing comment  In line 164 of NFTLoanFacilitator.sol there is a confusing or maybe incomplete comment. Since solidity 0.8 underflows and overflows reverts, so consider adding to the comment that the operation will throw an error. The comment just says \"will underflow if amount < previousAmount\".    "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Use private variables to save gas  Those can be declared as private for gas savings, only creating view functions for variables that should be read externally.  ## Proof of Concept  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L17-L44  ## Recommendation  Declare these variables to private.   # Fetch loan fields into memory to save gas  If storage is accessed more than once, it should be fetch into memory to save gas. `loan.lastAccumulatedTimestamp` is accessed twice in `totalOwed` and `interestOwed`  ## Proof of Concept  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L339  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L343  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L352  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L356   ## Recommendation  Fetch loan.lastAccumulatedTimestamp into memory  `uint40 lastAccumulatedTimestamp = loan.lastAccumulatedTimestamp;` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/91", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Summary  We list 2 non-critical findings here:  * (Non) loanEndSeconds does not check valid loanId * (Non) Should use safe version of ERC721 functions  In conclusion, it's better to check the validity of the mapping\u2019s key. And using a safe version of ERC721 functions is usually a better choice.  # (Non) loanEndSeconds does not check valid loanId ## Impact  In `NFTLoanFacilitator.sol/loanEndSeconds()`, it doesn\u2019t check whether loanId is valid  ## Proof of Concept  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L363  ## Recommended Mitigation Steps  Add check for loanId # (Non) Should use safe version of ERC721 functions  ## Impact  In `NFTLoanFacilitator.sol`, it uses `IERC721Mintable(borrowTicketContract).mint` which is not a good practice.  ## Proof of Concept  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L102  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L161   ## Recommended Mitigation Steps  Use `safeMint` instead of `mint` "}, {"title": "When an attacker lends to a loan, the attacker can trigger DoS that any lenders can not buyout it", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/89", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L205-L208 https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L215-L218   # Vulnerability details  ## Impact  If an attacker (lender) lends to a loan, the attacker can always revert transactions when any lenders try to buyout, making anyone can not buyout the loan of the attacker.  ## Proof of Concept  1. A victim calls `lend()`, trying to buyout the loan of the attacker. 2. In `lend()`, it always call `ERC20(loanAssetContractAddress).safeTransfer` to send `accumulatedInterest + previousLoanAmount` to `currentLoanOwner` (attacker). 3. If the `transfer` of `loanAssetContractAddress` is ERC777, it will call `_callTokensReceived` that the attacker can manipulate and always revert it. 4. Because `NFTLoanFacilitator` uses `safeTransfer` and `safeTransferFrom` to check return value, the transaction of the victim will also be reverted. It makes anyone can not buyout the loan of the attacker.  In `_callTokensReceived`, the attacker just wants to revert the buyout transaction, but keep `repayAndCloseLoan` successful. The attacker can call `loanInfoStruct(uint256 loanId)` in `_callTokensReceived` to check if the value of `loanInfo` is changed or not to decide to revert it.  ## Tools Used  vim  ## Recommended Mitigation Steps  Don't transfer `ERC20(loanAssetContractAddress)` to `currentLoanOwner` in `lend()`, use a global mapping to record redemption of lenders and add an external function `redeem` for lenders to transfer `ERC20(loanAssetContractAddress)`.   "}, {"title": "currentLoanOwner can manipulate loanInfo when any lenders try to buyout", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/88", "labels": ["bug", "help wanted", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L205-L208 https://github.com/code-423n4/2022-04-backed/blob/main/contracts/NFTLoanFacilitator.sol#L215-L218   # Vulnerability details  ## Impact  If an attacker already calls `lend()` to lend to a loan, the attacker can manipulate `loanInfo` by reentrancy attack when any lenders try to buyout. The attacker can set bad values of `lendInfo` (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect.  ## Proof of Concept  An attacker lends a loan, and `loanAssetContractAddress` in `loanInfo` is ERC777 which is suffering from reentrancy attack. When a lender (victim) try to buyout the loan of the attacker:  1. The victim called `lend()`. 2. In `lend()`, it always call `ERC20(loanAssetContractAddress).safeTransfer` to send `accumulatedInterest + previousLoanAmount` to `currentLoanOwner` (attacker). 3. The `transfer` of `loanAssetContractAddress` ERC777 will call `_callTokensReceived` so that the attacker can call `lend()` again in reentrancy with parameters:     * loanId: same loan Id     * interestRate: set to bad value (e.g. 0)     * amount: same amount     * durationSeconds: set to bad value (e.g. a long durationSeconds)     * sendLendTicketTo: same address of the attacker (`currentLoanOwner`) 4. Now the variables in `loanInfo` are changed to bad value, and the victim will get the lend ticket but the loan term is manipulated, and can not set it back (because it requires a better term).  ## Tools Used  vim  ## Recommended Mitigation Steps  Use `nonReentrant` modifier on `lend()` to prevent reentrancy attack:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol   "}, {"title": "Borrower can be their own lender and steal funds from buyout due to reentrancy", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/85", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L214-L221 https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L230-L250   # Vulnerability details  ## Impact If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.  ## Proof of Concept This exploit requires that the `loanAssetContractAddress` token transfers control to the receiver.  ### Steps of exploit:  - Borrower creates loan with `createLoan()`. - The same Borrower calls `lend()`, funding their own loan. The Borrower receives the lend ticket, and funds are transferred to themself. - A new lender attempts to buy out the loan. The original loan amount + accruedInterest are sent to the original lender (same person as borrower). - Due to lack of checks-effects-interactions pattern, the borrower is able to immediately call `repayAndCloseLoan()` before the lend ticket is transferred to the new lender.  The following code illustrates that the new lender sends funds to the original lender prior to receiving the lend ticket in return.  ```             } else {                 ERC20(loan.loanAssetContractAddress).safeTransferFrom(                     msg.sender,                     currentLoanOwner,                     accumulatedInterest + previousLoanAmount                 );             }             ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId); ```  The original lender/borrower calls the following `repayAndCloseLoan()` function so that they receive their collateral NFT from the protocol.  ```     function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {         Loan storage loan = loanInfo[loanId];           uint256 interest = _interestOwed(             loan.loanAmount,             loan.lastAccumulatedTimestamp,             loan.perAnumInterestRate,             loan.accumulatedInterest         );         address lender = IERC721(lendTicketContract).ownerOf(loanId);         loan.closed = true;         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);         IERC721(loan.collateralContractAddress).safeTransferFrom(             address(this),             IERC721(borrowTicketContract).ownerOf(loanId),             loan.collateralTokenId         );           emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);         emit Close(loanId);     } ```  Finally, the new lender receives the lend ticket that has no utility at this point. The borrower now possesses the NFT, original loan amount, and accrued interest.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Move the line to transfer the lend ticket to the new lender above the line to transfer to funds to the original lender. Or, use reentrancyGuard from OpenZeppelin to remove the risk of reentrant calls completely.  If desired, also require that the lender cannot be the same account as the borrower of a loan.  "}, {"title": "`requiredImprovementRate` can not work as expected when `previousInterestRate` less than 10 due to precision loss", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/80", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L167-L179   # Vulnerability details   https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L167-L179  ```solidity {     uint256 previousInterestRate = loan.perAnumInterestRate;     uint256 previousDurationSeconds = loan.durationSeconds;      require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');     require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');      require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease     || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds      || (previousInterestRate != 0 // do not allow rate improvement if rate already 0         && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate),      \"NFTLoanFacilitator: proposed terms must be better than existing terms\"); } ```  The `requiredImprovementRate` represents the percentage of improvement required of at least one of the terms when buying out from a previous lender.  However, when `previousInterestRate` is less than `10` and `requiredImprovementRate` is `100`, due to precision loss, the new `interestRate` is allowed to be the same as the previous one.  Making such an expected constraint absent.  ### PoC  1. Alice `createLoan()` with `maxPerAnumInterest` = 10, received `loanId` = 1 2. Bob `lend()` with `interestRate` = 9  for `loanId` = 1 3. Charlie `lend()` with `interestRate` = 9 (and all the same other terms with Bob) and buys out `loanId` = 1  Charlie is expected to provide at least 10% better terms, but actually bought out Bob with the same terms.  ### Recommendation  Consider using: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/math/Math.sol#L39-L42  And change the check to:  ```solidity (previousInterestRate != 0 // do not allow rate improvement if rate already 0         && previousInterestRate - Math.ceilDiv(previousInterestRate * requiredImprovementRate, SCALAR) >= interestRate) ```   "}, {"title": "Protocol doesn't handle fee on transfer tokens", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/75", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L155-L160   # Vulnerability details  ## Impact Since the borrower is able to specify any asset token, it is possible that loans will be created with tokens that support fee on transfer. If a fee on transfer asset token is chosen, the protocol will contain a point of failure on the original `lend()` call.  It is my belief that this is a medium severity vulnerability due to its ability to impact core protocol functionality.  ## Proof of Concept  For the first lender to call `lend()`, if the transfer fee % of the asset token is larger than the origination fee %, the second transfer will fail in the following code:  ```             ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);             uint256 facilitatorTake = amount * originationFeeRate / SCALAR;             ERC20(loanAssetContractAddress).safeTransfer(                 IERC721(borrowTicketContract).ownerOf(loanId),                 amount - facilitatorTake             ); ```  Example: - `originationFee = 2%` Max fee is 5% per comments - `feeOnTransfer = 3%` - `amount = 100 tokens`  - Lender transfers `amount` - `NFTLoanFacilitator` receives `97`. - `facilitatorTake = 2` - `NFTLoanFacilitator` attempts to send `100 - 2` to borrower, but only has `97`. - Execution reverts.  ### Other considerations: If the originationFee is less than or equal to the transferFee, the transfers will succeed but will be received at a loss for the borrower and lender. Specifically for the lender, it might be unwanted functionality for a lender to lend 100 and receive 97 following a successful repayment (excluding interest for this example).  ## Tools Used Manual review.  ## Recommended Mitigation Steps Since the `originationFee` is calculated based on the `amount` sent by the lender, this calculation will always underflow given the example above. Instead, a potential solution would be to calculate the `originationFee` based on the requested loan amount, allowing the lender to send a greater value so that `feeOnTransfer <= originationFee`.  Oppositely, the protocol can instead calculate the amount received from the initial transfer and use this amount to calculate the `originationFee`. The issue with this option is that the borrower will receive less than the desired loan amount.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/52", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "The overall Backed codebase quality is good. Functionalities are very well documented; explanatory comments are well placed. State changing functions follow the Checks-Effects-Interactions pattern and properly validate inputs. Tests are comprehensive.  The permissionless nature of the system allows anyone to use malicious NFTs/collaterals in the system to trick users or cause irregular states. Consider applying a guarded launch approach by having a whitelist\u2014or alternatively\u2014a blacklist for certain NFTs/collaterals. It can be deactivated after the protocol has been sufficiently battle-tested in production.  ## Low Risk Vulnerabilities ### 1. Missing sanity check on `minDurationSeconds` Mistakenly inputting a very low value of `minDurationSeconds` when [creating a loan](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L81) could lead to the NFT being lent and seized before the borrower is able to react.  **Mitigation**  Consider adding a reasonable minimum duration check when creating a loan.      ### 2. Missing `safeTransferFrom` in `closeLoan` Unlike seizeCollateral which implements `safeTransferFrom`, [closeLoan](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L124) only uses `safeTransfer` which could lead to irregular state for contract recipient.  **Mitigation**  Recommend using `safeTransferFrom` to transfer out the NFT when closing loan.  ### 3. Unclear `updateRequiredImprovementRate`  example [Comments](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L316) on updateRequiredImprovementRate stated that `E.g. setting this value to 10` would set improvement rate to 10%, while in reality inputting `10`  would set the rate to 1%.  **Mitigation**  Consider updating the comment example to include the scale calculation.  ### 4. Missing support for legacy NFTs Popular legacy NFT like CryptoPunks (which is used as the mock NFT when running tests) doesn't conform to ERC721 standard, which will exclude them from being able to be loaned.  **Mitigation**  Consider adding a transfer module or utility function that could handle transferring of non-standard ERC721 NFTs.   ## Non Critical Vulnerabilities ### 1. Redundant variable naming Redundant variable names `collateralContractAddress` and `loanAssetContractAddress` make the code less readable. Consider removing the `ContractAddress` as the type and name already imply it is a contract address."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Backed Contest April 06, 2022  @securerodd # ## Gas Optimizations ### 1. != 0 Instead of > 0 in Require Statement  Contract: `NFTLoanFacilitator.sol`   Function: `updateRequiredImprovementRate(uint256 _improvementRate)`   Code: `require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');` Gas: testUpdateRequiredImprovementRateRevertsIf0() (gas: 13310)   Recommended Code: `require(_improvementRate != 0, 'NFTLoanFacilitator: 0 improvement rate');` Gas: testUpdateRequiredImprovementRateRevertsIf0() (gas: 13304) "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/46", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L144   # Vulnerability details  ## Impact  Backed uses `solmate`'s `SafeTransferLib` to safely transfer non-standard ERC20 tokens:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L5  Notably, `SafeTransferLib` does not revert if the token being transferred has no code at all:  https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/utils/SafeTransferLib.sol#L9  This means transferring `address(0)` as a token will succeed, which could confuse users. As a result, Backed checks that the token is not `address(0)` on this line:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L144  However, this check is insufficient to protect users from accidentally creating loans with invalid tokens, as any address without code will be accepted as a valid token. One particularly consequential example of how this could go wrong for users would be inputting the address of a common token like DAI or USDC for another network on accident, but having the loan creation succeed as if it was the correct token. See the proof of concept for more details:  ## Proof of Concept  - Alice wants to create a DAI loan on Ethereum - Alice googles the DAI address and mistakenly copies the address of DAI on Optimism - Alice creates a the loan using Optimistic DAI and it succeeds - Alice is annoyed and confused why no one is lending to her - Alice closes the loan in anger and does not return to use Backed protocol  ## Recommended Mitigation Steps  Rewrite the require like so:  ```solidity    require(loanAssetContractAddress.code.length != 0, \"NFTLoanFacilitator: invalid loan\"); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "Title: Use calldata instead of memory Severity: GAS   Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.               NFTLoanTicket.constructor (name)         NFTLoanTicket.constructor (symbol)    Title: Short the following require messages Severity: GAS  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: NFTLoanFacilitator.sol, In line 258, Require message length to shorten: 39, The message: NFTLoanFacilitator: payment is not late         Solidity file: NFTLoanFacilitator.sol, In line 82, Require message length to shorten: 33, The message: NFTLoanFacilitator: 0 loan amount         Solidity file: NFTLoanFacilitator.sol, In line 321, Require message length to shorten: 38, The message: NFTLoanFacilitator: 0 improvement rate    Title: Use != 0 instead of > 0 Severity: GAS   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)           NFTLoanFacilitator.sol, 321: change '_improvementRate > 0' to '_improvementRate != 0'    Title: Storage double reading. Could save SLOAD Severity: GAS  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           NFTLoanFacilitator.sol: originationFeeRate is read twice in lend   Title: Internal functions to private Severity: GAS  The following functions could be set private to save gas and improve code quality:          LendTicket.sol, _transfer         NFTLoanFacilitator.sol, _interestOwed    Title: Unnecessary constructor Severity: GAS  The following constructors are empty.      (A similar issue https://github.com/code-423n4/2021-11-fei-findings/issues/12)              LendTicket.sol.constructor         BorrowTicket.sol.constructor    Title: Use unchecked to save gas for certain additive calculations that cannot overflow Severity: GAS   You can use unchecked in the following calculations since there is no risk to overflow:          NFTLoanFacilitator.sol (L#382) - return loanAmount * (block.timestamp - lastAccumulatedTimestamp) * (perAnumInterestRate * 1e18 / 365 days) / 1e21 + accumulatedInterest;         NFTLoanFacilitator.sol (L#258) - require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp, \"NFTLoanFacilitator: payment is not late\");     Title: Rearrange state variables Severity: GAS  You can change the order of the storage variables to decrease memory uses.  In NFTLoanFacilitator.sol,rearranging the storage fields can optimize to: 6 slots from: 7 slots. The new order of types (you choose the actual variables):         1. uint256         2. uint256         3. uint256         4. uint256         5. address         6. uint8         7. address     Title: Change transferFrom to transfer Severity: GAS  'transferFrom(address(this), *, **)' could be replaced by the following more gas efficient 'transfer(*, **)'                This replacement is more gas efficient and improves the code quality.          NFTLoanFacilitator.sol, 124 : IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);    Title: Inline one time use functions Severity: GAS   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.               LendTicket.sol, _transfer    Title: Consider inline the following functions to save gas Severity: GAS       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               NFTLoanFacilitator.sol, _interestOwed, { return loanAmount * (block.timestamp - lastAccumulatedTimestamp) * (perAnumInterestRate * 1e18 / 365 days) / 1e21 // SCALAR * 1e18 + accumulatedInterest; }    Title: Public functions to external Severity: GAS  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           NFTLoanTicket.sol, tokenURI"}, {"title": "Might not get desired min loan amount if `_originationFeeRate` changes", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L309   # Vulnerability details  ## Impact Admins can update the origination fee by calling `updateOriginationFeeRate`. Note that a borrower does not receive their `minLoanAmount` set in `createLoan`, they only receive `(1 - originationFee) * minLoanAmount`, see [`lend`](https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L159). Therefore, they need to precalculate the `minLoanAmount` using the **current** origination fee to arrive at the post-fee amount that they actually receive. If admins then increase the fee, the borrower receives fewer funds than required to cover their rent and might become homeless.  ## Recommended Mitigation Steps Reconsider how the min loan amount works. Imo, this `minLoanAmount` should be the post-fee amount, not the pre-fee amount. It's also more intuitive for the borrower when creating the loan.   "}, {"title": "Borrowers lose funds if they call `repayAndCloseLoan` instead of `closeLoan`", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L241   # Vulnerability details  ## Impact The `repayAndCloseLoan` function does not revert if there has not been a lender for a loan (matched with `lend`). Users should use `closeLoan` in this case but the contract should disallow calling `repayAndCloseLoan` because users can lose funds.  It performs a `ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount)` call where `interest` will be a high value accumulated from timestamp 0 and the `loan.loanAmount` is the initially desired min loan amount `minLoanAmount` set in `createLoan`. The user will lose these funds if they ever approved the contract (for example, for another loan).  ## Recommended Mitigation Steps Add a check that there actually is something to repay.  ```solidity require(loan.lastAccumulatedTimestamp > 0, \"loan was never matched by a lender. use closeLoan instead\"); ```   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "## Inefficient safe cast  A safe cast check is done here:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L188  The check uses `<=`, which compiles down to 2 opcodes (`ISZERO`, `GT`). This check can be done in a single opcode like so:  ```solidity require(accumulatedInterest < 1 << 128, \"NFTLoanFacilitator: accumulated interest exceeds uint128\"); ```  because `1 << 128` is equivalent to `2 ** 128` which is equal to `type(uin128).max + 1`  ## Unnecessary ownerOf check  A check that the `from` address equals `ownerOf[id]` is performed here:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/LendTicket.sol#L32  This is unnecessary as the only place where the internal `_transfer` is ever called (via the access controlled public version: `loanFacilitatorTransfer`) will only ever pass the owner of the token as ensured by this line:  https://github.com/code-423n4/2022-04-backed/blob/e8015d7c4b295af131f017e646ba1b99c8f608f0/contracts/NFTLoanFacilitator.sol#L197  Therefore the check can be removed to save an SLOAD."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "# Gas Report **Table of Contents:** - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [Findings](#findings)     - [Storage](#storage)       - [Caching storage values in memory](#caching-storage-values-in-memory)     - [Comparisons](#comparisons)       - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof)     - [Arithmetics](#arithmetics)       - [`++i` costs less gas compared to `i++` or `i += 1`](#i-costs-less-gas-compared-to-i-or-i--1)       - [Unchecking arithmetics operations that can't underflow/overflow](#unchecking-arithmetics-operations-that-cant-underflowoverflow)     - [Visibility](#visibility)       - [Consider making some constants as non-public to save gas](#consider-making-some-constants-as-non-public-to-save-gas)     - [Errors](#errors)       - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword - **`@audit` tags** > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Findings ### Storage  #### Caching storage values in memory The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, storage values should get cached in memory (see the `@audit` tags for further details):  ```solidity contracts/NFTLoanFacilitator.sol:   174:                 require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease //@audit gas: should cache requiredImprovementRate   175:                 || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds   //@audit gas: should use cached requiredImprovementRate   176                  || (previousInterestRate != 0 // do not allow rate improvement if rate already 0   177:                     && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), //@audit gas: should use cached requiredImprovementRate      231          Loan storage loan = loanInfo[loanId];   232     233          uint256 interest = _interestOwed(   234:             loan.loanAmount, //@audit gas: should cache loan.loanAmount   235              loan.lastAccumulatedTimestamp,   236              loan.perAnumInterestRate,   237              loan.accumulatedInterest   238          );   239          address lender = IERC721(lendTicketContract).ownerOf(loanId);   240          loan.closed = true;   241:         ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount); //@audit gas: should use cached loan.loanAmount   242          IERC721(loan.collateralContractAddress).safeTransferFrom(   243              address(this),   244              IERC721(borrowTicketContract).ownerOf(loanId),   245              loan.collateralTokenId   246          );   247     248:         emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount); //@audit gas: should use cached loan.loanAmount   249          emit Close(loanId);   250      }    338          Loan storage loan = loanInfo[loanId];   339          if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;   340     341:         return loanInfo[loanId].loanAmount + _interestOwed( //@audit gas: should use loan.loanAmount instead of loanInfo[loanId].loanAmount   342              loan.loanAmount,   343              loan.lastAccumulatedTimestamp,   344              loan.perAnumInterestRate,   345              loan.accumulatedInterest   346          ); ```  ### Comparisons  #### `> 0` is less efficient than `!= 0` for unsigned integers (with proof) `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: https://twitter.com/gzeon/status/1485428085885640706  I suggest changing `> 0` with `!= 0` here: ```solidity NFTLoanFacilitator.sol:321:        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate'); ```  Also, please enable the Optimizer.  ### Arithmetics    #### `++i` costs less gas compared to `i++` or `i += 1` `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:      ```solidity uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ```solidity uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:   ```solidity LendTicket.sol:39:            balanceOf[from]--; LendTicket.sol:41:            balanceOf[to]++; ```   I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`  #### Unchecking arithmetics operations that can't underflow/overflow Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  I suggest wrapping with an `unchecked` block here (see `@audit` tags for more details):  ```solidity contracts/NFTLoanFacilitator.sol:   156              uint256 facilitatorTake = amount * originationFeeRate / SCALAR;   157              ERC20(loanAssetContractAddress).safeTransfer(   158                  IERC721(borrowTicketContract).ownerOf(loanId),   159:                 amount - facilitatorTake //@audit gas: should be unchecked as facilitatorTake is < amount and can't underflow L156 (originationFeeRate is upper bounded and always < SCALAR)    209                  uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);   210                  ERC20(loanAssetContractAddress).safeTransfer(   211                      IERC721(borrowTicketContract).ownerOf(loanId),   212:                     amountIncrease - facilitatorTake //@audit gas: should be unchecked as facilitatorTake is < amount and can't underflow L209 (originationFeeRate is upper bounded and always < SCALAR) ``` ### Visibility  #### Consider making some constants as non-public to save gas Reducing from `public` to `private` or `internal` can save gas when a constant isn't used outside of its contract. I suggest changing the visibility from `public` to `internal` or `private` here: ```solidity NFTLoanFacilitator.sol:21:    uint8 public constant override INTEREST_RATE_DECIMALS = 3; NFTLoanFacilitator.sol:24:    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS; ```  ### Errors  #### Reduce the size of error messages (Long revert Strings) Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.   Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   Revert strings > 32 bytes:   ```solidity NFTLoanFacilitator.sol:118:        \"NFTLoanFacilitator: borrow ticket holder only\"); NFTLoanFacilitator.sol:121:        require(loan.lastAccumulatedTimestamp == 0, \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\"); NFTLoanFacilitator.sol:178:                \"NFTLoanFacilitator: proposed terms must be better than existing terms\"); NFTLoanFacilitator.sol:189:            \"NFTLoanFacilitator: accumulated interest exceeds uint128\"); NFTLoanFacilitator.sol:255:        \"NFTLoanFacilitator: lend ticket holder only\"); NFTLoanFacilitator.sol:259:        \"NFTLoanFacilitator: payment is not late\"); NFTLoanTicket.sol:15:        require(msg.sender == address(nftLoanFacilitator), \"NFTLoanTicket: only loan facilitator\");  ```  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next.  #### Use Custom Errors instead of Revert Strings to save Gas Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: https://blog.soliditylang.org/2021/04/21/custom-errors/: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:   ```solidity LendTicket.sol:32:        require(from == ownerOf[id], \"WRONG_FROM\"); LendTicket.sol:34:        require(to != address(0), \"INVALID_RECIPIENT\"); NFTLoanFacilitator.sol:53:        require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\"); NFTLoanFacilitator.sol:81:        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration'); NFTLoanFacilitator.sol:82:        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount'); NFTLoanFacilitator.sol:83:        require(collateralContractAddress != lendTicketContract, NFTLoanFacilitator.sol:85:        require(collateralContractAddress != borrowTicketContract,  NFTLoanFacilitator.sol:117:        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender, NFTLoanFacilitator.sol:121:        require(loan.lastAccumulatedTimestamp == 0, \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\"); NFTLoanFacilitator.sol:144:            require(loanAssetContractAddress != address(0), \"NFTLoanFacilitator: invalid loan\"); NFTLoanFacilitator.sol:146:            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high'); NFTLoanFacilitator.sol:147:            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low'); NFTLoanFacilitator.sol:148:            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low'); NFTLoanFacilitator.sol:171:                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high'); NFTLoanFacilitator.sol:172:                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low'); NFTLoanFacilitator.sol:174:                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease NFTLoanFacilitator.sol:188:            require(accumulatedInterest <= type(uint128).max, NFTLoanFacilitator.sol:254:        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender,  NFTLoanFacilitator.sol:258:        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp, NFTLoanFacilitator.sol:280:        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set'); NFTLoanFacilitator.sol:290:        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set'); NFTLoanFacilitator.sol:307:        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\"); NFTLoanFacilitator.sol:321:        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate'); NFTLoanTicket.sol:15:        require(msg.sender == address(nftLoanFacilitator), \"NFTLoanTicket: only loan facilitator\"); ```  I suggest replacing revert strings with custom errors."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-backed-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-04-backed-findings", "body": "-- 1  All functions that receive uints which are not uint256 could be changed to uint256 and only casted to the intended size when storing it.  More info at: https://github.com/ourzora/v3/pull/125#issuecomment-1034238815  Just swapped the `lend()` function and consequent related tests resulting in: ```(...) Overall gas change: -11839 (-0.041%)``` But there are many other functions (eg. `createLoan`) which could use such change, so the gas saving should be way more than that.  -- 2 cache `borrowTicketContract` at `createLoan` to save one SLOAD on a successful transaction.  -- 3 use cached `previousInterestRate` on calling `_interestOwed`  Overall gas change: -60 (-0.000%)  ```diff diff --git a/contracts/NFTLoanFacilitator.sol b/contracts/NFTLoanFacilitator.sol index 46d6ef5..bb25958 100644 --- a/contracts/NFTLoanFacilitator.sol +++ b/contracts/NFTLoanFacilitator.sol @@ -165,6 +165,7 @@ contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {              // will underflow if amount < previousAmount              uint256 amountIncrease = amount - previousLoanAmount;   +            uint256 accumulatedInterest;              {                  uint256 previousInterestRate = loan.perAnumInterestRate;                  uint256 previousDurationSeconds = loan.durationSeconds; @@ -177,14 +178,14 @@ contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {                  || (previousInterestRate != 0 // do not allow rate improvement if rate already 0                      && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate),                   \"NFTLoanFacilitator: proposed terms must be better than existing terms\"); -            }   -            uint256 accumulatedInterest = _interestOwed( -                previousLoanAmount, -                loan.lastAccumulatedTimestamp, -                loan.perAnumInterestRate, -                loan.accumulatedInterest -            ); +                 = _interestOwed( +                    previousLoanAmount, +                    loan.lastAccumulatedTimestamp, +                    previousInterestRate, +                    loan.accumulatedInterest +                ); +            }              require(accumulatedInterest <= type(uint128).max,              \"NFTLoanFacilitator: accumulated interest exceeds uint128\"); ```  -- 4  cache `loan.loanAmount` on `repayAndCloseLoan`  ``` testRepayInterestOwedExceedingUint128() (gas: -253 (-0.001%))  testRepayAndCloseSuccessful() (gas: -253 (-0.001%))  testRepayAndClose() (gas: -253 (-0.003%))  Overall gas change: -759 (-0.004%) ``` ```diff diff --git a/contracts/NFTLoanFacilitator.sol b/contracts/NFTLoanFacilitator.sol index f1f570f..ff2e3f7 100644 --- a/contracts/NFTLoanFacilitator.sol +++ b/contracts/NFTLoanFacilitator.sol @@ -231,23 +231,24 @@ contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {      /// See {INFTLoanFacilitator-repayAndCloseLoan}.      function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {          Loan storage loan = loanInfo[loanId]; +        uint256 _loanAmount = loan.loanAmount;            uint256 interest = _interestOwed( -            loan.loanAmount, +            _loanAmount,              loan.lastAccumulatedTimestamp,              loan.perAnumInterestRate,              loan.accumulatedInterest          );          address lender = IERC721(lendTicketContract).ownerOf(loanId);          loan.closed = true; -        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount); +        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + _loanAmount);          IERC721(loan.collateralContractAddress).safeTransferFrom(              address(this),              IERC721(borrowTicketContract).ownerOf(loanId),              loan.collateralTokenId          );   -        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount); +        emit Repay(loanId, msg.sender, lender, interest, _loanAmount);          emit Close(loanId);      } ```"}, {"title": "Not calling `approve(0)` before setting a new approval causes the call to revert when used with Tether (USDT)", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/39", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-dualityfocus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L48 https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L58 https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/UniV3LpVault.sol#L418   # Vulnerability details  Some tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens.  For example Tether (USDT)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.  ## Impact The code as currently implemented does not handle these sorts of tokens properly when they're a Uniswap pool asset, which would prevent USDT, the sixth largest pool, from being used by this project. This project relies heavily on Uniswap, so this would hamper future growth and availability of the protocol.  ## Proof of Concept  1. File: contracts/vault_and_oracles/FlashLoan.sol (line [48](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L48)) ```solidity         IERC20(assets[0]).approve(address(LP_VAULT), amounts[0]); ```  2. File: contracts/vault_and_oracles/FlashLoan.sol (line [58](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L58)) ```solidity         IERC20(assets[0]).approve(address(LENDING_POOL), amountOwing); ```  3. File: contracts/vault_and_oracles/UniV3LpVault.sol (line [418](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/UniV3LpVault.sol#L418)) ```solidity             IERC20Detailed(params.asset).approve(msg.sender, owedBack); ```  There are other calls to `approve()`, but they correctly set the approval to zero after the transfer is done, so that the next approval can go through.  ## Tools Used Code inspection  ## Recommended Mitigation Steps Use OpenZeppelin\u2019s `SafeERC20`'s `safeTransfer()` instead   "}, {"title": "Arbitrary contract call within `UniV3LpVault._swap` with controllable `swapPath`", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/31", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-dualityfocus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L621 https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L379 https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L520 https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L521   # Vulnerability details  ## Impact  `UniV3LpVault._swap` utilizes `swapRouter.exactInput` to perform swaps between two tokens. During swaps, `transfer` function of each token along the path will be called to propagate the assets.  Since anyone can create a uniswap pair of arbitrary assets, it is possible to include intermediate hop with malicious tokens within the path. Thus `UniV3LpVault._swap` effectively grants users the ability to perform arbitrary contract calls during the swap process if `swapPath` is not validated properly.  Usage of invalidated `swapPath` can be found in `UniV3LpVault.flashFocusCall` and `UniV3LpVault.repayDebt`.  ## Proof of Concept  The security of `Comptroller` and `UniV3LpVault` relies on validating all used tokens thoroughly. This is done by a whitelist mechanism where admin decides a predefined set of usable tokens, and users can only perform actions within the allowed range. This whitelist approach eliminates most of the attack surface regarding directly passing in malicious tokens as arguments.  Apart from passing malicious tokens directly, there are a few other potential weaknesses, the most obvious one is leveraging flash loans for collaterals. However, due to the adoption of AAVE LendingPool, the external validation within flash loan pool blocks this approach.  Unfortunately, a more obscure path exists. Looking at the swapping mechanism, it is not hard to realize it is backed by uniswapV3. An interesting characteristic of uniswap pools is that anyone can create pools for any token pairs, thus if we don't fully validate each and every pool we are using, chances are there will be malicious entries hidden within them.  This is partially the case which we see here, the user gets to supply a path, where the source and target are validated against benign tokens, the intermediate ones are not. An example of utilizing path for arbitrary function call is illustrated below 1. Create malicious token tokenM 2. Create pools tokenS<->tokenM and tokenM<->tokenT where tokenS and tokenT are benign tokens 3. Supply path (tokenS, tokenM, tokenT) for swapping  In the above case, when transferring tokenM while doing swap, we have full control over code executed and can insert arbitrary contract calls within.  Noticeably, while gaining arbitrary contract calls sounds dangerous, it does not necessarily mean the contract is exploitable. It still depends on the scenario in which an arbitrary call happens.  In the case of duality, the two locations where arbitrary `swapPath` can be provided is in `flashFocusCall` and `repayDebt`, both in which holds a local lock over `UniV3LpVault`. No global are applied to `Comptroller` or `Ctokens` while performing swaps.  ```     function flashFocusCall(FlashFocusParams calldata params) external override {         ...         {             ...             if (!tokenOfPool && params.swapPath.length > 0) amountIn0 = _swap(params.swapPath, params.amount);             ...         }         ...     }      function flashFocus(FlashFocusParams calldata params)         external         override         nonReentrant(true)         isAuthorizedForToken(params.tokenId)         avoidsShortfall     {         ...         flashLoan.LENDING_POOL().flashLoan(             receiverAddress,             assets,             amounts,             modes,             onBehalfOf,             newParams,             referralCode         );     }      function repayDebt(RepayDebtParams calldata params)         external         override         nonReentrant(true)         isAuthorizedForToken(params.tokenId)         avoidsShortfall         returns (uint256 amountReturned)     {         ...         {             ...             if (amountOutFrom0 == 0 && params.swapPath0.length > 0) amountOutFrom0 = _swap(params.swapPath0, amount0);             if (amountOutFrom1 == 0 && params.swapPath1.length > 0) amountOutFrom1 = _swap(params.swapPath1, amount1);             ...         }         ...     } ```   The lack of global locks here had us doubting whether an attack is possible. While we spent a considerable amount of time and failed to come up with any possible attack vectors, the complexity of the system held us back from concluding that an attack is impossible.  Thus we report this finding here in hope of inspiring developers either to prove the attack impossible or mitigate the attack surface.  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  The easiest way to mitigate this is to validate the entire path against a predefined whitelist while in `_checkSwapPath`. This approach is far from optimal and also limits the flexibility of swapping between tokens. However, before security is proved, this is the best approach we can come up with.   "}, {"title": "Dysfunctional `CToken._acceptAdmin` due to lack of function to assign `pendingAdmin`", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/29", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-dualityfocus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/compound_rari_fork/CToken.sol#L1379   # Vulnerability details  ## Impact  The implementation of `CToken` in Duality introduced an `_acceptAdmin` function, which presumably should allow changing the `admin`. However, there does not exist a pairing `proposePendingAdmin` function that can propose a new `pendingAdmin`, thus `pendingAdmin` will never be set. This renders the `_acceptAdmin` function useless.  ## Proof of Concept  `_acceptAdmin` requires `msg.sender` to equal `pendingAdmin`, however, since `pendingAdmin` can never be set, it will always be `address(0)`, making this function unusable.  ```     function _acceptAdmin() external returns (uint256) {         // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)         if (msg.sender != pendingAdmin || msg.sender == address(0)) {             return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);         }         // Save current values for inclusion in log         address oldAdmin = admin;         address oldPendingAdmin = pendingAdmin;         // Store admin with value pendingAdmin         admin = pendingAdmin;         // Clear the pending value         pendingAdmin = address(0);         emit NewAdmin(oldAdmin, admin);         emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);         return uint256(Error.NO_ERROR);     } ```  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Add a `proposePendingAdmin` function where the current admin can propose successors.  ```     function _proposePendingAdmin(address newPendingAdmin) external {         if (msg.sender != admin) {             return fail(Error.UNAUTHORIZED, FailureInfo.PROPOSE_PENDING_ADMIN_CHECK);         }         address oldPendingAdmin = pendingAdmin;         pendingAdmin = newPendingAdmin;         emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);         return uint256(Error.NO_ERROR)     } ```   "}, {"title": "`Comptroller._setUniV3LpVault` will always cause in-use uniswapV3 positions to become stuck in `UniV3LpVault`", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-dualityfocus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/compound_rari_fork/Comptroller.sol#L1105   # Vulnerability details  ## Impact  `Comptroller._setUniV3LpVault` allows the admin of `Comptroller` to change the accompanying `UniV3LpVault`. However since actions including collateral calculation, uniswapV3 position withdrawal, uniswapV3 collateral liquidation all require `Comptroller` and `UniV3LpVault` to cooperate seamlessly, a change in `Comptroller.uniV3LpVault` would mean all the above actions are no longer performable on existing NFTs.  ## Proof of Concept  `_setUniV3LpVault` allows changing of `uniV3LpVault`.  ```     function _setUniV3LpVault(IUniV3LpVault newVault) public returns (uint256) {         ...         uniV3LpVault = newVault;         ...     } ```  However, functions such as `UniV3LpVault.withdrawToken` require `Comptroller` to estimate NFT collateral value. This estimation can only be done when the address of `UniV3LpVault` matches `Comptroller.uniV3LpVault` as shown in `addNFTCollateral` below.  ``` contract UniV3LpVault is IUniV3LpVault {     ...     function withdrawToken(...) external override nonReentrant(false) avoidsShortfall {         ...     }      modifier avoidsShortfall() {         _;         (, , uint256 shortfall) = comptroller.getAccountLiquidity(msg.sender);         require(shortfall == 0, \"insufficient liquidity\");     }     ... }  contract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {     ...     function getAccountLiquidity(address account) public view returns (...) {         (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(...);         ...     }      function getHypotheticalAccountLiquidityInternal(...) internal view returns (...) {         ...         addNFTCollateral(account, vars);         ...     }      function addNFTCollateral(address account, AccountLiquidityLocalVars memory vars) internal view {         uint256 userTokensLength = uniV3LpVault.getUserTokensLength(account);         for (uint256 i = 0; i < userTokensLength; i++) {             ...             {                 ...                 address poolAddress = uniV3LpVault.getPoolAddress(tokenId);                 ...             }             ...         }         ...     } } ``` The mutual reliance causes NFT tokens to become stuck. In some cases users can solve this issue by depositing more collateral to cover the shortcoming caused by \"disappearing NFTs\". In other cases such as liquidation, the functionality becomes downright broken and unuseable..  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  Remove the option to change `Comptroller.uniV3LpVault` altogether, as this functionality is not really helpful for the overall protocol. Another way to handle this is to forcefully evict all NFTs before changing the vault. However, this is extremely complex as it would potentially cause users to become severely under-collateralized, and would require more care in tracking and maintaining states.   "}, {"title": "Improper Access Control", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/25", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-dualityfocus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/compound_rari_fork/CToken.sol#L1641   # Vulnerability details  ## Impact  In the referenced code this line,  `require(msg.sender != admin, \"caller not admin\");` is meant to prevent non-admins from calling the function however it instead prevents admins from calling the function and allows anyone else to. This could lead to defacing the token i.e changing the name to something offensive like Shit Token, Poo Coin, etc.  ## Recommended Mitigation Steps  Adjust the require statement to reflect it's intended function i.e ` require(msg.sender == admin, \"caller not admin\");`  "}, {"title": "Undercollateralized loans possible", "html_url": "https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-04-dualityfocus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/compound_rari_fork/Comptroller.sol#L1491   # Vulnerability details  ## Impact The `_setPoolCollateralFactors` function does not check that the collateral factor is < 100%. It's possible that it's set to 200% and then borrows more than the collateral is worth, stealing from the pool.  ## Recommended Mitigation Steps Disable the possibility of ever having a collateral factor > 100% by checking:  ```diff for (uint256 i = 0; i < pools.length; i++) { +   require(collateralFactorsMantissa[i] <= 1e18, \"CF > 100%\");     poolCollateralFactors[pools[i]] = collateralFactorsMantissa[i]; } ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-axelar-findings", "body": "1. Unmatch comment with actual code  https://github.com/code-423n4/2022-04-axelar/blob/main/src/ERC20.sol#L48  its said that :     ``` * All three of these values are immutable``  but in actual code`name` and `symbol` arent immutable value. so it would be missleading information on comment sectioin.   ##Tool Used  Manual Review, Remix  ##Recommended Mitigation Change it or remove it  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-axelar-findings", "body": "# Gas Report  **Table of Contents:**  - [Gas Report](#gas-report)   - [Foreword](#foreword)   - [Findings](#findings)     - [Variables](#variables)       - [Constants should be literal and their derivation should be in comments](#constants-should-be-literal-and-their-derivation-should-be-in-comments)     - [For-Loops](#for-loops)       - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops)       - [`++i` costs less gas compared to `i++` or `i += 1`](#i-costs-less-gas-compared-to-i-or-i--1)       - [Increments can be unchecked](#increments-can-be-unchecked)     - [Arithmetics](#arithmetics)       - [Unchecking arithmetics operations that can't underflow/overflow](#unchecking-arithmetics-operations-that-cant-underflowoverflow)     - [Errors](#errors)       - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Foreword  - **`@audit` tags**  > The code is annotated at multiple places with `//@audit` comments to pinpoint the issues. Please, pay attention to them for more details.  ## Findings  ### Variables  #### Constants should be literal and their derivation should be in comments  Due to how `constant` variables are implemented (replacements at compile-time), an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.  While I'm certain the sponsor is aware of this fact (thanks to the comments `AUDIT: constants should be literal and their derivation should be in comments`), I figured I'd still centralize the impacted lines of codes here:  ```solidity AdminMultisigBase.sol:16:    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch'); AdminMultisigBase.sol:18:    bytes32 internal constant PREFIX_ADMIN = keccak256('admin'); AdminMultisigBase.sol:19:    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count'); AdminMultisigBase.sol:20:    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold'); AdminMultisigBase.sol:21:    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts'); AdminMultisigBase.sol:22:    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted'); AdminMultisigBase.sol:23:    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin'); AxelarGateway.sol:45:    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen'); AxelarGateway.sol:47:    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed'); AxelarGateway.sol:48:    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address'); AxelarGateway.sol:49:    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type'); AxelarGateway.sol:50:    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen'); AxelarGateway.sol:51:    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved'); AxelarGateway.sol:52:    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint'); AxelarGateway.sol:54:    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken'); AxelarGateway.sol:55:    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken'); AxelarGateway.sol:56:    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken'); AxelarGateway.sol:57:    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall'); AxelarGateway.sol:58:    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint'); AxelarGateway.sol:59:    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship'); AxelarGateway.sol:60:    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership'); AxelarGatewayMultisig.sol:25:    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch'); AxelarGatewayMultisig.sol:27:    bytes32 internal constant PREFIX_OWNER = keccak256('owner'); AxelarGatewayMultisig.sol:28:    bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count'); AxelarGatewayMultisig.sol:29:    bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold'); AxelarGatewayMultisig.sol:30:    bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner'); AxelarGatewayMultisig.sol:32:    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch'); AxelarGatewayMultisig.sol:34:    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator'); AxelarGatewayMultisig.sol:35:    bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count'); AxelarGatewayMultisig.sol:36:    bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold'); AxelarGatewayMultisig.sol:37:    bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator'); ```  As already proposed by a previous auditor, I suggest hardcoding the computed values from these expressions in the constants variables and add a comment above them to say how the value was calculated.  ### For-Loops  #### An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.    Here, I suggest storing the array's length in a variable before the for-loop, and use it instead:  ```solidity AxelarGatewayMultisig.sol:42:        for (uint256 i; i < accounts.length - 1; ++i) { AxelarGatewayMultisig.sol:118:        for (uint256 i; i < accounts.length; i++) { AxelarGatewayMultisig.sol:271:        for (uint256 i; i < accounts.length; i++) {  ```  This is already done at most places in the solution.  #### `++i` costs less gas compared to `i++` or `i += 1`  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:      ```solidity uint i = 1;   i++; // == 1 but i == 2   ```    But `++i` returns the actual incremented value:      ```solidity uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```    In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`      Instances include:    ```solidity AdminMultisigBase.sol:51:        for (uint256 i; i < adminCount; i++) { AdminMultisigBase.sol:158:        for (uint256 i; i < adminLength; i++) { AxelarGateway.sol:225:        for (uint256 i; i < adminCount; i++) { AxelarGatewayMultisig.sol:118:        for (uint256 i; i < accounts.length; i++) { AxelarGatewayMultisig.sol:140:        for (uint256 i; i < ownerCount; i++) { AxelarGatewayMultisig.sol:181:        for (uint256 i; i < accountLength; i++) { AxelarGatewayMultisig.sol:271:        for (uint256 i; i < accounts.length; i++) { AxelarGatewayMultisig.sol:293:        for (uint256 i; i < operatorCount; i++) { AxelarGatewayMultisig.sol:332:        for (uint256 i; i < accountLength; i++) { AxelarGatewayMultisig.sol:495:        for (uint256 i; i < signatureCount; i++) { AxelarGatewayMultisig.sol:526:        for (uint256 i; i < commandsLength; i++) { ```  I suggest using `++i` instead of `i++` to increment the value of an uint variable, just like it's done here:  ```solidity AxelarGatewayMultisig.sol:42:        for (uint256 i; i < accounts.length - 1; ++i) { ```  #### Increments can be unchecked  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Instances include:    ```solidity AdminMultisigBase.sol:51:        for (uint256 i; i < adminCount; i++) { AdminMultisigBase.sol:158:        for (uint256 i; i < adminLength; i++) { AxelarGateway.sol:225:        for (uint256 i; i < adminCount; i++) { AxelarGatewayMultisig.sol:42:        for (uint256 i; i < accounts.length - 1; ++i) { AxelarGatewayMultisig.sol:118:        for (uint256 i; i < accounts.length; i++) { AxelarGatewayMultisig.sol:140:        for (uint256 i; i < ownerCount; i++) { AxelarGatewayMultisig.sol:181:        for (uint256 i; i < accountLength; i++) { AxelarGatewayMultisig.sol:271:        for (uint256 i; i < accounts.length; i++) { AxelarGatewayMultisig.sol:293:        for (uint256 i; i < operatorCount; i++) { AxelarGatewayMultisig.sol:332:        for (uint256 i; i < accountLength; i++) { AxelarGatewayMultisig.sol:495:        for (uint256 i; i < signatureCount; i++) { AxelarGatewayMultisig.sol:526:        for (uint256 i; i < commandsLength; i++) { ```  The code would go from:      ```solidity for (uint256 i; i < numIterations; i++) {    // ...   }   ```  to:    ```solidity for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ```  The risk of overflow is inexistant for a `uint256` here.  ### Arithmetics    #### Unchecking arithmetics operations that can't underflow/overflow  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  I suggest wrapping with an `unchecked` block here (see `@audit` tags for more details):  ```solidity src/AxelarGatewayMultisig.sol:   103:         uint256 lowerBoundOwnerEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0); //@audit gas: should be unchecked due to condition in ternary operation   257:         uint256 lowerBoundOperatorEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0); //@audit gas: should be unchecked due to condition in ternary operation ```  ### Errors  #### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  ```solidity BurnableMintableCappedERC20.sol:58:        require(!EternalStorage(owner).getBool(KEY_ALL_TOKENS_FROZEN), 'IS_FROZEN'); BurnableMintableCappedERC20.sol:59:        require(!EternalStorage(owner).getBool(keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol))), 'IS_FROZEN'); DepositHandler.sol:12:        require(_lockedStatus == IS_NOT_LOCKED); ERC20.sol:164:        require(sender != address(0), 'ZERO_ADDR'); ERC20.sol:165:        require(recipient != address(0), 'ZERO_ADDR'); ERC20.sol:184:        require(account != address(0), 'ZERO_ADDR'); ERC20.sol:205:        require(account != address(0), 'ZERO_ADDR'); ERC20.sol:232:        require(owner != address(0), 'ZERO_ADDR'); ERC20.sol:233:        require(spender != address(0), 'ZERO_ADDR'); ERC20Permit.sol:43:        require(block.timestamp < deadline, 'EXPIRED'); ERC20Permit.sol:44:        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'INV_S'); ERC20Permit.sol:45:        require(v == 27 || v == 28, 'INV_V'); ERC20Permit.sol:56:        require(recoveredAddress == issuer, 'INV_SIG'); MintableCappedERC20.sol:25:        require(capacity == 0 || totalSupply + amount <= capacity, 'CAP_EXCEEDED'); Ownable.sol:16:        require(owner == msg.sender, 'NOT_OWNER'); Ownable.sol:21:        require(newOwner != address(0), 'ZERO_ADDR'); ```  I suggest replacing revert strings with custom errors. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-axelar-findings", "body": "## Functions Visibility Can Be Declared External **Context**: [`ERC20.sol#L69-L72`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/ERC20.sol#L69-L72), [`ERC20.sol#L81-L84`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/ERC20.sol#L81-L84), [`ERC20.sol#L99-L107`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/ERC20.sol#L99-L107), [`ERC20.sol#L121-L124`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/ERC20.sol#L121-L124), [`ERC20.sol#L140-L143`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/ERC20.sol#L140-L143), [`MintableCappedERC20.sol#L23-L28`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/MintableCappedERC20.sol#L23-L28), [`Ownable.sol#L20-L25`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/Ownable.sol#L20-L25), [`EternalStorage.sol#L18-L20`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/Ownable.sol#L20-L25), [`EternalStorage.sol#L22-L24`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/EternalStorage.sol#L22-L24), [`EternalStorage.sol#L26-L28`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/EternalStorage.sol#L26-L28), [`EternalStorage.sol#L30-L32`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/EternalStorage.sol#L30-L32), [`EternalStorage.sol#L34-L36`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/EternalStorage.sol#L34-L36), [`EternalStorage.sol#L38-L40`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/EternalStorage.sol#L38-L40)  **Description**: Several functions across multiple contracts have a public visibility and can be marked with external visibility to save gas.    **Recommendation**:  Change the functions visibility to external to save gas.   ## Catching The Array Length Prior To Loop **Context**: [`AxelarGatewayMultisig.sol#L41-L49`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L41-L49), [`AxelarGatewayMultisig.sol#L114-L123`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L114-L123), [`AxelarGatewayMultisig.sol#L267-L276`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L267-L276)  **Description**: One can save gas by caching the array length (in stack) and using that set variable in the loop. Replace state variable reads and writes within loops with local variable reads and writes. This is done by assigning state variable values to new local variables, reading and/or writing the local variables in a loop, then after the loop assigning any changed local variables to their equivalent state variables.   **Recommendation**:  Simply do something like so before the for loop: ```uint length =  variable.length```. Then add ```length``` in place of ``` variable.length``` in the for loop.    ## Function Ordering via Method ID **Context**: [`All Contracts`](https://github.com/code-423n4/2022-04-axelar)  **Description**: Contracts most called functions could simply save gas by function ordering via Method ID. Calling a function at runtime will be cheaper if the function is positioned earlier in the order (has a relatively lower Method ID) because 22 gas are added to the cost of a function for every position that came before it. The caller can save on gas if you prioritize most called functions. One could use [`This tool`](https://emn178.github.io/solidity-optimize-name/) to help find alternative function names with lower Method IDs while keeping the original name intact.  **Recommendation**:  Find a lower method ID name for the most called functions for example ```mostCalled()``` vs. ```mostCalled_41q()``` is cheaper by 44 gas.   ## Use ++index instead of index++ to increment a loop counter **Context**: [`AxelarGateway.sol#L221-L228`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGateway.sol#L221-L228), [`AxelarGatewayMultisig.sol#L136-L143`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L136-L143), [`AxelarGatewayMultisig.sol#L167-L191`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L167-L191), [`AxelarGatewayMultisig.sol#L267-L276`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L267-L276), [`AxelarGatewayMultisig.sol#L289-L296`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L289-L296), [`AxelarGatewayMultisig.sol#L318-L344`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L318-L344), [`AxelarGatewayMultisig.sol#L490-L575 (for both for loops)`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L490-L575), [`AdminMultisigBase.sol#L25-L54`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AdminMultisigBase.sol#L25-L54), [`AdminMultisigBase.sol#L144-L168`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AdminMultisigBase.sol#L144-L168)  **Description**: Due to reduced stack operations, using ++index saves 5 gas per iteration.  **Recommendation**:  Use ++index to increment a loop counter.   ## State Variable Is Read From More Than Once In A Function **Context**: [`AxelarGateway.sol#L558-L560`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGateway.sol#L558-L560)  **Description**: If there's a state variable you'll read from more than once in a function, it's best to cast it into memory.  **Recommendation**:  Where state varibables are read from more than once in a function, cast it into memory and then use the casted varable.   ## Setting The Constructor To Payable **Context**: [`Ownable.sol#L10-L13`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/Ownable.sol#L10-L13), [`BurnableMintableCappedERC20.sol#L21-L26`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/BurnableMintableCappedERC20.sol#L21-L26), [`MintableCappedERC20.sol#L14-L21`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/MintableCappedERC20.sol#L14-L21), [`ERC20Permit.sol#L22-L32`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/ERC20Permit.sol#L22-L32), [`ERC20.sol#L51-L59`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/ERC20.sol#L51-L59), [`AxelarGatewayMultisig.sol#L39`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayMultisig.sol#L39), [`AxelarGateway.sol#L66-L68`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGateway.sol#L66-L68), [`AxelarGatewayProxy.sol#L16-L24`](https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGatewayProxy.sol#L16-L24)  **Description**: You can cut out 10 opcodes in the creation-time EVM bytecode if you declare a constructor payable. Making the constructor payable eliminates the need for an initial check of `msg.value == 0` and saves 21 gas on deployment with no security risks.  **Recommendation**:  Set the constructor to payable. "}, {"title": "Low level call returns true if the address doesn't exist", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-04-axelar-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-axelar/blob/dee2f2d352e8f20f20027977d511b19bfcca23a3/src/AxelarGateway.sol#L545-L548 https://github.com/code-423n4/2022-04-axelar/blob/dee2f2d352e8f20f20027977d511b19bfcca23a3/src/AxelarGatewayProxy.sol#L16-L24   # Vulnerability details  ## Impact As written in the [solidity documentation](https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions), the low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.   ## Proof of Concept The low-level functions `call` and `delegatecall` are used in some places in the code and it can be problematic. For example, in the `_callERC20Token` of the `AxelarGateway` contract there is a low level call in order to call the ERC20 functions, but if the given `tokenAddress` doesn't exist `success` will be equal to true and the function will return true and the code execution will be continued like the call was successful.  ```sol function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {     (bool success, bytes memory returnData) = tokenAddress.call(callData);     return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool))); } ``` Another place that this can happen is in `AxelarGatewayProxy`'s constructor ```sol constructor(address gatewayImplementation, bytes memory params) {     _setAddress(KEY_IMPLEMENTATION, gatewayImplementation);     (bool success, ) = gatewayImplementation.delegatecall(        abi.encodeWithSelector(IAxelarGateway.setup.selector, params)    );      if (!success) revert SetupFailed(); } ``` If the `gatewayImplementation` address doesn't exist, the delegate call will return true and the function won't revert.  ## Tools Used Remix, VS Code  ## Recommended Mitigation Steps Check before any low-level call that the address actually exists, for example before the low level call in the callERC20 function you can check that the address is a contract by checking its code size.  "}, {"title": "Unsupported fee-on-transfer tokens", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/5", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-axelar-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGateway.sol#L284-L334   # Vulnerability details  ## Impact When tokenAddress is fee-on-transfer tokens, in the _burnTokenFrom function, the actual amount of tokens received by the contract will be less than the amount. ## Proof of Concept https://github.com/code-423n4/2022-04-axelar/blob/main/src/AxelarGateway.sol#L284-L334 ## Tools Used None ## Recommended Mitigation Steps Consider getting the received amount by calculating the difference of token balance (using balanceOf) before and after the transferFrom.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-axelar-findings/issues/4", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-axelar-findings", "body": "Typos  https://github.com/code-423n4/2022-04-axelar/blob/dee2f2d352e8f20f20027977d511b19bfcca23a3/src/AxelarGateway.sol#L360 Change 'addressed' to 'address'  https://github.com/code-423n4/2022-04-axelar/blob/dee2f2d352e8f20f20027977d511b19bfcca23a3/src/AxelarGatewayMultisig.sol#L187 Change 'needed to we can get' to 'needed so we can get' or 'needed to get'  https://github.com/code-423n4/2022-04-axelar/blob/dee2f2d352e8f20f20027977d511b19bfcca23a3/src/AxelarGatewayMultisig.sol#L340 Change 'needed to we can get' to 'needed so we can get' or 'needed to get'"}, {"title": "no sanity checks on minDiscount", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/185", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L356   # Vulnerability details  Unlike maxDiscount, minDiscount is missing some sanity checks: minDiscount should be smaller than MAX_BPS minDoscount should be smaller than maxDiscount  "}, {"title": "Stale price used when `citadelPriceFlag` is cleared", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/176", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/Funding.sol#L430-L437   # Vulnerability details  During the [video](https://drive.google.com/file/d/1hCzQrgZEsbd0t2mtuaXm7Cp3YS-ZIlw3/view?usp=sharing) it was explained that the policy operations team was meant to be a nimble group that could change protocol values considered to be safe. Further, it was explained that since pricing comes from an oracle, and there would have to be unusual coordination between the two to affect outcomes, the group was given the ability to clear the pricing flag to get things moving again once the price was determined to be valid  ## Impact If an oracle price falls out of the valid min/max range, the `citadelPriceFlag` is set to true, but the out-of-bounds value is not stored. If the policy operations team calls `clearCitadelPriceFlag()`, the stale price from before the flag will be used. Not only is it an issue because of stale prices, but this means the policy op team now has a way to affect pricing not under the control of the oracle (i.e. no unusual coordination required to affect an outcome). Incorrect pricing leads to incorrect asset valuations, and loss of funds.  ## Proof of Concept  The flag is set but the price is not stored File: src/Funding.sol (lines [427-437](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/Funding.sol#L427-L437)) ```solidity         if (             _citadelPriceInAsset < minCitadelPriceInAsset ||             _citadelPriceInAsset > maxCitadelPriceInAsset         ) {             citadelPriceFlag = true;             emit CitadelPriceFlag(                 _citadelPriceInAsset,                 minCitadelPriceInAsset,                 maxCitadelPriceInAsset             );         } else { ```  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always set the `citadelPriceInAsset`   "}, {"title": "New vest reset `unlockBegin` of existing vest without removing vested amount", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/158", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L143 https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L109   # Vulnerability details  ## Impact When `vest` is called by xCTDL vault, the previous amount will re-lock according to the new vesting timeline. While this is as described in L127, `claimableBalance` might revert due to underflow if `vesting[recipient].claimedAmounts` > 0 because the user will need to vest the `claimedAmounts` again which should not be an expected behavior as it is already vested.  ## Proof of Concept https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L143 ```         vesting[recipient].lockedAmounts =             vesting[recipient].lockedAmounts +             _amount;         vesting[recipient].unlockBegin = _unlockBegin;         vesting[recipient].unlockEnd = _unlockBegin + vestingDuration; ``` https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadelVester.sol#L109 ```         uint256 locked = vesting[recipient].lockedAmounts;         uint256 claimed = vesting[recipient].claimedAmounts;         if (block.timestamp >= vesting[recipient].unlockEnd) {             return locked - claimed;         }         return             ((locked * (block.timestamp - vesting[recipient].unlockBegin)) /                 (vesting[recipient].unlockEnd -                     vesting[recipient].unlockBegin)) - claimed; ```  ## Recommended Mitigation Steps Reset claimedAmounts on new vest ```         vesting[recipient].lockedAmounts =             vesting[recipient].lockedAmounts -              vesting[recipient].claimedAmounts +             _amount;         vesting[recipient].claimedAmounts = 0         vesting[recipient].unlockBegin = _unlockBegin;         vesting[recipient].unlockEnd = _unlockBegin + vestingDuration; ```  "}, {"title": "Funding.deposit() doesn't work if there is no discount set", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/149", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L177 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L202 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L184 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L769   # Vulnerability details  ## Impact The Funding contract's `deposit()` function uses the `getAmountOut()` function to determine how many citadel tokens the user should receive for their deposit. But, if no discount is set, the function always returns 0. Now the `deposit()` function tries to deposit 0 tokens for the user through the StakedCitadel contract. But, that function requires the number of tokens to be `!= 0`. The transaction reverts.  This means, that no deposits are possible. Unless there is a discount.  ## Proof of Concept `Funding.deposit()` calls `getAmountOut()`: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L177  Here's the [`getAmountOut()` function](https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L202): ```sol     function getAmountOut(uint256 _assetAmountIn)         public         view         returns (uint256 citadelAmount_)     {         uint256 citadelAmountWithoutDiscount = _assetAmountIn * citadelPriceInAsset;          if (funding.discount > 0) {             citadelAmount_ =                 (citadelAmountWithoutDiscount * MAX_BPS) /                 (MAX_BPS - funding.discount);         }          // unless the above if block is executed, `citadelAmount_` is 0 when this line is executed.         // 0 = 0 / x         citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;     } ```  Call to `StakedCitadel.depositFor()`: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/Funding.sol#L184  require statement that makes the whole transaction revert: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L769  ## Tools Used none  ## Recommended Mitigation Steps Change the `getAmountOut()` function to:  ```sol     function getAmountOut(uint256 _assetAmountIn)         public         view         returns (uint256 citadelAmount_)     {          uint256 citadelAmount_ = _assetAmountIn * citadelPriceInAsset;          if (funding.discount > 0) {             citadelAmount_ =                 (citadelAmount_ * MAX_BPS) /                 (MAX_BPS - funding.discount);         }          citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;     } ```  "}, {"title": "StakedCitadel doesn't use correct balance for internal accounting", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/74", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L772-L776 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L881-L893   # Vulnerability details  ## Impact The StakedCitadel contract's `balance()` function is supposed to return the balance of the vault + the balance of the strategy. But, it only returns the balance of the vault. The balance is used to determine the number of shares that should be minted when depositing funds into the vault and the number of shares that should be burned when withdrawing funds from it.  Since most of the funds will be located in the strategy, the vault's balance will be very low. Some of the issues that arise from this:  **You can't deposit to a vault that already minted shares but has no balance of the underlying token**:  1. fresh vault with 0 funds and 0 shares 2. Alice deposits 10 tokens. She receives 10 shares back (https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888) 3. Vault's tokens are deposited into the strategy (now `balance == 0` and `totalSupply == 10`) 4. Bob tries to deposit but the transaction fails because the contract tries to divide by zero: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890 (`pool == balance()`)  **You get more shares than you should** 1. fresh vault with 0 funds and 0 shares 2. Alice deposits 10 tokens. She receives 10 shares back (https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888) 3. Vault's tokens are deposited into the strategy (now `balance == 0` and `totalSupply == 10`) 4. Bob now first transfers 1 token to the vault so that the balance is now `1` instead of `0`. 5. Bob deposits 5 tokens. He receives `5 * 10 / 1 == 50` shares: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890  Now, the vault received 15 tokens. 10 from Alice and 5 from Bob. But Alice only has 10 shares while Bob has 50. Thus, Bob can withdraw more tokens than he should be able to.  It simply breaks the whole accounting of the vault.  ## Proof of Concept The comment says that it should be vault's + strategy's balance: https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295  Here's another vault from the badger team where the function is implemented correctly: https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262  ## Tools Used none  ## Recommended Mitigation Steps Add the strategy's balance to the return value of the`balance()` function like [here](https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262).  "}, {"title": "KnightingRound tokenOutPrice changes", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/73", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/KnightingRound.sol#L162-L204   # Vulnerability details  ## Impact `Function.buy` buys the tokens for whatever price is set as `tokenOutPrice`. This might lead to accidental collisions or front-running attacks when user is trying to buy the tokens and his transaction is being included after the transaction of changing the price of the token via `setTokenOutPrice`.  Scenario: 1. User wants to `buy` tokens and can see price `tokenOutPrice` 2. User likes the price and issues a transaction to `buy` tokens 3. At the same time `CONTRACT_GOVERNANCE_ROLE` account is increasing `tokenOutPrice` through `setTokenOutPrice` 4. `setTokenOutPrice` transaction is included before user's `buy` transaction 5. User buys tokens with the price he was not aware of  Another variation of this attack can be performed using front-running.  ## Proof of Concept * https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/KnightingRound.sol#L162-L204  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to add additional parameter `uint256 believedPrice` to `KnightingRound.buy` function and check if `believedPrice` is equal to `tokenOutPrice`.  "}, {"title": "Guaranteed citadel profit", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/CitadelMinter.sol#L217   # Vulnerability details  ## Impact User can sandwich `mintAndDistribute` function if mintable is high enough - Deposit before - Withdraw after - Take after 21 days citadels  ## Proof of Concept `mintAndDistribute` increase a price of staking share, that allows to withdraw more than deposited. user takes part of distributed citadels, so different users have smaller profit from distribution  ## Tools Used  ## Recommended Mitigation Steps Call `mintAndDistribute` through flashbots  "}, {"title": "StakedCitadel: wrong setupVesting function name", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/9", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L830   # Vulnerability details  ## Impact In the _withdraw function of the StakedCitadel contract, the setupVesting function of vesting is called, while in the StakedCitadelVester contract, the function name is vest, which will cause the _withdraw function to fail, so that the user cannot withdraw the tokens.  ```         IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);         token.safeTransfer(vesting, _amount);         ...     function vest(         address recipient,         uint256 _amount,         uint256 _unlockBegin     ) external {         require(msg.sender == vault, \"StakedCitadelVester: only xCTDL vault\");         require(_amount > 0, \"StakedCitadelVester: cannot vest 0\");          vesting[recipient].lockedAmounts =             vesting[recipient].lockedAmounts +             _amount;         vesting[recipient].unlockBegin = _unlockBegin;         vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;          emit Vest(             recipient,             vesting[recipient].lockedAmounts,             _unlockBegin,             vesting[recipient].unlockEnd         );     } ``` ## Proof of Concept https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L830 https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/interfaces/citadel/IVesting.sol#L5  ## Tools Used None ## Recommended Mitigation Steps  Use the correct function name ``` interface IVesting {     function vest(         address recipient,         uint256 _amount,         uint256 _unlockBegin     ) external; } ... IVesting(vesting).vest(msg.sender, _amount, block.timestamp); token.safeTransfer(vesting, _amount); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/8", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-badger-citadel-findings", "body": "Median Oracle code non-existent, yet file exists:  https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/oracles/MedianOracle.sol"}, {"title": "Malicious Stakers can grief Keepers", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/194", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L727-L729   # Vulnerability details  ## Impact  A Staker -- that has their top-up position removed after `execute` is called by a Keeper -- can always cause the transaction to revert. They can do this by deploying a smart contract to the `payer` address that has implemented a `receive()` function that calls `revert()`. The revert will be triggered by the following [lines](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L727-L729) in `execute`  ```sol if (vars.removePosition) {     gasBank.withdrawUnused(payer); } ```  This will consume some gas from the keeper while preventing them accruing any rewards for performing the top-up action.  ## Proof of Concept  I have implemented a [PoC](https://github.com/sseefried/codearena-backd-2022-04/blob/4d3c3ba7a0139bea01a0bdee9e84a7921572a9fd/backd/tests/top_up_action/sseefried_test_staker_grief.py) in a fork of the contest repo. The attacker's contract can be found [here](https://github.com/sseefried/codearena-backd-2022-04/blob/4d3c3ba7a0139bea01a0bdee9e84a7921572a9fd/backd/contracts/AliceAttacker.sol).  ## Tools Used Manual inspection  ## Recommend Mitigation Steps  To prevent this denial of service attack some way of blacklisting badly behaved Stakers should be added.   "}, {"title": "Lack of `safeApprove(0)` prevents some registrations, and the changing of stakers and LP tokens", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/180", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L50 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L721   # Vulnerability details  OpenZeppelin's `safeApprove()` will revert if the account already is approved and the new `safeApprove()` is done with a non-zero value ```solidity     function safeApprove(         IERC20 token,         address spender,         uint256 value     ) internal {         // safeApprove should only be called when setting an initial allowance,         // or when resetting it to zero. To increase and decrease it, use         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'         require(             (value == 0) || (token.allowance(address(this), spender) == 0),             \"SafeERC20: approve from non-zero to non-zero allowance\"         );         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));     } ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fcf35e5722847f5eadaaee052968a8a54d03622a/contracts/token/ERC20/utils/SafeERC20.sol#L45-L58  ## Impact Customers can be prevented from `register()`ing the same `token`/`stakerVaultAddress` as another customer; and once changed away from, stakers and lptokens can't be used in the future.  ## Proof of Concept There are multiple places where `safeApprove()` is called a second time without setting the value to zero first.  `register()` calls `lockFunds()` for each user registration, and since users will use the same tokens and staker vaults, the second user's `register()` call will fail: ```solidity File: backd/contracts/actions/topup/TopUpAction.sol   #1  36       function lockFunds( 37           address stakerVaultAddress, 38           address payer, 39           address token, 40           uint256 lockAmount, 41           uint256 depositAmount 42       ) external { 43           uint256 amountLeft = lockAmount; 44           IStakerVault stakerVault = IStakerVault(stakerVaultAddress); 45    46           // stake deposit amount 47           if (depositAmount > 0) { 48               depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount; 49               IERC20(token).safeTransferFrom(payer, address(this), depositAmount); 50               IERC20(token).safeApprove(stakerVaultAddress, depositAmount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L36-L50  The changing of either the staker or an lp token is behind a time-lock, and once the time has passed, the changed variables rely on this function: ```solidity File: backd/contracts/pool/LiquidityPool.sol   #2  717       function _approveStakerVaultSpendingLpTokens() internal { 718           address staker_ = address(staker); 719           address lpToken_ = address(lpToken); 720           if (staker_ == address(0) || lpToken_ == address(0)) return; 721           IERC20(lpToken_).safeApprove(staker_, type(uint256).max); 722       } ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L717-L722  If a bug is found in a new `staker` or `lpToken` and the governor wishes to change back to the old one(s), the governor will have to wait for the time-lock delay only to find out that the old value(s) cause the code to revert.  I've filed the other more-severe instances as a separate high-severity issue, and flagged the remaining low-severity instances in my QA report  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always do `safeApprove(0)` if the allowance is being changed, or use `safeIncreaseAllowance()`   "}, {"title": "Customers cannot be `topUp()`ed a second time", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/178", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L71 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L120 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L53 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L847   # Vulnerability details  OpenZeppelin's `safeApprove()` will revert if the account already is approved and the new `safeApprove()` is done with a non-zero value ```solidity     function safeApprove(         IERC20 token,         address spender,         uint256 value     ) internal {         // safeApprove should only be called when setting an initial allowance,         // or when resetting it to zero. To increase and decrease it, use         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'         require(             (value == 0) || (token.allowance(address(this), spender) == 0),             \"SafeERC20: approve from non-zero to non-zero allowance\"         );         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));     } ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fcf35e5722847f5eadaaee052968a8a54d03622a/contracts/token/ERC20/utils/SafeERC20.sol#L45-L58  ## Impact Customers cannot be topped up a second time, which will cause them to be liquidated even though they think they're protected  ## Proof of Concept There are multiple places where `safeApprove()` is called a second time without setting the value to zero first. The instances below are all related to topping up.  Compound-specific top-ups will fail the second time around when approving the `ctoken` again: ```solidity File: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #1  50       function topUp( 51           bytes32 account, 52           address underlying, 53           uint256 amount, 54           bytes memory extra 55       ) external override returns (bool) { 56           bool repayDebt = abi.decode(extra, (bool)); 57           CToken ctoken = cTokenRegistry.fetchCToken(underlying); 58           uint256 initialTokens = ctoken.balanceOf(address(this)); 59    60           address addr = account.addr(); 61    62           if (repayDebt) { 63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken); 64               if (amount == 0) return true; 65           } 66    67           uint256 err; 68           if (underlying == address(0)) { 69               err = ctoken.mint{value: amount}(amount); 70           } else { 71               IERC20(underlying).safeApprove(address(ctoken), amount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L50-L71  Compound-specific top-ups will also fail when trying to repay debt: ```solidity File: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #2  62           if (repayDebt) { 63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken); 64               if (amount == 0) return true; 65           } ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L62-L65  Aave-specific top-ups will fail for the `lendingPool`: ```solidity File: backd/contracts/actions/topup/handlers/AaveHandler.sol   #3  36       function topUp( 37           bytes32 account, 38           address underlying, 39           uint256 amount, 40           bytes memory extra 41       ) external override returns (bool) { 42           bool repayDebt = abi.decode(extra, (bool)); 43           if (underlying == address(0)) { 44               weth.deposit{value: amount}(); 45               underlying = address(weth); 46           } 47    48           address addr = account.addr(); 49    50           DataTypes.ReserveData memory reserve = lendingPool.getReserveData(underlying); 51           require(reserve.aTokenAddress != address(0), Error.UNDERLYING_NOT_SUPPORTED); 52    53           IERC20(underlying).safeApprove(address(lendingPool), amount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L36-L53  The `TopUpAction` itself fails for the `feeHandler`: ```solidity File: backd/contracts/actions/topup/TopUpAction.sol   #4  840       function _payFees( 841           address payer, 842           address beneficiary, 843           uint256 feeAmount, 844           address depositToken 845       ) internal { 846           address feeHandler = getFeeHandler(); 847           IERC20(depositToken).safeApprove(feeHandler, feeAmount); ``` https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L840-L847  I've filed the other less-severe instances as a separate medium-severity issue, and flagged the remaining low-severity instances in my QA report  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always do `safeApprove(0)` if the allowance is being changed, or use `safeIncreaseAllowance()`   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/165", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/oracles/ChainlinkUsdWrapper.sol#L56   # Vulnerability details  ## Impact The current code returns the following: ``` return (roundId_, (answer_ * _ethPrice()) / 1e8, startedAt_, updatedAt_, answeredInRound_); ``` If we're wrapping an asset that's relatively stable to eth price, the `answer` here might not be updated constantly. By returning the startedAt of the last answer update, it's possible that this answer be considered \"stale\" from the protocol.  ## Recommended Mitigation Steps  It's better to return the new `updatedAt_ ` at the greater of the two:   * `updatedAt_ ` from eth oracle,  * `updatedAt_ ` from the asset oracle  This way, if asset/eth is unchanged for a while, but there's a eth price move, we capture the correct `updatedAt` timestamp  "}, {"title": "_revokeRole doesn't remove account from roleMember set", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/164", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/access/RoleManager.sol#L155   # Vulnerability details  ## Impact The function doesn't remove the address from _roleMembers[role] set, which will mess up with the roleCount  ## Proof of Concept  ## Tools Used  ## Recommended Mitigation Steps ``` _roles[role].members[account] = false; _roleMembers[role].remove(account); ```  "}, {"title": "CvxCrvRewardsLocker implements a swap without a slippage check that can result in a loss of funds through MEV", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/161", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/CvxCrvRewardsLocker.sol#L247-L252   # Vulnerability details  ## Impact The CvxCrvRewardsLocker contract swaps tokens through the CRV cvxCRV pool. But, it doesn't use any slippage checks. The swap is at risk of being frontrun / sandwiched which will result in a loss of funds.  Since MEV is very prominent I think the chance of that happening is pretty high.  ## Proof of Concept Here's the swap: https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/CvxCrvRewardsLocker.sol#L247-L252  ## Tools Used none  ## Recommended Mitigation Steps Use a proper value for `minOut` instead of `0`.  "}, {"title": "[WP-M11] `CEthInterface#mint()` reading non-existing returns makes `topUp()` with native token alway revert", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/125", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L345   # Vulnerability details  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L345  ```solidity  function mint() external payable returns (uint256); ```  `mint()` for native cToken (`CEther`) will return nothing, while the current `CEthInterface` interface defines the returns as `(uint256)`.  In the current implementation, the interface for `CToken` is used for both `CEther` and `CErc20`.  As a result, the transaction will revert with the error: `function returned an unexpected amount of data` when `topUp()` with the native token (ETH).  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L57-L70  ```solidity     CToken ctoken = cTokenRegistry.fetchCToken(underlying);     uint256 initialTokens = ctoken.balanceOf(address(this));      address addr = account.addr();      if (repayDebt) {         amount -= _repayAnyDebt(addr, underlying, amount, ctoken);         if (amount == 0) return true;     }      uint256 err;     if (underlying == address(0)) {         err = ctoken.mint{value: amount}(amount);     } ```  Ref:  | method  | CEther | CErc20 | |----------|------------|-------------| | mint()   | revert      | error code  | | redeem() | error code | error code  | | repayBorrow() | revert | error code  | | repayBorrowBehalf() | revert | error code  |   - Compound's cToken mint doc: https://compound.finance/docs/ctokens#mint - Compound CEther.mint() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L46 - Compound CErc20.mint() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CErc20.sol#L46  "}, {"title": "[WP-M9] `CEthInterface#repayBorrowBehalf()` reading non-existing returns makes  `_repayAnyDebt()` with CEther always revert", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/121", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L355-L358   # Vulnerability details  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L355-L358  ```solidity function repayBorrowBehalf(address borrower, uint256 repayAmount)         external         payable         returns (uint256); ```  `repayBorrowBehalf()` for native cToken (`CEther`) will return nothing, while the current `CEthInterface` interface defines the returns as `(uint256)`.  As a result, `ether.repayBorrowBehalf()` will always revert  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L117-L118  ```solidity     CEther cether = CEther(address(ctoken));     err = cether.repayBorrowBehalf{value: debt}(account); ```  Ref:  | method  | CEther | CErc20 | |----------|------------|-------------| | mint()   | revert      | error code  | | redeem() | error code | error code  | | repayBorrow() | revert | error code  | | repayBorrowBehalf() | revert | error code  |   - Compound cToken Repay Borrow Behalf doc: https://compound.finance/docs/ctokens#repay-borrow-behalf - Compound CEther.repayBorrowBehalf() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L92-L95 - Compound CErc20.repayBorrowBehalf() https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CErc20.sol#L94-L97  "}, {"title": "[WP-M8] `CompoundHandler#topUp()` Using the wrong function selector makes native token `topUp()` always revert", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/120", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L44-L47   # Vulnerability details  https://github.com/compound-finance/compound-protocol/blob/v2.8.1/contracts/CEther.sol#L44-L47  ```solidity function mint() external payable {     (uint err,) = mintInternal(msg.value);     requireNoError(err, \"mint failed\"); } ```  `mint()` for native cToken (`CEther`) does not have any parameters, as the `Function Selector` is based on `the function name with the parenthesised list of parameter types`, when you add a nonexisting `parameter`, the `Function Selector` will be incorrect.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/interfaces/vendor/CTokenInterfaces.sol#L316  ```solidity     function mint(uint256 mintAmount) external payable virtual returns (uint256); ```  The current implementation uses the same `CToken` interface for both `CEther` and `CErc20` in `topUp()`, and `function mint(uint256 mintAmount)` is a nonexisting function for `CEther`.  As a result, the native token `topUp()` always revert.  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L57-L70  ```solidity     CToken ctoken = cTokenRegistry.fetchCToken(underlying);     uint256 initialTokens = ctoken.balanceOf(address(this));      address addr = account.addr();      if (repayDebt) {         amount -= _repayAnyDebt(addr, underlying, amount, ctoken);         if (amount == 0) return true;     }      uint256 err;     if (underlying == address(0)) {         err = ctoken.mint{value: amount}(amount);     } ```  See also:  - Compound's cToken mint doc: https://compound.finance/docs/ctokens#mint  "}, {"title": "Inconsistency between constructor and setting method for slippageTolerance", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/97", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L38-L43 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L109-L114   # Vulnerability details  ## Impact in the setSlippageTolerance(L119) method you have certain requirements to set slippageTolerance, but in the constructor you don't.    ## Recommended Mitigation Steps I would add the corresponding validations to the constructor   "}, {"title": "Position owner should set allowed slippage", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L154 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L187   # Vulnerability details  ## Impact The default swap slippage of 5% allows malicious keepers to sandwich attack topup. Additionally, up to 40% (_MIN_SWAPPER_SLIPPAGE) slippage allows malicious owner to sandwich huge amounts from topup  ## Proof of Concept Keeper can bundle swaps before and after topup to sandwich topup action, in fact it's actually in their best interest to do so.  ## Tools Used  ## Recommended Mitigation Steps Allow user to specify max swap slippage when creating topup similar to how it's specified on uniswap or sushiswap to block attacks from both keepers and owners  "}, {"title": "function lockFunds in TopUpActionLibrary can cause serious fund lose. fee and Capped bypass. It's not calling stakerVault.increaseActionLockedBalance when transfers stakes.", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/60", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L57-L65   # Vulnerability details  ## Impact In function TopUpActionLibrary.lockFunds when transfers stakes from payer it doesn't call stakerVault.increaseActionLockedBalance for that payer so stakerVault.actionLockedBalances[payer] is not get updated for payer and stakerVault.stakedAndActionLockedBalanceOf(payer) is going to show wrong value and any calculation based on this function is gonna be wrong which will cause fund lose and theft and some restriction bypasses.  ## Proof of Concept When user wants to create a TopUpAction. so he seposit his funds to Pool and get LP token. then stake the LP token in StakerVault and use that stakes to create a TopUp position with function TopUpAction.register. This function transfer user stakes (locks user staks) and create his position. for transferring and locking user stakes it uses TopUpActionLibrary.lockFunds. function lockFunds transfers user stakes but don't call stakerVault.increaseActionLockedBalance for the payer which cause that stakerVault.actionLockedBalances[payer] to get different values(not equal to position.depositTokenBalance). function StakerVault.stakedAndActionLockedBalanceOf(account) uses stakerVault.actionLockedBalances[account] so it will return wrong value and any where in code that uses stakedAndActionLockedBalanceOf() is going to cause problems. three part of the codes uses stakerVault.stakedAndActionLockedBalanceOf(): 1- LiqudityPool.depositFor() for checking user total deposits to be less than depositCap. 2- LiqudityPool._updateUserFeesOnDeposit() for updating user fee on new deposits. 3- userCheckpoint() for calculating user rewards. attacker can use #1 and #2 to bypass high fee payment and max depositCap and #3 will cause users to lose  rewards.  The detail steps: 1- user deposit fund to Pool and get LP token. 2- user stakes LP token in StakerVault. 3- user approve TopUpAction address to transfer his staks in StakerVault. 3- user use all his stakes to create a position with TopUpAction.register() function. 3.1- register() will call lockFunds to transfer and lock user stakes. 3.2- lockFunds() will transfer user stakes with stakerVault.transferFrom() but don't call stakerVault.increaseActionLockedBalance() so StakerVault.actionLockedBalances[user] will be zero. 3.3- StakerVault.balance[useer] will be zero too because his stakes get transfers in 3.2 4- StakerVault.stakedAndActionLockedBalanceOf(user) will return zero (user has some locked stakes in TopUpAction but because of the bug calculation get out of sync)  In this moment user will lose all the rewards that are minted in LpGauge. becasue userCheckpoint() use stakerVault.stakedAndActionLockedBalanceOf(user) for calculating rewards which is zero  and new rewards will be zero too.  Attacker can use this process to bypass \"max deposit Cap\" and deposit any amount of assets he wants. because LiqudityPool.depositFor(address,uint256,uint256) uses stakedAndActionLockedBalanceOf to check user deposits which is zero so Attacker can deposit & stake & register to make his balance zero and repeat this and in the end reset his TopUp positions to get back his large stakes which are multiple time bigger than \"max deposit Cap\"  Attacker can also use this process to bypass fee penalties for early withdraw. because LiqudityPool._updateUserFeesOnDeposit() to get user current balance use stakedAndActionLockedBalanceOf() which is zero. so the value of shareExisting variable become zero and newFeeRatio will be calculated based on feeOnDeposit which can be minFee if asset is already in wallet for some time.   ## Tools Used VIM  ## Recommended Mitigation Steps add this line to TopUpActionLibrary.lockFunds() after stakerVault.transferFrom():  stakerVault.increaseActionLockedBalance(payer, amountLeft);  "}, {"title": "Griefer can extend period of higher withdrawal fees", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/56", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L790-L792   # Vulnerability details  ## Impact The `_updateUserFeesOnDeposit()` function in `LiquidityPool.sol` is used to update a user's withdrawal fees after an action such as deposit, transfer in, etc. The withdrawal fee decays toward a minimum withdrawal fee over a period of 1 or 2 weeks (discussed with developer). Since anyone can transfer lp tokens to any user, a griefer can transfer 1 wei of lp tokens to another user to reset their `lastActionTimestamp` used in the withdrawal fee calculation.  The developers nicely weight the updated withdrawal fee by taking the original balance/original fee vs the added balance/added fee. The attacker will only be able to extend the runway of the withdrawal fee cooldown by resetting the `lastActionTimestamp` for future calculations. Example below:  ## Proof of Concept Assumptions: - MinWithdrawalFee = 0% //For easy math - MaxWithdrawalFee = 10% - timeToWait = 2 weeks  ### Steps - User A has `100 wei` of shares - User A waits 1 week (Current withdrawal fee = 5%) - User B deposits, receives `1 wei` of shares, current withdrawal fee = 10% - User B immediately transfers `1 wei` of shares to User A  Based on the formula to calculated User A's new feeRatio:  ```         uint256 newFeeRatio = shareExisting.scaledMul(newCurrentFeeRatio) +             shareAdded.scaledMul(feeOnDeposit); ```  In reality, User A's withdrawal fee will only increase by a negligible amount since the shares added were very small in proportion to the original shares. We can assume user A's current withdrawal fee is still 5%.  The issue is that the function then reset's User A's `lastActionTimestamp` to the current time. This means that User A will have to wait the maximum 2 weeks for the withdrawal fee to reduce from 5% to 0%. Effectively the cooldown runway is the same length as the original runway length, so the decay down to 0% will take twice as long.  `meta.lastActionTimestamp = uint64(_getTime());`  ## Tools Used Manual Review  ## Recommended Mitigation Steps Instead of resetting `lastActionTimestamp` to the current time, scale it the same way the `feeRatio` is scaled. I understand that this would technically not be the timestamp of the last action, so the variable would probably need to be renamed.  "}, {"title": "`call()` should be used instead of `transfer()` on an `address payable`", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/52", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/actions/topup/TopUpAction.sol#L291 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/pool/EthPool.sol#L30 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/strategies/BkdEthCvx.sol#L77 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/strategies/BkdEthCvx.sol#L93 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/strategies/BkdEthCvx.sol#L117 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/vault/EthVault.sol#L29 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/vault/EthVault.sol#L37 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/vault/VaultReserve.sol#L81   # Vulnerability details  This is a classic Code4rena issue:  - https://github.com/code-423n4/2021-04-meebits-findings/issues/2 - https://github.com/code-423n4/2021-10-tally-findings/issues/20 - https://github.com/code-423n4/2022-01-openleverage-findings/issues/75  ## Impact The use of the deprecated `transfer()` function for an address will inevitably make the transaction fail when:  1. The claimer smart contract does not implement a payable function. 2. The claimer smart contract does implement a payable fallback which uses more than 2300 gas unit. 3. The claimer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the call's gas usage above 2300.  Additionally, using higher than 2300 gas might be mandatory for some multisig wallets.  ## Impacted lines:  ```solidity backd/contracts/pool/EthPool.sol:   30:         to.transfer(amount);  backd/contracts/strategies/BkdEthCvx.sol:    77:             payable(vault).transfer(amount);    93:         payable(vault).transfer(amount);   117:         payable(vault).transfer(underlyingBalance);  backd/contracts/vault/EthVault.sol:   29:         payable(to).transfer(amount);    37:         payable(addressProvider.getTreasury()).transfer(amount);    backd/contracts/vault/VaultReserve.sol:   81:             payable(msg.sender).transfer(amount); ```  ## Recommended Mitigation  I recommend using `call()` instead of `transfer()`  "}, {"title": "`getNewCurrentFees` reverts when `minFeePercentage` > `feeRatio`", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L694   # Vulnerability details  ## Impact Depositors won't be able to transfer or redeem funds temporarily.   The problem is caused by the implementation of `LiquidityPool.getNewCurrentFees`:  ``` function getNewCurrentFees(     uint256 timeToWait,     uint256 lastActionTimestamp,     uint256 feeRatio ) public view returns (uint256) {     uint256 timeElapsed = _getTime() - lastActionTimestamp;     uint256 minFeePercentage = getMinWithdrawalFee();     if (timeElapsed >= timeToWait) {         return minFeePercentage;     }     uint256 elapsedShare = timeElapsed.scaledDiv(timeToWait);     return feeRatio - (feeRatio - minFeePercentage).scaledMul(elapsedShare); } ``` The last line requires the current `feeRatio` to be higher than `minFeePercentage` or the function will revert. When this condition is broken, some critical functions such as transferring tokens and redeeming will be unusable. Affected users need to wait until enough time has elapsed and `getNewCurrentFees` returns `minFeePercentage` on [L691](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L691).  This could happen if governance changes the `MinWithdrawalFee` to be higher than a user's feeRatio.  ## Proof of Concept - Initial `MinWithdrawalFee` is set to 0, `MaxWithdrawalFee` is set to 0.03e18. - Alice deposits fund and receives LP token. Alice's `feeRatio` is now set to 0.03e18 (the current `MaxWithdrawalFee`). - Governance changes `MaxWithdrawalFee` to `0.05e18` and `MinWithdrawalFee` to `0.04e18`. - `minFeePercentage` is now higher than Alice's `feeRatio` and she can't transfer nor redeem the LP token until `timeElapsed >= timeToWait`.  ## Recommended Mitigation Steps Add a new condition in `getNewCurrentFees` [L690](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L690) to account for this case: ``` if (timeElapsed >= timeToWait || minFeePercentage > feeRatio) {     return minFeePercentage; } ```   "}, {"title": "`_decimalMultiplier` doesn't account for tokens with decimals higher than 18", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/49", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L287-L289 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L318-L320 https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L335-L337   # Vulnerability details  ## Impact In `StrategySwapper`, swapping from or to tokens with decimals higher than 18 will always revert. This will cause inabilities for strategies to harvest rewards.  ## Proof of Concept [L288](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L288) will revert when `token_` has higher than 18 decimals. ```  return 10**(18 - IERC20Full(token_).decimals()); ```   ## Recommended Mitigation Steps Consider modifying how `_decimalMultiplier` works so it could handle tokens with higher than 18 decimals.   Update the calculation of `_minTokenAmountOut` and `_minWethAmountOut` to account when decimals are higher/lower than `18`.  "}, {"title": "ERC777 tokens can bypass `depositCap` guard", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L523   # Vulnerability details  ## Impact When ERC777 token is used as the underlying token for a `LiquidityPool`, a depositor can reenter `depositFor` and bypass the `depositCap` requirement check, resulting in higher total deposit than intended by governance.  ## Proof of Concept - An empty ERC777 liquidity pool is capped at 1.000 token. - Alice deposits 1.000 token. Before the token is actually sent to the contract, `tokensToSend` ERC777 hook is called and Alice reenters `depositFor`. - As the previous deposit hasn't been taken into account, the reentrancy passes the `depositCap` check. - Pool has 2.000 token now, despite the 1.000 deposit cap.  ## Recommended Mitigation Steps Add reentrancy guards to `depositFor`.   "}, {"title": "User can steal all rewards due to checkpoint after transfer", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/36", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/StakerVault.sol#L112-L119   # Vulnerability details  ## Impact I believe this to be a high severity vulnerability that is potentially included in the currently deployed `StakerVault.sol` contract also. The team will be contacted immediately following the submission of this report.  In `StakerVault.sol`, the user checkpoints occur AFTER the balances are updated in the `transfer()` function. The user checkpoints update the amount of rewards claimable by the user. Since their rewards will be updated after transfer, a user can send funds between their own accounts and repeatedly claim maximum rewards since the pool's inception.  In every actionable function except `transfer()` of `StakerVault.sol`, a call to `ILpGauge(lpGauge).userCheckpoint()` is correctly made BEFORE the action effects.  ## Proof of Concept Assume a certain period of time has passed since the pool's inception. For easy accounting, assume `poolStakedIntegral` of `LpGauge.sol` equals `1`. The `poolStakedIntegral` is used to keep track of the current reward rate.  Steps: - Account A stakes 1000 LP tokens. `balances[A] += 1000`  - In the same `stakeFor()` function, `userCheckpoint()` was already called so A will already have `perUserShare[A]` set correctly based on their previously 0 balance and the current `poolStakedIntegral`. - Account A can immediately send all balance to Account B via `transfer()`. - Since the checkpoint occurs after the transfer, B's balance will increase and then `perUserShare[B]` will be updated. The calculation for `perUserShare` looks as follows.  ``` perUserShare[user] += (             (stakerVault.stakedAndActionLockedBalanceOf(user)).scaledMul(                 (poolStakedIntegral_ - perUserStakedIntegral[user])             )         ); ```  Assuming Account B is new to the protocol, their `perUserStakedIntegral[user]` will default to `0`.  `perUserShare[B] += 1000 * (1 - 0) = 1000`  - B is able to call `claimRewards()` and mint all 1000 reward tokens. - B then calls `transfer()` and sends all 1000 staked tokens to Account C. - Same calculation occurs, and C can claim all 1000 reward tokens. - This process can be repeated until the contract is drained of reward tokens.  ## Tools Used Static review.  ## Recommended Mitigation Steps In `StakerVault.transfer()`, move the call to `ILpGauge(lpGauge).userCheckpoint()` to before the balances are updated.  "}, {"title": "Chainlink's latestRoundData might return stale or incorrect results", "html_url": "https://github.com/code-423n4/2022-04-backd-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "reviewed"], "target": "2022-04-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/oracles/ChainlinkOracleProvider.sol#L55   # Vulnerability details  ## Impact On ChainlinkOracleProvider.sol and ChainlinkUsdWrapper.sol , we are using latestRoundData, but there is no check if the return value indicates stale data. ```     function _ethPrice() private view returns (int256) {         (, int256 answer, , , ) = _ethOracle.latestRoundData();         return answer;     } ...     function getPriceUSD(address asset) public view override returns (uint256) {         address feed = feeds[asset];         require(feed != address(0), Error.ASSET_NOT_SUPPORTED);          (, int256 answer, , uint256 updatedAt, ) = AggregatorV2V3Interface(feed).latestRoundData();          require(block.timestamp <= updatedAt + stalePriceDelay, Error.STALE_PRICE);         require(answer >= 0, Error.NEGATIVE_PRICE);          uint256 price = uint256(answer);         uint8 decimals = AggregatorV2V3Interface(feed).decimals();         return price.scaleFrom(decimals);     } ``` This could lead to stale prices according to the Chainlink documentation:  https://docs.chain.link/docs/historical-price-data/#historical-rounds https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round ## Proof of Concept https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/oracles/ChainlinkOracleProvider.sol#L55 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/oracles/ChainlinkUsdWrapper.sol#L64 ## Tools Used None ## Recommended Mitigation Steps ```     function _ethPrice() private view returns (int256) {         (uint80 roundID, int256 answer, , uint256 timestamp, uint80 answeredInRound) = _ethOracle.latestRoundData();         require(answeredInRound >= roundID, \"Stale price\");         require(timestamp != 0,\"Round not complete\");         require(answer > 0,\"Chainlink answer reporting 0\");         return answer;     } ...     function getPriceUSD(address asset) public view override returns (uint256) {         address feed = feeds[asset];         require(feed != address(0), Error.ASSET_NOT_SUPPORTED);         (uint80 roundID, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = AggregatorV2V3Interface(feed).latestRoundData();         require(answeredInRound >= roundID, \"Stale price\");         require(answer > 0,\" Error.NEGATIVE_PRICE\");         require(block.timestamp <= updatedAt + stalePriceDelay, Error.STALE_PRICE);          uint256 price = uint256(answer);         uint8 decimals = AggregatorV2V3Interface(feed).decimals();         return price.scaleFrom(decimals);     }  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/85", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "## Low Risk Issues  ### 1. `safeApprove()` is deprecated [Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead  ```solidity File: contracts/AaveV3YieldSource.sol   #1  183       IERC20(_tokenAddress()).safeApprove(address(_pool()), type(uint256).max); ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L183  ### 2. Comments should be enforced with `require()`s The comment below should be enforced with `require(decimals_ == _aToken.decimals())`. If this seems excessive, then why require `decimals_` be passed in at all? Why isn't `_aToken.decimals()` stored instead?  ```solidity File: contracts/AaveV3YieldSource.sol   #1  156     * @param decimals_ Number of decimals the shares (inhereted ERC20) will have. Same as underlying asset to ensure sane exchange rates for shares. ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L156  ### 3. Formula does not match what the code is doing  ```solidity File: contracts/AaveV3YieldSource.sol   #1  360      // shares = (tokens * totalShares) / yieldSourceATokenTotalSupply 361      return _supply == 0 ? _tokens : _tokens.mul(_supply).div(aToken.balanceOf(address(this))); ``` should be `// shares = (tokens * totalSupply) / yieldSourceBalanceOfAToken` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L360-L361  ```solidity File: contracts/AaveV3YieldSource.sol   #2  372      // tokens = (shares * yieldSourceATokenTotalSupply) / totalShares 373      return _supply == 0 ? _shares : _shares.mul(aToken.balanceOf(address(this))).div(_supply); ``` should be `// tokens = (shares * yieldSourceBalanceOfAToken) / totalSupply` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L372-L373  ### 4. Revert if amount is zero There is already a check in one of the functions that the final token amount is not zero, but it would be better to check the input amount first in _all_ functions that take in an amount  ```solidity File: contracts/AaveV3YieldSource.sol   #1  231    function supplyTokenTo(uint256 _depositAmount, address _to) external override nonReentrant { ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L231  ```solidity File: contracts/AaveV3YieldSource.sol   #2  251    function redeemToken(uint256 _redeemAmount) external override nonReentrant returns (uint256) { ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L251  ```solidity File: contracts/AaveV3YieldSource.sol   #3  332    function transferERC20( 333      IERC20 _token, 334      address _to, 335      uint256 _amount 336    ) external onlyManagerOrOwner { ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L332-L336   ## Non-critical Issues  ### 1. Consider making whether to `safeApprove()` be based on a constructor argument Approvals are only needed if doing flash loans or liquidations. If these are not used by the strategy, there is no need for the approval, which will lower the attack surface.  ```solidity File: contracts/AaveV3YieldSource.sol   #1  183      IERC20(_tokenAddress()).safeApprove(address(_pool()), type(uint256).max); ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L183  ### 2. Function state mutability can be restricted to view The compiler warns about this issue during compilation. Add the `view` visibility to resolve the warning  ```solidity File: contracts/AaveV3YieldSource.sol   #1  203    function balanceOfToken(address _user) external override returns (uint256) { ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L203  ### 3. `public` functions not called by the contract should be declared `external` instead Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.  ```solidity File: contracts/AaveV3YieldSource.sol   #1  211   function depositToken() public view override returns (address) { ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L211  ### 4. Inconsistent variable-name-to-variable-type usage In the case below `_token` is an `address` whereas in all other instances, `_token` is an `IERC20`. Changing the name of the variable to something like `_tokenAddr` will make the code more readable and consistent  ```solidity File: contracts/AaveV3YieldSource.sol   #1  348    function _requireNotAToken(address _token) internal view { ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L348  ### 5. Typos  ```solidity File: contracts/AaveV3YieldSource.sol   #1  38      * @param decimals Number of decimals the shares (inhereted ERC20) will have. Same as underlying asset to ensure sane exchange rates for shares. ``` inhereted https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L38  ```solidity File: contracts/AaveV3YieldSource.sol   #2  156      * @param decimals_ Number of decimals the shares (inhereted ERC20) will have. Same as underlying asset to ensure sane exchange rates for shares. ``` inhereted https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L156  ### 6. Grammar A lot of the NatSpec/comments add a period to the end of fragments. Periods should only be used when there is both a noun phrase and a verb phrase  ```solidity File: contracts/AaveV3YieldSource.sol (various lines)   #1  ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol  ### 7. Use a more recent version of solidity Use a solidity version of at least 0.8.13 to get the ability to use `using for` with a list of free functions  ```solidity File: contracts/AaveV3YieldSource.sol   #1  3   pragma solidity 0.8.10; ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L3  ### 8. Function behavior doesn't match name The line below should use `_requireNotAToken()` but it doesn't because that function's `revert()` string specifically refers to the 'allowance' functions. The function NatSpec doesn't mention this fact. If the function wants different strings based on where it's called from, it can use `msg.sig` to choose the right one. An even better approach would be to have a custom error instead of a revert string, and include the `msg.sig` as an argument to the error.  ```solidity File: contracts/AaveV3YieldSource.sol   #1  337      require(address(_token) != address(aToken), \"AaveV3YS/forbid-aToken-transfer\"); ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L337  ### 9. Unneeded functions The `transferERC20()` function is sufficient for handling unexpected tokens; the increase/decrease allowance functions aren't useful. Approval isn't required for the contract itself to do the transfer when told to do it, but the increase function requires a second operation to actually do the transfer. Even if there is a case where funds can be moved by an existing contract's functionality, that contract might pass along its own token to this contract, starting another issue. The increase/decrease functions just add an extra attack surface and should just be removed.  ```solidity File: contracts/AaveV3YieldSource.sol   #1  315    function increaseERC20Allowance( 316      IERC20 _token, 317      address _spender, 318      uint256 _amount 319    ) external onlyManagerOrOwner { 320      _requireNotAToken(address(_token)); 321      _token.safeIncreaseAllowance(_spender, _amount); 322      emit IncreasedERC20Allowance(msg.sender, _spender, _amount, _token); 323    } 324   325    /** 326     * @notice Transfer ERC20 tokens other than the aTokens held by this contract to the recipient address. 327     * @dev This function is only callable by the owner or asset manager. 328     * @param _token Address of the ERC20 token to transfer 329     * @param _to Address of the recipient of the tokens 330     * @param _amount Amount of tokens to transfer 331     */ 332    function transferERC20( 333      IERC20 _token, 334      address _to, 335      uint256 _amount 336    ) external onlyManagerOrOwner { 337      require(address(_token) != address(aToken), \"AaveV3YS/forbid-aToken-transfer\"); 338      _token.safeTransfer(_to, _amount); 339      emit TransferredERC20(msg.sender, _to, _amount, _token); 340    } ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L315-L340  ### 10. Natspec descriptions incorrect The instances below say that the argument is an `address` but they're in fact all variables of type contract. Internally solidity translates contracts to addresses when passing them to `abi` calls and when emitting events, but the compiler requires the specific user-defined type and errors if a simple address is provided without a cast instead.  ```solidity File: contracts/AaveV3YieldSource.sol   #1  33     * @param aToken Aave aToken address 34     * @param rewardsController Aave rewardsController address 35     * @param poolAddressesProviderRegistry Aave poolAddressesProviderRegistry address ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L33-L35  ```solidity File: contracts/AaveV3YieldSource.sol   #2  87     * @param token Address of the ERC20 token to decrease allowance for ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L87  ```solidity File: contracts/AaveV3YieldSource.sol   #3  101     * @param token Address of the ERC20 token to increase allowance for ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L101  ```solidity File: contracts/AaveV3YieldSource.sol   #4  115     * @param token Address of the ERC20 token transferred ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L115  ```solidity File: contracts/AaveV3YieldSource.sol   #5  126    /// @notice Yield-bearing Aave aToken address. ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L126  ```solidity File: contracts/AaveV3YieldSource.sol   #6  129    /// @notice Aave RewardsController address. ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L129  ```solidity File: contracts/AaveV3YieldSource.sol   #7  132    /// @notice Aave poolAddressesProviderRegistry address. ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L132  ```solidity File: contracts/AaveV3YieldSource.sol   #8  151     * @param _aToken Aave aToken address ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L151  ```solidity File: contracts/AaveV3YieldSource.sol   #9  152     * @param _rewardsController Aave rewardsController address ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L152  ### 11. Event is missing `indexed` fields Each `event` should use three `indexed` fields if there are three or more fields  ```solidity File: contracts/AaveV3YieldSource.sol   #1  41     event AaveV3YieldSourceInitialized( 42       IAToken indexed aToken, 43       IRewardsController rewardsController, 44       IPoolAddressesProviderRegistry poolAddressesProviderRegistry, 45       string name, 46       string symbol, 47       uint8 decimals, 48       address owner 49     ); ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L41-L49  ```solidity File: contracts/AaveV3YieldSource.sol   #2  58     event SuppliedTokenTo(address indexed from, uint256 shares, uint256 amount, address indexed to); ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L58  ```solidity File: contracts/AaveV3YieldSource.sol   #3  66     event RedeemedToken(address indexed from, uint256 shares, uint256 amount); ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L66  ```solidity File: contracts/AaveV3YieldSource.sol   #4  75     event Claimed( 76       address indexed from, 77       address indexed to, 78       address[] rewardsList, 79       uint256[] claimedAmounts 80     ); ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L75-L80  ### 12. Non-exploitable re-entrancies Code should follow the best-practice of [check-effects-interaction](https://blockchain-academy.hs-mittweida.de/courses/solidity-coding-beginners-to-intermediate/lessons/solidity-11-coding-patterns/topic/checks-effects-interactions/)  ``` Reentrancy in AaveV3YieldSource.supplyTokenTo(uint256,address) (contracts/AaveV3YieldSource.sol#231-242):  #1     External calls:     - IERC20(_underlyingAssetAddress).safeTransferFrom(msg.sender,address(this),_depositAmount) (contracts/AaveV3YieldSource.sol#236)     - _pool().supply(_underlyingAssetAddress,_depositAmount,address(this),REFERRAL_CODE) (contracts/AaveV3YieldSource.sol#237)     State variables written after the call(s):     - _mint(_to,_shares) (contracts/AaveV3YieldSource.sol#239)         - _totalSupply += amount (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#262) ```  ``` Reentrancy in AaveV3YieldSource.supplyTokenTo(uint256,address) (contracts/AaveV3YieldSource.sol#231-242):  #2     External calls:     - IERC20(_underlyingAssetAddress).safeTransferFrom(msg.sender,address(this),_depositAmount) (contracts/AaveV3YieldSource.sol#236)     - _pool().supply(_underlyingAssetAddress,_depositAmount,address(this),REFERRAL_CODE) (contracts/AaveV3YieldSource.sol#237)     State variables written after the call(s):     - _mint(_to,_shares) (contracts/AaveV3YieldSource.sol#239)         - _balances[account] += amount (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#263) ```  ``` Reentrancy in AaveV3YieldSource.claimRewards(address) (contracts/AaveV3YieldSource.sol#275-286):  #3     External calls:     - (_rewardsList,_claimedAmounts) = rewardsController.claimAllRewards(_assets,_to) (contracts/AaveV3YieldSource.sol#281-282)     Event emitted after the call(s):     - Claimed(msg.sender,_to,_rewardsList,_claimedAmounts) (contracts/AaveV3YieldSource.sol#284) ```  ``` Reentrancy in AaveV3YieldSource.decreaseERC20Allowance(IERC20,address,uint256) (contracts/AaveV3YieldSource.sol#296-304):  #4     External calls:     - _token.safeDecreaseAllowance(_spender,_amount) (contracts/AaveV3YieldSource.sol#302)     Event emitted after the call(s):     - DecreasedERC20Allowance(msg.sender,_spender,_amount,_token) (contracts/AaveV3YieldSource.sol#303) ```  ``` Reentrancy in AaveV3YieldSource.increaseERC20Allowance(IERC20,address,uint256) (contracts/AaveV3YieldSource.sol#315-323):  #5     External calls:     - _token.safeIncreaseAllowance(_spender,_amount) (contracts/AaveV3YieldSource.sol#321)     Event emitted after the call(s):     - IncreasedERC20Allowance(msg.sender,_spender,_amount,_token) (contracts/AaveV3YieldSource.sol#322) ```  ``` Reentrancy in AaveV3YieldSource.redeemToken(uint256) (contracts/AaveV3YieldSource.sol#251-267):  #6     External calls:     - _pool().withdraw(_underlyingAssetAddress,_redeemAmount,address(this)) (contracts/AaveV3YieldSource.sol#259)     - _assetToken.safeTransfer(msg.sender,_balanceDiff) (contracts/AaveV3YieldSource.sol#263)     Event emitted after the call(s):     - RedeemedToken(msg.sender,_shares,_redeemAmount) (contracts/AaveV3YieldSource.sol#265) ```  ``` Reentrancy in AaveV3YieldSource.supplyTokenTo(uint256,address) (contracts/AaveV3YieldSource.sol#231-242):  #7     External calls:     - IERC20(_underlyingAssetAddress).safeTransferFrom(msg.sender,address(this),_depositAmount) (contracts/AaveV3YieldSource.sol#236)     - _pool().supply(_underlyingAssetAddress,_depositAmount,address(this),REFERRAL_CODE) (contracts/AaveV3YieldSource.sol#237)     Event emitted after the call(s):     - SuppliedTokenTo(msg.sender,_shares,_depositAmount,_to) (contracts/AaveV3YieldSource.sol#241)     - Transfer(address(0),account,amount) (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#264)         - _mint(_to,_shares) (contracts/AaveV3YieldSource.sol#239) ```  ``` Reentrancy in AaveV3YieldSource.transferERC20(IERC20,address,uint256) (contracts/AaveV3YieldSource.sol#332-340):  #8     External calls:     - _token.safeTransfer(_to,_amount) (contracts/AaveV3YieldSource.sol#338)     Event emitted after the call(s):     - TransferredERC20(msg.sender,_to,_amount,_token) (contracts/AaveV3YieldSource.sol#339) ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "### 1. State variables only set in the constructor should be declared `immutable` Avoids a Gsset (20000 gas) in the constructor, and replaces each Gwarmacces (100 gas) with a `PUSH32` (3 gas)  ```solidity File: contracts/AaveV3YieldSource.sol   #1  127     IAToken public aToken; ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L127  ```solidity File: contracts/AaveV3YieldSource.sol   #2  130     IRewardsController public rewardsController; ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L130  ```solidity File: contracts/AaveV3YieldSource.sol   #3  133     IPoolAddressesProviderRegistry public poolAddressesProviderRegistry; ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L133   ```diff diff --git a/AaveV3YieldSource.sol.orig b/AaveV3YieldSource.sol.new index 3975311..1d229ff 100644 --- a/AaveV3YieldSource.sol.orig +++ b/AaveV3YieldSource.sol.new @@ -124,13 +124,13 @@ contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {    /* ============ Variables ============ */      /// @notice Yield-bearing Aave aToken address. -  IAToken public aToken; +  IAToken public immutable aToken;      /// @notice Aave RewardsController address. -  IRewardsController public rewardsController; +  IRewardsController public immutable rewardsController;      /// @notice Aave poolAddressesProviderRegistry address. -  IPoolAddressesProviderRegistry public poolAddressesProviderRegistry; +  IPoolAddressesProviderRegistry public immutable poolAddressesProviderRegistry;      /// @notice ERC20 token decimals.    uint8 private immutable _decimals; ```  ```diff diff --git a/gas.orig b/gas.new index d87edc2..a6cd51d 100644 --- a/gas.orig +++ b/gas.new @@ -5,21 +5,21 @@  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  Contract                  \u00b7  Method                  \u00b7  Min        \u00b7  Max        \u00b7  Avg        \u00b7  # calls      \u00b7  usd (avg)  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV3YieldSourceHarness  \u00b7  claimRewards            \u00b7      54735  \u00b7      56896  \u00b7      55816  \u00b7            4  \u00b7          -  \u2502 +|  AaveV3YieldSourceHarness  \u00b7  claimRewards            \u00b7      50521  \u00b7      52682  \u00b7      51602  \u00b7            4  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV3YieldSourceHarness  \u00b7  decreaseERC20Allowance  \u00b7      37465  \u00b7      39638  \u00b7      38910  \u00b7            3  \u00b7          -  \u2502 +|  AaveV3YieldSourceHarness  \u00b7  decreaseERC20Allowance  \u00b7      35374  \u00b7      37547  \u00b7      36819  \u00b7            3  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV3YieldSourceHarness  \u00b7  increaseERC20Allowance  \u00b7      59133  \u00b7      61618  \u00b7      61212  \u00b7            7  \u00b7          -  \u2502 +|  AaveV3YieldSourceHarness  \u00b7  increaseERC20Allowance  \u00b7      57042  \u00b7      59527  \u00b7      59121  \u00b7            7  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  AaveV3YieldSourceHarness  \u00b7  mint                    \u00b7      51381  \u00b7      68493  \u00b7      61904  \u00b7           13  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV3YieldSourceHarness  \u00b7  redeemToken             \u00b7          -  \u00b7          -  \u00b7     110713  \u00b7            1  \u00b7          -  \u2502 +|  AaveV3YieldSourceHarness  \u00b7  redeemToken             \u00b7          -  \u00b7          -  \u00b7     106359  \u00b7            1  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  AaveV3YieldSourceHarness  \u00b7  setManager              \u00b7          -  \u00b7          -  \u00b7      47982  \u00b7            4  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV3YieldSourceHarness  \u00b7  supplyTokenTo           \u00b7     110668  \u00b7     153720  \u00b7     142217  \u00b7            6  \u00b7          -  \u2502 +|  AaveV3YieldSourceHarness  \u00b7  supplyTokenTo           \u00b7     106314  \u00b7     149466  \u00b7     137930  \u00b7            6  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV3YieldSourceHarness  \u00b7  transferERC20           \u00b7      58318  \u00b7      60467  \u00b7      59393  \u00b7            2  \u00b7          -  \u2502 +|  AaveV3YieldSourceHarness  \u00b7  transferERC20           \u00b7      56227  \u00b7      58376  \u00b7      57302  \u00b7            2  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  ERC20Mintable             \u00b7  approve                 \u00b7      26692  \u00b7      46592  \u00b7      43275  \u00b7            6  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 @@ -29,7 +29,7 @@  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  Deployments                                          \u00b7                                         \u00b7  % of limit   \u00b7             \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV3YieldSourceHarness                             \u00b7    2505760  \u00b7    2505772  \u00b7    2505770  \u00b7        8.4 %  \u00b7          -  \u2502 +|  AaveV3YieldSourceHarness                             \u00b7    2497750  \u00b7    2497762  \u00b7    2497760  \u00b7        8.3 %  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  ERC20Mintable                                        \u00b7          -  \u00b7          -  \u00b7    1154099  \u00b7        3.8 %  \u00b7          -  \u2502  \u00b7-------------------------------------------------------|-------------|-------------|-------------|---------------|-------------\u00b7 ```   ### 2. `internal` functions only called once can be inlined to save gas Not inlining costs 20 to 40 gas because of two extra `JUMP` instructions and additional stack operations needed for function calls.  ```solidity File: contracts/AaveV3YieldSource.sol   #1  369     function _sharesToToken(uint256 _shares) internal view returns (uint256) { ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L369  ```solidity File: contracts/AaveV3YieldSource.sol   #2  388     function _poolProvider() internal view returns (IPoolAddressesProvider) { ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L388  ```diff diff --git a/AaveV3YieldSource.sol.orig b/AaveV3YieldSource.sol.new index 3975311..d7ec7ec 100644 --- a/AaveV3YieldSource.sol.orig +++ b/AaveV3YieldSource.sol.new @@ -201,7 +201,12 @@ contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {     * @return The underlying balance of asset tokens.     */    function balanceOfToken(address _user) external override returns (uint256) { -    return _sharesToToken(balanceOf(_user)); +    uint256 _shares = balanceOf(_user); +    uint256 _supply = totalSupply(); + +    // tokens = (shares * yieldSourceATokenTotalSupply) / totalShares +    return _supply == 0 ? _shares : _shares.mul(aToken.balanceOf(address(this))).div(_supply); +     }      /** @@ -361,18 +366,6 @@ contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {      return _supply == 0 ? _tokens : _tokens.mul(_supply).div(aToken.balanceOf(address(this)));    }   -  /** -   * @notice Calculates the number of asset tokens a user has in the yield source. -   * @param _shares Amount of shares -   * @return Number of asset tokens. -   */ -  function _sharesToToken(uint256 _shares) internal view returns (uint256) { -    uint256 _supply = totalSupply(); - -    // tokens = (shares * yieldSourceATokenTotalSupply) / totalShares -    return _supply == 0 ? _shares : _shares.mul(aToken.balanceOf(address(this))).div(_supply); -  } -    /**     * @notice Returns the underlying asset token address.     * @return Underlying asset token address. @@ -381,22 +374,13 @@ contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {      return aToken.UNDERLYING_ASSET_ADDRESS();    }   -  /** -   * @notice Retrieves Aave PoolAddressesProvider address. -   * @return A reference to PoolAddressesProvider interface. -   */ -  function _poolProvider() internal view returns (IPoolAddressesProvider) { -    return -      IPoolAddressesProvider( -        poolAddressesProviderRegistry.getAddressesProvidersList()[ADDRESSES_PROVIDER_ID] -      ); -  } -    /**     * @notice Retrieves Aave Pool address.     * @return A reference to Pool interface.     */    function _pool() internal view returns (IPool) { -    return IPool(_poolProvider().getPool()); +    return IPool(IPoolAddressesProvider( +        poolAddressesProviderRegistry.getAddressesProvidersList()[ADDRESSES_PROVIDER_ID] +      ).getPool());    }  } ```  ```diff diff --git a/gas.orig b/gas.new index d87edc2..6948266 100644 --- a/gas.orig +++ b/gas.new @@ -13,11 +13,11 @@  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  AaveV3YieldSourceHarness  \u00b7  mint                    \u00b7      51381  \u00b7      68493  \u00b7      61904  \u00b7           13  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV3YieldSourceHarness  \u00b7  redeemToken             \u00b7          -  \u00b7          -  \u00b7     110713  \u00b7            1  \u00b7          -  \u2502 +|  AaveV3YieldSourceHarness  \u00b7  redeemToken             \u00b7          -  \u00b7          -  \u00b7     110678  \u00b7            1  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  AaveV3YieldSourceHarness  \u00b7  setManager              \u00b7          -  \u00b7          -  \u00b7      47982  \u00b7            4  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV3YieldSourceHarness  \u00b7  supplyTokenTo           \u00b7     110668  \u00b7     153720  \u00b7     142217  \u00b7            6  \u00b7          -  \u2502 +|  AaveV3YieldSourceHarness  \u00b7  supplyTokenTo           \u00b7     110633  \u00b7     153685  \u00b7     142182  \u00b7            6  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  AaveV3YieldSourceHarness  \u00b7  transferERC20           \u00b7      58318  \u00b7      60467  \u00b7      59393  \u00b7            2  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 @@ -29,7 +29,7 @@  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  Deployments                                          \u00b7                                         \u00b7  % of limit   \u00b7             \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV3YieldSourceHarness                             \u00b7    2505760  \u00b7    2505772  \u00b7    2505770  \u00b7        8.4 %  \u00b7          -  \u2502 +|  AaveV3YieldSourceHarness                             \u00b7    2559043  \u00b7    2559055  \u00b7    2559053  \u00b7        8.5 %  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  ERC20Mintable                                        \u00b7          -  \u00b7          -  \u00b7    1154099  \u00b7        3.8 %  \u00b7          -  \u2502  \u00b7-------------------------------------------------------|-------------|-------------|-------------|---------------|-------------\u00b7 ``` ### 3. Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement This change saves [6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png) per instance  ```solidity File: contracts/AaveV3YieldSource.sol   #1  179       require(decimals_ > 0, \"AaveV3YS/decimals-gt-zero\"); ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L179  ```solidity File: contracts/AaveV3YieldSource.sol   #2  233       require(_shares > 0, \"AaveV3YS/shares-gt-zero\"); ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L233  ```diff diff --git a/AaveV3YieldSource.sol.orig b/AaveV3YieldSource.sol.new index 3975311..e00ad47 100644 --- a/AaveV3YieldSource.sol.orig +++ b/AaveV3YieldSource.sol.new @@ -176,7 +176,7 @@ contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {        require(_owner != address(0), \"AaveV3YS/owner-not-zero-address\");   -    require(decimals_ > 0, \"AaveV3YS/decimals-gt-zero\"); +    require(decimals_ != 0, \"AaveV3YS/decimals-gt-zero\");      _decimals = decimals_;        // Approve once for max amount @@ -230,7 +230,7 @@ contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {     */    function supplyTokenTo(uint256 _depositAmount, address _to) external override nonReentrant {      uint256 _shares = _tokenToShares(_depositAmount); -    require(_shares > 0, \"AaveV3YS/shares-gt-zero\"); +    require(_shares != 0, \"AaveV3YS/shares-gt-zero\");        address _underlyingAssetAddress = _tokenAddress();      IERC20(_underlyingAssetAddress).safeTransferFrom(msg.sender, address(this), _depositAmount); ```  ```diff diff --git a/gas.orig b/gas.new index d87edc2..9a90ad3 100644 --- a/gas.orig +++ b/gas.new @@ -17,7 +17,7 @@  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  AaveV3YieldSourceHarness  \u00b7  setManager              \u00b7          -  \u00b7          -  \u00b7      47982  \u00b7            4  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV3YieldSourceHarness  \u00b7  supplyTokenTo           \u00b7     110668  \u00b7     153720  \u00b7     142217  \u00b7            6  \u00b7          -  \u2502 +|  AaveV3YieldSourceHarness  \u00b7  supplyTokenTo           \u00b7     110662  \u00b7     153714  \u00b7     142211  \u00b7            6  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  AaveV3YieldSourceHarness  \u00b7  transferERC20           \u00b7      58318  \u00b7      60467  \u00b7      59393  \u00b7            2  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 @@ -29,7 +29,7 @@  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  Deployments                                          \u00b7                                         \u00b7  % of limit   \u00b7             \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  AaveV3YieldSourceHarness                             \u00b7    2505760  \u00b7    2505772  \u00b7    2505770  \u00b7        8.4 %  \u00b7          -  \u2502 +|  AaveV3YieldSourceHarness                             \u00b7    2505106  \u00b7    2505118  \u00b7    2505116  \u00b7        8.4 %  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  ERC20Mintable                                        \u00b7          -  \u00b7          -  \u00b7    1154099  \u00b7        3.8 %  \u00b7          -  \u2502  \u00b7-------------------------------------------------------|-------------|-------------|-------------|---------------|-------------\u00b7 ```  ### 4. Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead > When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.  https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html Use a larger size then downcast where needed  ```solidity File: contracts/AaveV3YieldSource.sol   #1  47       uint8 decimals, ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L47  ```solidity File: contracts/AaveV3YieldSource.sol   #2  136     uint8 private immutable _decimals; ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L136  ```solidity File: contracts/AaveV3YieldSource.sol   #3  145     uint16 private constant REFERRAL_CODE = uint16(188); ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L145  ```solidity File: contracts/AaveV3YieldSource.sol   #4  165       uint8 decimals_, ``` https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L165  ```diff diff --git a/AaveV3YieldSource.sol.orig b/AaveV3YieldSource.sol.new index 3975311..0dfa477 100644 --- a/AaveV3YieldSource.sol.orig +++ b/AaveV3YieldSource.sol.new @@ -44,7 +44,7 @@ contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {      IPoolAddressesProviderRegistry poolAddressesProviderRegistry,      string name,      string symbol, -    uint8 decimals, +    uint256 decimals,      address owner    );   @@ -133,7 +133,7 @@ contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {    IPoolAddressesProviderRegistry public poolAddressesProviderRegistry;      /// @notice ERC20 token decimals. -  uint8 private immutable _decimals; +  uint256 private immutable _decimals;      /**     * @dev Aave genesis market PoolAddressesProvider's ID. @@ -142,7 +142,7 @@ contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {    uint256 private constant ADDRESSES_PROVIDER_ID = uint256(0);      /// @dev PoolTogether's Aave Referral Code -  uint16 private constant REFERRAL_CODE = uint16(188); +  uint256 private constant REFERRAL_CODE = 188;      /* ============ Constructor ============ */   @@ -162,7 +162,7 @@ contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {      IPoolAddressesProviderRegistry _poolAddressesProviderRegistry,      string memory _name,      string memory _symbol, -    uint8 decimals_, +    uint256 decimals_,      address _owner    ) Ownable(_owner) ERC20(_name, _symbol) ReentrancyGuard() {      require(address(_aToken) != address(0), \"AaveV3YS/aToken-not-zero-address\"); @@ -218,7 +218,7 @@ contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {     * @return The number of decimals.     */    function decimals() public view virtual override returns (uint8) { -    return _decimals; +    return uint8(_decimals); "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "Make 3 indexed variables to save gas  https://github.com/pooltogether/aave-v3-yield-source/blob/0f52c5ff27e7c2ef1b32fe2fb12ac16b1bba5e75/contracts/AaveV3YieldSource.sol#L41 https://github.com/pooltogether/aave-v3-yield-source/blob/0f52c5ff27e7c2ef1b32fe2fb12ac16b1bba5e75/contracts/AaveV3YieldSource.sol#L58 https://github.com/pooltogether/aave-v3-yield-source/blob/0f52c5ff27e7c2ef1b32fe2fb12ac16b1bba5e75/contracts/AaveV3YieldSource.sol#L66 https://github.com/pooltogether/aave-v3-yield-source/blob/0f52c5ff27e7c2ef1b32fe2fb12ac16b1bba5e75/contracts/AaveV3YieldSource.sol#L75 "}, {"title": "[WP-H1] A malicious early user/attacker can manipulate the vault's pricePerShare to take an unfair share of future users' deposits", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/44", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "# Lines of code  https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L352-L374   # Vulnerability details  This is a well-known attack vector for new contracts that utilize pricePerShare for accounting.  https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L352-L374  ```solidity   /**    * @notice Calculates the number of shares that should be minted or burnt when a user deposit or withdraw.    * @param _tokens Amount of asset tokens    * @return Number of shares.    */   function _tokenToShares(uint256 _tokens) internal view returns (uint256) {     uint256 _supply = totalSupply();      // shares = (tokens * totalShares) / yieldSourceATokenTotalSupply     return _supply == 0 ? _tokens : _tokens.mul(_supply).div(aToken.balanceOf(address(this)));   }    /**    * @notice Calculates the number of asset tokens a user has in the yield source.    * @param _shares Amount of shares    * @return Number of asset tokens.    */   function _sharesToToken(uint256 _shares) internal view returns (uint256) {     uint256 _supply = totalSupply();      // tokens = (shares * yieldSourceATokenTotalSupply) / totalShares     return _supply == 0 ? _shares : _shares.mul(aToken.balanceOf(address(this))).div(_supply);   } ```  A malicious early user can `supplyTokenTo()` with `1 wei` of `_underlyingAssetAddress` token as the first depositor of the `AaveV3YieldSource.sol`, and get `1 wei` of shares token.  Then the attacker can send `10000e18 - 1` of `aToken` and inflate the price per share from 1.0000 to an extreme value of 1.0000e22 ( from `(1 + 10000e18 - 1) / 1`) .  As a result, the future user who deposits `19999e18` will only receive `1 wei` (from `19999e18 * 1 / 10000e18`) of shares token.  They will immediately lose `9999e18` or half of their deposits if they `redeemToken()` right after the `supplyTokenTo()`.  https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L251-L256  ```solidity   function redeemToken(uint256 _redeemAmount) external override nonReentrant returns (uint256) {     address _underlyingAssetAddress = _tokenAddress();     IERC20 _assetToken = IERC20(_underlyingAssetAddress);      uint256 _shares = _tokenToShares(_redeemAmount);     _burn(msg.sender, _shares);     ... ```  Furthermore, after the PPS has been inflated to an extremely high value (`10000e18`), the attacker can also redeem tokens up to `9999e18` for free, (burn `0` shares) due to the precision loss.  ### Recommendation  Consider requiring a minimal amount of share tokens to be minted for the first minter, and send a port of the initial mints as a reserve to the DAO address so that the pricePerShare can be more resistant to manipulation.  Also, consder adding `require(_shares > 0, \"AaveV3YS/shares-gt-zero\");` before `_burn(msg.sender, _shares);`.  "}, {"title": "User fund loss in supplyTokenTo() because of rounding", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/37", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "# Lines of code  https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L231-L242 https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L357-L362   # Vulnerability details  ## Impact When user use `supplyTokenTo()` to deposit his tokens and get `share` in `FeildSource` because of rounding in division user gets lower amount of `share`. for example if token's `_decimal` was `1` and `totalSupply()` was `1000` and `aToken.balanceOf(FieldSource.address)` was `2100` (becasue of profits in `Aave Pool` `balance` is higher than `supply`), then if user deposit `4` token to the contract with `supplyTokenTo()`, contract is going to `mint` only `1` share for that user and if user calls `YeildToken.balanceOf(user)` the return value is going to be `2` and user already lost half of his deposit. Of course if `_precision ` was high this loss is going to be low enough to ignore but in case of low `_precision` and high price `token` and high `balance / supply` ratio this loss is going to be noticeable.  ## Proof of Concept This is the code of `supplyTokenTo()`: ```   function supplyTokenTo(uint256 _depositAmount, address _to) external override nonReentrant {     uint256 _shares = _tokenToShares(_depositAmount);     require(_shares > 0, \"AaveV3YS/shares-gt-zero\");      address _underlyingAssetAddress = _tokenAddress();     IERC20(_underlyingAssetAddress).safeTransferFrom(msg.sender, address(this), _depositAmount);     _pool().supply(_underlyingAssetAddress, _depositAmount, address(this), REFERRAL_CODE);      _mint(_to, _shares);      emit SuppliedTokenTo(msg.sender, _shares, _depositAmount, _to);   } ``` which in line: `_shares = _tokenToShares(_depositAmount)` trying to calculated `shares` corresponding to the number of tokens supplied. and then transfer `_depositAmount` from user and `mint` shares amount for user. the problem is that if user convert `_shares` to token, he is going to receive lower amount because in most cases: ``` _depositAmount > _sharesToToken(_tokenToShares(_depositAmount)) ``` and that's because of rounding in division. Value of `_shares` is less than _depositAmount. so `YeildSource` should only take part of `_depositAmount` that equals to `_sharesToToken(_tokenToShares(_depositAmount))` and mint `_share` for user.  Of course if `_precision` was high and `aToken.balanceOf(FieldSource.address) / totalSupply()` was low, then this amount will be insignificant, but for some cases it can be harmful for users. for example this conditions: - `_perecision` is low like 1 or 2. - `token` value is very high like BTC. - `aToken.balanceOf(FieldSource.address) / totalSupply()` is high due to manipulation or profit in `Aave pool`.  ## Tools Used VIM  ## Recommended Mitigation Steps To resolve this issue this can be done: ```   function supplyTokenTo(uint256 _depositAmount, address _to) external override nonReentrant {     uint256 _shares = _tokenToShares(_depositAmount);     require(_shares > 0, \"AaveV3YS/shares-gt-zero\");          _depositAmount = _sharesToToken(_shares); // added hero to only take correct amount of user tokens     address _underlyingAssetAddress = _tokenAddress();     IERC20(_underlyingAssetAddress).safeTransferFrom(msg.sender, address(this), _depositAmount);     _pool().supply(_underlyingAssetAddress, _depositAmount, address(this), REFERRAL_CODE);      _mint(_to, _shares);      emit SuppliedTokenTo(msg.sender, _shares, _depositAmount, _to);   } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "**AaveV3YieldSource.sol**  - L136-145 - _decimals which is uint8 would be better than this together with REFERRAL_CODE uint16 , so it takes up less storage space.  - L168.171.174 - In the constructor, it is not necessary to validate if it is zero, since if an interface is set in the input parameters of the signature, it already includes the validation that it is different from zero.  - L235.236.237 - _tokenAddress() is view therefore it does not generate a gas cost, instead the creation of the variable and its use does. It would be best to call _tokenAddress() directly.  - L252.253.259 - _tokenAddress() is view therefore it does not generate a gas cost, instead the creation of the variable and its use does. It would be best to call _tokenAddress() directly.  - L260.262  -  It could be executed like this and it would save creating a variable (_assetToken.balanceOf(address(this))).sub(_beforeBalance);  - L232.239.241 - _tokenToShares() is a view function, so it can be passed as a parameter without creating a local variable, this would reduce the gas by 2000.  - L255.256.265 - _tokenToShares() is a view function, so it can be passed as a parameter without creating a local variable, this would reduce the gas by 2000."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/22", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "# Low Critical ## Use `_balanceDiff` instead of `_redeemAmount` in `RedeemedToken` event: [AaveV3YieldSource.sol#L265](https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L265) `redeemToken()` send user `_balanceDiff` so it's better to emit `RedeemedToken` event with `_balanceDiff` instead of `_redeemAmount`. ### Recommended Mitigation Steps: change: ```solidity emit RedeemedToken(msg.sender, _shares, _redeemAmount); ``` to this: ```solidity emit RedeemedToken(msg.sender, _shares, _balanceDiff); ```  # Non Critical ## `balanceOfToken()` do not write, so it can be restricted to `view` for readability: [AaveV3YieldSource.sol#L203](https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L203) ### Recommended Mitigation Steps: change: ```solidity function balanceOfToken(address _user) external override returns (uint256) { ``` to this: ```solidity function balanceOfToken(address _user) external view override returns (uint256) { ```  ## typos in comments: ### change `inhereted` to `inherited`: ``` AaveV3YieldSource.sol   38,53:    * @param decimals Number of decimals the shares (inhereted ERC20) will ...   156,54:    * @param decimals_ Number of decimals the shares (inhereted ERC20) will ... ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "## Gas1: No need to use safemath library for solidity 0.8.4+ as the compiler itself now checks for overflow/underflow, hence results in lot of gas savings  ## Gas2: prefer `!=` instead of `>` for unsigned integer, saves gas https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L179 https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L233  ## Gas3: uint256 should be preferred, not against readability of code https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L145 https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L136  ## Gas4: no need to increase or decrease allowance if it's approved for max limit,results in lot of gas savings Similar optimizations are used in ERC20 tokens like WETH, The Wrapped Ether (WETH) ERC-20 contract does not update the allowance if it is the max uint.  https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L296 https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L315"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "1. Gas saving using immutable. It's possible to avoid storage access a save gas using `immutable` keyword for the following variables: - `aToken` at [AaveV3YieldSource.sol#L127](https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L127) - `rewardsController` at [AaveV3YieldSource.sol#L130](https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L130) - `poolAddressesProviderRegistry` at [AaveV3YieldSource.sol#L130](https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L133)  2. Remove returns because always returns the same value. - `bool` in [claimRewards](https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L285) "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/4", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L337 Use _requireNotAToken(address(_token)) for consistency across functions"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-pooltogether-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-pooltogether-findings", "body": "https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L127 https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L130 https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L133  The contract variables aToken, rewardsController, poolAddressesProviderRegistry must be immutable to save gas  ``` IAToken public immutable aToken; IRewardsController public immutable rewardsController; IPoolAddressesProviderRegistry public immutable poolAddressesProviderRegistry; ```  extend this report:   If change the aToken should also change the constructor https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L183 ``` - IERC20(_tokenAddress()).safeApprove(address(_pool()), type(uint256).max); + IERC20(_aToken.UNDERLYING_ASSET_ADDRESS()).safeApprove(address(_pool()), type(uint256).max);  ```"}, {"title": "Avoidance of Liquidation Via Malicious Oracle", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/136", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-abranft-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L312-L318   # Vulnerability details  Issue: Arbitrary oracles are permitted on construction of loans, and there is no check that the lender agrees to the used oracle.  Consequences: A borrower who requests a loan with a malicious oracle can avoid legitimate liquidation.  ## Proof of Concept  - Borrower requests loan with an malicious oracle - Lender accepts loan unknowingly - Borrowers's bad oracle is set to never return a liquidating rate on `oracle.get` call. - Lender cannot call `removeCollateral` to liquidate the NFT when it should be allowed, as it will fail the check on [L288](https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L288) - To liquidate the NFT, the lender would have to whitehat along the lines of H-01, by atomically updating to an honest oracle and calling `removeCollateral`.  ## Mitigations  - Add `require(params.oracle == accepted.oracle)` as a condition in `_lend` - Consider only allowing whitelisted oracles, to avoid injection of malicious oracles at the initial loan request stage   "}, {"title": "Mistake while checking LTV to lender accepted LTV", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/55", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-abranft-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-abranft/blob/main/contracts/NFTPairWithOracle.sol#L316   # Vulnerability details  ## Impact It comments in the _lend() function that lender accepted conditions must be at least as good as the borrower is asking for. The line which checks the accepted LTV (lender's LTV) against borrower asking LTV is:                 params.ltvBPS >= accepted.ltvBPS, This means lender should be offering a lower LTV, which must be the opposite way around.  I think this may have the potential to strand the lender, if he enters a lower LTV. For example borrower asking LTV is 86%. However, lender enters his accepted LTV as 80%. lend() will execute with 86% LTV and punish the lender, whereas it should revert and acknowledge the lender that his bid is not good enough.  ## Proof of Concept https://github.com/code-423n4/2022-04-abranft/blob/main/contracts/NFTPairWithOracle.sol#L316  ## Tools Used Manual analysis  ## Recommended Mitigation Steps The condition should be changed as:                 params.ltvBPS <= accepted.ltvBPS,    "}, {"title": "Lender is able to seize the collateral by changing the loan parameters", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/51", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-abranft-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-abranft/blob/main/contracts/NFTPairWithOracle.sol#L198-L223 https://github.com/code-423n4/2022-04-abranft/blob/main/contracts/NFTPairWithOracle.sol#L200-L212 https://github.com/code-423n4/2022-04-abranft/blob/main/contracts/NFTPairWithOracle.sol#L288   # Vulnerability details  ## Impact The lender should only be able to seize the collateral if: - the borrower didn't repay in time - the collateral loses too much of its value  But, the lender is able to seize the collateral at any time by modifying the loan parameters.  ## Proof of Concept The [`updateLoanParams()`](https://github.com/code-423n4/2022-04-abranft/blob/main/contracts/NFTPairWithOracle.sol#L198-L223) allows the lender to modify the parameters of an active loan in favor of the borrower. But, by setting the `ltvBPS` value to `0` they are able to seize the collateral.  If `ltvBPS` is `0` the following require statement in `removeCollateral()` will always be true:  https://github.com/code-423n4/2022-04-abranft/blob/main/contracts/NFTPairWithOracle.sol#L288  `rate * 0 / BPS < amount` is always `true`.  That allows the lender to seize the collateral although its value didn't decrease nor did the time to repay the loan come.  So the required steps are: 1. lend the funds to the borrower 2. call `updateLoanParams()` to set the `ltvBPS` value to `0` 3. call `removeCollateral()` to steal the collateral from the contract  ## Tools Used none  ## Recommended Mitigation Steps Don't allow `updateLoanParams()` to change the `ltvBPS` value.  "}, {"title": "Critical Oracle Manipulation Risk by Lender", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/37", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-abranft-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L286-L288 https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L200-L211   # Vulnerability details  ## Impact  The intended use of the Oracle is to protect the lender from a drop in the borrower's collateral value. If the collateral value goes up significantly and higher than borrowed amount + interest, the lender should not be able to seize the collateral at the expense of the borrower. However, in the `NFTPairWithOracle` contract, the lender could change the Oracle once a loan is outstanding, and therefore seize the collateral at the expense of the borrower, if the actual value of the collateral has increased significantly. This is a critical risk because borrowers asset could be lost to malicious lenders.   ## Proof of Concept  In `NFTPairWithOracle`, the `params` are set by the `borrower` when they call `requestLoan()`, including the Oracle used. Once a lender agrees with the parameters and calls the `lend()` function, the `loan.status` changes to `LOAN_OUTSTANDING`.   Then, the lender can call the `updateLoanParams()` function and pass in its own `params` including the Oracle used. The `require` statement from line 205 to 211 does not check if `params.oracle` and `cur.oracle` are the same. A malicious lender could pass in his own `oracle` after the loan becomes outstanding, and the change would be reflected in line 221.   https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L200-L211  In a situation where the actual value of the collateral has gone up by a lot, exceeding the amount the lender is owed (principal + interest), the lender would have an incentive to seize the collateral. If the Oracle is not tampered with, lender should not be able to do this, because line 288 should fail. But a lender could freely change Oracle once the loan is outstanding, then a tampered Oracle could produce a very low `rate` in line 287 such that line 288 would pass, allowing the lender to seize the collateral, hurting the borrower.   https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L286-L288    ## Tools Used  Manual review  ## Recommended Mitigation Steps  Once a loan is agreed to, the oracle used should not change. I'd recommend adding a check in the `require` statement in line 205 - 211 that `params.oracle == cur.oracle`  "}, {"title": "The return value `success` of the get function of the INFTOracle interface is not checked", "html_url": "https://github.com/code-423n4/2022-04-abranft-findings/issues/21", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-abranft-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/interfaces/INFTOracle.sol#L10-L10   # Vulnerability details  ## Impact ```     function get(address pair, uint256 tokenId) external returns (bool success, uint256 rate); ``` The get function of the INFTOracle interface returns two values, but the success value is not checked when used in the NFTPairWithOracle contract. When success is false, NFTOracle may return stale data.  ## Proof of Concept https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/interfaces/INFTOracle.sol#L10-L10 https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L287-L287 https://github.com/code-423n4/2022-04-abranft/blob/5cd4edc3298c05748e952f8a8c93e42f930a78c2/contracts/NFTPairWithOracle.sol#L321-L321 ## Tools Used None ## Recommended Mitigation Steps ``` (bool success, uint256 rate) = loanParams.oracle.get(address(this), tokenId); require(success); ```  "}, {"title": "Users can use updateBoost function to claim unfairly large rewards from liquidity mining contracts for themselves at cost of other users.", "html_url": "https://github.com/code-423n4/2022-04-mimo-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-mimo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/liquidityMining/v2/PARMinerV2.sol#L159-L165 https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/liquidityMining/v2/GenericMinerV2.sol#L88-L94   # Vulnerability details  ## Impact Users aware of this vulnerability could effectively steal a portion of liquidity mining rewards from honest users.  Affected contracts are: `SupplyMinerV2`, ` DemandMinerV2`, ` PARMinerV2`   `VotingMinerV2` is less affected because locking veMIMO in `votingEscrow`  triggers a call to `releaseMIMO` of this miner contract (which in turn updates user's boost multiplier).   ## Proof of Concept Let's focus here on `SupplyMinerV2`. The exploits for other liquidity mining contracts are analogous.  ### Scenario 1:  Both Alice and Bob deposit 1 WETH to `coreVaults`  and borrow 100 PAR from `coreVaults`. They both have no locked veMIMO.   Now they wait for a month without interacting with the protocol. In the meantime, `SupplyMinerV2` accumulated 100 MIMO for rewards.  Alice locks huge amount of veMIMO in `votingEscrow`, so now her `boostMultiplier`  is 4.  Let's assume that Alice and Bob are the only users of the protocol. Because they borrowed the same amounts of PAR, they should have the same stakes for past month, so a fair reward for each of them (for this past month) should be 50 MIMO. If they simply repay their debts now, 50 MIMO is indeed what they get.  However if Alice calls `supplyMiner.updateBoost(alice)` before repaying her debt, she can claim 80 MIMO and leave only 20 MIMO for Bob. She can basically apply the multiplier 4 to her past stake.  ### Scenario 2:  Both Alice and Bob deposit 1 WETH to `coreVaults`  and borrow 100 PAR from `coreVaults`. Bob locks huge amount of veMIMO in `votingEscrow` for 4 years, so now his `boostMultiplier` is 4.   Alice and Bob wait for 4 years without interacting with the protocol.  `SupplyMinerV2` accumulated 1000 MIMO rewards.   Because of his locked veMIMO, Bob should be able to claim larger reward than Alice. Maybe not 4 times larger but definitely larger.  However, if Alice includes  a transaction with call `supplyMiner.updateBoost(bob)` before Bob's `vaultsCore.repay()` , then she can claim 500 MIMO. She can effectively set Bob's `boostMultiplier` for past 4 years to 1.  ## Tools Used Tested in Foundry  ## Recommended Mitigation Steps I have 2 ideas: 1. Remove `updateBoost` function. There shouldn't be a way to update boost multiplier without claiming rewards and updating `_userInfo.accAmountPerShare` .  So `releaseRewards`  should be sufficient. 2. A better, but also much more difficult solution, would be to redesign boost updates in such a way that distribution of rewards no longer depends on when and how often boost multiplier is updated. If the formula for boost multiplier stays the same, this approach might require calculating integrals of the multiplier as a function of time.  "}, {"title": "Fund loss or theft by attacker with creating a flash loan and setting SuperVault as receiver so executeOperation()  will be get called by lendingPool but with attackers specified params", "html_url": "https://github.com/code-423n4/2022-04-mimo-findings/issues/123", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-mimo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/supervaults/contracts/SuperVault.sol#L76-L99   # Vulnerability details  ## Impact According to Aave documentation, when requesting flash-loan, it's possible to specify a `receiver`, so function `executeOperation()` of that `receiver` will be called by `lendingPool`. https://docs.aave.com/developers/v/2.0/guides/flash-loans In the `SuperVault` there is no check to prevent this attack so attacker can use this and perform  `griefing attack` and make miner contract lose all its funds. or he can create specifically crafted `params` so when `executeOperation()` is called by `lendingPool`, attacker could steal vault's user funds.   ## Proof of Concept To exploit this attacker will do this steps: 1. will call `Aave lendingPool` to get a flash-loan and specify `SuperVault` as `receiver` of flash-loan. and also create a specific `params` that invoke `Operation.REBALANCE` action to change user vault's collateral. 2. `lendingPool` will call `executeOperation()` of `SuperVault` with attacker specified data. 3. `executeOperation()` will check `msg.sender` and will process the function call which will cause some dummy exchanges that will cost user exchange fee and flash-loan fee. 4. attacker will repeat this attack until user losses all his funds. ```   function executeOperation(     address[] calldata assets,     uint256[] calldata amounts,     uint256[] calldata premiums,     address,     bytes calldata params   ) external returns (bool) {     require(msg.sender == address(lendingPool), \"SV002\");     (Operation operation, bytes memory operationParams) = abi.decode(params, (Operation, bytes));     IERC20 asset = IERC20(assets[0]);     uint256 flashloanRepayAmount = amounts[0] + premiums[0];     if (operation == Operation.LEVERAGE) {       leverageOperation(asset, flashloanRepayAmount, operationParams);     }     if (operation == Operation.REBALANCE) {       rebalanceOperation(asset, amounts[0], flashloanRepayAmount, operationParams);     }     if (operation == Operation.EMPTY) {       emptyVaultOperation(asset, amounts[0], flashloanRepayAmount, operationParams);     }      asset.approve(address(lendingPool), flashloanRepayAmount);     return true;   } ```  To steal user fund in `SupperVault` attacker needs more steps. in all these actions (`Operation.REBALANCE`, `Operation.LEVERAGE`, `Operation.EMPTY`) contract will call `aggregatorSwap()` with data that are controlled by attacker. ```   function aggregatorSwap(     uint256 dexIndex,     IERC20 token,     uint256 amount,     bytes memory dexTxData   ) internal {     (address proxy, address router) = _dexAP.dexMapping(dexIndex);     require(proxy != address(0) && router != address(0), \"SV201\");      token.approve(proxy, amount);     router.call(dexTxData);   } ```  Attacker can put special data in `dexTxData` that make contract to do an exchange with bad price. To do this, attacker will create a smart contract that will do this steps: 1. manipulate price in exchange with flash loan. 2. make a call to `executeOperation()` by `Aave flash-loan` with `receiver` and specific `params` so that `SuperVault` will make calls to manipulated exchange for exchanging. 3. do the reverse of #1 and pay the flash-loan and steal the user fund. The details are: Attacker can manipulate swapping pool price with flash-loan, then Attacker will create specific `params` and perform steps 1 to 4. so contract will try to exchange tokens and because of attacker price manipulation and specific `dexTxData`, contract will have bad deals. After that, attacker can reverse the process of swap manipulation and get his  flash-loan tokens and some of `SuperVault` funds and. then pay the flash-loan.  ## Tools Used VIM  ## Recommended Mitigation Steps There should be some state variable which stores the fact that `SuperVault` imitated flash-loan. When contract tries to start flash-loan, it sets the `isFlash` to `True` and `executeOperation()` only accepts calls if `isFlash` is `True`. and after the flash loan code will set `isFlash` to `False.`  "}, {"title": "User can call liquidate() and steal all collateral due to arbitrary router call", "html_url": "https://github.com/code-423n4/2022-04-mimo-findings/issues/83", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-04-mimo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/liquidityMining/v2/PARMinerV2.sol#L126 https://github.com/Uniswap/v2-periphery/blob/2efa12e0f2d808d9b49737927f0e416fafa5af68/contracts/UniswapV2Router02.sol#L299 https://github.com/Uniswap/solidity-lib/blob/c01640b0f0f1d8a85cba8de378cc48469fcfd9a6/contracts/libraries/TransferHelper.sol#L47-L50   # Vulnerability details  ## Impact A malicious user is able to steal all collateral of an unhealthy position in `PARMinerV2.sol`. The code for the `liquidate()` function is written so that the following steps are followed:  - User calls `PARMinerV2.liquidate()` - PARMinerV2 performs the liquidation with `_a.parallel().core().liquidatePartial()` - PARMinerV2 receives the liquidated collateral - An arbitrary router function is called to swap the collateral to PAR - Finally, `PARMinerV2.liquidate()` checks that PARMinerV2's PAR balance is higher than the balance at the beginning of the function call.  The exploit occurs with the arbitrary router call. The malicious user is able to supply the `dexTxnData` parameter which dictates the function call to the router. If the user supplied a function such as UniswapV2Router's `swapExactTokenForETH()`, then control flow will be given to the user, allowing them to perform the exploit.  Note: The Mimo developers have stated that the routers used by the protocol will be DEX Aggregators such as 1inch and Paraswap, but this submission will be referring to UniswapV2Router for simplicity. It can be assumed that the dex aggregators currently allow swapping tokens for ETH.  Continuing the exploit, once the attacker has gained control due to the ETH transfer, they are able to swap the ETH for PAR. Finally, they deposit the PAR with `PARMinerV2.deposit()`. This will cause the final check of `liquidate()` to pass because PARMinerV2's PAR balance will be larger than the start of the liquidation call.  The attacker is able to steal all collateral from every unhealthy position that they liquidate. In the most extreme case, the attacker is able to open their own risky positions with the hope that the position becomes unhealthy. They will borrow the PAR and then liquidate themselves to take back the collateral. Thus effectively stealing PAR.  ## Proof of Concept Steps for exploit:  - Attacker monitors unhealthy positions. Finds a position to liquidate. - Attacker calls `PARMinerV2.liquidate()` - Position liquidated. Collateral transferred back to `PARMinerV2` - In the `liquidate()` function, attacker supplies bytes for `UniswapV2Router.swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)`. For `to`, they supply the attacker contract. - `swapExactTokensForETH()` firstly swaps the collateral for ETH and then transfers the ETH to the user with `TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);` - `TransferHelper.safeTransferETH()` contains a call to the receiver via `(bool success, ) = to.call{value: value}(new bytes(0));` - Therefore, the attacker contract will indeed gain control of execution.  The attacker contract will then perform the following steps:  - Swap the received ETH to PAR. - Deposit the PAR in `PARMinerV2` - Withdraw the deposited PAR.  ## Tools Used Static review.  ## Recommended Mitigation Steps The arbitrary call to the router contracts is risky because of the various functions that they can contain. Perhaps a solution is to only allow certain calls such as swapping tokens to tokens, not ETH. This would require frequently updated knowledge of the router's functions, though would be beneficial for security.   Also, adding a check that the `_totalStake` variable has not increased during the liquidation call will mitigate the risk of the attacker depositing the PAR to increase the contract's balance. The attacker would have no option but to transfer the PAR to PARMinerV2 as is intended.  "}, {"title": "Decimal token underflow could produce loose of funds", "html_url": "https://github.com/code-423n4/2022-04-mimo-findings/issues/55", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-mimo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/oracles/GUniLPOracle.sol#L47 https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/oracles/GUniLPOracle.sol#L51   # Vulnerability details  ## Impact It is possible to produce underflows with specific tokens which can cause errors when calculating prices.  ## Proof of Concept The pragma is `pragma solidity 0.6.12;` therefore, integer overflows must be protected with safe math. But in the case of [GUniLPOracle](https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/oracles/GUniLPOracle.sol#L51), there is a decimal subtraction that could underflow if any token in the pool has more than 18 decimals. this could cause an error when calculating price values.  ## Recommended Mitigation Steps Ensure that tokens have less than 18 decimals.  "}]